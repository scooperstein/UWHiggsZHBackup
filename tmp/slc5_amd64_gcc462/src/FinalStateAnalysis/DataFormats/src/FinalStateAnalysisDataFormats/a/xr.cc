// Generated at Fri Feb 28 12:41:33 2014. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gccxml/20110825/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gccxml/20110825/bin/gccxml_cc1plus"
  GCCXML_CPP="/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gccxml/20110825/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='2' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='1' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.6.2"' -D__UINT64_C(c)='c ## UL' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__GNUC_MINOR__='6' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -iwrapper"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gccxml/20110825/share/gccxml-0.9/GCC/4.6" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../include/c++/4.6.2" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../include/c++/4.6.2/x86_64-unknown-linux-gnu" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../include/c++/4.6.2/backward" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/include" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/include-fixed" -isystem"/usr/local/include" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gccxml/20110825/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.6.2
Copyright (C) 2011 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "/afs/hep.wisc.edu/user/stephane/sync_setup/src/FinalStateAnalysis/DataFormats/src/classes.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("edm") );
  ::Reflex::Type type_88 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_11 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_414 = ::Reflex::TypeBuilder(Reflex::Literal("char"));
  ::Reflex::Type type_539 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_2301 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_251 = ::Reflex::TypeBuilder(Reflex::Literal("short"));
  ::Reflex::Type type_138 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_1261 = ::Reflex::TypeBuilder(Reflex::Literal("float"));
  ::Reflex::Type type_7135 = ::Reflex::TypeBuilder(Reflex::Literal("pat::Tau"));
  ::Reflex::Type type_7094 = ::Reflex::TypeBuilder(Reflex::Literal("pat::Jet"));
  ::Reflex::Type type_6497 = ::Reflex::TypeBuilder(Reflex::Literal("pat::Muon"));
  ::Reflex::Type type_497 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_6478 = ::Reflex::TypeBuilder(Reflex::Literal("pat::Photon"));
  ::Reflex::Type type_466 = ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState"));
  ::Reflex::Type type_484 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_2448 = ::Reflex::TypeBuilder(Reflex::Literal("VBFVariables"));
  ::Reflex::Type type_9665 = ::Reflex::TypeBuilder(Reflex::Literal("edm::EventID"));
  ::Reflex::Type type_9667 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefCore"));
  ::Reflex::Type type_15528 = ::Reflex::TypeBuilder(Reflex::Literal("lhef::HEPEUP"));
  ::Reflex::Type type_2105 = ::Reflex::TypeBuilder(Reflex::Literal("GenFilterInfo"));
  ::Reflex::Type type_690 = ::Reflex::TypeBuilder(Reflex::Literal("std::type_info"));
  ::Reflex::Type type_16644 = ::Reflex::TypeBuilder(Reflex::Literal("reco::Vertex"));
  ::Reflex::Type type_6476 = ::Reflex::TypeBuilder(Reflex::Literal("pat::Electron"));
  ::Reflex::Type type_9664 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ProductID"));
  ::Reflex::Type type_3039 = ::Reflex::TypeBuilder(Reflex::Literal("PATFinalStateLS"));
  ::Reflex::Type type_12204 = ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate"));
  ::Reflex::Type type_1613 = ::Reflex::TypeBuilder(Reflex::Literal("TMatrixT<double>"));
  ::Reflex::Type type_583 = ::Reflex::TypeBuilder(Reflex::Literal("PATFinalStateEvent"));
  ::Reflex::Type type_9783 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<pat::MET>"));
  ::Reflex::Type type_9787 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<pat::Tau>"));
  ::Reflex::Type type_9781 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<pat::Jet>"));
  ::Reflex::Type type_2951 = ::Reflex::TypeBuilder(Reflex::Literal("PATFinalStateProxy"));
  ::Reflex::Type type_19282 = ::Reflex::TypeBuilder(Reflex::Literal("pat::TriggerEvent"));
  ::Reflex::Type type_9562 = ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVectorBase"));
  ::Reflex::Type type_9782 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<pat::Muon>"));
  ::Reflex::Type type_4600 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<double>"));
  ::Reflex::Type type_1176 = ::Reflex::TypeBuilder(Reflex::Literal("GenEventInfoProduct"));
  ::Reflex::Type type_67 = ::Reflex::TypeBuilder(Reflex::Literal("PATMultiCandFinalState"));
  ::Reflex::Type type_9820 = ::Reflex::TypeBuilder(Reflex::Literal("edm::EDProductGetter"));
  ::Reflex::Type type_9786 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<pat::Photon>"));
  ::Reflex::Type type_4641 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::Jet>"));
  ::Reflex::Type type_4671 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::Tau>"));
  ::Reflex::Type type_9920 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefCoreWithIndex"));
  ::Reflex::Type type_9784 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<reco::Vertex>"));
  ::Reflex::Type type_4694 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::Muon>"));
  ::Reflex::Type type_9676 = ::Reflex::TypeBuilder(Reflex::Literal("edm::LuminosityBlockID"));
  ::Reflex::Type type_3906 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_9785 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<pat::Electron>"));
  ::Reflex::Type type_3651 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<PATFinalState>"));
  ::Reflex::Type type_4617 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::Photon>"));
  ::Reflex::Type type_4589 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const void*>"));
  ::Reflex::Type type_9788 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<reco::Candidate>"));
  ::Reflex::Type type_1814 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<PATFinalStateLS>"));
  ::Reflex::Type type_4591 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned int>"));
  ::Reflex::Type type_4590 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long>"));
  ::Reflex::Type type_4715 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<pat::Electron>"));
  ::Reflex::Type type_4595 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATFinalState*>"));
  ::Reflex::Type type_2244 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATFinalStateLS>"));
  ::Reflex::Type type_2414 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<PATFinalStateEvent>"));
  ::Reflex::Type type_8840 = ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVector<reco::Vertex>"));
  ::Reflex::Type type_9237 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATFinalStateLS>"));
  ::Reflex::Type type_480 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATFinalStateEvent>"));
  ::Reflex::Type type_4599 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PileupSummaryInfo>"));
  ::Reflex::Type type_4630 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::PFCandidate>"));
  ::Reflex::Type type_5037 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATFinalState*>"));
  ::Reflex::Type type_4272 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATFinalStateLS>"));
  ::Reflex::Type type_8841 = ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVector<reco::Candidate>"));
  ::Reflex::Type type_9383 = ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVectorItr<reco::Vertex>"));
  ::Reflex::Type type_9906 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ClonePolicy<PATFinalState>"));
  ::Reflex::Type type_5033 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATFinalStateLS>"));
  ::Reflex::Type type_7828 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<PATFinalState>"));
  ::Reflex::Type type_3318 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<PATMultiCandFinalState>"));
  ::Reflex::Type type_6435 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorBase<unsigned int>"));
  ::Reflex::Type type_9239 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATFinalStateEvent>"));
  ::Reflex::Type type_4274 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATFinalStateEvent>"));
  ::Reflex::Type type_5035 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATFinalStateEvent>"));
  ::Reflex::Type type_3002 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATMultiCandFinalState>"));
  ::Reflex::Type type_2873 = ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>"));
  ::Reflex::Type type_4689 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const reco::Candidate*>"));
  ::Reflex::Type type_4075 = ::Reflex::TypeBuilder(Reflex::Literal("std::less<std::basic_string<char> >"));
  ::Reflex::Type type_9669 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefVectorHolderBase"));
  ::Reflex::Type type_9925 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<std::vector<pat::Jet> >"));
  ::Reflex::Type type_9926 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<std::vector<pat::Tau> >"));
  ::Reflex::Type type_334 = ::Reflex::TypeBuilder(Reflex::Literal("PATPairFinalStateT<pat::Tau,pat::Tau>"));
  ::Reflex::Type type_9698 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<pat::Tau> >"));
  ::Reflex::Type type_9697 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<pat::Jet> >"));
  ::Reflex::Type type_9927 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<std::vector<pat::Muon> >"));
  ::Reflex::Type type_9235 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATMultiCandFinalState>"));
  ::Reflex::Type type_288 = ::Reflex::TypeBuilder(Reflex::Literal("PATPairFinalStateT<pat::Muon,pat::Jet>"));
  ::Reflex::Type type_4900 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,int>"));
  ::Reflex::Type type_9699 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<pat::Muon> >"));
  ::Reflex::Type type_4270 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATMultiCandFinalState>"));
  ::Reflex::Type type_1885 = ::Reflex::TypeBuilder(Reflex::Literal("PATPairFinalStateT<pat::Muon,pat::Tau>"));
  ::Reflex::Type type_4465 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,int>"));
  ::Reflex::Type type_9339 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATFinalStateLS>"));
  ::Reflex::Type type_5031 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATMultiCandFinalState>"));
  ::Reflex::Type type_9924 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<std::vector<pat::Photon> >"));
  ::Reflex::Type type_1200 = ::Reflex::TypeBuilder(Reflex::Literal("PATPairFinalStateT<pat::Muon,pat::Muon>"));
  ::Reflex::Type type_4598 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::Ptr<reco::Candidate> >"));
  ::Reflex::Type type_4901 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,float>"));
  ::Reflex::Type type_9696 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<pat::Photon> >"));
  ::Reflex::Type type_9694 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<reco::Track> >"));
  ::Reflex::Type type_9470 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<std::vector<pat::Jet> >"));
  ::Reflex::Type type_9471 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<std::vector<pat::Tau> >"));
  ::Reflex::Type type_4466 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,float>"));
  ::Reflex::Type type_9472 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<std::vector<pat::Muon> >"));
  ::Reflex::Type type_9928 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<std::vector<pat::Electron> >"));
  ::Reflex::Type type_1607 = ::Reflex::TypeBuilder(Reflex::Literal("PATPairFinalStateT<pat::Muon,pat::Photon>"));
  ::Reflex::Type type_9700 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<pat::Electron> >"));
  ::Reflex::Type type_9341 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATFinalStateEvent>"));
  ::Reflex::Type type_9594 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<std::vector<pat::Jet> >"));
  ::Reflex::Type type_9595 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<std::vector<pat::Tau> >"));
  ::Reflex::Type type_1593 = ::Reflex::TypeBuilder(Reflex::Literal("PATPairFinalStateT<pat::Electron,pat::Jet>"));
  ::Reflex::Type type_1887 = ::Reflex::TypeBuilder(Reflex::Literal("PATPairFinalStateT<pat::Electron,pat::Tau>"));
  ::Reflex::Type type_9693 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<reco::GsfTrack> >"));
  ::Reflex::Type type_263 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<PATFinalStateLS> >"));
  ::Reflex::Type type_9932 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<std::vector<PATFinalStateLS> >"));
  ::Reflex::Type type_9469 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<std::vector<pat::Photon> >"));
  ::Reflex::Type type_9596 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<std::vector<pat::Muon> >"));
  ::Reflex::Type type_1155 = ::Reflex::TypeBuilder(Reflex::Literal("PATPairFinalStateT<pat::Photon,pat::Photon>"));
  ::Reflex::Type type_1888 = ::Reflex::TypeBuilder(Reflex::Literal("PATPairFinalStateT<pat::Electron,pat::Muon>"));
  ::Reflex::Type type_9236 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATFinalStateLS> >"));
  ::Reflex::Type type_4467 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const std::basic_string<char>,int>"));
  ::Reflex::Type type_80 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<PATFinalStateEvent> >"));
  ::Reflex::Type type_4271 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATFinalStateLS> >"));
  ::Reflex::Type type_9593 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<std::vector<pat::Photon> >"));
  ::Reflex::Type type_9473 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<std::vector<pat::Electron> >"));
  ::Reflex::Type type_1886 = ::Reflex::TypeBuilder(Reflex::Literal("PATPairFinalStateT<pat::Electron,pat::Photon>"));
  ::Reflex::Type type_9701 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<reco::GenParticle> >"));
  ::Reflex::Type type_9695 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<reco::PFCandidate> >"));
  ::Reflex::Type type_9337 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATMultiCandFinalState>"));
  ::Reflex::Type type_9933 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<std::vector<PATFinalStateEvent> >"));
  ::Reflex::Type type_4468 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const std::basic_string<char>,float>"));
  ::Reflex::Type type_9476 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<std::vector<PATFinalStateLS> >"));
  ::Reflex::Type type_9597 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<std::vector<pat::Electron> >"));
  ::Reflex::Type type_9238 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATFinalStateEvent> >"));
  ::Reflex::Type type_1889 = ::Reflex::TypeBuilder(Reflex::Literal("PATPairFinalStateT<pat::Electron,pat::Electron>"));
  ::Reflex::Type type_4273 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATFinalStateEvent> >"));
  ::Reflex::Type type_9600 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<std::vector<PATFinalStateLS> >"));
  ::Reflex::Type type_634 = ::Reflex::TypeBuilder(Reflex::Literal("PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>"));
  ::Reflex::Type type_9477 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<std::vector<PATFinalStateEvent> >"));
  ::Reflex::Type type_9931 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<std::vector<PATMultiCandFinalState> >"));
  ::Reflex::Type type_1518 = ::Reflex::TypeBuilder(Reflex::Literal("PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>"));
  ::Reflex::Type type_2093 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<PATMultiCandFinalState> >"));
  ::Reflex::Type type_9234 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATMultiCandFinalState> >"));
  ::Reflex::Type type_1519 = ::Reflex::TypeBuilder(Reflex::Literal("PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>"));
  ::Reflex::Type type_3403 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >"));
  ::Reflex::Type type_9601 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<std::vector<PATFinalStateEvent> >"));
  ::Reflex::Type type_4269 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATMultiCandFinalState> >"));
  ::Reflex::Type type_922 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >"));
  ::Reflex::Type type_1051 = ::Reflex::TypeBuilder(Reflex::Literal("PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>"));
  ::Reflex::Type type_1614 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >"));
  ::Reflex::Type type_1869 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >"));
  ::Reflex::Type type_9338 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATFinalStateLS> >"));
  ::Reflex::Type type_9219 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Tau,pat::Tau> >"));
  ::Reflex::Type type_716 = ::Reflex::TypeBuilder(Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>"));
  ::Reflex::Type type_912 = ::Reflex::TypeBuilder(Reflex::Literal("PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>"));
  ::Reflex::Type type_4899 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,edm::Ptr<pat::MET> >"));
  ::Reflex::Type type_9475 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<std::vector<PATMultiCandFinalState> >"));
  ::Reflex::Type type_4254 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATPairFinalStateT<pat::Tau,pat::Tau> >"));
  ::Reflex::Type type_9213 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Jet> >"));
  ::Reflex::Type type_9223 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Tau> >"));
  ::Reflex::Type type_7825 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_5079 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATPairFinalStateT<pat::Tau,pat::Tau> >"));
  ::Reflex::Type type_4248 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATPairFinalStateT<pat::Muon,pat::Jet> >"));
  ::Reflex::Type type_4258 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATPairFinalStateT<pat::Muon,pat::Tau> >"));
  ::Reflex::Type type_9225 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Muon> >"));
  ::Reflex::Type type_444 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >"));
  ::Reflex::Type type_1521 = ::Reflex::TypeBuilder(Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>"));
  ::Reflex::Type type_3550 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >"));
  ::Reflex::Type type_5081 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATPairFinalStateT<pat::Muon,pat::Tau> >"));
  ::Reflex::Type type_5076 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATPairFinalStateT<pat::Muon,pat::Jet> >"));
  ::Reflex::Type type_9599 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<std::vector<PATMultiCandFinalState> >"));
  ::Reflex::Type type_4260 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATPairFinalStateT<pat::Muon,pat::Muon> >"));
  ::Reflex::Type type_9340 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATFinalStateEvent> >"));
  ::Reflex::Type type_552 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >"));
  ::Reflex::Type type_1517 = ::Reflex::TypeBuilder(Reflex::Literal("PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>"));
  ::Reflex::Type type_2858 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >"));
  ::Reflex::Type type_1522 = ::Reflex::TypeBuilder(Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>"));
  ::Reflex::Type type_5082 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATPairFinalStateT<pat::Muon,pat::Muon> >"));
  ::Reflex::Type type_9221 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Photon> >"));
  ::Reflex::Type type_308 = ::Reflex::TypeBuilder(Reflex::Literal("PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>"));
  ::Reflex::Type type_1251 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >"));
  ::Reflex::Type type_1959 = ::Reflex::TypeBuilder(Reflex::Literal("PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>"));
  ::Reflex::Type type_7505 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >"));
  ::Reflex::Type type_4256 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATPairFinalStateT<pat::Muon,pat::Photon> >"));
  ::Reflex::Type type_9211 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Jet> >"));
  ::Reflex::Type type_9229 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Tau> >"));
  ::Reflex::Type type_1520 = ::Reflex::TypeBuilder(Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>"));
  ::Reflex::Type type_5080 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATPairFinalStateT<pat::Muon,pat::Photon> >"));
  ::Reflex::Type type_4246 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATPairFinalStateT<pat::Electron,pat::Jet> >"));
  ::Reflex::Type type_4264 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATPairFinalStateT<pat::Electron,pat::Tau> >"));
  ::Reflex::Type type_9215 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Photon,pat::Photon> >"));
  ::Reflex::Type type_9231 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Muon> >"));
  ::Reflex::Type type_110 = ::Reflex::TypeBuilder(Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>"));
  ::Reflex::Type type_1121 = ::Reflex::TypeBuilder(Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>"));
  ::Reflex::Type type_2440 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >"));
  ::Reflex::Type type_2807 = ::Reflex::TypeBuilder(Reflex::Literal("PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>"));
  ::Reflex::Type type_5075 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATPairFinalStateT<pat::Electron,pat::Jet> >"));
  ::Reflex::Type type_5084 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATPairFinalStateT<pat::Electron,pat::Tau> >"));
  ::Reflex::Type type_4250 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATPairFinalStateT<pat::Photon,pat::Photon> >"));
  ::Reflex::Type type_4266 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATPairFinalStateT<pat::Electron,pat::Muon> >"));
  ::Reflex::Type type_9336 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATMultiCandFinalState> >"));
  ::Reflex::Type type_164 = ::Reflex::TypeBuilder(Reflex::Literal("PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>"));
  ::Reflex::Type type_1523 = ::Reflex::TypeBuilder(Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>"));
  ::Reflex::Type type_4464 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> >"));
  ::Reflex::Type type_5085 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATPairFinalStateT<pat::Electron,pat::Muon> >"));
  ::Reflex::Type type_5077 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATPairFinalStateT<pat::Photon,pat::Photon> >"));
  ::Reflex::Type type_9227 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Photon> >"));
  ::Reflex::Type type_951 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >"));
  ::Reflex::Type type_1022 = ::Reflex::TypeBuilder(Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>"));
  ::Reflex::Type type_1724 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >"));
  ::Reflex::Type type_5039 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const std::basic_string<char>,int> >"));
  ::Reflex::Type type_9321 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATPairFinalStateT<pat::Tau,pat::Tau> >"));
  ::Reflex::Type type_4262 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATPairFinalStateT<pat::Electron,pat::Photon> >"));
  ::Reflex::Type type_113 = ::Reflex::TypeBuilder(Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>"));
  ::Reflex::Type type_1393 = ::Reflex::TypeBuilder(Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>"));
  ::Reflex::Type type_2810 = ::Reflex::TypeBuilder(Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>"));
  ::Reflex::Type type_5083 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATPairFinalStateT<pat::Electron,pat::Photon> >"));
  ::Reflex::Type type_9315 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATPairFinalStateT<pat::Muon,pat::Jet> >"));
  ::Reflex::Type type_9325 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATPairFinalStateT<pat::Muon,pat::Tau> >"));
  ::Reflex::Type type_9233 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Electron> >"));
  ::Reflex::Type type_2525 = ::Reflex::TypeBuilder(Reflex::Literal("PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>"));
  ::Reflex::Type type_5040 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const std::basic_string<char>,float> >"));
  ::Reflex::Type type_9327 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATPairFinalStateT<pat::Muon,pat::Muon> >"));
  ::Reflex::Type type_4268 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATPairFinalStateT<pat::Electron,pat::Electron> >"));
  ::Reflex::Type type_260 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >"));
  ::Reflex::Type type_956 = ::Reflex::TypeBuilder(Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>"));
  ::Reflex::Type type_1524 = ::Reflex::TypeBuilder(Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>"));
  ::Reflex::Type type_1842 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >"));
  ::Reflex::Type type_2938 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >"));
  ::Reflex::Type type_5086 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATPairFinalStateT<pat::Electron,pat::Electron> >"));
  ::Reflex::Type type_762 = ::Reflex::TypeBuilder(Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>"));
  ::Reflex::Type type_2809 = ::Reflex::TypeBuilder(Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>"));
  ::Reflex::Type type_3855 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATFinalState*,std::allocator<PATFinalState*> >"));
  ::Reflex::Type type_9323 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATPairFinalStateT<pat::Muon,pat::Photon> >"));
  ::Reflex::Type type_9181 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >"));
  ::Reflex::Type type_9185 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >"));
  ::Reflex::Type type_803 = ::Reflex::TypeBuilder(Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>"));
  ::Reflex::Type type_2919 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >"));
  ::Reflex::Type type_4216 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >"));
  ::Reflex::Type type_4220 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >"));
  ::Reflex::Type type_9313 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATPairFinalStateT<pat::Electron,pat::Jet> >"));
  ::Reflex::Type type_9331 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATPairFinalStateT<pat::Electron,pat::Tau> >"));
  ::Reflex::Type type_9189 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >"));
  ::Reflex::Type type_9218 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >"));
  ::Reflex::Type type_2808 = ::Reflex::TypeBuilder(Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>"));
  ::Reflex::Type type_5060 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >"));
  ::Reflex::Type type_3732 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATFinalStateLS,std::allocator<PATFinalStateLS> >"));
  ::Reflex::Type type_5062 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >"));
  ::Reflex::Type type_4224 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >"));
  ::Reflex::Type type_9317 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATPairFinalStateT<pat::Photon,pat::Photon> >"));
  ::Reflex::Type type_4253 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >"));
  ::Reflex::Type type_9333 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATPairFinalStateT<pat::Electron,pat::Muon> >"));
  ::Reflex::Type type_9191 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >"));
  ::Reflex::Type type_9212 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >"));
  ::Reflex::Type type_9222 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >"));
  ::Reflex::Type type_891 = ::Reflex::TypeBuilder(Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>"));
  ::Reflex::Type type_1352 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >"));
  ::Reflex::Type type_3061 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >"));
  ::Reflex::Type type_5064 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >"));
  ::Reflex::Type type_4226 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >"));
  ::Reflex::Type type_4247 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >"));
  ::Reflex::Type type_4257 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >"));
  ::Reflex::Type type_9224 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >"));
  ::Reflex::Type type_3537 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >"));
  ::Reflex::Type type_4837 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,int> >"));
  ::Reflex::Type type_5065 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >"));
  ::Reflex::Type type_4259 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >"));
  ::Reflex::Type type_9329 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATPairFinalStateT<pat::Electron,pat::Photon> >"));
  ::Reflex::Type type_9187 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >"));
  ::Reflex::Type type_9195 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >"));
  ::Reflex::Type type_473 = ::Reflex::TypeBuilder(Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>"));
  ::Reflex::Type type_1163 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >"));
  ::Reflex::Type type_2030 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >"));
  ::Reflex::Type type_2562 = ::Reflex::TypeBuilder(Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>"));
  ::Reflex::Type type_4222 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >"));
  ::Reflex::Type type_4230 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >"));
  ::Reflex::Type type_9199 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >"));
  ::Reflex::Type type_9220 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >"));
  ::Reflex::Type type_1605 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >"));
  ::Reflex::Type type_2811 = ::Reflex::TypeBuilder(Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>"));
  ::Reflex::Type type_4838 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,float> >"));
  ::Reflex::Type type_5067 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >"));
  ::Reflex::Type type_5063 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >"));
  ::Reflex::Type type_4234 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >"));
  ::Reflex::Type type_4255 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >"));
  ::Reflex::Type type_9335 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATPairFinalStateT<pat::Electron,pat::Electron> >"));
  ::Reflex::Type type_9183 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >"));
  ::Reflex::Type type_9201 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >"));
  ::Reflex::Type type_9210 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >"));
  ::Reflex::Type type_9228 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >"));
  ::Reflex::Type type_1303 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >"));
  ::Reflex::Type type_3510 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >"));
  ::Reflex::Type type_5069 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >"));
  ::Reflex::Type type_4218 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >"));
  ::Reflex::Type type_4236 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >"));
  ::Reflex::Type type_4245 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >"));
  ::Reflex::Type type_4263 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >"));
  ::Reflex::Type type_9145 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >"));
  ::Reflex::Type type_9214 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >"));
  ::Reflex::Type type_9230 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >"));
  ::Reflex::Type type_1270 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >"));
  ::Reflex::Type type_2311 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >"));
  ::Reflex::Type type_2684 = ::Reflex::TypeBuilder(Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>"));
  ::Reflex::Type type_3857 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATFinalStateEvent,std::allocator<PATFinalStateEvent> >"));
  ::Reflex::Type type_11117 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >::iterator"));
  ::Reflex::Type type_5061 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >"));
  ::Reflex::Type type_5070 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >"));
  ::Reflex::Type type_4180 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >"));
  ::Reflex::Type type_4249 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >"));
  ::Reflex::Type type_4265 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >"));
  ::Reflex::Type type_9149 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >"));
  ::Reflex::Type type_9197 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >"));
  ::Reflex::Type type_505 = ::Reflex::TypeBuilder(Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>"));
  ::Reflex::Type type_1976 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >"));
  ::Reflex::Type type_2880 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >"));
  ::Reflex::Type type_5042 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >"));
  ::Reflex::Type type_4184 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >"));
  ::Reflex::Type type_9283 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >"));
  ::Reflex::Type type_9287 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >"));
  ::Reflex::Type type_4232 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >"));
  ::Reflex::Type type_9151 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >"));
  ::Reflex::Type type_9205 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >"));
  ::Reflex::Type type_9226 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >"));
  ::Reflex::Type type_2341 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >"));
  ::Reflex::Type type_3101 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >"));
  ::Reflex::Type type_17975 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATFinalState**,std::vector<PATFinalState*> >"));
  ::Reflex::Type type_4300 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,int> >"));
  ::Reflex::Type type_5044 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >"));
  ::Reflex::Type type_5068 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >"));
  ::Reflex::Type type_4186 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >"));
  ::Reflex::Type type_9291 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >"));
  ::Reflex::Type type_4240 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >"));
  ::Reflex::Type type_9320 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >"));
  ::Reflex::Type type_4261 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >"));
  ::Reflex::Type type_9193 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >"));
  ::Reflex::Type type_9207 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >"));
  ::Reflex::Type type_1381 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >"));
  ::Reflex::Type type_3132 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >"));
  ::Reflex::Type type_5072 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >"));
  ::Reflex::Type type_5045 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >"));
  ::Reflex::Type type_229 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >"));
  ::Reflex::Type type_9934 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >"));
  ::Reflex::Type type_9293 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >"));
  ::Reflex::Type type_4228 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >"));
  ::Reflex::Type type_4242 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >"));
  ::Reflex::Type type_9314 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >"));
  ::Reflex::Type type_9324 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >"));
  ::Reflex::Type type_9147 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >"));
  ::Reflex::Type type_9155 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >"));
  ::Reflex::Type type_9232 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >"));
  ::Reflex::Type type_2945 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >"));
  ::Reflex::Type type_3307 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >"));
  ::Reflex::Type type_5038 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> > >"));
  ::Reflex::Type type_4301 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,float> >"));
  ::Reflex::Type type_5073 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >"));
  ::Reflex::Type type_14873 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATFinalStateLS*,std::vector<PATFinalStateLS> >"));
  ::Reflex::Type type_5066 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >"));
  ::Reflex::Type type_4182 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >"));
  ::Reflex::Type type_4190 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >"));
  ::Reflex::Type type_9326 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >"));
  ::Reflex::Type type_4267 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >"));
  ::Reflex::Type type_9159 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >"));
  ::Reflex::Type type_9203 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >"));
  ::Reflex::Type type_9240 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >"));
  ::Reflex::Type type_3126 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >"));
  ::Reflex::Type type_5043 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >"));
  ::Reflex::Type type_5047 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >"));
  ::Reflex::Type type_7027 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS>"));
  ::Reflex::Type type_4194 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >"));
  ::Reflex::Type type_9289 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >"));
  ::Reflex::Type type_9297 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >"));
  ::Reflex::Type type_4238 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >"));
  ::Reflex::Type type_4275 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >"));
  ::Reflex::Type type_9143 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >"));
  ::Reflex::Type type_9161 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >"));
  ::Reflex::Type type_556 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >"));
  ::Reflex::Type type_1982 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >"));
  ::Reflex::Type type_2163 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >"));
  ::Reflex::Type type_11118 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >::const_iterator"));
  ::Reflex::Type type_5049 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >"));
  ::Reflex::Type type_5071 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >"));
  ::Reflex::Type type_4178 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >"));
  ::Reflex::Type type_4196 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >"));
  ::Reflex::Type type_9301 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >"));
  ::Reflex::Type type_9322 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >"));
  ::Reflex::Type type_9180 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >"));
  ::Reflex::Type type_9184 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >"));
  ::Reflex::Type type_9209 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >"));
  ::Reflex::Type type_5050 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >"));
  ::Reflex::Type type_5041 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >"));
  ::Reflex::Type type_9478 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >"));
  ::Reflex::Type type_18420 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefToBaseVector<PATFinalState> >"));
  ::Reflex::Type type_4215 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >"));
  ::Reflex::Type type_9285 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >"));
  ::Reflex::Type type_4219 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >"));
  ::Reflex::Type type_9303 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >"));
  ::Reflex::Type type_4244 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >"));
  ::Reflex::Type type_9312 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >"));
  ::Reflex::Type type_9330 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >"));
  ::Reflex::Type type_9157 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >"));
  ::Reflex::Type type_9165 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >"));
  ::Reflex::Type type_9188 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >"));
  ::Reflex::Type type_1852 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >"));
  ::Reflex::Type type_2170 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >"));
  ::Reflex::Type type_17976 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATFinalState* const*,std::vector<PATFinalState*> >"));
  ::Reflex::Type type_3735 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATMultiCandFinalState,std::allocator<PATMultiCandFinalState> >"));
  ::Reflex::Type type_5074 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >"));
  ::Reflex::Type type_9247 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >"));
  ::Reflex::Type type_4192 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >"));
  ::Reflex::Type type_4200 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >"));
  ::Reflex::Type type_4223 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >"));
  ::Reflex::Type type_9316 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >"));
  ::Reflex::Type type_9332 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >"));
  ::Reflex::Type type_9169 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >"));
  ::Reflex::Type type_9190 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >"));
  ::Reflex::Type type_7671 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATFinalStateEvent*,std::vector<PATFinalStateEvent> >"));
  ::Reflex::Type type_5052 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >"));
  ::Reflex::Type type_5048 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >"));
  ::Reflex::Type type_9602 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >"));
  ::Reflex::Type type_14756 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefToBaseVector<PATFinalStateLS> >"));
  ::Reflex::Type type_9251 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >"));
  ::Reflex::Type type_4204 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >"));
  ::Reflex::Type type_4225 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >"));
  ::Reflex::Type type_9299 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >"));
  ::Reflex::Type type_9153 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >"));
  ::Reflex::Type type_9171 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >"));
  ::Reflex::Type type_1850 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >"));
  ::Reflex::Type type_5054 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >"));
  ::Reflex::Type type_14875 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATFinalStateLS*,std::vector<PATFinalStateLS> >"));
  ::Reflex::Type type_9253 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >"));
  ::Reflex::Type type_4188 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >"));
  ::Reflex::Type type_4206 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >"));
  ::Reflex::Type type_9307 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >"));
  ::Reflex::Type type_9328 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >"));
  ::Reflex::Type type_9186 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >"));
  ::Reflex::Type type_9194 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >"));
  ::Reflex::Type type_670 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >"));
  ::Reflex::Type type_3617 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >"));
  ::Reflex::Type type_5046 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >"));
  ::Reflex::Type type_5055 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >"));
  ::Reflex::Type type_6424 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent>"));
  ::Reflex::Type type_4221 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >"));
  ::Reflex::Type type_9295 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >"));
  ::Reflex::Type type_4229 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >"));
  ::Reflex::Type type_9309 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >"));
  ::Reflex::Type type_9167 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >"));
  ::Reflex::Type type_9198 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >"));
  ::Reflex::Type type_3645 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >"));
  ::Reflex::Type type_4836 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> > >"));
  ::Reflex::Type type_4474 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,int> >,bool>"));
  ::Reflex::Type type_18377 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefToBaseVector<PATFinalStateEvent> >"));
  ::Reflex::Type type_9249 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >"));
  ::Reflex::Type type_9257 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >"));
  ::Reflex::Type type_4202 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >"));
  ::Reflex::Type type_4233 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >"));
  ::Reflex::Type type_9334 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >"));
  ::Reflex::Type type_9175 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >"));
  ::Reflex::Type type_9182 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >"));
  ::Reflex::Type type_9200 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >"));
  ::Reflex::Type type_5053 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >"));
  ::Reflex::Type type_9261 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >"));
  ::Reflex::Type type_4210 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >"));
  ::Reflex::Type type_4217 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >"));
  ::Reflex::Type type_4235 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >"));
  ::Reflex::Type type_9305 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >"));
  ::Reflex::Type type_9342 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >"));
  ::Reflex::Type type_9144 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >"));
  ::Reflex::Type type_9163 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >"));
  ::Reflex::Type type_9177 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >"));
  ::Reflex::Type type_2188 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >"));
  ::Reflex::Type type_4477 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,float> >,bool>"));
  ::Reflex::Type type_5057 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >"));
  ::Reflex::Type type_9245 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >"));
  ::Reflex::Type type_4179 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >"));
  ::Reflex::Type type_9263 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >"));
  ::Reflex::Type type_4198 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >"));
  ::Reflex::Type type_4212 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >"));
  ::Reflex::Type type_9148 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >"));
  ::Reflex::Type type_9196 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >"));
  ::Reflex::Type type_7673 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATFinalStateEvent*,std::vector<PATFinalStateEvent> >"));
  ::Reflex::Type type_5051 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >"));
  ::Reflex::Type type_5058 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >"));
  ::Reflex::Type type_4183 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >"));
  ::Reflex::Type type_9282 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >"));
  ::Reflex::Type type_9286 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >"));
  ::Reflex::Type type_4231 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >"));
  ::Reflex::Type type_9311 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >"));
  ::Reflex::Type type_9150 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >"));
  ::Reflex::Type type_9173 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >"));
  ::Reflex::Type type_9204 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >"));
  ::Reflex::Type type_2037 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >"));
  ::Reflex::Type type_15327 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefToBaseVector<PATMultiCandFinalState> >"));
  ::Reflex::Type type_4185 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >"));
  ::Reflex::Type type_9259 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >"));
  ::Reflex::Type type_9267 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >"));
  ::Reflex::Type type_4208 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >"));
  ::Reflex::Type type_9290 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >"));
  ::Reflex::Type type_4239 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >"));
  ::Reflex::Type type_9192 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >"));
  ::Reflex::Type type_9206 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >"));
  ::Reflex::Type type_5056 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >"));
  ::Reflex::Type type_9271 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >"));
  ::Reflex::Type type_9292 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >"));
  ::Reflex::Type type_4227 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >"));
  ::Reflex::Type type_4241 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >"));
  ::Reflex::Type type_9146 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >"));
  ::Reflex::Type type_9154 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >"));
  ::Reflex::Type type_9179 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >"));
  ::Reflex::Type type_4299 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> > >"));
  ::Reflex::Type type_17746 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATMultiCandFinalState*,std::vector<PATMultiCandFinalState> >"));
  ::Reflex::Type type_4181 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >"));
  ::Reflex::Type type_9255 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >"));
  ::Reflex::Type type_4189 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >"));
  ::Reflex::Type type_9273 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >"));
  ::Reflex::Type type_4214 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >"));
  ::Reflex::Type type_9158 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >"));
  ::Reflex::Type type_9202 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >"));
  ::Reflex::Type type_5059 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >"));
  ::Reflex::Type type_4193 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >"));
  ::Reflex::Type type_9288 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >"));
  ::Reflex::Type type_9296 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >"));
  ::Reflex::Type type_4237 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >"));
  ::Reflex::Type type_9142 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >"));
  ::Reflex::Type type_9160 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >"));
  ::Reflex::Type type_5730 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,int> > >"));
  ::Reflex::Type type_14309 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState>"));
  ::Reflex::Type type_4177 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >"));
  ::Reflex::Type type_4195 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >"));
  ::Reflex::Type type_9269 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >"));
  ::Reflex::Type type_9300 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >"));
  ::Reflex::Type type_9208 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >"));
  ::Reflex::Type type_9277 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >"));
  ::Reflex::Type type_9284 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >"));
  ::Reflex::Type type_9302 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >"));
  ::Reflex::Type type_4243 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >"));
  ::Reflex::Type type_9156 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >"));
  ::Reflex::Type type_9164 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >"));
  ::Reflex::Type type_5732 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,float> > >"));
  ::Reflex::Type type_9246 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >"));
  ::Reflex::Type type_4191 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >"));
  ::Reflex::Type type_9265 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >"));
  ::Reflex::Type type_4199 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >"));
  ::Reflex::Type type_9279 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >"));
  ::Reflex::Type type_9168 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >"));
  ::Reflex::Type type_9250 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >"));
  ::Reflex::Type type_4203 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >"));
  ::Reflex::Type type_9298 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >"));
  ::Reflex::Type type_9152 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >"));
  ::Reflex::Type type_9170 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >"));
  ::Reflex::Type type_17747 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATMultiCandFinalState*,std::vector<PATMultiCandFinalState> >"));
  ::Reflex::Type type_9252 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >"));
  ::Reflex::Type type_4187 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >"));
  ::Reflex::Type type_4205 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >"));
  ::Reflex::Type type_9275 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >"));
  ::Reflex::Type type_9306 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >"));
  ::Reflex::Type type_5984 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATFinalState**,std::vector<PATFinalState*> > >"));
  ::Reflex::Type type_9294 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >"));
  ::Reflex::Type type_9308 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >"));
  ::Reflex::Type type_9166 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >"));
  ::Reflex::Type type_5729 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,int> > >"));
  ::Reflex::Type type_9248 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >"));
  ::Reflex::Type type_9256 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >"));
  ::Reflex::Type type_4201 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >"));
  ::Reflex::Type type_9281 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >"));
  ::Reflex::Type type_9174 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >"));
  ::Reflex::Type type_5718 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATFinalStateLS*,std::vector<PATFinalStateLS> > >"));
  ::Reflex::Type type_9260 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >"));
  ::Reflex::Type type_4209 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >"));
  ::Reflex::Type type_9304 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >"));
  ::Reflex::Type type_9162 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >"));
  ::Reflex::Type type_9176 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >"));
  ::Reflex::Type type_4471 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> > >,bool>"));
  ::Reflex::Type type_5731 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,float> > >"));
  ::Reflex::Type type_9244 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >"));
  ::Reflex::Type type_9262 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >"));
  ::Reflex::Type type_4197 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >"));
  ::Reflex::Type type_4211 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >"));
  ::Reflex::Type type_9310 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >"));
  ::Reflex::Type type_9172 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >"));
  ::Reflex::Type type_9258 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >"));
  ::Reflex::Type type_9266 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >"));
  ::Reflex::Type type_4207 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >"));
  ::Reflex::Type type_5983 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATFinalState* const*,std::vector<PATFinalState*> > >"));
  ::Reflex::Type type_9270 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >"));
  ::Reflex::Type type_9178 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >"));
  ::Reflex::Type type_14441 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>"));
  ::Reflex::Type type_9254 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >"));
  ::Reflex::Type type_9272 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >"));
  ::Reflex::Type type_4213 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >"));
  ::Reflex::Type type_5988 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATFinalStateEvent*,std::vector<PATFinalStateEvent> > >"));
  ::Reflex::Type type_5717 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATFinalStateLS*,std::vector<PATFinalStateLS> > >"));
  ::Reflex::Type type_9268 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >"));
  ::Reflex::Type type_9276 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >"));
  ::Reflex::Type type_5726 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> > > >"));
  ::Reflex::Type type_9264 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >"));
  ::Reflex::Type type_9278 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >"));
  ::Reflex::Type type_16267 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState>"));
  ::Reflex::Type type_9274 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >"));
  ::Reflex::Type type_5987 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATFinalStateEvent*,std::vector<PATFinalStateEvent> > >"));
  ::Reflex::Type type_3724 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATPairFinalStateT<pat::Tau,pat::Tau>,std::allocator<PATPairFinalStateT<pat::Tau,pat::Tau> > >"));
  ::Reflex::Type type_9280 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >"));
  ::Reflex::Type type_3726 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATPairFinalStateT<pat::Muon,pat::Tau>,std::allocator<PATPairFinalStateT<pat::Muon,pat::Tau> > >"));
  ::Reflex::Type type_3721 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATPairFinalStateT<pat::Muon,pat::Jet>,std::allocator<PATPairFinalStateT<pat::Muon,pat::Jet> > >"));
  ::Reflex::Type type_5724 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATMultiCandFinalState*,std::vector<PATMultiCandFinalState> > >"));
  ::Reflex::Type type_5725 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> > > >"));
  ::Reflex::Type type_3727 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATPairFinalStateT<pat::Muon,pat::Muon>,std::allocator<PATPairFinalStateT<pat::Muon,pat::Muon> > >"));
  ::Reflex::Type type_5723 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATMultiCandFinalState*,std::vector<PATMultiCandFinalState> > >"));
  ::Reflex::Type type_3725 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATPairFinalStateT<pat::Muon,pat::Photon>,std::allocator<PATPairFinalStateT<pat::Muon,pat::Photon> > >"));
  ::Reflex::Type type_3720 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATPairFinalStateT<pat::Electron,pat::Jet>,std::allocator<PATPairFinalStateT<pat::Electron,pat::Jet> > >"));
  ::Reflex::Type type_3729 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATPairFinalStateT<pat::Electron,pat::Tau>,std::allocator<PATPairFinalStateT<pat::Electron,pat::Tau> > >"));
  ::Reflex::Type type_17738 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Tau,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >"));
  ::Reflex::Type type_3730 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATPairFinalStateT<pat::Electron,pat::Muon>,std::allocator<PATPairFinalStateT<pat::Electron,pat::Muon> > >"));
  ::Reflex::Type type_3722 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATPairFinalStateT<pat::Photon,pat::Photon>,std::allocator<PATPairFinalStateT<pat::Photon,pat::Photon> > >"));
  ::Reflex::Type type_12952 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >"));
  ::Reflex::Type type_13623 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Jet>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >"));
  ::Reflex::Type type_10930 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Muon>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >"));
  ::Reflex::Type type_3728 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATPairFinalStateT<pat::Electron,pat::Photon>,std::allocator<PATPairFinalStateT<pat::Electron,pat::Photon> > >"));
  ::Reflex::Type type_17739 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Tau,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >"));
  ::Reflex::Type type_12954 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Muon,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >"));
  ::Reflex::Type type_13625 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Muon,pat::Jet>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >"));
  ::Reflex::Type type_17740 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >"));
  ::Reflex::Type type_7357 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Jet>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >"));
  ::Reflex::Type type_10932 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Muon,pat::Muon>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >"));
  ::Reflex::Type type_3731 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATPairFinalStateT<pat::Electron,pat::Electron>,std::allocator<PATPairFinalStateT<pat::Electron,pat::Electron> > >"));
  ::Reflex::Type type_16848 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >"));
  ::Reflex::Type type_8500 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Muon>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >"));
  ::Reflex::Type type_11784 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Photon,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >"));
  ::Reflex::Type type_2230 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >"));
  ::Reflex::Type type_17741 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Muon,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >"));
  ::Reflex::Type type_7359 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Electron,pat::Jet>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >"));
  ::Reflex::Type type_3705 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>,std::allocator<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >"));
  ::Reflex::Type type_15473 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >"));
  ::Reflex::Type type_16850 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Electron,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >"));
  ::Reflex::Type type_3707 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >"));
  ::Reflex::Type type_8502 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Electron,pat::Muon>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >"));
  ::Reflex::Type type_277 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >"));
  ::Reflex::Type type_3709 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >"));
  ::Reflex::Type type_11786 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Photon,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >"));
  ::Reflex::Type type_9821 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<reco::GenParticle>,reco::GenParticle,edm::refhelper::FindUsingAdvance<std::vector<reco::GenParticle>,reco::GenParticle> >"));
  ::Reflex::Type type_13128 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Electron>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >"));
  ::Reflex::Type type_3710 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>,std::allocator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >"));
  ::Reflex::Type type_15475 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Electron,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >"));
  ::Reflex::Type type_5702 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Tau,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > > >"));
  ::Reflex::Type type_3712 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >"));
  ::Reflex::Type type_3708 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >"));
  ::Reflex::Type type_3065 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >"));
  ::Reflex::Type type_5706 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > > >"));
  ::Reflex::Type type_5696 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Jet>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > > >"));
  ::Reflex::Type type_13130 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Electron,pat::Electron>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >"));
  ::Reflex::Type type_13381 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >"));
  ::Reflex::Type type_17252 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >"));
  ::Reflex::Type type_3714 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >"));
  ::Reflex::Type type_7029 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorIterator<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >"));
  ::Reflex::Type type_6939 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >"));
  ::Reflex::Type type_5708 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Muon>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > > >"));
  ::Reflex::Type type_3706 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >"));
  ::Reflex::Type type_3715 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >"));
  ::Reflex::Type type_96 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >"));
  ::Reflex::Type type_4473 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,int> >,std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,int> > >"));
  ::Reflex::Type type_5701 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Tau,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > > >"));
  ::Reflex::Type type_3687 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >"));
  ::Reflex::Type type_17185 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >"));
  ::Reflex::Type type_5705 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Muon,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > > >"));
  ::Reflex::Type type_5695 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Muon,pat::Jet>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > > >"));
  ::Reflex::Type type_5704 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > > >"));
  ::Reflex::Type type_3689 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >"));
  ::Reflex::Type type_13383 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >"));
  ::Reflex::Type type_17254 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >"));
  ::Reflex::Type type_3713 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >"));
  ::Reflex::Type type_4476 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,float> >,std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,float> > >"));
  ::Reflex::Type type_6941 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >"));
  ::Reflex::Type type_5694 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Jet>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > > >"));
  ::Reflex::Type type_5707 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Muon,pat::Muon>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > > >"));
  ::Reflex::Type type_5712 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > > >"));
  ::Reflex::Type type_3717 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >"));
  ::Reflex::Type type_12068 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >"));
  ::Reflex::Type type_3690 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>,std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >"));
  ::Reflex::Type type_17728 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >"));
  ::Reflex::Type type_5714 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Muon>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > > >"));
  ::Reflex::Type type_5698 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Photon,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > > >"));
  ::Reflex::Type type_3718 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >"));
  ::Reflex::Type type_3711 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >"));
  ::Reflex::Type type_17187 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >"));
  ::Reflex::Type type_17732 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >"));
  ::Reflex::Type type_5703 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Muon,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > > >"));
  ::Reflex::Type type_11573 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >"));
  ::Reflex::Type type_14183 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >"));
  ::Reflex::Type type_3688 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >"));
  ::Reflex::Type type_3692 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >"));
  ::Reflex::Type type_6426 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorIterator<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >"));
  ::Reflex::Type type_5693 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Electron,pat::Jet>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > > >"));
  ::Reflex::Type type_5710 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > > >"));
  ::Reflex::Type type_5711 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Electron,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > > >"));
  ::Reflex::Type type_12070 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >"));
  ::Reflex::Type type_3694 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >"));
  ::Reflex::Type type_12758 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >"));
  ::Reflex::Type type_17729 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >"));
  ::Reflex::Type type_3716 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >"));
  ::Reflex::Type type_2399 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >"));
  ::Reflex::Type type_4472 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,int> >,std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,int> > >"));
  ::Reflex::Type type_5713 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Electron,pat::Muon>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > > >"));
  ::Reflex::Type type_5697 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Photon,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > > >"));
  ::Reflex::Type type_11959 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >"));
  ::Reflex::Type type_3695 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >"));
  ::Reflex::Type type_3686 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >"));
  ::Reflex::Type type_17730 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >"));
  ::Reflex::Type type_17733 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >"));
  ::Reflex::Type type_5716 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Electron>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > > >"));
  ::Reflex::Type type_11575 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >"));
  ::Reflex::Type type_11873 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >"));
  ::Reflex::Type type_14185 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >"));
  ::Reflex::Type type_15103 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >"));
  ::Reflex::Type type_3719 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >"));
  ::Reflex::Type type_4475 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,float> >,std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,float> > >"));
  ::Reflex::Type type_5709 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Electron,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > > >"));
  ::Reflex::Type type_12760 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >"));
  ::Reflex::Type type_13944 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >"));
  ::Reflex::Type type_3697 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >"));
  ::Reflex::Type type_3693 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >"));
  ::Reflex::Type type_17035 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >"));
  ::Reflex::Type type_2057 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >"));
  ::Reflex::Type type_3699 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >"));
  ::Reflex::Type type_11961 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >"));
  ::Reflex::Type type_15241 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >"));
  ::Reflex::Type type_17722 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >"));
  ::Reflex::Type type_17731 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >"));
  ::Reflex::Type type_5715 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Electron,pat::Electron>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > > >"));
  ::Reflex::Type type_5664 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > > >"));
  ::Reflex::Type type_5668 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > > >"));
  ::Reflex::Type type_11875 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >"));
  ::Reflex::Type type_12148 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >"));
  ::Reflex::Type type_3691 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >"));
  ::Reflex::Type type_3700 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >"));
  ::Reflex::Type type_15105 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >"));
  ::Reflex::Type type_17734 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >"));
  ::Reflex::Type type_5672 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > > >"));
  ::Reflex::Type type_13946 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >"));
  ::Reflex::Type type_17037 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >"));
  ::Reflex::Type type_17319 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >"));
  ::Reflex::Type type_17720 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >"));
  ::Reflex::Type type_5674 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > > >"));
  ::Reflex::Type type_3698 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >"));
  ::Reflex::Type type_15243 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >"));
  ::Reflex::Type type_17723 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >"));
  ::Reflex::Type type_17736 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >"));
  ::Reflex::Type type_8775 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorIterator<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >"));
  ::Reflex::Type type_5663 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > > >"));
  ::Reflex::Type type_5667 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > > >"));
  ::Reflex::Type type_12150 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >"));
  ::Reflex::Type type_14049 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >"));
  ::Reflex::Type type_14502 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >"));
  ::Reflex::Type type_17735 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >"));
  ::Reflex::Type type_3702 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >"));
  ::Reflex::Type type_5671 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > > >"));
  ::Reflex::Type type_8567 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >"));
  ::Reflex::Type type_5678 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > > >"));
  ::Reflex::Type type_5670 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > > >"));
  ::Reflex::Type type_3696 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >"));
  ::Reflex::Type type_17321 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >"));
  ::Reflex::Type type_17721 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >"));
  ::Reflex::Type type_3703 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >"));
  ::Reflex::Type type_5673 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > > >"));
  ::Reflex::Type type_5682 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > > >"));
  ::Reflex::Type type_13515 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >"));
  ::Reflex::Type type_14569 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >"));
  ::Reflex::Type type_17737 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >"));
  ::Reflex::Type type_4470 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> > >,std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> > > >"));
  ::Reflex::Type type_5666 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > > >"));
  ::Reflex::Type type_5684 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > > >"));
  ::Reflex::Type type_14051 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >"));
  ::Reflex::Type type_14504 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >"));
  ::Reflex::Type type_3701 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >"));
  ::Reflex::Type type_8569 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >"));
  ::Reflex::Type type_5677 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > > >"));
  ::Reflex::Type type_5628 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > > >"));
  ::Reflex::Type type_5669 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > > >"));
  ::Reflex::Type type_14754 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> > >"));
  ::Reflex::Type type_13448 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >"));
  ::Reflex::Type type_5632 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > > >"));
  ::Reflex::Type type_5680 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > > >"));
  ::Reflex::Type type_5681 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > > >"));
  ::Reflex::Type type_13517 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >"));
  ::Reflex::Type type_3704 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >"));
  ::Reflex::Type type_14571 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >"));
  ::Reflex::Type type_17724 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >"));
  ::Reflex::Type type_5665 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > > >"));
  ::Reflex::Type type_5688 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > > >"));
  ::Reflex::Type type_5683 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > > >"));
  ::Reflex::Type type_5634 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > > >"));
  ::Reflex::Type type_10033 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >"));
  ::Reflex::Type type_17726 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >"));
  ::Reflex::Type type_5627 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > > >"));
  ::Reflex::Type type_5690 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > > >"));
  ::Reflex::Type type_5676 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > > >"));
  ::Reflex::Type type_13450 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >"));
  ::Reflex::Type type_5631 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > > >"));
  ::Reflex::Type type_5630 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > > >"));
  ::Reflex::Type type_5638 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > > >"));
  ::Reflex::Type type_5679 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > > >"));
  ::Reflex::Type type_14664 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >"));
  ::Reflex::Type type_17725 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >"));
  ::Reflex::Type type_4469 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> > >,std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> > > >"));
  ::Reflex::Type type_5687 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > > >"));
  ::Reflex::Type type_5642 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > > >"));
  ::Reflex::Type type_5633 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > > >"));
  ::Reflex::Type type_5686 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > > >"));
  ::Reflex::Type type_10035 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >"));
  ::Reflex::Type type_17727 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >"));
  ::Reflex::Type type_5689 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > > >"));
  ::Reflex::Type type_5675 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > > >"));
  ::Reflex::Type type_5644 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > > >"));
  ::Reflex::Type type_5626 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > > >"));
  ::Reflex::Type type_18375 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> > >"));
  ::Reflex::Type type_14250 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >"));
  ::Reflex::Type type_3090 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >"));
  ::Reflex::Type type_5629 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > > >"));
  ::Reflex::Type type_5637 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > > >"));
  ::Reflex::Type type_5692 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > > >"));
  ::Reflex::Type type_14666 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >"));
  ::Reflex::Type type_5641 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > > >"));
  ::Reflex::Type type_5648 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > > >"));
  ::Reflex::Type type_5640 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > > >"));
  ::Reflex::Type type_5685 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > > >"));
  ::Reflex::Type type_5652 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > > >"));
  ::Reflex::Type type_5643 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > > >"));
  ::Reflex::Type type_5625 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > > >"));
  ::Reflex::Type type_14252 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >"));
  ::Reflex::Type type_2787 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >"));
  ::Reflex::Type type_5636 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > > >"));
  ::Reflex::Type type_5654 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > > >"));
  ::Reflex::Type type_5691 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > > >"));
  ::Reflex::Type type_5647 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > > >"));
  ::Reflex::Type type_5639 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > > >"));
  ::Reflex::Type type_5651 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > > >"));
  ::Reflex::Type type_5650 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > > >"));
  ::Reflex::Type type_5635 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > > >"));
  ::Reflex::Type type_5653 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > > >"));
  ::Reflex::Type type_5658 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > > >"));
  ::Reflex::Type type_8776 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorIterator<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >"));
  ::Reflex::Type type_5646 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > > >"));
  ::Reflex::Type type_5660 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > > >"));
  ::Reflex::Type type_15325 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> > >"));
  ::Reflex::Type type_5649 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > > >"));
  ::Reflex::Type type_5656 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > > >"));
  ::Reflex::Type type_5657 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > > >"));
  ::Reflex::Type type_5645 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > > >"));
  ::Reflex::Type type_5659 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > > >"));
  ::Reflex::Type type_5662 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > > >"));
  ::Reflex::Type type_5655 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > > >"));
  ::Reflex::Type type_5661 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > > >"));
  ::Reflex::Type type_4117 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<std::basic_string<char>,std::pair<const std::basic_string<char>,int>,std::_Select1st<std::pair<const std::basic_string<char>,int> >,std::less<std::basic_string<char> >,std::allocator<std::pair<const std::basic_string<char>,int> > >"));
  ::Reflex::Type type_18418 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> > >"));
  ::Reflex::Type type_4118 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<std::basic_string<char>,std::pair<const std::basic_string<char>,float>,std::_Select1st<std::pair<const std::basic_string<char>,float> >,std::less<std::basic_string<char> >,std::allocator<std::pair<const std::basic_string<char>,float> > >"));
  ::Reflex::Type type_4116 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<std::basic_string<char>,std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> >,std::_Select1st<std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> > >,std::less<std::basic_string<char> >,std::allocator<std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> > > >"));
  ::Reflex::Type type_111 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecPhoPhoFinalState"), type_110);
  ::Reflex::Type type_114 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecMuMuMuFinalState"), type_113);
  ::Reflex::Type type_165 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATMuMuMuPhoFinalState"), type_164);
  ::Reflex::Type type_261 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATMuMuTauFinalStateCollection"), type_260);
  ::Reflex::Type type_289 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATMuJetFinalState"), type_288);
  ::Reflex::Type type_309 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATMuMuMuTauFinalState"), type_308);
  ::Reflex::Type type_335 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATTauTauFinalState"), type_334);
  ::Reflex::Type type_445 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecJetFinalStateCollection"), type_444);
  ::Reflex::Type type_474 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecElecPhoPhoFinalState"), type_473);
  ::Reflex::Type type_481 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATFinalStateEventCollection"), type_480);
  ::Reflex::Type type_506 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecElecElecElecFinalState"), type_505);
  ::Reflex::Type type_553 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecMuFinalStateCollection"), type_552);
  ::Reflex::Type type_557 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecElecMuTauFinalStateCollection"), type_556);
  ::Reflex::Type type_635 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATMuJetJetFinalState"), type_634);
  ::Reflex::Type type_671 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecElecPhoPhoFinalStateCollection"), type_670);
  ::Reflex::Type type_717 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecTauTauFinalState"), type_716);
  ::Reflex::Type type_763 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecElecMuTauFinalState"), type_762);
  ::Reflex::Type type_804 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecElecMuMuFinalState"), type_803);
  ::Reflex::Type type_892 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecElecMuPhoFinalState"), type_891);
  ::Reflex::Type type_913 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATMuMuPhoFinalState"), type_912);
  ::Reflex::Type type_923 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATMuMuFinalStateCollection"), type_922);
  ::Reflex::Type type_952 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATFinalStateCollection"), type_951);
  ::Reflex::Type type_957 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecElecTauTauFinalState"), type_956);
  ::Reflex::Type type_1023 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecMuTauTauFinalState"), type_1022);
  ::Reflex::Type type_1052 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATMuMuMuFinalState"), type_1051);
  ::Reflex::Type type_1122 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecElecTauFinalState"), type_1121);
  ::Reflex::Type type_1156 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATPhoPhoFinalState"), type_1155);
  ::Reflex::Type type_1164 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATMuPhoPhoFinalStateCollection"), type_1163);
  ::Reflex::Type type_1201 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATMuMuFinalState"), type_1200);
  ::Reflex::Type type_1252 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATPhoPhoFinalStateCollection"), type_1251);
  ::Reflex::Type type_1271 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecElecTauFinalStateCollection"), type_1270);
  ::Reflex::Type type_1304 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATMuMuMuTauFinalStateCollection"), type_1303);
  ::Reflex::Type type_1353 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecTauTauFinalStateCollection"), type_1352);
  ::Reflex::Type type_1382 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecMuMuTauFinalStateCollection"), type_1381);
  ::Reflex::Type type_1394 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecElecPhoFinalState"), type_1393);
  ::Reflex::Type type_1549 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATMuPhoPhoFinalState"), type_1517);
  ::Reflex::Type type_1594 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecJetFinalState"), type_1593);
  ::Reflex::Type type_1606 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATMuMuTauTauFinalStateCollection"), type_1605);
  ::Reflex::Type type_1608 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATMuPhoFinalState"), type_1607);
  ::Reflex::Type type_1615 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATMuTauFinalStateCollection"), type_1614);
  ::Reflex::Type type_1638 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecMuTauFinalState"), type_1521);
  ::Reflex::Type type_1725 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecElecFinalStateCollection"), type_1724);
  ::Reflex::Type type_1822 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecMuPhoFinalState"), type_1520);
  ::Reflex::Type type_1832 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecElecElecFinalState"), type_1524);
  ::Reflex::Type type_1843 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATMuJetJetFinalStateCollection"), type_1842);
  ::Reflex::Type type_1851 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecElecMuPhoFinalStateCollection"), type_1850);
  ::Reflex::Type type_1853 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecMuPhoPhoFinalStateCollection"), type_1852);
  ::Reflex::Type type_1870 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATMuJetFinalStateCollection"), type_1869);
  ::Reflex::Type type_1960 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATMuMuTauTauFinalState"), type_1959);
  ::Reflex::Type type_1977 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecElecMuFinalStateCollection"), type_1976);
  ::Reflex::Type type_1983 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecElecTauTauFinalStateCollection"), type_1982);
  ::Reflex::Type type_2031 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecMuMuFinalStateCollection"), type_2030);
  ::Reflex::Type type_2038 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecElecElecElecFinalStateCollection"), type_2037);
  ::Reflex::Type type_2164 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecMuMuPhoFinalStateCollection"), type_2163);
  ::Reflex::Type type_2171 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecElecMuMuFinalStateCollection"), type_2170);
  ::Reflex::Type type_2189 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecElecElecPhoFinalStateCollection"), type_2188);
  ::Reflex::Type type_2245 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATFinalStateLSCollection"), type_2244);
  ::Reflex::Type type_2312 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATMuMuMuMuFinalStateCollection"), type_2311);
  ::Reflex::Type type_2342 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATMuMuMuPhoFinalStateCollection"), type_2341);
  ::Reflex::Type type_2425 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATMuTauTauFinalState"), type_1518);
  ::Reflex::Type type_2441 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecPhoFinalStateCollection"), type_2440);
  ::Reflex::Type type_2466 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATMuMuTauFinalState"), type_1519);
  ::Reflex::Type type_2489 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecMuFinalState"), type_1888);
  ::Reflex::Type type_2500 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecElecFinalState"), type_1889);
  ::Reflex::Type type_2526 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATMuMuPhoPhoFinalState"), type_2525);
  ::Reflex::Type type_2563 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecElecElecTauFinalState"), type_2562);
  ::Reflex::Type type_2685 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecElecElecPhoFinalState"), type_2684);
  ::Reflex::Type type_2812 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecMuMuPhoFinalState"), type_2809);
  ::Reflex::Type type_2837 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecElecMuFinalState"), type_1523);
  ::Reflex::Type type_2859 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecTauFinalStateCollection"), type_2858);
  ::Reflex::Type type_2881 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecPhoPhoFinalStateCollection"), type_2880);
  ::Reflex::Type type_2920 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATMuMuMuFinalStateCollection"), type_2919);
  ::Reflex::Type type_2937 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecTauFinalState"), type_1887);
  ::Reflex::Type type_2939 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATMuTauTauFinalStateCollection"), type_2938);
  ::Reflex::Type type_2946 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecMuMuMuFinalStateCollection"), type_2945);
  ::Reflex::Type type_3003 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATMultiCandFinalStateCollection"), type_3002);
  ::Reflex::Type type_3017 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecElecElecMuFinalState"), type_2811);
  ::Reflex::Type type_3054 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecPhoFinalState"), type_1886);
  ::Reflex::Type type_3062 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATMuMuPhoFinalStateCollection"), type_3061);
  ::Reflex::Type type_3079 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATMuMuMuMuFinalState"), type_2807);
  ::Reflex::Type type_3102 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecMuTauTauFinalStateCollection"), type_3101);
  ::Reflex::Type type_3115 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecMuPhoPhoFinalState"), type_2808);
  ::Reflex::Type type_3121 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATMuTauFinalState"), type_1885);
  ::Reflex::Type type_3127 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecElecElecFinalStateCollection"), type_3126);
  ::Reflex::Type type_3133 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecElecPhoFinalStateCollection"), type_3132);
  ::Reflex::Type type_3181 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecMuMuFinalState"), type_1522);
  ::Reflex::Type type_3308 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATMuMuPhoPhoFinalStateCollection"), type_3307);
  ::Reflex::Type type_3404 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATTauTauFinalStateCollection"), type_3403);
  ::Reflex::Type type_3445 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecMuMuTauFinalState"), type_2810);
  ::Reflex::Type type_3511 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecMuPhoFinalStateCollection"), type_3510);
  ::Reflex::Type type_3538 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecMuTauFinalStateCollection"), type_3537);
  ::Reflex::Type type_3551 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATMuPhoFinalStateCollection"), type_3550);
  ::Reflex::Type type_3618 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecElecElecTauFinalStateCollection"), type_3617);
  ::Reflex::Type type_3646 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PATElecElecElecMuFinalStateCollection"), type_3645);
  ::Reflex::Type type_18148 = ::Reflex::ReferenceBuilder(type_67);
  ::Reflex::Type type_67c = ::Reflex::ConstBuilder(type_67);
  ::Reflex::Type type_18150 = ::Reflex::ReferenceBuilder(type_67c);
  ::Reflex::Type type_4598c = ::Reflex::ConstBuilder(type_4598);
  ::Reflex::Type type_45405 = ::Reflex::ReferenceBuilder(type_4598c);
  ::Reflex::Type type_2414c = ::Reflex::ConstBuilder(type_2414);
  ::Reflex::Type type_45406 = ::Reflex::ReferenceBuilder(type_2414c);
  ::Reflex::Type type_18144 = ::Reflex::PointerBuilder(type_67);
  ::Reflex::Type type_12204c = ::Reflex::ConstBuilder(type_12204);
  ::Reflex::Type type_45407 = ::Reflex::PointerBuilder(type_12204c);
  ::Reflex::Type type_3148 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("size_t"), type_484);
  ::Reflex::Type type_16736 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::CandidatePtr"), type_9788);
  ::Reflex::Type type_16736c = ::Reflex::ConstBuilder(type_16736);
  ::Reflex::Type type_3907 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::string"), type_3906);
  ::Reflex::Type type_3907c = ::Reflex::ConstBuilder(type_3907);
  ::Reflex::Type type_6741 = ::Reflex::ReferenceBuilder(type_3907c);
  ::Reflex::Type type_16637 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::CandidatePtrVector"), type_8841);
  ::Reflex::Type type_16637c = ::Reflex::ConstBuilder(type_16637);
  ::Reflex::Type type_45409 = ::Reflex::ReferenceBuilder(type_16637c);
  ::Reflex::Type type_138c = ::Reflex::ConstBuilder(type_138);
  ::Reflex::Type type_14428 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("math::XYZTLorentzVectorD"), type_7505);
  ::Reflex::Type type_14477 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("math::XYZTLorentzVector"), type_14428);
  ::Reflex::Type type_11112 = ::Reflex::ReferenceBuilder(type_466);
  ::Reflex::Type type_466c = ::Reflex::ConstBuilder(type_466);
  ::Reflex::Type type_11114 = ::Reflex::ReferenceBuilder(type_466c);
  ::Reflex::Type type_9783c = ::Reflex::ConstBuilder(type_9783);
  ::Reflex::Type type_46447 = ::Reflex::ReferenceBuilder(type_9783c);
  ::Reflex::Type type_9784c = ::Reflex::ConstBuilder(type_9784);
  ::Reflex::Type type_46448 = ::Reflex::ReferenceBuilder(type_9784c);
  ::Reflex::Type type_11110 = ::Reflex::PointerBuilder(type_466);
  ::Reflex::Type type_14477c = ::Reflex::ConstBuilder(type_14477);
  ::Reflex::Type type_13680 = ::Reflex::ReferenceBuilder(type_14477c);
  ::Reflex::Type type_88c = ::Reflex::ConstBuilder(type_88);
  ::Reflex::Type type_16442 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::GenParticleRef"), type_9821);
  ::Reflex::Type type_16442c = ::Reflex::ConstBuilder(type_16442);
  ::Reflex::Type type_2301c = ::Reflex::ConstBuilder(type_2301);
  ::Reflex::Type type_14442 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("math::XYZVectorD"), type_14441);
  ::Reflex::Type type_14476 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("math::XYZVector"), type_14442);
  ::Reflex::Type type_14476c = ::Reflex::ConstBuilder(type_14476);
  ::Reflex::Type type_1261c = ::Reflex::ConstBuilder(type_1261);
  ::Reflex::Type type_3064 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("TMatrixD"), type_1613);
  ::Reflex::Type type_16497 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::GenParticleRefProd"), type_9701);
  ::Reflex::Type type_16531 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::PFCandidateRefProd"), type_9695);
  ::Reflex::Type type_16438 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::TrackRefProd"), type_9694);
  ::Reflex::Type type_16457 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::GsfTrackRefProd"), type_9693);
  ::Reflex::Type type_7667 = ::Reflex::ReferenceBuilder(type_583);
  ::Reflex::Type type_583c = ::Reflex::ConstBuilder(type_583);
  ::Reflex::Type type_7669 = ::Reflex::ReferenceBuilder(type_583c);
  ::Reflex::Type type_8840c = ::Reflex::ConstBuilder(type_8840);
  ::Reflex::Type type_50680 = ::Reflex::ReferenceBuilder(type_8840c);
  ::Reflex::Type type_3064c = ::Reflex::ConstBuilder(type_3064);
  ::Reflex::Type type_50681 = ::Reflex::ReferenceBuilder(type_3064c);
  ::Reflex::Type type_19282c = ::Reflex::ConstBuilder(type_19282);
  ::Reflex::Type type_50682 = ::Reflex::ReferenceBuilder(type_19282c);
  ::Reflex::Type type_4599c = ::Reflex::ConstBuilder(type_4599);
  ::Reflex::Type type_50683 = ::Reflex::ReferenceBuilder(type_4599c);
  ::Reflex::Type type_15528c = ::Reflex::ConstBuilder(type_15528);
  ::Reflex::Type type_50684 = ::Reflex::ReferenceBuilder(type_15528c);
  ::Reflex::Type type_16497c = ::Reflex::ConstBuilder(type_16497);
  ::Reflex::Type type_50685 = ::Reflex::ReferenceBuilder(type_16497c);
  ::Reflex::Type type_9665c = ::Reflex::ConstBuilder(type_9665);
  ::Reflex::Type type_29100 = ::Reflex::ReferenceBuilder(type_9665c);
  ::Reflex::Type type_1176c = ::Reflex::ConstBuilder(type_1176);
  ::Reflex::Type type_50686 = ::Reflex::ReferenceBuilder(type_1176c);
  ::Reflex::Type type_2105c = ::Reflex::ConstBuilder(type_2105);
  ::Reflex::Type type_50687 = ::Reflex::ReferenceBuilder(type_2105c);
  ::Reflex::Type type_9700c = ::Reflex::ConstBuilder(type_9700);
  ::Reflex::Type type_50688 = ::Reflex::ReferenceBuilder(type_9700c);
  ::Reflex::Type type_9699c = ::Reflex::ConstBuilder(type_9699);
  ::Reflex::Type type_50689 = ::Reflex::ReferenceBuilder(type_9699c);
  ::Reflex::Type type_9698c = ::Reflex::ConstBuilder(type_9698);
  ::Reflex::Type type_50690 = ::Reflex::ReferenceBuilder(type_9698c);
  ::Reflex::Type type_9697c = ::Reflex::ConstBuilder(type_9697);
  ::Reflex::Type type_50691 = ::Reflex::ReferenceBuilder(type_9697c);
  ::Reflex::Type type_9696c = ::Reflex::ConstBuilder(type_9696);
  ::Reflex::Type type_50692 = ::Reflex::ReferenceBuilder(type_9696c);
  ::Reflex::Type type_16531c = ::Reflex::ConstBuilder(type_16531);
  ::Reflex::Type type_50693 = ::Reflex::ReferenceBuilder(type_16531c);
  ::Reflex::Type type_16438c = ::Reflex::ConstBuilder(type_16438);
  ::Reflex::Type type_50694 = ::Reflex::ReferenceBuilder(type_16438c);
  ::Reflex::Type type_16457c = ::Reflex::ConstBuilder(type_16457);
  ::Reflex::Type type_50695 = ::Reflex::ReferenceBuilder(type_16457c);
  ::Reflex::Type type_4899c = ::Reflex::ConstBuilder(type_4899);
  ::Reflex::Type type_50696 = ::Reflex::ReferenceBuilder(type_4899c);
  ::Reflex::Type type_50698 = ::Reflex::ReferenceBuilder(type_12204c);
  ::Reflex::Type type_19249 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::ElectronCollection"), type_4715);
  ::Reflex::Type type_19249c = ::Reflex::ConstBuilder(type_19249);
  ::Reflex::Type type_50699 = ::Reflex::ReferenceBuilder(type_19249c);
  ::Reflex::Type type_19242 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::MuonCollection"), type_4694);
  ::Reflex::Type type_19242c = ::Reflex::ConstBuilder(type_19242);
  ::Reflex::Type type_50700 = ::Reflex::ReferenceBuilder(type_19242c);
  ::Reflex::Type type_19265 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::JetCollection"), type_4641);
  ::Reflex::Type type_19265c = ::Reflex::ConstBuilder(type_19265);
  ::Reflex::Type type_50701 = ::Reflex::ReferenceBuilder(type_19265c);
  ::Reflex::Type type_19287 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::TauCollection"), type_4671);
  ::Reflex::Type type_19287c = ::Reflex::ConstBuilder(type_19287);
  ::Reflex::Type type_50702 = ::Reflex::ReferenceBuilder(type_19287c);
  ::Reflex::Type type_19210 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("pat::PhotonCollection"), type_4617);
  ::Reflex::Type type_19210c = ::Reflex::ConstBuilder(type_19210);
  ::Reflex::Type type_50703 = ::Reflex::ReferenceBuilder(type_19210c);
  ::Reflex::Type type_16649 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::PFCandidateCollection"), type_4630);
  ::Reflex::Type type_16649c = ::Reflex::ConstBuilder(type_16649);
  ::Reflex::Type type_50704 = ::Reflex::ReferenceBuilder(type_16649c);
  ::Reflex::Type type_14869 = ::Reflex::ReferenceBuilder(type_3039);
  ::Reflex::Type type_3039c = ::Reflex::ConstBuilder(type_3039);
  ::Reflex::Type type_14871 = ::Reflex::ReferenceBuilder(type_3039c);
  ::Reflex::Type type_9676c = ::Reflex::ConstBuilder(type_9676);
  ::Reflex::Type type_54976 = ::Reflex::ReferenceBuilder(type_9676c);
  ::Reflex::Type type_60200 = ::Reflex::ReferenceBuilder(type_1814);
  ::Reflex::Type type_1814c = ::Reflex::ConstBuilder(type_1814);
  ::Reflex::Type type_60201 = ::Reflex::ReferenceBuilder(type_1814c);
  ::Reflex::Type type_9664c = ::Reflex::ConstBuilder(type_9664);
  ::Reflex::Type type_45417 = ::Reflex::ReferenceBuilder(type_9664c);
  ::Reflex::Type type_9820c = ::Reflex::ConstBuilder(type_9820);
  ::Reflex::Type type_45418 = ::Reflex::PointerBuilder(type_9820c);
  ::Reflex::Type type_14867 = ::Reflex::PointerBuilder(type_3039c);
  ::Reflex::Type type_9667c = ::Reflex::ConstBuilder(type_9667);
  ::Reflex::Type type_45420 = ::Reflex::ReferenceBuilder(type_9667c);
  ::Reflex::Type type_539c = ::Reflex::ConstBuilder(type_539);
  ::Reflex::Type type_6842 = ::Reflex::PointerBuilder(type_539c);
  ::Reflex::Type type_60878 = ::Reflex::ReferenceBuilder(type_2414);
  ::Reflex::Type type_7665 = ::Reflex::PointerBuilder(type_583c);
  ::Reflex::Type type_60925 = ::Reflex::ReferenceBuilder(type_2448);
  ::Reflex::Type type_2448c = ::Reflex::ConstBuilder(type_2448);
  ::Reflex::Type type_60926 = ::Reflex::ReferenceBuilder(type_2448c);
  ::Reflex::Type type_63848 = ::Reflex::ReferenceBuilder(type_2951);
  ::Reflex::Type type_2951c = ::Reflex::ConstBuilder(type_2951);
  ::Reflex::Type type_63849 = ::Reflex::ReferenceBuilder(type_2951c);
  ::Reflex::Type type_47165 = ::Reflex::PointerBuilder(type_466c);
  ::Reflex::Type type_70722 = ::Reflex::ReferenceBuilder(type_3318);
  ::Reflex::Type type_3318c = ::Reflex::ConstBuilder(type_3318);
  ::Reflex::Type type_60859 = ::Reflex::ReferenceBuilder(type_3318c);
  ::Reflex::Type type_18146 = ::Reflex::PointerBuilder(type_67c);
  ::Reflex::Type type_72490 = ::Reflex::ReferenceBuilder(type_3651);
  ::Reflex::Type type_3651c = ::Reflex::ConstBuilder(type_3651);
  ::Reflex::Type type_72181 = ::Reflex::ReferenceBuilder(type_3651c);
  ::Reflex::Type type_75756 = ::Reflex::ReferenceBuilder(type_4465);
  ::Reflex::Type type_4465c = ::Reflex::ConstBuilder(type_4465);
  ::Reflex::Type type_75757 = ::Reflex::ReferenceBuilder(type_4465c);
  ::Reflex::Type type_3906c = ::Reflex::ConstBuilder(type_3906);
  ::Reflex::Type type_24234 = ::Reflex::ReferenceBuilder(type_3906c);
  ::Reflex::Type type_24190 = ::Reflex::ReferenceBuilder(type_88c);
  ::Reflex::Type type_31287 = ::Reflex::ReferenceBuilder(type_4466);
  ::Reflex::Type type_4466c = ::Reflex::ConstBuilder(type_4466);
  ::Reflex::Type type_31289 = ::Reflex::ReferenceBuilder(type_4466c);
  ::Reflex::Type type_14349 = ::Reflex::ReferenceBuilder(type_1261c);
  ::Reflex::Type type_28456 = ::Reflex::PointerBuilder(type_11110);
  ::Reflex::Type type_11110c = ::Reflex::ConstBuilder(type_11110);
  ::Reflex::Type type_28458 = ::Reflex::PointerBuilder(type_11110c);
  ::Reflex::Type type_28460 = ::Reflex::ReferenceBuilder(type_11110);
  ::Reflex::Type type_28462 = ::Reflex::ReferenceBuilder(type_11110c);
  ::Reflex::Type type_5015 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_484);
  ::Reflex::Type type_4878 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_11);
  ::Reflex::Type type_5037c = ::Reflex::ConstBuilder(type_5037);
  ::Reflex::Type type_74533 = ::Reflex::ReferenceBuilder(type_5037c);
  ::Reflex::Type type_4595c = ::Reflex::ConstBuilder(type_4595);
  ::Reflex::Type type_59600 = ::Reflex::ReferenceBuilder(type_4595c);
  ::Reflex::Type type_75802 = ::Reflex::ReferenceBuilder(type_4595);
  ::Reflex::Type type_25233 = ::Reflex::PointerBuilder(type_4464);
  ::Reflex::Type type_4464c = ::Reflex::ConstBuilder(type_4464);
  ::Reflex::Type type_25235 = ::Reflex::PointerBuilder(type_4464c);
  ::Reflex::Type type_25237 = ::Reflex::ReferenceBuilder(type_4464);
  ::Reflex::Type type_25239 = ::Reflex::ReferenceBuilder(type_4464c);
  ::Reflex::Type type_4075c = ::Reflex::ConstBuilder(type_4075);
  ::Reflex::Type type_75365 = ::Reflex::ReferenceBuilder(type_4075c);
  ::Reflex::Type type_5038c = ::Reflex::ConstBuilder(type_5038);
  ::Reflex::Type type_75452 = ::Reflex::ReferenceBuilder(type_5038c);
  ::Reflex::Type type_76388 = ::Reflex::ReferenceBuilder(type_4899);
  ::Reflex::Type type_76389 = ::Reflex::ReferenceBuilder(type_9783);
  ::Reflex::Type type_25338 = ::Reflex::PointerBuilder(type_4467);
  ::Reflex::Type type_4467c = ::Reflex::ConstBuilder(type_4467);
  ::Reflex::Type type_25340 = ::Reflex::PointerBuilder(type_4467c);
  ::Reflex::Type type_25342 = ::Reflex::ReferenceBuilder(type_4467);
  ::Reflex::Type type_25344 = ::Reflex::ReferenceBuilder(type_4467c);
  ::Reflex::Type type_5039c = ::Reflex::ConstBuilder(type_5039);
  ::Reflex::Type type_75459 = ::Reflex::ReferenceBuilder(type_5039c);
  ::Reflex::Type type_4900c = ::Reflex::ConstBuilder(type_4900);
  ::Reflex::Type type_76390 = ::Reflex::ReferenceBuilder(type_4900c);
  ::Reflex::Type type_76391 = ::Reflex::ReferenceBuilder(type_4900);
  ::Reflex::Type type_24179 = ::Reflex::ReferenceBuilder(type_88);
  ::Reflex::Type type_25443 = ::Reflex::PointerBuilder(type_4468);
  ::Reflex::Type type_4468c = ::Reflex::ConstBuilder(type_4468);
  ::Reflex::Type type_25445 = ::Reflex::PointerBuilder(type_4468c);
  ::Reflex::Type type_25447 = ::Reflex::ReferenceBuilder(type_4468);
  ::Reflex::Type type_25449 = ::Reflex::ReferenceBuilder(type_4468c);
  ::Reflex::Type type_5040c = ::Reflex::ConstBuilder(type_5040);
  ::Reflex::Type type_75466 = ::Reflex::ReferenceBuilder(type_5040c);
  ::Reflex::Type type_4901c = ::Reflex::ConstBuilder(type_4901);
  ::Reflex::Type type_76392 = ::Reflex::ReferenceBuilder(type_4901c);
  ::Reflex::Type type_76393 = ::Reflex::ReferenceBuilder(type_4901);
  ::Reflex::Type type_29162 = ::Reflex::ReferenceBuilder(type_1261);
  ::Reflex::Type type_484c = ::Reflex::ConstBuilder(type_484);
  ::Reflex::Type type_84809 = ::Reflex::ReferenceBuilder(type_8840);
  ::Reflex::Type type_45461 = ::Reflex::ReferenceBuilder(type_4589);
  ::Reflex::Type type_690c = ::Reflex::ConstBuilder(type_690);
  ::Reflex::Type type_8743 = ::Reflex::ReferenceBuilder(type_690c);
  ::Reflex::Type type_9337c = ::Reflex::ConstBuilder(type_9337);
  ::Reflex::Type type_85374 = ::Reflex::PointerBuilder(type_9337c);
  ::Reflex::Type type_77636 = ::Reflex::ReferenceBuilder(type_7825);
  ::Reflex::Type type_24201 = ::Reflex::ReferenceBuilder(type_6842);
  ::Reflex::Type type_4590c = ::Reflex::ConstBuilder(type_4590);
  ::Reflex::Type type_59093 = ::Reflex::ReferenceBuilder(type_4590c);
  ::Reflex::Type type_14865 = ::Reflex::PointerBuilder(type_3039);
  ::Reflex::Type type_9339c = ::Reflex::ConstBuilder(type_9339);
  ::Reflex::Type type_85381 = ::Reflex::PointerBuilder(type_9339c);
  ::Reflex::Type type_7663 = ::Reflex::PointerBuilder(type_583);
  ::Reflex::Type type_9341c = ::Reflex::ConstBuilder(type_9341);
  ::Reflex::Type type_85388 = ::Reflex::PointerBuilder(type_9341c);
  ::Reflex::Type type_85747 = ::Reflex::ReferenceBuilder(type_9784);
  ::Reflex::Type type_16644c = ::Reflex::ConstBuilder(type_16644);
  ::Reflex::Type type_32584 = ::Reflex::PointerBuilder(type_16644c);
  ::Reflex::Type type_32588 = ::Reflex::ReferenceBuilder(type_16644c);
  ::Reflex::Type type_85749 = ::Reflex::ReferenceBuilder(type_9786);
  ::Reflex::Type type_9786c = ::Reflex::ConstBuilder(type_9786);
  ::Reflex::Type type_45637 = ::Reflex::ReferenceBuilder(type_9786c);
  ::Reflex::Type type_6478c = ::Reflex::ConstBuilder(type_6478);
  ::Reflex::Type type_29862 = ::Reflex::PointerBuilder(type_6478c);
  ::Reflex::Type type_29866 = ::Reflex::ReferenceBuilder(type_6478c);
  ::Reflex::Type type_17031 = ::Reflex::ReferenceBuilder(type_110);
  ::Reflex::Type type_110c = ::Reflex::ConstBuilder(type_110);
  ::Reflex::Type type_17033 = ::Reflex::ReferenceBuilder(type_110c);
  ::Reflex::Type type_9785c = ::Reflex::ConstBuilder(type_9785);
  ::Reflex::Type type_45636 = ::Reflex::ReferenceBuilder(type_9785c);
  ::Reflex::Type type_17027 = ::Reflex::PointerBuilder(type_110);
  ::Reflex::Type type_9788c = ::Reflex::ConstBuilder(type_9788);
  ::Reflex::Type type_8841c = ::Reflex::ConstBuilder(type_8841);
  ::Reflex::Type type_29484 = ::Reflex::ReferenceBuilder(type_8841c);
  ::Reflex::Type type_17315 = ::Reflex::ReferenceBuilder(type_113);
  ::Reflex::Type type_113c = ::Reflex::ConstBuilder(type_113);
  ::Reflex::Type type_17317 = ::Reflex::ReferenceBuilder(type_113c);
  ::Reflex::Type type_9782c = ::Reflex::ConstBuilder(type_9782);
  ::Reflex::Type type_45727 = ::Reflex::ReferenceBuilder(type_9782c);
  ::Reflex::Type type_17311 = ::Reflex::PointerBuilder(type_113);
  ::Reflex::Type type_15237 = ::Reflex::ReferenceBuilder(type_164);
  ::Reflex::Type type_164c = ::Reflex::ConstBuilder(type_164);
  ::Reflex::Type type_15239 = ::Reflex::ReferenceBuilder(type_164c);
  ::Reflex::Type type_15233 = ::Reflex::PointerBuilder(type_164);
  ::Reflex::Type type_6935 = ::Reflex::ReferenceBuilder(type_1519);
  ::Reflex::Type type_1519c = ::Reflex::ConstBuilder(type_1519);
  ::Reflex::Type type_6937 = ::Reflex::ReferenceBuilder(type_1519c);
  ::Reflex::Type type_9787c = ::Reflex::ConstBuilder(type_9787);
  ::Reflex::Type type_46321 = ::Reflex::ReferenceBuilder(type_9787c);
  ::Reflex::Type type_6931 = ::Reflex::PointerBuilder(type_1519);
  ::Reflex::Type type_6933 = ::Reflex::PointerBuilder(type_1519c);
  ::Reflex::Type type_5064c = ::Reflex::ConstBuilder(type_5064);
  ::Reflex::Type type_45944 = ::Reflex::ReferenceBuilder(type_5064c);
  ::Reflex::Type type_260c = ::Reflex::ConstBuilder(type_260);
  ::Reflex::Type type_45945 = ::Reflex::ReferenceBuilder(type_260c);
  ::Reflex::Type type_45946 = ::Reflex::ReferenceBuilder(type_260);
  ::Reflex::Type type_13619 = ::Reflex::ReferenceBuilder(type_288);
  ::Reflex::Type type_288c = ::Reflex::ConstBuilder(type_288);
  ::Reflex::Type type_13621 = ::Reflex::ReferenceBuilder(type_288c);
  ::Reflex::Type type_9781c = ::Reflex::ConstBuilder(type_9781);
  ::Reflex::Type type_46161 = ::Reflex::ReferenceBuilder(type_9781c);
  ::Reflex::Type type_13615 = ::Reflex::PointerBuilder(type_288);
  ::Reflex::Type type_11955 = ::Reflex::ReferenceBuilder(type_308);
  ::Reflex::Type type_308c = ::Reflex::ConstBuilder(type_308);
  ::Reflex::Type type_11957 = ::Reflex::ReferenceBuilder(type_308c);
  ::Reflex::Type type_11951 = ::Reflex::PointerBuilder(type_308);
  ::Reflex::Type type_19147 = ::Reflex::ReferenceBuilder(type_334);
  ::Reflex::Type type_334c = ::Reflex::ConstBuilder(type_334);
  ::Reflex::Type type_19149 = ::Reflex::ReferenceBuilder(type_334c);
  ::Reflex::Type type_19143 = ::Reflex::PointerBuilder(type_334);
  ::Reflex::Type type_7353 = ::Reflex::ReferenceBuilder(type_1593);
  ::Reflex::Type type_1593c = ::Reflex::ConstBuilder(type_1593);
  ::Reflex::Type type_7355 = ::Reflex::ReferenceBuilder(type_1593c);
  ::Reflex::Type type_7349 = ::Reflex::PointerBuilder(type_1593);
  ::Reflex::Type type_7351 = ::Reflex::PointerBuilder(type_1593c);
  ::Reflex::Type type_5075c = ::Reflex::ConstBuilder(type_5075);
  ::Reflex::Type type_46348 = ::Reflex::ReferenceBuilder(type_5075c);
  ::Reflex::Type type_444c = ::Reflex::ConstBuilder(type_444);
  ::Reflex::Type type_46349 = ::Reflex::ReferenceBuilder(type_444c);
  ::Reflex::Type type_46350 = ::Reflex::ReferenceBuilder(type_444);
  ::Reflex::Type type_10029 = ::Reflex::ReferenceBuilder(type_473);
  ::Reflex::Type type_473c = ::Reflex::ConstBuilder(type_473);
  ::Reflex::Type type_10031 = ::Reflex::ReferenceBuilder(type_473c);
  ::Reflex::Type type_10025 = ::Reflex::PointerBuilder(type_473);
  ::Reflex::Type type_5035c = ::Reflex::ConstBuilder(type_5035);
  ::Reflex::Type type_46456 = ::Reflex::ReferenceBuilder(type_5035c);
  ::Reflex::Type type_480c = ::Reflex::ConstBuilder(type_480);
  ::Reflex::Type type_45419 = ::Reflex::ReferenceBuilder(type_480c);
  ::Reflex::Type type_46457 = ::Reflex::ReferenceBuilder(type_480);
  ::Reflex::Type type_14246 = ::Reflex::ReferenceBuilder(type_505);
  ::Reflex::Type type_505c = ::Reflex::ConstBuilder(type_505);
  ::Reflex::Type type_14248 = ::Reflex::ReferenceBuilder(type_505c);
  ::Reflex::Type type_14242 = ::Reflex::PointerBuilder(type_505);
  ::Reflex::Type type_8496 = ::Reflex::ReferenceBuilder(type_1888);
  ::Reflex::Type type_1888c = ::Reflex::ConstBuilder(type_1888);
  ::Reflex::Type type_8498 = ::Reflex::ReferenceBuilder(type_1888c);
  ::Reflex::Type type_8492 = ::Reflex::PointerBuilder(type_1888);
  ::Reflex::Type type_8494 = ::Reflex::PointerBuilder(type_1888c);
  ::Reflex::Type type_5085c = ::Reflex::ConstBuilder(type_5085);
  ::Reflex::Type type_50670 = ::Reflex::ReferenceBuilder(type_5085c);
  ::Reflex::Type type_552c = ::Reflex::ConstBuilder(type_552);
  ::Reflex::Type type_50671 = ::Reflex::ReferenceBuilder(type_552c);
  ::Reflex::Type type_50672 = ::Reflex::ReferenceBuilder(type_552);
  ::Reflex::Type type_8563 = ::Reflex::ReferenceBuilder(type_762);
  ::Reflex::Type type_762c = ::Reflex::ConstBuilder(type_762);
  ::Reflex::Type type_8565 = ::Reflex::ReferenceBuilder(type_762c);
  ::Reflex::Type type_8559 = ::Reflex::PointerBuilder(type_762);
  ::Reflex::Type type_8561 = ::Reflex::PointerBuilder(type_762c);
  ::Reflex::Type type_5054c = ::Reflex::ConstBuilder(type_5054);
  ::Reflex::Type type_50674 = ::Reflex::ReferenceBuilder(type_5054c);
  ::Reflex::Type type_556c = ::Reflex::ConstBuilder(type_556);
  ::Reflex::Type type_50675 = ::Reflex::ReferenceBuilder(type_556c);
  ::Reflex::Type type_50676 = ::Reflex::ReferenceBuilder(type_556);
  ::Reflex::Type type_13377 = ::Reflex::ReferenceBuilder(type_634);
  ::Reflex::Type type_634c = ::Reflex::ConstBuilder(type_634);
  ::Reflex::Type type_13379 = ::Reflex::ReferenceBuilder(type_634c);
  ::Reflex::Type type_13373 = ::Reflex::PointerBuilder(type_634);
  ::Reflex::Type type_10027 = ::Reflex::PointerBuilder(type_473c);
  ::Reflex::Type type_5051c = ::Reflex::ConstBuilder(type_5051);
  ::Reflex::Type type_59085 = ::Reflex::ReferenceBuilder(type_5051c);
  ::Reflex::Type type_670c = ::Reflex::ConstBuilder(type_670);
  ::Reflex::Type type_59086 = ::Reflex::ReferenceBuilder(type_670c);
  ::Reflex::Type type_59087 = ::Reflex::ReferenceBuilder(type_670);
  ::Reflex::Type type_12064 = ::Reflex::ReferenceBuilder(type_716);
  ::Reflex::Type type_716c = ::Reflex::ConstBuilder(type_716);
  ::Reflex::Type type_12066 = ::Reflex::ReferenceBuilder(type_716c);
  ::Reflex::Type type_12060 = ::Reflex::PointerBuilder(type_716);
  ::Reflex::Type type_14565 = ::Reflex::ReferenceBuilder(type_803);
  ::Reflex::Type type_803c = ::Reflex::ConstBuilder(type_803);
  ::Reflex::Type type_14567 = ::Reflex::ReferenceBuilder(type_803c);
  ::Reflex::Type type_14561 = ::Reflex::PointerBuilder(type_803);
  ::Reflex::Type type_13444 = ::Reflex::ReferenceBuilder(type_891);
  ::Reflex::Type type_891c = ::Reflex::ConstBuilder(type_891);
  ::Reflex::Type type_13446 = ::Reflex::ReferenceBuilder(type_891c);
  ::Reflex::Type type_13440 = ::Reflex::PointerBuilder(type_891);
  ::Reflex::Type type_18315 = ::Reflex::ReferenceBuilder(type_912);
  ::Reflex::Type type_912c = ::Reflex::ConstBuilder(type_912);
  ::Reflex::Type type_18317 = ::Reflex::ReferenceBuilder(type_912c);
  ::Reflex::Type type_18311 = ::Reflex::PointerBuilder(type_912);
  ::Reflex::Type type_10926 = ::Reflex::ReferenceBuilder(type_1200);
  ::Reflex::Type type_1200c = ::Reflex::ConstBuilder(type_1200);
  ::Reflex::Type type_10928 = ::Reflex::ReferenceBuilder(type_1200c);
  ::Reflex::Type type_10922 = ::Reflex::PointerBuilder(type_1200);
  ::Reflex::Type type_10924 = ::Reflex::PointerBuilder(type_1200c);
  ::Reflex::Type type_5082c = ::Reflex::ConstBuilder(type_5082);
  ::Reflex::Type type_59307 = ::Reflex::ReferenceBuilder(type_5082c);
  ::Reflex::Type type_922c = ::Reflex::ConstBuilder(type_922);
  ::Reflex::Type type_59308 = ::Reflex::ReferenceBuilder(type_922c);
  ::Reflex::Type type_59309 = ::Reflex::ReferenceBuilder(type_922);
  ::Reflex::Type type_951c = ::Reflex::ConstBuilder(type_951);
  ::Reflex::Type type_45908 = ::Reflex::ReferenceBuilder(type_951c);
  ::Reflex::Type type_59599 = ::Reflex::ReferenceBuilder(type_951);
  ::Reflex::Type type_9670 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::helper_vector"), type_9669);
  ::Reflex::Type type_45462 = ::Reflex::ReferenceBuilder(type_9670);
  ::Reflex::Type type_14045 = ::Reflex::ReferenceBuilder(type_956);
  ::Reflex::Type type_956c = ::Reflex::ConstBuilder(type_956);
  ::Reflex::Type type_14047 = ::Reflex::ReferenceBuilder(type_956c);
  ::Reflex::Type type_14041 = ::Reflex::PointerBuilder(type_956);
  ::Reflex::Type type_18467 = ::Reflex::ReferenceBuilder(type_1022);
  ::Reflex::Type type_1022c = ::Reflex::ConstBuilder(type_1022);
  ::Reflex::Type type_18469 = ::Reflex::ReferenceBuilder(type_1022c);
  ::Reflex::Type type_18463 = ::Reflex::PointerBuilder(type_1022);
  ::Reflex::Type type_17181 = ::Reflex::ReferenceBuilder(type_1051);
  ::Reflex::Type type_1051c = ::Reflex::ConstBuilder(type_1051);
  ::Reflex::Type type_17183 = ::Reflex::ReferenceBuilder(type_1051c);
  ::Reflex::Type type_17177 = ::Reflex::PointerBuilder(type_1051);
  ::Reflex::Type type_11869 = ::Reflex::ReferenceBuilder(type_1121);
  ::Reflex::Type type_1121c = ::Reflex::ConstBuilder(type_1121);
  ::Reflex::Type type_11871 = ::Reflex::ReferenceBuilder(type_1121c);
  ::Reflex::Type type_11865 = ::Reflex::PointerBuilder(type_1121);
  ::Reflex::Type type_11780 = ::Reflex::ReferenceBuilder(type_1155);
  ::Reflex::Type type_1155c = ::Reflex::ConstBuilder(type_1155);
  ::Reflex::Type type_11782 = ::Reflex::ReferenceBuilder(type_1155c);
  ::Reflex::Type type_11776 = ::Reflex::PointerBuilder(type_1155);
  ::Reflex::Type type_11569 = ::Reflex::ReferenceBuilder(type_1517);
  ::Reflex::Type type_1517c = ::Reflex::ConstBuilder(type_1517);
  ::Reflex::Type type_11571 = ::Reflex::ReferenceBuilder(type_1517c);
  ::Reflex::Type type_11565 = ::Reflex::PointerBuilder(type_1517);
  ::Reflex::Type type_11567 = ::Reflex::PointerBuilder(type_1517c);
  ::Reflex::Type type_5061c = ::Reflex::ConstBuilder(type_5061);
  ::Reflex::Type type_59757 = ::Reflex::ReferenceBuilder(type_5061c);
  ::Reflex::Type type_1163c = ::Reflex::ConstBuilder(type_1163);
  ::Reflex::Type type_59758 = ::Reflex::ReferenceBuilder(type_1163c);
  ::Reflex::Type type_59759 = ::Reflex::ReferenceBuilder(type_1163);
  ::Reflex::Type type_11778 = ::Reflex::PointerBuilder(type_1155c);
  ::Reflex::Type type_5077c = ::Reflex::ConstBuilder(type_5077);
  ::Reflex::Type type_59784 = ::Reflex::ReferenceBuilder(type_5077c);
  ::Reflex::Type type_1251c = ::Reflex::ConstBuilder(type_1251);
  ::Reflex::Type type_59785 = ::Reflex::ReferenceBuilder(type_1251c);
  ::Reflex::Type type_59786 = ::Reflex::ReferenceBuilder(type_1251);
  ::Reflex::Type type_11867 = ::Reflex::PointerBuilder(type_1121c);
  ::Reflex::Type type_5072c = ::Reflex::ConstBuilder(type_5072);
  ::Reflex::Type type_59788 = ::Reflex::ReferenceBuilder(type_5072c);
  ::Reflex::Type type_1270c = ::Reflex::ConstBuilder(type_1270);
  ::Reflex::Type type_59789 = ::Reflex::ReferenceBuilder(type_1270c);
  ::Reflex::Type type_59790 = ::Reflex::ReferenceBuilder(type_1270);
  ::Reflex::Type type_11953 = ::Reflex::PointerBuilder(type_308c);
  ::Reflex::Type type_5044c = ::Reflex::ConstBuilder(type_5044);
  ::Reflex::Type type_59799 = ::Reflex::ReferenceBuilder(type_5044c);
  ::Reflex::Type type_1303c = ::Reflex::ConstBuilder(type_1303);
  ::Reflex::Type type_59800 = ::Reflex::ReferenceBuilder(type_1303c);
  ::Reflex::Type type_59801 = ::Reflex::ReferenceBuilder(type_1303);
  ::Reflex::Type type_12062 = ::Reflex::PointerBuilder(type_716c);
  ::Reflex::Type type_5067c = ::Reflex::ConstBuilder(type_5067);
  ::Reflex::Type type_59804 = ::Reflex::ReferenceBuilder(type_5067c);
  ::Reflex::Type type_1352c = ::Reflex::ConstBuilder(type_1352);
  ::Reflex::Type type_59805 = ::Reflex::ReferenceBuilder(type_1352c);
  ::Reflex::Type type_59806 = ::Reflex::ReferenceBuilder(type_1352);
  ::Reflex::Type type_12144 = ::Reflex::ReferenceBuilder(type_2810);
  ::Reflex::Type type_2810c = ::Reflex::ConstBuilder(type_2810);
  ::Reflex::Type type_12146 = ::Reflex::ReferenceBuilder(type_2810c);
  ::Reflex::Type type_12140 = ::Reflex::PointerBuilder(type_2810);
  ::Reflex::Type type_12142 = ::Reflex::PointerBuilder(type_2810c);
  ::Reflex::Type type_5049c = ::Reflex::ConstBuilder(type_5049);
  ::Reflex::Type type_59809 = ::Reflex::ReferenceBuilder(type_5049c);
  ::Reflex::Type type_1381c = ::Reflex::ConstBuilder(type_1381);
  ::Reflex::Type type_59810 = ::Reflex::ReferenceBuilder(type_1381c);
  ::Reflex::Type type_59811 = ::Reflex::ReferenceBuilder(type_1381);
  ::Reflex::Type type_18603 = ::Reflex::ReferenceBuilder(type_1393);
  ::Reflex::Type type_1393c = ::Reflex::ConstBuilder(type_1393);
  ::Reflex::Type type_18605 = ::Reflex::ReferenceBuilder(type_1393c);
  ::Reflex::Type type_18599 = ::Reflex::PointerBuilder(type_1393);
  ::Reflex::Type type_12754 = ::Reflex::ReferenceBuilder(type_1959);
  ::Reflex::Type type_1959c = ::Reflex::ConstBuilder(type_1959);
  ::Reflex::Type type_12756 = ::Reflex::ReferenceBuilder(type_1959c);
  ::Reflex::Type type_12750 = ::Reflex::PointerBuilder(type_1959);
  ::Reflex::Type type_12752 = ::Reflex::PointerBuilder(type_1959c);
  ::Reflex::Type type_5042c = ::Reflex::ConstBuilder(type_5042);
  ::Reflex::Type type_60115 = ::Reflex::ReferenceBuilder(type_5042c);
  ::Reflex::Type type_1605c = ::Reflex::ConstBuilder(type_1605);
  ::Reflex::Type type_60116 = ::Reflex::ReferenceBuilder(type_1605c);
  ::Reflex::Type type_60117 = ::Reflex::ReferenceBuilder(type_1605);
  ::Reflex::Type type_19540 = ::Reflex::ReferenceBuilder(type_1607);
  ::Reflex::Type type_1607c = ::Reflex::ConstBuilder(type_1607);
  ::Reflex::Type type_19542 = ::Reflex::ReferenceBuilder(type_1607c);
  ::Reflex::Type type_19536 = ::Reflex::PointerBuilder(type_1607);
  ::Reflex::Type type_12948 = ::Reflex::ReferenceBuilder(type_1885);
  ::Reflex::Type type_1885c = ::Reflex::ConstBuilder(type_1885);
  ::Reflex::Type type_12950 = ::Reflex::ReferenceBuilder(type_1885c);
  ::Reflex::Type type_12944 = ::Reflex::PointerBuilder(type_1885);
  ::Reflex::Type type_12946 = ::Reflex::PointerBuilder(type_1885c);
  ::Reflex::Type type_5081c = ::Reflex::ConstBuilder(type_5081);
  ::Reflex::Type type_60132 = ::Reflex::ReferenceBuilder(type_5081c);
  ::Reflex::Type type_1614c = ::Reflex::ConstBuilder(type_1614);
  ::Reflex::Type type_60133 = ::Reflex::ReferenceBuilder(type_1614c);
  ::Reflex::Type type_60134 = ::Reflex::ReferenceBuilder(type_1614);
  ::Reflex::Type type_19457 = ::Reflex::ReferenceBuilder(type_1521);
  ::Reflex::Type type_1521c = ::Reflex::ConstBuilder(type_1521);
  ::Reflex::Type type_19459 = ::Reflex::ReferenceBuilder(type_1521c);
  ::Reflex::Type type_19453 = ::Reflex::PointerBuilder(type_1521);
  ::Reflex::Type type_13124 = ::Reflex::ReferenceBuilder(type_1889);
  ::Reflex::Type type_1889c = ::Reflex::ConstBuilder(type_1889);
  ::Reflex::Type type_13126 = ::Reflex::ReferenceBuilder(type_1889c);
  ::Reflex::Type type_13120 = ::Reflex::PointerBuilder(type_1889);
  ::Reflex::Type type_13122 = ::Reflex::PointerBuilder(type_1889c);
  ::Reflex::Type type_5086c = ::Reflex::ConstBuilder(type_5086);
  ::Reflex::Type type_60190 = ::Reflex::ReferenceBuilder(type_5086c);
  ::Reflex::Type type_1724c = ::Reflex::ConstBuilder(type_1724);
  ::Reflex::Type type_60191 = ::Reflex::ReferenceBuilder(type_1724c);
  ::Reflex::Type type_60192 = ::Reflex::ReferenceBuilder(type_1724);
  ::Reflex::Type type_19343 = ::Reflex::ReferenceBuilder(type_1520);
  ::Reflex::Type type_1520c = ::Reflex::ConstBuilder(type_1520);
  ::Reflex::Type type_19345 = ::Reflex::ReferenceBuilder(type_1520c);
  ::Reflex::Type type_19339 = ::Reflex::PointerBuilder(type_1520);
  ::Reflex::Type type_18538 = ::Reflex::ReferenceBuilder(type_1524);
  ::Reflex::Type type_1524c = ::Reflex::ConstBuilder(type_1524);
  ::Reflex::Type type_18540 = ::Reflex::ReferenceBuilder(type_1524c);
  ::Reflex::Type type_18534 = ::Reflex::PointerBuilder(type_1524);
  ::Reflex::Type type_13375 = ::Reflex::PointerBuilder(type_634c);
  ::Reflex::Type type_5060c = ::Reflex::ConstBuilder(type_5060);
  ::Reflex::Type type_60214 = ::Reflex::ReferenceBuilder(type_5060c);
  ::Reflex::Type type_1842c = ::Reflex::ConstBuilder(type_1842);
  ::Reflex::Type type_60215 = ::Reflex::ReferenceBuilder(type_1842c);
  ::Reflex::Type type_60216 = ::Reflex::ReferenceBuilder(type_1842);
  ::Reflex::Type type_13442 = ::Reflex::PointerBuilder(type_891c);
  ::Reflex::Type type_5053c = ::Reflex::ConstBuilder(type_5053);
  ::Reflex::Type type_60218 = ::Reflex::ReferenceBuilder(type_5053c);
  ::Reflex::Type type_1850c = ::Reflex::ConstBuilder(type_1850);
  ::Reflex::Type type_60219 = ::Reflex::ReferenceBuilder(type_1850c);
  ::Reflex::Type type_60220 = ::Reflex::ReferenceBuilder(type_1850);
  ::Reflex::Type type_13511 = ::Reflex::ReferenceBuilder(type_2808);
  ::Reflex::Type type_2808c = ::Reflex::ConstBuilder(type_2808);
  ::Reflex::Type type_13513 = ::Reflex::ReferenceBuilder(type_2808c);
  ::Reflex::Type type_13507 = ::Reflex::PointerBuilder(type_2808);
  ::Reflex::Type type_13509 = ::Reflex::PointerBuilder(type_2808c);
  ::Reflex::Type type_5046c = ::Reflex::ConstBuilder(type_5046);
  ::Reflex::Type type_60222 = ::Reflex::ReferenceBuilder(type_5046c);
  ::Reflex::Type type_1852c = ::Reflex::ConstBuilder(type_1852);
  ::Reflex::Type type_60223 = ::Reflex::ReferenceBuilder(type_1852c);
  ::Reflex::Type type_60224 = ::Reflex::ReferenceBuilder(type_1852);
  ::Reflex::Type type_13617 = ::Reflex::PointerBuilder(type_288c);
  ::Reflex::Type type_5076c = ::Reflex::ConstBuilder(type_5076);
  ::Reflex::Type type_60230 = ::Reflex::ReferenceBuilder(type_5076c);
  ::Reflex::Type type_1869c = ::Reflex::ConstBuilder(type_1869);
  ::Reflex::Type type_60231 = ::Reflex::ReferenceBuilder(type_1869c);
  ::Reflex::Type type_60232 = ::Reflex::ReferenceBuilder(type_1869);
  ::Reflex::Type type_13940 = ::Reflex::ReferenceBuilder(type_1523);
  ::Reflex::Type type_1523c = ::Reflex::ConstBuilder(type_1523);
  ::Reflex::Type type_13942 = ::Reflex::ReferenceBuilder(type_1523c);
  ::Reflex::Type type_13936 = ::Reflex::PointerBuilder(type_1523);
  ::Reflex::Type type_13938 = ::Reflex::PointerBuilder(type_1523c);
  ::Reflex::Type type_5073c = ::Reflex::ConstBuilder(type_5073);
  ::Reflex::Type type_60356 = ::Reflex::ReferenceBuilder(type_5073c);
  ::Reflex::Type type_1976c = ::Reflex::ConstBuilder(type_1976);
  ::Reflex::Type type_60357 = ::Reflex::ReferenceBuilder(type_1976c);
  ::Reflex::Type type_60358 = ::Reflex::ReferenceBuilder(type_1976);
  ::Reflex::Type type_14043 = ::Reflex::PointerBuilder(type_956c);
  ::Reflex::Type type_5052c = ::Reflex::ConstBuilder(type_5052);
  ::Reflex::Type type_60363 = ::Reflex::ReferenceBuilder(type_5052c);
  ::Reflex::Type type_1982c = ::Reflex::ConstBuilder(type_1982);
  ::Reflex::Type type_60364 = ::Reflex::ReferenceBuilder(type_1982c);
  ::Reflex::Type type_60365 = ::Reflex::ReferenceBuilder(type_1982);
  ::Reflex::Type type_14179 = ::Reflex::ReferenceBuilder(type_1522);
  ::Reflex::Type type_1522c = ::Reflex::ConstBuilder(type_1522);
  ::Reflex::Type type_14181 = ::Reflex::ReferenceBuilder(type_1522c);
  ::Reflex::Type type_14175 = ::Reflex::PointerBuilder(type_1522);
  ::Reflex::Type type_14177 = ::Reflex::PointerBuilder(type_1522c);
  ::Reflex::Type type_5070c = ::Reflex::ConstBuilder(type_5070);
  ::Reflex::Type type_60395 = ::Reflex::ReferenceBuilder(type_5070c);
  ::Reflex::Type type_2030c = ::Reflex::ConstBuilder(type_2030);
  ::Reflex::Type type_60396 = ::Reflex::ReferenceBuilder(type_2030c);
  ::Reflex::Type type_60397 = ::Reflex::ReferenceBuilder(type_2030);
  ::Reflex::Type type_14244 = ::Reflex::PointerBuilder(type_505c);
  ::Reflex::Type type_5059c = ::Reflex::ConstBuilder(type_5059);
  ::Reflex::Type type_60399 = ::Reflex::ReferenceBuilder(type_5059c);
  ::Reflex::Type type_2037c = ::Reflex::ConstBuilder(type_2037);
  ::Reflex::Type type_60400 = ::Reflex::ReferenceBuilder(type_2037c);
  ::Reflex::Type type_60401 = ::Reflex::ReferenceBuilder(type_2037);
  ::Reflex::Type type_14498 = ::Reflex::ReferenceBuilder(type_2809);
  ::Reflex::Type type_2809c = ::Reflex::ConstBuilder(type_2809);
  ::Reflex::Type type_14500 = ::Reflex::ReferenceBuilder(type_2809c);
  ::Reflex::Type type_14494 = ::Reflex::PointerBuilder(type_2809);
  ::Reflex::Type type_14496 = ::Reflex::PointerBuilder(type_2809c);
  ::Reflex::Type type_5048c = ::Reflex::ConstBuilder(type_5048);
  ::Reflex::Type type_60791 = ::Reflex::ReferenceBuilder(type_5048c);
  ::Reflex::Type type_2163c = ::Reflex::ConstBuilder(type_2163);
  ::Reflex::Type type_60792 = ::Reflex::ReferenceBuilder(type_2163c);
  ::Reflex::Type type_60793 = ::Reflex::ReferenceBuilder(type_2163);
  ::Reflex::Type type_14563 = ::Reflex::PointerBuilder(type_803c);
  ::Reflex::Type type_5055c = ::Reflex::ConstBuilder(type_5055);
  ::Reflex::Type type_60795 = ::Reflex::ReferenceBuilder(type_5055c);
  ::Reflex::Type type_2170c = ::Reflex::ConstBuilder(type_2170);
  ::Reflex::Type type_60796 = ::Reflex::ReferenceBuilder(type_2170c);
  ::Reflex::Type type_60797 = ::Reflex::ReferenceBuilder(type_2170);
  ::Reflex::Type type_14660 = ::Reflex::ReferenceBuilder(type_2684);
  ::Reflex::Type type_2684c = ::Reflex::ConstBuilder(type_2684);
  ::Reflex::Type type_14662 = ::Reflex::ReferenceBuilder(type_2684c);
  ::Reflex::Type type_14656 = ::Reflex::PointerBuilder(type_2684);
  ::Reflex::Type type_14658 = ::Reflex::PointerBuilder(type_2684c);
  ::Reflex::Type type_5056c = ::Reflex::ConstBuilder(type_5056);
  ::Reflex::Type type_60801 = ::Reflex::ReferenceBuilder(type_5056c);
  ::Reflex::Type type_2188c = ::Reflex::ConstBuilder(type_2188);
  ::Reflex::Type type_60802 = ::Reflex::ReferenceBuilder(type_2188c);
  ::Reflex::Type type_60803 = ::Reflex::ReferenceBuilder(type_2188);
  ::Reflex::Type type_5033c = ::Reflex::ConstBuilder(type_5033);
  ::Reflex::Type type_60811 = ::Reflex::ReferenceBuilder(type_5033c);
  ::Reflex::Type type_2244c = ::Reflex::ConstBuilder(type_2244);
  ::Reflex::Type type_45953 = ::Reflex::ReferenceBuilder(type_2244c);
  ::Reflex::Type type_60812 = ::Reflex::ReferenceBuilder(type_2244);
  ::Reflex::Type type_15099 = ::Reflex::ReferenceBuilder(type_2807);
  ::Reflex::Type type_2807c = ::Reflex::ConstBuilder(type_2807);
  ::Reflex::Type type_15101 = ::Reflex::ReferenceBuilder(type_2807c);
  ::Reflex::Type type_15095 = ::Reflex::PointerBuilder(type_2807);
  ::Reflex::Type type_15097 = ::Reflex::PointerBuilder(type_2807c);
  ::Reflex::Type type_5045c = ::Reflex::ConstBuilder(type_5045);
  ::Reflex::Type type_60863 = ::Reflex::ReferenceBuilder(type_5045c);
  ::Reflex::Type type_2311c = ::Reflex::ConstBuilder(type_2311);
  ::Reflex::Type type_60864 = ::Reflex::ReferenceBuilder(type_2311c);
  ::Reflex::Type type_60865 = ::Reflex::ReferenceBuilder(type_2311);
  ::Reflex::Type type_15235 = ::Reflex::PointerBuilder(type_164c);
  ::Reflex::Type type_5043c = ::Reflex::ConstBuilder(type_5043);
  ::Reflex::Type type_60869 = ::Reflex::ReferenceBuilder(type_5043c);
  ::Reflex::Type type_2341c = ::Reflex::ConstBuilder(type_2341);
  ::Reflex::Type type_60870 = ::Reflex::ReferenceBuilder(type_2341c);
  ::Reflex::Type type_60871 = ::Reflex::ReferenceBuilder(type_2341);
  ::Reflex::Type type_17248 = ::Reflex::ReferenceBuilder(type_1518);
  ::Reflex::Type type_1518c = ::Reflex::ConstBuilder(type_1518);
  ::Reflex::Type type_17250 = ::Reflex::ReferenceBuilder(type_1518c);
  ::Reflex::Type type_17244 = ::Reflex::PointerBuilder(type_1518);
  ::Reflex::Type type_15469 = ::Reflex::ReferenceBuilder(type_1886);
  ::Reflex::Type type_1886c = ::Reflex::ConstBuilder(type_1886);
  ::Reflex::Type type_15471 = ::Reflex::ReferenceBuilder(type_1886c);
  ::Reflex::Type type_15465 = ::Reflex::PointerBuilder(type_1886);
  ::Reflex::Type type_15467 = ::Reflex::PointerBuilder(type_1886c);
  ::Reflex::Type type_5083c = ::Reflex::ConstBuilder(type_5083);
  ::Reflex::Type type_60885 = ::Reflex::ReferenceBuilder(type_5083c);
  ::Reflex::Type type_2440c = ::Reflex::ConstBuilder(type_2440);
  ::Reflex::Type type_60886 = ::Reflex::ReferenceBuilder(type_2440c);
  ::Reflex::Type type_60887 = ::Reflex::ReferenceBuilder(type_2440);
  ::Reflex::Type type_18963 = ::Reflex::ReferenceBuilder(type_2525);
  ::Reflex::Type type_2525c = ::Reflex::ConstBuilder(type_2525);
  ::Reflex::Type type_18965 = ::Reflex::ReferenceBuilder(type_2525c);
  ::Reflex::Type type_18959 = ::Reflex::PointerBuilder(type_2525);
  ::Reflex::Type type_19793 = ::Reflex::ReferenceBuilder(type_2562);
  ::Reflex::Type type_2562c = ::Reflex::ConstBuilder(type_2562);
  ::Reflex::Type type_19795 = ::Reflex::ReferenceBuilder(type_2562c);
  ::Reflex::Type type_19789 = ::Reflex::PointerBuilder(type_2562);
  ::Reflex::Type type_16844 = ::Reflex::ReferenceBuilder(type_1887);
  ::Reflex::Type type_1887c = ::Reflex::ConstBuilder(type_1887);
  ::Reflex::Type type_16846 = ::Reflex::ReferenceBuilder(type_1887c);
  ::Reflex::Type type_16840 = ::Reflex::PointerBuilder(type_1887);
  ::Reflex::Type type_16842 = ::Reflex::PointerBuilder(type_1887c);
  ::Reflex::Type type_5084c = ::Reflex::ConstBuilder(type_5084);
  ::Reflex::Type type_63797 = ::Reflex::ReferenceBuilder(type_5084c);
  ::Reflex::Type type_2858c = ::Reflex::ConstBuilder(type_2858);
  ::Reflex::Type type_63798 = ::Reflex::ReferenceBuilder(type_2858c);
  ::Reflex::Type type_63799 = ::Reflex::ReferenceBuilder(type_2858);
  ::Reflex::Type type_17029 = ::Reflex::PointerBuilder(type_110c);
  ::Reflex::Type type_5066c = ::Reflex::ConstBuilder(type_5066);
  ::Reflex::Type type_63812 = ::Reflex::ReferenceBuilder(type_5066c);
  ::Reflex::Type type_2880c = ::Reflex::ConstBuilder(type_2880);
  ::Reflex::Type type_63813 = ::Reflex::ReferenceBuilder(type_2880c);
  ::Reflex::Type type_63814 = ::Reflex::ReferenceBuilder(type_2880);
  ::Reflex::Type type_17179 = ::Reflex::PointerBuilder(type_1051c);
  ::Reflex::Type type_5065c = ::Reflex::ConstBuilder(type_5065);
  ::Reflex::Type type_63837 = ::Reflex::ReferenceBuilder(type_5065c);
  ::Reflex::Type type_2919c = ::Reflex::ConstBuilder(type_2919);
  ::Reflex::Type type_63838 = ::Reflex::ReferenceBuilder(type_2919c);
  ::Reflex::Type type_63839 = ::Reflex::ReferenceBuilder(type_2919);
  ::Reflex::Type type_17246 = ::Reflex::PointerBuilder(type_1518c);
  ::Reflex::Type type_5062c = ::Reflex::ConstBuilder(type_5062);
  ::Reflex::Type type_63841 = ::Reflex::ReferenceBuilder(type_5062c);
  ::Reflex::Type type_2938c = ::Reflex::ConstBuilder(type_2938);
  ::Reflex::Type type_63842 = ::Reflex::ReferenceBuilder(type_2938c);
  ::Reflex::Type type_63843 = ::Reflex::ReferenceBuilder(type_2938);
  ::Reflex::Type type_17313 = ::Reflex::PointerBuilder(type_113c);
  ::Reflex::Type type_5050c = ::Reflex::ConstBuilder(type_5050);
  ::Reflex::Type type_63845 = ::Reflex::ReferenceBuilder(type_5050c);
  ::Reflex::Type type_2945c = ::Reflex::ConstBuilder(type_2945);
  ::Reflex::Type type_63846 = ::Reflex::ReferenceBuilder(type_2945c);
  ::Reflex::Type type_63847 = ::Reflex::ReferenceBuilder(type_2945);
  ::Reflex::Type type_5031c = ::Reflex::ConstBuilder(type_5031);
  ::Reflex::Type type_69772 = ::Reflex::ReferenceBuilder(type_5031c);
  ::Reflex::Type type_3002c = ::Reflex::ConstBuilder(type_3002);
  ::Reflex::Type type_47135 = ::Reflex::ReferenceBuilder(type_3002c);
  ::Reflex::Type type_69773 = ::Reflex::ReferenceBuilder(type_3002);
  ::Reflex::Type type_20125 = ::Reflex::ReferenceBuilder(type_2811);
  ::Reflex::Type type_2811c = ::Reflex::ConstBuilder(type_2811);
  ::Reflex::Type type_20127 = ::Reflex::ReferenceBuilder(type_2811c);
  ::Reflex::Type type_20121 = ::Reflex::PointerBuilder(type_2811);
  ::Reflex::Type type_18313 = ::Reflex::PointerBuilder(type_912c);
  ::Reflex::Type type_5063c = ::Reflex::ConstBuilder(type_5063);
  ::Reflex::Type type_69784 = ::Reflex::ReferenceBuilder(type_5063c);
  ::Reflex::Type type_3061c = ::Reflex::ConstBuilder(type_3061);
  ::Reflex::Type type_69785 = ::Reflex::ReferenceBuilder(type_3061c);
  ::Reflex::Type type_69786 = ::Reflex::ReferenceBuilder(type_3061);
  ::Reflex::Type type_18465 = ::Reflex::PointerBuilder(type_1022c);
  ::Reflex::Type type_5047c = ::Reflex::ConstBuilder(type_5047);
  ::Reflex::Type type_69790 = ::Reflex::ReferenceBuilder(type_5047c);
  ::Reflex::Type type_3101c = ::Reflex::ConstBuilder(type_3101);
  ::Reflex::Type type_69791 = ::Reflex::ReferenceBuilder(type_3101c);
  ::Reflex::Type type_69792 = ::Reflex::ReferenceBuilder(type_3101);
  ::Reflex::Type type_18536 = ::Reflex::PointerBuilder(type_1524c);
  ::Reflex::Type type_5074c = ::Reflex::ConstBuilder(type_5074);
  ::Reflex::Type type_69797 = ::Reflex::ReferenceBuilder(type_5074c);
  ::Reflex::Type type_3126c = ::Reflex::ConstBuilder(type_3126);
  ::Reflex::Type type_69798 = ::Reflex::ReferenceBuilder(type_3126c);
  ::Reflex::Type type_69799 = ::Reflex::ReferenceBuilder(type_3126);
  ::Reflex::Type type_18601 = ::Reflex::PointerBuilder(type_1393c);
  ::Reflex::Type type_5071c = ::Reflex::ConstBuilder(type_5071);
  ::Reflex::Type type_69801 = ::Reflex::ReferenceBuilder(type_5071c);
  ::Reflex::Type type_3132c = ::Reflex::ConstBuilder(type_3132);
  ::Reflex::Type type_69802 = ::Reflex::ReferenceBuilder(type_3132c);
  ::Reflex::Type type_69803 = ::Reflex::ReferenceBuilder(type_3132);
  ::Reflex::Type type_18961 = ::Reflex::PointerBuilder(type_2525c);
  ::Reflex::Type type_5041c = ::Reflex::ConstBuilder(type_5041);
  ::Reflex::Type type_70717 = ::Reflex::ReferenceBuilder(type_5041c);
  ::Reflex::Type type_3307c = ::Reflex::ConstBuilder(type_3307);
  ::Reflex::Type type_70718 = ::Reflex::ReferenceBuilder(type_3307c);
  ::Reflex::Type type_70719 = ::Reflex::ReferenceBuilder(type_3307);
  ::Reflex::Type type_19145 = ::Reflex::PointerBuilder(type_334c);
  ::Reflex::Type type_5079c = ::Reflex::ConstBuilder(type_5079);
  ::Reflex::Type type_70741 = ::Reflex::ReferenceBuilder(type_5079c);
  ::Reflex::Type type_3403c = ::Reflex::ConstBuilder(type_3403);
  ::Reflex::Type type_70742 = ::Reflex::ReferenceBuilder(type_3403c);
  ::Reflex::Type type_70743 = ::Reflex::ReferenceBuilder(type_3403);
  ::Reflex::Type type_19341 = ::Reflex::PointerBuilder(type_1520c);
  ::Reflex::Type type_5068c = ::Reflex::ConstBuilder(type_5068);
  ::Reflex::Type type_72167 = ::Reflex::ReferenceBuilder(type_5068c);
  ::Reflex::Type type_3510c = ::Reflex::ConstBuilder(type_3510);
  ::Reflex::Type type_72168 = ::Reflex::ReferenceBuilder(type_3510c);
  ::Reflex::Type type_72169 = ::Reflex::ReferenceBuilder(type_3510);
  ::Reflex::Type type_19455 = ::Reflex::PointerBuilder(type_1521c);
  ::Reflex::Type type_5069c = ::Reflex::ConstBuilder(type_5069);
  ::Reflex::Type type_72177 = ::Reflex::ReferenceBuilder(type_5069c);
  ::Reflex::Type type_3537c = ::Reflex::ConstBuilder(type_3537);
  ::Reflex::Type type_72178 = ::Reflex::ReferenceBuilder(type_3537c);
  ::Reflex::Type type_72179 = ::Reflex::ReferenceBuilder(type_3537);
  ::Reflex::Type type_19538 = ::Reflex::PointerBuilder(type_1607c);
  ::Reflex::Type type_5080c = ::Reflex::ConstBuilder(type_5080);
  ::Reflex::Type type_72184 = ::Reflex::ReferenceBuilder(type_5080c);
  ::Reflex::Type type_3550c = ::Reflex::ConstBuilder(type_3550);
  ::Reflex::Type type_72185 = ::Reflex::ReferenceBuilder(type_3550c);
  ::Reflex::Type type_72186 = ::Reflex::ReferenceBuilder(type_3550);
  ::Reflex::Type type_19791 = ::Reflex::PointerBuilder(type_2562c);
  ::Reflex::Type type_5057c = ::Reflex::ConstBuilder(type_5057);
  ::Reflex::Type type_72441 = ::Reflex::ReferenceBuilder(type_5057c);
  ::Reflex::Type type_3617c = ::Reflex::ConstBuilder(type_3617);
  ::Reflex::Type type_72442 = ::Reflex::ReferenceBuilder(type_3617c);
  ::Reflex::Type type_72443 = ::Reflex::ReferenceBuilder(type_3617);
  ::Reflex::Type type_20123 = ::Reflex::PointerBuilder(type_2811c);
  ::Reflex::Type type_5058c = ::Reflex::ConstBuilder(type_5058);
  ::Reflex::Type type_72486 = ::Reflex::ReferenceBuilder(type_5058c);
  ::Reflex::Type type_3645c = ::Reflex::ConstBuilder(type_3645);
  ::Reflex::Type type_72487 = ::Reflex::ReferenceBuilder(type_3645c);
  ::Reflex::Type type_72488 = ::Reflex::ReferenceBuilder(type_3645);
  ::Reflex::Type type_45411 = ::Reflex::ReferenceBuilder(type_80);
  ::Reflex::Type type_80c = ::Reflex::ConstBuilder(type_80);
  ::Reflex::Type type_45412 = ::Reflex::ReferenceBuilder(type_80c);
  ::Reflex::Type type_9933c = ::Reflex::ConstBuilder(type_9933);
  ::Reflex::Type type_45413 = ::Reflex::ReferenceBuilder(type_9933c);
  ::Reflex::Type type_9601c = ::Reflex::ConstBuilder(type_9601);
  ::Reflex::Type type_45414 = ::Reflex::ReferenceBuilder(type_9601c);
  ::Reflex::Type type_45415 = ::Reflex::PointerBuilder(type_480c);
  ::Reflex::Type type_9477c = ::Reflex::ConstBuilder(type_9477);
  ::Reflex::Type type_45416 = ::Reflex::ReferenceBuilder(type_9477c);
  ::Reflex::Type type_3065c = ::Reflex::ConstBuilder(type_3065);
  ::Reflex::Type type_96c = ::Reflex::ConstBuilder(type_96);
  ::Reflex::Type type_45456 = ::Reflex::ReferenceBuilder(type_96c);
  ::Reflex::Type type_45457 = ::Reflex::ReferenceBuilder(type_3065c);
  ::Reflex::Type type_6435c = ::Reflex::ConstBuilder(type_6435);
  ::Reflex::Type type_45458 = ::Reflex::ReferenceBuilder(type_6435c);
  ::Reflex::Type type_6426c = ::Reflex::ConstBuilder(type_6426);
  ::Reflex::Type type_45459 = ::Reflex::ReferenceBuilder(type_6426c);
  ::Reflex::Type type_45460 = ::Reflex::ReferenceBuilder(type_96);
  ::Reflex::Type type_45902 = ::Reflex::ReferenceBuilder(type_229);
  ::Reflex::Type type_229c = ::Reflex::ConstBuilder(type_229);
  ::Reflex::Type type_45903 = ::Reflex::ReferenceBuilder(type_229c);
  ::Reflex::Type type_9934c = ::Reflex::ConstBuilder(type_9934);
  ::Reflex::Type type_45904 = ::Reflex::ReferenceBuilder(type_9934c);
  ::Reflex::Type type_9602c = ::Reflex::ConstBuilder(type_9602);
  ::Reflex::Type type_45905 = ::Reflex::ReferenceBuilder(type_9602c);
  ::Reflex::Type type_45906 = ::Reflex::PointerBuilder(type_951c);
  ::Reflex::Type type_9478c = ::Reflex::ConstBuilder(type_9478);
  ::Reflex::Type type_45907 = ::Reflex::ReferenceBuilder(type_9478c);
  ::Reflex::Type type_45947 = ::Reflex::ReferenceBuilder(type_263);
  ::Reflex::Type type_263c = ::Reflex::ConstBuilder(type_263);
  ::Reflex::Type type_45948 = ::Reflex::ReferenceBuilder(type_263c);
  ::Reflex::Type type_9932c = ::Reflex::ConstBuilder(type_9932);
  ::Reflex::Type type_45949 = ::Reflex::ReferenceBuilder(type_9932c);
  ::Reflex::Type type_9600c = ::Reflex::ConstBuilder(type_9600);
  ::Reflex::Type type_45950 = ::Reflex::ReferenceBuilder(type_9600c);
  ::Reflex::Type type_45951 = ::Reflex::PointerBuilder(type_2244c);
  ::Reflex::Type type_9476c = ::Reflex::ConstBuilder(type_9476);
  ::Reflex::Type type_45952 = ::Reflex::ReferenceBuilder(type_9476c);
  ::Reflex::Type type_2230c = ::Reflex::ConstBuilder(type_2230);
  ::Reflex::Type type_277c = ::Reflex::ConstBuilder(type_277);
  ::Reflex::Type type_45963 = ::Reflex::ReferenceBuilder(type_277c);
  ::Reflex::Type type_45964 = ::Reflex::ReferenceBuilder(type_2230c);
  ::Reflex::Type type_7029c = ::Reflex::ConstBuilder(type_7029);
  ::Reflex::Type type_45965 = ::Reflex::ReferenceBuilder(type_7029c);
  ::Reflex::Type type_45966 = ::Reflex::ReferenceBuilder(type_277);
  ::Reflex::Type type_2399c = ::Reflex::ConstBuilder(type_2399);
  ::Reflex::Type type_2057c = ::Reflex::ConstBuilder(type_2057);
  ::Reflex::Type type_60411 = ::Reflex::ReferenceBuilder(type_2057c);
  ::Reflex::Type type_60412 = ::Reflex::ReferenceBuilder(type_2399c);
  ::Reflex::Type type_60413 = ::Reflex::PointerBuilder(type_3002c);
  ::Reflex::Type type_8775c = ::Reflex::ConstBuilder(type_8775);
  ::Reflex::Type type_60414 = ::Reflex::ReferenceBuilder(type_8775c);
  ::Reflex::Type type_60415 = ::Reflex::ReferenceBuilder(type_2057);
  ::Reflex::Type type_60419 = ::Reflex::ReferenceBuilder(type_2093);
  ::Reflex::Type type_2093c = ::Reflex::ConstBuilder(type_2093);
  ::Reflex::Type type_60420 = ::Reflex::ReferenceBuilder(type_2093c);
  ::Reflex::Type type_9931c = ::Reflex::ConstBuilder(type_9931);
  ::Reflex::Type type_60421 = ::Reflex::ReferenceBuilder(type_9931c);
  ::Reflex::Type type_9599c = ::Reflex::ConstBuilder(type_9599);
  ::Reflex::Type type_60422 = ::Reflex::ReferenceBuilder(type_9599c);
  ::Reflex::Type type_9475c = ::Reflex::ConstBuilder(type_9475);
  ::Reflex::Type type_60423 = ::Reflex::ReferenceBuilder(type_9475c);
  ::Reflex::Type type_60808 = ::Reflex::ReferenceBuilder(type_2230);
  ::Reflex::Type type_497c = ::Reflex::ConstBuilder(type_497);
  ::Reflex::Type type_24095 = ::Reflex::ReferenceBuilder(type_497c);
  ::Reflex::Type type_60877 = ::Reflex::ReferenceBuilder(type_2399);
  ::Reflex::Type type_3090c = ::Reflex::ConstBuilder(type_3090);
  ::Reflex::Type type_2787c = ::Reflex::ConstBuilder(type_2787);
  ::Reflex::Type type_61014 = ::Reflex::ReferenceBuilder(type_2787c);
  ::Reflex::Type type_61015 = ::Reflex::ReferenceBuilder(type_3090c);
  ::Reflex::Type type_8776c = ::Reflex::ConstBuilder(type_8776);
  ::Reflex::Type type_61016 = ::Reflex::ReferenceBuilder(type_8776c);
  ::Reflex::Type type_61017 = ::Reflex::ReferenceBuilder(type_2787);
  ::Reflex::Type type_69787 = ::Reflex::ReferenceBuilder(type_3065);
  ::Reflex::Type type_69788 = ::Reflex::ReferenceBuilder(type_3090);
  ::Reflex::Type type_85002 = ::Reflex::PointerBuilder(type_3307c);
  ::Reflex::Type type_85003 = ::Reflex::PointerBuilder(type_3307);
  ::Reflex::Type type_9244c = ::Reflex::ConstBuilder(type_9244);
  ::Reflex::Type type_85004 = ::Reflex::PointerBuilder(type_9244c);
  ::Reflex::Type type_9245c = ::Reflex::ConstBuilder(type_9245);
  ::Reflex::Type type_85007 = ::Reflex::PointerBuilder(type_9245c);
  ::Reflex::Type type_85010 = ::Reflex::PointerBuilder(type_1605c);
  ::Reflex::Type type_85011 = ::Reflex::PointerBuilder(type_1605);
  ::Reflex::Type type_9246c = ::Reflex::ConstBuilder(type_9246);
  ::Reflex::Type type_85012 = ::Reflex::PointerBuilder(type_9246c);
  ::Reflex::Type type_9247c = ::Reflex::ConstBuilder(type_9247);
  ::Reflex::Type type_85015 = ::Reflex::PointerBuilder(type_9247c);
  ::Reflex::Type type_85018 = ::Reflex::PointerBuilder(type_2341c);
  ::Reflex::Type type_85019 = ::Reflex::PointerBuilder(type_2341);
  ::Reflex::Type type_9248c = ::Reflex::ConstBuilder(type_9248);
  ::Reflex::Type type_85020 = ::Reflex::PointerBuilder(type_9248c);
  ::Reflex::Type type_9249c = ::Reflex::ConstBuilder(type_9249);
  ::Reflex::Type type_85023 = ::Reflex::PointerBuilder(type_9249c);
  ::Reflex::Type type_85026 = ::Reflex::PointerBuilder(type_1303c);
  ::Reflex::Type type_85027 = ::Reflex::PointerBuilder(type_1303);
  ::Reflex::Type type_9250c = ::Reflex::ConstBuilder(type_9250);
  ::Reflex::Type type_85028 = ::Reflex::PointerBuilder(type_9250c);
  ::Reflex::Type type_9251c = ::Reflex::ConstBuilder(type_9251);
  ::Reflex::Type type_85031 = ::Reflex::PointerBuilder(type_9251c);
  ::Reflex::Type type_85034 = ::Reflex::PointerBuilder(type_2311c);
  ::Reflex::Type type_85035 = ::Reflex::PointerBuilder(type_2311);
  ::Reflex::Type type_9252c = ::Reflex::ConstBuilder(type_9252);
  ::Reflex::Type type_85036 = ::Reflex::PointerBuilder(type_9252c);
  ::Reflex::Type type_9253c = ::Reflex::ConstBuilder(type_9253);
  ::Reflex::Type type_85039 = ::Reflex::PointerBuilder(type_9253c);
  ::Reflex::Type type_85042 = ::Reflex::PointerBuilder(type_1852c);
  ::Reflex::Type type_85043 = ::Reflex::PointerBuilder(type_1852);
  ::Reflex::Type type_9254c = ::Reflex::ConstBuilder(type_9254);
  ::Reflex::Type type_85044 = ::Reflex::PointerBuilder(type_9254c);
  ::Reflex::Type type_9255c = ::Reflex::ConstBuilder(type_9255);
  ::Reflex::Type type_85047 = ::Reflex::PointerBuilder(type_9255c);
  ::Reflex::Type type_85050 = ::Reflex::PointerBuilder(type_3101c);
  ::Reflex::Type type_85051 = ::Reflex::PointerBuilder(type_3101);
  ::Reflex::Type type_9256c = ::Reflex::ConstBuilder(type_9256);
  ::Reflex::Type type_85052 = ::Reflex::PointerBuilder(type_9256c);
  ::Reflex::Type type_9257c = ::Reflex::ConstBuilder(type_9257);
  ::Reflex::Type type_85055 = ::Reflex::PointerBuilder(type_9257c);
  ::Reflex::Type type_85058 = ::Reflex::PointerBuilder(type_2163c);
  ::Reflex::Type type_85059 = ::Reflex::PointerBuilder(type_2163);
  ::Reflex::Type type_9258c = ::Reflex::ConstBuilder(type_9258);
  ::Reflex::Type type_85060 = ::Reflex::PointerBuilder(type_9258c);
  ::Reflex::Type type_9259c = ::Reflex::ConstBuilder(type_9259);
  ::Reflex::Type type_85063 = ::Reflex::PointerBuilder(type_9259c);
  ::Reflex::Type type_85066 = ::Reflex::PointerBuilder(type_1381c);
  ::Reflex::Type type_85067 = ::Reflex::PointerBuilder(type_1381);
  ::Reflex::Type type_9260c = ::Reflex::ConstBuilder(type_9260);
  ::Reflex::Type type_85068 = ::Reflex::PointerBuilder(type_9260c);
  ::Reflex::Type type_9261c = ::Reflex::ConstBuilder(type_9261);
  ::Reflex::Type type_85071 = ::Reflex::PointerBuilder(type_9261c);
  ::Reflex::Type type_85074 = ::Reflex::PointerBuilder(type_2945c);
  ::Reflex::Type type_85075 = ::Reflex::PointerBuilder(type_2945);
  ::Reflex::Type type_9262c = ::Reflex::ConstBuilder(type_9262);
  ::Reflex::Type type_85076 = ::Reflex::PointerBuilder(type_9262c);
  ::Reflex::Type type_9263c = ::Reflex::ConstBuilder(type_9263);
  ::Reflex::Type type_85079 = ::Reflex::PointerBuilder(type_9263c);
  ::Reflex::Type type_85082 = ::Reflex::PointerBuilder(type_670c);
  ::Reflex::Type type_85083 = ::Reflex::PointerBuilder(type_670);
  ::Reflex::Type type_9264c = ::Reflex::ConstBuilder(type_9264);
  ::Reflex::Type type_85084 = ::Reflex::PointerBuilder(type_9264c);
  ::Reflex::Type type_9265c = ::Reflex::ConstBuilder(type_9265);
  ::Reflex::Type type_85087 = ::Reflex::PointerBuilder(type_9265c);
  ::Reflex::Type type_85090 = ::Reflex::PointerBuilder(type_1982c);
  ::Reflex::Type type_85091 = ::Reflex::PointerBuilder(type_1982);
  ::Reflex::Type type_9266c = ::Reflex::ConstBuilder(type_9266);
  ::Reflex::Type type_85092 = ::Reflex::PointerBuilder(type_9266c);
  ::Reflex::Type type_9267c = ::Reflex::ConstBuilder(type_9267);
  ::Reflex::Type type_85095 = ::Reflex::PointerBuilder(type_9267c);
  ::Reflex::Type type_85098 = ::Reflex::PointerBuilder(type_1850c);
  ::Reflex::Type type_85099 = ::Reflex::PointerBuilder(type_1850);
  ::Reflex::Type type_9268c = ::Reflex::ConstBuilder(type_9268);
  ::Reflex::Type type_85100 = ::Reflex::PointerBuilder(type_9268c);
  ::Reflex::Type type_9269c = ::Reflex::ConstBuilder(type_9269);
  ::Reflex::Type type_85103 = ::Reflex::PointerBuilder(type_9269c);
  ::Reflex::Type type_85106 = ::Reflex::PointerBuilder(type_556c);
  ::Reflex::Type type_85107 = ::Reflex::PointerBuilder(type_556);
  ::Reflex::Type type_9270c = ::Reflex::ConstBuilder(type_9270);
  ::Reflex::Type type_85108 = ::Reflex::PointerBuilder(type_9270c);
  ::Reflex::Type type_9271c = ::Reflex::ConstBuilder(type_9271);
  ::Reflex::Type type_85111 = ::Reflex::PointerBuilder(type_9271c);
  ::Reflex::Type type_85114 = ::Reflex::PointerBuilder(type_2170c);
  ::Reflex::Type type_85115 = ::Reflex::PointerBuilder(type_2170);
  ::Reflex::Type type_9272c = ::Reflex::ConstBuilder(type_9272);
  ::Reflex::Type type_85116 = ::Reflex::PointerBuilder(type_9272c);
  ::Reflex::Type type_9273c = ::Reflex::ConstBuilder(type_9273);
  ::Reflex::Type type_85119 = ::Reflex::PointerBuilder(type_9273c);
  ::Reflex::Type type_85122 = ::Reflex::PointerBuilder(type_2188c);
  ::Reflex::Type type_85123 = ::Reflex::PointerBuilder(type_2188);
  ::Reflex::Type type_9274c = ::Reflex::ConstBuilder(type_9274);
  ::Reflex::Type type_85124 = ::Reflex::PointerBuilder(type_9274c);
  ::Reflex::Type type_9275c = ::Reflex::ConstBuilder(type_9275);
  ::Reflex::Type type_85127 = ::Reflex::PointerBuilder(type_9275c);
  ::Reflex::Type type_85130 = ::Reflex::PointerBuilder(type_3617c);
  ::Reflex::Type type_85131 = ::Reflex::PointerBuilder(type_3617);
  ::Reflex::Type type_9276c = ::Reflex::ConstBuilder(type_9276);
  ::Reflex::Type type_85132 = ::Reflex::PointerBuilder(type_9276c);
  ::Reflex::Type type_9277c = ::Reflex::ConstBuilder(type_9277);
  ::Reflex::Type type_85135 = ::Reflex::PointerBuilder(type_9277c);
  ::Reflex::Type type_85138 = ::Reflex::PointerBuilder(type_3645c);
  ::Reflex::Type type_85139 = ::Reflex::PointerBuilder(type_3645);
  ::Reflex::Type type_9278c = ::Reflex::ConstBuilder(type_9278);
  ::Reflex::Type type_85140 = ::Reflex::PointerBuilder(type_9278c);
  ::Reflex::Type type_9279c = ::Reflex::ConstBuilder(type_9279);
  ::Reflex::Type type_85143 = ::Reflex::PointerBuilder(type_9279c);
  ::Reflex::Type type_85146 = ::Reflex::PointerBuilder(type_2037c);
  ::Reflex::Type type_85147 = ::Reflex::PointerBuilder(type_2037);
  ::Reflex::Type type_9280c = ::Reflex::ConstBuilder(type_9280);
  ::Reflex::Type type_85148 = ::Reflex::PointerBuilder(type_9280c);
  ::Reflex::Type type_9281c = ::Reflex::ConstBuilder(type_9281);
  ::Reflex::Type type_85151 = ::Reflex::PointerBuilder(type_9281c);
  ::Reflex::Type type_85154 = ::Reflex::PointerBuilder(type_1842c);
  ::Reflex::Type type_85155 = ::Reflex::PointerBuilder(type_1842);
  ::Reflex::Type type_9282c = ::Reflex::ConstBuilder(type_9282);
  ::Reflex::Type type_85156 = ::Reflex::PointerBuilder(type_9282c);
  ::Reflex::Type type_9283c = ::Reflex::ConstBuilder(type_9283);
  ::Reflex::Type type_85159 = ::Reflex::PointerBuilder(type_9283c);
  ::Reflex::Type type_85162 = ::Reflex::PointerBuilder(type_1163c);
  ::Reflex::Type type_85163 = ::Reflex::PointerBuilder(type_1163);
  ::Reflex::Type type_9284c = ::Reflex::ConstBuilder(type_9284);
  ::Reflex::Type type_85164 = ::Reflex::PointerBuilder(type_9284c);
  ::Reflex::Type type_9285c = ::Reflex::ConstBuilder(type_9285);
  ::Reflex::Type type_85167 = ::Reflex::PointerBuilder(type_9285c);
  ::Reflex::Type type_85170 = ::Reflex::PointerBuilder(type_2938c);
  ::Reflex::Type type_85171 = ::Reflex::PointerBuilder(type_2938);
  ::Reflex::Type type_9286c = ::Reflex::ConstBuilder(type_9286);
  ::Reflex::Type type_85172 = ::Reflex::PointerBuilder(type_9286c);
  ::Reflex::Type type_9287c = ::Reflex::ConstBuilder(type_9287);
  ::Reflex::Type type_85175 = ::Reflex::PointerBuilder(type_9287c);
  ::Reflex::Type type_85178 = ::Reflex::PointerBuilder(type_3061c);
  ::Reflex::Type type_85179 = ::Reflex::PointerBuilder(type_3061);
  ::Reflex::Type type_9288c = ::Reflex::ConstBuilder(type_9288);
  ::Reflex::Type type_85180 = ::Reflex::PointerBuilder(type_9288c);
  ::Reflex::Type type_9289c = ::Reflex::ConstBuilder(type_9289);
  ::Reflex::Type type_85183 = ::Reflex::PointerBuilder(type_9289c);
  ::Reflex::Type type_85186 = ::Reflex::PointerBuilder(type_260c);
  ::Reflex::Type type_85187 = ::Reflex::PointerBuilder(type_260);
  ::Reflex::Type type_9290c = ::Reflex::ConstBuilder(type_9290);
  ::Reflex::Type type_85188 = ::Reflex::PointerBuilder(type_9290c);
  ::Reflex::Type type_9291c = ::Reflex::ConstBuilder(type_9291);
  ::Reflex::Type type_85191 = ::Reflex::PointerBuilder(type_9291c);
  ::Reflex::Type type_85194 = ::Reflex::PointerBuilder(type_2919c);
  ::Reflex::Type type_85195 = ::Reflex::PointerBuilder(type_2919);
  ::Reflex::Type type_9292c = ::Reflex::ConstBuilder(type_9292);
  ::Reflex::Type type_85196 = ::Reflex::PointerBuilder(type_9292c);
  ::Reflex::Type type_9293c = ::Reflex::ConstBuilder(type_9293);
  ::Reflex::Type type_85199 = ::Reflex::PointerBuilder(type_9293c);
  ::Reflex::Type type_85202 = ::Reflex::PointerBuilder(type_2880c);
  ::Reflex::Type type_85203 = ::Reflex::PointerBuilder(type_2880);
  ::Reflex::Type type_9294c = ::Reflex::ConstBuilder(type_9294);
  ::Reflex::Type type_85204 = ::Reflex::PointerBuilder(type_9294c);
  ::Reflex::Type type_9295c = ::Reflex::ConstBuilder(type_9295);
  ::Reflex::Type type_85207 = ::Reflex::PointerBuilder(type_9295c);
  ::Reflex::Type type_85210 = ::Reflex::PointerBuilder(type_1352c);
  ::Reflex::Type type_85211 = ::Reflex::PointerBuilder(type_1352);
  ::Reflex::Type type_9296c = ::Reflex::ConstBuilder(type_9296);
  ::Reflex::Type type_85212 = ::Reflex::PointerBuilder(type_9296c);
  ::Reflex::Type type_9297c = ::Reflex::ConstBuilder(type_9297);
  ::Reflex::Type type_85215 = ::Reflex::PointerBuilder(type_9297c);
  ::Reflex::Type type_85218 = ::Reflex::PointerBuilder(type_3510c);
  ::Reflex::Type type_85219 = ::Reflex::PointerBuilder(type_3510);
  ::Reflex::Type type_9298c = ::Reflex::ConstBuilder(type_9298);
  ::Reflex::Type type_85220 = ::Reflex::PointerBuilder(type_9298c);
  ::Reflex::Type type_9299c = ::Reflex::ConstBuilder(type_9299);
  ::Reflex::Type type_85223 = ::Reflex::PointerBuilder(type_9299c);
  ::Reflex::Type type_85226 = ::Reflex::PointerBuilder(type_3537c);
  ::Reflex::Type type_85227 = ::Reflex::PointerBuilder(type_3537);
  ::Reflex::Type type_9300c = ::Reflex::ConstBuilder(type_9300);
  ::Reflex::Type type_85228 = ::Reflex::PointerBuilder(type_9300c);
  ::Reflex::Type type_9301c = ::Reflex::ConstBuilder(type_9301);
  ::Reflex::Type type_85231 = ::Reflex::PointerBuilder(type_9301c);
  ::Reflex::Type type_85234 = ::Reflex::PointerBuilder(type_2030c);
  ::Reflex::Type type_85235 = ::Reflex::PointerBuilder(type_2030);
  ::Reflex::Type type_9302c = ::Reflex::ConstBuilder(type_9302);
  ::Reflex::Type type_85236 = ::Reflex::PointerBuilder(type_9302c);
  ::Reflex::Type type_9303c = ::Reflex::ConstBuilder(type_9303);
  ::Reflex::Type type_85239 = ::Reflex::PointerBuilder(type_9303c);
  ::Reflex::Type type_85242 = ::Reflex::PointerBuilder(type_3132c);
  ::Reflex::Type type_85243 = ::Reflex::PointerBuilder(type_3132);
  ::Reflex::Type type_9304c = ::Reflex::ConstBuilder(type_9304);
  ::Reflex::Type type_85244 = ::Reflex::PointerBuilder(type_9304c);
  ::Reflex::Type type_9305c = ::Reflex::ConstBuilder(type_9305);
  ::Reflex::Type type_85247 = ::Reflex::PointerBuilder(type_9305c);
  ::Reflex::Type type_85250 = ::Reflex::PointerBuilder(type_1270c);
  ::Reflex::Type type_85251 = ::Reflex::PointerBuilder(type_1270);
  ::Reflex::Type type_9306c = ::Reflex::ConstBuilder(type_9306);
  ::Reflex::Type type_85252 = ::Reflex::PointerBuilder(type_9306c);
  ::Reflex::Type type_9307c = ::Reflex::ConstBuilder(type_9307);
  ::Reflex::Type type_85255 = ::Reflex::PointerBuilder(type_9307c);
  ::Reflex::Type type_85258 = ::Reflex::PointerBuilder(type_1976c);
  ::Reflex::Type type_85259 = ::Reflex::PointerBuilder(type_1976);
  ::Reflex::Type type_9308c = ::Reflex::ConstBuilder(type_9308);
  ::Reflex::Type type_85260 = ::Reflex::PointerBuilder(type_9308c);
  ::Reflex::Type type_9309c = ::Reflex::ConstBuilder(type_9309);
  ::Reflex::Type type_85263 = ::Reflex::PointerBuilder(type_9309c);
  ::Reflex::Type type_85266 = ::Reflex::PointerBuilder(type_3126c);
  ::Reflex::Type type_85267 = ::Reflex::PointerBuilder(type_3126);
  ::Reflex::Type type_9310c = ::Reflex::ConstBuilder(type_9310);
  ::Reflex::Type type_85268 = ::Reflex::PointerBuilder(type_9310c);
  ::Reflex::Type type_9311c = ::Reflex::ConstBuilder(type_9311);
  ::Reflex::Type type_85271 = ::Reflex::PointerBuilder(type_9311c);
  ::Reflex::Type type_85274 = ::Reflex::PointerBuilder(type_444c);
  ::Reflex::Type type_85275 = ::Reflex::PointerBuilder(type_444);
  ::Reflex::Type type_9312c = ::Reflex::ConstBuilder(type_9312);
  ::Reflex::Type type_85276 = ::Reflex::PointerBuilder(type_9312c);
  ::Reflex::Type type_9313c = ::Reflex::ConstBuilder(type_9313);
  ::Reflex::Type type_85279 = ::Reflex::PointerBuilder(type_9313c);
  ::Reflex::Type type_85282 = ::Reflex::PointerBuilder(type_1869c);
  ::Reflex::Type type_85283 = ::Reflex::PointerBuilder(type_1869);
  ::Reflex::Type type_9314c = ::Reflex::ConstBuilder(type_9314);
  ::Reflex::Type type_85284 = ::Reflex::PointerBuilder(type_9314c);
  ::Reflex::Type type_9315c = ::Reflex::ConstBuilder(type_9315);
  ::Reflex::Type type_85287 = ::Reflex::PointerBuilder(type_9315c);
  ::Reflex::Type type_85290 = ::Reflex::PointerBuilder(type_1251c);
  ::Reflex::Type type_85291 = ::Reflex::PointerBuilder(type_1251);
  ::Reflex::Type type_9316c = ::Reflex::ConstBuilder(type_9316);
  ::Reflex::Type type_85292 = ::Reflex::PointerBuilder(type_9316c);
  ::Reflex::Type type_9317c = ::Reflex::ConstBuilder(type_9317);
  ::Reflex::Type type_85295 = ::Reflex::PointerBuilder(type_9317c);
  ::Reflex::Type type_85306 = ::Reflex::PointerBuilder(type_3403c);
  ::Reflex::Type type_85307 = ::Reflex::PointerBuilder(type_3403);
  ::Reflex::Type type_9320c = ::Reflex::ConstBuilder(type_9320);
  ::Reflex::Type type_85308 = ::Reflex::PointerBuilder(type_9320c);
  ::Reflex::Type type_9321c = ::Reflex::ConstBuilder(type_9321);
  ::Reflex::Type type_85311 = ::Reflex::PointerBuilder(type_9321c);
  ::Reflex::Type type_85314 = ::Reflex::PointerBuilder(type_3550c);
  ::Reflex::Type type_85315 = ::Reflex::PointerBuilder(type_3550);
  ::Reflex::Type type_9322c = ::Reflex::ConstBuilder(type_9322);
  ::Reflex::Type type_85316 = ::Reflex::PointerBuilder(type_9322c);
  ::Reflex::Type type_9323c = ::Reflex::ConstBuilder(type_9323);
  ::Reflex::Type type_85319 = ::Reflex::PointerBuilder(type_9323c);
  ::Reflex::Type type_85322 = ::Reflex::PointerBuilder(type_1614c);
  ::Reflex::Type type_85323 = ::Reflex::PointerBuilder(type_1614);
  ::Reflex::Type type_9324c = ::Reflex::ConstBuilder(type_9324);
  ::Reflex::Type type_85324 = ::Reflex::PointerBuilder(type_9324c);
  ::Reflex::Type type_9325c = ::Reflex::ConstBuilder(type_9325);
  ::Reflex::Type type_85327 = ::Reflex::PointerBuilder(type_9325c);
  ::Reflex::Type type_85330 = ::Reflex::PointerBuilder(type_922c);
  ::Reflex::Type type_85331 = ::Reflex::PointerBuilder(type_922);
  ::Reflex::Type type_9326c = ::Reflex::ConstBuilder(type_9326);
  ::Reflex::Type type_85332 = ::Reflex::PointerBuilder(type_9326c);
  ::Reflex::Type type_9327c = ::Reflex::ConstBuilder(type_9327);
  ::Reflex::Type type_85335 = ::Reflex::PointerBuilder(type_9327c);
  ::Reflex::Type type_85338 = ::Reflex::PointerBuilder(type_2440c);
  ::Reflex::Type type_85339 = ::Reflex::PointerBuilder(type_2440);
  ::Reflex::Type type_9328c = ::Reflex::ConstBuilder(type_9328);
  ::Reflex::Type type_85340 = ::Reflex::PointerBuilder(type_9328c);
  ::Reflex::Type type_9329c = ::Reflex::ConstBuilder(type_9329);
  ::Reflex::Type type_85343 = ::Reflex::PointerBuilder(type_9329c);
  ::Reflex::Type type_85346 = ::Reflex::PointerBuilder(type_2858c);
  ::Reflex::Type type_85347 = ::Reflex::PointerBuilder(type_2858);
  ::Reflex::Type type_9330c = ::Reflex::ConstBuilder(type_9330);
  ::Reflex::Type type_85348 = ::Reflex::PointerBuilder(type_9330c);
  ::Reflex::Type type_9331c = ::Reflex::ConstBuilder(type_9331);
  ::Reflex::Type type_85351 = ::Reflex::PointerBuilder(type_9331c);
  ::Reflex::Type type_85354 = ::Reflex::PointerBuilder(type_552c);
  ::Reflex::Type type_85355 = ::Reflex::PointerBuilder(type_552);
  ::Reflex::Type type_9332c = ::Reflex::ConstBuilder(type_9332);
  ::Reflex::Type type_85356 = ::Reflex::PointerBuilder(type_9332c);
  ::Reflex::Type type_9333c = ::Reflex::ConstBuilder(type_9333);
  ::Reflex::Type type_85359 = ::Reflex::PointerBuilder(type_9333c);
  ::Reflex::Type type_85362 = ::Reflex::PointerBuilder(type_1724c);
  ::Reflex::Type type_85363 = ::Reflex::PointerBuilder(type_1724);
  ::Reflex::Type type_9334c = ::Reflex::ConstBuilder(type_9334);
  ::Reflex::Type type_85364 = ::Reflex::PointerBuilder(type_9334c);
  ::Reflex::Type type_9335c = ::Reflex::ConstBuilder(type_9335);
  ::Reflex::Type type_85367 = ::Reflex::PointerBuilder(type_9335c);
  ::Reflex::Type type_85370 = ::Reflex::PointerBuilder(type_3002);
  ::Reflex::Type type_9336c = ::Reflex::ConstBuilder(type_9336);
  ::Reflex::Type type_85371 = ::Reflex::PointerBuilder(type_9336c);
  ::Reflex::Type type_85377 = ::Reflex::PointerBuilder(type_2244);
  ::Reflex::Type type_9338c = ::Reflex::ConstBuilder(type_9338);
  ::Reflex::Type type_85378 = ::Reflex::PointerBuilder(type_9338c);
  ::Reflex::Type type_85384 = ::Reflex::PointerBuilder(type_480);
  ::Reflex::Type type_9340c = ::Reflex::ConstBuilder(type_9340);
  ::Reflex::Type type_85385 = ::Reflex::PointerBuilder(type_9340c);
  ::Reflex::Type type_85391 = ::Reflex::PointerBuilder(type_951);
  ::Reflex::Type type_9342c = ::Reflex::ConstBuilder(type_9342);
  ::Reflex::Type type_85392 = ::Reflex::PointerBuilder(type_9342c);
  ::Reflex::Type type_85660 = ::Reflex::ReferenceBuilder(type_9696);
  ::Reflex::Type type_9924c = ::Reflex::ConstBuilder(type_9924);
  ::Reflex::Type type_85661 = ::Reflex::ReferenceBuilder(type_9924c);
  ::Reflex::Type type_9593c = ::Reflex::ConstBuilder(type_9593);
  ::Reflex::Type type_85564 = ::Reflex::ReferenceBuilder(type_9593c);
  ::Reflex::Type type_4617c = ::Reflex::ConstBuilder(type_4617);
  ::Reflex::Type type_85490 = ::Reflex::PointerBuilder(type_4617c);
  ::Reflex::Type type_9469c = ::Reflex::ConstBuilder(type_9469);
  ::Reflex::Type type_85489 = ::Reflex::ReferenceBuilder(type_9469c);
  ::Reflex::Type type_75847 = ::Reflex::ReferenceBuilder(type_4617c);
  ::Reflex::Type type_85662 = ::Reflex::ReferenceBuilder(type_9697);
  ::Reflex::Type type_9925c = ::Reflex::ConstBuilder(type_9925);
  ::Reflex::Type type_85663 = ::Reflex::ReferenceBuilder(type_9925c);
  ::Reflex::Type type_9594c = ::Reflex::ConstBuilder(type_9594);
  ::Reflex::Type type_85566 = ::Reflex::ReferenceBuilder(type_9594c);
  ::Reflex::Type type_4641c = ::Reflex::ConstBuilder(type_4641);
  ::Reflex::Type type_85493 = ::Reflex::PointerBuilder(type_4641c);
  ::Reflex::Type type_9470c = ::Reflex::ConstBuilder(type_9470);
  ::Reflex::Type type_85492 = ::Reflex::ReferenceBuilder(type_9470c);
  ::Reflex::Type type_75910 = ::Reflex::ReferenceBuilder(type_4641c);
  ::Reflex::Type type_85664 = ::Reflex::ReferenceBuilder(type_9698);
  ::Reflex::Type type_9926c = ::Reflex::ConstBuilder(type_9926);
  ::Reflex::Type type_85665 = ::Reflex::ReferenceBuilder(type_9926c);
  ::Reflex::Type type_9595c = ::Reflex::ConstBuilder(type_9595);
  ::Reflex::Type type_85568 = ::Reflex::ReferenceBuilder(type_9595c);
  ::Reflex::Type type_4671c = ::Reflex::ConstBuilder(type_4671);
  ::Reflex::Type type_85496 = ::Reflex::PointerBuilder(type_4671c);
  ::Reflex::Type type_9471c = ::Reflex::ConstBuilder(type_9471);
  ::Reflex::Type type_85495 = ::Reflex::ReferenceBuilder(type_9471c);
  ::Reflex::Type type_76063 = ::Reflex::ReferenceBuilder(type_4671c);
  ::Reflex::Type type_85666 = ::Reflex::ReferenceBuilder(type_9699);
  ::Reflex::Type type_9927c = ::Reflex::ConstBuilder(type_9927);
  ::Reflex::Type type_85667 = ::Reflex::ReferenceBuilder(type_9927c);
  ::Reflex::Type type_9596c = ::Reflex::ConstBuilder(type_9596);
  ::Reflex::Type type_85570 = ::Reflex::ReferenceBuilder(type_9596c);
  ::Reflex::Type type_4694c = ::Reflex::ConstBuilder(type_4694);
  ::Reflex::Type type_85499 = ::Reflex::PointerBuilder(type_4694c);
  ::Reflex::Type type_9472c = ::Reflex::ConstBuilder(type_9472);
  ::Reflex::Type type_85498 = ::Reflex::ReferenceBuilder(type_9472c);
  ::Reflex::Type type_76097 = ::Reflex::ReferenceBuilder(type_4694c);
  ::Reflex::Type type_85668 = ::Reflex::ReferenceBuilder(type_9700);
  ::Reflex::Type type_9928c = ::Reflex::ConstBuilder(type_9928);
  ::Reflex::Type type_85669 = ::Reflex::ReferenceBuilder(type_9928c);
  ::Reflex::Type type_9597c = ::Reflex::ConstBuilder(type_9597);
  ::Reflex::Type type_85572 = ::Reflex::ReferenceBuilder(type_9597c);
  ::Reflex::Type type_4715c = ::Reflex::ConstBuilder(type_4715);
  ::Reflex::Type type_85502 = ::Reflex::PointerBuilder(type_4715c);
  ::Reflex::Type type_9473c = ::Reflex::ConstBuilder(type_9473);
  ::Reflex::Type type_85501 = ::Reflex::ReferenceBuilder(type_9473c);
  ::Reflex::Type type_76128 = ::Reflex::ReferenceBuilder(type_4715c);
  ::Reflex::Type type_80f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::RefProd<PATFinalStateEventCollection>"), type_80);
  ::Reflex::Type type_96f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::RefVector<PATFinalStateEventCollection,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<PATFinalStateEventCollection,PATFinalStateEvent> >"), type_96);
  ::Reflex::Type type_229f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::RefProd<PATFinalStateCollection>"), type_229);
  ::Reflex::Type type_263f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::RefProd<PATFinalStateLSCollection>"), type_263);
  ::Reflex::Type type_277f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::RefVector<PATFinalStateLSCollection,PATFinalStateLS,edm::refhelper::FindUsingAdvance<PATFinalStateLSCollection,PATFinalStateLS> >"), type_277);
  ::Reflex::Type type_2057f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::RefVector<PATMultiCandFinalStateCollection,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<PATMultiCandFinalStateCollection,PATMultiCandFinalState> >"), type_2057);
  ::Reflex::Type type_2093f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::RefProd<PATMultiCandFinalStateCollection>"), type_2093);
  ::Reflex::Type type_2230f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Ref<PATFinalStateLSCollection,PATFinalStateLS,edm::refhelper::FindUsingAdvance<PATFinalStateLSCollection,PATFinalStateLS> >"), type_2230);
  ::Reflex::Type type_2399f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Ref<PATMultiCandFinalStateCollection,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<PATMultiCandFinalStateCollection,PATMultiCandFinalState> >"), type_2399);
  ::Reflex::Type type_2787f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::RefVector<PATFinalStateCollection,PATFinalState,edm::refhelper::FindUsingAdvance<PATFinalStateCollection,PATFinalState> >"), type_2787);
  ::Reflex::Type type_3065f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Ref<PATFinalStateEventCollection,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<PATFinalStateEventCollection,PATFinalStateEvent> >"), type_3065);
  ::Reflex::Type type_3090f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Ref<PATFinalStateCollection,PATFinalState,edm::refhelper::FindUsingAdvance<PATFinalStateCollection,PATFinalState> >"), type_3090);
  ::Reflex::Type type_9142f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATMuMuPhoPhoFinalStateCollection>"), type_9142);
  ::Reflex::Type type_9143f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATMuMuPhoPhoFinalState>"), type_9143);
  ::Reflex::Type type_9144f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATMuMuTauTauFinalStateCollection>"), type_9144);
  ::Reflex::Type type_9145f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATMuMuTauTauFinalState>"), type_9145);
  ::Reflex::Type type_9146f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATMuMuMuPhoFinalStateCollection>"), type_9146);
  ::Reflex::Type type_9147f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATMuMuMuPhoFinalState>"), type_9147);
  ::Reflex::Type type_9148f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATMuMuMuTauFinalStateCollection>"), type_9148);
  ::Reflex::Type type_9149f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATMuMuMuTauFinalState>"), type_9149);
  ::Reflex::Type type_9150f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATMuMuMuMuFinalStateCollection>"), type_9150);
  ::Reflex::Type type_9151f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATMuMuMuMuFinalState>"), type_9151);
  ::Reflex::Type type_9152f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecMuPhoPhoFinalStateCollection>"), type_9152);
  ::Reflex::Type type_9153f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecMuPhoPhoFinalState>"), type_9153);
  ::Reflex::Type type_9154f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecMuTauTauFinalStateCollection>"), type_9154);
  ::Reflex::Type type_9155f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecMuTauTauFinalState>"), type_9155);
  ::Reflex::Type type_9156f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecMuMuPhoFinalStateCollection>"), type_9156);
  ::Reflex::Type type_9157f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecMuMuPhoFinalState>"), type_9157);
  ::Reflex::Type type_9158f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecMuMuTauFinalStateCollection>"), type_9158);
  ::Reflex::Type type_9159f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecMuMuTauFinalState>"), type_9159);
  ::Reflex::Type type_9160f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecMuMuMuFinalStateCollection>"), type_9160);
  ::Reflex::Type type_9161f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecMuMuMuFinalState>"), type_9161);
  ::Reflex::Type type_9162f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecElecPhoPhoFinalStateCollection>"), type_9162);
  ::Reflex::Type type_9163f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecElecPhoPhoFinalState>"), type_9163);
  ::Reflex::Type type_9164f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecElecTauTauFinalStateCollection>"), type_9164);
  ::Reflex::Type type_9165f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecElecTauTauFinalState>"), type_9165);
  ::Reflex::Type type_9166f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecElecMuPhoFinalStateCollection>"), type_9166);
  ::Reflex::Type type_9167f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecElecMuPhoFinalState>"), type_9167);
  ::Reflex::Type type_9168f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecElecMuTauFinalStateCollection>"), type_9168);
  ::Reflex::Type type_9169f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecElecMuTauFinalState>"), type_9169);
  ::Reflex::Type type_9170f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecElecMuMuFinalStateCollection>"), type_9170);
  ::Reflex::Type type_9171f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecElecMuMuFinalState>"), type_9171);
  ::Reflex::Type type_9172f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecElecElecPhoFinalStateCollection>"), type_9172);
  ::Reflex::Type type_9173f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecElecElecPhoFinalState>"), type_9173);
  ::Reflex::Type type_9174f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecElecElecTauFinalStateCollection>"), type_9174);
  ::Reflex::Type type_9175f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecElecElecTauFinalState>"), type_9175);
  ::Reflex::Type type_9176f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecElecElecMuFinalStateCollection>"), type_9176);
  ::Reflex::Type type_9177f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecElecElecMuFinalState>"), type_9177);
  ::Reflex::Type type_9178f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecElecElecElecFinalStateCollection>"), type_9178);
  ::Reflex::Type type_9179f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecElecElecElecFinalState>"), type_9179);
  ::Reflex::Type type_9180f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATMuJetJetFinalStateCollection>"), type_9180);
  ::Reflex::Type type_9181f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATMuJetJetFinalState>"), type_9181);
  ::Reflex::Type type_9182f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATMuPhoPhoFinalStateCollection>"), type_9182);
  ::Reflex::Type type_9183f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATMuPhoPhoFinalState>"), type_9183);
  ::Reflex::Type type_9184f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATMuTauTauFinalStateCollection>"), type_9184);
  ::Reflex::Type type_9185f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATMuTauTauFinalState>"), type_9185);
  ::Reflex::Type type_9186f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATMuMuPhoFinalStateCollection>"), type_9186);
  ::Reflex::Type type_9187f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATMuMuPhoFinalState>"), type_9187);
  ::Reflex::Type type_9188f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATMuMuTauFinalStateCollection>"), type_9188);
  ::Reflex::Type type_9189f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATMuMuTauFinalState>"), type_9189);
  ::Reflex::Type type_9190f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATMuMuMuFinalStateCollection>"), type_9190);
  ::Reflex::Type type_9191f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATMuMuMuFinalState>"), type_9191);
  ::Reflex::Type type_9192f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecPhoPhoFinalStateCollection>"), type_9192);
  ::Reflex::Type type_9193f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecPhoPhoFinalState>"), type_9193);
  ::Reflex::Type type_9194f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecTauTauFinalStateCollection>"), type_9194);
  ::Reflex::Type type_9195f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecTauTauFinalState>"), type_9195);
  ::Reflex::Type type_9196f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecMuPhoFinalStateCollection>"), type_9196);
  ::Reflex::Type type_9197f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecMuPhoFinalState>"), type_9197);
  ::Reflex::Type type_9198f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecMuTauFinalStateCollection>"), type_9198);
  ::Reflex::Type type_9199f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecMuTauFinalState>"), type_9199);
  ::Reflex::Type type_9200f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecMuMuFinalStateCollection>"), type_9200);
  ::Reflex::Type type_9201f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecMuMuFinalState>"), type_9201);
  ::Reflex::Type type_9202f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecElecPhoFinalStateCollection>"), type_9202);
  ::Reflex::Type type_9203f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecElecPhoFinalState>"), type_9203);
  ::Reflex::Type type_9204f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecElecTauFinalStateCollection>"), type_9204);
  ::Reflex::Type type_9205f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecElecTauFinalState>"), type_9205);
  ::Reflex::Type type_9206f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecElecMuFinalStateCollection>"), type_9206);
  ::Reflex::Type type_9207f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecElecMuFinalState>"), type_9207);
  ::Reflex::Type type_9208f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecElecElecFinalStateCollection>"), type_9208);
  ::Reflex::Type type_9209f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecElecElecFinalState>"), type_9209);
  ::Reflex::Type type_9210f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecJetFinalStateCollection>"), type_9210);
  ::Reflex::Type type_9211f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecJetFinalState>"), type_9211);
  ::Reflex::Type type_9212f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATMuJetFinalStateCollection>"), type_9212);
  ::Reflex::Type type_9213f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATMuJetFinalState>"), type_9213);
  ::Reflex::Type type_9214f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATPhoPhoFinalStateCollection>"), type_9214);
  ::Reflex::Type type_9215f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATPhoPhoFinalState>"), type_9215);
  ::Reflex::Type type_9218f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATTauTauFinalStateCollection>"), type_9218);
  ::Reflex::Type type_9219f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATTauTauFinalState>"), type_9219);
  ::Reflex::Type type_9220f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATMuPhoFinalStateCollection>"), type_9220);
  ::Reflex::Type type_9221f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATMuPhoFinalState>"), type_9221);
  ::Reflex::Type type_9222f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATMuTauFinalStateCollection>"), type_9222);
  ::Reflex::Type type_9223f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATMuTauFinalState>"), type_9223);
  ::Reflex::Type type_9224f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATMuMuFinalStateCollection>"), type_9224);
  ::Reflex::Type type_9225f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATMuMuFinalState>"), type_9225);
  ::Reflex::Type type_9226f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecPhoFinalStateCollection>"), type_9226);
  ::Reflex::Type type_9227f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecPhoFinalState>"), type_9227);
  ::Reflex::Type type_9228f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecTauFinalStateCollection>"), type_9228);
  ::Reflex::Type type_9229f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecTauFinalState>"), type_9229);
  ::Reflex::Type type_9230f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecMuFinalStateCollection>"), type_9230);
  ::Reflex::Type type_9231f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecMuFinalState>"), type_9231);
  ::Reflex::Type type_9232f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecElecFinalStateCollection>"), type_9232);
  ::Reflex::Type type_9233f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATElecElecFinalState>"), type_9233);
  ::Reflex::Type type_9234f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATMultiCandFinalStateCollection>"), type_9234);
  ::Reflex::Type type_9236f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATFinalStateLSCollection>"), type_9236);
  ::Reflex::Type type_9238f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATFinalStateEventCollection>"), type_9238);
  ::Reflex::Type type_9240f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<PATFinalStateCollection>"), type_9240);
  ::Reflex::Type type_9696f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::RefProd<pat::PhotonCollection>"), type_9696);
  ::Reflex::Type type_9697f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::RefProd<pat::JetCollection>"), type_9697);
  ::Reflex::Type type_9698f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::RefProd<pat::TauCollection>"), type_9698);
  ::Reflex::Type type_9699f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::RefProd<pat::MuonCollection>"), type_9699);
  ::Reflex::Type type_9700f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::RefProd<pat::ElectronCollection>"), type_9700);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __PATMultiCandFinalState
#undef __PATMultiCandFinalState
#endif
class __PATMultiCandFinalState : public ::PATFinalState {
  public:
  __PATMultiCandFinalState();
  virtual ~__PATMultiCandFinalState() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::reco::CandidatePtr daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATMultiCandFinalState* clone() const throw();
  virtual const ::reco::CandidatePtr daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::reco::CandidatePtrVector& daughterOverlaps(unsigned long, std::string const&) const throw();
  virtual const double daughterCosThetaStar(unsigned long) const throw();
  ::std::vector<edm::Ptr<reco::Candidate> > cands_;
};
#ifdef __PATFinalState
#undef __PATFinalState
#endif
class __PATFinalState : public ::pat::PATObject<reco::LeafCandidate> {
  public:
  __PATFinalState();
  virtual ~__PATFinalState() throw();
  virtual ::PATFinalState* clone() const throw();
  virtual const ::reco::Candidate* daughter(unsigned long) const throw();
  virtual ::reco::CandidatePtr daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual const ::reco::CandidatePtrVector& daughterOverlaps(unsigned long, std::string const&) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::reco::CandidatePtr daughterPtrUnsafe(unsigned long) const throw();
  ::edm::Ptr<PATFinalStateEvent> event_;
};
#ifdef __PATFinalStateEvent
#undef __PATFinalStateEvent
#endif
class __PATFinalStateEvent {
  public:
  __PATFinalStateEvent();
  ::std::map<std::basic_string<char>,float> weights_;
  ::std::map<std::basic_string<char>,int> flags_;
  double rho_;
  ::pat::TriggerEvent triggerEvent_;
  ::edm::Ptr<reco::Vertex> pv_;
  ::edm::PtrVector<reco::Vertex> recoVertices_;
  ::edm::Ptr<pat::MET> met_;
  ::TMatrixD metCovariance_;
  ::std::vector<PileupSummaryInfo> puInfo_;
  ::lhef::HEPEUP lhe_;
  ::reco::GenParticleRefProd genParticles_;
  ::edm::EventID evtID_;
  ::GenEventInfoProduct genEventInfoProduct_;
  ::GenFilterInfo generatorFilter_;
  bool isRealData_;
  ::std::string puScenario_;
  char fsaDataFormatVersion_;
  ::edm::RefProd<std::vector<pat::Electron> > electronRefProd_;
  ::edm::RefProd<std::vector<pat::Muon> > muonRefProd_;
  ::edm::RefProd<std::vector<pat::Tau> > tauRefProd_;
  ::edm::RefProd<std::vector<pat::Jet> > jetRefProd_;
  ::edm::RefProd<std::vector<pat::Photon> > phoRefProd_;
  ::reco::PFCandidateRefProd pfRefProd_;
  ::reco::TrackRefProd tracks_;
  ::reco::GsfTrackRefProd gsfTracks_;
  ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> > mets_;
};
#ifdef __PATFinalStateLS
#undef __PATFinalStateLS
#endif
class __PATFinalStateLS {
  public:
  __PATFinalStateLS();
  ::edm::LuminosityBlockID id_;
  double integratedLumi_;
  double instaneousLumi_;
};
#ifdef __edm__Ptr_PATFinalStateLS_
#undef __edm__Ptr_PATFinalStateLS_
#endif
class __edm__Ptr_PATFinalStateLS_ {
  public:
  __edm__Ptr_PATFinalStateLS_();
  ::edm::RefCore core_;
  unsigned long key_;
};
#ifdef __edm__Ptr_PATFinalStateEvent_
#undef __edm__Ptr_PATFinalStateEvent_
#endif
class __edm__Ptr_PATFinalStateEvent_ {
  public:
  __edm__Ptr_PATFinalStateEvent_();
  ::edm::RefCore core_;
  unsigned long key_;
};
#ifdef __VBFVariables
#undef __VBFVariables
#endif
class __VBFVariables {
  public:
  __VBFVariables();
  void* leadJet;
  void* subleadJet;
  double mass;
  double deta;
  double dphi;
  double pt1;
  double pt2;
  double dijetpt;
  double ditaupt;
  double hrapidity;
  double dijetrapidity;
  double eta1;
  double eta2;
  double dphihj;
  double dphihj_nomet;
  double c1;
  double c2;
  double mva;
  unsigned int jets20;
  unsigned int jets30;
  unsigned int nJets;
};
#ifdef __PATFinalStateProxy
#undef __PATFinalStateProxy
#endif
class __PATFinalStateProxy {
  public:
  __PATFinalStateProxy();
  ::boost::shared_ptr<PATFinalState> finalState_;
};
#ifdef __edm__Ptr_PATMultiCandFinalState_
#undef __edm__Ptr_PATMultiCandFinalState_
#endif
class __edm__Ptr_PATMultiCandFinalState_ {
  public:
  __edm__Ptr_PATMultiCandFinalState_();
  ::edm::RefCore core_;
  unsigned long key_;
};
#ifdef __edm__Ptr_PATFinalState_
#undef __edm__Ptr_PATFinalState_
#endif
class __edm__Ptr_PATFinalState_ {
  public:
  __edm__Ptr_PATFinalState_();
  ::edm::RefCore core_;
  unsigned long key_;
};
#ifdef __std__pair_std__basic_string_char__int_
#undef __std__pair_std__basic_string_char__int_
#endif
struct __std__pair_std__basic_string_char__int_ {
  public:
  __std__pair_std__basic_string_char__int_();
  ::std::basic_string<char> first;
  int second;
};
#ifdef __std__pair_std__basic_string_char__float_
#undef __std__pair_std__basic_string_char__float_
#endif
struct __std__pair_std__basic_string_char__float_ {
  public:
  __std__pair_std__basic_string_char__float_();
  ::std::basic_string<char> first;
  float second;
};
#ifdef __std__vector_PATFinalStatep_
#undef __std__vector_PATFinalStatep_
#endif
class __std__vector_PATFinalStatep_ : protected ::std::_Vector_base<PATFinalState*,std::allocator<PATFinalState*> > {
  public:
  __std__vector_PATFinalStatep_();
};
#ifdef __std__map_std__basic_string_char__edm__Ptr_pat__MET_s_
#undef __std__map_std__basic_string_char__edm__Ptr_pat__MET_s_
#endif
class __std__map_std__basic_string_char__edm__Ptr_pat__MET_s_ {
  public:
  __std__map_std__basic_string_char__edm__Ptr_pat__MET_s_();
  ::std::_Rb_tree<std::basic_string<char>,std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> >,std::_Select1st<std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> > >,std::less<std::basic_string<char> >,std::allocator<std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> > > > _M_t;
};
#ifdef __std__map_std__basic_string_char__int_
#undef __std__map_std__basic_string_char__int_
#endif
class __std__map_std__basic_string_char__int_ {
  public:
  __std__map_std__basic_string_char__int_();
  ::std::_Rb_tree<std::basic_string<char>,std::pair<const std::basic_string<char>,int>,std::_Select1st<std::pair<const std::basic_string<char>,int> >,std::less<std::basic_string<char> >,std::allocator<std::pair<const std::basic_string<char>,int> > > _M_t;
};
#ifdef __std__map_std__basic_string_char__float_
#undef __std__map_std__basic_string_char__float_
#endif
class __std__map_std__basic_string_char__float_ {
  public:
  __std__map_std__basic_string_char__float_();
  ::std::_Rb_tree<std::basic_string<char>,std::pair<const std::basic_string<char>,float>,std::_Select1st<std::pair<const std::basic_string<char>,float> >,std::less<std::basic_string<char> >,std::allocator<std::pair<const std::basic_string<char>,float> > > _M_t;
};
#ifdef __edm__PtrVector_reco__Vertex_
#undef __edm__PtrVector_reco__Vertex_
#endif
class __edm__PtrVector_reco__Vertex_ : public ::edm::PtrVectorBase {
  public:
  __edm__PtrVector_reco__Vertex_();
  virtual ~__edm__PtrVector_reco__Vertex_() throw();
};
#ifdef __edm__Wrapper_PATMultiCandFinalState_
#undef __edm__Wrapper_PATMultiCandFinalState_
#endif
class __edm__Wrapper_PATMultiCandFinalState_ {
  public:
  __edm__Wrapper_PATMultiCandFinalState_();
  bool present;
  ::PATMultiCandFinalState obj;
};
#ifdef __edm__Wrapper_PATFinalStateLS_
#undef __edm__Wrapper_PATFinalStateLS_
#endif
class __edm__Wrapper_PATFinalStateLS_ {
  public:
  __edm__Wrapper_PATFinalStateLS_();
  bool present;
  ::PATFinalStateLS obj;
};
#ifdef __edm__Wrapper_PATFinalStateEvent_
#undef __edm__Wrapper_PATFinalStateEvent_
#endif
class __edm__Wrapper_PATFinalStateEvent_ {
  public:
  __edm__Wrapper_PATFinalStateEvent_();
  bool present;
  ::PATFinalStateEvent obj;
};
#ifdef __edm__Ptr_reco__Vertex_
#undef __edm__Ptr_reco__Vertex_
#endif
class __edm__Ptr_reco__Vertex_ {
  public:
  __edm__Ptr_reco__Vertex_();
  ::edm::RefCore core_;
  unsigned long key_;
};
#ifdef __edm__Ptr_pat__Photon_
#undef __edm__Ptr_pat__Photon_
#endif
class __edm__Ptr_pat__Photon_ {
  public:
  __edm__Ptr_pat__Photon_();
  ::edm::RefCore core_;
  unsigned long key_;
};
#ifdef __PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_
#undef __PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_
#endif
class __PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_ : public ::PATFinalState {
  public:
  __PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_();
  virtual ~__PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Electron> p1_;
  ::edm::Ptr<pat::Photon> p2_;
  ::edm::Ptr<pat::Photon> p3_;
};
#ifdef __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_
#undef __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_
#endif
class __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_ : public ::PATFinalState {
  public:
  __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_();
  virtual ~__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Electron> p1_;
  ::edm::Ptr<pat::Muon> p2_;
  ::edm::Ptr<pat::Muon> p3_;
  ::edm::Ptr<pat::Muon> p4_;
};
#ifdef __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_
#undef __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_
#endif
class __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_ : public ::PATFinalState {
  public:
  __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_();
  virtual ~__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Muon> p1_;
  ::edm::Ptr<pat::Muon> p2_;
  ::edm::Ptr<pat::Muon> p3_;
  ::edm::Ptr<pat::Photon> p4_;
};
#ifdef __PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_
#undef __PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_
#endif
class __PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_ : public ::PATFinalState {
  public:
  __PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_();
  virtual ~__PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Muon> p1_;
  ::edm::Ptr<pat::Muon> p2_;
  ::edm::Ptr<pat::Tau> p3_;
};
#ifdef __std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s_
#undef __std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s_
#endif
class __std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s_ : protected ::std::_Vector_base<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > > {
  public:
  __std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s_();
};
#ifdef __PATPairFinalStateT_pat__Muon_pat__Jet_
#undef __PATPairFinalStateT_pat__Muon_pat__Jet_
#endif
class __PATPairFinalStateT_pat__Muon_pat__Jet_ : public ::PATFinalState {
  public:
  __PATPairFinalStateT_pat__Muon_pat__Jet_();
  virtual ~__PATPairFinalStateT_pat__Muon_pat__Jet_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATPairFinalStateT<pat::Muon,pat::Jet>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Muon> p1_;
  ::edm::Ptr<pat::Jet> p2_;
};
#ifdef __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_
#undef __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_
#endif
class __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_ : public ::PATFinalState {
  public:
  __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_();
  virtual ~__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Muon> p1_;
  ::edm::Ptr<pat::Muon> p2_;
  ::edm::Ptr<pat::Muon> p3_;
  ::edm::Ptr<pat::Tau> p4_;
};
#ifdef __PATPairFinalStateT_pat__Tau_pat__Tau_
#undef __PATPairFinalStateT_pat__Tau_pat__Tau_
#endif
class __PATPairFinalStateT_pat__Tau_pat__Tau_ : public ::PATFinalState {
  public:
  __PATPairFinalStateT_pat__Tau_pat__Tau_();
  virtual ~__PATPairFinalStateT_pat__Tau_pat__Tau_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATPairFinalStateT<pat::Tau,pat::Tau>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Tau> p1_;
  ::edm::Ptr<pat::Tau> p2_;
};
#ifdef __PATPairFinalStateT_pat__Electron_pat__Jet_
#undef __PATPairFinalStateT_pat__Electron_pat__Jet_
#endif
class __PATPairFinalStateT_pat__Electron_pat__Jet_ : public ::PATFinalState {
  public:
  __PATPairFinalStateT_pat__Electron_pat__Jet_();
  virtual ~__PATPairFinalStateT_pat__Electron_pat__Jet_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATPairFinalStateT<pat::Electron,pat::Jet>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Electron> p1_;
  ::edm::Ptr<pat::Jet> p2_;
};
#ifdef __std__vector_PATPairFinalStateT_pat__Electron_pat__Jet_s_
#undef __std__vector_PATPairFinalStateT_pat__Electron_pat__Jet_s_
#endif
class __std__vector_PATPairFinalStateT_pat__Electron_pat__Jet_s_ : protected ::std::_Vector_base<PATPairFinalStateT<pat::Electron,pat::Jet>,std::allocator<PATPairFinalStateT<pat::Electron,pat::Jet> > > {
  public:
  __std__vector_PATPairFinalStateT_pat__Electron_pat__Jet_s_();
};
#ifdef __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_
#undef __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_
#endif
class __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_ : public ::PATFinalState {
  public:
  __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_();
  virtual ~__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Electron> p1_;
  ::edm::Ptr<pat::Electron> p2_;
  ::edm::Ptr<pat::Photon> p3_;
  ::edm::Ptr<pat::Photon> p4_;
};
#ifdef __std__vector_PATFinalStateEvent_
#undef __std__vector_PATFinalStateEvent_
#endif
class __std__vector_PATFinalStateEvent_ : protected ::std::_Vector_base<PATFinalStateEvent,std::allocator<PATFinalStateEvent> > {
  public:
  __std__vector_PATFinalStateEvent_();
};
#ifdef __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_
#undef __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_
#endif
class __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_ : public ::PATFinalState {
  public:
  __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_();
  virtual ~__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Electron> p1_;
  ::edm::Ptr<pat::Electron> p2_;
  ::edm::Ptr<pat::Electron> p3_;
  ::edm::Ptr<pat::Electron> p4_;
};
#ifdef __PATPairFinalStateT_pat__Electron_pat__Muon_
#undef __PATPairFinalStateT_pat__Electron_pat__Muon_
#endif
class __PATPairFinalStateT_pat__Electron_pat__Muon_ : public ::PATFinalState {
  public:
  __PATPairFinalStateT_pat__Electron_pat__Muon_();
  virtual ~__PATPairFinalStateT_pat__Electron_pat__Muon_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATPairFinalStateT<pat::Electron,pat::Muon>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Electron> p1_;
  ::edm::Ptr<pat::Muon> p2_;
};
#ifdef __std__vector_PATPairFinalStateT_pat__Electron_pat__Muon_s_
#undef __std__vector_PATPairFinalStateT_pat__Electron_pat__Muon_s_
#endif
class __std__vector_PATPairFinalStateT_pat__Electron_pat__Muon_s_ : protected ::std::_Vector_base<PATPairFinalStateT<pat::Electron,pat::Muon>,std::allocator<PATPairFinalStateT<pat::Electron,pat::Muon> > > {
  public:
  __std__vector_PATPairFinalStateT_pat__Electron_pat__Muon_s_();
};
#ifdef __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_
#undef __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_
#endif
class __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_ : public ::PATFinalState {
  public:
  __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_();
  virtual ~__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Electron> p1_;
  ::edm::Ptr<pat::Electron> p2_;
  ::edm::Ptr<pat::Muon> p3_;
  ::edm::Ptr<pat::Tau> p4_;
};
#ifdef __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s_
#undef __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s_
#endif
class __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s_ : protected ::std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > > {
  public:
  __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s_();
};
#ifdef __PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_
#undef __PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_
#endif
class __PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_ : public ::PATFinalState {
  public:
  __PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_();
  virtual ~__PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Muon> p1_;
  ::edm::Ptr<pat::Jet> p2_;
  ::edm::Ptr<pat::Jet> p3_;
};
#ifdef __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s_
#undef __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s_
#endif
class __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s_ : protected ::std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > > {
  public:
  __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s_();
};
#ifdef __PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_
#undef __PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_
#endif
class __PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_ : public ::PATFinalState {
  public:
  __PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_();
  virtual ~__PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Electron> p1_;
  ::edm::Ptr<pat::Tau> p2_;
  ::edm::Ptr<pat::Tau> p3_;
};
#ifdef __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_
#undef __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_
#endif
class __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_ : public ::PATFinalState {
  public:
  __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_();
  virtual ~__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Electron> p1_;
  ::edm::Ptr<pat::Electron> p2_;
  ::edm::Ptr<pat::Muon> p3_;
  ::edm::Ptr<pat::Muon> p4_;
};
#ifdef __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_
#undef __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_
#endif
class __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_ : public ::PATFinalState {
  public:
  __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_();
  virtual ~__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Electron> p1_;
  ::edm::Ptr<pat::Electron> p2_;
  ::edm::Ptr<pat::Muon> p3_;
  ::edm::Ptr<pat::Photon> p4_;
};
#ifdef __PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_
#undef __PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_
#endif
class __PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_ : public ::PATFinalState {
  public:
  __PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_();
  virtual ~__PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Muon> p1_;
  ::edm::Ptr<pat::Muon> p2_;
  ::edm::Ptr<pat::Photon> p3_;
};
#ifdef __PATPairFinalStateT_pat__Muon_pat__Muon_
#undef __PATPairFinalStateT_pat__Muon_pat__Muon_
#endif
class __PATPairFinalStateT_pat__Muon_pat__Muon_ : public ::PATFinalState {
  public:
  __PATPairFinalStateT_pat__Muon_pat__Muon_();
  virtual ~__PATPairFinalStateT_pat__Muon_pat__Muon_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATPairFinalStateT<pat::Muon,pat::Muon>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Muon> p1_;
  ::edm::Ptr<pat::Muon> p2_;
};
#ifdef __std__vector_PATPairFinalStateT_pat__Muon_pat__Muon_s_
#undef __std__vector_PATPairFinalStateT_pat__Muon_pat__Muon_s_
#endif
class __std__vector_PATPairFinalStateT_pat__Muon_pat__Muon_s_ : protected ::std::_Vector_base<PATPairFinalStateT<pat::Muon,pat::Muon>,std::allocator<PATPairFinalStateT<pat::Muon,pat::Muon> > > {
  public:
  __std__vector_PATPairFinalStateT_pat__Muon_pat__Muon_s_();
};
#ifdef __edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s_
#undef __edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s_
#endif
class __edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s_ {
  public:
  __edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s_();
  ::std::vector<PATFinalState*> data_;
};
#ifdef __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_
#undef __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_
#endif
class __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_ : public ::PATFinalState {
  public:
  __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_();
  virtual ~__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Electron> p1_;
  ::edm::Ptr<pat::Electron> p2_;
  ::edm::Ptr<pat::Tau> p3_;
  ::edm::Ptr<pat::Tau> p4_;
};
#ifdef __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_
#undef __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_
#endif
class __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_ : public ::PATFinalState {
  public:
  __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_();
  virtual ~__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Electron> p1_;
  ::edm::Ptr<pat::Muon> p2_;
  ::edm::Ptr<pat::Tau> p3_;
  ::edm::Ptr<pat::Tau> p4_;
};
#ifdef __PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_
#undef __PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_
#endif
class __PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_ : public ::PATFinalState {
  public:
  __PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_();
  virtual ~__PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Muon> p1_;
  ::edm::Ptr<pat::Muon> p2_;
  ::edm::Ptr<pat::Muon> p3_;
};
#ifdef __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_
#undef __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_
#endif
class __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_ : public ::PATFinalState {
  public:
  __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_();
  virtual ~__PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Electron> p1_;
  ::edm::Ptr<pat::Electron> p2_;
  ::edm::Ptr<pat::Tau> p3_;
};
#ifdef __PATPairFinalStateT_pat__Photon_pat__Photon_
#undef __PATPairFinalStateT_pat__Photon_pat__Photon_
#endif
class __PATPairFinalStateT_pat__Photon_pat__Photon_ : public ::PATFinalState {
  public:
  __PATPairFinalStateT_pat__Photon_pat__Photon_();
  virtual ~__PATPairFinalStateT_pat__Photon_pat__Photon_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATPairFinalStateT<pat::Photon,pat::Photon>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Photon> p1_;
  ::edm::Ptr<pat::Photon> p2_;
};
#ifdef __PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_
#undef __PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_
#endif
class __PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_ : public ::PATFinalState {
  public:
  __PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_();
  virtual ~__PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Muon> p1_;
  ::edm::Ptr<pat::Photon> p2_;
  ::edm::Ptr<pat::Photon> p3_;
};
#ifdef __std__vector_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s_
#undef __std__vector_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s_
#endif
class __std__vector_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s_ : protected ::std::_Vector_base<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > > {
  public:
  __std__vector_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s_();
};
#ifdef __std__vector_PATPairFinalStateT_pat__Photon_pat__Photon_s_
#undef __std__vector_PATPairFinalStateT_pat__Photon_pat__Photon_s_
#endif
class __std__vector_PATPairFinalStateT_pat__Photon_pat__Photon_s_ : protected ::std::_Vector_base<PATPairFinalStateT<pat::Photon,pat::Photon>,std::allocator<PATPairFinalStateT<pat::Photon,pat::Photon> > > {
  public:
  __std__vector_PATPairFinalStateT_pat__Photon_pat__Photon_s_();
};
#ifdef __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s_
#undef __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s_
#endif
class __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s_ : protected ::std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > > {
  public:
  __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s_();
};
#ifdef __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s_
#undef __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s_
#endif
class __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s_ : protected ::std::_Vector_base<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > > {
  public:
  __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s_();
};
#ifdef __std__vector_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s_
#undef __std__vector_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s_
#endif
class __std__vector_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s_ : protected ::std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > > {
  public:
  __std__vector_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s_();
};
#ifdef __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_
#undef __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_
#endif
class __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_ : public ::PATFinalState {
  public:
  __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_();
  virtual ~__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Electron> p1_;
  ::edm::Ptr<pat::Muon> p2_;
  ::edm::Ptr<pat::Muon> p3_;
  ::edm::Ptr<pat::Tau> p4_;
};
#ifdef __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s_
#undef __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s_
#endif
class __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s_ : protected ::std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > > {
  public:
  __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s_();
};
#ifdef __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_
#undef __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_
#endif
class __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_ : public ::PATFinalState {
  public:
  __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_();
  virtual ~__PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Electron> p1_;
  ::edm::Ptr<pat::Electron> p2_;
  ::edm::Ptr<pat::Photon> p3_;
};
#ifdef __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_
#undef __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_
#endif
class __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_ : public ::PATFinalState {
  public:
  __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_();
  virtual ~__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Muon> p1_;
  ::edm::Ptr<pat::Muon> p2_;
  ::edm::Ptr<pat::Tau> p3_;
  ::edm::Ptr<pat::Tau> p4_;
};
#ifdef __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s_
#undef __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s_
#endif
class __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s_ : protected ::std::_Vector_base<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > > {
  public:
  __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s_();
};
#ifdef __PATPairFinalStateT_pat__Muon_pat__Photon_
#undef __PATPairFinalStateT_pat__Muon_pat__Photon_
#endif
class __PATPairFinalStateT_pat__Muon_pat__Photon_ : public ::PATFinalState {
  public:
  __PATPairFinalStateT_pat__Muon_pat__Photon_();
  virtual ~__PATPairFinalStateT_pat__Muon_pat__Photon_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATPairFinalStateT<pat::Muon,pat::Photon>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Muon> p1_;
  ::edm::Ptr<pat::Photon> p2_;
};
#ifdef __PATPairFinalStateT_pat__Muon_pat__Tau_
#undef __PATPairFinalStateT_pat__Muon_pat__Tau_
#endif
class __PATPairFinalStateT_pat__Muon_pat__Tau_ : public ::PATFinalState {
  public:
  __PATPairFinalStateT_pat__Muon_pat__Tau_();
  virtual ~__PATPairFinalStateT_pat__Muon_pat__Tau_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATPairFinalStateT<pat::Muon,pat::Tau>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Muon> p1_;
  ::edm::Ptr<pat::Tau> p2_;
};
#ifdef __std__vector_PATPairFinalStateT_pat__Muon_pat__Tau_s_
#undef __std__vector_PATPairFinalStateT_pat__Muon_pat__Tau_s_
#endif
class __std__vector_PATPairFinalStateT_pat__Muon_pat__Tau_s_ : protected ::std::_Vector_base<PATPairFinalStateT<pat::Muon,pat::Tau>,std::allocator<PATPairFinalStateT<pat::Muon,pat::Tau> > > {
  public:
  __std__vector_PATPairFinalStateT_pat__Muon_pat__Tau_s_();
};
#ifdef __PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_
#undef __PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_
#endif
class __PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_ : public ::PATFinalState {
  public:
  __PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_();
  virtual ~__PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Electron> p1_;
  ::edm::Ptr<pat::Muon> p2_;
  ::edm::Ptr<pat::Tau> p3_;
};
#ifdef __PATPairFinalStateT_pat__Electron_pat__Electron_
#undef __PATPairFinalStateT_pat__Electron_pat__Electron_
#endif
class __PATPairFinalStateT_pat__Electron_pat__Electron_ : public ::PATFinalState {
  public:
  __PATPairFinalStateT_pat__Electron_pat__Electron_();
  virtual ~__PATPairFinalStateT_pat__Electron_pat__Electron_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATPairFinalStateT<pat::Electron,pat::Electron>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Electron> p1_;
  ::edm::Ptr<pat::Electron> p2_;
};
#ifdef __std__vector_PATPairFinalStateT_pat__Electron_pat__Electron_s_
#undef __std__vector_PATPairFinalStateT_pat__Electron_pat__Electron_s_
#endif
class __std__vector_PATPairFinalStateT_pat__Electron_pat__Electron_s_ : protected ::std::_Vector_base<PATPairFinalStateT<pat::Electron,pat::Electron>,std::allocator<PATPairFinalStateT<pat::Electron,pat::Electron> > > {
  public:
  __std__vector_PATPairFinalStateT_pat__Electron_pat__Electron_s_();
};
#ifdef __PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_
#undef __PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_
#endif
class __PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_ : public ::PATFinalState {
  public:
  __PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_();
  virtual ~__PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Electron> p1_;
  ::edm::Ptr<pat::Muon> p2_;
  ::edm::Ptr<pat::Photon> p3_;
};
#ifdef __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_
#undef __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_
#endif
class __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_ : public ::PATFinalState {
  public:
  __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_();
  virtual ~__PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Electron> p1_;
  ::edm::Ptr<pat::Electron> p2_;
  ::edm::Ptr<pat::Electron> p3_;
};
#ifdef __std__vector_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s_
#undef __std__vector_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s_
#endif
class __std__vector_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s_ : protected ::std::_Vector_base<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>,std::allocator<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > > {
  public:
  __std__vector_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s_();
};
#ifdef __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s_
#undef __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s_
#endif
class __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s_ : protected ::std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > > {
  public:
  __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s_();
};
#ifdef __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_
#undef __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_
#endif
class __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_ : public ::PATFinalState {
  public:
  __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_();
  virtual ~__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Electron> p1_;
  ::edm::Ptr<pat::Muon> p2_;
  ::edm::Ptr<pat::Photon> p3_;
  ::edm::Ptr<pat::Photon> p4_;
};
#ifdef __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s_
#undef __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s_
#endif
class __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s_ : protected ::std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > > {
  public:
  __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s_();
};
#ifdef __std__vector_PATPairFinalStateT_pat__Muon_pat__Jet_s_
#undef __std__vector_PATPairFinalStateT_pat__Muon_pat__Jet_s_
#endif
class __std__vector_PATPairFinalStateT_pat__Muon_pat__Jet_s_ : protected ::std::_Vector_base<PATPairFinalStateT<pat::Muon,pat::Jet>,std::allocator<PATPairFinalStateT<pat::Muon,pat::Jet> > > {
  public:
  __std__vector_PATPairFinalStateT_pat__Muon_pat__Jet_s_();
};
#ifdef __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_
#undef __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_
#endif
class __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_ : public ::PATFinalState {
  public:
  __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_();
  virtual ~__PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Electron> p1_;
  ::edm::Ptr<pat::Electron> p2_;
  ::edm::Ptr<pat::Muon> p3_;
};
#ifdef __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s_
#undef __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s_
#endif
class __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s_ : protected ::std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > > {
  public:
  __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s_();
};
#ifdef __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s_
#undef __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s_
#endif
class __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s_ : protected ::std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > > {
  public:
  __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s_();
};
#ifdef __PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_
#undef __PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_
#endif
class __PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_ : public ::PATFinalState {
  public:
  __PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_();
  virtual ~__PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Electron> p1_;
  ::edm::Ptr<pat::Muon> p2_;
  ::edm::Ptr<pat::Muon> p3_;
};
#ifdef __std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s_
#undef __std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s_
#endif
class __std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s_ : protected ::std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > > {
  public:
  __std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s_();
};
#ifdef __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s_
#undef __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s_
#endif
class __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s_ : protected ::std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > > {
  public:
  __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s_();
};
#ifdef __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_
#undef __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_
#endif
class __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_ : public ::PATFinalState {
  public:
  __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_();
  virtual ~__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Electron> p1_;
  ::edm::Ptr<pat::Muon> p2_;
  ::edm::Ptr<pat::Muon> p3_;
  ::edm::Ptr<pat::Photon> p4_;
};
#ifdef __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s_
#undef __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s_
#endif
class __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s_ : protected ::std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > > {
  public:
  __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s_();
};
#ifdef __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s_
#undef __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s_
#endif
class __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s_ : protected ::std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > > {
  public:
  __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s_();
};
#ifdef __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_
#undef __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_
#endif
class __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_ : public ::PATFinalState {
  public:
  __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_();
  virtual ~__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Electron> p1_;
  ::edm::Ptr<pat::Electron> p2_;
  ::edm::Ptr<pat::Electron> p3_;
  ::edm::Ptr<pat::Photon> p4_;
};
#ifdef __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s_
#undef __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s_
#endif
class __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s_ : protected ::std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > > {
  public:
  __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s_();
};
#ifdef __std__vector_PATFinalStateLS_
#undef __std__vector_PATFinalStateLS_
#endif
class __std__vector_PATFinalStateLS_ : protected ::std::_Vector_base<PATFinalStateLS,std::allocator<PATFinalStateLS> > {
  public:
  __std__vector_PATFinalStateLS_();
};
#ifdef __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_
#undef __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_
#endif
class __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_ : public ::PATFinalState {
  public:
  __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_();
  virtual ~__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Muon> p1_;
  ::edm::Ptr<pat::Muon> p2_;
  ::edm::Ptr<pat::Muon> p3_;
  ::edm::Ptr<pat::Muon> p4_;
};
#ifdef __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s_
#undef __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s_
#endif
class __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s_ : protected ::std::_Vector_base<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>,std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > > {
  public:
  __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s_();
};
#ifdef __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s_
#undef __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s_
#endif
class __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s_ : protected ::std::_Vector_base<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > > {
  public:
  __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s_();
};
#ifdef __PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_
#undef __PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_
#endif
class __PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_ : public ::PATFinalState {
  public:
  __PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_();
  virtual ~__PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Muon> p1_;
  ::edm::Ptr<pat::Tau> p2_;
  ::edm::Ptr<pat::Tau> p3_;
};
#ifdef __PATPairFinalStateT_pat__Electron_pat__Photon_
#undef __PATPairFinalStateT_pat__Electron_pat__Photon_
#endif
class __PATPairFinalStateT_pat__Electron_pat__Photon_ : public ::PATFinalState {
  public:
  __PATPairFinalStateT_pat__Electron_pat__Photon_();
  virtual ~__PATPairFinalStateT_pat__Electron_pat__Photon_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATPairFinalStateT<pat::Electron,pat::Photon>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Electron> p1_;
  ::edm::Ptr<pat::Photon> p2_;
};
#ifdef __std__vector_PATPairFinalStateT_pat__Electron_pat__Photon_s_
#undef __std__vector_PATPairFinalStateT_pat__Electron_pat__Photon_s_
#endif
class __std__vector_PATPairFinalStateT_pat__Electron_pat__Photon_s_ : protected ::std::_Vector_base<PATPairFinalStateT<pat::Electron,pat::Photon>,std::allocator<PATPairFinalStateT<pat::Electron,pat::Photon> > > {
  public:
  __std__vector_PATPairFinalStateT_pat__Electron_pat__Photon_s_();
};
#ifdef __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_
#undef __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_
#endif
class __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_ : public ::PATFinalState {
  public:
  __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_();
  virtual ~__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Muon> p1_;
  ::edm::Ptr<pat::Muon> p2_;
  ::edm::Ptr<pat::Photon> p3_;
  ::edm::Ptr<pat::Photon> p4_;
};
#ifdef __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_
#undef __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_
#endif
class __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_ : public ::PATFinalState {
  public:
  __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_();
  virtual ~__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Electron> p1_;
  ::edm::Ptr<pat::Electron> p2_;
  ::edm::Ptr<pat::Electron> p3_;
  ::edm::Ptr<pat::Tau> p4_;
};
#ifdef __PATPairFinalStateT_pat__Electron_pat__Tau_
#undef __PATPairFinalStateT_pat__Electron_pat__Tau_
#endif
class __PATPairFinalStateT_pat__Electron_pat__Tau_ : public ::PATFinalState {
  public:
  __PATPairFinalStateT_pat__Electron_pat__Tau_();
  virtual ~__PATPairFinalStateT_pat__Electron_pat__Tau_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATPairFinalStateT<pat::Electron,pat::Tau>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Electron> p1_;
  ::edm::Ptr<pat::Tau> p2_;
};
#ifdef __std__vector_PATPairFinalStateT_pat__Electron_pat__Tau_s_
#undef __std__vector_PATPairFinalStateT_pat__Electron_pat__Tau_s_
#endif
class __std__vector_PATPairFinalStateT_pat__Electron_pat__Tau_s_ : protected ::std::_Vector_base<PATPairFinalStateT<pat::Electron,pat::Tau>,std::allocator<PATPairFinalStateT<pat::Electron,pat::Tau> > > {
  public:
  __std__vector_PATPairFinalStateT_pat__Electron_pat__Tau_s_();
};
#ifdef __std__vector_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s_
#undef __std__vector_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s_
#endif
class __std__vector_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s_ : protected ::std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > > {
  public:
  __std__vector_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s_();
};
#ifdef __std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s_
#undef __std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s_
#endif
class __std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s_ : protected ::std::_Vector_base<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>,std::allocator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > > {
  public:
  __std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s_();
};
#ifdef __std__vector_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s_
#undef __std__vector_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s_
#endif
class __std__vector_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s_ : protected ::std::_Vector_base<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > > {
  public:
  __std__vector_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s_();
};
#ifdef __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s_
#undef __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s_
#endif
class __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s_ : protected ::std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > > {
  public:
  __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s_();
};
#ifdef __std__vector_PATMultiCandFinalState_
#undef __std__vector_PATMultiCandFinalState_
#endif
class __std__vector_PATMultiCandFinalState_ : protected ::std::_Vector_base<PATMultiCandFinalState,std::allocator<PATMultiCandFinalState> > {
  public:
  __std__vector_PATMultiCandFinalState_();
};
#ifdef __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_
#undef __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_
#endif
class __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_ : public ::PATFinalState {
  public:
  __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_();
  virtual ~__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_() throw();
  virtual ::size_t numberOfDaughters() const throw();
  virtual ::edm::Ptr<reco::Candidate> daughterUserCandUnsafe(unsigned long, std::string const&) const throw();
  virtual ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>* clone() const throw();
  virtual const ::edm::Ptr<reco::Candidate> daughterPtrUnsafe(unsigned long) const throw();
  virtual const ::reco::Candidate* daughterUnsafe(unsigned long) const throw();
  virtual const ::edm::PtrVector<reco::Candidate>& daughterOverlaps(unsigned long, std::string const&) const throw();
  ::edm::Ptr<pat::Electron> p1_;
  ::edm::Ptr<pat::Electron> p2_;
  ::edm::Ptr<pat::Electron> p3_;
  ::edm::Ptr<pat::Muon> p4_;
};
#ifdef __std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s_
#undef __std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s_
#endif
class __std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s_ : protected ::std::_Vector_base<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > > {
  public:
  __std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s_();
};
#ifdef __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s_
#undef __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s_
#endif
class __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s_ : protected ::std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > > {
  public:
  __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s_();
};
#ifdef __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s_
#undef __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s_
#endif
class __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s_ : protected ::std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > > {
  public:
  __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s_();
};
#ifdef __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s_
#undef __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s_
#endif
class __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s_ : protected ::std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > > {
  public:
  __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s_();
};
#ifdef __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s_
#undef __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s_
#endif
class __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s_ : protected ::std::_Vector_base<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > > {
  public:
  __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s_();
};
#ifdef __std__vector_PATPairFinalStateT_pat__Tau_pat__Tau_s_
#undef __std__vector_PATPairFinalStateT_pat__Tau_pat__Tau_s_
#endif
class __std__vector_PATPairFinalStateT_pat__Tau_pat__Tau_s_ : protected ::std::_Vector_base<PATPairFinalStateT<pat::Tau,pat::Tau>,std::allocator<PATPairFinalStateT<pat::Tau,pat::Tau> > > {
  public:
  __std__vector_PATPairFinalStateT_pat__Tau_pat__Tau_s_();
};
#ifdef __std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s_
#undef __std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s_
#endif
class __std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s_ : protected ::std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > > {
  public:
  __std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s_();
};
#ifdef __std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s_
#undef __std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s_
#endif
class __std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s_ : protected ::std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > > {
  public:
  __std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s_();
};
#ifdef __std__vector_PATPairFinalStateT_pat__Muon_pat__Photon_s_
#undef __std__vector_PATPairFinalStateT_pat__Muon_pat__Photon_s_
#endif
class __std__vector_PATPairFinalStateT_pat__Muon_pat__Photon_s_ : protected ::std::_Vector_base<PATPairFinalStateT<pat::Muon,pat::Photon>,std::allocator<PATPairFinalStateT<pat::Muon,pat::Photon> > > {
  public:
  __std__vector_PATPairFinalStateT_pat__Muon_pat__Photon_s_();
};
#ifdef __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s_
#undef __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s_
#endif
class __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s_ : protected ::std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > > {
  public:
  __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s_();
};
#ifdef __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s_
#undef __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s_
#endif
class __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s_ : protected ::std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > > {
  public:
  __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s_();
};
#ifdef __edm__RefProd_std__vector_PATFinalStateEvent_s_
#undef __edm__RefProd_std__vector_PATFinalStateEvent_s_
#endif
class __edm__RefProd_std__vector_PATFinalStateEvent_s_ {
  public:
  __edm__RefProd_std__vector_PATFinalStateEvent_s_();
  ::edm::RefCore product_;
};
#ifdef __edm__RefVector_std__vector_PATFinalStateEvent__PATFinalStateEvent_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateEvent__PATFinalStateEvent_s_
#undef __edm__RefVector_std__vector_PATFinalStateEvent__PATFinalStateEvent_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateEvent__PATFinalStateEvent_s_
#endif
class __edm__RefVector_std__vector_PATFinalStateEvent__PATFinalStateEvent_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateEvent__PATFinalStateEvent_s_ {
  public:
  __edm__RefVector_std__vector_PATFinalStateEvent__PATFinalStateEvent_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateEvent__PATFinalStateEvent_s_();
  ::edm::RefVectorBase<unsigned int> refVector_;
};
#ifdef __edm__RefProd_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s_s_
#undef __edm__RefProd_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s_s_
#endif
class __edm__RefProd_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s_s_ {
  public:
  __edm__RefProd_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s_s_();
  ::edm::RefCore product_;
};
#ifdef __edm__RefProd_std__vector_PATFinalStateLS_s_
#undef __edm__RefProd_std__vector_PATFinalStateLS_s_
#endif
class __edm__RefProd_std__vector_PATFinalStateLS_s_ {
  public:
  __edm__RefProd_std__vector_PATFinalStateLS_s_();
  ::edm::RefCore product_;
};
#ifdef __edm__RefVector_std__vector_PATFinalStateLS__PATFinalStateLS_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateLS__PATFinalStateLS_s_
#undef __edm__RefVector_std__vector_PATFinalStateLS__PATFinalStateLS_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateLS__PATFinalStateLS_s_
#endif
class __edm__RefVector_std__vector_PATFinalStateLS__PATFinalStateLS_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateLS__PATFinalStateLS_s_ {
  public:
  __edm__RefVector_std__vector_PATFinalStateLS__PATFinalStateLS_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateLS__PATFinalStateLS_s_();
  ::edm::RefVectorBase<unsigned int> refVector_;
};
#ifdef __edm__RefVector_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_edm__refhelper__FindUsingAdvance_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_s_
#undef __edm__RefVector_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_edm__refhelper__FindUsingAdvance_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_s_
#endif
class __edm__RefVector_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_edm__refhelper__FindUsingAdvance_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_s_ {
  public:
  __edm__RefVector_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_edm__refhelper__FindUsingAdvance_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_s_();
  ::edm::RefVectorBase<unsigned int> refVector_;
};
#ifdef __edm__RefProd_std__vector_PATMultiCandFinalState_s_
#undef __edm__RefProd_std__vector_PATMultiCandFinalState_s_
#endif
class __edm__RefProd_std__vector_PATMultiCandFinalState_s_ {
  public:
  __edm__RefProd_std__vector_PATMultiCandFinalState_s_();
  ::edm::RefCore product_;
};
#ifdef __edm__Ref_std__vector_PATFinalStateLS__PATFinalStateLS_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateLS__PATFinalStateLS_s_
#undef __edm__Ref_std__vector_PATFinalStateLS__PATFinalStateLS_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateLS__PATFinalStateLS_s_
#endif
class __edm__Ref_std__vector_PATFinalStateLS__PATFinalStateLS_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateLS__PATFinalStateLS_s_ {
  public:
  __edm__Ref_std__vector_PATFinalStateLS__PATFinalStateLS_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateLS__PATFinalStateLS_s_();
  ::edm::RefCoreWithIndex product_;
};
#ifdef __edm__Ref_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_edm__refhelper__FindUsingAdvance_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_s_
#undef __edm__Ref_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_edm__refhelper__FindUsingAdvance_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_s_
#endif
class __edm__Ref_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_edm__refhelper__FindUsingAdvance_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_s_ {
  public:
  __edm__Ref_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_edm__refhelper__FindUsingAdvance_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_s_();
  ::edm::RefCoreWithIndex product_;
};
#ifdef __edm__RefVector_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_edm__refhelper__FindUsingAdvance_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_s_
#undef __edm__RefVector_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_edm__refhelper__FindUsingAdvance_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_s_
#endif
class __edm__RefVector_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_edm__refhelper__FindUsingAdvance_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_s_ {
  public:
  __edm__RefVector_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_edm__refhelper__FindUsingAdvance_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_s_();
  ::edm::RefVectorBase<unsigned int> refVector_;
};
#ifdef __edm__Ref_std__vector_PATFinalStateEvent__PATFinalStateEvent_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateEvent__PATFinalStateEvent_s_
#undef __edm__Ref_std__vector_PATFinalStateEvent__PATFinalStateEvent_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateEvent__PATFinalStateEvent_s_
#endif
class __edm__Ref_std__vector_PATFinalStateEvent__PATFinalStateEvent_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateEvent__PATFinalStateEvent_s_ {
  public:
  __edm__Ref_std__vector_PATFinalStateEvent__PATFinalStateEvent_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateEvent__PATFinalStateEvent_s_();
  ::edm::RefCoreWithIndex product_;
};
#ifdef __edm__Ref_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_edm__refhelper__FindUsingAdvance_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_s_
#undef __edm__Ref_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_edm__refhelper__FindUsingAdvance_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_s_
#endif
class __edm__Ref_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_edm__refhelper__FindUsingAdvance_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_s_ {
  public:
  __edm__Ref_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_edm__refhelper__FindUsingAdvance_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_s_();
  ::edm::RefCore product_;
  unsigned int index_;
};
#ifdef __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s_s_
#undef __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s_s_
#endif
class __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s_s_();
  bool present;
  ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > obj;
};
#ifdef __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s_
#undef __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s_
#endif
class __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s_ {
  public:
  __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s_();
  bool present;
  ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> obj;
};
#ifdef __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s_s_
#undef __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s_s_
#endif
class __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s_s_();
  bool present;
  ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > obj;
};
#ifdef __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s_
#undef __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s_
#endif
class __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s_ {
  public:
  __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s_();
  bool present;
  ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> obj;
};
#ifdef __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s_s_
#undef __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s_s_
#endif
class __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s_s_();
  bool present;
  ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > obj;
};
#ifdef __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s_
#undef __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s_
#endif
class __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s_ {
  public:
  __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s_();
  bool present;
  ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> obj;
};
#ifdef __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s_s_
#undef __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s_s_
#endif
class __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s_s_();
  bool present;
  ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > obj;
};
#ifdef __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s_
#undef __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s_
#endif
class __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s_ {
  public:
  __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s_();
  bool present;
  ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> obj;
};
#ifdef __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s_s_
#undef __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s_s_
#endif
class __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s_s_();
  bool present;
  ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > obj;
};
#ifdef __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s_
#undef __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s_
#endif
class __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s_ {
  public:
  __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s_();
  bool present;
  ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> obj;
};
#ifdef __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s_s_
#undef __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s_s_
#endif
class __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s_s_();
  bool present;
  ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > obj;
};
#ifdef __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s_
#undef __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s_
#endif
class __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s_ {
  public:
  __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s_();
  bool present;
  ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> obj;
};
#ifdef __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s_s_
#undef __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s_s_
#endif
class __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s_s_();
  bool present;
  ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > obj;
};
#ifdef __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s_
#undef __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s_
#endif
class __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s_ {
  public:
  __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s_();
  bool present;
  ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> obj;
};
#ifdef __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s_s_
#undef __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s_s_
#endif
class __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s_s_();
  bool present;
  ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > obj;
};
#ifdef __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s_
#undef __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s_
#endif
class __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s_ {
  public:
  __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s_();
  bool present;
  ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> obj;
};
#ifdef __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s_s_
#undef __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s_s_
#endif
class __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s_s_();
  bool present;
  ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > obj;
};
#ifdef __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s_
#undef __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s_
#endif
class __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s_ {
  public:
  __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s_();
  bool present;
  ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> obj;
};
#ifdef __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s_s_
#undef __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s_s_
#endif
class __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s_s_();
  bool present;
  ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > obj;
};
#ifdef __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s_
#undef __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s_
#endif
class __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s_ {
  public:
  __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s_();
  bool present;
  ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> obj;
};
#ifdef __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s_s_
#undef __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s_s_
#endif
class __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s_s_();
  bool present;
  ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > obj;
};
#ifdef __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s_
#undef __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s_
#endif
class __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s_ {
  public:
  __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s_();
  bool present;
  ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> obj;
};
#ifdef __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s_s_
#undef __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s_s_
#endif
class __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s_s_();
  bool present;
  ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > obj;
};
#ifdef __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s_
#undef __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s_
#endif
class __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s_ {
  public:
  __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s_();
  bool present;
  ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> obj;
};
#ifdef __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s_s_
#undef __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s_s_
#endif
class __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s_s_();
  bool present;
  ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > obj;
};
#ifdef __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s_
#undef __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s_
#endif
class __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s_ {
  public:
  __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s_();
  bool present;
  ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> obj;
};
#ifdef __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s_s_
#undef __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s_s_
#endif
class __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s_s_();
  bool present;
  ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > obj;
};
#ifdef __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s_
#undef __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s_
#endif
class __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s_ {
  public:
  __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s_();
  bool present;
  ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> obj;
};
#ifdef __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s_s_
#undef __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s_s_
#endif
class __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s_s_();
  bool present;
  ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > obj;
};
#ifdef __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s_
#undef __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s_
#endif
class __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s_ {
  public:
  __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s_();
  bool present;
  ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> obj;
};
#ifdef __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s_s_
#undef __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s_s_
#endif
class __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s_s_();
  bool present;
  ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > obj;
};
#ifdef __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s_
#undef __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s_
#endif
class __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s_ {
  public:
  __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s_();
  bool present;
  ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> obj;
};
#ifdef __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s_s_
#undef __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s_s_
#endif
class __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s_s_();
  bool present;
  ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > obj;
};
#ifdef __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s_
#undef __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s_
#endif
class __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s_ {
  public:
  __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s_();
  bool present;
  ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> obj;
};
#ifdef __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s_s_
#undef __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s_s_
#endif
class __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s_s_();
  bool present;
  ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > obj;
};
#ifdef __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s_
#undef __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s_
#endif
class __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s_ {
  public:
  __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s_();
  bool present;
  ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> obj;
};
#ifdef __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s_s_
#undef __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s_s_
#endif
class __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s_s_();
  bool present;
  ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > obj;
};
#ifdef __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s_
#undef __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s_
#endif
class __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s_ {
  public:
  __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s_();
  bool present;
  ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> obj;
};
#ifdef __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s_s_
#undef __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s_s_
#endif
class __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s_s_();
  bool present;
  ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > obj;
};
#ifdef __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s_
#undef __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s_
#endif
class __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s_ {
  public:
  __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s_();
  bool present;
  ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> obj;
};
#ifdef __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s_s_
#undef __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s_s_
#endif
class __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s_s_();
  bool present;
  ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > obj;
};
#ifdef __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s_
#undef __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s_
#endif
class __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s_ {
  public:
  __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s_();
  bool present;
  ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> obj;
};
#ifdef __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s_s_
#undef __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s_s_
#endif
class __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s_s_();
  bool present;
  ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > obj;
};
#ifdef __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s_
#undef __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s_
#endif
class __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s_ {
  public:
  __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s_();
  bool present;
  ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> obj;
};
#ifdef __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s_s_
#undef __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s_s_
#endif
class __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s_s_();
  bool present;
  ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > obj;
};
#ifdef __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s_
#undef __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s_
#endif
class __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s_ {
  public:
  __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s_();
  bool present;
  ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> obj;
};
#ifdef __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s_s_
#undef __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s_s_
#endif
class __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s_s_();
  bool present;
  ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > obj;
};
#ifdef __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s_
#undef __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s_
#endif
class __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s_ {
  public:
  __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s_();
  bool present;
  ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> obj;
};
#ifdef __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s_s_
#undef __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s_s_
#endif
class __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s_s_();
  bool present;
  ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > obj;
};
#ifdef __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s_
#undef __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s_
#endif
class __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s_ {
  public:
  __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s_();
  bool present;
  ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> obj;
};
#ifdef __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s_s_
#undef __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s_s_
#endif
class __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s_s_();
  bool present;
  ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > obj;
};
#ifdef __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s_
#undef __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s_
#endif
class __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s_ {
  public:
  __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s_();
  bool present;
  ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> obj;
};
#ifdef __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s_s_
#undef __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s_s_
#endif
class __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s_s_();
  bool present;
  ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > obj;
};
#ifdef __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s_
#undef __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s_
#endif
class __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s_ {
  public:
  __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s_();
  bool present;
  ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> obj;
};
#ifdef __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s_s_
#undef __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s_s_
#endif
class __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s_s_();
  bool present;
  ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > obj;
};
#ifdef __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s_
#undef __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s_
#endif
class __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s_ {
  public:
  __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s_();
  bool present;
  ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> obj;
};
#ifdef __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s_s_
#undef __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s_s_
#endif
class __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s_s_();
  bool present;
  ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > obj;
};
#ifdef __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s_
#undef __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s_
#endif
class __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s_ {
  public:
  __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s_();
  bool present;
  ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> obj;
};
#ifdef __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s_s_
#undef __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s_s_
#endif
class __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s_s_();
  bool present;
  ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > obj;
};
#ifdef __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s_
#undef __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s_
#endif
class __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s_ {
  public:
  __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s_();
  bool present;
  ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> obj;
};
#ifdef __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s_s_
#undef __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s_s_
#endif
class __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s_s_();
  bool present;
  ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > obj;
};
#ifdef __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s_
#undef __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s_
#endif
class __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s_ {
  public:
  __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s_();
  bool present;
  ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> obj;
};
#ifdef __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s_s_
#undef __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s_s_
#endif
class __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s_s_();
  bool present;
  ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > obj;
};
#ifdef __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s_
#undef __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s_
#endif
class __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s_ {
  public:
  __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s_();
  bool present;
  ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> obj;
};
#ifdef __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s_s_
#undef __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s_s_
#endif
class __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s_s_();
  bool present;
  ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > obj;
};
#ifdef __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s_
#undef __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s_
#endif
class __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s_ {
  public:
  __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s_();
  bool present;
  ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> obj;
};
#ifdef __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s_s_
#undef __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s_s_
#endif
class __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s_s_();
  bool present;
  ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > obj;
};
#ifdef __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s_
#undef __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s_
#endif
class __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s_ {
  public:
  __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s_();
  bool present;
  ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> obj;
};
#ifdef __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Jet_s_s_
#undef __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Jet_s_s_
#endif
class __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Jet_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Jet_s_s_();
  bool present;
  ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > obj;
};
#ifdef __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Jet_s_
#undef __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Jet_s_
#endif
class __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Jet_s_ {
  public:
  __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Jet_s_();
  bool present;
  ::PATPairFinalStateT<pat::Electron,pat::Jet> obj;
};
#ifdef __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Jet_s_s_
#undef __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Jet_s_s_
#endif
class __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Jet_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Jet_s_s_();
  bool present;
  ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > obj;
};
#ifdef __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Jet_s_
#undef __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Jet_s_
#endif
class __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Jet_s_ {
  public:
  __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Jet_s_();
  bool present;
  ::PATPairFinalStateT<pat::Muon,pat::Jet> obj;
};
#ifdef __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Photon_pat__Photon_s_s_
#undef __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Photon_pat__Photon_s_s_
#endif
class __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Photon_pat__Photon_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Photon_pat__Photon_s_s_();
  bool present;
  ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > obj;
};
#ifdef __edm__Wrapper_PATPairFinalStateT_pat__Photon_pat__Photon_s_
#undef __edm__Wrapper_PATPairFinalStateT_pat__Photon_pat__Photon_s_
#endif
class __edm__Wrapper_PATPairFinalStateT_pat__Photon_pat__Photon_s_ {
  public:
  __edm__Wrapper_PATPairFinalStateT_pat__Photon_pat__Photon_s_();
  bool present;
  ::PATPairFinalStateT<pat::Photon,pat::Photon> obj;
};
#ifdef __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Tau_pat__Tau_s_s_
#undef __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Tau_pat__Tau_s_s_
#endif
class __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Tau_pat__Tau_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Tau_pat__Tau_s_s_();
  bool present;
  ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > obj;
};
#ifdef __edm__Wrapper_PATPairFinalStateT_pat__Tau_pat__Tau_s_
#undef __edm__Wrapper_PATPairFinalStateT_pat__Tau_pat__Tau_s_
#endif
class __edm__Wrapper_PATPairFinalStateT_pat__Tau_pat__Tau_s_ {
  public:
  __edm__Wrapper_PATPairFinalStateT_pat__Tau_pat__Tau_s_();
  bool present;
  ::PATPairFinalStateT<pat::Tau,pat::Tau> obj;
};
#ifdef __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Photon_s_s_
#undef __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Photon_s_s_
#endif
class __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Photon_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Photon_s_s_();
  bool present;
  ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > obj;
};
#ifdef __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Photon_s_
#undef __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Photon_s_
#endif
class __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Photon_s_ {
  public:
  __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Photon_s_();
  bool present;
  ::PATPairFinalStateT<pat::Muon,pat::Photon> obj;
};
#ifdef __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Tau_s_s_
#undef __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Tau_s_s_
#endif
class __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Tau_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Tau_s_s_();
  bool present;
  ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > obj;
};
#ifdef __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Tau_s_
#undef __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Tau_s_
#endif
class __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Tau_s_ {
  public:
  __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Tau_s_();
  bool present;
  ::PATPairFinalStateT<pat::Muon,pat::Tau> obj;
};
#ifdef __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Muon_s_s_
#undef __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Muon_s_s_
#endif
class __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Muon_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Muon_s_s_();
  bool present;
  ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > obj;
};
#ifdef __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Muon_s_
#undef __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Muon_s_
#endif
class __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Muon_s_ {
  public:
  __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Muon_s_();
  bool present;
  ::PATPairFinalStateT<pat::Muon,pat::Muon> obj;
};
#ifdef __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Photon_s_s_
#undef __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Photon_s_s_
#endif
class __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Photon_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Photon_s_s_();
  bool present;
  ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > obj;
};
#ifdef __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Photon_s_
#undef __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Photon_s_
#endif
class __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Photon_s_ {
  public:
  __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Photon_s_();
  bool present;
  ::PATPairFinalStateT<pat::Electron,pat::Photon> obj;
};
#ifdef __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Tau_s_s_
#undef __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Tau_s_s_
#endif
class __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Tau_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Tau_s_s_();
  bool present;
  ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > obj;
};
#ifdef __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Tau_s_
#undef __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Tau_s_
#endif
class __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Tau_s_ {
  public:
  __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Tau_s_();
  bool present;
  ::PATPairFinalStateT<pat::Electron,pat::Tau> obj;
};
#ifdef __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Muon_s_s_
#undef __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Muon_s_s_
#endif
class __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Muon_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Muon_s_s_();
  bool present;
  ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > obj;
};
#ifdef __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Muon_s_
#undef __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Muon_s_
#endif
class __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Muon_s_ {
  public:
  __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Muon_s_();
  bool present;
  ::PATPairFinalStateT<pat::Electron,pat::Muon> obj;
};
#ifdef __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Electron_s_s_
#undef __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Electron_s_s_
#endif
class __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Electron_s_s_ {
  public:
  __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Electron_s_s_();
  bool present;
  ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > obj;
};
#ifdef __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Electron_s_
#undef __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Electron_s_
#endif
class __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Electron_s_ {
  public:
  __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Electron_s_();
  bool present;
  ::PATPairFinalStateT<pat::Electron,pat::Electron> obj;
};
#ifdef __edm__Wrapper_std__vector_PATMultiCandFinalState_s_
#undef __edm__Wrapper_std__vector_PATMultiCandFinalState_s_
#endif
class __edm__Wrapper_std__vector_PATMultiCandFinalState_s_ {
  public:
  __edm__Wrapper_std__vector_PATMultiCandFinalState_s_();
  bool present;
  ::std::vector<PATMultiCandFinalState> obj;
};
#ifdef __edm__Wrapper_std__vector_PATFinalStateLS_s_
#undef __edm__Wrapper_std__vector_PATFinalStateLS_s_
#endif
class __edm__Wrapper_std__vector_PATFinalStateLS_s_ {
  public:
  __edm__Wrapper_std__vector_PATFinalStateLS_s_();
  bool present;
  ::std::vector<PATFinalStateLS> obj;
};
#ifdef __edm__Wrapper_std__vector_PATFinalStateEvent_s_
#undef __edm__Wrapper_std__vector_PATFinalStateEvent_s_
#endif
class __edm__Wrapper_std__vector_PATFinalStateEvent_s_ {
  public:
  __edm__Wrapper_std__vector_PATFinalStateEvent_s_();
  bool present;
  ::std::vector<PATFinalStateEvent> obj;
};
#ifdef __edm__Wrapper_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s_s_
#undef __edm__Wrapper_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s_s_
#endif
class __edm__Wrapper_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s_s_ {
  public:
  __edm__Wrapper_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s_s_();
  bool present;
  ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > obj;
};
#ifdef __edm__RefProd_std__vector_pat__Photon_s_
#undef __edm__RefProd_std__vector_pat__Photon_s_
#endif
class __edm__RefProd_std__vector_pat__Photon_s_ {
  public:
  __edm__RefProd_std__vector_pat__Photon_s_();
  ::edm::RefCore product_;
};
#ifdef __edm__RefProd_std__vector_pat__Jet_s_
#undef __edm__RefProd_std__vector_pat__Jet_s_
#endif
class __edm__RefProd_std__vector_pat__Jet_s_ {
  public:
  __edm__RefProd_std__vector_pat__Jet_s_();
  ::edm::RefCore product_;
};
#ifdef __edm__RefProd_std__vector_pat__Tau_s_
#undef __edm__RefProd_std__vector_pat__Tau_s_
#endif
class __edm__RefProd_std__vector_pat__Tau_s_ {
  public:
  __edm__RefProd_std__vector_pat__Tau_s_();
  ::edm::RefCore product_;
};
#ifdef __edm__RefProd_std__vector_pat__Muon_s_
#undef __edm__RefProd_std__vector_pat__Muon_s_
#endif
class __edm__RefProd_std__vector_pat__Muon_s_ {
  public:
  __edm__RefProd_std__vector_pat__Muon_s_();
  ::edm::RefCore product_;
};
#ifdef __edm__RefProd_std__vector_pat__Electron_s_
#undef __edm__RefProd_std__vector_pat__Electron_s_
#endif
class __edm__RefProd_std__vector_pat__Electron_s_ {
  public:
  __edm__RefProd_std__vector_pat__Electron_s_();
  ::edm::RefCore product_;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class PATMultiCandFinalState -------------------------------
static  void operator_6191( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATMultiCandFinalState*)o)->operator=)(*(const ::PATMultiCandFinalState*)arg[0]);
  else   (((::PATMultiCandFinalState*)o)->operator=)(*(const ::PATMultiCandFinalState*)arg[0]);
}

static void constructor_6192( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATMultiCandFinalState(*(const ::PATMultiCandFinalState*)arg[0]);
  else ::new(mem) ::PATMultiCandFinalState(*(const ::PATMultiCandFinalState*)arg[0]);
}

static void constructor_6193( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATMultiCandFinalState();
  else ::new(mem) ::PATMultiCandFinalState();
}

static void constructor_6194( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATMultiCandFinalState(*(const ::std::vector<edm::Ptr<reco::Candidate> >*)arg[0],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[1]);
  else ::new(mem) ::PATMultiCandFinalState(*(const ::std::vector<edm::Ptr<reco::Candidate> >*)arg[0],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[1]);
}

static  void method_6195( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATMultiCandFinalState*)o)->clone)());
  else   (((const ::PATMultiCandFinalState*)o)->clone)();
}

static  void method_6196( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATMultiCandFinalState*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATMultiCandFinalState*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_6197( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (reco::CandidatePtr)((((const ::PATMultiCandFinalState*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATMultiCandFinalState*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_6198( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATMultiCandFinalState*)o)->numberOfDaughters)());
  else   (((const ::PATMultiCandFinalState*)o)->numberOfDaughters)();
}

static  void method_6199( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (reco::CandidatePtr)((((const ::PATMultiCandFinalState*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((const ::PATMultiCandFinalState*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_6200( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATMultiCandFinalState*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::string*)arg[1]);
  else   (((const ::PATMultiCandFinalState*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_6201( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::PATMultiCandFinalState*)o)->daughterCosThetaStar)(*(::size_t*)arg[0]));
  else   (((const ::PATMultiCandFinalState*)o)->daughterCosThetaStar)(*(::size_t*)arg[0]);
}

static void destructor_6202(void*, void * o, const std::vector<void*>&, void *) {
(((::PATMultiCandFinalState*)o)->::PATMultiCandFinalState::~PATMultiCandFinalState)();
}
static void method_newdel_67( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATMultiCandFinalState >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATMultiCandFinalState >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATMultiCandFinalState >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATMultiCandFinalState >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATMultiCandFinalState >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x1( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATMultiCandFinalState,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATMultiCandFinalState,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATMultiCandFinalState,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATMultiCandFinalState,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATMultiCandFinalState -------------------------------
void __PATMultiCandFinalState_db_datamem(Reflex::Class*);
void __PATMultiCandFinalState_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATMultiCandFinalState_datamem_bld(&__PATMultiCandFinalState_db_datamem);
Reflex::GenreflexMemberBuilder __PATMultiCandFinalState_funcmem_bld(&__PATMultiCandFinalState_db_funcmem);
void __PATMultiCandFinalState_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATMultiCandFinalState"), typeid(::PATMultiCandFinalState), sizeof(::PATMultiCandFinalState), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATMultiCandFinalState, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18148, type_18150), Reflex::Literal("operator="), operator_6191, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18150), Reflex::Literal("PATMultiCandFinalState"), constructor_6192, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATMultiCandFinalState"), constructor_6193, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45405, type_45406), Reflex::Literal("PATMultiCandFinalState"), constructor_6194, 0, "cands;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATMultiCandFinalState"), destructor_6202, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_67, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x1, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATMultiCandFinalState_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATMultiCandFinalState_funcmem_bld);
}

//------Delayed data member builder for class PATMultiCandFinalState -------------------
void __PATMultiCandFinalState_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4598, Reflex::Literal("cands_"), OffsetOf(__shadow__::__PATMultiCandFinalState, cands_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATMultiCandFinalState -------------------
void __PATMultiCandFinalState_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18144), Reflex::Literal("clone"), method_6195, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_6196, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16736c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_6197, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_6198, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16736, type_3148, type_6741), Reflex::Literal("daughterUserCandUnsafe"), method_6199, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45409, type_3148, type_6741), Reflex::Literal("daughterOverlaps"), method_6200, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138c, type_3148), Reflex::Literal("daughterCosThetaStar"), method_6201, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class PATFinalState -------------------------------
static  void operator_7507( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATFinalState*)o)->operator=)(*(const ::PATFinalState*)arg[0]);
  else   (((::PATFinalState*)o)->operator=)(*(const ::PATFinalState*)arg[0]);
}

static  void method_7511( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATFinalState*)o)->met)();
  else   (((const ::PATFinalState*)o)->met)();
}

static  void method_7512( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATFinalState*)o)->vertexObject)();
  else   (((const ::PATFinalState*)o)->vertexObject)();
}

static  void method_7513( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATFinalState*)o)->evt)();
  else   (((const ::PATFinalState*)o)->evt)();
}

static  void method_7514( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATFinalState*)o)->clone)());
  else   (((const ::PATFinalState*)o)->clone)();
}

static  void method_7515( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATFinalState*)o)->daughter)(*(::size_t*)arg[0]));
  else   (((const ::PATFinalState*)o)->daughter)(*(::size_t*)arg[0]);
}

static  void method_7516( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (reco::CandidatePtr)((((const ::PATFinalState*)o)->daughterPtr)(*(::size_t*)arg[0]));
  else   (((const ::PATFinalState*)o)->daughterPtr)(*(::size_t*)arg[0]);
}

static  void method_7517( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATFinalState*)o)->numberOfDaughters)());
  else   (((const ::PATFinalState*)o)->numberOfDaughters)();
}

static  void method_7518( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<const reco::Candidate*>)((((const ::PATFinalState*)o)->daughters)());
  else   (((const ::PATFinalState*)o)->daughters)();
}

static  void method_7519( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<const reco::Candidate*>)((((const ::PATFinalState*)o)->daughters)(*(const ::std::string*)arg[0]));
  else   (((const ::PATFinalState*)o)->daughters)(*(const ::std::string*)arg[0]);
}

static  void method_7520( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<edm::Ptr<reco::Candidate> >)((((const ::PATFinalState*)o)->daughterPtrs)(*(const ::std::string*)arg[0]));
  else   (((const ::PATFinalState*)o)->daughterPtrs)(*(const ::std::string*)arg[0]);
}

static  void method_7521( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<edm::Ptr<reco::Candidate> >)((((const ::PATFinalState*)o)->daughterPtrs)());
  else   (((const ::PATFinalState*)o)->daughterPtrs)();
}

static  void method_7522( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::PATFinalState*)o)->daughterHasUserCand)(*(::size_t*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((const ::PATFinalState*)o)->daughterHasUserCand)(*(::size_t*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_7523( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (reco::CandidatePtr)((((const ::PATFinalState*)o)->daughterUserCand)(*(::size_t*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((const ::PATFinalState*)o)->daughterUserCand)(*(::size_t*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_7524( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATFinalState*)o)->daughterUserCandP4)(*(::size_t*)arg[0],
    *(const ::std::string*)arg[1]);
  else   (((const ::PATFinalState*)o)->daughterUserCandP4)(*(::size_t*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_7525( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (std::vector<unsigned long>)((((const ::PATFinalState*)o)->indicesByPt)());
    else     (((const ::PATFinalState*)o)->indicesByPt)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (std::vector<unsigned long>)((((const ::PATFinalState*)o)->indicesByPt)(*(const ::std::string*)arg[0]));
    else     (((const ::PATFinalState*)o)->indicesByPt)(*(const ::std::string*)arg[0]);
  }
}

static  void method_7526( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (std::vector<const reco::Candidate*>)((((const ::PATFinalState*)o)->daughtersByPt)());
    else     (((const ::PATFinalState*)o)->daughtersByPt)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (std::vector<const reco::Candidate*>)((((const ::PATFinalState*)o)->daughtersByPt)(*(const ::std::string*)arg[0]));
    else     (((const ::PATFinalState*)o)->daughtersByPt)(*(const ::std::string*)arg[0]);
  }
}

static  void method_7527( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATFinalState*)o)->daughterByPt)(*(::size_t*)arg[0]));
    else     (((const ::PATFinalState*)o)->daughterByPt)(*(::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATFinalState*)o)->daughterByPt)(*(::size_t*)arg[0],
      *(const ::std::string*)arg[1]));
    else     (((const ::PATFinalState*)o)->daughterByPt)(*(::size_t*)arg[0],
      *(const ::std::string*)arg[1]);
  }
}

static  void method_7528( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (bool)((((const ::PATFinalState*)o)->ptOrdered)(*(::size_t*)arg[0],
      *(::size_t*)arg[1]));
    else     (((const ::PATFinalState*)o)->ptOrdered)(*(::size_t*)arg[0],
      *(::size_t*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::PATFinalState*)o)->ptOrdered)(*(::size_t*)arg[0],
      *(::size_t*)arg[1],
      *(const ::std::string*)arg[2]));
    else     (((const ::PATFinalState*)o)->ptOrdered)(*(::size_t*)arg[0],
      *(::size_t*)arg[1],
      *(const ::std::string*)arg[2]);
  }
}

static  void method_7529( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<pat::Tau>)((((const ::PATFinalState*)o)->daughterAsTau)(*(::size_t*)arg[0]));
  else   (((const ::PATFinalState*)o)->daughterAsTau)(*(::size_t*)arg[0]);
}

static  void method_7530( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<pat::Muon>)((((const ::PATFinalState*)o)->daughterAsMuon)(*(::size_t*)arg[0]));
  else   (((const ::PATFinalState*)o)->daughterAsMuon)(*(::size_t*)arg[0]);
}

static  void method_7531( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<pat::Electron>)((((const ::PATFinalState*)o)->daughterAsElectron)(*(::size_t*)arg[0]));
  else   (((const ::PATFinalState*)o)->daughterAsElectron)(*(::size_t*)arg[0]);
}

static  void method_7532( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<pat::Jet>)((((const ::PATFinalState*)o)->daughterAsJet)(*(::size_t*)arg[0]));
  else   (((const ::PATFinalState*)o)->daughterAsJet)(*(::size_t*)arg[0]);
}

static  void method_7533( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<pat::Photon>)((((const ::PATFinalState*)o)->daughterAsPhoton)(*(::size_t*)arg[0]));
  else   (((const ::PATFinalState*)o)->daughterAsPhoton)(*(::size_t*)arg[0]);
}

static  void method_7534( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (int)((((const ::PATFinalState*)o)->matchToHLTFilter)(*(::size_t*)arg[0],
      *(const ::std::string*)arg[1]));
    else     (((const ::PATFinalState*)o)->matchToHLTFilter)(*(::size_t*)arg[0],
      *(const ::std::string*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (int)((((const ::PATFinalState*)o)->matchToHLTFilter)(*(::size_t*)arg[0],
      *(const ::std::string*)arg[1],
      *(double*)arg[2]));
    else     (((const ::PATFinalState*)o)->matchToHLTFilter)(*(::size_t*)arg[0],
      *(const ::std::string*)arg[1],
      *(double*)arg[2]);
  }
}

static  void method_7535( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (int)((((const ::PATFinalState*)o)->matchToHLTPath)(*(::size_t*)arg[0],
      *(const ::std::string*)arg[1]));
    else     (((const ::PATFinalState*)o)->matchToHLTPath)(*(::size_t*)arg[0],
      *(const ::std::string*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (int)((((const ::PATFinalState*)o)->matchToHLTPath)(*(::size_t*)arg[0],
      *(const ::std::string*)arg[1],
      *(double*)arg[2]));
    else     (((const ::PATFinalState*)o)->matchToHLTPath)(*(::size_t*)arg[0],
      *(const ::std::string*)arg[1],
      *(double*)arg[2]);
  }
}

static  void method_7536( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::PATFinalState*)o)->eval)(*(const ::std::string*)arg[0]));
  else   (((const ::PATFinalState*)o)->eval)(*(const ::std::string*)arg[0]);
}

static  void method_7537( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::PATFinalState*)o)->filter)(*(const ::std::string*)arg[0]));
  else   (((const ::PATFinalState*)o)->filter)(*(const ::std::string*)arg[0]);
}

static  void method_7538( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (math::XYZTLorentzVector)((((const ::PATFinalState*)o)->visP4)(*(const ::std::string*)arg[0]));
  else   (((const ::PATFinalState*)o)->visP4)(*(const ::std::string*)arg[0]);
}

static  void method_7539( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (math::XYZTLorentzVector)((((const ::PATFinalState*)o)->visP4)());
  else   (((const ::PATFinalState*)o)->visP4)();
}

static  void method_7540( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (math::XYZTLorentzVector)((((const ::PATFinalState*)o)->totalP4)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((const ::PATFinalState*)o)->totalP4)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_7541( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (math::XYZTLorentzVector)((((const ::PATFinalState*)o)->totalP4)());
  else   (((const ::PATFinalState*)o)->totalP4)();
}

static  void method_7542( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::PATFinalState*)o)->dPhi)(*(int*)arg[0],
    *(const ::std::string*)arg[1],
    *(int*)arg[2],
    *(const ::std::string*)arg[3]));
  else   (((const ::PATFinalState*)o)->dPhi)(*(int*)arg[0],
    *(const ::std::string*)arg[1],
    *(int*)arg[2],
    *(const ::std::string*)arg[3]);
}

static  void method_7543( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::PATFinalState*)o)->dPhi)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::PATFinalState*)o)->dPhi)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_7544( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::PATFinalState*)o)->smallestDeltaPhi)());
  else   (((const ::PATFinalState*)o)->smallestDeltaPhi)();
}

static  void method_7545( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::PATFinalState*)o)->dR)(*(int*)arg[0],
    *(const ::std::string*)arg[1],
    *(int*)arg[2],
    *(const ::std::string*)arg[3]));
  else   (((const ::PATFinalState*)o)->dR)(*(int*)arg[0],
    *(const ::std::string*)arg[1],
    *(int*)arg[2],
    *(const ::std::string*)arg[3]);
}

static  void method_7546( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::PATFinalState*)o)->dR)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::PATFinalState*)o)->dR)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_7547( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::PATFinalState*)o)->smallestDeltaR)());
  else   (((const ::PATFinalState*)o)->smallestDeltaR)();
}

static  void method_7548( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::PATFinalState*)o)->deltaPhiToMEt)(*(int*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2]));
  else   (((const ::PATFinalState*)o)->deltaPhiToMEt)(*(int*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2]);
}

static  void method_7549( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::PATFinalState*)o)->deltaPhiToMEt)(*(int*)arg[0]));
  else   (((const ::PATFinalState*)o)->deltaPhiToMEt)(*(int*)arg[0]);
}

static  void method_7550( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<double>)((((const ::PATFinalState*)o)->SVfit)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::PATFinalState*)o)->SVfit)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_7551( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::PATFinalState*)o)->mt)(*(int*)arg[0],
    *(const ::std::string*)arg[1],
    *(int*)arg[2],
    *(const ::std::string*)arg[3]));
  else   (((const ::PATFinalState*)o)->mt)(*(int*)arg[0],
    *(const ::std::string*)arg[1],
    *(int*)arg[2],
    *(const ::std::string*)arg[3]);
}

static  void method_7552( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::PATFinalState*)o)->mt)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::PATFinalState*)o)->mt)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_7553( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::PATFinalState*)o)->mtMET)(*(int*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2]));
  else   (((const ::PATFinalState*)o)->mtMET)(*(int*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2]);
}

static  void method_7554( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (double)((((const ::PATFinalState*)o)->mtMET)(*(int*)arg[0]));
    else     (((const ::PATFinalState*)o)->mtMET)(*(int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (double)((((const ::PATFinalState*)o)->mtMET)(*(int*)arg[0],
      *(const ::std::string*)arg[1]));
    else     (((const ::PATFinalState*)o)->mtMET)(*(int*)arg[0],
      *(const ::std::string*)arg[1]);
  }
}

static  void method_7555( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::PATFinalState*)o)->mtMET)(*(int*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2],
    *(const ::std::string*)arg[3],
    *(const int*)arg[4]));
  else   (((const ::PATFinalState*)o)->mtMET)(*(int*)arg[0],
    *(const ::std::string*)arg[1],
    *(const ::std::string*)arg[2],
    *(const ::std::string*)arg[3],
    *(const int*)arg[4]);
}

static  void method_7556( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::PATFinalState*)o)->ht)(*(const ::std::string*)arg[0]));
  else   (((const ::PATFinalState*)o)->ht)(*(const ::std::string*)arg[0]);
}

static  void method_7557( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::PATFinalState*)o)->ht)());
  else   (((const ::PATFinalState*)o)->ht)();
}

static  void method_7558( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::PATFinalState*)o)->pZeta)());
    else     (((const ::PATFinalState*)o)->pZeta)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::PATFinalState*)o)->pZeta)(*(int*)arg[0]));
    else     (((const ::PATFinalState*)o)->pZeta)(*(int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (double)((((const ::PATFinalState*)o)->pZeta)(*(int*)arg[0],
      *(int*)arg[1]));
    else     (((const ::PATFinalState*)o)->pZeta)(*(int*)arg[0],
      *(int*)arg[1]);
  }
}

static  void method_7559( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::PATFinalState*)o)->pZetaVis)());
    else     (((const ::PATFinalState*)o)->pZetaVis)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::PATFinalState*)o)->pZetaVis)(*(int*)arg[0]));
    else     (((const ::PATFinalState*)o)->pZetaVis)(*(int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (double)((((const ::PATFinalState*)o)->pZetaVis)(*(int*)arg[0],
      *(int*)arg[1]));
    else     (((const ::PATFinalState*)o)->pZetaVis)(*(int*)arg[0],
      *(int*)arg[1]);
  }
}

static  void method_7560( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::PATFinalState*)o)->likeSigned)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::PATFinalState*)o)->likeSigned)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_7561( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::PATFinalState*)o)->likeFlavor)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::PATFinalState*)o)->likeFlavor)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_7562( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::PATFinalState*)o)->zCompatibility)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::PATFinalState*)o)->zCompatibility)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_7563( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (VBFVariables)((((const ::PATFinalState*)o)->vbfVariables)(*(const ::std::string*)arg[0]));
  else   (((const ::PATFinalState*)o)->vbfVariables)(*(const ::std::string*)arg[0]);
}

static  void method_7564( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::PATFinalState*)o)->orderedInPt)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::PATFinalState*)o)->orderedInPt)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_7565( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<edm::Ptr<reco::Candidate> >)((((const ::PATFinalState*)o)->extras)(*(const ::std::string*)arg[0]));
    else     (((const ::PATFinalState*)o)->extras)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<edm::Ptr<reco::Candidate> >)((((const ::PATFinalState*)o)->extras)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]));
    else     (((const ::PATFinalState*)o)->extras)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  }
}

static  void method_7566( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (std::vector<edm::Ptr<reco::Candidate> >)((((const ::PATFinalState*)o)->filteredOverlaps)(*(int*)arg[0],
      *(const ::std::string*)arg[1]));
    else     (((const ::PATFinalState*)o)->filteredOverlaps)(*(int*)arg[0],
      *(const ::std::string*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<edm::Ptr<reco::Candidate> >)((((const ::PATFinalState*)o)->filteredOverlaps)(*(int*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2]));
    else     (((const ::PATFinalState*)o)->filteredOverlaps)(*(int*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2]);
  }
}

static  void method_7567( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (std::vector<const reco::Candidate*>)((((const ::PATFinalState*)o)->vetoMuons)());
    else     (((const ::PATFinalState*)o)->vetoMuons)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (std::vector<const reco::Candidate*>)((((const ::PATFinalState*)o)->vetoMuons)(*(double*)arg[0]));
    else     (((const ::PATFinalState*)o)->vetoMuons)(*(double*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<const reco::Candidate*>)((((const ::PATFinalState*)o)->vetoMuons)(*(double*)arg[0],
      *(const ::std::string*)arg[1]));
    else     (((const ::PATFinalState*)o)->vetoMuons)(*(double*)arg[0],
      *(const ::std::string*)arg[1]);
  }
}

static  void method_7568( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (std::vector<const reco::Candidate*>)((((const ::PATFinalState*)o)->vetoElectrons)());
    else     (((const ::PATFinalState*)o)->vetoElectrons)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (std::vector<const reco::Candidate*>)((((const ::PATFinalState*)o)->vetoElectrons)(*(double*)arg[0]));
    else     (((const ::PATFinalState*)o)->vetoElectrons)(*(double*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<const reco::Candidate*>)((((const ::PATFinalState*)o)->vetoElectrons)(*(double*)arg[0],
      *(const ::std::string*)arg[1]));
    else     (((const ::PATFinalState*)o)->vetoElectrons)(*(double*)arg[0],
      *(const ::std::string*)arg[1]);
  }
}

static  void method_7569( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (std::vector<const reco::Candidate*>)((((const ::PATFinalState*)o)->vetoTaus)());
    else     (((const ::PATFinalState*)o)->vetoTaus)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (std::vector<const reco::Candidate*>)((((const ::PATFinalState*)o)->vetoTaus)(*(double*)arg[0]));
    else     (((const ::PATFinalState*)o)->vetoTaus)(*(double*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<const reco::Candidate*>)((((const ::PATFinalState*)o)->vetoTaus)(*(double*)arg[0],
      *(const ::std::string*)arg[1]));
    else     (((const ::PATFinalState*)o)->vetoTaus)(*(double*)arg[0],
      *(const ::std::string*)arg[1]);
  }
}

static  void method_7570( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (std::vector<const reco::Candidate*>)((((const ::PATFinalState*)o)->vetoJets)());
    else     (((const ::PATFinalState*)o)->vetoJets)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (std::vector<const reco::Candidate*>)((((const ::PATFinalState*)o)->vetoJets)(*(double*)arg[0]));
    else     (((const ::PATFinalState*)o)->vetoJets)(*(double*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<const reco::Candidate*>)((((const ::PATFinalState*)o)->vetoJets)(*(double*)arg[0],
      *(const ::std::string*)arg[1]));
    else     (((const ::PATFinalState*)o)->vetoJets)(*(double*)arg[0],
      *(const ::std::string*)arg[1]);
  }
}

static  void method_7571( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (std::vector<const reco::Candidate*>)((((const ::PATFinalState*)o)->vetoPhotons)());
    else     (((const ::PATFinalState*)o)->vetoPhotons)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (std::vector<const reco::Candidate*>)((((const ::PATFinalState*)o)->vetoPhotons)(*(double*)arg[0]));
    else     (((const ::PATFinalState*)o)->vetoPhotons)(*(double*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<const reco::Candidate*>)((((const ::PATFinalState*)o)->vetoPhotons)(*(double*)arg[0],
      *(const ::std::string*)arg[1]));
    else     (((const ::PATFinalState*)o)->vetoPhotons)(*(double*)arg[0],
      *(const ::std::string*)arg[1]);
  }
}

static  void method_7572( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<const reco::Candidate*>)((((const ::PATFinalState*)o)->overlapMuons)(*(int*)arg[0]));
    else     (((const ::PATFinalState*)o)->overlapMuons)(*(int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<const reco::Candidate*>)((((const ::PATFinalState*)o)->overlapMuons)(*(int*)arg[0],
      *(double*)arg[1]));
    else     (((const ::PATFinalState*)o)->overlapMuons)(*(int*)arg[0],
      *(double*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<const reco::Candidate*>)((((const ::PATFinalState*)o)->overlapMuons)(*(int*)arg[0],
      *(double*)arg[1],
      *(const ::std::string*)arg[2]));
    else     (((const ::PATFinalState*)o)->overlapMuons)(*(int*)arg[0],
      *(double*)arg[1],
      *(const ::std::string*)arg[2]);
  }
}

static  void method_7573( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<const reco::Candidate*>)((((const ::PATFinalState*)o)->overlapElectrons)(*(int*)arg[0]));
    else     (((const ::PATFinalState*)o)->overlapElectrons)(*(int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<const reco::Candidate*>)((((const ::PATFinalState*)o)->overlapElectrons)(*(int*)arg[0],
      *(double*)arg[1]));
    else     (((const ::PATFinalState*)o)->overlapElectrons)(*(int*)arg[0],
      *(double*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<const reco::Candidate*>)((((const ::PATFinalState*)o)->overlapElectrons)(*(int*)arg[0],
      *(double*)arg[1],
      *(const ::std::string*)arg[2]));
    else     (((const ::PATFinalState*)o)->overlapElectrons)(*(int*)arg[0],
      *(double*)arg[1],
      *(const ::std::string*)arg[2]);
  }
}

static  void method_7574( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<const reco::Candidate*>)((((const ::PATFinalState*)o)->overlapTaus)(*(int*)arg[0]));
    else     (((const ::PATFinalState*)o)->overlapTaus)(*(int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<const reco::Candidate*>)((((const ::PATFinalState*)o)->overlapTaus)(*(int*)arg[0],
      *(double*)arg[1]));
    else     (((const ::PATFinalState*)o)->overlapTaus)(*(int*)arg[0],
      *(double*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<const reco::Candidate*>)((((const ::PATFinalState*)o)->overlapTaus)(*(int*)arg[0],
      *(double*)arg[1],
      *(const ::std::string*)arg[2]));
    else     (((const ::PATFinalState*)o)->overlapTaus)(*(int*)arg[0],
      *(double*)arg[1],
      *(const ::std::string*)arg[2]);
  }
}

static  void method_7575( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<const reco::Candidate*>)((((const ::PATFinalState*)o)->overlapJets)(*(int*)arg[0]));
    else     (((const ::PATFinalState*)o)->overlapJets)(*(int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<const reco::Candidate*>)((((const ::PATFinalState*)o)->overlapJets)(*(int*)arg[0],
      *(double*)arg[1]));
    else     (((const ::PATFinalState*)o)->overlapJets)(*(int*)arg[0],
      *(double*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<const reco::Candidate*>)((((const ::PATFinalState*)o)->overlapJets)(*(int*)arg[0],
      *(double*)arg[1],
      *(const ::std::string*)arg[2]));
    else     (((const ::PATFinalState*)o)->overlapJets)(*(int*)arg[0],
      *(double*)arg[1],
      *(const ::std::string*)arg[2]);
  }
}

static  void method_7576( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::vector<const reco::Candidate*>)((((const ::PATFinalState*)o)->overlapPhotons)(*(int*)arg[0]));
    else     (((const ::PATFinalState*)o)->overlapPhotons)(*(int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::vector<const reco::Candidate*>)((((const ::PATFinalState*)o)->overlapPhotons)(*(int*)arg[0],
      *(double*)arg[1]));
    else     (((const ::PATFinalState*)o)->overlapPhotons)(*(int*)arg[0],
      *(double*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::vector<const reco::Candidate*>)((((const ::PATFinalState*)o)->overlapPhotons)(*(int*)arg[0],
      *(double*)arg[1],
      *(const ::std::string*)arg[2]));
    else     (((const ::PATFinalState*)o)->overlapPhotons)(*(int*)arg[0],
      *(double*)arg[1],
      *(const ::std::string*)arg[2]);
  }
}

static  void method_7577( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (PATFinalStateProxy)((((const ::PATFinalState*)o)->subcand)(*(int*)arg[0],
      *(int*)arg[1]));
    else     (((const ::PATFinalState*)o)->subcand)(*(int*)arg[0],
      *(int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (PATFinalStateProxy)((((const ::PATFinalState*)o)->subcand)(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2]));
    else     (((const ::PATFinalState*)o)->subcand)(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) new (retaddr) (PATFinalStateProxy)((((const ::PATFinalState*)o)->subcand)(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3]));
    else     (((const ::PATFinalState*)o)->subcand)(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) new (retaddr) (PATFinalStateProxy)((((const ::PATFinalState*)o)->subcand)(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4]));
    else     (((const ::PATFinalState*)o)->subcand)(*(int*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4]);
  }
}

static  void method_7578( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (PATFinalStateProxy)((((const ::PATFinalState*)o)->subcandfsr)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::PATFinalState*)o)->subcandfsr)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_7579( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (math::XYZTLorentzVector)((((const ::PATFinalState*)o)->p4fsr)());
  else   (((const ::PATFinalState*)o)->p4fsr)();
}

static  void method_7580( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (PATFinalStateProxy)((((const ::PATFinalState*)o)->subcand)(*(const ::std::string*)arg[0]));
  else   (((const ::PATFinalState*)o)->subcand)(*(const ::std::string*)arg[0]);
}

static  void method_7581( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (PATFinalStateProxy)((((const ::PATFinalState*)o)->subcand)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]));
    else     (((const ::PATFinalState*)o)->subcand)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (PATFinalStateProxy)((((const ::PATFinalState*)o)->subcand)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2]));
    else     (((const ::PATFinalState*)o)->subcand)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const ::std::string*)arg[2]);
  }
}

static  void method_7582( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATFinalState*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATFinalState*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_7583( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (reco::CandidatePtr)((((const ::PATFinalState*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATFinalState*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_7584( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (reco::CandidatePtr)((((const ::PATFinalState*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((const ::PATFinalState*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_7585( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATFinalState*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::string*)arg[1]);
  else   (((const ::PATFinalState*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_7586( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (reco::GenParticleRef)((((const ::PATFinalState*)o)->getDaughterGenParticle)(*(::size_t*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2]));
  else   (((const ::PATFinalState*)o)->getDaughterGenParticle)(*(::size_t*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2]);
}

static  void method_7587( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (reco::GenParticleRef)((((const ::PATFinalState*)o)->getDaughterGenParticleMotherSmart)(*(::size_t*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2]));
  else   (((const ::PATFinalState*)o)->getDaughterGenParticleMotherSmart)(*(::size_t*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2]);
}

static  void method_7588( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::PATFinalState*)o)->comesFromHiggs)(*(::size_t*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2]));
  else   (((const ::PATFinalState*)o)->comesFromHiggs)(*(::size_t*)arg[0],
    *(int*)arg[1],
    *(int*)arg[2]);
}

static  void method_7589( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (math::XYZVector)((((const ::PATFinalState*)o)->getDaughtersRecoil)());
  else   (((const ::PATFinalState*)o)->getDaughtersRecoil)();
}

static  void method_7590( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (math::XYZVector)((((const ::PATFinalState*)o)->getDaughtersRecoilWithMet)());
  else   (((const ::PATFinalState*)o)->getDaughtersRecoilWithMet)();
}

static  void method_7591( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::PATFinalState*)o)->getRecoilWithMetSignificance)());
  else   (((const ::PATFinalState*)o)->getRecoilWithMetSignificance)();
}

static  void method_7592( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (math::XYZTLorentzVector)((((const ::PATFinalState*)o)->getUserLorentzVector)(*(::size_t*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((const ::PATFinalState*)o)->getUserLorentzVector)(*(::size_t*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_7593( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::PATFinalState*)o)->getPhotonUserIsolation)(*(::size_t*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((const ::PATFinalState*)o)->getPhotonUserIsolation)(*(::size_t*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_7594( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::PATFinalState*)o)->jetVariables)(*(::size_t*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((const ::PATFinalState*)o)->jetVariables)(*(::size_t*)arg[0],
    *(const ::std::string*)arg[1]);
}

static void destructor_7595(void*, void * o, const std::vector<void*>&, void *) {
(((::PATFinalState*)o)->::PATFinalState::~PATFinalState)();
}
static void method_x2( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATFinalState,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATFinalState,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATFinalState,::reco::Candidate >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATFinalState -------------------------------
void __PATFinalState_db_datamem(Reflex::Class*);
void __PATFinalState_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATFinalState_datamem_bld(&__PATFinalState_db_datamem);
Reflex::GenreflexMemberBuilder __PATFinalState_funcmem_bld(&__PATFinalState_db_funcmem);
void __PATFinalState_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATFinalState"), typeid(::PATFinalState), sizeof(::PATFinalState), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddBase(type_2873, ::Reflex::BaseOffset< ::PATFinalState, ::pat::PATObject<reco::LeafCandidate> >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_14477, Reflex::Literal("PATFinalState::LorentzVector"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11112, type_11114), Reflex::Literal("operator="), operator_7507, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATFinalState"), destructor_7595, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x2, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATFinalState_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATFinalState_funcmem_bld);
}

//------Delayed data member builder for class PATFinalState -------------------
void __PATFinalState_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2414, Reflex::Literal("event_"), OffsetOf(__shadow__::__PATFinalState, event_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATFinalState -------------------
void __PATFinalState_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46447), Reflex::Literal("met"), method_7511, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46448), Reflex::Literal("vertexObject"), method_7512, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45406), Reflex::Literal("evt"), method_7513, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11110), Reflex::Literal("clone"), method_7514, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughter"), method_7515, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16736c, type_3148), Reflex::Literal("daughterPtr"), method_7516, 0, "i", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_7517, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4689), Reflex::Literal("daughters"), method_7518, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4689, type_6741), Reflex::Literal("daughters"), method_7519, 0, "tags", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4598, type_6741), Reflex::Literal("daughterPtrs"), method_7520, 0, "tags", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4598), Reflex::Literal("daughterPtrs"), method_7521, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301, type_3148, type_6741), Reflex::Literal("daughterHasUserCand"), method_7522, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16736c, type_3148, type_6741), Reflex::Literal("daughterUserCand"), method_7523, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13680, type_3148, type_6741), Reflex::Literal("daughterUserCandP4"), method_7524, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4590, type_6741), Reflex::Literal("indicesByPt"), method_7525, 0, "tags=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4689, type_6741), Reflex::Literal("daughtersByPt"), method_7526, 0, "tags=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148, type_6741), Reflex::Literal("daughterByPt"), method_7527, 0, "i;tags=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301, type_3148, type_3148, type_6741), Reflex::Literal("ptOrdered"), method_7528, 0, "i;j;tags=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9787, type_3148), Reflex::Literal("daughterAsTau"), method_7529, 0, "i", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9782, type_3148), Reflex::Literal("daughterAsMuon"), method_7530, 0, "i", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9785, type_3148), Reflex::Literal("daughterAsElectron"), method_7531, 0, "i", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9781, type_3148), Reflex::Literal("daughterAsJet"), method_7532, 0, "i", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9786, type_3148), Reflex::Literal("daughterAsPhoton"), method_7533, 0, "i", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_88, type_3148, type_6741, type_138), Reflex::Literal("matchToHLTFilter"), method_7534, 0, "i;filter;maxDeltaR=2.99999999999999988897769753748434595763683319091796875e-1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_88, type_3148, type_6741, type_138), Reflex::Literal("matchToHLTPath"), method_7535, 0, "i;path;maxDeltaR=2.99999999999999988897769753748434595763683319091796875e-1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_6741), Reflex::Literal("eval"), method_7536, 0, "function", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301, type_6741), Reflex::Literal("filter"), method_7537, 0, "cut", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14477, type_6741), Reflex::Literal("visP4"), method_7538, 0, "tags", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14477), Reflex::Literal("visP4"), method_7539, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14477, type_6741, type_6741), Reflex::Literal("totalP4"), method_7540, 0, "tags;metTag", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14477), Reflex::Literal("totalP4"), method_7541, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_88, type_6741, type_88, type_6741), Reflex::Literal("dPhi"), method_7542, 0, "i;tagI;j;tagJ", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_88, type_88), Reflex::Literal("dPhi"), method_7543, 0, "i;j", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138), Reflex::Literal("smallestDeltaPhi"), method_7544, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_88, type_6741, type_88, type_6741), Reflex::Literal("dR"), method_7545, 0, "i;tagI;j;tagJ", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_88, type_88), Reflex::Literal("dR"), method_7546, 0, "i;j", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138), Reflex::Literal("smallestDeltaR"), method_7547, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_88, type_6741, type_6741), Reflex::Literal("deltaPhiToMEt"), method_7548, 0, "i;tag;metTag", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_88), Reflex::Literal("deltaPhiToMEt"), method_7549, 0, "i", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4600, type_88, type_88), Reflex::Literal("SVfit"), method_7550, 0, "i;j", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_88, type_6741, type_88, type_6741), Reflex::Literal("mt"), method_7551, 0, "i;tagI;j;tagJ", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_88, type_88), Reflex::Literal("mt"), method_7552, 0, "i;j", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_88, type_6741, type_6741), Reflex::Literal("mtMET"), method_7553, 0, "i;tag;metTag", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_88, type_6741), Reflex::Literal("mtMET"), method_7554, 0, "i;metTag=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_88, type_6741, type_6741, type_6741, type_88c), Reflex::Literal("mtMET"), method_7555, 0, "i;tag;metName;metTag;applyPhiCorr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_6741), Reflex::Literal("ht"), method_7556, 0, "sysTags", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138), Reflex::Literal("ht"), method_7557, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_88, type_88), Reflex::Literal("pZeta"), method_7558, 0, "i=0;j=1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_88, type_88), Reflex::Literal("pZetaVis"), method_7559, 0, "i=0;j=1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301, type_88, type_88), Reflex::Literal("likeSigned"), method_7560, 0, "i;j", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301, type_88, type_88), Reflex::Literal("likeFlavor"), method_7561, 0, "i;j", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_88, type_88), Reflex::Literal("zCompatibility"), method_7562, 0, "i;j", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2448, type_6741), Reflex::Literal("vbfVariables"), method_7563, 0, "jetCuts", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301, type_88, type_88), Reflex::Literal("orderedInPt"), method_7564, 0, "i;j", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4598, type_6741, type_6741), Reflex::Literal("extras"), method_7565, 0, "label;filter=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4598, type_88, type_6741, type_6741), Reflex::Literal("filteredOverlaps"), method_7566, 0, "i;label;filter=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4689, type_138, type_6741), Reflex::Literal("vetoMuons"), method_7567, 0, "dR=1.000000000000000055511151231257827021181583404541015625e-1;filter=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4689, type_138, type_6741), Reflex::Literal("vetoElectrons"), method_7568, 0, "dR=1.000000000000000055511151231257827021181583404541015625e-1;filter=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4689, type_138, type_6741), Reflex::Literal("vetoTaus"), method_7569, 0, "dR=1.000000000000000055511151231257827021181583404541015625e-1;filter=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4689, type_138, type_6741), Reflex::Literal("vetoJets"), method_7570, 0, "dR=1.000000000000000055511151231257827021181583404541015625e-1;filter=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4689, type_138, type_6741), Reflex::Literal("vetoPhotons"), method_7571, 0, "dR=1.000000000000000055511151231257827021181583404541015625e-1;filter=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4689, type_88, type_138, type_6741), Reflex::Literal("overlapMuons"), method_7572, 0, "i;dR=1.000000000000000055511151231257827021181583404541015625e-1;filter=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4689, type_88, type_138, type_6741), Reflex::Literal("overlapElectrons"), method_7573, 0, "i;dR=1.000000000000000055511151231257827021181583404541015625e-1;filter=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4689, type_88, type_138, type_6741), Reflex::Literal("overlapTaus"), method_7574, 0, "i;dR=1.000000000000000055511151231257827021181583404541015625e-1;filter=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4689, type_88, type_138, type_6741), Reflex::Literal("overlapJets"), method_7575, 0, "i;dR=1.000000000000000055511151231257827021181583404541015625e-1;filter=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4689, type_88, type_138, type_6741), Reflex::Literal("overlapPhotons"), method_7576, 0, "i;dR=1.000000000000000055511151231257827021181583404541015625e-1;filter=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2951, type_88, type_88, type_88, type_88, type_88), Reflex::Literal("subcand"), method_7577, 0, "i;j;x=-0x00000000000000001;y=-0x00000000000000001;z=-0x00000000000000001", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2951, type_88, type_88), Reflex::Literal("subcandfsr"), method_7578, 0, "i;j", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14477), Reflex::Literal("p4fsr"), method_7579, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2951, type_6741), Reflex::Literal("subcand"), method_7580, 0, "tags", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2951, type_6741, type_6741, type_6741), Reflex::Literal("subcand"), method_7581, 0, "tags;extras;filter=\"\"", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_7582, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16736c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_7583, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16736, type_3148, type_6741), Reflex::Literal("daughterUserCandUnsafe"), method_7584, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45409, type_3148, type_6741), Reflex::Literal("daughterOverlaps"), method_7585, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16442c, type_3148, type_88, type_88), Reflex::Literal("getDaughterGenParticle"), method_7586, 0, "i;pdgIdToMatch;checkCharge", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16442c, type_3148, type_88, type_88), Reflex::Literal("getDaughterGenParticleMotherSmart"), method_7587, 0, "i;pdgIdToMatch;checkCharge", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301c, type_3148, type_88, type_88), Reflex::Literal("comesFromHiggs"), method_7588, 0, "i;pdgIdToMatch;checkCharge", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14476c), Reflex::Literal("getDaughtersRecoil"), method_7589, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14476c), Reflex::Literal("getDaughtersRecoilWithMet"), method_7590, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138c), Reflex::Literal("getRecoilWithMetSignificance"), method_7591, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14477c, type_3148, type_6741), Reflex::Literal("getUserLorentzVector"), method_7592, 0, "i;", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1261c, type_3148, type_6741), Reflex::Literal("getPhotonUserIsolation"), method_7593, 0, "i;key", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1261c, type_3148, type_6741), Reflex::Literal("jetVariables"), method_7594, 0, "i;key", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class PATFinalStateEvent -------------------------------
static void destructor_8688(void*, void * o, const std::vector<void*>&, void *) {
(((::PATFinalStateEvent*)o)->::PATFinalStateEvent::~PATFinalStateEvent)();
}
static  void operator_8689( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATFinalStateEvent*)o)->operator=)(*(const ::PATFinalStateEvent*)arg[0]);
  else   (((::PATFinalStateEvent*)o)->operator=)(*(const ::PATFinalStateEvent*)arg[0]);
}

static void constructor_8690( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATFinalStateEvent(*(const ::PATFinalStateEvent*)arg[0]);
  else ::new(mem) ::PATFinalStateEvent(*(const ::PATFinalStateEvent*)arg[0]);
}

static void constructor_8691( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATFinalStateEvent();
  else ::new(mem) ::PATFinalStateEvent();
}

static void constructor_8692( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATFinalStateEvent(*(const ::edm::Ptr<reco::Vertex>*)arg[0],
      *(const ::edm::Ptr<pat::MET>*)arg[1]);
  else ::new(mem) ::PATFinalStateEvent(*(const ::edm::Ptr<reco::Vertex>*)arg[0],
      *(const ::edm::Ptr<pat::MET>*)arg[1]);
}

static void constructor_8693( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATFinalStateEvent(*(double*)arg[0],
      *(const ::edm::Ptr<reco::Vertex>*)arg[1],
      *(const ::edm::PtrVector<reco::Vertex>*)arg[2],
      *(const ::edm::Ptr<pat::MET>*)arg[3],
      *(const ::TMatrixD*)arg[4],
      *(const ::pat::TriggerEvent*)arg[5],
      *(const ::std::vector<PileupSummaryInfo>*)arg[6],
      *(const ::lhef::HEPEUP*)arg[7],
      *(const ::reco::GenParticleRefProd*)arg[8],
      *(const ::edm::EventID*)arg[9],
      *(const ::GenEventInfoProduct*)arg[10],
      *(const ::GenFilterInfo*)arg[11],
      *(bool*)arg[12],
      *(const ::std::string*)arg[13],
      *(const ::edm::RefProd<std::vector<pat::Electron> >*)arg[14],
      *(const ::edm::RefProd<std::vector<pat::Muon> >*)arg[15],
      *(const ::edm::RefProd<std::vector<pat::Tau> >*)arg[16],
      *(const ::edm::RefProd<std::vector<pat::Jet> >*)arg[17],
      *(const ::edm::RefProd<std::vector<pat::Photon> >*)arg[18],
      *(const ::reco::PFCandidateRefProd*)arg[19],
      *(const ::reco::TrackRefProd*)arg[20],
      *(const ::reco::GsfTrackRefProd*)arg[21],
      *(const ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)arg[22]);
  else ::new(mem) ::PATFinalStateEvent(*(double*)arg[0],
      *(const ::edm::Ptr<reco::Vertex>*)arg[1],
      *(const ::edm::PtrVector<reco::Vertex>*)arg[2],
      *(const ::edm::Ptr<pat::MET>*)arg[3],
      *(const ::TMatrixD*)arg[4],
      *(const ::pat::TriggerEvent*)arg[5],
      *(const ::std::vector<PileupSummaryInfo>*)arg[6],
      *(const ::lhef::HEPEUP*)arg[7],
      *(const ::reco::GenParticleRefProd*)arg[8],
      *(const ::edm::EventID*)arg[9],
      *(const ::GenEventInfoProduct*)arg[10],
      *(const ::GenFilterInfo*)arg[11],
      *(bool*)arg[12],
      *(const ::std::string*)arg[13],
      *(const ::edm::RefProd<std::vector<pat::Electron> >*)arg[14],
      *(const ::edm::RefProd<std::vector<pat::Muon> >*)arg[15],
      *(const ::edm::RefProd<std::vector<pat::Tau> >*)arg[16],
      *(const ::edm::RefProd<std::vector<pat::Jet> >*)arg[17],
      *(const ::edm::RefProd<std::vector<pat::Photon> >*)arg[18],
      *(const ::reco::PFCandidateRefProd*)arg[19],
      *(const ::reco::TrackRefProd*)arg[20],
      *(const ::reco::GsfTrackRefProd*)arg[21],
      *(const ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)arg[22]);
}

static  void method_8694( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATFinalStateEvent*)o)->pv)();
  else   (((const ::PATFinalStateEvent*)o)->pv)();
}

static  void method_8695( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATFinalStateEvent*)o)->recoVertices)();
  else   (((const ::PATFinalStateEvent*)o)->recoVertices)();
}

static  void method_8696( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATFinalStateEvent*)o)->puInfo)();
  else   (((const ::PATFinalStateEvent*)o)->puInfo)();
}

static  void method_8697( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATFinalStateEvent*)o)->lesHouches)();
  else   (((const ::PATFinalStateEvent*)o)->lesHouches)();
}

static  void method_8698( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATFinalStateEvent*)o)->genEventInfo)();
  else   (((const ::PATFinalStateEvent*)o)->genEventInfo)();
}

static  void method_8699( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATFinalStateEvent*)o)->generatorFilter)();
  else   (((const ::PATFinalStateEvent*)o)->generatorFilter)();
}

static  void method_8700( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::PATFinalStateEvent*)o)->rho)());
  else   (((const ::PATFinalStateEvent*)o)->rho)();
}

static  void method_8701( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATFinalStateEvent*)o)->trig)();
  else   (((const ::PATFinalStateEvent*)o)->trig)();
}

static  void method_8702( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATFinalStateEvent*)o)->met)();
  else   (((const ::PATFinalStateEvent*)o)->met)();
}

static  void method_8703( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATFinalStateEvent*)o)->metCovariance)();
  else   (((const ::PATFinalStateEvent*)o)->metCovariance)();
}

static  void method_8704( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::PATFinalStateEvent*)o)->metSignificance)());
  else   (((const ::PATFinalStateEvent*)o)->metSignificance)();
}

static  void method_8705( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<pat::MET>)((((const ::PATFinalStateEvent*)o)->met)(*(const ::std::string*)arg[0]));
  else   (((const ::PATFinalStateEvent*)o)->met)(*(const ::std::string*)arg[0]);
}

static  void method_8706( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (math::XYZTLorentzVector)((((const ::PATFinalStateEvent*)o)->met4vector)(*(const ::std::string*)arg[0]));
    else     (((const ::PATFinalStateEvent*)o)->met4vector)(*(const ::std::string*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (math::XYZTLorentzVector)((((const ::PATFinalStateEvent*)o)->met4vector)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]));
    else     (((const ::PATFinalStateEvent*)o)->met4vector)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (math::XYZTLorentzVector)((((const ::PATFinalStateEvent*)o)->met4vector)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const int*)arg[2]));
    else     (((const ::PATFinalStateEvent*)o)->met4vector)(*(const ::std::string*)arg[0],
      *(const ::std::string*)arg[1],
      *(const int*)arg[2]);
  }
}

static  void method_8707( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATFinalStateEvent*)o)->evtId)();
  else   (((const ::PATFinalStateEvent*)o)->evtId)();
}

static  void method_8708( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::PATFinalStateEvent*)o)->hltResult)(*(const ::std::string*)arg[0]));
  else   (((const ::PATFinalStateEvent*)o)->hltResult)(*(const ::std::string*)arg[0]);
}

static  void method_8709( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::PATFinalStateEvent*)o)->hltPrescale)(*(const ::std::string*)arg[0]));
  else   (((const ::PATFinalStateEvent*)o)->hltPrescale)(*(const ::std::string*)arg[0]);
}

static  void method_8710( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::PATFinalStateEvent*)o)->hltGroup)(*(const ::std::string*)arg[0]));
  else   (((const ::PATFinalStateEvent*)o)->hltGroup)(*(const ::std::string*)arg[0]);
}

static  void method_8711( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (int)((((const ::PATFinalStateEvent*)o)->matchedToFilter)(*(const ::reco::Candidate*)arg[0],
      *(const ::std::string*)arg[1]));
    else     (((const ::PATFinalStateEvent*)o)->matchedToFilter)(*(const ::reco::Candidate*)arg[0],
      *(const ::std::string*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (int)((((const ::PATFinalStateEvent*)o)->matchedToFilter)(*(const ::reco::Candidate*)arg[0],
      *(const ::std::string*)arg[1],
      *(double*)arg[2]));
    else     (((const ::PATFinalStateEvent*)o)->matchedToFilter)(*(const ::reco::Candidate*)arg[0],
      *(const ::std::string*)arg[1],
      *(double*)arg[2]);
  }
}

static  void method_8712( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (int)((((const ::PATFinalStateEvent*)o)->matchedToPath)(*(const ::reco::Candidate*)arg[0],
      *(const ::std::string*)arg[1]));
    else     (((const ::PATFinalStateEvent*)o)->matchedToPath)(*(const ::reco::Candidate*)arg[0],
      *(const ::std::string*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (int)((((const ::PATFinalStateEvent*)o)->matchedToPath)(*(const ::reco::Candidate*)arg[0],
      *(const ::std::string*)arg[1],
      *(double*)arg[2]));
    else     (((const ::PATFinalStateEvent*)o)->matchedToPath)(*(const ::reco::Candidate*)arg[0],
      *(const ::std::string*)arg[1],
      *(double*)arg[2]);
  }
}

static  void method_8713( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::PATFinalStateEvent*)o)->findDecay)(*(const int*)arg[0],
    *(const int*)arg[1]));
  else   (((const ::PATFinalStateEvent*)o)->findDecay)(*(const int*)arg[0],
    *(const int*)arg[1]);
}

static  void method_8714( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATFinalStateEvent*)o)->puTag)();
  else   (((const ::PATFinalStateEvent*)o)->puTag)();
}

static  void method_8715( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::PATFinalStateEvent*)o)->puWeight)(*(const ::std::string*)arg[0]));
  else   (((const ::PATFinalStateEvent*)o)->puWeight)(*(const ::std::string*)arg[0]);
}

static  void method_8716( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::PATFinalStateEvent*)o)->puWeight)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((const ::PATFinalStateEvent*)o)->puWeight)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_8717( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::PATFinalStateEvent*)o)->puWeight3D)(*(const ::std::string*)arg[0]));
  else   (((const ::PATFinalStateEvent*)o)->puWeight3D)(*(const ::std::string*)arg[0]);
}

static  void method_8718( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::PATFinalStateEvent*)o)->puWeight3D)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((const ::PATFinalStateEvent*)o)->puWeight3D)(*(const ::std::string*)arg[0],
    *(const ::std::string*)arg[1]);
}

static  void method_8719( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::PATFinalStateEvent*)o)->weight)(*(const ::std::string*)arg[0]));
  else   (((const ::PATFinalStateEvent*)o)->weight)(*(const ::std::string*)arg[0]);
}

static  void method_8720( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PATFinalStateEvent*)o)->addWeight)(*(const ::std::string*)arg[0],
    *(float*)arg[1]);
}

static  void method_8721( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::PATFinalStateEvent*)o)->flag)(*(const ::std::string*)arg[0]));
  else   (((const ::PATFinalStateEvent*)o)->flag)(*(const ::std::string*)arg[0]);
}

static  void method_8722( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::PATFinalStateEvent*)o)->addFlag)(*(const ::std::string*)arg[0],
    *(int*)arg[1]);
}

static  void method_8723( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::PATFinalStateEvent*)o)->isRealData)());
  else   (((const ::PATFinalStateEvent*)o)->isRealData)();
}

static  void method_8724( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATFinalStateEvent*)o)->electrons)();
  else   (((const ::PATFinalStateEvent*)o)->electrons)();
}

static  void method_8725( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATFinalStateEvent*)o)->muons)();
  else   (((const ::PATFinalStateEvent*)o)->muons)();
}

static  void method_8726( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATFinalStateEvent*)o)->jets)();
  else   (((const ::PATFinalStateEvent*)o)->jets)();
}

static  void method_8727( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATFinalStateEvent*)o)->taus)();
  else   (((const ::PATFinalStateEvent*)o)->taus)();
}

static  void method_8728( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATFinalStateEvent*)o)->photons)();
  else   (((const ::PATFinalStateEvent*)o)->photons)();
}

static  void method_8729( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATFinalStateEvent*)o)->pflow)();
  else   (((const ::PATFinalStateEvent*)o)->pflow)();
}

static  void method_8730( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (reco::GenParticleRefProd)((((const ::PATFinalStateEvent*)o)->genParticleRefProd)());
  else   (((const ::PATFinalStateEvent*)o)->genParticleRefProd)();
}

static  void method_8731( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (char)((((const ::PATFinalStateEvent*)o)->version)());
  else   (((const ::PATFinalStateEvent*)o)->version)();
}

static  void method_8732( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::PATFinalStateEvent*)o)->jetVariables)(*(const ::reco::CandidatePtr*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((const ::PATFinalStateEvent*)o)->jetVariables)(*(const ::reco::CandidatePtr*)arg[0],
    *(const ::std::string*)arg[1]);
}

static void method_newdel_583( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATFinalStateEvent >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATFinalStateEvent >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATFinalStateEvent >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATFinalStateEvent >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATFinalStateEvent >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class PATFinalStateEvent -------------------------------
void __PATFinalStateEvent_db_datamem(Reflex::Class*);
void __PATFinalStateEvent_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATFinalStateEvent_datamem_bld(&__PATFinalStateEvent_db_datamem);
Reflex::GenreflexMemberBuilder __PATFinalStateEvent_funcmem_bld(&__PATFinalStateEvent_db_funcmem);
void __PATFinalStateEvent_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATFinalStateEvent"), typeid(::PATFinalStateEvent), sizeof(::PATFinalStateEvent), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "15")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATFinalStateEvent"), destructor_8688, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7667, type_7669), Reflex::Literal("operator="), operator_8689, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7669), Reflex::Literal("PATFinalStateEvent"), constructor_8690, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATFinalStateEvent"), constructor_8691, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_46448, type_46447), Reflex::Literal("PATFinalStateEvent"), constructor_8692, 0, "pv;met", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_138, type_46448, type_50680, type_46447, type_50681, type_50682, type_50683, type_50684, type_50685, type_29100, type_50686, type_50687, type_2301, type_6741, type_50688, type_50689, type_50690, type_50691, type_50692, type_50693, type_50694, type_50695, type_50696), Reflex::Literal("PATFinalStateEvent"), constructor_8693, 0, "rho;pv;recoVertices;met;metCovariance;triggerEvent;puInfo;hepeup;genParticles;evtId;genEventInfoProd;genFilterInfo;isRealData;puScenario;electronRefProd;muonRefProd;tauRefProd;jetRefProd;phoRefProd;pfRefProd;tracks;gsfTracks;mets", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_583, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATFinalStateEvent_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATFinalStateEvent_funcmem_bld);
}

//------Delayed data member builder for class PATFinalStateEvent -------------------
void __PATFinalStateEvent_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4901, Reflex::Literal("weights_"), OffsetOf(__shadow__::__PATFinalStateEvent, weights_), ::Reflex::PRIVATE)
  .AddDataMember(type_4900, Reflex::Literal("flags_"), OffsetOf(__shadow__::__PATFinalStateEvent, flags_), ::Reflex::PRIVATE)
  .AddDataMember(type_138, Reflex::Literal("rho_"), OffsetOf(__shadow__::__PATFinalStateEvent, rho_), ::Reflex::PRIVATE)
  .AddDataMember(type_19282, Reflex::Literal("triggerEvent_"), OffsetOf(__shadow__::__PATFinalStateEvent, triggerEvent_), ::Reflex::PRIVATE)
  .AddDataMember(type_9784, Reflex::Literal("pv_"), OffsetOf(__shadow__::__PATFinalStateEvent, pv_), ::Reflex::PRIVATE)
  .AddDataMember(type_8840, Reflex::Literal("recoVertices_"), OffsetOf(__shadow__::__PATFinalStateEvent, recoVertices_), ::Reflex::PRIVATE)
  .AddDataMember(type_9783, Reflex::Literal("met_"), OffsetOf(__shadow__::__PATFinalStateEvent, met_), ::Reflex::PRIVATE)
  .AddDataMember(type_3064, Reflex::Literal("metCovariance_"), OffsetOf(__shadow__::__PATFinalStateEvent, metCovariance_), ::Reflex::PRIVATE)
  .AddDataMember(type_4599, Reflex::Literal("puInfo_"), OffsetOf(__shadow__::__PATFinalStateEvent, puInfo_), ::Reflex::PRIVATE)
  .AddDataMember(type_15528, Reflex::Literal("lhe_"), OffsetOf(__shadow__::__PATFinalStateEvent, lhe_), ::Reflex::PRIVATE)
  .AddDataMember(type_16497, Reflex::Literal("genParticles_"), OffsetOf(__shadow__::__PATFinalStateEvent, genParticles_), ::Reflex::PRIVATE)
  .AddDataMember(type_9665, Reflex::Literal("evtID_"), OffsetOf(__shadow__::__PATFinalStateEvent, evtID_), ::Reflex::PRIVATE)
  .AddDataMember(type_1176, Reflex::Literal("genEventInfoProduct_"), OffsetOf(__shadow__::__PATFinalStateEvent, genEventInfoProduct_), ::Reflex::PRIVATE)
  .AddDataMember(type_2105, Reflex::Literal("generatorFilter_"), OffsetOf(__shadow__::__PATFinalStateEvent, generatorFilter_), ::Reflex::PRIVATE)
  .AddDataMember(type_2301, Reflex::Literal("isRealData_"), OffsetOf(__shadow__::__PATFinalStateEvent, isRealData_), ::Reflex::PRIVATE)
  .AddDataMember(type_3907, Reflex::Literal("puScenario_"), OffsetOf(__shadow__::__PATFinalStateEvent, puScenario_), ::Reflex::PRIVATE)
  .AddDataMember(type_414, Reflex::Literal("fsaDataFormatVersion_"), OffsetOf(__shadow__::__PATFinalStateEvent, fsaDataFormatVersion_), ::Reflex::PRIVATE)
  .AddDataMember(type_9700, Reflex::Literal("electronRefProd_"), OffsetOf(__shadow__::__PATFinalStateEvent, electronRefProd_), ::Reflex::PRIVATE)
  .AddDataMember(type_9699, Reflex::Literal("muonRefProd_"), OffsetOf(__shadow__::__PATFinalStateEvent, muonRefProd_), ::Reflex::PRIVATE)
  .AddDataMember(type_9698, Reflex::Literal("tauRefProd_"), OffsetOf(__shadow__::__PATFinalStateEvent, tauRefProd_), ::Reflex::PRIVATE)
  .AddDataMember(type_9697, Reflex::Literal("jetRefProd_"), OffsetOf(__shadow__::__PATFinalStateEvent, jetRefProd_), ::Reflex::PRIVATE)
  .AddDataMember(type_9696, Reflex::Literal("phoRefProd_"), OffsetOf(__shadow__::__PATFinalStateEvent, phoRefProd_), ::Reflex::PRIVATE)
  .AddDataMember(type_16531, Reflex::Literal("pfRefProd_"), OffsetOf(__shadow__::__PATFinalStateEvent, pfRefProd_), ::Reflex::PRIVATE)
  .AddDataMember(type_16438, Reflex::Literal("tracks_"), OffsetOf(__shadow__::__PATFinalStateEvent, tracks_), ::Reflex::PRIVATE)
  .AddDataMember(type_16457, Reflex::Literal("gsfTracks_"), OffsetOf(__shadow__::__PATFinalStateEvent, gsfTracks_), ::Reflex::PRIVATE)
  .AddDataMember(type_4899, Reflex::Literal("mets_"), OffsetOf(__shadow__::__PATFinalStateEvent, mets_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATFinalStateEvent -------------------
void __PATFinalStateEvent_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46448), Reflex::Literal("pv"), method_8694, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_50680), Reflex::Literal("recoVertices"), method_8695, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_50683), Reflex::Literal("puInfo"), method_8696, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_50684), Reflex::Literal("lesHouches"), method_8697, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_50686), Reflex::Literal("genEventInfo"), method_8698, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_50687), Reflex::Literal("generatorFilter"), method_8699, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138), Reflex::Literal("rho"), method_8700, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_50682), Reflex::Literal("trig"), method_8701, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46447), Reflex::Literal("met"), method_8702, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_50681), Reflex::Literal("metCovariance"), method_8703, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138), Reflex::Literal("metSignificance"), method_8704, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9783c, type_6741), Reflex::Literal("met"), method_8705, 0, "type", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14477c, type_6741, type_6741, type_88c), Reflex::Literal("met4vector"), method_8706, 0, "type;tag=\"\";applyPhiCorr=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29100), Reflex::Literal("evtId"), method_8707, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_88, type_6741), Reflex::Literal("hltResult"), method_8708, 0, "pattern", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_88, type_6741), Reflex::Literal("hltPrescale"), method_8709, 0, "pattern", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_88, type_6741), Reflex::Literal("hltGroup"), method_8710, 0, "pattern", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_88, type_50698, type_6741, type_138), Reflex::Literal("matchedToFilter"), method_8711, 0, "cand;filter;maxDeltaR=2.99999999999999988897769753748434595763683319091796875e-1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_88, type_50698, type_6741, type_138), Reflex::Literal("matchedToPath"), method_8712, 0, "cand;pattern;maxDeltaR=2.99999999999999988897769753748434595763683319091796875e-1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301c, type_88c, type_88c), Reflex::Literal("findDecay"), method_8713, 0, "pdgIdMother;pdgIdDaughter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6741), Reflex::Literal("puTag"), method_8714, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_6741), Reflex::Literal("puWeight"), method_8715, 0, "dataTag", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_6741, type_6741), Reflex::Literal("puWeight"), method_8716, 0, "dataTag;mcTag", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_6741), Reflex::Literal("puWeight3D"), method_8717, 0, "dataTag", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138, type_6741, type_6741), Reflex::Literal("puWeight3D"), method_8718, 0, "dataTag;mcTag", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1261, type_6741), Reflex::Literal("weight"), method_8719, 0, "name", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_6741, type_1261), Reflex::Literal("addWeight"), method_8720, 0, "name;weight", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_88, type_6741), Reflex::Literal("flag"), method_8721, 0, "flag", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_6741, type_88), Reflex::Literal("addFlag"), method_8722, 0, "name;flag", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isRealData"), method_8723, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_50699), Reflex::Literal("electrons"), method_8724, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_50700), Reflex::Literal("muons"), method_8725, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_50701), Reflex::Literal("jets"), method_8726, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_50702), Reflex::Literal("taus"), method_8727, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_50703), Reflex::Literal("photons"), method_8728, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_50704), Reflex::Literal("pflow"), method_8729, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16497c), Reflex::Literal("genParticleRefProd"), method_8730, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_414), Reflex::Literal("version"), method_8731, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1261, type_16736c, type_6741), Reflex::Literal("jetVariables"), method_8732, 0, "jet;myvar", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class PATFinalStateLS -------------------------------
static void destructor_18270(void*, void * o, const std::vector<void*>&, void *) {
(((::PATFinalStateLS*)o)->::PATFinalStateLS::~PATFinalStateLS)();
}
static  void operator_18271( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATFinalStateLS*)o)->operator=)(*(const ::PATFinalStateLS*)arg[0]);
  else   (((::PATFinalStateLS*)o)->operator=)(*(const ::PATFinalStateLS*)arg[0]);
}

static void constructor_18272( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATFinalStateLS(*(const ::PATFinalStateLS*)arg[0]);
  else ::new(mem) ::PATFinalStateLS(*(const ::PATFinalStateLS*)arg[0]);
}

static void constructor_18273( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATFinalStateLS();
  else ::new(mem) ::PATFinalStateLS();
}

static void constructor_18274( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATFinalStateLS(*(const ::edm::LuminosityBlockID*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
  else ::new(mem) ::PATFinalStateLS(*(const ::edm::LuminosityBlockID*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
}

static  void method_18275( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATFinalStateLS*)o)->lsID)();
  else   (((const ::PATFinalStateLS*)o)->lsID)();
}

static  void method_18276( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::PATFinalStateLS*)o)->instantaneousLumi)());
  else   (((const ::PATFinalStateLS*)o)->instantaneousLumi)();
}

static  void method_18277( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::PATFinalStateLS*)o)->intLumi)());
  else   (((const ::PATFinalStateLS*)o)->intLumi)();
}

static  void method_18278( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::PATFinalStateLS*)o)->mergeProduct)(*(const ::PATFinalStateLS*)arg[0]));
  else   (((::PATFinalStateLS*)o)->mergeProduct)(*(const ::PATFinalStateLS*)arg[0]);
}

static void method_newdel_3039( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATFinalStateLS >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATFinalStateLS >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATFinalStateLS >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATFinalStateLS >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATFinalStateLS >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class PATFinalStateLS -------------------------------
void __PATFinalStateLS_db_datamem(Reflex::Class*);
void __PATFinalStateLS_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATFinalStateLS_datamem_bld(&__PATFinalStateLS_db_datamem);
Reflex::GenreflexMemberBuilder __PATFinalStateLS_funcmem_bld(&__PATFinalStateLS_db_funcmem);
void __PATFinalStateLS_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATFinalStateLS"), typeid(::PATFinalStateLS), sizeof(::PATFinalStateLS), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATFinalStateLS"), destructor_18270, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14869, type_14871), Reflex::Literal("operator="), operator_18271, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14871), Reflex::Literal("PATFinalStateLS"), constructor_18272, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATFinalStateLS"), constructor_18273, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_54976, type_138, type_138), Reflex::Literal("PATFinalStateLS"), constructor_18274, 0, "id;integratedLuminosity;instantaneousLumi", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3039, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATFinalStateLS_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATFinalStateLS_funcmem_bld);
}

//------Delayed data member builder for class PATFinalStateLS -------------------
void __PATFinalStateLS_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9676, Reflex::Literal("id_"), OffsetOf(__shadow__::__PATFinalStateLS, id_), ::Reflex::PRIVATE)
  .AddDataMember(type_138, Reflex::Literal("integratedLumi_"), OffsetOf(__shadow__::__PATFinalStateLS, integratedLumi_), ::Reflex::PRIVATE)
  .AddDataMember(type_138, Reflex::Literal("instaneousLumi_"), OffsetOf(__shadow__::__PATFinalStateLS, instaneousLumi_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATFinalStateLS -------------------
void __PATFinalStateLS_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_54976), Reflex::Literal("lsID"), method_18275, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138), Reflex::Literal("instantaneousLumi"), method_18276, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_138), Reflex::Literal("intLumi"), method_18277, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301, type_14871), Reflex::Literal("mergeProduct"), method_18278, 0, "other", ::Reflex::PUBLIC);
}
//------Stub functions for class Ptr<PATFinalStateLS> -------------------------------
static  void operator_13296( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ptr<PATFinalStateLS>*)o)->operator=)(*(const ::edm::Ptr<PATFinalStateLS>*)arg[0]);
  else   (((::edm::Ptr<PATFinalStateLS>*)o)->operator=)(*(const ::edm::Ptr<PATFinalStateLS>*)arg[0]);
}

static void constructor_13297( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<PATFinalStateLS>(*(const ::edm::Ptr<PATFinalStateLS>*)arg[0]);
  else ::new(mem) ::edm::Ptr<PATFinalStateLS>(*(const ::edm::Ptr<PATFinalStateLS>*)arg[0]);
}

static void constructor_13298( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<PATFinalStateLS>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ptr<PATFinalStateLS>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_13299( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<PATFinalStateLS>(*(const ::edm::ProductID*)arg[0],
      (const ::PATFinalStateLS*)arg[1],
      *(unsigned long*)arg[2]);
  else ::new(mem) ::edm::Ptr<PATFinalStateLS>(*(const ::edm::ProductID*)arg[0],
      (const ::PATFinalStateLS*)arg[1],
      *(unsigned long*)arg[2]);
}

static void constructor_13300( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<PATFinalStateLS>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ptr<PATFinalStateLS>(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_13301( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<PATFinalStateLS>();
  else ::new(mem) ::edm::Ptr<PATFinalStateLS>();
}

static void destructor_13302(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ptr<PATFinalStateLS>*)o)->::edm::Ptr<PATFinalStateLS>::~Ptr)();
}
static  void operator_13303( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<PATFinalStateLS>*)o)->operator*)();
  else   (((const ::edm::Ptr<PATFinalStateLS>*)o)->operator*)();
}

static  void operator_13304( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<PATFinalStateLS>*)o)->operator->)());
  else   (((const ::edm::Ptr<PATFinalStateLS>*)o)->operator->)();
}

static  void method_13305( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<PATFinalStateLS>*)o)->get)());
  else   (((const ::edm::Ptr<PATFinalStateLS>*)o)->get)();
}

static  void method_13306( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<PATFinalStateLS>*)o)->isNull)());
  else   (((const ::edm::Ptr<PATFinalStateLS>*)o)->isNull)();
}

static  void method_13307( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<PATFinalStateLS>*)o)->isNonnull)());
  else   (((const ::edm::Ptr<PATFinalStateLS>*)o)->isNonnull)();
}

static  void operator_13308( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<PATFinalStateLS>*)o)->operator!)());
  else   (((const ::edm::Ptr<PATFinalStateLS>*)o)->operator!)();
}

static  void method_13309( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<PATFinalStateLS>*)o)->isAvailable)());
  else   (((const ::edm::Ptr<PATFinalStateLS>*)o)->isAvailable)();
}

static  void method_13310( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<PATFinalStateLS>*)o)->isTransient)());
  else   (((const ::edm::Ptr<PATFinalStateLS>*)o)->isTransient)();
}

static  void method_13311( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ptr<PATFinalStateLS>*)o)->id)());
  else   (((const ::edm::Ptr<PATFinalStateLS>*)o)->id)();
}

static  void method_13312( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<PATFinalStateLS>*)o)->productGetter)());
  else   (((const ::edm::Ptr<PATFinalStateLS>*)o)->productGetter)();
}

static  void method_13313( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::edm::Ptr<PATFinalStateLS>*)o)->key)());
  else   (((const ::edm::Ptr<PATFinalStateLS>*)o)->key)();
}

static  void method_13314( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<PATFinalStateLS>*)o)->hasProductCache)());
  else   (((const ::edm::Ptr<PATFinalStateLS>*)o)->hasProductCache)();
}

static  void method_13315( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<PATFinalStateLS>*)o)->refCore)();
  else   (((const ::edm::Ptr<PATFinalStateLS>*)o)->refCore)();
}

static  void method_13316( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<PATFinalStateLS>*)o)->product)());
  else   (((const ::edm::Ptr<PATFinalStateLS>*)o)->product)();
}

static  void method_13317( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ptr<PATFinalStateLS>*)o)->Class_Version)());
  else   (((::edm::Ptr<PATFinalStateLS>*)o)->Class_Version)();
}

static void method_newdel_1814( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ptr<PATFinalStateLS> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ptr<PATFinalStateLS> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ptr<PATFinalStateLS> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ptr<PATFinalStateLS> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ptr<PATFinalStateLS> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ptr<PATFinalStateLS> -------------------------------
void __edm__Ptr_PATFinalStateLS__db_datamem(Reflex::Class*);
void __edm__Ptr_PATFinalStateLS__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ptr_PATFinalStateLS__datamem_bld(&__edm__Ptr_PATFinalStateLS__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ptr_PATFinalStateLS__funcmem_bld(&__edm__Ptr_PATFinalStateLS__db_funcmem);
void __edm__Ptr_PATFinalStateLS__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ptr<PATFinalStateLS>"), typeid(::edm::Ptr<PATFinalStateLS>), sizeof(::edm::Ptr<PATFinalStateLS>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ptr<PATFinalStateLS>::Class_Version())
  .AddTypedef(type_484, Reflex::Literal("edm::Ptr<PATFinalStateLS>::key_type"))
  .AddTypedef(type_3039, Reflex::Literal("edm::Ptr<PATFinalStateLS>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60200, type_60201), Reflex::Literal("operator="), operator_13296, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60201), Reflex::Literal("Ptr"), constructor_13297, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417, type_484, type_45418), Reflex::Literal("Ptr"), constructor_13298, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417, type_14867, type_484), Reflex::Literal("Ptr"), constructor_13299, 0, "productID;item;item_key", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417), Reflex::Literal("Ptr"), constructor_13300, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ptr"), constructor_13301, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ptr"), destructor_13302, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1814, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ptr_PATFinalStateLS__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ptr_PATFinalStateLS__funcmem_bld);
}

//------Delayed data member builder for class Ptr<PATFinalStateLS> -------------------
void __edm__Ptr_PATFinalStateLS__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9667, Reflex::Literal("core_"), OffsetOf(__shadow__::__edm__Ptr_PATFinalStateLS_, core_), ::Reflex::PRIVATE)
  .AddDataMember(type_484, Reflex::Literal("key_"), OffsetOf(__shadow__::__edm__Ptr_PATFinalStateLS_, key_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Ptr<PATFinalStateLS> -------------------
void __edm__Ptr_PATFinalStateLS__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14871), Reflex::Literal("operator*"), operator_13303, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14867), Reflex::Literal("operator->"), operator_13304, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14867), Reflex::Literal("get"), method_13305, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNull"), method_13306, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNonnull"), method_13307, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("operator!"), operator_13308, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isAvailable"), method_13309, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isTransient"), method_13310, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9664), Reflex::Literal("id"), method_13311, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45418), Reflex::Literal("productGetter"), method_13312, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_484), Reflex::Literal("key"), method_13313, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("hasProductCache"), method_13314, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45420), Reflex::Literal("refCore"), method_13315, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6842), Reflex::Literal("product"), method_13316, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_251), Reflex::Literal("Class_Version"), method_13317, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ptr<PATFinalStateEvent> -------------------------------
static  void operator_15371( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ptr<PATFinalStateEvent>*)o)->operator=)(*(const ::edm::Ptr<PATFinalStateEvent>*)arg[0]);
  else   (((::edm::Ptr<PATFinalStateEvent>*)o)->operator=)(*(const ::edm::Ptr<PATFinalStateEvent>*)arg[0]);
}

static void constructor_15372( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<PATFinalStateEvent>(*(const ::edm::Ptr<PATFinalStateEvent>*)arg[0]);
  else ::new(mem) ::edm::Ptr<PATFinalStateEvent>(*(const ::edm::Ptr<PATFinalStateEvent>*)arg[0]);
}

static void constructor_15373( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<PATFinalStateEvent>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ptr<PATFinalStateEvent>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_15374( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<PATFinalStateEvent>(*(const ::edm::ProductID*)arg[0],
      (const ::PATFinalStateEvent*)arg[1],
      *(unsigned long*)arg[2]);
  else ::new(mem) ::edm::Ptr<PATFinalStateEvent>(*(const ::edm::ProductID*)arg[0],
      (const ::PATFinalStateEvent*)arg[1],
      *(unsigned long*)arg[2]);
}

static void constructor_15375( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<PATFinalStateEvent>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ptr<PATFinalStateEvent>(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_15376( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<PATFinalStateEvent>();
  else ::new(mem) ::edm::Ptr<PATFinalStateEvent>();
}

static void destructor_15377(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ptr<PATFinalStateEvent>*)o)->::edm::Ptr<PATFinalStateEvent>::~Ptr)();
}
static  void operator_15378( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<PATFinalStateEvent>*)o)->operator*)();
  else   (((const ::edm::Ptr<PATFinalStateEvent>*)o)->operator*)();
}

static  void operator_15379( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<PATFinalStateEvent>*)o)->operator->)());
  else   (((const ::edm::Ptr<PATFinalStateEvent>*)o)->operator->)();
}

static  void method_15380( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<PATFinalStateEvent>*)o)->get)());
  else   (((const ::edm::Ptr<PATFinalStateEvent>*)o)->get)();
}

static  void method_15381( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<PATFinalStateEvent>*)o)->isNull)());
  else   (((const ::edm::Ptr<PATFinalStateEvent>*)o)->isNull)();
}

static  void method_15382( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<PATFinalStateEvent>*)o)->isNonnull)());
  else   (((const ::edm::Ptr<PATFinalStateEvent>*)o)->isNonnull)();
}

static  void operator_15383( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<PATFinalStateEvent>*)o)->operator!)());
  else   (((const ::edm::Ptr<PATFinalStateEvent>*)o)->operator!)();
}

static  void method_15384( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<PATFinalStateEvent>*)o)->isAvailable)());
  else   (((const ::edm::Ptr<PATFinalStateEvent>*)o)->isAvailable)();
}

static  void method_15385( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<PATFinalStateEvent>*)o)->isTransient)());
  else   (((const ::edm::Ptr<PATFinalStateEvent>*)o)->isTransient)();
}

static  void method_15386( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ptr<PATFinalStateEvent>*)o)->id)());
  else   (((const ::edm::Ptr<PATFinalStateEvent>*)o)->id)();
}

static  void method_15387( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<PATFinalStateEvent>*)o)->productGetter)());
  else   (((const ::edm::Ptr<PATFinalStateEvent>*)o)->productGetter)();
}

static  void method_15388( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::edm::Ptr<PATFinalStateEvent>*)o)->key)());
  else   (((const ::edm::Ptr<PATFinalStateEvent>*)o)->key)();
}

static  void method_15389( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<PATFinalStateEvent>*)o)->hasProductCache)());
  else   (((const ::edm::Ptr<PATFinalStateEvent>*)o)->hasProductCache)();
}

static  void method_15390( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<PATFinalStateEvent>*)o)->refCore)();
  else   (((const ::edm::Ptr<PATFinalStateEvent>*)o)->refCore)();
}

static  void method_15391( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<PATFinalStateEvent>*)o)->product)());
  else   (((const ::edm::Ptr<PATFinalStateEvent>*)o)->product)();
}

static  void method_15392( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ptr<PATFinalStateEvent>*)o)->Class_Version)());
  else   (((::edm::Ptr<PATFinalStateEvent>*)o)->Class_Version)();
}

static void method_newdel_2414( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ptr<PATFinalStateEvent> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ptr<PATFinalStateEvent> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ptr<PATFinalStateEvent> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ptr<PATFinalStateEvent> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ptr<PATFinalStateEvent> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ptr<PATFinalStateEvent> -------------------------------
void __edm__Ptr_PATFinalStateEvent__db_datamem(Reflex::Class*);
void __edm__Ptr_PATFinalStateEvent__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ptr_PATFinalStateEvent__datamem_bld(&__edm__Ptr_PATFinalStateEvent__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ptr_PATFinalStateEvent__funcmem_bld(&__edm__Ptr_PATFinalStateEvent__db_funcmem);
void __edm__Ptr_PATFinalStateEvent__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ptr<PATFinalStateEvent>"), typeid(::edm::Ptr<PATFinalStateEvent>), sizeof(::edm::Ptr<PATFinalStateEvent>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ptr<PATFinalStateEvent>::Class_Version())
  .AddTypedef(type_484, Reflex::Literal("edm::Ptr<PATFinalStateEvent>::key_type"))
  .AddTypedef(type_583, Reflex::Literal("edm::Ptr<PATFinalStateEvent>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60878, type_45406), Reflex::Literal("operator="), operator_15371, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45406), Reflex::Literal("Ptr"), constructor_15372, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417, type_484, type_45418), Reflex::Literal("Ptr"), constructor_15373, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417, type_7665, type_484), Reflex::Literal("Ptr"), constructor_15374, 0, "productID;item;item_key", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417), Reflex::Literal("Ptr"), constructor_15375, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ptr"), constructor_15376, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ptr"), destructor_15377, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2414, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ptr_PATFinalStateEvent__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ptr_PATFinalStateEvent__funcmem_bld);
}

//------Delayed data member builder for class Ptr<PATFinalStateEvent> -------------------
void __edm__Ptr_PATFinalStateEvent__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9667, Reflex::Literal("core_"), OffsetOf(__shadow__::__edm__Ptr_PATFinalStateEvent_, core_), ::Reflex::PRIVATE)
  .AddDataMember(type_484, Reflex::Literal("key_"), OffsetOf(__shadow__::__edm__Ptr_PATFinalStateEvent_, key_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Ptr<PATFinalStateEvent> -------------------
void __edm__Ptr_PATFinalStateEvent__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7669), Reflex::Literal("operator*"), operator_15378, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7665), Reflex::Literal("operator->"), operator_15379, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7665), Reflex::Literal("get"), method_15380, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNull"), method_15381, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNonnull"), method_15382, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("operator!"), operator_15383, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isAvailable"), method_15384, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isTransient"), method_15385, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9664), Reflex::Literal("id"), method_15386, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45418), Reflex::Literal("productGetter"), method_15387, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_484), Reflex::Literal("key"), method_15388, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("hasProductCache"), method_15389, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45420), Reflex::Literal("refCore"), method_15390, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6842), Reflex::Literal("product"), method_15391, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_251), Reflex::Literal("Class_Version"), method_15392, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class VBFVariables -------------------------------
static void destructor_15551(void*, void * o, const std::vector<void*>&, void *) {
(((::VBFVariables*)o)->::VBFVariables::~VBFVariables)();
}
static  void operator_15552( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::VBFVariables*)o)->operator=)(*(const ::VBFVariables*)arg[0]);
  else   (((::VBFVariables*)o)->operator=)(*(const ::VBFVariables*)arg[0]);
}

static void constructor_15553( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::VBFVariables(*(const ::VBFVariables*)arg[0]);
  else ::new(mem) ::VBFVariables(*(const ::VBFVariables*)arg[0]);
}

static void constructor_15554( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::VBFVariables();
  else ::new(mem) ::VBFVariables();
}

static void method_newdel_2448( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::VBFVariables >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::VBFVariables >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::VBFVariables >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::VBFVariables >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::VBFVariables >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class VBFVariables -------------------------------
void __VBFVariables_db_datamem(Reflex::Class*);
void __VBFVariables_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __VBFVariables_datamem_bld(&__VBFVariables_db_datamem);
Reflex::GenreflexMemberBuilder __VBFVariables_funcmem_bld(&__VBFVariables_db_funcmem);
void __VBFVariables_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("VBFVariables"), typeid(::VBFVariables), sizeof(::VBFVariables), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "11")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~VBFVariables"), destructor_15551, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60925, type_60926), Reflex::Literal("operator="), operator_15552, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60926), Reflex::Literal("VBFVariables"), constructor_15553, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("VBFVariables"), constructor_15554, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2448, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__VBFVariables_datamem_bld);
}

//------Delayed data member builder for class VBFVariables -------------------
void __VBFVariables_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_45407, Reflex::Literal("leadJet"), OffsetOf(__shadow__::__VBFVariables, leadJet), ::Reflex::PUBLIC)
  .AddDataMember(type_45407, Reflex::Literal("subleadJet"), OffsetOf(__shadow__::__VBFVariables, subleadJet), ::Reflex::PUBLIC)
  .AddDataMember(type_138, Reflex::Literal("mass"), OffsetOf(__shadow__::__VBFVariables, mass), ::Reflex::PUBLIC)
  .AddDataMember(type_138, Reflex::Literal("deta"), OffsetOf(__shadow__::__VBFVariables, deta), ::Reflex::PUBLIC)
  .AddDataMember(type_138, Reflex::Literal("dphi"), OffsetOf(__shadow__::__VBFVariables, dphi), ::Reflex::PUBLIC)
  .AddDataMember(type_138, Reflex::Literal("pt1"), OffsetOf(__shadow__::__VBFVariables, pt1), ::Reflex::PUBLIC)
  .AddDataMember(type_138, Reflex::Literal("pt2"), OffsetOf(__shadow__::__VBFVariables, pt2), ::Reflex::PUBLIC)
  .AddDataMember(type_138, Reflex::Literal("dijetpt"), OffsetOf(__shadow__::__VBFVariables, dijetpt), ::Reflex::PUBLIC)
  .AddDataMember(type_138, Reflex::Literal("ditaupt"), OffsetOf(__shadow__::__VBFVariables, ditaupt), ::Reflex::PUBLIC)
  .AddDataMember(type_138, Reflex::Literal("hrapidity"), OffsetOf(__shadow__::__VBFVariables, hrapidity), ::Reflex::PUBLIC)
  .AddDataMember(type_138, Reflex::Literal("dijetrapidity"), OffsetOf(__shadow__::__VBFVariables, dijetrapidity), ::Reflex::PUBLIC)
  .AddDataMember(type_138, Reflex::Literal("eta1"), OffsetOf(__shadow__::__VBFVariables, eta1), ::Reflex::PUBLIC)
  .AddDataMember(type_138, Reflex::Literal("eta2"), OffsetOf(__shadow__::__VBFVariables, eta2), ::Reflex::PUBLIC)
  .AddDataMember(type_138, Reflex::Literal("dphihj"), OffsetOf(__shadow__::__VBFVariables, dphihj), ::Reflex::PUBLIC)
  .AddDataMember(type_138, Reflex::Literal("dphihj_nomet"), OffsetOf(__shadow__::__VBFVariables, dphihj_nomet), ::Reflex::PUBLIC)
  .AddDataMember(type_138, Reflex::Literal("c1"), OffsetOf(__shadow__::__VBFVariables, c1), ::Reflex::PUBLIC)
  .AddDataMember(type_138, Reflex::Literal("c2"), OffsetOf(__shadow__::__VBFVariables, c2), ::Reflex::PUBLIC)
  .AddDataMember(type_138, Reflex::Literal("mva"), OffsetOf(__shadow__::__VBFVariables, mva), ::Reflex::PUBLIC)
  .AddDataMember(type_497, Reflex::Literal("jets20"), OffsetOf(__shadow__::__VBFVariables, jets20), ::Reflex::PUBLIC)
  .AddDataMember(type_497, Reflex::Literal("jets30"), OffsetOf(__shadow__::__VBFVariables, jets30), ::Reflex::PUBLIC)
  .AddDataMember(type_497, Reflex::Literal("nJets"), OffsetOf(__shadow__::__VBFVariables, nJets), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class VBFVariables -------------------
void __VBFVariables_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class PATFinalStateProxy -------------------------------
static void destructor_17375(void*, void * o, const std::vector<void*>&, void *) {
(((::PATFinalStateProxy*)o)->::PATFinalStateProxy::~PATFinalStateProxy)();
}
static  void operator_17376( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATFinalStateProxy*)o)->operator=)(*(const ::PATFinalStateProxy*)arg[0]);
  else   (((::PATFinalStateProxy*)o)->operator=)(*(const ::PATFinalStateProxy*)arg[0]);
}

static void constructor_17377( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATFinalStateProxy(*(const ::PATFinalStateProxy*)arg[0]);
  else ::new(mem) ::PATFinalStateProxy(*(const ::PATFinalStateProxy*)arg[0]);
}

static void constructor_17378( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATFinalStateProxy((::PATFinalState*)arg[0]);
  else ::new(mem) ::PATFinalStateProxy((::PATFinalState*)arg[0]);
}

static void constructor_17379( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATFinalStateProxy();
  else ::new(mem) ::PATFinalStateProxy();
}

static  void method_17380( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATFinalStateProxy*)o)->get)());
  else   (((const ::PATFinalStateProxy*)o)->get)();
}

static  void operator_17381( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATFinalStateProxy*)o)->operator->)());
  else   (((const ::PATFinalStateProxy*)o)->operator->)();
}

static void method_newdel_2951( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATFinalStateProxy >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATFinalStateProxy >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATFinalStateProxy >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATFinalStateProxy >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATFinalStateProxy >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class PATFinalStateProxy -------------------------------
void __PATFinalStateProxy_db_datamem(Reflex::Class*);
void __PATFinalStateProxy_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATFinalStateProxy_datamem_bld(&__PATFinalStateProxy_db_datamem);
Reflex::GenreflexMemberBuilder __PATFinalStateProxy_funcmem_bld(&__PATFinalStateProxy_db_funcmem);
void __PATFinalStateProxy_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATFinalStateProxy"), typeid(::PATFinalStateProxy), sizeof(::PATFinalStateProxy), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATFinalStateProxy"), destructor_17375, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63848, type_63849), Reflex::Literal("operator="), operator_17376, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63849), Reflex::Literal("PATFinalStateProxy"), constructor_17377, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11110), Reflex::Literal("PATFinalStateProxy"), constructor_17378, 0, "finalState", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATFinalStateProxy"), constructor_17379, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2951, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATFinalStateProxy_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATFinalStateProxy_funcmem_bld);
}

//------Delayed data member builder for class PATFinalStateProxy -------------------
void __PATFinalStateProxy_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7828, Reflex::Literal("finalState_"), OffsetOf(__shadow__::__PATFinalStateProxy, finalState_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATFinalStateProxy -------------------
void __PATFinalStateProxy_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_47165), Reflex::Literal("get"), method_17380, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_47165), Reflex::Literal("operator->"), operator_17381, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class Ptr<PATMultiCandFinalState> -------------------------------
static  void operator_19028( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ptr<PATMultiCandFinalState>*)o)->operator=)(*(const ::edm::Ptr<PATMultiCandFinalState>*)arg[0]);
  else   (((::edm::Ptr<PATMultiCandFinalState>*)o)->operator=)(*(const ::edm::Ptr<PATMultiCandFinalState>*)arg[0]);
}

static void constructor_19029( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<PATMultiCandFinalState>(*(const ::edm::Ptr<PATMultiCandFinalState>*)arg[0]);
  else ::new(mem) ::edm::Ptr<PATMultiCandFinalState>(*(const ::edm::Ptr<PATMultiCandFinalState>*)arg[0]);
}

static void constructor_19030( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<PATMultiCandFinalState>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ptr<PATMultiCandFinalState>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_19031( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<PATMultiCandFinalState>(*(const ::edm::ProductID*)arg[0],
      (const ::PATMultiCandFinalState*)arg[1],
      *(unsigned long*)arg[2]);
  else ::new(mem) ::edm::Ptr<PATMultiCandFinalState>(*(const ::edm::ProductID*)arg[0],
      (const ::PATMultiCandFinalState*)arg[1],
      *(unsigned long*)arg[2]);
}

static void constructor_19032( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<PATMultiCandFinalState>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ptr<PATMultiCandFinalState>(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_19033( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<PATMultiCandFinalState>();
  else ::new(mem) ::edm::Ptr<PATMultiCandFinalState>();
}

static void destructor_19034(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ptr<PATMultiCandFinalState>*)o)->::edm::Ptr<PATMultiCandFinalState>::~Ptr)();
}
static  void operator_19035( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<PATMultiCandFinalState>*)o)->operator*)();
  else   (((const ::edm::Ptr<PATMultiCandFinalState>*)o)->operator*)();
}

static  void operator_19036( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<PATMultiCandFinalState>*)o)->operator->)());
  else   (((const ::edm::Ptr<PATMultiCandFinalState>*)o)->operator->)();
}

static  void method_19037( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<PATMultiCandFinalState>*)o)->get)());
  else   (((const ::edm::Ptr<PATMultiCandFinalState>*)o)->get)();
}

static  void method_19038( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<PATMultiCandFinalState>*)o)->isNull)());
  else   (((const ::edm::Ptr<PATMultiCandFinalState>*)o)->isNull)();
}

static  void method_19039( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<PATMultiCandFinalState>*)o)->isNonnull)());
  else   (((const ::edm::Ptr<PATMultiCandFinalState>*)o)->isNonnull)();
}

static  void operator_19040( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<PATMultiCandFinalState>*)o)->operator!)());
  else   (((const ::edm::Ptr<PATMultiCandFinalState>*)o)->operator!)();
}

static  void method_19041( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<PATMultiCandFinalState>*)o)->isAvailable)());
  else   (((const ::edm::Ptr<PATMultiCandFinalState>*)o)->isAvailable)();
}

static  void method_19042( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<PATMultiCandFinalState>*)o)->isTransient)());
  else   (((const ::edm::Ptr<PATMultiCandFinalState>*)o)->isTransient)();
}

static  void method_19043( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ptr<PATMultiCandFinalState>*)o)->id)());
  else   (((const ::edm::Ptr<PATMultiCandFinalState>*)o)->id)();
}

static  void method_19044( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<PATMultiCandFinalState>*)o)->productGetter)());
  else   (((const ::edm::Ptr<PATMultiCandFinalState>*)o)->productGetter)();
}

static  void method_19045( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::edm::Ptr<PATMultiCandFinalState>*)o)->key)());
  else   (((const ::edm::Ptr<PATMultiCandFinalState>*)o)->key)();
}

static  void method_19046( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<PATMultiCandFinalState>*)o)->hasProductCache)());
  else   (((const ::edm::Ptr<PATMultiCandFinalState>*)o)->hasProductCache)();
}

static  void method_19047( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<PATMultiCandFinalState>*)o)->refCore)();
  else   (((const ::edm::Ptr<PATMultiCandFinalState>*)o)->refCore)();
}

static  void method_19048( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<PATMultiCandFinalState>*)o)->product)());
  else   (((const ::edm::Ptr<PATMultiCandFinalState>*)o)->product)();
}

static  void method_19049( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ptr<PATMultiCandFinalState>*)o)->Class_Version)());
  else   (((::edm::Ptr<PATMultiCandFinalState>*)o)->Class_Version)();
}

static void method_newdel_3318( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ptr<PATMultiCandFinalState> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ptr<PATMultiCandFinalState> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ptr<PATMultiCandFinalState> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ptr<PATMultiCandFinalState> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ptr<PATMultiCandFinalState> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ptr<PATMultiCandFinalState> -------------------------------
void __edm__Ptr_PATMultiCandFinalState__db_datamem(Reflex::Class*);
void __edm__Ptr_PATMultiCandFinalState__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ptr_PATMultiCandFinalState__datamem_bld(&__edm__Ptr_PATMultiCandFinalState__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ptr_PATMultiCandFinalState__funcmem_bld(&__edm__Ptr_PATMultiCandFinalState__db_funcmem);
void __edm__Ptr_PATMultiCandFinalState__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ptr<PATMultiCandFinalState>"), typeid(::edm::Ptr<PATMultiCandFinalState>), sizeof(::edm::Ptr<PATMultiCandFinalState>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ptr<PATMultiCandFinalState>::Class_Version())
  .AddTypedef(type_484, Reflex::Literal("edm::Ptr<PATMultiCandFinalState>::key_type"))
  .AddTypedef(type_67, Reflex::Literal("edm::Ptr<PATMultiCandFinalState>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70722, type_60859), Reflex::Literal("operator="), operator_19028, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60859), Reflex::Literal("Ptr"), constructor_19029, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417, type_484, type_45418), Reflex::Literal("Ptr"), constructor_19030, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417, type_18146, type_484), Reflex::Literal("Ptr"), constructor_19031, 0, "productID;item;item_key", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417), Reflex::Literal("Ptr"), constructor_19032, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ptr"), constructor_19033, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ptr"), destructor_19034, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3318, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ptr_PATMultiCandFinalState__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ptr_PATMultiCandFinalState__funcmem_bld);
}

//------Delayed data member builder for class Ptr<PATMultiCandFinalState> -------------------
void __edm__Ptr_PATMultiCandFinalState__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9667, Reflex::Literal("core_"), OffsetOf(__shadow__::__edm__Ptr_PATMultiCandFinalState_, core_), ::Reflex::PRIVATE)
  .AddDataMember(type_484, Reflex::Literal("key_"), OffsetOf(__shadow__::__edm__Ptr_PATMultiCandFinalState_, key_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Ptr<PATMultiCandFinalState> -------------------
void __edm__Ptr_PATMultiCandFinalState__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18150), Reflex::Literal("operator*"), operator_19035, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18146), Reflex::Literal("operator->"), operator_19036, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18146), Reflex::Literal("get"), method_19037, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNull"), method_19038, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNonnull"), method_19039, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("operator!"), operator_19040, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isAvailable"), method_19041, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isTransient"), method_19042, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9664), Reflex::Literal("id"), method_19043, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45418), Reflex::Literal("productGetter"), method_19044, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_484), Reflex::Literal("key"), method_19045, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("hasProductCache"), method_19046, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45420), Reflex::Literal("refCore"), method_19047, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6842), Reflex::Literal("product"), method_19048, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_251), Reflex::Literal("Class_Version"), method_19049, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ptr<PATFinalState> -------------------------------
static  void operator_20197( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ptr<PATFinalState>*)o)->operator=)(*(const ::edm::Ptr<PATFinalState>*)arg[0]);
  else   (((::edm::Ptr<PATFinalState>*)o)->operator=)(*(const ::edm::Ptr<PATFinalState>*)arg[0]);
}

static void constructor_20198( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<PATFinalState>(*(const ::edm::Ptr<PATFinalState>*)arg[0]);
  else ::new(mem) ::edm::Ptr<PATFinalState>(*(const ::edm::Ptr<PATFinalState>*)arg[0]);
}

static void constructor_20199( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<PATFinalState>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ptr<PATFinalState>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_20200( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<PATFinalState>(*(const ::edm::ProductID*)arg[0],
      (const ::PATFinalState*)arg[1],
      *(unsigned long*)arg[2]);
  else ::new(mem) ::edm::Ptr<PATFinalState>(*(const ::edm::ProductID*)arg[0],
      (const ::PATFinalState*)arg[1],
      *(unsigned long*)arg[2]);
}

static void constructor_20201( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<PATFinalState>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ptr<PATFinalState>(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_20202( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<PATFinalState>();
  else ::new(mem) ::edm::Ptr<PATFinalState>();
}

static void destructor_20203(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ptr<PATFinalState>*)o)->::edm::Ptr<PATFinalState>::~Ptr)();
}
static  void operator_20204( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<PATFinalState>*)o)->operator*)();
  else   (((const ::edm::Ptr<PATFinalState>*)o)->operator*)();
}

static  void operator_20205( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<PATFinalState>*)o)->operator->)());
  else   (((const ::edm::Ptr<PATFinalState>*)o)->operator->)();
}

static  void method_20206( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<PATFinalState>*)o)->get)());
  else   (((const ::edm::Ptr<PATFinalState>*)o)->get)();
}

static  void method_20207( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<PATFinalState>*)o)->isNull)());
  else   (((const ::edm::Ptr<PATFinalState>*)o)->isNull)();
}

static  void method_20208( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<PATFinalState>*)o)->isNonnull)());
  else   (((const ::edm::Ptr<PATFinalState>*)o)->isNonnull)();
}

static  void operator_20209( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<PATFinalState>*)o)->operator!)());
  else   (((const ::edm::Ptr<PATFinalState>*)o)->operator!)();
}

static  void method_20210( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<PATFinalState>*)o)->isAvailable)());
  else   (((const ::edm::Ptr<PATFinalState>*)o)->isAvailable)();
}

static  void method_20211( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<PATFinalState>*)o)->isTransient)());
  else   (((const ::edm::Ptr<PATFinalState>*)o)->isTransient)();
}

static  void method_20212( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ptr<PATFinalState>*)o)->id)());
  else   (((const ::edm::Ptr<PATFinalState>*)o)->id)();
}

static  void method_20213( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<PATFinalState>*)o)->productGetter)());
  else   (((const ::edm::Ptr<PATFinalState>*)o)->productGetter)();
}

static  void method_20214( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::edm::Ptr<PATFinalState>*)o)->key)());
  else   (((const ::edm::Ptr<PATFinalState>*)o)->key)();
}

static  void method_20215( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<PATFinalState>*)o)->hasProductCache)());
  else   (((const ::edm::Ptr<PATFinalState>*)o)->hasProductCache)();
}

static  void method_20216( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<PATFinalState>*)o)->refCore)();
  else   (((const ::edm::Ptr<PATFinalState>*)o)->refCore)();
}

static  void method_20217( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<PATFinalState>*)o)->product)());
  else   (((const ::edm::Ptr<PATFinalState>*)o)->product)();
}

static  void method_20218( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ptr<PATFinalState>*)o)->Class_Version)());
  else   (((::edm::Ptr<PATFinalState>*)o)->Class_Version)();
}

static void method_newdel_3651( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ptr<PATFinalState> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ptr<PATFinalState> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ptr<PATFinalState> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ptr<PATFinalState> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ptr<PATFinalState> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ptr<PATFinalState> -------------------------------
void __edm__Ptr_PATFinalState__db_datamem(Reflex::Class*);
void __edm__Ptr_PATFinalState__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ptr_PATFinalState__datamem_bld(&__edm__Ptr_PATFinalState__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ptr_PATFinalState__funcmem_bld(&__edm__Ptr_PATFinalState__db_funcmem);
void __edm__Ptr_PATFinalState__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ptr<PATFinalState>"), typeid(::edm::Ptr<PATFinalState>), sizeof(::edm::Ptr<PATFinalState>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ptr<PATFinalState>::Class_Version())
  .AddTypedef(type_484, Reflex::Literal("edm::Ptr<PATFinalState>::key_type"))
  .AddTypedef(type_466, Reflex::Literal("edm::Ptr<PATFinalState>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72490, type_72181), Reflex::Literal("operator="), operator_20197, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72181), Reflex::Literal("Ptr"), constructor_20198, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417, type_484, type_45418), Reflex::Literal("Ptr"), constructor_20199, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417, type_47165, type_484), Reflex::Literal("Ptr"), constructor_20200, 0, "productID;item;item_key", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417), Reflex::Literal("Ptr"), constructor_20201, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ptr"), constructor_20202, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ptr"), destructor_20203, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3651, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ptr_PATFinalState__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ptr_PATFinalState__funcmem_bld);
}

//------Delayed data member builder for class Ptr<PATFinalState> -------------------
void __edm__Ptr_PATFinalState__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9667, Reflex::Literal("core_"), OffsetOf(__shadow__::__edm__Ptr_PATFinalState_, core_), ::Reflex::PRIVATE)
  .AddDataMember(type_484, Reflex::Literal("key_"), OffsetOf(__shadow__::__edm__Ptr_PATFinalState_, key_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Ptr<PATFinalState> -------------------
void __edm__Ptr_PATFinalState__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11114), Reflex::Literal("operator*"), operator_20204, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_47165), Reflex::Literal("operator->"), operator_20205, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_47165), Reflex::Literal("get"), method_20206, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNull"), method_20207, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNonnull"), method_20208, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("operator!"), operator_20209, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isAvailable"), method_20210, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isTransient"), method_20211, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9664), Reflex::Literal("id"), method_20212, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45418), Reflex::Literal("productGetter"), method_20213, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_484), Reflex::Literal("key"), method_20214, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("hasProductCache"), method_20215, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45420), Reflex::Literal("refCore"), method_20216, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6842), Reflex::Literal("product"), method_20217, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_251), Reflex::Literal("Class_Version"), method_20218, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,int> -------------------------------
static void destructor_27828(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<std::basic_string<char>,int>*)o)->::std::pair<std::basic_string<char>,int>::~pair)();
}
static  void operator_27829( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<std::basic_string<char>,int>*)o)->operator=)(*(const ::std::pair<std::basic_string<char>,int>*)arg[0]);
  else   (((::std::pair<std::basic_string<char>,int>*)o)->operator=)(*(const ::std::pair<std::basic_string<char>,int>*)arg[0]);
}

static void constructor_27830( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,int>(*(const ::std::pair<std::basic_string<char>,int>*)arg[0]);
  else ::new(mem) ::std::pair<std::basic_string<char>,int>(*(const ::std::pair<std::basic_string<char>,int>*)arg[0]);
}

static void constructor_27831( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,int>();
  else ::new(mem) ::std::pair<std::basic_string<char>,int>();
}

static void constructor_27832( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,int>(*(const ::std::basic_string<char>*)arg[0],
      *(const int*)arg[1]);
  else ::new(mem) ::std::pair<std::basic_string<char>,int>(*(const ::std::basic_string<char>*)arg[0],
      *(const int*)arg[1]);
}

static void method_newdel_4465( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,int> -------------------------------
void __std__pair_std__basic_string_char__int__db_datamem(Reflex::Class*);
void __std__pair_std__basic_string_char__int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_std__basic_string_char__int__datamem_bld(&__std__pair_std__basic_string_char__int__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_std__basic_string_char__int__funcmem_bld(&__std__pair_std__basic_string_char__int__db_funcmem);
void __std__pair_std__basic_string_char__int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<std::basic_string<char>,int>"), typeid(::std::pair<std::basic_string<char>,int>), sizeof(::std::pair<std::basic_string<char>,int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_3906, Reflex::Literal("std::pair<std::basic_string<char>,int>::first_type"))
  .AddTypedef(type_88, Reflex::Literal("std::pair<std::basic_string<char>,int>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_27828, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75756, type_75757), Reflex::Literal("operator="), operator_27829, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_75757), Reflex::Literal("pair"), constructor_27830, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_27831, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24234, type_24190), Reflex::Literal("pair"), constructor_27832, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4465, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_std__basic_string_char__int__datamem_bld);
}

//------Delayed data member builder for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,int> -------------------
void __std__pair_std__basic_string_char__int__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3906, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_std__basic_string_char__int_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_88, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_std__basic_string_char__int_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,int> -------------------
void __std__pair_std__basic_string_char__int__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,float> -------------------------------
static void destructor_27837(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<std::basic_string<char>,float>*)o)->::std::pair<std::basic_string<char>,float>::~pair)();
}
static  void operator_27838( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<std::basic_string<char>,float>*)o)->operator=)(*(const ::std::pair<std::basic_string<char>,float>*)arg[0]);
  else   (((::std::pair<std::basic_string<char>,float>*)o)->operator=)(*(const ::std::pair<std::basic_string<char>,float>*)arg[0]);
}

static void constructor_27839( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,float>(*(const ::std::pair<std::basic_string<char>,float>*)arg[0]);
  else ::new(mem) ::std::pair<std::basic_string<char>,float>(*(const ::std::pair<std::basic_string<char>,float>*)arg[0]);
}

static void constructor_27840( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,float>();
  else ::new(mem) ::std::pair<std::basic_string<char>,float>();
}

static void constructor_27841( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,float>(*(const ::std::basic_string<char>*)arg[0],
      *(const float*)arg[1]);
  else ::new(mem) ::std::pair<std::basic_string<char>,float>(*(const ::std::basic_string<char>*)arg[0],
      *(const float*)arg[1]);
}

static void method_newdel_4466( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,float> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,float> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,float> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,float> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,float> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,float> -------------------------------
void __std__pair_std__basic_string_char__float__db_datamem(Reflex::Class*);
void __std__pair_std__basic_string_char__float__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_std__basic_string_char__float__datamem_bld(&__std__pair_std__basic_string_char__float__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_std__basic_string_char__float__funcmem_bld(&__std__pair_std__basic_string_char__float__db_funcmem);
void __std__pair_std__basic_string_char__float__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<std::basic_string<char>,float>"), typeid(::std::pair<std::basic_string<char>,float>), sizeof(::std::pair<std::basic_string<char>,float>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_3906, Reflex::Literal("std::pair<std::basic_string<char>,float>::first_type"))
  .AddTypedef(type_1261, Reflex::Literal("std::pair<std::basic_string<char>,float>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_27837, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31287, type_31289), Reflex::Literal("operator="), operator_27838, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31289), Reflex::Literal("pair"), constructor_27839, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_27840, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_24234, type_14349), Reflex::Literal("pair"), constructor_27841, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4466, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_std__basic_string_char__float__datamem_bld);
}

//------Delayed data member builder for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,float> -------------------
void __std__pair_std__basic_string_char__float__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3906, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_std__basic_string_char__float_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_1261, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_std__basic_string_char__float_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,float> -------------------
void __std__pair_std__basic_string_char__float__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<PATFinalState*,std::allocator<PATFinalState*> > -------------------------------
static void constructor_28471( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATFinalState*>();
  else ::new(mem) ::std::vector<PATFinalState*>();
}

static void constructor_28472( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATFinalState*>(*(const ::std::allocator<PATFinalState*>*)arg[0]);
  else ::new(mem) ::std::vector<PATFinalState*>(*(const ::std::allocator<PATFinalState*>*)arg[0]);
}

static void constructor_28473( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATFinalState*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATFinalState*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATFinalState*>(*(::std::size_t*)arg[0],
      *(::PATFinalState* const*)arg[1]);
  else ::new(mem) ::std::vector<PATFinalState*>(*(::std::size_t*)arg[0],
      *(::PATFinalState* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATFinalState*>(*(::std::size_t*)arg[0],
      *(::PATFinalState* const*)arg[1],
      *(const ::std::allocator<PATFinalState*>*)arg[2]);
  else ::new(mem) ::std::vector<PATFinalState*>(*(::std::size_t*)arg[0],
      *(::PATFinalState* const*)arg[1],
      *(const ::std::allocator<PATFinalState*>*)arg[2]);
  }
}

static void constructor_28474( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATFinalState*>(*(const ::std::vector<PATFinalState*>*)arg[0]);
  else ::new(mem) ::std::vector<PATFinalState*>(*(const ::std::vector<PATFinalState*>*)arg[0]);
}

static void destructor_28475(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATFinalState*>*)o)->::std::vector<PATFinalState*>::~vector)();
}
static  void operator_28476( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATFinalState*>*)o)->operator=)(*(const ::std::vector<PATFinalState*>*)arg[0]);
  else   (((::std::vector<PATFinalState*>*)o)->operator=)(*(const ::std::vector<PATFinalState*>*)arg[0]);
}

static  void method_28477( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATFinalState*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(::PATFinalState* const*)arg[1]);
}

static  void method_28478( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATFinalState**,std::vector<PATFinalState*> >)((((::std::vector<PATFinalState*>*)o)->begin)());
  else   (((::std::vector<PATFinalState*>*)o)->begin)();
}

static  void method_28479( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATFinalState* const*,std::vector<PATFinalState*> >)((((const ::std::vector<PATFinalState*>*)o)->begin)());
  else   (((const ::std::vector<PATFinalState*>*)o)->begin)();
}

static  void method_28480( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATFinalState**,std::vector<PATFinalState*> >)((((::std::vector<PATFinalState*>*)o)->end)());
  else   (((::std::vector<PATFinalState*>*)o)->end)();
}

static  void method_28481( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATFinalState* const*,std::vector<PATFinalState*> >)((((const ::std::vector<PATFinalState*>*)o)->end)());
  else   (((const ::std::vector<PATFinalState*>*)o)->end)();
}

static  void method_28486( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATFinalState*>*)o)->size)());
  else   (((const ::std::vector<PATFinalState*>*)o)->size)();
}

static  void method_28487( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATFinalState*>*)o)->max_size)());
  else   (((const ::std::vector<PATFinalState*>*)o)->max_size)();
}

static  void method_28488( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATFinalState*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATFinalState*>*)o)->resize)(*(::std::size_t*)arg[0],
      (::PATFinalState*)arg[1]);
  }
}

static  void method_28489( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATFinalState*>*)o)->capacity)());
  else   (((const ::std::vector<PATFinalState*>*)o)->capacity)();
}

static  void method_28490( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATFinalState*>*)o)->empty)());
  else   (((const ::std::vector<PATFinalState*>*)o)->empty)();
}

static  void method_28491( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATFinalState*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_28492( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATFinalState*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATFinalState*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_28493( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATFinalState*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATFinalState*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_28495( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATFinalState*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATFinalState*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_28496( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATFinalState*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATFinalState*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_28497( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATFinalState*>*)o)->front)();
  else   (((::std::vector<PATFinalState*>*)o)->front)();
}

static  void method_28498( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATFinalState*>*)o)->front)();
  else   (((const ::std::vector<PATFinalState*>*)o)->front)();
}

static  void method_28499( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATFinalState*>*)o)->back)();
  else   (((::std::vector<PATFinalState*>*)o)->back)();
}

static  void method_28500( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATFinalState*>*)o)->back)();
  else   (((const ::std::vector<PATFinalState*>*)o)->back)();
}

static  void method_28501( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATFinalState*>*)o)->data)());
  else   (((::std::vector<PATFinalState*>*)o)->data)();
}

static  void method_28502( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATFinalState*>*)o)->data)());
  else   (((const ::std::vector<PATFinalState*>*)o)->data)();
}

static  void method_28503( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATFinalState*>*)o)->push_back)(*(::PATFinalState* const*)arg[0]);
}

static  void method_28504( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATFinalState*>*)o)->pop_back)();
}

static  void method_28505( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATFinalState**,std::vector<PATFinalState*> >)((((::std::vector<PATFinalState*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATFinalState**,std::vector<PATFinalState*> >*)arg[0],
    *(::PATFinalState* const*)arg[1]));
  else   (((::std::vector<PATFinalState*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATFinalState**,std::vector<PATFinalState*> >*)arg[0],
    *(::PATFinalState* const*)arg[1]);
}

static  void method_28506( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATFinalState*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATFinalState**,std::vector<PATFinalState*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(::PATFinalState* const*)arg[2]);
}

static  void method_28507( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATFinalState**,std::vector<PATFinalState*> >)((((::std::vector<PATFinalState*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATFinalState**,std::vector<PATFinalState*> >*)arg[0]));
  else   (((::std::vector<PATFinalState*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATFinalState**,std::vector<PATFinalState*> >*)arg[0]);
}

static  void method_28508( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATFinalState**,std::vector<PATFinalState*> >)((((::std::vector<PATFinalState*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATFinalState**,std::vector<PATFinalState*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATFinalState**,std::vector<PATFinalState*> >*)arg[1]));
  else   (((::std::vector<PATFinalState*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATFinalState**,std::vector<PATFinalState*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATFinalState**,std::vector<PATFinalState*> >*)arg[1]);
}

static  void method_28509( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATFinalState*>*)o)->swap)(*(::std::vector<PATFinalState*>*)arg[0]);
}

static  void method_28510( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATFinalState*>*)o)->clear)();
}

static void method_newdel_4595( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATFinalState*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATFinalState*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATFinalState*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATFinalState*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATFinalState*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x14( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATFinalState*,std::allocator<PATFinalState*> >")), ::Reflex::BaseOffset< ::std::vector<PATFinalState*>,::std::_Vector_base<PATFinalState*,std::allocator<PATFinalState*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x15( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATFinalState*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATFinalState*> >::Generate();
}

//------Dictionary for class vector<PATFinalState*,std::allocator<PATFinalState*> > -------------------------------
void __std__vector_PATFinalStatep__db_datamem(Reflex::Class*);
void __std__vector_PATFinalStatep__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATFinalStatep__datamem_bld(&__std__vector_PATFinalStatep__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATFinalStatep__funcmem_bld(&__std__vector_PATFinalStatep__db_funcmem);
void __std__vector_PATFinalStatep__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATFinalState*>"), typeid(::std::vector<PATFinalState*>), sizeof(::std::vector<PATFinalState*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3855, ::Reflex::BaseOffset< ::std::vector<PATFinalState*>, ::std::_Vector_base<PATFinalState*,std::allocator<PATFinalState*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_11110, Reflex::Literal("std::vector<PATFinalState*>::_Alloc_value_type"))
  .AddTypedef(type_3855, Reflex::Literal("std::vector<PATFinalState*>::_Base"))
  .AddTypedef(type_5037, Reflex::Literal("std::vector<PATFinalState*>::_Tp_alloc_type"))
  .AddTypedef(type_11110, Reflex::Literal("std::vector<PATFinalState*>::value_type"))
  .AddTypedef(type_28456, Reflex::Literal("std::vector<PATFinalState*>::pointer"))
  .AddTypedef(type_28458, Reflex::Literal("std::vector<PATFinalState*>::const_pointer"))
  .AddTypedef(type_28460, Reflex::Literal("std::vector<PATFinalState*>::reference"))
  .AddTypedef(type_28462, Reflex::Literal("std::vector<PATFinalState*>::const_reference"))
  .AddTypedef(type_17975, Reflex::Literal("std::vector<PATFinalState*>::iterator"))
  .AddTypedef(type_17976, Reflex::Literal("std::vector<PATFinalState*>::const_iterator"))
  .AddTypedef(type_5983, Reflex::Literal("std::vector<PATFinalState*>::const_reverse_iterator"))
  .AddTypedef(type_5984, Reflex::Literal("std::vector<PATFinalState*>::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATFinalState*>::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATFinalState*>::difference_type"))
  .AddTypedef(type_5037, Reflex::Literal("std::vector<PATFinalState*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_28471, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_74533), Reflex::Literal("vector"), constructor_28472, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_28462, type_74533), Reflex::Literal("vector"), constructor_28473, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_59600), Reflex::Literal("vector"), constructor_28474, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_28475, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4595, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x14, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x15, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATFinalStatep__funcmem_bld);
}

//------Delayed data member builder for class vector<PATFinalState*,std::allocator<PATFinalState*> > -------------------
void __std__vector_PATFinalStatep__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATFinalState*,std::allocator<PATFinalState*> > -------------------
void __std__vector_PATFinalStatep__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75802, type_59600), Reflex::Literal("operator="), operator_28476, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_28462), Reflex::Literal("assign"), method_28477, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17975), Reflex::Literal("begin"), method_28478, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17976), Reflex::Literal("begin"), method_28479, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17975), Reflex::Literal("end"), method_28480, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17976), Reflex::Literal("end"), method_28481, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_28486, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_28487, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_11110), Reflex::Literal("resize"), method_28488, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_28489, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_28490, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_28491, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28460, type_5015), Reflex::Literal("operator[]"), operator_28492, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28462, type_5015), Reflex::Literal("operator[]"), operator_28493, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28460, type_5015), Reflex::Literal("at"), method_28495, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28462, type_5015), Reflex::Literal("at"), method_28496, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28460), Reflex::Literal("front"), method_28497, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28462), Reflex::Literal("front"), method_28498, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28460), Reflex::Literal("back"), method_28499, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28462), Reflex::Literal("back"), method_28500, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28456), Reflex::Literal("data"), method_28501, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28458), Reflex::Literal("data"), method_28502, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_28462), Reflex::Literal("push_back"), method_28503, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_28504, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17975, type_17975, type_28462), Reflex::Literal("insert"), method_28505, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_17975, type_5015, type_28462), Reflex::Literal("insert"), method_28506, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17975, type_17975), Reflex::Literal("erase"), method_28507, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17975, type_17975, type_17975), Reflex::Literal("erase"), method_28508, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_75802), Reflex::Literal("swap"), method_28509, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_28510, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,edm::Ptr<pat::MET>,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, edm::Ptr<pat::MET> > > > -------------------------------
static void destructor_39047(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >::~map)();
}
static void constructor_39048( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >();
  else ::new(mem) ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >();
}

static void constructor_39049( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >(*(const ::std::less<std::basic_string<char> >*)arg[0]);
  else ::new(mem) ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >(*(const ::std::less<std::basic_string<char> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >(*(const ::std::less<std::basic_string<char> >*)arg[0],
      *(const ::std::allocator<std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> > >*)arg[1]);
  else ::new(mem) ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >(*(const ::std::less<std::basic_string<char> >*)arg[0],
      *(const ::std::allocator<std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> > >*)arg[1]);
  }
}

static void constructor_39050( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >(*(const ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)arg[0]);
  else ::new(mem) ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >(*(const ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)arg[0]);
}

static  void operator_39051( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->operator=)(*(const ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)arg[0]);
  else   (((::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->operator=)(*(const ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)arg[0]);
}

static  void method_39052( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> > >)((((const ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->get_allocator)());
  else   (((const ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->get_allocator)();
}

static  void method_39053( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> > >)((((::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->begin)());
  else   (((::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->begin)();
}

static  void method_39054( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> > >)((((const ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->begin)());
  else   (((const ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->begin)();
}

static  void method_39055( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> > >)((((::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->end)());
  else   (((::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->end)();
}

static  void method_39056( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> > >)((((const ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->end)());
  else   (((const ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->end)();
}

static  void method_39061( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->empty)());
  else   (((const ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->empty)();
}

static  void method_39062( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->size)());
  else   (((const ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->size)();
}

static  void method_39063( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->max_size)());
  else   (((const ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->max_size)();
}

static  void operator_39064( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->operator[])(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->operator[])(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_39065( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_39066( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_39067( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> > >,bool>)((((::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->insert)(*(const ::std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> >*)arg[0]));
  else   (((::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->insert)(*(const ::std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> >*)arg[0]);
}

static  void method_39068( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> > >)((((::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> > >*)arg[0],
    *(const ::std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> >*)arg[1]));
  else   (((::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> > >*)arg[0],
    *(const ::std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> >*)arg[1]);
}

static  void method_39069( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> > >*)arg[0]);
}

static  void method_39070( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->erase)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->erase)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_39071( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> > >*)arg[1]);
}

static  void method_39072( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->swap)(*(::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)arg[0]);
}

static  void method_39073( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->clear)();
}

static  void method_39074( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<std::basic_string<char> >)((((const ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->key_comp)());
  else   (((const ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->key_comp)();
}

static  void method_39076( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> > >)((((::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->find)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->find)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_39077( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> > >)((((const ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->find)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->find)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_39078( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->count)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->count)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_39079( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> > >)((((::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_39080( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> > >)((((const ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_39081( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> > >)((((::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_39082( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> > >)((((const ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_39083( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> > >,std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> > > >)((((::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_39084( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> > >,std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,edm::Ptr<pat::MET> > > >)((((const ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]);
}

static void method_newdel_4899( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x17( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> > >::Generate();
  else ::Reflex::Proxy< ::std::map<std::basic_string<char>,edm::Ptr<pat::MET> > >::Generate();
}

//------Dictionary for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,edm::Ptr<pat::MET>,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, edm::Ptr<pat::MET> > > > -------------------------------
void __std__map_std__basic_string_char__edm__Ptr_pat__MET_s__db_datamem(Reflex::Class*);
void __std__map_std__basic_string_char__edm__Ptr_pat__MET_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_std__basic_string_char__edm__Ptr_pat__MET_s__datamem_bld(&__std__map_std__basic_string_char__edm__Ptr_pat__MET_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_std__basic_string_char__edm__Ptr_pat__MET_s__funcmem_bld(&__std__map_std__basic_string_char__edm__Ptr_pat__MET_s__db_funcmem);
void __std__map_std__basic_string_char__edm__Ptr_pat__MET_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<std::basic_string<char>,edm::Ptr<pat::MET> >"), typeid(::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >), sizeof(::std::map<std::basic_string<char>,edm::Ptr<pat::MET> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3906, Reflex::Literal("std::map<std::basic_string<char>,edm::Ptr<pat::MET> >::key_type"))
  .AddTypedef(type_9783, Reflex::Literal("std::map<std::basic_string<char>,edm::Ptr<pat::MET> >::mapped_type"))
  .AddTypedef(type_4464, Reflex::Literal("std::map<std::basic_string<char>,edm::Ptr<pat::MET> >::value_type"))
  .AddTypedef(type_4075, Reflex::Literal("std::map<std::basic_string<char>,edm::Ptr<pat::MET> >::key_compare"))
  .AddTypedef(type_5038, Reflex::Literal("std::map<std::basic_string<char>,edm::Ptr<pat::MET> >::allocator_type"))
  .AddTypedef(type_4464, Reflex::Literal("std::map<std::basic_string<char>,edm::Ptr<pat::MET> >::_Alloc_value_type"))
  .AddTypedef(type_5038, Reflex::Literal("std::map<std::basic_string<char>,edm::Ptr<pat::MET> >::_Pair_alloc_type"))
  .AddTypedef(type_4116, Reflex::Literal("std::map<std::basic_string<char>,edm::Ptr<pat::MET> >::_Rep_type"))
  .AddTypedef(type_25233, Reflex::Literal("std::map<std::basic_string<char>,edm::Ptr<pat::MET> >::pointer"))
  .AddTypedef(type_25235, Reflex::Literal("std::map<std::basic_string<char>,edm::Ptr<pat::MET> >::const_pointer"))
  .AddTypedef(type_25237, Reflex::Literal("std::map<std::basic_string<char>,edm::Ptr<pat::MET> >::reference"))
  .AddTypedef(type_25239, Reflex::Literal("std::map<std::basic_string<char>,edm::Ptr<pat::MET> >::const_reference"))
  .AddTypedef(type_4836, Reflex::Literal("std::map<std::basic_string<char>,edm::Ptr<pat::MET> >::iterator"))
  .AddTypedef(type_4299, Reflex::Literal("std::map<std::basic_string<char>,edm::Ptr<pat::MET> >::const_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::map<std::basic_string<char>,edm::Ptr<pat::MET> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::map<std::basic_string<char>,edm::Ptr<pat::MET> >::difference_type"))
  .AddTypedef(type_5726, Reflex::Literal("std::map<std::basic_string<char>,edm::Ptr<pat::MET> >::reverse_iterator"))
  .AddTypedef(type_5725, Reflex::Literal("std::map<std::basic_string<char>,edm::Ptr<pat::MET> >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_39047, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_39048, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_75365, type_75452), Reflex::Literal("map"), constructor_39049, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_50696), Reflex::Literal("map"), constructor_39050, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4899, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x17, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_std__basic_string_char__edm__Ptr_pat__MET_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_std__basic_string_char__edm__Ptr_pat__MET_s__funcmem_bld);
}

//------Delayed data member builder for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,edm::Ptr<pat::MET>,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, edm::Ptr<pat::MET> > > > -------------------
void __std__map_std__basic_string_char__edm__Ptr_pat__MET_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4116, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_std__basic_string_char__edm__Ptr_pat__MET_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,edm::Ptr<pat::MET>,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, edm::Ptr<pat::MET> > > > -------------------
void __std__map_std__basic_string_char__edm__Ptr_pat__MET_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_76388, type_50696), Reflex::Literal("operator="), operator_39051, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5038), Reflex::Literal("get_allocator"), method_39052, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4836), Reflex::Literal("begin"), method_39053, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4299), Reflex::Literal("begin"), method_39054, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4836), Reflex::Literal("end"), method_39055, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4299), Reflex::Literal("end"), method_39056, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_39061, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_39062, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_39063, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_76389, type_24234), Reflex::Literal("operator[]"), operator_39064, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_76389, type_24234), Reflex::Literal("at"), method_39065, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46447, type_24234), Reflex::Literal("at"), method_39066, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4471, type_25239), Reflex::Literal("insert"), method_39067, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4836, type_4836, type_25239), Reflex::Literal("insert"), method_39068, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_4836), Reflex::Literal("erase"), method_39069, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015, type_24234), Reflex::Literal("erase"), method_39070, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_4836, type_4836), Reflex::Literal("erase"), method_39071, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_76388), Reflex::Literal("swap"), method_39072, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_39073, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4075), Reflex::Literal("key_comp"), method_39074, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4836, type_24234), Reflex::Literal("find"), method_39076, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4299, type_24234), Reflex::Literal("find"), method_39077, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015, type_24234), Reflex::Literal("count"), method_39078, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4836, type_24234), Reflex::Literal("lower_bound"), method_39079, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4299, type_24234), Reflex::Literal("lower_bound"), method_39080, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4836, type_24234), Reflex::Literal("upper_bound"), method_39081, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4299, type_24234), Reflex::Literal("upper_bound"), method_39082, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4470, type_24234), Reflex::Literal("equal_range"), method_39083, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4469, type_24234), Reflex::Literal("equal_range"), method_39084, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,int,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > > -------------------------------
static void destructor_39105(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<std::basic_string<char>,int>*)o)->::std::map<std::basic_string<char>,int>::~map)();
}
static void constructor_39106( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,int>();
  else ::new(mem) ::std::map<std::basic_string<char>,int>();
}

static void constructor_39107( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,int>(*(const ::std::less<std::basic_string<char> >*)arg[0]);
  else ::new(mem) ::std::map<std::basic_string<char>,int>(*(const ::std::less<std::basic_string<char> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,int>(*(const ::std::less<std::basic_string<char> >*)arg[0],
      *(const ::std::allocator<std::pair<const std::basic_string<char>,int> >*)arg[1]);
  else ::new(mem) ::std::map<std::basic_string<char>,int>(*(const ::std::less<std::basic_string<char> >*)arg[0],
      *(const ::std::allocator<std::pair<const std::basic_string<char>,int> >*)arg[1]);
  }
}

static void constructor_39108( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,int>(*(const ::std::map<std::basic_string<char>,int>*)arg[0]);
  else ::new(mem) ::std::map<std::basic_string<char>,int>(*(const ::std::map<std::basic_string<char>,int>*)arg[0]);
}

static  void operator_39109( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,int>*)o)->operator=)(*(const ::std::map<std::basic_string<char>,int>*)arg[0]);
  else   (((::std::map<std::basic_string<char>,int>*)o)->operator=)(*(const ::std::map<std::basic_string<char>,int>*)arg[0]);
}

static  void method_39110( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const std::basic_string<char>,int> >)((((const ::std::map<std::basic_string<char>,int>*)o)->get_allocator)());
  else   (((const ::std::map<std::basic_string<char>,int>*)o)->get_allocator)();
}

static  void method_39111( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,int> >)((((::std::map<std::basic_string<char>,int>*)o)->begin)());
  else   (((::std::map<std::basic_string<char>,int>*)o)->begin)();
}

static  void method_39112( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,int> >)((((const ::std::map<std::basic_string<char>,int>*)o)->begin)());
  else   (((const ::std::map<std::basic_string<char>,int>*)o)->begin)();
}

static  void method_39113( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,int> >)((((::std::map<std::basic_string<char>,int>*)o)->end)());
  else   (((::std::map<std::basic_string<char>,int>*)o)->end)();
}

static  void method_39114( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,int> >)((((const ::std::map<std::basic_string<char>,int>*)o)->end)());
  else   (((const ::std::map<std::basic_string<char>,int>*)o)->end)();
}

static  void method_39119( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<std::basic_string<char>,int>*)o)->empty)());
  else   (((const ::std::map<std::basic_string<char>,int>*)o)->empty)();
}

static  void method_39120( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,int>*)o)->size)());
  else   (((const ::std::map<std::basic_string<char>,int>*)o)->size)();
}

static  void method_39121( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,int>*)o)->max_size)());
  else   (((const ::std::map<std::basic_string<char>,int>*)o)->max_size)();
}

static  void operator_39122( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,int>*)o)->operator[])(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::map<std::basic_string<char>,int>*)o)->operator[])(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_39123( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,int>*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::map<std::basic_string<char>,int>*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_39124( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<std::basic_string<char>,int>*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::std::map<std::basic_string<char>,int>*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_39125( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,int> >,bool>)((((::std::map<std::basic_string<char>,int>*)o)->insert)(*(const ::std::pair<const std::basic_string<char>,int>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,int>*)o)->insert)(*(const ::std::pair<const std::basic_string<char>,int>*)arg[0]);
}

static  void method_39126( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,int> >)((((::std::map<std::basic_string<char>,int>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,int> >*)arg[0],
    *(const ::std::pair<const std::basic_string<char>,int>*)arg[1]));
  else   (((::std::map<std::basic_string<char>,int>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,int> >*)arg[0],
    *(const ::std::pair<const std::basic_string<char>,int>*)arg[1]);
}

static  void method_39127( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,int>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,int> >*)arg[0]);
}

static  void method_39128( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<std::basic_string<char>,int>*)o)->erase)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,int>*)o)->erase)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_39129( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,int>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,int> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,int> >*)arg[1]);
}

static  void method_39130( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,int>*)o)->swap)(*(::std::map<std::basic_string<char>,int>*)arg[0]);
}

static  void method_39131( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<std::basic_string<char>,int>*)o)->clear)();
}

static  void method_39132( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<std::basic_string<char> >)((((const ::std::map<std::basic_string<char>,int>*)o)->key_comp)());
  else   (((const ::std::map<std::basic_string<char>,int>*)o)->key_comp)();
}

static  void method_39134( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,int> >)((((::std::map<std::basic_string<char>,int>*)o)->find)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,int>*)o)->find)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_39135( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,int> >)((((const ::std::map<std::basic_string<char>,int>*)o)->find)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,int>*)o)->find)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_39136( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,int>*)o)->count)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,int>*)o)->count)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_39137( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,int> >)((((::std::map<std::basic_string<char>,int>*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,int>*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_39138( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,int> >)((((const ::std::map<std::basic_string<char>,int>*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,int>*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_39139( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,int> >)((((::std::map<std::basic_string<char>,int>*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,int>*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_39140( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,int> >)((((const ::std::map<std::basic_string<char>,int>*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,int>*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_39141( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,int> >,std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,int> > >)((((::std::map<std::basic_string<char>,int>*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,int>*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_39142( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,int> >,std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,int> > >)((((const ::std::map<std::basic_string<char>,int>*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,int>*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]);
}

static void method_newdel_4900( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x19( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<std::basic_string<char>,int> >::Generate();
  else ::Reflex::Proxy< ::std::map<std::basic_string<char>,int> >::Generate();
}

//------Dictionary for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,int,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > > -------------------------------
void __std__map_std__basic_string_char__int__db_datamem(Reflex::Class*);
void __std__map_std__basic_string_char__int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_std__basic_string_char__int__datamem_bld(&__std__map_std__basic_string_char__int__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_std__basic_string_char__int__funcmem_bld(&__std__map_std__basic_string_char__int__db_funcmem);
void __std__map_std__basic_string_char__int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<std::basic_string<char>,int>"), typeid(::std::map<std::basic_string<char>,int>), sizeof(::std::map<std::basic_string<char>,int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3906, Reflex::Literal("std::map<std::basic_string<char>,int>::key_type"))
  .AddTypedef(type_88, Reflex::Literal("std::map<std::basic_string<char>,int>::mapped_type"))
  .AddTypedef(type_4467, Reflex::Literal("std::map<std::basic_string<char>,int>::value_type"))
  .AddTypedef(type_4075, Reflex::Literal("std::map<std::basic_string<char>,int>::key_compare"))
  .AddTypedef(type_5039, Reflex::Literal("std::map<std::basic_string<char>,int>::allocator_type"))
  .AddTypedef(type_4467, Reflex::Literal("std::map<std::basic_string<char>,int>::_Alloc_value_type"))
  .AddTypedef(type_5039, Reflex::Literal("std::map<std::basic_string<char>,int>::_Pair_alloc_type"))
  .AddTypedef(type_4117, Reflex::Literal("std::map<std::basic_string<char>,int>::_Rep_type"))
  .AddTypedef(type_25338, Reflex::Literal("std::map<std::basic_string<char>,int>::pointer"))
  .AddTypedef(type_25340, Reflex::Literal("std::map<std::basic_string<char>,int>::const_pointer"))
  .AddTypedef(type_25342, Reflex::Literal("std::map<std::basic_string<char>,int>::reference"))
  .AddTypedef(type_25344, Reflex::Literal("std::map<std::basic_string<char>,int>::const_reference"))
  .AddTypedef(type_4837, Reflex::Literal("std::map<std::basic_string<char>,int>::iterator"))
  .AddTypedef(type_4300, Reflex::Literal("std::map<std::basic_string<char>,int>::const_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::map<std::basic_string<char>,int>::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::map<std::basic_string<char>,int>::difference_type"))
  .AddTypedef(type_5730, Reflex::Literal("std::map<std::basic_string<char>,int>::reverse_iterator"))
  .AddTypedef(type_5729, Reflex::Literal("std::map<std::basic_string<char>,int>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_39105, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_39106, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_75365, type_75459), Reflex::Literal("map"), constructor_39107, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_76390), Reflex::Literal("map"), constructor_39108, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4900, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x19, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_std__basic_string_char__int__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_std__basic_string_char__int__funcmem_bld);
}

//------Delayed data member builder for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,int,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > > -------------------
void __std__map_std__basic_string_char__int__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4117, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_std__basic_string_char__int_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,int,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > > -------------------
void __std__map_std__basic_string_char__int__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_76391, type_76390), Reflex::Literal("operator="), operator_39109, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5039), Reflex::Literal("get_allocator"), method_39110, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4837), Reflex::Literal("begin"), method_39111, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4300), Reflex::Literal("begin"), method_39112, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4837), Reflex::Literal("end"), method_39113, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4300), Reflex::Literal("end"), method_39114, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_39119, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_39120, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_39121, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24179, type_24234), Reflex::Literal("operator[]"), operator_39122, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24179, type_24234), Reflex::Literal("at"), method_39123, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_24190, type_24234), Reflex::Literal("at"), method_39124, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4474, type_25344), Reflex::Literal("insert"), method_39125, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4837, type_4837, type_25344), Reflex::Literal("insert"), method_39126, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_4837), Reflex::Literal("erase"), method_39127, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015, type_24234), Reflex::Literal("erase"), method_39128, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_4837, type_4837), Reflex::Literal("erase"), method_39129, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_76391), Reflex::Literal("swap"), method_39130, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_39131, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4075), Reflex::Literal("key_comp"), method_39132, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4837, type_24234), Reflex::Literal("find"), method_39134, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4300, type_24234), Reflex::Literal("find"), method_39135, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015, type_24234), Reflex::Literal("count"), method_39136, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4837, type_24234), Reflex::Literal("lower_bound"), method_39137, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4300, type_24234), Reflex::Literal("lower_bound"), method_39138, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4837, type_24234), Reflex::Literal("upper_bound"), method_39139, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4300, type_24234), Reflex::Literal("upper_bound"), method_39140, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4473, type_24234), Reflex::Literal("equal_range"), method_39141, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4472, type_24234), Reflex::Literal("equal_range"), method_39142, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,float,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, float> > > -------------------------------
static void destructor_39163(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<std::basic_string<char>,float>*)o)->::std::map<std::basic_string<char>,float>::~map)();
}
static void constructor_39164( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,float>();
  else ::new(mem) ::std::map<std::basic_string<char>,float>();
}

static void constructor_39165( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,float>(*(const ::std::less<std::basic_string<char> >*)arg[0]);
  else ::new(mem) ::std::map<std::basic_string<char>,float>(*(const ::std::less<std::basic_string<char> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,float>(*(const ::std::less<std::basic_string<char> >*)arg[0],
      *(const ::std::allocator<std::pair<const std::basic_string<char>,float> >*)arg[1]);
  else ::new(mem) ::std::map<std::basic_string<char>,float>(*(const ::std::less<std::basic_string<char> >*)arg[0],
      *(const ::std::allocator<std::pair<const std::basic_string<char>,float> >*)arg[1]);
  }
}

static void constructor_39166( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,float>(*(const ::std::map<std::basic_string<char>,float>*)arg[0]);
  else ::new(mem) ::std::map<std::basic_string<char>,float>(*(const ::std::map<std::basic_string<char>,float>*)arg[0]);
}

static  void operator_39167( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,float>*)o)->operator=)(*(const ::std::map<std::basic_string<char>,float>*)arg[0]);
  else   (((::std::map<std::basic_string<char>,float>*)o)->operator=)(*(const ::std::map<std::basic_string<char>,float>*)arg[0]);
}

static  void method_39168( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const std::basic_string<char>,float> >)((((const ::std::map<std::basic_string<char>,float>*)o)->get_allocator)());
  else   (((const ::std::map<std::basic_string<char>,float>*)o)->get_allocator)();
}

static  void method_39169( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,float> >)((((::std::map<std::basic_string<char>,float>*)o)->begin)());
  else   (((::std::map<std::basic_string<char>,float>*)o)->begin)();
}

static  void method_39170( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,float> >)((((const ::std::map<std::basic_string<char>,float>*)o)->begin)());
  else   (((const ::std::map<std::basic_string<char>,float>*)o)->begin)();
}

static  void method_39171( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,float> >)((((::std::map<std::basic_string<char>,float>*)o)->end)());
  else   (((::std::map<std::basic_string<char>,float>*)o)->end)();
}

static  void method_39172( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,float> >)((((const ::std::map<std::basic_string<char>,float>*)o)->end)());
  else   (((const ::std::map<std::basic_string<char>,float>*)o)->end)();
}

static  void method_39177( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<std::basic_string<char>,float>*)o)->empty)());
  else   (((const ::std::map<std::basic_string<char>,float>*)o)->empty)();
}

static  void method_39178( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,float>*)o)->size)());
  else   (((const ::std::map<std::basic_string<char>,float>*)o)->size)();
}

static  void method_39179( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,float>*)o)->max_size)());
  else   (((const ::std::map<std::basic_string<char>,float>*)o)->max_size)();
}

static  void operator_39180( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,float>*)o)->operator[])(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::map<std::basic_string<char>,float>*)o)->operator[])(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_39181( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,float>*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::map<std::basic_string<char>,float>*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_39182( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<std::basic_string<char>,float>*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::std::map<std::basic_string<char>,float>*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_39183( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,float> >,bool>)((((::std::map<std::basic_string<char>,float>*)o)->insert)(*(const ::std::pair<const std::basic_string<char>,float>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,float>*)o)->insert)(*(const ::std::pair<const std::basic_string<char>,float>*)arg[0]);
}

static  void method_39184( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,float> >)((((::std::map<std::basic_string<char>,float>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,float> >*)arg[0],
    *(const ::std::pair<const std::basic_string<char>,float>*)arg[1]));
  else   (((::std::map<std::basic_string<char>,float>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,float> >*)arg[0],
    *(const ::std::pair<const std::basic_string<char>,float>*)arg[1]);
}

static  void method_39185( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,float>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,float> >*)arg[0]);
}

static  void method_39186( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<std::basic_string<char>,float>*)o)->erase)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,float>*)o)->erase)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_39187( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,float>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,float> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,float> >*)arg[1]);
}

static  void method_39188( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,float>*)o)->swap)(*(::std::map<std::basic_string<char>,float>*)arg[0]);
}

static  void method_39189( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<std::basic_string<char>,float>*)o)->clear)();
}

static  void method_39190( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<std::basic_string<char> >)((((const ::std::map<std::basic_string<char>,float>*)o)->key_comp)());
  else   (((const ::std::map<std::basic_string<char>,float>*)o)->key_comp)();
}

static  void method_39192( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,float> >)((((::std::map<std::basic_string<char>,float>*)o)->find)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,float>*)o)->find)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_39193( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,float> >)((((const ::std::map<std::basic_string<char>,float>*)o)->find)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,float>*)o)->find)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_39194( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,float>*)o)->count)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,float>*)o)->count)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_39195( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,float> >)((((::std::map<std::basic_string<char>,float>*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,float>*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_39196( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,float> >)((((const ::std::map<std::basic_string<char>,float>*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,float>*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_39197( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,float> >)((((::std::map<std::basic_string<char>,float>*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,float>*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_39198( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,float> >)((((const ::std::map<std::basic_string<char>,float>*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,float>*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_39199( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,float> >,std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,float> > >)((((::std::map<std::basic_string<char>,float>*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,float>*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_39200( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,float> >,std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,float> > >)((((const ::std::map<std::basic_string<char>,float>*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,float>*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]);
}

static void method_newdel_4901( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,float> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,float> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,float> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,float> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,float> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x21( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<std::basic_string<char>,float> >::Generate();
  else ::Reflex::Proxy< ::std::map<std::basic_string<char>,float> >::Generate();
}

//------Dictionary for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,float,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, float> > > -------------------------------
void __std__map_std__basic_string_char__float__db_datamem(Reflex::Class*);
void __std__map_std__basic_string_char__float__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_std__basic_string_char__float__datamem_bld(&__std__map_std__basic_string_char__float__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_std__basic_string_char__float__funcmem_bld(&__std__map_std__basic_string_char__float__db_funcmem);
void __std__map_std__basic_string_char__float__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<std::basic_string<char>,float>"), typeid(::std::map<std::basic_string<char>,float>), sizeof(::std::map<std::basic_string<char>,float>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3906, Reflex::Literal("std::map<std::basic_string<char>,float>::key_type"))
  .AddTypedef(type_1261, Reflex::Literal("std::map<std::basic_string<char>,float>::mapped_type"))
  .AddTypedef(type_4468, Reflex::Literal("std::map<std::basic_string<char>,float>::value_type"))
  .AddTypedef(type_4075, Reflex::Literal("std::map<std::basic_string<char>,float>::key_compare"))
  .AddTypedef(type_5040, Reflex::Literal("std::map<std::basic_string<char>,float>::allocator_type"))
  .AddTypedef(type_4468, Reflex::Literal("std::map<std::basic_string<char>,float>::_Alloc_value_type"))
  .AddTypedef(type_5040, Reflex::Literal("std::map<std::basic_string<char>,float>::_Pair_alloc_type"))
  .AddTypedef(type_4118, Reflex::Literal("std::map<std::basic_string<char>,float>::_Rep_type"))
  .AddTypedef(type_25443, Reflex::Literal("std::map<std::basic_string<char>,float>::pointer"))
  .AddTypedef(type_25445, Reflex::Literal("std::map<std::basic_string<char>,float>::const_pointer"))
  .AddTypedef(type_25447, Reflex::Literal("std::map<std::basic_string<char>,float>::reference"))
  .AddTypedef(type_25449, Reflex::Literal("std::map<std::basic_string<char>,float>::const_reference"))
  .AddTypedef(type_4838, Reflex::Literal("std::map<std::basic_string<char>,float>::iterator"))
  .AddTypedef(type_4301, Reflex::Literal("std::map<std::basic_string<char>,float>::const_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::map<std::basic_string<char>,float>::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::map<std::basic_string<char>,float>::difference_type"))
  .AddTypedef(type_5732, Reflex::Literal("std::map<std::basic_string<char>,float>::reverse_iterator"))
  .AddTypedef(type_5731, Reflex::Literal("std::map<std::basic_string<char>,float>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_39163, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_39164, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_75365, type_75466), Reflex::Literal("map"), constructor_39165, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_76392), Reflex::Literal("map"), constructor_39166, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4901, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x21, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_std__basic_string_char__float__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_std__basic_string_char__float__funcmem_bld);
}

//------Delayed data member builder for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,float,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, float> > > -------------------
void __std__map_std__basic_string_char__float__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4118, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_std__basic_string_char__float_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,float,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, float> > > -------------------
void __std__map_std__basic_string_char__float__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_76393, type_76392), Reflex::Literal("operator="), operator_39167, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5040), Reflex::Literal("get_allocator"), method_39168, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4838), Reflex::Literal("begin"), method_39169, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4301), Reflex::Literal("begin"), method_39170, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4838), Reflex::Literal("end"), method_39171, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4301), Reflex::Literal("end"), method_39172, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_39177, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_39178, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_39179, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29162, type_24234), Reflex::Literal("operator[]"), operator_39180, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29162, type_24234), Reflex::Literal("at"), method_39181, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14349, type_24234), Reflex::Literal("at"), method_39182, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4477, type_25449), Reflex::Literal("insert"), method_39183, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4838, type_4838, type_25449), Reflex::Literal("insert"), method_39184, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_4838), Reflex::Literal("erase"), method_39185, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015, type_24234), Reflex::Literal("erase"), method_39186, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_4838, type_4838), Reflex::Literal("erase"), method_39187, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_76393), Reflex::Literal("swap"), method_39188, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_39189, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4075), Reflex::Literal("key_comp"), method_39190, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4838, type_24234), Reflex::Literal("find"), method_39192, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4301, type_24234), Reflex::Literal("find"), method_39193, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015, type_24234), Reflex::Literal("count"), method_39194, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4838, type_24234), Reflex::Literal("lower_bound"), method_39195, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4301, type_24234), Reflex::Literal("lower_bound"), method_39196, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4838, type_24234), Reflex::Literal("upper_bound"), method_39197, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4301, type_24234), Reflex::Literal("upper_bound"), method_39198, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4476, type_24234), Reflex::Literal("equal_range"), method_39199, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4475, type_24234), Reflex::Literal("equal_range"), method_39200, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class PtrVector<reco::Vertex> -------------------------------
static void constructor_51280( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<reco::Vertex>();
  else ::new(mem) ::edm::PtrVector<reco::Vertex>();
}

static void constructor_51281( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<reco::Vertex>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::PtrVector<reco::Vertex>(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_51282( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<reco::Vertex>(*(const ::edm::PtrVector<reco::Vertex>*)arg[0]);
  else ::new(mem) ::edm::PtrVector<reco::Vertex>(*(const ::edm::PtrVector<reco::Vertex>*)arg[0]);
}

static  void operator_51283( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Vertex>)((((const ::edm::PtrVector<reco::Vertex>*)o)->operator[])(*(const unsigned long*)arg[0]));
  else   (((const ::edm::PtrVector<reco::Vertex>*)o)->operator[])(*(const unsigned long*)arg[0]);
}

static  void method_51284( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::PtrVectorItr<reco::Vertex>)((((const ::edm::PtrVector<reco::Vertex>*)o)->begin)());
  else   (((const ::edm::PtrVector<reco::Vertex>*)o)->begin)();
}

static  void method_51285( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::PtrVectorItr<reco::Vertex>)((((const ::edm::PtrVector<reco::Vertex>*)o)->end)());
  else   (((const ::edm::PtrVector<reco::Vertex>*)o)->end)();
}

static  void method_51286( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::PtrVector<reco::Vertex>*)o)->push_back)(*(const ::edm::Ptr<reco::Vertex>*)arg[0]);
}

static  void method_51287( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::PtrVector<reco::Vertex>*)o)->swap)(*(::edm::PtrVector<reco::Vertex>*)arg[0]);
}

static  void operator_51288( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::PtrVector<reco::Vertex>*)o)->operator=)(*(const ::edm::PtrVector<reco::Vertex>*)arg[0]);
  else   (((::edm::PtrVector<reco::Vertex>*)o)->operator=)(*(const ::edm::PtrVector<reco::Vertex>*)arg[0]);
}

static  void method_51289( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::PtrVector<reco::Vertex>*)o)->fillView)(*(::std::vector<const void*>*)arg[0]);
}

static  void method_51290( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::PtrVector<reco::Vertex>*)o)->Class_Version)());
  else   (((::edm::PtrVector<reco::Vertex>*)o)->Class_Version)();
}

static void destructor_51293(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::PtrVector<reco::Vertex>*)o)->::edm::PtrVector<reco::Vertex>::~PtrVector)();
}
static void method_newdel_8840( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::Vertex> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::Vertex> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::Vertex> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::Vertex> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::Vertex> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x23( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVectorBase")), ::Reflex::BaseOffset< ::edm::PtrVector<reco::Vertex>,::edm::PtrVectorBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PtrVector<reco::Vertex> -------------------------------
void __edm__PtrVector_reco__Vertex__db_datamem(Reflex::Class*);
void __edm__PtrVector_reco__Vertex__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__PtrVector_reco__Vertex__datamem_bld(&__edm__PtrVector_reco__Vertex__db_datamem);
Reflex::GenreflexMemberBuilder __edm__PtrVector_reco__Vertex__funcmem_bld(&__edm__PtrVector_reco__Vertex__db_funcmem);
void __edm__PtrVector_reco__Vertex__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::PtrVector<reco::Vertex>"), typeid(::edm::PtrVector<reco::Vertex>), sizeof(::edm::PtrVector<reco::Vertex>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::PtrVector<reco::Vertex>::Class_Version())
  .AddBase(type_9562, ::Reflex::BaseOffset< ::edm::PtrVector<reco::Vertex>, ::edm::PtrVectorBase >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_9383, Reflex::Literal("edm::PtrVector<reco::Vertex>::const_iterator"))
  .AddTypedef(type_9383, Reflex::Literal("edm::PtrVector<reco::Vertex>::iterator"))
  .AddTypedef(type_9784, Reflex::Literal("edm::PtrVector<reco::Vertex>::value_type"))
  .AddTypedef(type_539, Reflex::Literal("edm::PtrVector<reco::Vertex>::collection_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PtrVector"), constructor_51280, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417), Reflex::Literal("PtrVector"), constructor_51281, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_50680), Reflex::Literal("PtrVector"), constructor_51282, 0, "iOther", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PtrVector"), destructor_51293, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_8840, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x23, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__edm__PtrVector_reco__Vertex__funcmem_bld);
}

//------Delayed data member builder for class PtrVector<reco::Vertex> -------------------
void __edm__PtrVector_reco__Vertex__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class PtrVector<reco::Vertex> -------------------
void __edm__PtrVector_reco__Vertex__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9784, type_484c), Reflex::Literal("operator[]"), operator_51283, 0, "iIndex", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9383), Reflex::Literal("begin"), method_51284, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9383), Reflex::Literal("end"), method_51285, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_46448), Reflex::Literal("push_back"), method_51286, 0, "iPtr", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_84809), Reflex::Literal("swap"), method_51287, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_84809, type_50680), Reflex::Literal("operator="), operator_51288, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45461), Reflex::Literal("fillView"), method_51289, 0, "pointers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_251), Reflex::Literal("Class_Version"), method_51290, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Wrapper<PATMultiCandFinalState> -------------------------------
static void constructor_54510( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATMultiCandFinalState>();
  else ::new(mem) ::edm::Wrapper<PATMultiCandFinalState>();
}

static void constructor_54511( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATMultiCandFinalState>(*(::std::auto_ptr<PATMultiCandFinalState>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATMultiCandFinalState>(*(::std::auto_ptr<PATMultiCandFinalState>*)arg[0]);
}

static void destructor_54512(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATMultiCandFinalState>*)o)->::edm::Wrapper<PATMultiCandFinalState>::~Wrapper)();
}
static  void method_54513( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATMultiCandFinalState>*)o)->product)());
  else   (((const ::edm::Wrapper<PATMultiCandFinalState>*)o)->product)();
}

static  void operator_54514( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATMultiCandFinalState>*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATMultiCandFinalState>*)o)->operator->)();
}

static  void method_54515( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATMultiCandFinalState>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATMultiCandFinalState>*)o)->productTypeInfo)();
}

static  void method_54516( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATMultiCandFinalState>*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATMultiCandFinalState>*)o)->typeInfo)();
}

static void constructor_54517( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATMultiCandFinalState>((::PATMultiCandFinalState*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATMultiCandFinalState>((::PATMultiCandFinalState*)arg[0]);
}

static  void method_54518( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATMultiCandFinalState>*)o)->getInterface)());
  else   (((::edm::Wrapper<PATMultiCandFinalState>*)o)->getInterface)();
}

static  void method_54519( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATMultiCandFinalState>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_54520( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATMultiCandFinalState>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_54521( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATMultiCandFinalState>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_54522( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATMultiCandFinalState>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATMultiCandFinalState>*)o)->dynamicTypeInfo)();
}

static  void method_54523( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATMultiCandFinalState>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATMultiCandFinalState>*)o)->isPresent)();
}

static  void method_54524( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATMultiCandFinalState>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATMultiCandFinalState>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9235( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATMultiCandFinalState> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATMultiCandFinalState> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATMultiCandFinalState> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATMultiCandFinalState> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATMultiCandFinalState> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATMultiCandFinalState> -------------------------------
void __edm__Wrapper_PATMultiCandFinalState__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATMultiCandFinalState__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATMultiCandFinalState__datamem_bld(&__edm__Wrapper_PATMultiCandFinalState__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATMultiCandFinalState__funcmem_bld(&__edm__Wrapper_PATMultiCandFinalState__db_funcmem);
void __edm__Wrapper_PATMultiCandFinalState__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATMultiCandFinalState>"), typeid(::edm::Wrapper<PATMultiCandFinalState>), sizeof(::edm::Wrapper<PATMultiCandFinalState>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_67, Reflex::Literal("edm::Wrapper<PATMultiCandFinalState>::value_type"))
  .AddTypedef(type_67, Reflex::Literal("edm::Wrapper<PATMultiCandFinalState>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_54510, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4270), Reflex::Literal("Wrapper"), constructor_54511, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_54512, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18144), Reflex::Literal("Wrapper"), constructor_54517, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9235, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATMultiCandFinalState__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATMultiCandFinalState__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATMultiCandFinalState> -------------------
void __edm__Wrapper_PATMultiCandFinalState__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATMultiCandFinalState_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_67, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATMultiCandFinalState_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATMultiCandFinalState> -------------------
void __edm__Wrapper_PATMultiCandFinalState__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18146), Reflex::Literal("product"), method_54513, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18146), Reflex::Literal("operator->"), operator_54514, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_54515, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_54516, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85374), Reflex::Literal("getInterface"), method_54518, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_54519, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_54520, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_54521, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_54522, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_54523, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_54524, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATFinalStateLS> -------------------------------
static void constructor_54552( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATFinalStateLS>();
  else ::new(mem) ::edm::Wrapper<PATFinalStateLS>();
}

static void constructor_54553( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATFinalStateLS>(*(::std::auto_ptr<PATFinalStateLS>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATFinalStateLS>(*(::std::auto_ptr<PATFinalStateLS>*)arg[0]);
}

static void destructor_54554(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATFinalStateLS>*)o)->::edm::Wrapper<PATFinalStateLS>::~Wrapper)();
}
static  void method_54555( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATFinalStateLS>*)o)->product)());
  else   (((const ::edm::Wrapper<PATFinalStateLS>*)o)->product)();
}

static  void operator_54556( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATFinalStateLS>*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATFinalStateLS>*)o)->operator->)();
}

static  void method_54557( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATFinalStateLS>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATFinalStateLS>*)o)->productTypeInfo)();
}

static  void method_54558( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATFinalStateLS>*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATFinalStateLS>*)o)->typeInfo)();
}

static void constructor_54559( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATFinalStateLS>((::PATFinalStateLS*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATFinalStateLS>((::PATFinalStateLS*)arg[0]);
}

static  void method_54560( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATFinalStateLS>*)o)->getInterface)());
  else   (((::edm::Wrapper<PATFinalStateLS>*)o)->getInterface)();
}

static  void method_54561( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATFinalStateLS>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_54562( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATFinalStateLS>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_54563( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATFinalStateLS>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_54564( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATFinalStateLS>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATFinalStateLS>*)o)->dynamicTypeInfo)();
}

static  void method_54565( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATFinalStateLS>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATFinalStateLS>*)o)->isPresent)();
}

static  void method_54566( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATFinalStateLS>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATFinalStateLS>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9237( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATFinalStateLS> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATFinalStateLS> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATFinalStateLS> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATFinalStateLS> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATFinalStateLS> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATFinalStateLS> -------------------------------
void __edm__Wrapper_PATFinalStateLS__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATFinalStateLS__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATFinalStateLS__datamem_bld(&__edm__Wrapper_PATFinalStateLS__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATFinalStateLS__funcmem_bld(&__edm__Wrapper_PATFinalStateLS__db_funcmem);
void __edm__Wrapper_PATFinalStateLS__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATFinalStateLS>"), typeid(::edm::Wrapper<PATFinalStateLS>), sizeof(::edm::Wrapper<PATFinalStateLS>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3039, Reflex::Literal("edm::Wrapper<PATFinalStateLS>::value_type"))
  .AddTypedef(type_3039, Reflex::Literal("edm::Wrapper<PATFinalStateLS>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_54552, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4272), Reflex::Literal("Wrapper"), constructor_54553, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_54554, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14865), Reflex::Literal("Wrapper"), constructor_54559, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9237, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATFinalStateLS__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATFinalStateLS__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATFinalStateLS> -------------------
void __edm__Wrapper_PATFinalStateLS__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATFinalStateLS_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3039, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATFinalStateLS_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATFinalStateLS> -------------------
void __edm__Wrapper_PATFinalStateLS__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14867), Reflex::Literal("product"), method_54555, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14867), Reflex::Literal("operator->"), operator_54556, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_54557, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_54558, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85381), Reflex::Literal("getInterface"), method_54560, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_54561, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_54562, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_54563, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_54564, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_54565, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_54566, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATFinalStateEvent> -------------------------------
static void constructor_54594( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATFinalStateEvent>();
  else ::new(mem) ::edm::Wrapper<PATFinalStateEvent>();
}

static void constructor_54595( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATFinalStateEvent>(*(::std::auto_ptr<PATFinalStateEvent>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATFinalStateEvent>(*(::std::auto_ptr<PATFinalStateEvent>*)arg[0]);
}

static void destructor_54596(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATFinalStateEvent>*)o)->::edm::Wrapper<PATFinalStateEvent>::~Wrapper)();
}
static  void method_54597( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATFinalStateEvent>*)o)->product)());
  else   (((const ::edm::Wrapper<PATFinalStateEvent>*)o)->product)();
}

static  void operator_54598( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATFinalStateEvent>*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATFinalStateEvent>*)o)->operator->)();
}

static  void method_54599( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATFinalStateEvent>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATFinalStateEvent>*)o)->productTypeInfo)();
}

static  void method_54600( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATFinalStateEvent>*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATFinalStateEvent>*)o)->typeInfo)();
}

static void constructor_54601( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATFinalStateEvent>((::PATFinalStateEvent*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATFinalStateEvent>((::PATFinalStateEvent*)arg[0]);
}

static  void method_54602( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATFinalStateEvent>*)o)->getInterface)());
  else   (((::edm::Wrapper<PATFinalStateEvent>*)o)->getInterface)();
}

static  void method_54603( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATFinalStateEvent>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_54604( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATFinalStateEvent>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_54605( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATFinalStateEvent>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_54606( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATFinalStateEvent>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATFinalStateEvent>*)o)->dynamicTypeInfo)();
}

static  void method_54607( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATFinalStateEvent>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATFinalStateEvent>*)o)->isPresent)();
}

static  void method_54608( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATFinalStateEvent>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATFinalStateEvent>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9239( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATFinalStateEvent> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATFinalStateEvent> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATFinalStateEvent> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATFinalStateEvent> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATFinalStateEvent> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATFinalStateEvent> -------------------------------
void __edm__Wrapper_PATFinalStateEvent__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATFinalStateEvent__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATFinalStateEvent__datamem_bld(&__edm__Wrapper_PATFinalStateEvent__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATFinalStateEvent__funcmem_bld(&__edm__Wrapper_PATFinalStateEvent__db_funcmem);
void __edm__Wrapper_PATFinalStateEvent__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATFinalStateEvent>"), typeid(::edm::Wrapper<PATFinalStateEvent>), sizeof(::edm::Wrapper<PATFinalStateEvent>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_583, Reflex::Literal("edm::Wrapper<PATFinalStateEvent>::value_type"))
  .AddTypedef(type_583, Reflex::Literal("edm::Wrapper<PATFinalStateEvent>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_54594, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4274), Reflex::Literal("Wrapper"), constructor_54595, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_54596, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7663), Reflex::Literal("Wrapper"), constructor_54601, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9239, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATFinalStateEvent__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATFinalStateEvent__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATFinalStateEvent> -------------------
void __edm__Wrapper_PATFinalStateEvent__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATFinalStateEvent_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_583, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATFinalStateEvent_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATFinalStateEvent> -------------------
void __edm__Wrapper_PATFinalStateEvent__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7665), Reflex::Literal("product"), method_54597, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7665), Reflex::Literal("operator->"), operator_54598, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_54599, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_54600, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85388), Reflex::Literal("getInterface"), method_54602, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_54603, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_54604, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_54605, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_54606, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_54607, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_54608, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Ptr<reco::Vertex> -------------------------------
static  void operator_56391( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ptr<reco::Vertex>*)o)->operator=)(*(const ::edm::Ptr<reco::Vertex>*)arg[0]);
  else   (((::edm::Ptr<reco::Vertex>*)o)->operator=)(*(const ::edm::Ptr<reco::Vertex>*)arg[0]);
}

static void constructor_56392( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::Vertex>(*(const ::edm::Ptr<reco::Vertex>*)arg[0]);
  else ::new(mem) ::edm::Ptr<reco::Vertex>(*(const ::edm::Ptr<reco::Vertex>*)arg[0]);
}

static void constructor_56393( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::Vertex>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ptr<reco::Vertex>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_56394( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::Vertex>(*(const ::edm::ProductID*)arg[0],
      (const ::reco::Vertex*)arg[1],
      *(unsigned long*)arg[2]);
  else ::new(mem) ::edm::Ptr<reco::Vertex>(*(const ::edm::ProductID*)arg[0],
      (const ::reco::Vertex*)arg[1],
      *(unsigned long*)arg[2]);
}

static void constructor_56395( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::Vertex>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ptr<reco::Vertex>(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_56396( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::Vertex>();
  else ::new(mem) ::edm::Ptr<reco::Vertex>();
}

static void destructor_56397(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ptr<reco::Vertex>*)o)->::edm::Ptr<reco::Vertex>::~Ptr)();
}
static  void operator_56398( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<reco::Vertex>*)o)->operator*)();
  else   (((const ::edm::Ptr<reco::Vertex>*)o)->operator*)();
}

static  void operator_56399( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::Vertex>*)o)->operator->)());
  else   (((const ::edm::Ptr<reco::Vertex>*)o)->operator->)();
}

static  void method_56400( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::Vertex>*)o)->get)());
  else   (((const ::edm::Ptr<reco::Vertex>*)o)->get)();
}

static  void method_56401( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::Vertex>*)o)->isNull)());
  else   (((const ::edm::Ptr<reco::Vertex>*)o)->isNull)();
}

static  void method_56402( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::Vertex>*)o)->isNonnull)());
  else   (((const ::edm::Ptr<reco::Vertex>*)o)->isNonnull)();
}

static  void operator_56403( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::Vertex>*)o)->operator!)());
  else   (((const ::edm::Ptr<reco::Vertex>*)o)->operator!)();
}

static  void method_56404( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::Vertex>*)o)->isAvailable)());
  else   (((const ::edm::Ptr<reco::Vertex>*)o)->isAvailable)();
}

static  void method_56405( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::Vertex>*)o)->isTransient)());
  else   (((const ::edm::Ptr<reco::Vertex>*)o)->isTransient)();
}

static  void method_56406( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ptr<reco::Vertex>*)o)->id)());
  else   (((const ::edm::Ptr<reco::Vertex>*)o)->id)();
}

static  void method_56407( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::Vertex>*)o)->productGetter)());
  else   (((const ::edm::Ptr<reco::Vertex>*)o)->productGetter)();
}

static  void method_56408( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::edm::Ptr<reco::Vertex>*)o)->key)());
  else   (((const ::edm::Ptr<reco::Vertex>*)o)->key)();
}

static  void method_56409( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::Vertex>*)o)->hasProductCache)());
  else   (((const ::edm::Ptr<reco::Vertex>*)o)->hasProductCache)();
}

static  void method_56410( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<reco::Vertex>*)o)->refCore)();
  else   (((const ::edm::Ptr<reco::Vertex>*)o)->refCore)();
}

static  void method_56411( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::Vertex>*)o)->product)());
  else   (((const ::edm::Ptr<reco::Vertex>*)o)->product)();
}

static  void method_56412( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ptr<reco::Vertex>*)o)->Class_Version)());
  else   (((::edm::Ptr<reco::Vertex>*)o)->Class_Version)();
}

static void method_newdel_9784( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::Vertex> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::Vertex> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::Vertex> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::Vertex> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::Vertex> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ptr<reco::Vertex> -------------------------------
void __edm__Ptr_reco__Vertex__db_datamem(Reflex::Class*);
void __edm__Ptr_reco__Vertex__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ptr_reco__Vertex__datamem_bld(&__edm__Ptr_reco__Vertex__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ptr_reco__Vertex__funcmem_bld(&__edm__Ptr_reco__Vertex__db_funcmem);
void __edm__Ptr_reco__Vertex__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ptr<reco::Vertex>"), typeid(::edm::Ptr<reco::Vertex>), sizeof(::edm::Ptr<reco::Vertex>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ptr<reco::Vertex>::Class_Version())
  .AddTypedef(type_484, Reflex::Literal("edm::Ptr<reco::Vertex>::key_type"))
  .AddTypedef(type_16644, Reflex::Literal("edm::Ptr<reco::Vertex>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85747, type_46448), Reflex::Literal("operator="), operator_56391, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_46448), Reflex::Literal("Ptr"), constructor_56392, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417, type_484, type_45418), Reflex::Literal("Ptr"), constructor_56393, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417, type_32584, type_484), Reflex::Literal("Ptr"), constructor_56394, 0, "productID;item;item_key", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417), Reflex::Literal("Ptr"), constructor_56395, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ptr"), constructor_56396, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ptr"), destructor_56397, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9784, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ptr_reco__Vertex__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ptr_reco__Vertex__funcmem_bld);
}

//------Delayed data member builder for class Ptr<reco::Vertex> -------------------
void __edm__Ptr_reco__Vertex__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9667, Reflex::Literal("core_"), OffsetOf(__shadow__::__edm__Ptr_reco__Vertex_, core_), ::Reflex::PRIVATE)
  .AddDataMember(type_484, Reflex::Literal("key_"), OffsetOf(__shadow__::__edm__Ptr_reco__Vertex_, key_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Ptr<reco::Vertex> -------------------
void __edm__Ptr_reco__Vertex__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32588), Reflex::Literal("operator*"), operator_56398, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32584), Reflex::Literal("operator->"), operator_56399, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32584), Reflex::Literal("get"), method_56400, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNull"), method_56401, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNonnull"), method_56402, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("operator!"), operator_56403, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isAvailable"), method_56404, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isTransient"), method_56405, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9664), Reflex::Literal("id"), method_56406, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45418), Reflex::Literal("productGetter"), method_56407, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_484), Reflex::Literal("key"), method_56408, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("hasProductCache"), method_56409, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45420), Reflex::Literal("refCore"), method_56410, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6842), Reflex::Literal("product"), method_56411, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_251), Reflex::Literal("Class_Version"), method_56412, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ptr<pat::Photon> -------------------------------
static  void operator_56447( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ptr<pat::Photon>*)o)->operator=)(*(const ::edm::Ptr<pat::Photon>*)arg[0]);
  else   (((::edm::Ptr<pat::Photon>*)o)->operator=)(*(const ::edm::Ptr<pat::Photon>*)arg[0]);
}

static void constructor_56448( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<pat::Photon>(*(const ::edm::Ptr<pat::Photon>*)arg[0]);
  else ::new(mem) ::edm::Ptr<pat::Photon>(*(const ::edm::Ptr<pat::Photon>*)arg[0]);
}

static void constructor_56449( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<pat::Photon>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ptr<pat::Photon>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_56450( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<pat::Photon>(*(const ::edm::ProductID*)arg[0],
      (const ::pat::Photon*)arg[1],
      *(unsigned long*)arg[2]);
  else ::new(mem) ::edm::Ptr<pat::Photon>(*(const ::edm::ProductID*)arg[0],
      (const ::pat::Photon*)arg[1],
      *(unsigned long*)arg[2]);
}

static void constructor_56451( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<pat::Photon>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ptr<pat::Photon>(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_56452( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<pat::Photon>();
  else ::new(mem) ::edm::Ptr<pat::Photon>();
}

static void destructor_56453(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ptr<pat::Photon>*)o)->::edm::Ptr<pat::Photon>::~Ptr)();
}
static  void operator_56454( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<pat::Photon>*)o)->operator*)();
  else   (((const ::edm::Ptr<pat::Photon>*)o)->operator*)();
}

static  void operator_56455( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<pat::Photon>*)o)->operator->)());
  else   (((const ::edm::Ptr<pat::Photon>*)o)->operator->)();
}

static  void method_56456( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<pat::Photon>*)o)->get)());
  else   (((const ::edm::Ptr<pat::Photon>*)o)->get)();
}

static  void method_56457( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::Photon>*)o)->isNull)());
  else   (((const ::edm::Ptr<pat::Photon>*)o)->isNull)();
}

static  void method_56458( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::Photon>*)o)->isNonnull)());
  else   (((const ::edm::Ptr<pat::Photon>*)o)->isNonnull)();
}

static  void operator_56459( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::Photon>*)o)->operator!)());
  else   (((const ::edm::Ptr<pat::Photon>*)o)->operator!)();
}

static  void method_56460( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::Photon>*)o)->isAvailable)());
  else   (((const ::edm::Ptr<pat::Photon>*)o)->isAvailable)();
}

static  void method_56461( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::Photon>*)o)->isTransient)());
  else   (((const ::edm::Ptr<pat::Photon>*)o)->isTransient)();
}

static  void method_56462( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ptr<pat::Photon>*)o)->id)());
  else   (((const ::edm::Ptr<pat::Photon>*)o)->id)();
}

static  void method_56463( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<pat::Photon>*)o)->productGetter)());
  else   (((const ::edm::Ptr<pat::Photon>*)o)->productGetter)();
}

static  void method_56464( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::edm::Ptr<pat::Photon>*)o)->key)());
  else   (((const ::edm::Ptr<pat::Photon>*)o)->key)();
}

static  void method_56465( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<pat::Photon>*)o)->hasProductCache)());
  else   (((const ::edm::Ptr<pat::Photon>*)o)->hasProductCache)();
}

static  void method_56466( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<pat::Photon>*)o)->refCore)();
  else   (((const ::edm::Ptr<pat::Photon>*)o)->refCore)();
}

static  void method_56467( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<pat::Photon>*)o)->product)());
  else   (((const ::edm::Ptr<pat::Photon>*)o)->product)();
}

static  void method_56468( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ptr<pat::Photon>*)o)->Class_Version)());
  else   (((::edm::Ptr<pat::Photon>*)o)->Class_Version)();
}

static void method_newdel_9786( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ptr<pat::Photon> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ptr<pat::Photon> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ptr<pat::Photon> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ptr<pat::Photon> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ptr<pat::Photon> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ptr<pat::Photon> -------------------------------
void __edm__Ptr_pat__Photon__db_datamem(Reflex::Class*);
void __edm__Ptr_pat__Photon__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ptr_pat__Photon__datamem_bld(&__edm__Ptr_pat__Photon__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ptr_pat__Photon__funcmem_bld(&__edm__Ptr_pat__Photon__db_funcmem);
void __edm__Ptr_pat__Photon__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ptr<pat::Photon>"), typeid(::edm::Ptr<pat::Photon>), sizeof(::edm::Ptr<pat::Photon>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ptr<pat::Photon>::Class_Version())
  .AddTypedef(type_484, Reflex::Literal("edm::Ptr<pat::Photon>::key_type"))
  .AddTypedef(type_6478, Reflex::Literal("edm::Ptr<pat::Photon>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85749, type_45637), Reflex::Literal("operator="), operator_56447, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45637), Reflex::Literal("Ptr"), constructor_56448, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417, type_484, type_45418), Reflex::Literal("Ptr"), constructor_56449, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417, type_29862, type_484), Reflex::Literal("Ptr"), constructor_56450, 0, "productID;item;item_key", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417), Reflex::Literal("Ptr"), constructor_56451, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ptr"), constructor_56452, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ptr"), destructor_56453, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9786, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ptr_pat__Photon__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ptr_pat__Photon__funcmem_bld);
}

//------Delayed data member builder for class Ptr<pat::Photon> -------------------
void __edm__Ptr_pat__Photon__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9667, Reflex::Literal("core_"), OffsetOf(__shadow__::__edm__Ptr_pat__Photon_, core_), ::Reflex::PRIVATE)
  .AddDataMember(type_484, Reflex::Literal("key_"), OffsetOf(__shadow__::__edm__Ptr_pat__Photon_, key_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Ptr<pat::Photon> -------------------
void __edm__Ptr_pat__Photon__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29866), Reflex::Literal("operator*"), operator_56454, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29862), Reflex::Literal("operator->"), operator_56455, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29862), Reflex::Literal("get"), method_56456, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNull"), method_56457, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNonnull"), method_56458, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("operator!"), operator_56459, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isAvailable"), method_56460, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isTransient"), method_56461, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9664), Reflex::Literal("id"), method_56462, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45418), Reflex::Literal("productGetter"), method_56463, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_484), Reflex::Literal("key"), method_56464, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("hasProductCache"), method_56465, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45420), Reflex::Literal("refCore"), method_56466, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6842), Reflex::Literal("product"), method_56467, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_251), Reflex::Literal("Class_Version"), method_56468, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> -------------------------------
static  void operator_6481( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*)o)->operator=)(*(const ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*)arg[0]);
  else   (((::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*)o)->operator=)(*(const ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*)arg[0]);
}

static void constructor_6482( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>(*(const ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*)arg[0]);
  else ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>(*(const ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*)arg[0]);
}

static void constructor_6483( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>();
  else ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>();
}

static void constructor_6484( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Photon>*)arg[1],
      *(const ::edm::Ptr<pat::Photon>*)arg[2],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[3]);
  else ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Photon>*)arg[1],
      *(const ::edm::Ptr<pat::Photon>*)arg[2],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[3]);
}

static  void method_6485( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*)o)->clone)());
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*)o)->clone)();
}

static  void method_6486( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_6487( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_6488( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*)o)->numberOfDaughters)());
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*)o)->numberOfDaughters)();
}

static  void method_6489( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_6490( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_6491(void*, void * o, const std::vector<void*>&, void *) {
(((::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*)o)->::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>::~PATTripletFinalStateT)();
}
static void method_newdel_110( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x30( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> -------------------------------
void __PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon__db_datamem(Reflex::Class*);
void __PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon__datamem_bld(&__PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon__db_datamem);
Reflex::GenreflexMemberBuilder __PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon__funcmem_bld(&__PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon__db_funcmem);
void __PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>"), typeid(::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>), sizeof(::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6476, Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>::daughter1_type"))
  .AddTypedef(type_6478, Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>::daughter2_type"))
  .AddTypedef(type_6478, Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>::daughter3_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17031, type_17033), Reflex::Literal("operator="), operator_6481, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17033), Reflex::Literal("PATTripletFinalStateT"), constructor_6482, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATTripletFinalStateT"), constructor_6483, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45636, type_45637, type_45637, type_45406), Reflex::Literal("PATTripletFinalStateT"), constructor_6484, 0, "p1;p2;p3;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATTripletFinalStateT"), destructor_6491, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_110, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x30, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon__funcmem_bld);
}

//------Delayed data member builder for class PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> -------------------
void __PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9785, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9786, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_, p2_), ::Reflex::PRIVATE)
  .AddDataMember(type_9786, Reflex::Literal("p3_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_, p3_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> -------------------
void __PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17027), Reflex::Literal("clone"), method_6485, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_6486, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_6487, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_6488, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_6489, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_6490, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> -------------------------------
static  void operator_6501( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*)o)->operator=)(*(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*)arg[0]);
  else   (((::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*)o)->operator=)(*(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*)arg[0]);
}

static void constructor_6502( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>(*(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*)arg[0]);
  else ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>(*(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*)arg[0]);
}

static void constructor_6503( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>();
  else ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>();
}

static void constructor_6504( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Muon>*)arg[1],
      *(const ::edm::Ptr<pat::Muon>*)arg[2],
      *(const ::edm::Ptr<pat::Muon>*)arg[3],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[4]);
  else ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Muon>*)arg[1],
      *(const ::edm::Ptr<pat::Muon>*)arg[2],
      *(const ::edm::Ptr<pat::Muon>*)arg[3],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[4]);
}

static  void method_6505( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*)o)->clone)());
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*)o)->clone)();
}

static  void method_6506( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_6507( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_6508( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*)o)->numberOfDaughters)());
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*)o)->numberOfDaughters)();
}

static  void method_6509( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_6510( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_6511(void*, void * o, const std::vector<void*>&, void *) {
(((::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*)o)->::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>::~PATQuadFinalStateT)();
}
static void method_newdel_113( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x32( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> -------------------------------
void __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon__db_datamem(Reflex::Class*);
void __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon__datamem_bld(&__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon__db_datamem);
Reflex::GenreflexMemberBuilder __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon__funcmem_bld(&__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon__db_funcmem);
void __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>"), typeid(::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>), sizeof(::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6476, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>::daughter1_type"))
  .AddTypedef(type_6497, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>::daughter2_type"))
  .AddTypedef(type_6497, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>::daughter3_type"))
  .AddTypedef(type_6497, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>::daughter4_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17315, type_17317), Reflex::Literal("operator="), operator_6501, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17317), Reflex::Literal("PATQuadFinalStateT"), constructor_6502, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATQuadFinalStateT"), constructor_6503, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45636, type_45727, type_45727, type_45727, type_45406), Reflex::Literal("PATQuadFinalStateT"), constructor_6504, 0, "p1;p2;p3;p4;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATQuadFinalStateT"), destructor_6511, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_113, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x32, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon__funcmem_bld);
}

//------Delayed data member builder for class PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> -------------------
void __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9785, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9782, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_, p2_), ::Reflex::PRIVATE)
  .AddDataMember(type_9782, Reflex::Literal("p3_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_, p3_), ::Reflex::PRIVATE)
  .AddDataMember(type_9782, Reflex::Literal("p4_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_, p4_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> -------------------
void __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17311), Reflex::Literal("clone"), method_6505, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_6506, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_6507, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_6508, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_6509, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_6510, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> -------------------------------
static  void operator_6730( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*)o)->operator=)(*(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*)arg[0]);
  else   (((::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*)o)->operator=)(*(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*)arg[0]);
}

static void constructor_6731( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>(*(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*)arg[0]);
  else ::new(mem) ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>(*(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*)arg[0]);
}

static void constructor_6732( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>();
  else ::new(mem) ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>();
}

static void constructor_6733( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>(*(const ::edm::Ptr<pat::Muon>*)arg[0],
      *(const ::edm::Ptr<pat::Muon>*)arg[1],
      *(const ::edm::Ptr<pat::Muon>*)arg[2],
      *(const ::edm::Ptr<pat::Photon>*)arg[3],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[4]);
  else ::new(mem) ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>(*(const ::edm::Ptr<pat::Muon>*)arg[0],
      *(const ::edm::Ptr<pat::Muon>*)arg[1],
      *(const ::edm::Ptr<pat::Muon>*)arg[2],
      *(const ::edm::Ptr<pat::Photon>*)arg[3],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[4]);
}

static  void method_6734( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*)o)->clone)());
  else   (((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*)o)->clone)();
}

static  void method_6735( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_6736( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_6737( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*)o)->numberOfDaughters)());
  else   (((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*)o)->numberOfDaughters)();
}

static  void method_6738( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_6739( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_6740(void*, void * o, const std::vector<void*>&, void *) {
(((::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*)o)->::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>::~PATQuadFinalStateT)();
}
static void method_newdel_164( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x34( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> -------------------------------
void __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon__db_datamem(Reflex::Class*);
void __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon__datamem_bld(&__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon__db_datamem);
Reflex::GenreflexMemberBuilder __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon__funcmem_bld(&__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon__db_funcmem);
void __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>"), typeid(::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>), sizeof(::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6497, Reflex::Literal("PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>::daughter1_type"))
  .AddTypedef(type_6497, Reflex::Literal("PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>::daughter2_type"))
  .AddTypedef(type_6497, Reflex::Literal("PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>::daughter3_type"))
  .AddTypedef(type_6478, Reflex::Literal("PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>::daughter4_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15237, type_15239), Reflex::Literal("operator="), operator_6730, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15239), Reflex::Literal("PATQuadFinalStateT"), constructor_6731, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATQuadFinalStateT"), constructor_6732, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45727, type_45727, type_45727, type_45637, type_45406), Reflex::Literal("PATQuadFinalStateT"), constructor_6733, 0, "p1;p2;p3;p4;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATQuadFinalStateT"), destructor_6740, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_164, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x34, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon__funcmem_bld);
}

//------Delayed data member builder for class PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> -------------------
void __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9782, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9782, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_, p2_), ::Reflex::PRIVATE)
  .AddDataMember(type_9782, Reflex::Literal("p3_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_, p3_), ::Reflex::PRIVATE)
  .AddDataMember(type_9786, Reflex::Literal("p4_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_, p4_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> -------------------
void __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15233), Reflex::Literal("clone"), method_6734, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_6735, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_6736, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_6737, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_6738, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_6739, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> -------------------------------
static  void operator_12437( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*)o)->operator=)(*(const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*)arg[0]);
  else   (((::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*)o)->operator=)(*(const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*)arg[0]);
}

static void constructor_12438( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>(*(const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*)arg[0]);
  else ::new(mem) ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>(*(const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*)arg[0]);
}

static void constructor_12439( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>();
  else ::new(mem) ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>();
}

static void constructor_12440( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>(*(const ::edm::Ptr<pat::Muon>*)arg[0],
      *(const ::edm::Ptr<pat::Muon>*)arg[1],
      *(const ::edm::Ptr<pat::Tau>*)arg[2],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[3]);
  else ::new(mem) ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>(*(const ::edm::Ptr<pat::Muon>*)arg[0],
      *(const ::edm::Ptr<pat::Muon>*)arg[1],
      *(const ::edm::Ptr<pat::Tau>*)arg[2],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[3]);
}

static  void method_12441( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*)o)->clone)());
  else   (((const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*)o)->clone)();
}

static  void method_12442( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_12443( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_12444( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*)o)->numberOfDaughters)());
  else   (((const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*)o)->numberOfDaughters)();
}

static  void method_12445( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_12446( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_12447(void*, void * o, const std::vector<void*>&, void *) {
(((::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*)o)->::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>::~PATTripletFinalStateT)();
}
static void method_newdel_1519( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x36( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> -------------------------------
void __PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau__db_datamem(Reflex::Class*);
void __PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau__datamem_bld(&__PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau__db_datamem);
Reflex::GenreflexMemberBuilder __PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau__funcmem_bld(&__PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau__db_funcmem);
void __PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>"), typeid(::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>), sizeof(::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6497, Reflex::Literal("PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>::daughter1_type"))
  .AddTypedef(type_6497, Reflex::Literal("PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>::daughter2_type"))
  .AddTypedef(type_7135, Reflex::Literal("PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>::daughter3_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6935, type_6937), Reflex::Literal("operator="), operator_12437, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6937), Reflex::Literal("PATTripletFinalStateT"), constructor_12438, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATTripletFinalStateT"), constructor_12439, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45727, type_45727, type_46321, type_45406), Reflex::Literal("PATTripletFinalStateT"), constructor_12440, 0, "p1;p2;p3;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATTripletFinalStateT"), destructor_12447, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1519, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x36, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau__funcmem_bld);
}

//------Delayed data member builder for class PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> -------------------
void __PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9782, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9782, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_, p2_), ::Reflex::PRIVATE)
  .AddDataMember(type_9787, Reflex::Literal("p3_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_, p3_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> -------------------
void __PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6931), Reflex::Literal("clone"), method_12441, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_12442, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_12443, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_12444, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_12445, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_12446, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class vector<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Tau> > > -------------------------------
static void constructor_6948( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >();
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >();
}

static void constructor_6949( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >(*(const ::std::allocator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >(*(const ::std::allocator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)arg[0]);
}

static void constructor_6950( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*)arg[1]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*)arg[1],
      *(const ::std::allocator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)arg[2]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*)arg[1],
      *(const ::std::allocator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)arg[2]);
  }
}

static void constructor_6951( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >(*(const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >(*(const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)arg[0]);
}

static void destructor_6952(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >::~vector)();
}
static  void operator_6953( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->operator=)(*(const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->operator=)(*(const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)arg[0]);
}

static  void method_6954( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*)arg[1]);
}

static  void method_6955( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >)((((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->begin)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->begin)();
}

static  void method_6956( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >)((((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->begin)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->begin)();
}

static  void method_6957( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >)((((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->end)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->end)();
}

static  void method_6958( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >)((((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->end)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->end)();
}

static  void method_6963( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->size)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->size)();
}

static  void method_6964( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->max_size)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->max_size)();
}

static  void method_6965( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*)arg[1]);
  }
}

static  void method_6966( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->capacity)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->capacity)();
}

static  void method_6967( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->empty)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->empty)();
}

static  void method_6968( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_6969( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_6970( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_6972( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6973( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6974( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->front)();
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->front)();
}

static  void method_6975( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->front)();
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->front)();
}

static  void method_6976( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->back)();
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->back)();
}

static  void method_6977( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->back)();
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->back)();
}

static  void method_6978( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->data)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->data)();
}

static  void method_6979( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->data)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->data)();
}

static  void method_6980( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->push_back)(*(const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*)arg[0]);
}

static  void method_6981( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->pop_back)();
}

static  void method_6982( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >)((((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*)arg[1]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*)arg[1]);
}

static  void method_6983( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*)arg[2]);
}

static  void method_6984( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >)((((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >*)arg[0]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >*)arg[0]);
}

static  void method_6985( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >)((((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >*)arg[1]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >*)arg[1]);
}

static  void method_6986( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->swap)(*(::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)arg[0]);
}

static  void method_6987( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->clear)();
}

static void method_newdel_260( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x38( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >")), ::Reflex::BaseOffset< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >,::std::_Vector_base<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x39( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >::Generate();
}

//------Dictionary for class vector<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Tau> > > -------------------------------
void __std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s__db_datamem(Reflex::Class*);
void __std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s__datamem_bld(&__std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s__funcmem_bld(&__std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s__db_funcmem);
void __std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >"), typeid(::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >), sizeof(::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3709, ::Reflex::BaseOffset< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >, ::std::_Vector_base<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1519, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >::_Alloc_value_type"))
  .AddTypedef(type_3709, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >::_Base"))
  .AddTypedef(type_5064, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >::_Tp_alloc_type"))
  .AddTypedef(type_1519, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >::value_type"))
  .AddTypedef(type_6931, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >::pointer"))
  .AddTypedef(type_6933, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >::const_pointer"))
  .AddTypedef(type_6935, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >::reference"))
  .AddTypedef(type_6937, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >::const_reference"))
  .AddTypedef(type_6939, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >::iterator"))
  .AddTypedef(type_6941, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >::const_iterator"))
  .AddTypedef(type_5671, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >::const_reverse_iterator"))
  .AddTypedef(type_5672, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >::difference_type"))
  .AddTypedef(type_5064, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_6948, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45944), Reflex::Literal("vector"), constructor_6949, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_6937, type_45944), Reflex::Literal("vector"), constructor_6950, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45945), Reflex::Literal("vector"), constructor_6951, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_6952, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_260, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x38, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x39, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Tau> > > -------------------
void __std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Tau> > > -------------------
void __std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45946, type_45945), Reflex::Literal("operator="), operator_6953, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_6937), Reflex::Literal("assign"), method_6954, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6939), Reflex::Literal("begin"), method_6955, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6941), Reflex::Literal("begin"), method_6956, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6939), Reflex::Literal("end"), method_6957, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6941), Reflex::Literal("end"), method_6958, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_6963, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_6964, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_1519), Reflex::Literal("resize"), method_6965, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_6966, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_6967, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_6968, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6935, type_5015), Reflex::Literal("operator[]"), operator_6969, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6937, type_5015), Reflex::Literal("operator[]"), operator_6970, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6935, type_5015), Reflex::Literal("at"), method_6972, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6937, type_5015), Reflex::Literal("at"), method_6973, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6935), Reflex::Literal("front"), method_6974, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6937), Reflex::Literal("front"), method_6975, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6935), Reflex::Literal("back"), method_6976, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6937), Reflex::Literal("back"), method_6977, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6931), Reflex::Literal("data"), method_6978, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6933), Reflex::Literal("data"), method_6979, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_6937), Reflex::Literal("push_back"), method_6980, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_6981, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6939, type_6939, type_6937), Reflex::Literal("insert"), method_6982, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_6939, type_5015, type_6937), Reflex::Literal("insert"), method_6983, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6939, type_6939), Reflex::Literal("erase"), method_6984, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6939, type_6939, type_6939), Reflex::Literal("erase"), method_6985, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45946), Reflex::Literal("swap"), method_6986, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_6987, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class PATPairFinalStateT<pat::Muon,pat::Jet> -------------------------------
static  void operator_7096( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATPairFinalStateT<pat::Muon,pat::Jet>*)o)->operator=)(*(const ::PATPairFinalStateT<pat::Muon,pat::Jet>*)arg[0]);
  else   (((::PATPairFinalStateT<pat::Muon,pat::Jet>*)o)->operator=)(*(const ::PATPairFinalStateT<pat::Muon,pat::Jet>*)arg[0]);
}

static void constructor_7097( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATPairFinalStateT<pat::Muon,pat::Jet>(*(const ::PATPairFinalStateT<pat::Muon,pat::Jet>*)arg[0]);
  else ::new(mem) ::PATPairFinalStateT<pat::Muon,pat::Jet>(*(const ::PATPairFinalStateT<pat::Muon,pat::Jet>*)arg[0]);
}

static void constructor_7098( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATPairFinalStateT<pat::Muon,pat::Jet>();
  else ::new(mem) ::PATPairFinalStateT<pat::Muon,pat::Jet>();
}

static void constructor_7099( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATPairFinalStateT<pat::Muon,pat::Jet>(*(const ::edm::Ptr<pat::Muon>*)arg[0],
      *(const ::edm::Ptr<pat::Jet>*)arg[1],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[2]);
  else ::new(mem) ::PATPairFinalStateT<pat::Muon,pat::Jet>(*(const ::edm::Ptr<pat::Muon>*)arg[0],
      *(const ::edm::Ptr<pat::Jet>*)arg[1],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[2]);
}

static  void method_7100( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATPairFinalStateT<pat::Muon,pat::Jet>*)o)->clone)());
  else   (((const ::PATPairFinalStateT<pat::Muon,pat::Jet>*)o)->clone)();
}

static  void method_7101( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATPairFinalStateT<pat::Muon,pat::Jet>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATPairFinalStateT<pat::Muon,pat::Jet>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_7102( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATPairFinalStateT<pat::Muon,pat::Jet>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATPairFinalStateT<pat::Muon,pat::Jet>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_7103( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATPairFinalStateT<pat::Muon,pat::Jet>*)o)->numberOfDaughters)());
  else   (((const ::PATPairFinalStateT<pat::Muon,pat::Jet>*)o)->numberOfDaughters)();
}

static  void method_7104( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATPairFinalStateT<pat::Muon,pat::Jet>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATPairFinalStateT<pat::Muon,pat::Jet>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_7105( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATPairFinalStateT<pat::Muon,pat::Jet>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATPairFinalStateT<pat::Muon,pat::Jet>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_7106(void*, void * o, const std::vector<void*>&, void *) {
(((::PATPairFinalStateT<pat::Muon,pat::Jet>*)o)->::PATPairFinalStateT<pat::Muon,pat::Jet>::~PATPairFinalStateT)();
}
static void method_newdel_288( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Muon,pat::Jet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Muon,pat::Jet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Muon,pat::Jet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Muon,pat::Jet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Muon,pat::Jet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x41( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Muon,pat::Jet>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Muon,pat::Jet>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Muon,pat::Jet>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Muon,pat::Jet>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATPairFinalStateT<pat::Muon,pat::Jet> -------------------------------
void __PATPairFinalStateT_pat__Muon_pat__Jet__db_datamem(Reflex::Class*);
void __PATPairFinalStateT_pat__Muon_pat__Jet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATPairFinalStateT_pat__Muon_pat__Jet__datamem_bld(&__PATPairFinalStateT_pat__Muon_pat__Jet__db_datamem);
Reflex::GenreflexMemberBuilder __PATPairFinalStateT_pat__Muon_pat__Jet__funcmem_bld(&__PATPairFinalStateT_pat__Muon_pat__Jet__db_funcmem);
void __PATPairFinalStateT_pat__Muon_pat__Jet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATPairFinalStateT<pat::Muon,pat::Jet>"), typeid(::PATPairFinalStateT<pat::Muon,pat::Jet>), sizeof(::PATPairFinalStateT<pat::Muon,pat::Jet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Muon,pat::Jet>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6497, Reflex::Literal("PATPairFinalStateT<pat::Muon,pat::Jet>::daughter1_type"))
  .AddTypedef(type_7094, Reflex::Literal("PATPairFinalStateT<pat::Muon,pat::Jet>::daughter2_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13619, type_13621), Reflex::Literal("operator="), operator_7096, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13621), Reflex::Literal("PATPairFinalStateT"), constructor_7097, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATPairFinalStateT"), constructor_7098, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45727, type_46161, type_45406), Reflex::Literal("PATPairFinalStateT"), constructor_7099, 0, "p1;p2;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATPairFinalStateT"), destructor_7106, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_288, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x41, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATPairFinalStateT_pat__Muon_pat__Jet__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATPairFinalStateT_pat__Muon_pat__Jet__funcmem_bld);
}

//------Delayed data member builder for class PATPairFinalStateT<pat::Muon,pat::Jet> -------------------
void __PATPairFinalStateT_pat__Muon_pat__Jet__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9782, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATPairFinalStateT_pat__Muon_pat__Jet_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9781, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATPairFinalStateT_pat__Muon_pat__Jet_, p2_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATPairFinalStateT<pat::Muon,pat::Jet> -------------------
void __PATPairFinalStateT_pat__Muon_pat__Jet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13615), Reflex::Literal("clone"), method_7100, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_7101, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_7102, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_7103, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_7104, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_7105, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> -------------------------------
static  void operator_7137( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*)o)->operator=)(*(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*)arg[0]);
  else   (((::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*)o)->operator=)(*(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*)arg[0]);
}

static void constructor_7138( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>(*(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*)arg[0]);
  else ::new(mem) ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>(*(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*)arg[0]);
}

static void constructor_7139( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>();
  else ::new(mem) ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>();
}

static void constructor_7140( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>(*(const ::edm::Ptr<pat::Muon>*)arg[0],
      *(const ::edm::Ptr<pat::Muon>*)arg[1],
      *(const ::edm::Ptr<pat::Muon>*)arg[2],
      *(const ::edm::Ptr<pat::Tau>*)arg[3],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[4]);
  else ::new(mem) ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>(*(const ::edm::Ptr<pat::Muon>*)arg[0],
      *(const ::edm::Ptr<pat::Muon>*)arg[1],
      *(const ::edm::Ptr<pat::Muon>*)arg[2],
      *(const ::edm::Ptr<pat::Tau>*)arg[3],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[4]);
}

static  void method_7141( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*)o)->clone)());
  else   (((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*)o)->clone)();
}

static  void method_7142( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_7143( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_7144( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*)o)->numberOfDaughters)());
  else   (((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*)o)->numberOfDaughters)();
}

static  void method_7145( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_7146( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_7147(void*, void * o, const std::vector<void*>&, void *) {
(((::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*)o)->::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>::~PATQuadFinalStateT)();
}
static void method_newdel_308( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x43( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> -------------------------------
void __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau__db_datamem(Reflex::Class*);
void __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau__datamem_bld(&__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau__db_datamem);
Reflex::GenreflexMemberBuilder __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau__funcmem_bld(&__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau__db_funcmem);
void __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>"), typeid(::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>), sizeof(::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6497, Reflex::Literal("PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>::daughter1_type"))
  .AddTypedef(type_6497, Reflex::Literal("PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>::daughter2_type"))
  .AddTypedef(type_6497, Reflex::Literal("PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>::daughter3_type"))
  .AddTypedef(type_7135, Reflex::Literal("PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>::daughter4_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11955, type_11957), Reflex::Literal("operator="), operator_7137, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11957), Reflex::Literal("PATQuadFinalStateT"), constructor_7138, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATQuadFinalStateT"), constructor_7139, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45727, type_45727, type_45727, type_46321, type_45406), Reflex::Literal("PATQuadFinalStateT"), constructor_7140, 0, "p1;p2;p3;p4;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATQuadFinalStateT"), destructor_7147, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_308, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x43, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau__funcmem_bld);
}

//------Delayed data member builder for class PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> -------------------
void __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9782, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9782, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_, p2_), ::Reflex::PRIVATE)
  .AddDataMember(type_9782, Reflex::Literal("p3_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_, p3_), ::Reflex::PRIVATE)
  .AddDataMember(type_9787, Reflex::Literal("p4_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_, p4_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> -------------------
void __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11951), Reflex::Literal("clone"), method_7141, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_7142, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_7143, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_7144, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_7145, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_7146, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class PATPairFinalStateT<pat::Tau,pat::Tau> -------------------------------
static  void operator_7178( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATPairFinalStateT<pat::Tau,pat::Tau>*)o)->operator=)(*(const ::PATPairFinalStateT<pat::Tau,pat::Tau>*)arg[0]);
  else   (((::PATPairFinalStateT<pat::Tau,pat::Tau>*)o)->operator=)(*(const ::PATPairFinalStateT<pat::Tau,pat::Tau>*)arg[0]);
}

static void constructor_7179( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATPairFinalStateT<pat::Tau,pat::Tau>(*(const ::PATPairFinalStateT<pat::Tau,pat::Tau>*)arg[0]);
  else ::new(mem) ::PATPairFinalStateT<pat::Tau,pat::Tau>(*(const ::PATPairFinalStateT<pat::Tau,pat::Tau>*)arg[0]);
}

static void constructor_7180( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATPairFinalStateT<pat::Tau,pat::Tau>();
  else ::new(mem) ::PATPairFinalStateT<pat::Tau,pat::Tau>();
}

static void constructor_7181( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATPairFinalStateT<pat::Tau,pat::Tau>(*(const ::edm::Ptr<pat::Tau>*)arg[0],
      *(const ::edm::Ptr<pat::Tau>*)arg[1],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[2]);
  else ::new(mem) ::PATPairFinalStateT<pat::Tau,pat::Tau>(*(const ::edm::Ptr<pat::Tau>*)arg[0],
      *(const ::edm::Ptr<pat::Tau>*)arg[1],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[2]);
}

static  void method_7182( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATPairFinalStateT<pat::Tau,pat::Tau>*)o)->clone)());
  else   (((const ::PATPairFinalStateT<pat::Tau,pat::Tau>*)o)->clone)();
}

static  void method_7183( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATPairFinalStateT<pat::Tau,pat::Tau>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATPairFinalStateT<pat::Tau,pat::Tau>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_7184( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATPairFinalStateT<pat::Tau,pat::Tau>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATPairFinalStateT<pat::Tau,pat::Tau>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_7185( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATPairFinalStateT<pat::Tau,pat::Tau>*)o)->numberOfDaughters)());
  else   (((const ::PATPairFinalStateT<pat::Tau,pat::Tau>*)o)->numberOfDaughters)();
}

static  void method_7186( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATPairFinalStateT<pat::Tau,pat::Tau>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATPairFinalStateT<pat::Tau,pat::Tau>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_7187( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATPairFinalStateT<pat::Tau,pat::Tau>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATPairFinalStateT<pat::Tau,pat::Tau>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_7188(void*, void * o, const std::vector<void*>&, void *) {
(((::PATPairFinalStateT<pat::Tau,pat::Tau>*)o)->::PATPairFinalStateT<pat::Tau,pat::Tau>::~PATPairFinalStateT)();
}
static void method_newdel_334( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Tau,pat::Tau> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Tau,pat::Tau> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Tau,pat::Tau> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Tau,pat::Tau> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Tau,pat::Tau> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x45( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Tau,pat::Tau>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Tau,pat::Tau>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Tau,pat::Tau>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Tau,pat::Tau>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATPairFinalStateT<pat::Tau,pat::Tau> -------------------------------
void __PATPairFinalStateT_pat__Tau_pat__Tau__db_datamem(Reflex::Class*);
void __PATPairFinalStateT_pat__Tau_pat__Tau__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATPairFinalStateT_pat__Tau_pat__Tau__datamem_bld(&__PATPairFinalStateT_pat__Tau_pat__Tau__db_datamem);
Reflex::GenreflexMemberBuilder __PATPairFinalStateT_pat__Tau_pat__Tau__funcmem_bld(&__PATPairFinalStateT_pat__Tau_pat__Tau__db_funcmem);
void __PATPairFinalStateT_pat__Tau_pat__Tau__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATPairFinalStateT<pat::Tau,pat::Tau>"), typeid(::PATPairFinalStateT<pat::Tau,pat::Tau>), sizeof(::PATPairFinalStateT<pat::Tau,pat::Tau>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Tau,pat::Tau>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_7135, Reflex::Literal("PATPairFinalStateT<pat::Tau,pat::Tau>::daughter1_type"))
  .AddTypedef(type_7135, Reflex::Literal("PATPairFinalStateT<pat::Tau,pat::Tau>::daughter2_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19147, type_19149), Reflex::Literal("operator="), operator_7178, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19149), Reflex::Literal("PATPairFinalStateT"), constructor_7179, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATPairFinalStateT"), constructor_7180, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_46321, type_46321, type_45406), Reflex::Literal("PATPairFinalStateT"), constructor_7181, 0, "p1;p2;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATPairFinalStateT"), destructor_7188, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_334, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x45, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATPairFinalStateT_pat__Tau_pat__Tau__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATPairFinalStateT_pat__Tau_pat__Tau__funcmem_bld);
}

//------Delayed data member builder for class PATPairFinalStateT<pat::Tau,pat::Tau> -------------------
void __PATPairFinalStateT_pat__Tau_pat__Tau__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9787, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATPairFinalStateT_pat__Tau_pat__Tau_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9787, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATPairFinalStateT_pat__Tau_pat__Tau_, p2_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATPairFinalStateT<pat::Tau,pat::Tau> -------------------
void __PATPairFinalStateT_pat__Tau_pat__Tau__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19143), Reflex::Literal("clone"), method_7182, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_7183, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_7184, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_7185, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_7186, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_7187, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class PATPairFinalStateT<pat::Electron,pat::Jet> -------------------------------
static  void operator_12696( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATPairFinalStateT<pat::Electron,pat::Jet>*)o)->operator=)(*(const ::PATPairFinalStateT<pat::Electron,pat::Jet>*)arg[0]);
  else   (((::PATPairFinalStateT<pat::Electron,pat::Jet>*)o)->operator=)(*(const ::PATPairFinalStateT<pat::Electron,pat::Jet>*)arg[0]);
}

static void constructor_12697( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATPairFinalStateT<pat::Electron,pat::Jet>(*(const ::PATPairFinalStateT<pat::Electron,pat::Jet>*)arg[0]);
  else ::new(mem) ::PATPairFinalStateT<pat::Electron,pat::Jet>(*(const ::PATPairFinalStateT<pat::Electron,pat::Jet>*)arg[0]);
}

static void constructor_12698( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATPairFinalStateT<pat::Electron,pat::Jet>();
  else ::new(mem) ::PATPairFinalStateT<pat::Electron,pat::Jet>();
}

static void constructor_12699( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATPairFinalStateT<pat::Electron,pat::Jet>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Jet>*)arg[1],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[2]);
  else ::new(mem) ::PATPairFinalStateT<pat::Electron,pat::Jet>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Jet>*)arg[1],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[2]);
}

static  void method_12700( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATPairFinalStateT<pat::Electron,pat::Jet>*)o)->clone)());
  else   (((const ::PATPairFinalStateT<pat::Electron,pat::Jet>*)o)->clone)();
}

static  void method_12701( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATPairFinalStateT<pat::Electron,pat::Jet>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATPairFinalStateT<pat::Electron,pat::Jet>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_12702( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATPairFinalStateT<pat::Electron,pat::Jet>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATPairFinalStateT<pat::Electron,pat::Jet>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_12703( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATPairFinalStateT<pat::Electron,pat::Jet>*)o)->numberOfDaughters)());
  else   (((const ::PATPairFinalStateT<pat::Electron,pat::Jet>*)o)->numberOfDaughters)();
}

static  void method_12704( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATPairFinalStateT<pat::Electron,pat::Jet>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATPairFinalStateT<pat::Electron,pat::Jet>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_12705( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATPairFinalStateT<pat::Electron,pat::Jet>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATPairFinalStateT<pat::Electron,pat::Jet>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_12706(void*, void * o, const std::vector<void*>&, void *) {
(((::PATPairFinalStateT<pat::Electron,pat::Jet>*)o)->::PATPairFinalStateT<pat::Electron,pat::Jet>::~PATPairFinalStateT)();
}
static void method_newdel_1593( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Electron,pat::Jet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Electron,pat::Jet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Electron,pat::Jet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Electron,pat::Jet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Electron,pat::Jet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x47( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Electron,pat::Jet>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Electron,pat::Jet>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Electron,pat::Jet>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Electron,pat::Jet>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATPairFinalStateT<pat::Electron,pat::Jet> -------------------------------
void __PATPairFinalStateT_pat__Electron_pat__Jet__db_datamem(Reflex::Class*);
void __PATPairFinalStateT_pat__Electron_pat__Jet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATPairFinalStateT_pat__Electron_pat__Jet__datamem_bld(&__PATPairFinalStateT_pat__Electron_pat__Jet__db_datamem);
Reflex::GenreflexMemberBuilder __PATPairFinalStateT_pat__Electron_pat__Jet__funcmem_bld(&__PATPairFinalStateT_pat__Electron_pat__Jet__db_funcmem);
void __PATPairFinalStateT_pat__Electron_pat__Jet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATPairFinalStateT<pat::Electron,pat::Jet>"), typeid(::PATPairFinalStateT<pat::Electron,pat::Jet>), sizeof(::PATPairFinalStateT<pat::Electron,pat::Jet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Electron,pat::Jet>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6476, Reflex::Literal("PATPairFinalStateT<pat::Electron,pat::Jet>::daughter1_type"))
  .AddTypedef(type_7094, Reflex::Literal("PATPairFinalStateT<pat::Electron,pat::Jet>::daughter2_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7353, type_7355), Reflex::Literal("operator="), operator_12696, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7355), Reflex::Literal("PATPairFinalStateT"), constructor_12697, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATPairFinalStateT"), constructor_12698, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45636, type_46161, type_45406), Reflex::Literal("PATPairFinalStateT"), constructor_12699, 0, "p1;p2;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATPairFinalStateT"), destructor_12706, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1593, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x47, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATPairFinalStateT_pat__Electron_pat__Jet__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATPairFinalStateT_pat__Electron_pat__Jet__funcmem_bld);
}

//------Delayed data member builder for class PATPairFinalStateT<pat::Electron,pat::Jet> -------------------
void __PATPairFinalStateT_pat__Electron_pat__Jet__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9785, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATPairFinalStateT_pat__Electron_pat__Jet_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9781, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATPairFinalStateT_pat__Electron_pat__Jet_, p2_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATPairFinalStateT<pat::Electron,pat::Jet> -------------------
void __PATPairFinalStateT_pat__Electron_pat__Jet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7349), Reflex::Literal("clone"), method_12700, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_12701, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_12702, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_12703, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_12704, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_12705, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class vector<PATPairFinalStateT<pat::Electron, pat::Jet>,std::allocator<PATPairFinalStateT<pat::Electron, pat::Jet> > > -------------------------------
static void constructor_7366( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >();
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >();
}

static void constructor_7367( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >(*(const ::std::allocator<PATPairFinalStateT<pat::Electron,pat::Jet> >*)arg[0]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >(*(const ::std::allocator<PATPairFinalStateT<pat::Electron,pat::Jet> >*)arg[0]);
}

static void constructor_7368( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Electron,pat::Jet>*)arg[1]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Electron,pat::Jet>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Electron,pat::Jet>*)arg[1],
      *(const ::std::allocator<PATPairFinalStateT<pat::Electron,pat::Jet> >*)arg[2]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Electron,pat::Jet>*)arg[1],
      *(const ::std::allocator<PATPairFinalStateT<pat::Electron,pat::Jet> >*)arg[2]);
  }
}

static void constructor_7369( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >(*(const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)arg[0]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >(*(const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)arg[0]);
}

static void destructor_7370(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >::~vector)();
}
static  void operator_7371( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->operator=)(*(const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)arg[0]);
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->operator=)(*(const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)arg[0]);
}

static  void method_7372( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATPairFinalStateT<pat::Electron,pat::Jet>*)arg[1]);
}

static  void method_7373( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Jet>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >)((((::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->begin)());
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->begin)();
}

static  void method_7374( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Electron,pat::Jet>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >)((((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->begin)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->begin)();
}

static  void method_7375( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Jet>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >)((((::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->end)());
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->end)();
}

static  void method_7376( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Electron,pat::Jet>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >)((((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->end)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->end)();
}

static  void method_7381( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->size)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->size)();
}

static  void method_7382( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->max_size)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->max_size)();
}

static  void method_7383( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATPairFinalStateT<pat::Electron,pat::Jet>*)arg[1]);
  }
}

static  void method_7384( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->capacity)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->capacity)();
}

static  void method_7385( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->empty)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->empty)();
}

static  void method_7386( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_7387( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_7388( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_7390( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_7391( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_7392( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->front)();
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->front)();
}

static  void method_7393( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->front)();
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->front)();
}

static  void method_7394( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->back)();
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->back)();
}

static  void method_7395( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->back)();
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->back)();
}

static  void method_7396( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->data)());
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->data)();
}

static  void method_7397( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->data)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->data)();
}

static  void method_7398( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->push_back)(*(const ::PATPairFinalStateT<pat::Electron,pat::Jet>*)arg[0]);
}

static  void method_7399( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->pop_back)();
}

static  void method_7400( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Jet>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >)((((::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Jet>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >*)arg[0],
    *(const ::PATPairFinalStateT<pat::Electron,pat::Jet>*)arg[1]));
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Jet>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >*)arg[0],
    *(const ::PATPairFinalStateT<pat::Electron,pat::Jet>*)arg[1]);
}

static  void method_7401( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Jet>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATPairFinalStateT<pat::Electron,pat::Jet>*)arg[2]);
}

static  void method_7402( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Jet>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >)((((::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Jet>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >*)arg[0]));
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Jet>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >*)arg[0]);
}

static  void method_7403( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Jet>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >)((((::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Jet>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Jet>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >*)arg[1]));
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Jet>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Jet>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >*)arg[1]);
}

static  void method_7404( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->swap)(*(::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)arg[0]);
}

static  void method_7405( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->clear)();
}

static void method_newdel_444( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x49( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATPairFinalStateT<pat::Electron,pat::Jet>,std::allocator<PATPairFinalStateT<pat::Electron,pat::Jet> > >")), ::Reflex::BaseOffset< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >,::std::_Vector_base<PATPairFinalStateT<pat::Electron,pat::Jet>,std::allocator<PATPairFinalStateT<pat::Electron,pat::Jet> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x50( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >::Generate();
}

//------Dictionary for class vector<PATPairFinalStateT<pat::Electron, pat::Jet>,std::allocator<PATPairFinalStateT<pat::Electron, pat::Jet> > > -------------------------------
void __std__vector_PATPairFinalStateT_pat__Electron_pat__Jet_s__db_datamem(Reflex::Class*);
void __std__vector_PATPairFinalStateT_pat__Electron_pat__Jet_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATPairFinalStateT_pat__Electron_pat__Jet_s__datamem_bld(&__std__vector_PATPairFinalStateT_pat__Electron_pat__Jet_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATPairFinalStateT_pat__Electron_pat__Jet_s__funcmem_bld(&__std__vector_PATPairFinalStateT_pat__Electron_pat__Jet_s__db_funcmem);
void __std__vector_PATPairFinalStateT_pat__Electron_pat__Jet_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >"), typeid(::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >), sizeof(::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3720, ::Reflex::BaseOffset< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >, ::std::_Vector_base<PATPairFinalStateT<pat::Electron,pat::Jet>,std::allocator<PATPairFinalStateT<pat::Electron,pat::Jet> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1593, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >::_Alloc_value_type"))
  .AddTypedef(type_3720, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >::_Base"))
  .AddTypedef(type_5075, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >::_Tp_alloc_type"))
  .AddTypedef(type_1593, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >::value_type"))
  .AddTypedef(type_7349, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >::pointer"))
  .AddTypedef(type_7351, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >::const_pointer"))
  .AddTypedef(type_7353, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >::reference"))
  .AddTypedef(type_7355, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >::const_reference"))
  .AddTypedef(type_7357, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >::iterator"))
  .AddTypedef(type_7359, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >::const_iterator"))
  .AddTypedef(type_5693, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >::const_reverse_iterator"))
  .AddTypedef(type_5694, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >::difference_type"))
  .AddTypedef(type_5075, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_7366, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_46348), Reflex::Literal("vector"), constructor_7367, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_7355, type_46348), Reflex::Literal("vector"), constructor_7368, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_46349), Reflex::Literal("vector"), constructor_7369, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_7370, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_444, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x49, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x50, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATPairFinalStateT_pat__Electron_pat__Jet_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATPairFinalStateT<pat::Electron, pat::Jet>,std::allocator<PATPairFinalStateT<pat::Electron, pat::Jet> > > -------------------
void __std__vector_PATPairFinalStateT_pat__Electron_pat__Jet_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATPairFinalStateT<pat::Electron, pat::Jet>,std::allocator<PATPairFinalStateT<pat::Electron, pat::Jet> > > -------------------
void __std__vector_PATPairFinalStateT_pat__Electron_pat__Jet_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46350, type_46349), Reflex::Literal("operator="), operator_7371, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_7355), Reflex::Literal("assign"), method_7372, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7357), Reflex::Literal("begin"), method_7373, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7359), Reflex::Literal("begin"), method_7374, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7357), Reflex::Literal("end"), method_7375, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7359), Reflex::Literal("end"), method_7376, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_7381, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_7382, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_1593), Reflex::Literal("resize"), method_7383, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_7384, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_7385, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_7386, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7353, type_5015), Reflex::Literal("operator[]"), operator_7387, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7355, type_5015), Reflex::Literal("operator[]"), operator_7388, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7353, type_5015), Reflex::Literal("at"), method_7390, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7355, type_5015), Reflex::Literal("at"), method_7391, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7353), Reflex::Literal("front"), method_7392, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7355), Reflex::Literal("front"), method_7393, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7353), Reflex::Literal("back"), method_7394, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7355), Reflex::Literal("back"), method_7395, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7349), Reflex::Literal("data"), method_7396, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7351), Reflex::Literal("data"), method_7397, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_7355), Reflex::Literal("push_back"), method_7398, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_7399, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7357, type_7357, type_7355), Reflex::Literal("insert"), method_7400, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_7357, type_5015, type_7355), Reflex::Literal("insert"), method_7401, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7357, type_7357), Reflex::Literal("erase"), method_7402, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7357, type_7357, type_7357), Reflex::Literal("erase"), method_7403, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_46350), Reflex::Literal("swap"), method_7404, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_7405, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> -------------------------------
static  void operator_7646( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*)o)->operator=)(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*)arg[0]);
  else   (((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*)o)->operator=)(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*)arg[0]);
}

static void constructor_7647( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*)arg[0]);
  else ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*)arg[0]);
}

static void constructor_7648( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>();
  else ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>();
}

static void constructor_7649( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Electron>*)arg[1],
      *(const ::edm::Ptr<pat::Photon>*)arg[2],
      *(const ::edm::Ptr<pat::Photon>*)arg[3],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[4]);
  else ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Electron>*)arg[1],
      *(const ::edm::Ptr<pat::Photon>*)arg[2],
      *(const ::edm::Ptr<pat::Photon>*)arg[3],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[4]);
}

static  void method_7650( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*)o)->clone)());
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*)o)->clone)();
}

static  void method_7651( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_7652( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_7653( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*)o)->numberOfDaughters)());
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*)o)->numberOfDaughters)();
}

static  void method_7654( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_7655( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_7656(void*, void * o, const std::vector<void*>&, void *) {
(((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*)o)->::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>::~PATQuadFinalStateT)();
}
static void method_newdel_473( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x52( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> -------------------------------
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon__db_datamem(Reflex::Class*);
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon__datamem_bld(&__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon__db_datamem);
Reflex::GenreflexMemberBuilder __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon__funcmem_bld(&__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon__db_funcmem);
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>"), typeid(::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>), sizeof(::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6476, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>::daughter1_type"))
  .AddTypedef(type_6476, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>::daughter2_type"))
  .AddTypedef(type_6478, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>::daughter3_type"))
  .AddTypedef(type_6478, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>::daughter4_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10029, type_10031), Reflex::Literal("operator="), operator_7646, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10031), Reflex::Literal("PATQuadFinalStateT"), constructor_7647, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATQuadFinalStateT"), constructor_7648, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45636, type_45636, type_45637, type_45637, type_45406), Reflex::Literal("PATQuadFinalStateT"), constructor_7649, 0, "p1;p2;p3;p4;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATQuadFinalStateT"), destructor_7656, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_473, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x52, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon__funcmem_bld);
}

//------Delayed data member builder for class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> -------------------
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9785, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9785, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_, p2_), ::Reflex::PRIVATE)
  .AddDataMember(type_9786, Reflex::Literal("p3_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_, p3_), ::Reflex::PRIVATE)
  .AddDataMember(type_9786, Reflex::Literal("p4_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_, p4_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> -------------------
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10025), Reflex::Literal("clone"), method_7650, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_7651, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_7652, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_7653, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_7654, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_7655, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class vector<PATFinalStateEvent,std::allocator<PATFinalStateEvent> > -------------------------------
static void constructor_7680( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATFinalStateEvent>();
  else ::new(mem) ::std::vector<PATFinalStateEvent>();
}

static void constructor_7681( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATFinalStateEvent>(*(const ::std::allocator<PATFinalStateEvent>*)arg[0]);
  else ::new(mem) ::std::vector<PATFinalStateEvent>(*(const ::std::allocator<PATFinalStateEvent>*)arg[0]);
}

static void constructor_7682( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATFinalStateEvent>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATFinalStateEvent>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATFinalStateEvent>(*(::std::size_t*)arg[0],
      *(const ::PATFinalStateEvent*)arg[1]);
  else ::new(mem) ::std::vector<PATFinalStateEvent>(*(::std::size_t*)arg[0],
      *(const ::PATFinalStateEvent*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATFinalStateEvent>(*(::std::size_t*)arg[0],
      *(const ::PATFinalStateEvent*)arg[1],
      *(const ::std::allocator<PATFinalStateEvent>*)arg[2]);
  else ::new(mem) ::std::vector<PATFinalStateEvent>(*(::std::size_t*)arg[0],
      *(const ::PATFinalStateEvent*)arg[1],
      *(const ::std::allocator<PATFinalStateEvent>*)arg[2]);
  }
}

static void constructor_7683( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATFinalStateEvent>(*(const ::std::vector<PATFinalStateEvent>*)arg[0]);
  else ::new(mem) ::std::vector<PATFinalStateEvent>(*(const ::std::vector<PATFinalStateEvent>*)arg[0]);
}

static void destructor_7684(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATFinalStateEvent>*)o)->::std::vector<PATFinalStateEvent>::~vector)();
}
static  void operator_7685( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATFinalStateEvent>*)o)->operator=)(*(const ::std::vector<PATFinalStateEvent>*)arg[0]);
  else   (((::std::vector<PATFinalStateEvent>*)o)->operator=)(*(const ::std::vector<PATFinalStateEvent>*)arg[0]);
}

static  void method_7686( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATFinalStateEvent>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATFinalStateEvent*)arg[1]);
}

static  void method_7687( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATFinalStateEvent*,std::vector<PATFinalStateEvent> >)((((::std::vector<PATFinalStateEvent>*)o)->begin)());
  else   (((::std::vector<PATFinalStateEvent>*)o)->begin)();
}

static  void method_7688( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATFinalStateEvent*,std::vector<PATFinalStateEvent> >)((((const ::std::vector<PATFinalStateEvent>*)o)->begin)());
  else   (((const ::std::vector<PATFinalStateEvent>*)o)->begin)();
}

static  void method_7689( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATFinalStateEvent*,std::vector<PATFinalStateEvent> >)((((::std::vector<PATFinalStateEvent>*)o)->end)());
  else   (((::std::vector<PATFinalStateEvent>*)o)->end)();
}

static  void method_7690( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATFinalStateEvent*,std::vector<PATFinalStateEvent> >)((((const ::std::vector<PATFinalStateEvent>*)o)->end)());
  else   (((const ::std::vector<PATFinalStateEvent>*)o)->end)();
}

static  void method_7695( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATFinalStateEvent>*)o)->size)());
  else   (((const ::std::vector<PATFinalStateEvent>*)o)->size)();
}

static  void method_7696( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATFinalStateEvent>*)o)->max_size)());
  else   (((const ::std::vector<PATFinalStateEvent>*)o)->max_size)();
}

static  void method_7697( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATFinalStateEvent>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATFinalStateEvent>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATFinalStateEvent*)arg[1]);
  }
}

static  void method_7698( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATFinalStateEvent>*)o)->capacity)());
  else   (((const ::std::vector<PATFinalStateEvent>*)o)->capacity)();
}

static  void method_7699( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATFinalStateEvent>*)o)->empty)());
  else   (((const ::std::vector<PATFinalStateEvent>*)o)->empty)();
}

static  void method_7700( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATFinalStateEvent>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_7701( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATFinalStateEvent>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATFinalStateEvent>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_7702( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATFinalStateEvent>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATFinalStateEvent>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_7704( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATFinalStateEvent>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATFinalStateEvent>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_7705( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATFinalStateEvent>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATFinalStateEvent>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_7706( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATFinalStateEvent>*)o)->front)();
  else   (((::std::vector<PATFinalStateEvent>*)o)->front)();
}

static  void method_7707( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATFinalStateEvent>*)o)->front)();
  else   (((const ::std::vector<PATFinalStateEvent>*)o)->front)();
}

static  void method_7708( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATFinalStateEvent>*)o)->back)();
  else   (((::std::vector<PATFinalStateEvent>*)o)->back)();
}

static  void method_7709( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATFinalStateEvent>*)o)->back)();
  else   (((const ::std::vector<PATFinalStateEvent>*)o)->back)();
}

static  void method_7710( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATFinalStateEvent>*)o)->data)());
  else   (((::std::vector<PATFinalStateEvent>*)o)->data)();
}

static  void method_7711( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATFinalStateEvent>*)o)->data)());
  else   (((const ::std::vector<PATFinalStateEvent>*)o)->data)();
}

static  void method_7712( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATFinalStateEvent>*)o)->push_back)(*(const ::PATFinalStateEvent*)arg[0]);
}

static  void method_7713( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATFinalStateEvent>*)o)->pop_back)();
}

static  void method_7714( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATFinalStateEvent*,std::vector<PATFinalStateEvent> >)((((::std::vector<PATFinalStateEvent>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATFinalStateEvent*,std::vector<PATFinalStateEvent> >*)arg[0],
    *(const ::PATFinalStateEvent*)arg[1]));
  else   (((::std::vector<PATFinalStateEvent>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATFinalStateEvent*,std::vector<PATFinalStateEvent> >*)arg[0],
    *(const ::PATFinalStateEvent*)arg[1]);
}

static  void method_7715( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATFinalStateEvent>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATFinalStateEvent*,std::vector<PATFinalStateEvent> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATFinalStateEvent*)arg[2]);
}

static  void method_7716( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATFinalStateEvent*,std::vector<PATFinalStateEvent> >)((((::std::vector<PATFinalStateEvent>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATFinalStateEvent*,std::vector<PATFinalStateEvent> >*)arg[0]));
  else   (((::std::vector<PATFinalStateEvent>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATFinalStateEvent*,std::vector<PATFinalStateEvent> >*)arg[0]);
}

static  void method_7717( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATFinalStateEvent*,std::vector<PATFinalStateEvent> >)((((::std::vector<PATFinalStateEvent>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATFinalStateEvent*,std::vector<PATFinalStateEvent> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATFinalStateEvent*,std::vector<PATFinalStateEvent> >*)arg[1]));
  else   (((::std::vector<PATFinalStateEvent>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATFinalStateEvent*,std::vector<PATFinalStateEvent> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATFinalStateEvent*,std::vector<PATFinalStateEvent> >*)arg[1]);
}

static  void method_7718( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATFinalStateEvent>*)o)->swap)(*(::std::vector<PATFinalStateEvent>*)arg[0]);
}

static  void method_7719( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATFinalStateEvent>*)o)->clear)();
}

static void method_newdel_480( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATFinalStateEvent> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATFinalStateEvent> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATFinalStateEvent> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATFinalStateEvent> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATFinalStateEvent> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x54( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATFinalStateEvent,std::allocator<PATFinalStateEvent> >")), ::Reflex::BaseOffset< ::std::vector<PATFinalStateEvent>,::std::_Vector_base<PATFinalStateEvent,std::allocator<PATFinalStateEvent> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x55( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATFinalStateEvent> >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATFinalStateEvent> >::Generate();
}

//------Dictionary for class vector<PATFinalStateEvent,std::allocator<PATFinalStateEvent> > -------------------------------
void __std__vector_PATFinalStateEvent__db_datamem(Reflex::Class*);
void __std__vector_PATFinalStateEvent__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATFinalStateEvent__datamem_bld(&__std__vector_PATFinalStateEvent__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATFinalStateEvent__funcmem_bld(&__std__vector_PATFinalStateEvent__db_funcmem);
void __std__vector_PATFinalStateEvent__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATFinalStateEvent>"), typeid(::std::vector<PATFinalStateEvent>), sizeof(::std::vector<PATFinalStateEvent>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3857, ::Reflex::BaseOffset< ::std::vector<PATFinalStateEvent>, ::std::_Vector_base<PATFinalStateEvent,std::allocator<PATFinalStateEvent> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_583, Reflex::Literal("std::vector<PATFinalStateEvent>::_Alloc_value_type"))
  .AddTypedef(type_3857, Reflex::Literal("std::vector<PATFinalStateEvent>::_Base"))
  .AddTypedef(type_5035, Reflex::Literal("std::vector<PATFinalStateEvent>::_Tp_alloc_type"))
  .AddTypedef(type_583, Reflex::Literal("std::vector<PATFinalStateEvent>::value_type"))
  .AddTypedef(type_7663, Reflex::Literal("std::vector<PATFinalStateEvent>::pointer"))
  .AddTypedef(type_7665, Reflex::Literal("std::vector<PATFinalStateEvent>::const_pointer"))
  .AddTypedef(type_7667, Reflex::Literal("std::vector<PATFinalStateEvent>::reference"))
  .AddTypedef(type_7669, Reflex::Literal("std::vector<PATFinalStateEvent>::const_reference"))
  .AddTypedef(type_7671, Reflex::Literal("std::vector<PATFinalStateEvent>::iterator"))
  .AddTypedef(type_7673, Reflex::Literal("std::vector<PATFinalStateEvent>::const_iterator"))
  .AddTypedef(type_5987, Reflex::Literal("std::vector<PATFinalStateEvent>::const_reverse_iterator"))
  .AddTypedef(type_5988, Reflex::Literal("std::vector<PATFinalStateEvent>::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATFinalStateEvent>::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATFinalStateEvent>::difference_type"))
  .AddTypedef(type_5035, Reflex::Literal("std::vector<PATFinalStateEvent>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_7680, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_46456), Reflex::Literal("vector"), constructor_7681, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_7669, type_46456), Reflex::Literal("vector"), constructor_7682, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45419), Reflex::Literal("vector"), constructor_7683, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_7684, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_480, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x54, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x55, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATFinalStateEvent__funcmem_bld);
}

//------Delayed data member builder for class vector<PATFinalStateEvent,std::allocator<PATFinalStateEvent> > -------------------
void __std__vector_PATFinalStateEvent__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATFinalStateEvent,std::allocator<PATFinalStateEvent> > -------------------
void __std__vector_PATFinalStateEvent__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_46457, type_45419), Reflex::Literal("operator="), operator_7685, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_7669), Reflex::Literal("assign"), method_7686, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7671), Reflex::Literal("begin"), method_7687, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7673), Reflex::Literal("begin"), method_7688, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7671), Reflex::Literal("end"), method_7689, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7673), Reflex::Literal("end"), method_7690, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_7695, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_7696, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_583), Reflex::Literal("resize"), method_7697, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_7698, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_7699, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_7700, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7667, type_5015), Reflex::Literal("operator[]"), operator_7701, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7669, type_5015), Reflex::Literal("operator[]"), operator_7702, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7667, type_5015), Reflex::Literal("at"), method_7704, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7669, type_5015), Reflex::Literal("at"), method_7705, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7667), Reflex::Literal("front"), method_7706, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7669), Reflex::Literal("front"), method_7707, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7667), Reflex::Literal("back"), method_7708, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7669), Reflex::Literal("back"), method_7709, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7663), Reflex::Literal("data"), method_7710, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7665), Reflex::Literal("data"), method_7711, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_7669), Reflex::Literal("push_back"), method_7712, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_7713, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7671, type_7671, type_7669), Reflex::Literal("insert"), method_7714, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_7671, type_5015, type_7669), Reflex::Literal("insert"), method_7715, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7671, type_7671), Reflex::Literal("erase"), method_7716, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7671, type_7671, type_7671), Reflex::Literal("erase"), method_7717, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_46457), Reflex::Literal("swap"), method_7718, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_7719, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> -------------------------------
static  void operator_7738( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*)o)->operator=)(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*)arg[0]);
  else   (((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*)o)->operator=)(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*)arg[0]);
}

static void constructor_7739( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*)arg[0]);
  else ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*)arg[0]);
}

static void constructor_7740( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>();
  else ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>();
}

static void constructor_7741( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Electron>*)arg[1],
      *(const ::edm::Ptr<pat::Electron>*)arg[2],
      *(const ::edm::Ptr<pat::Electron>*)arg[3],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[4]);
  else ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Electron>*)arg[1],
      *(const ::edm::Ptr<pat::Electron>*)arg[2],
      *(const ::edm::Ptr<pat::Electron>*)arg[3],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[4]);
}

static  void method_7742( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*)o)->clone)());
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*)o)->clone)();
}

static  void method_7743( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_7744( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_7745( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*)o)->numberOfDaughters)());
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*)o)->numberOfDaughters)();
}

static  void method_7746( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_7747( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_7748(void*, void * o, const std::vector<void*>&, void *) {
(((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*)o)->::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>::~PATQuadFinalStateT)();
}
static void method_newdel_505( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x57( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> -------------------------------
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron__db_datamem(Reflex::Class*);
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron__datamem_bld(&__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron__db_datamem);
Reflex::GenreflexMemberBuilder __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron__funcmem_bld(&__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron__db_funcmem);
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>"), typeid(::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>), sizeof(::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6476, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>::daughter1_type"))
  .AddTypedef(type_6476, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>::daughter2_type"))
  .AddTypedef(type_6476, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>::daughter3_type"))
  .AddTypedef(type_6476, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>::daughter4_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14246, type_14248), Reflex::Literal("operator="), operator_7738, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14248), Reflex::Literal("PATQuadFinalStateT"), constructor_7739, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATQuadFinalStateT"), constructor_7740, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45636, type_45636, type_45636, type_45636, type_45406), Reflex::Literal("PATQuadFinalStateT"), constructor_7741, 0, "p1;p2;p3;p4;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATQuadFinalStateT"), destructor_7748, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_505, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x57, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron__funcmem_bld);
}

//------Delayed data member builder for class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> -------------------
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9785, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9785, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_, p2_), ::Reflex::PRIVATE)
  .AddDataMember(type_9785, Reflex::Literal("p3_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_, p3_), ::Reflex::PRIVATE)
  .AddDataMember(type_9785, Reflex::Literal("p4_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_, p4_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> -------------------
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14242), Reflex::Literal("clone"), method_7742, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_7743, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_7744, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_7745, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_7746, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_7747, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class PATPairFinalStateT<pat::Electron,pat::Muon> -------------------------------
static  void operator_13730( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATPairFinalStateT<pat::Electron,pat::Muon>*)o)->operator=)(*(const ::PATPairFinalStateT<pat::Electron,pat::Muon>*)arg[0]);
  else   (((::PATPairFinalStateT<pat::Electron,pat::Muon>*)o)->operator=)(*(const ::PATPairFinalStateT<pat::Electron,pat::Muon>*)arg[0]);
}

static void constructor_13731( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATPairFinalStateT<pat::Electron,pat::Muon>(*(const ::PATPairFinalStateT<pat::Electron,pat::Muon>*)arg[0]);
  else ::new(mem) ::PATPairFinalStateT<pat::Electron,pat::Muon>(*(const ::PATPairFinalStateT<pat::Electron,pat::Muon>*)arg[0]);
}

static void constructor_13732( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATPairFinalStateT<pat::Electron,pat::Muon>();
  else ::new(mem) ::PATPairFinalStateT<pat::Electron,pat::Muon>();
}

static void constructor_13733( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATPairFinalStateT<pat::Electron,pat::Muon>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Muon>*)arg[1],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[2]);
  else ::new(mem) ::PATPairFinalStateT<pat::Electron,pat::Muon>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Muon>*)arg[1],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[2]);
}

static  void method_13734( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATPairFinalStateT<pat::Electron,pat::Muon>*)o)->clone)());
  else   (((const ::PATPairFinalStateT<pat::Electron,pat::Muon>*)o)->clone)();
}

static  void method_13735( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATPairFinalStateT<pat::Electron,pat::Muon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATPairFinalStateT<pat::Electron,pat::Muon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_13736( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATPairFinalStateT<pat::Electron,pat::Muon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATPairFinalStateT<pat::Electron,pat::Muon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_13737( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATPairFinalStateT<pat::Electron,pat::Muon>*)o)->numberOfDaughters)());
  else   (((const ::PATPairFinalStateT<pat::Electron,pat::Muon>*)o)->numberOfDaughters)();
}

static  void method_13738( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATPairFinalStateT<pat::Electron,pat::Muon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATPairFinalStateT<pat::Electron,pat::Muon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_13739( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATPairFinalStateT<pat::Electron,pat::Muon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATPairFinalStateT<pat::Electron,pat::Muon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_13740(void*, void * o, const std::vector<void*>&, void *) {
(((::PATPairFinalStateT<pat::Electron,pat::Muon>*)o)->::PATPairFinalStateT<pat::Electron,pat::Muon>::~PATPairFinalStateT)();
}
static void method_newdel_1888( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Electron,pat::Muon> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Electron,pat::Muon> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Electron,pat::Muon> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Electron,pat::Muon> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Electron,pat::Muon> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x59( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Electron,pat::Muon>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Electron,pat::Muon>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Electron,pat::Muon>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Electron,pat::Muon>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATPairFinalStateT<pat::Electron,pat::Muon> -------------------------------
void __PATPairFinalStateT_pat__Electron_pat__Muon__db_datamem(Reflex::Class*);
void __PATPairFinalStateT_pat__Electron_pat__Muon__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATPairFinalStateT_pat__Electron_pat__Muon__datamem_bld(&__PATPairFinalStateT_pat__Electron_pat__Muon__db_datamem);
Reflex::GenreflexMemberBuilder __PATPairFinalStateT_pat__Electron_pat__Muon__funcmem_bld(&__PATPairFinalStateT_pat__Electron_pat__Muon__db_funcmem);
void __PATPairFinalStateT_pat__Electron_pat__Muon__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATPairFinalStateT<pat::Electron,pat::Muon>"), typeid(::PATPairFinalStateT<pat::Electron,pat::Muon>), sizeof(::PATPairFinalStateT<pat::Electron,pat::Muon>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Electron,pat::Muon>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6476, Reflex::Literal("PATPairFinalStateT<pat::Electron,pat::Muon>::daughter1_type"))
  .AddTypedef(type_6497, Reflex::Literal("PATPairFinalStateT<pat::Electron,pat::Muon>::daughter2_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8496, type_8498), Reflex::Literal("operator="), operator_13730, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8498), Reflex::Literal("PATPairFinalStateT"), constructor_13731, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATPairFinalStateT"), constructor_13732, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45636, type_45727, type_45406), Reflex::Literal("PATPairFinalStateT"), constructor_13733, 0, "p1;p2;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATPairFinalStateT"), destructor_13740, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1888, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x59, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATPairFinalStateT_pat__Electron_pat__Muon__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATPairFinalStateT_pat__Electron_pat__Muon__funcmem_bld);
}

//------Delayed data member builder for class PATPairFinalStateT<pat::Electron,pat::Muon> -------------------
void __PATPairFinalStateT_pat__Electron_pat__Muon__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9785, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATPairFinalStateT_pat__Electron_pat__Muon_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9782, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATPairFinalStateT_pat__Electron_pat__Muon_, p2_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATPairFinalStateT<pat::Electron,pat::Muon> -------------------
void __PATPairFinalStateT_pat__Electron_pat__Muon__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8492), Reflex::Literal("clone"), method_13734, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_13735, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_13736, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_13737, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_13738, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_13739, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class vector<PATPairFinalStateT<pat::Electron, pat::Muon>,std::allocator<PATPairFinalStateT<pat::Electron, pat::Muon> > > -------------------------------
static void constructor_8509( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >();
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >();
}

static void constructor_8510( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >(*(const ::std::allocator<PATPairFinalStateT<pat::Electron,pat::Muon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >(*(const ::std::allocator<PATPairFinalStateT<pat::Electron,pat::Muon> >*)arg[0]);
}

static void constructor_8511( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Electron,pat::Muon>*)arg[1]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Electron,pat::Muon>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Electron,pat::Muon>*)arg[1],
      *(const ::std::allocator<PATPairFinalStateT<pat::Electron,pat::Muon> >*)arg[2]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Electron,pat::Muon>*)arg[1],
      *(const ::std::allocator<PATPairFinalStateT<pat::Electron,pat::Muon> >*)arg[2]);
  }
}

static void constructor_8512( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >(*(const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >(*(const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)arg[0]);
}

static void destructor_8513(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >::~vector)();
}
static  void operator_8514( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->operator=)(*(const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)arg[0]);
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->operator=)(*(const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)arg[0]);
}

static  void method_8515( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATPairFinalStateT<pat::Electron,pat::Muon>*)arg[1]);
}

static  void method_8516( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Muon>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >)((((::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->begin)());
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->begin)();
}

static  void method_8517( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Electron,pat::Muon>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >)((((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->begin)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->begin)();
}

static  void method_8518( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Muon>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >)((((::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->end)());
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->end)();
}

static  void method_8519( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Electron,pat::Muon>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >)((((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->end)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->end)();
}

static  void method_8524( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->size)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->size)();
}

static  void method_8525( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->max_size)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->max_size)();
}

static  void method_8526( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATPairFinalStateT<pat::Electron,pat::Muon>*)arg[1]);
  }
}

static  void method_8527( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->capacity)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->capacity)();
}

static  void method_8528( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->empty)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->empty)();
}

static  void method_8529( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_8530( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_8531( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_8533( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8534( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8535( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->front)();
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->front)();
}

static  void method_8536( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->front)();
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->front)();
}

static  void method_8537( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->back)();
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->back)();
}

static  void method_8538( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->back)();
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->back)();
}

static  void method_8539( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->data)());
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->data)();
}

static  void method_8540( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->data)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->data)();
}

static  void method_8541( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->push_back)(*(const ::PATPairFinalStateT<pat::Electron,pat::Muon>*)arg[0]);
}

static  void method_8542( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->pop_back)();
}

static  void method_8543( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Muon>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >)((((::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Muon>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >*)arg[0],
    *(const ::PATPairFinalStateT<pat::Electron,pat::Muon>*)arg[1]));
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Muon>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >*)arg[0],
    *(const ::PATPairFinalStateT<pat::Electron,pat::Muon>*)arg[1]);
}

static  void method_8544( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Muon>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATPairFinalStateT<pat::Electron,pat::Muon>*)arg[2]);
}

static  void method_8545( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Muon>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >)((((::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Muon>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >*)arg[0]));
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Muon>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >*)arg[0]);
}

static  void method_8546( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Muon>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >)((((::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Muon>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Muon>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >*)arg[1]));
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Muon>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Muon>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >*)arg[1]);
}

static  void method_8547( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->swap)(*(::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)arg[0]);
}

static  void method_8548( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->clear)();
}

static void method_newdel_552( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x61( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATPairFinalStateT<pat::Electron,pat::Muon>,std::allocator<PATPairFinalStateT<pat::Electron,pat::Muon> > >")), ::Reflex::BaseOffset< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >,::std::_Vector_base<PATPairFinalStateT<pat::Electron,pat::Muon>,std::allocator<PATPairFinalStateT<pat::Electron,pat::Muon> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x62( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >::Generate();
}

//------Dictionary for class vector<PATPairFinalStateT<pat::Electron, pat::Muon>,std::allocator<PATPairFinalStateT<pat::Electron, pat::Muon> > > -------------------------------
void __std__vector_PATPairFinalStateT_pat__Electron_pat__Muon_s__db_datamem(Reflex::Class*);
void __std__vector_PATPairFinalStateT_pat__Electron_pat__Muon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATPairFinalStateT_pat__Electron_pat__Muon_s__datamem_bld(&__std__vector_PATPairFinalStateT_pat__Electron_pat__Muon_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATPairFinalStateT_pat__Electron_pat__Muon_s__funcmem_bld(&__std__vector_PATPairFinalStateT_pat__Electron_pat__Muon_s__db_funcmem);
void __std__vector_PATPairFinalStateT_pat__Electron_pat__Muon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >"), typeid(::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >), sizeof(::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3730, ::Reflex::BaseOffset< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >, ::std::_Vector_base<PATPairFinalStateT<pat::Electron,pat::Muon>,std::allocator<PATPairFinalStateT<pat::Electron,pat::Muon> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1888, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >::_Alloc_value_type"))
  .AddTypedef(type_3730, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >::_Base"))
  .AddTypedef(type_5085, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >::_Tp_alloc_type"))
  .AddTypedef(type_1888, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >::value_type"))
  .AddTypedef(type_8492, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >::pointer"))
  .AddTypedef(type_8494, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >::const_pointer"))
  .AddTypedef(type_8496, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >::reference"))
  .AddTypedef(type_8498, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >::const_reference"))
  .AddTypedef(type_8500, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >::iterator"))
  .AddTypedef(type_8502, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >::const_iterator"))
  .AddTypedef(type_5713, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >::const_reverse_iterator"))
  .AddTypedef(type_5714, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >::difference_type"))
  .AddTypedef(type_5085, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_8509, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_50670), Reflex::Literal("vector"), constructor_8510, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_8498, type_50670), Reflex::Literal("vector"), constructor_8511, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_50671), Reflex::Literal("vector"), constructor_8512, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_8513, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_552, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x61, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x62, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATPairFinalStateT_pat__Electron_pat__Muon_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATPairFinalStateT<pat::Electron, pat::Muon>,std::allocator<PATPairFinalStateT<pat::Electron, pat::Muon> > > -------------------
void __std__vector_PATPairFinalStateT_pat__Electron_pat__Muon_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATPairFinalStateT<pat::Electron, pat::Muon>,std::allocator<PATPairFinalStateT<pat::Electron, pat::Muon> > > -------------------
void __std__vector_PATPairFinalStateT_pat__Electron_pat__Muon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_50672, type_50671), Reflex::Literal("operator="), operator_8514, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_8498), Reflex::Literal("assign"), method_8515, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8500), Reflex::Literal("begin"), method_8516, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8502), Reflex::Literal("begin"), method_8517, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8500), Reflex::Literal("end"), method_8518, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8502), Reflex::Literal("end"), method_8519, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_8524, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_8525, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_1888), Reflex::Literal("resize"), method_8526, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_8527, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_8528, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_8529, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8496, type_5015), Reflex::Literal("operator[]"), operator_8530, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8498, type_5015), Reflex::Literal("operator[]"), operator_8531, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8496, type_5015), Reflex::Literal("at"), method_8533, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8498, type_5015), Reflex::Literal("at"), method_8534, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8496), Reflex::Literal("front"), method_8535, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8498), Reflex::Literal("front"), method_8536, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8496), Reflex::Literal("back"), method_8537, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8498), Reflex::Literal("back"), method_8538, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8492), Reflex::Literal("data"), method_8539, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8494), Reflex::Literal("data"), method_8540, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8498), Reflex::Literal("push_back"), method_8541, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_8542, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8500, type_8500, type_8498), Reflex::Literal("insert"), method_8543, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8500, type_5015, type_8498), Reflex::Literal("insert"), method_8544, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8500, type_8500), Reflex::Literal("erase"), method_8545, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8500, type_8500, type_8500), Reflex::Literal("erase"), method_8546, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_50672), Reflex::Literal("swap"), method_8547, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_8548, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> -------------------------------
static  void operator_10306( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*)o)->operator=)(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*)arg[0]);
  else   (((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*)o)->operator=)(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*)arg[0]);
}

static void constructor_10307( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*)arg[0]);
  else ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*)arg[0]);
}

static void constructor_10308( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>();
  else ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>();
}

static void constructor_10309( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Electron>*)arg[1],
      *(const ::edm::Ptr<pat::Muon>*)arg[2],
      *(const ::edm::Ptr<pat::Tau>*)arg[3],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[4]);
  else ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Electron>*)arg[1],
      *(const ::edm::Ptr<pat::Muon>*)arg[2],
      *(const ::edm::Ptr<pat::Tau>*)arg[3],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[4]);
}

static  void method_10310( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*)o)->clone)());
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*)o)->clone)();
}

static  void method_10311( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_10312( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_10313( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*)o)->numberOfDaughters)());
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*)o)->numberOfDaughters)();
}

static  void method_10314( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_10315( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_10316(void*, void * o, const std::vector<void*>&, void *) {
(((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*)o)->::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>::~PATQuadFinalStateT)();
}
static void method_newdel_762( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x64( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> -------------------------------
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau__db_datamem(Reflex::Class*);
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau__datamem_bld(&__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau__db_datamem);
Reflex::GenreflexMemberBuilder __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau__funcmem_bld(&__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau__db_funcmem);
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>"), typeid(::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>), sizeof(::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6476, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>::daughter1_type"))
  .AddTypedef(type_6476, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>::daughter2_type"))
  .AddTypedef(type_6497, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>::daughter3_type"))
  .AddTypedef(type_7135, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>::daughter4_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8563, type_8565), Reflex::Literal("operator="), operator_10306, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8565), Reflex::Literal("PATQuadFinalStateT"), constructor_10307, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATQuadFinalStateT"), constructor_10308, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45636, type_45636, type_45727, type_46321, type_45406), Reflex::Literal("PATQuadFinalStateT"), constructor_10309, 0, "p1;p2;p3;p4;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATQuadFinalStateT"), destructor_10316, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_762, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x64, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau__funcmem_bld);
}

//------Delayed data member builder for class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> -------------------
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9785, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9785, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_, p2_), ::Reflex::PRIVATE)
  .AddDataMember(type_9782, Reflex::Literal("p3_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_, p3_), ::Reflex::PRIVATE)
  .AddDataMember(type_9787, Reflex::Literal("p4_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_, p4_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> -------------------
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8559), Reflex::Literal("clone"), method_10310, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_10311, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_10312, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_10313, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_10314, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_10315, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Tau> > > -------------------------------
static void constructor_8576( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >();
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >();
}

static void constructor_8577( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >(*(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >(*(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)arg[0]);
}

static void constructor_8578( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*)arg[1]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*)arg[1],
      *(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)arg[2]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*)arg[1],
      *(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)arg[2]);
  }
}

static void constructor_8579( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)arg[0]);
}

static void destructor_8580(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >::~vector)();
}
static  void operator_8581( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->operator=)(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->operator=)(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)arg[0]);
}

static  void method_8582( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*)arg[1]);
}

static  void method_8583( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->begin)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->begin)();
}

static  void method_8584( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->begin)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->begin)();
}

static  void method_8585( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->end)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->end)();
}

static  void method_8586( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->end)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->end)();
}

static  void method_8591( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->size)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->size)();
}

static  void method_8592( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->max_size)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->max_size)();
}

static  void method_8593( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*)arg[1]);
  }
}

static  void method_8594( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->capacity)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->capacity)();
}

static  void method_8595( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->empty)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->empty)();
}

static  void method_8596( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_8597( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_8598( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_8600( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8601( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_8602( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->front)();
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->front)();
}

static  void method_8603( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->front)();
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->front)();
}

static  void method_8604( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->back)();
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->back)();
}

static  void method_8605( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->back)();
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->back)();
}

static  void method_8606( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->data)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->data)();
}

static  void method_8607( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->data)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->data)();
}

static  void method_8608( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->push_back)(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*)arg[0]);
}

static  void method_8609( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->pop_back)();
}

static  void method_8610( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*)arg[1]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*)arg[1]);
}

static  void method_8611( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*)arg[2]);
}

static  void method_8612( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >*)arg[0]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >*)arg[0]);
}

static  void method_8613( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >*)arg[1]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >*)arg[1]);
}

static  void method_8614( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->swap)(*(::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)arg[0]);
}

static  void method_8615( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->clear)();
}

static void method_newdel_556( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x66( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >")), ::Reflex::BaseOffset< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >,::std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x67( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >::Generate();
}

//------Dictionary for class vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Tau> > > -------------------------------
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s__db_datamem(Reflex::Class*);
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s__datamem_bld(&__std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s__funcmem_bld(&__std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s__db_funcmem);
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >"), typeid(::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >), sizeof(::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3699, ::Reflex::BaseOffset< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >, ::std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_762, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >::_Alloc_value_type"))
  .AddTypedef(type_3699, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >::_Base"))
  .AddTypedef(type_5054, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >::_Tp_alloc_type"))
  .AddTypedef(type_762, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >::value_type"))
  .AddTypedef(type_8559, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >::pointer"))
  .AddTypedef(type_8561, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >::const_pointer"))
  .AddTypedef(type_8563, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >::reference"))
  .AddTypedef(type_8565, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >::const_reference"))
  .AddTypedef(type_8567, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >::iterator"))
  .AddTypedef(type_8569, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >::const_iterator"))
  .AddTypedef(type_5651, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >::const_reverse_iterator"))
  .AddTypedef(type_5652, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >::difference_type"))
  .AddTypedef(type_5054, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_8576, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_50674), Reflex::Literal("vector"), constructor_8577, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_8565, type_50674), Reflex::Literal("vector"), constructor_8578, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_50675), Reflex::Literal("vector"), constructor_8579, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_8580, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_556, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x66, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x67, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Tau> > > -------------------
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Tau> > > -------------------
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_50676, type_50675), Reflex::Literal("operator="), operator_8581, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_8565), Reflex::Literal("assign"), method_8582, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8567), Reflex::Literal("begin"), method_8583, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8569), Reflex::Literal("begin"), method_8584, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8567), Reflex::Literal("end"), method_8585, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8569), Reflex::Literal("end"), method_8586, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_8591, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_8592, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_762), Reflex::Literal("resize"), method_8593, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_8594, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_8595, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_8596, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8563, type_5015), Reflex::Literal("operator[]"), operator_8597, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8565, type_5015), Reflex::Literal("operator[]"), operator_8598, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8563, type_5015), Reflex::Literal("at"), method_8600, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8565, type_5015), Reflex::Literal("at"), method_8601, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8563), Reflex::Literal("front"), method_8602, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8565), Reflex::Literal("front"), method_8603, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8563), Reflex::Literal("back"), method_8604, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8565), Reflex::Literal("back"), method_8605, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8559), Reflex::Literal("data"), method_8606, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8561), Reflex::Literal("data"), method_8607, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8565), Reflex::Literal("push_back"), method_8608, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_8609, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8567, type_8567, type_8565), Reflex::Literal("insert"), method_8610, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8567, type_5015, type_8565), Reflex::Literal("insert"), method_8611, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8567, type_8567), Reflex::Literal("erase"), method_8612, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8567, type_8567, type_8567), Reflex::Literal("erase"), method_8613, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_50676), Reflex::Literal("swap"), method_8614, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_8615, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> -------------------------------
static  void operator_8762( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*)o)->operator=)(*(const ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*)arg[0]);
  else   (((::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*)o)->operator=)(*(const ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*)arg[0]);
}

static void constructor_8763( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>(*(const ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*)arg[0]);
  else ::new(mem) ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>(*(const ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*)arg[0]);
}

static void constructor_8764( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>();
  else ::new(mem) ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>();
}

static void constructor_8765( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>(*(const ::edm::Ptr<pat::Muon>*)arg[0],
      *(const ::edm::Ptr<pat::Jet>*)arg[1],
      *(const ::edm::Ptr<pat::Jet>*)arg[2],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[3]);
  else ::new(mem) ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>(*(const ::edm::Ptr<pat::Muon>*)arg[0],
      *(const ::edm::Ptr<pat::Jet>*)arg[1],
      *(const ::edm::Ptr<pat::Jet>*)arg[2],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[3]);
}

static  void method_8766( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*)o)->clone)());
  else   (((const ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*)o)->clone)();
}

static  void method_8767( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_8768( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_8769( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*)o)->numberOfDaughters)());
  else   (((const ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*)o)->numberOfDaughters)();
}

static  void method_8770( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_8771( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_8772(void*, void * o, const std::vector<void*>&, void *) {
(((::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*)o)->::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>::~PATTripletFinalStateT)();
}
static void method_newdel_634( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x69( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> -------------------------------
void __PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet__db_datamem(Reflex::Class*);
void __PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet__datamem_bld(&__PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet__db_datamem);
Reflex::GenreflexMemberBuilder __PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet__funcmem_bld(&__PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet__db_funcmem);
void __PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>"), typeid(::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>), sizeof(::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6497, Reflex::Literal("PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>::daughter1_type"))
  .AddTypedef(type_7094, Reflex::Literal("PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>::daughter2_type"))
  .AddTypedef(type_7094, Reflex::Literal("PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>::daughter3_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13377, type_13379), Reflex::Literal("operator="), operator_8762, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13379), Reflex::Literal("PATTripletFinalStateT"), constructor_8763, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATTripletFinalStateT"), constructor_8764, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45727, type_46161, type_46161, type_45406), Reflex::Literal("PATTripletFinalStateT"), constructor_8765, 0, "p1;p2;p3;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATTripletFinalStateT"), destructor_8772, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_634, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x69, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet__funcmem_bld);
}

//------Delayed data member builder for class PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> -------------------
void __PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9782, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9781, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_, p2_), ::Reflex::PRIVATE)
  .AddDataMember(type_9781, Reflex::Literal("p3_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_, p3_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> -------------------
void __PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13373), Reflex::Literal("clone"), method_8766, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_8767, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_8768, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_8769, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_8770, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_8771, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Photon, pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Photon, pat::Photon> > > -------------------------------
static void constructor_10042( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >();
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >();
}

static void constructor_10043( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >(*(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >(*(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)arg[0]);
}

static void constructor_10044( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*)arg[1]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*)arg[1],
      *(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)arg[2]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*)arg[1],
      *(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)arg[2]);
  }
}

static void constructor_10045( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)arg[0]);
}

static void destructor_10046(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >::~vector)();
}
static  void operator_10047( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->operator=)(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->operator=)(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)arg[0]);
}

static  void method_10048( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*)arg[1]);
}

static  void method_10049( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->begin)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->begin)();
}

static  void method_10050( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->begin)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->begin)();
}

static  void method_10051( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->end)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->end)();
}

static  void method_10052( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->end)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->end)();
}

static  void method_10057( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->size)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->size)();
}

static  void method_10058( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->max_size)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->max_size)();
}

static  void method_10059( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*)arg[1]);
  }
}

static  void method_10060( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->capacity)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->capacity)();
}

static  void method_10061( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->empty)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->empty)();
}

static  void method_10062( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_10063( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_10064( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_10066( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10067( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10068( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->front)();
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->front)();
}

static  void method_10069( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->front)();
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->front)();
}

static  void method_10070( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->back)();
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->back)();
}

static  void method_10071( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->back)();
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->back)();
}

static  void method_10072( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->data)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->data)();
}

static  void method_10073( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->data)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->data)();
}

static  void method_10074( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->push_back)(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*)arg[0]);
}

static  void method_10075( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->pop_back)();
}

static  void method_10076( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*)arg[1]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*)arg[1]);
}

static  void method_10077( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*)arg[2]);
}

static  void method_10078( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >*)arg[0]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >*)arg[0]);
}

static  void method_10079( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >*)arg[1]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >*)arg[1]);
}

static  void method_10080( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->swap)(*(::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)arg[0]);
}

static  void method_10081( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->clear)();
}

static void method_newdel_670( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x71( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >")), ::Reflex::BaseOffset< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >,::std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x72( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >::Generate();
}

//------Dictionary for class vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Photon, pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Photon, pat::Photon> > > -------------------------------
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s__db_datamem(Reflex::Class*);
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s__datamem_bld(&__std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s__funcmem_bld(&__std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s__db_funcmem);
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >"), typeid(::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >), sizeof(::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3696, ::Reflex::BaseOffset< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >, ::std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_473, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >::_Alloc_value_type"))
  .AddTypedef(type_3696, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >::_Base"))
  .AddTypedef(type_5051, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >::_Tp_alloc_type"))
  .AddTypedef(type_473, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >::value_type"))
  .AddTypedef(type_10025, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >::pointer"))
  .AddTypedef(type_10027, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >::const_pointer"))
  .AddTypedef(type_10029, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >::reference"))
  .AddTypedef(type_10031, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >::const_reference"))
  .AddTypedef(type_10033, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >::iterator"))
  .AddTypedef(type_10035, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >::const_iterator"))
  .AddTypedef(type_5645, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >::const_reverse_iterator"))
  .AddTypedef(type_5646, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >::difference_type"))
  .AddTypedef(type_5051, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_10042, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_59085), Reflex::Literal("vector"), constructor_10043, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_10031, type_59085), Reflex::Literal("vector"), constructor_10044, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_59086), Reflex::Literal("vector"), constructor_10045, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_10046, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_670, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x71, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x72, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Photon, pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Photon, pat::Photon> > > -------------------
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Photon, pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Photon, pat::Photon> > > -------------------
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_59087, type_59086), Reflex::Literal("operator="), operator_10047, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_10031), Reflex::Literal("assign"), method_10048, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10033), Reflex::Literal("begin"), method_10049, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10035), Reflex::Literal("begin"), method_10050, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10033), Reflex::Literal("end"), method_10051, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10035), Reflex::Literal("end"), method_10052, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_10057, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_10058, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_473), Reflex::Literal("resize"), method_10059, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_10060, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_10061, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_10062, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10029, type_5015), Reflex::Literal("operator[]"), operator_10063, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10031, type_5015), Reflex::Literal("operator[]"), operator_10064, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10029, type_5015), Reflex::Literal("at"), method_10066, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10031, type_5015), Reflex::Literal("at"), method_10067, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10029), Reflex::Literal("front"), method_10068, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10031), Reflex::Literal("front"), method_10069, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10029), Reflex::Literal("back"), method_10070, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10031), Reflex::Literal("back"), method_10071, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10025), Reflex::Literal("data"), method_10072, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10027), Reflex::Literal("data"), method_10073, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_10031), Reflex::Literal("push_back"), method_10074, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_10075, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10033, type_10033, type_10031), Reflex::Literal("insert"), method_10076, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_10033, type_5015, type_10031), Reflex::Literal("insert"), method_10077, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10033, type_10033), Reflex::Literal("erase"), method_10078, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10033, type_10033, type_10033), Reflex::Literal("erase"), method_10079, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_59087), Reflex::Literal("swap"), method_10080, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_10081, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> -------------------------------
static  void operator_10244( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*)o)->operator=)(*(const ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*)arg[0]);
  else   (((::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*)o)->operator=)(*(const ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*)arg[0]);
}

static void constructor_10245( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>(*(const ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*)arg[0]);
  else ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>(*(const ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*)arg[0]);
}

static void constructor_10246( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>();
  else ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>();
}

static void constructor_10247( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Tau>*)arg[1],
      *(const ::edm::Ptr<pat::Tau>*)arg[2],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[3]);
  else ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Tau>*)arg[1],
      *(const ::edm::Ptr<pat::Tau>*)arg[2],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[3]);
}

static  void method_10248( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*)o)->clone)());
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*)o)->clone)();
}

static  void method_10249( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_10250( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_10251( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*)o)->numberOfDaughters)());
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*)o)->numberOfDaughters)();
}

static  void method_10252( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_10253( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_10254(void*, void * o, const std::vector<void*>&, void *) {
(((::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*)o)->::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>::~PATTripletFinalStateT)();
}
static void method_newdel_716( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x74( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> -------------------------------
void __PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau__db_datamem(Reflex::Class*);
void __PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau__datamem_bld(&__PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau__db_datamem);
Reflex::GenreflexMemberBuilder __PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau__funcmem_bld(&__PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau__db_funcmem);
void __PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>"), typeid(::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>), sizeof(::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6476, Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>::daughter1_type"))
  .AddTypedef(type_7135, Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>::daughter2_type"))
  .AddTypedef(type_7135, Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>::daughter3_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12064, type_12066), Reflex::Literal("operator="), operator_10244, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12066), Reflex::Literal("PATTripletFinalStateT"), constructor_10245, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATTripletFinalStateT"), constructor_10246, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45636, type_46321, type_46321, type_45406), Reflex::Literal("PATTripletFinalStateT"), constructor_10247, 0, "p1;p2;p3;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATTripletFinalStateT"), destructor_10254, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_716, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x74, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau__funcmem_bld);
}

//------Delayed data member builder for class PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> -------------------
void __PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9785, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9787, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_, p2_), ::Reflex::PRIVATE)
  .AddDataMember(type_9787, Reflex::Literal("p3_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_, p3_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> -------------------
void __PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12060), Reflex::Literal("clone"), method_10248, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_10249, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_10250, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_10251, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_10252, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_10253, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> -------------------------------
static  void operator_10612( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*)o)->operator=)(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*)arg[0]);
  else   (((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*)o)->operator=)(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*)arg[0]);
}

static void constructor_10613( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*)arg[0]);
  else ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*)arg[0]);
}

static void constructor_10614( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>();
  else ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>();
}

static void constructor_10615( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Electron>*)arg[1],
      *(const ::edm::Ptr<pat::Muon>*)arg[2],
      *(const ::edm::Ptr<pat::Muon>*)arg[3],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[4]);
  else ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Electron>*)arg[1],
      *(const ::edm::Ptr<pat::Muon>*)arg[2],
      *(const ::edm::Ptr<pat::Muon>*)arg[3],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[4]);
}

static  void method_10616( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*)o)->clone)());
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*)o)->clone)();
}

static  void method_10617( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_10618( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_10619( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*)o)->numberOfDaughters)());
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*)o)->numberOfDaughters)();
}

static  void method_10620( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_10621( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_10622(void*, void * o, const std::vector<void*>&, void *) {
(((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*)o)->::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>::~PATQuadFinalStateT)();
}
static void method_newdel_803( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x76( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> -------------------------------
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon__db_datamem(Reflex::Class*);
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon__datamem_bld(&__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon__db_datamem);
Reflex::GenreflexMemberBuilder __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon__funcmem_bld(&__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon__db_funcmem);
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>"), typeid(::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>), sizeof(::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6476, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>::daughter1_type"))
  .AddTypedef(type_6476, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>::daughter2_type"))
  .AddTypedef(type_6497, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>::daughter3_type"))
  .AddTypedef(type_6497, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>::daughter4_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14565, type_14567), Reflex::Literal("operator="), operator_10612, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14567), Reflex::Literal("PATQuadFinalStateT"), constructor_10613, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATQuadFinalStateT"), constructor_10614, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45636, type_45636, type_45727, type_45727, type_45406), Reflex::Literal("PATQuadFinalStateT"), constructor_10615, 0, "p1;p2;p3;p4;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATQuadFinalStateT"), destructor_10622, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_803, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x76, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon__funcmem_bld);
}

//------Delayed data member builder for class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> -------------------
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9785, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9785, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_, p2_), ::Reflex::PRIVATE)
  .AddDataMember(type_9782, Reflex::Literal("p3_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_, p3_), ::Reflex::PRIVATE)
  .AddDataMember(type_9782, Reflex::Literal("p4_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_, p4_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> -------------------
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14561), Reflex::Literal("clone"), method_10616, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_10617, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_10618, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_10619, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_10620, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_10621, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> -------------------------------
static  void operator_10877( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*)o)->operator=)(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*)arg[0]);
  else   (((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*)o)->operator=)(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*)arg[0]);
}

static void constructor_10878( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*)arg[0]);
  else ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*)arg[0]);
}

static void constructor_10879( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>();
  else ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>();
}

static void constructor_10880( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Electron>*)arg[1],
      *(const ::edm::Ptr<pat::Muon>*)arg[2],
      *(const ::edm::Ptr<pat::Photon>*)arg[3],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[4]);
  else ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Electron>*)arg[1],
      *(const ::edm::Ptr<pat::Muon>*)arg[2],
      *(const ::edm::Ptr<pat::Photon>*)arg[3],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[4]);
}

static  void method_10881( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*)o)->clone)());
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*)o)->clone)();
}

static  void method_10882( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_10883( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_10884( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*)o)->numberOfDaughters)());
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*)o)->numberOfDaughters)();
}

static  void method_10885( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_10886( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_10887(void*, void * o, const std::vector<void*>&, void *) {
(((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*)o)->::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>::~PATQuadFinalStateT)();
}
static void method_newdel_891( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x78( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> -------------------------------
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon__db_datamem(Reflex::Class*);
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon__datamem_bld(&__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon__db_datamem);
Reflex::GenreflexMemberBuilder __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon__funcmem_bld(&__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon__db_funcmem);
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>"), typeid(::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>), sizeof(::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6476, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>::daughter1_type"))
  .AddTypedef(type_6476, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>::daughter2_type"))
  .AddTypedef(type_6497, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>::daughter3_type"))
  .AddTypedef(type_6478, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>::daughter4_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13444, type_13446), Reflex::Literal("operator="), operator_10877, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13446), Reflex::Literal("PATQuadFinalStateT"), constructor_10878, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATQuadFinalStateT"), constructor_10879, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45636, type_45636, type_45727, type_45637, type_45406), Reflex::Literal("PATQuadFinalStateT"), constructor_10880, 0, "p1;p2;p3;p4;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATQuadFinalStateT"), destructor_10887, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_891, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x78, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon__funcmem_bld);
}

//------Delayed data member builder for class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> -------------------
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9785, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9785, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_, p2_), ::Reflex::PRIVATE)
  .AddDataMember(type_9782, Reflex::Literal("p3_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_, p3_), ::Reflex::PRIVATE)
  .AddDataMember(type_9786, Reflex::Literal("p4_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_, p4_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> -------------------
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13440), Reflex::Literal("clone"), method_10881, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_10882, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_10883, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_10884, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_10885, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_10886, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> -------------------------------
static  void operator_10907( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*)o)->operator=)(*(const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*)arg[0]);
  else   (((::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*)o)->operator=)(*(const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*)arg[0]);
}

static void constructor_10908( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>(*(const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*)arg[0]);
  else ::new(mem) ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>(*(const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*)arg[0]);
}

static void constructor_10909( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>();
  else ::new(mem) ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>();
}

static void constructor_10910( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>(*(const ::edm::Ptr<pat::Muon>*)arg[0],
      *(const ::edm::Ptr<pat::Muon>*)arg[1],
      *(const ::edm::Ptr<pat::Photon>*)arg[2],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[3]);
  else ::new(mem) ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>(*(const ::edm::Ptr<pat::Muon>*)arg[0],
      *(const ::edm::Ptr<pat::Muon>*)arg[1],
      *(const ::edm::Ptr<pat::Photon>*)arg[2],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[3]);
}

static  void method_10911( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*)o)->clone)());
  else   (((const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*)o)->clone)();
}

static  void method_10912( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_10913( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_10914( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*)o)->numberOfDaughters)());
  else   (((const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*)o)->numberOfDaughters)();
}

static  void method_10915( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_10916( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_10917(void*, void * o, const std::vector<void*>&, void *) {
(((::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*)o)->::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>::~PATTripletFinalStateT)();
}
static void method_newdel_912( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x80( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> -------------------------------
void __PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon__db_datamem(Reflex::Class*);
void __PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon__datamem_bld(&__PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon__db_datamem);
Reflex::GenreflexMemberBuilder __PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon__funcmem_bld(&__PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon__db_funcmem);
void __PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>"), typeid(::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>), sizeof(::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6497, Reflex::Literal("PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>::daughter1_type"))
  .AddTypedef(type_6497, Reflex::Literal("PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>::daughter2_type"))
  .AddTypedef(type_6478, Reflex::Literal("PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>::daughter3_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18315, type_18317), Reflex::Literal("operator="), operator_10907, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18317), Reflex::Literal("PATTripletFinalStateT"), constructor_10908, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATTripletFinalStateT"), constructor_10909, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45727, type_45727, type_45637, type_45406), Reflex::Literal("PATTripletFinalStateT"), constructor_10910, 0, "p1;p2;p3;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATTripletFinalStateT"), destructor_10917, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_912, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x80, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon__funcmem_bld);
}

//------Delayed data member builder for class PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> -------------------
void __PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9782, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9782, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_, p2_), ::Reflex::PRIVATE)
  .AddDataMember(type_9786, Reflex::Literal("p3_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_, p3_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> -------------------
void __PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18311), Reflex::Literal("clone"), method_10911, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_10912, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_10913, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_10914, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_10915, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_10916, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class PATPairFinalStateT<pat::Muon,pat::Muon> -------------------------------
static  void operator_11707( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATPairFinalStateT<pat::Muon,pat::Muon>*)o)->operator=)(*(const ::PATPairFinalStateT<pat::Muon,pat::Muon>*)arg[0]);
  else   (((::PATPairFinalStateT<pat::Muon,pat::Muon>*)o)->operator=)(*(const ::PATPairFinalStateT<pat::Muon,pat::Muon>*)arg[0]);
}

static void constructor_11708( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATPairFinalStateT<pat::Muon,pat::Muon>(*(const ::PATPairFinalStateT<pat::Muon,pat::Muon>*)arg[0]);
  else ::new(mem) ::PATPairFinalStateT<pat::Muon,pat::Muon>(*(const ::PATPairFinalStateT<pat::Muon,pat::Muon>*)arg[0]);
}

static void constructor_11709( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATPairFinalStateT<pat::Muon,pat::Muon>();
  else ::new(mem) ::PATPairFinalStateT<pat::Muon,pat::Muon>();
}

static void constructor_11710( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATPairFinalStateT<pat::Muon,pat::Muon>(*(const ::edm::Ptr<pat::Muon>*)arg[0],
      *(const ::edm::Ptr<pat::Muon>*)arg[1],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[2]);
  else ::new(mem) ::PATPairFinalStateT<pat::Muon,pat::Muon>(*(const ::edm::Ptr<pat::Muon>*)arg[0],
      *(const ::edm::Ptr<pat::Muon>*)arg[1],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[2]);
}

static  void method_11711( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATPairFinalStateT<pat::Muon,pat::Muon>*)o)->clone)());
  else   (((const ::PATPairFinalStateT<pat::Muon,pat::Muon>*)o)->clone)();
}

static  void method_11712( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATPairFinalStateT<pat::Muon,pat::Muon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATPairFinalStateT<pat::Muon,pat::Muon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_11713( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATPairFinalStateT<pat::Muon,pat::Muon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATPairFinalStateT<pat::Muon,pat::Muon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_11714( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATPairFinalStateT<pat::Muon,pat::Muon>*)o)->numberOfDaughters)());
  else   (((const ::PATPairFinalStateT<pat::Muon,pat::Muon>*)o)->numberOfDaughters)();
}

static  void method_11715( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATPairFinalStateT<pat::Muon,pat::Muon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATPairFinalStateT<pat::Muon,pat::Muon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_11716( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATPairFinalStateT<pat::Muon,pat::Muon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATPairFinalStateT<pat::Muon,pat::Muon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_11717(void*, void * o, const std::vector<void*>&, void *) {
(((::PATPairFinalStateT<pat::Muon,pat::Muon>*)o)->::PATPairFinalStateT<pat::Muon,pat::Muon>::~PATPairFinalStateT)();
}
static void method_newdel_1200( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Muon,pat::Muon> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Muon,pat::Muon> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Muon,pat::Muon> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Muon,pat::Muon> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Muon,pat::Muon> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x82( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Muon,pat::Muon>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Muon,pat::Muon>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Muon,pat::Muon>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Muon,pat::Muon>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATPairFinalStateT<pat::Muon,pat::Muon> -------------------------------
void __PATPairFinalStateT_pat__Muon_pat__Muon__db_datamem(Reflex::Class*);
void __PATPairFinalStateT_pat__Muon_pat__Muon__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATPairFinalStateT_pat__Muon_pat__Muon__datamem_bld(&__PATPairFinalStateT_pat__Muon_pat__Muon__db_datamem);
Reflex::GenreflexMemberBuilder __PATPairFinalStateT_pat__Muon_pat__Muon__funcmem_bld(&__PATPairFinalStateT_pat__Muon_pat__Muon__db_funcmem);
void __PATPairFinalStateT_pat__Muon_pat__Muon__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATPairFinalStateT<pat::Muon,pat::Muon>"), typeid(::PATPairFinalStateT<pat::Muon,pat::Muon>), sizeof(::PATPairFinalStateT<pat::Muon,pat::Muon>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Muon,pat::Muon>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6497, Reflex::Literal("PATPairFinalStateT<pat::Muon,pat::Muon>::daughter1_type"))
  .AddTypedef(type_6497, Reflex::Literal("PATPairFinalStateT<pat::Muon,pat::Muon>::daughter2_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10926, type_10928), Reflex::Literal("operator="), operator_11707, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10928), Reflex::Literal("PATPairFinalStateT"), constructor_11708, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATPairFinalStateT"), constructor_11709, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45727, type_45727, type_45406), Reflex::Literal("PATPairFinalStateT"), constructor_11710, 0, "p1;p2;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATPairFinalStateT"), destructor_11717, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1200, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x82, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATPairFinalStateT_pat__Muon_pat__Muon__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATPairFinalStateT_pat__Muon_pat__Muon__funcmem_bld);
}

//------Delayed data member builder for class PATPairFinalStateT<pat::Muon,pat::Muon> -------------------
void __PATPairFinalStateT_pat__Muon_pat__Muon__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9782, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATPairFinalStateT_pat__Muon_pat__Muon_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9782, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATPairFinalStateT_pat__Muon_pat__Muon_, p2_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATPairFinalStateT<pat::Muon,pat::Muon> -------------------
void __PATPairFinalStateT_pat__Muon_pat__Muon__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10922), Reflex::Literal("clone"), method_11711, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_11712, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_11713, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_11714, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_11715, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_11716, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class vector<PATPairFinalStateT<pat::Muon, pat::Muon>,std::allocator<PATPairFinalStateT<pat::Muon, pat::Muon> > > -------------------------------
static void constructor_10939( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >();
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >();
}

static void constructor_10940( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >(*(const ::std::allocator<PATPairFinalStateT<pat::Muon,pat::Muon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >(*(const ::std::allocator<PATPairFinalStateT<pat::Muon,pat::Muon> >*)arg[0]);
}

static void constructor_10941( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Muon,pat::Muon>*)arg[1]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Muon,pat::Muon>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Muon,pat::Muon>*)arg[1],
      *(const ::std::allocator<PATPairFinalStateT<pat::Muon,pat::Muon> >*)arg[2]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Muon,pat::Muon>*)arg[1],
      *(const ::std::allocator<PATPairFinalStateT<pat::Muon,pat::Muon> >*)arg[2]);
  }
}

static void constructor_10942( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >(*(const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >(*(const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)arg[0]);
}

static void destructor_10943(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >::~vector)();
}
static  void operator_10944( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->operator=)(*(const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)arg[0]);
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->operator=)(*(const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)arg[0]);
}

static  void method_10945( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATPairFinalStateT<pat::Muon,pat::Muon>*)arg[1]);
}

static  void method_10946( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Muon>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >)((((::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->begin)());
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->begin)();
}

static  void method_10947( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Muon,pat::Muon>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >)((((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->begin)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->begin)();
}

static  void method_10948( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Muon>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >)((((::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->end)());
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->end)();
}

static  void method_10949( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Muon,pat::Muon>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >)((((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->end)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->end)();
}

static  void method_10954( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->size)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->size)();
}

static  void method_10955( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->max_size)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->max_size)();
}

static  void method_10956( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATPairFinalStateT<pat::Muon,pat::Muon>*)arg[1]);
  }
}

static  void method_10957( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->capacity)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->capacity)();
}

static  void method_10958( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->empty)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->empty)();
}

static  void method_10959( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_10960( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_10961( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_10963( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10964( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10965( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->front)();
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->front)();
}

static  void method_10966( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->front)();
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->front)();
}

static  void method_10967( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->back)();
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->back)();
}

static  void method_10968( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->back)();
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->back)();
}

static  void method_10969( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->data)());
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->data)();
}

static  void method_10970( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->data)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->data)();
}

static  void method_10971( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->push_back)(*(const ::PATPairFinalStateT<pat::Muon,pat::Muon>*)arg[0]);
}

static  void method_10972( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->pop_back)();
}

static  void method_10973( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Muon>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >)((((::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Muon>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >*)arg[0],
    *(const ::PATPairFinalStateT<pat::Muon,pat::Muon>*)arg[1]));
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Muon>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >*)arg[0],
    *(const ::PATPairFinalStateT<pat::Muon,pat::Muon>*)arg[1]);
}

static  void method_10974( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Muon>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATPairFinalStateT<pat::Muon,pat::Muon>*)arg[2]);
}

static  void method_10975( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Muon>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >)((((::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Muon>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >*)arg[0]));
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Muon>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >*)arg[0]);
}

static  void method_10976( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Muon>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >)((((::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Muon>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Muon>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >*)arg[1]));
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Muon>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Muon>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >*)arg[1]);
}

static  void method_10977( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->swap)(*(::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)arg[0]);
}

static  void method_10978( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->clear)();
}

static void method_newdel_922( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x84( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATPairFinalStateT<pat::Muon,pat::Muon>,std::allocator<PATPairFinalStateT<pat::Muon,pat::Muon> > >")), ::Reflex::BaseOffset< ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >,::std::_Vector_base<PATPairFinalStateT<pat::Muon,pat::Muon>,std::allocator<PATPairFinalStateT<pat::Muon,pat::Muon> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x85( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >::Generate();
}

//------Dictionary for class vector<PATPairFinalStateT<pat::Muon, pat::Muon>,std::allocator<PATPairFinalStateT<pat::Muon, pat::Muon> > > -------------------------------
void __std__vector_PATPairFinalStateT_pat__Muon_pat__Muon_s__db_datamem(Reflex::Class*);
void __std__vector_PATPairFinalStateT_pat__Muon_pat__Muon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATPairFinalStateT_pat__Muon_pat__Muon_s__datamem_bld(&__std__vector_PATPairFinalStateT_pat__Muon_pat__Muon_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATPairFinalStateT_pat__Muon_pat__Muon_s__funcmem_bld(&__std__vector_PATPairFinalStateT_pat__Muon_pat__Muon_s__db_funcmem);
void __std__vector_PATPairFinalStateT_pat__Muon_pat__Muon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >"), typeid(::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >), sizeof(::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3727, ::Reflex::BaseOffset< ::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >, ::std::_Vector_base<PATPairFinalStateT<pat::Muon,pat::Muon>,std::allocator<PATPairFinalStateT<pat::Muon,pat::Muon> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1200, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >::_Alloc_value_type"))
  .AddTypedef(type_3727, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >::_Base"))
  .AddTypedef(type_5082, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >::_Tp_alloc_type"))
  .AddTypedef(type_1200, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >::value_type"))
  .AddTypedef(type_10922, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >::pointer"))
  .AddTypedef(type_10924, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >::const_pointer"))
  .AddTypedef(type_10926, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >::reference"))
  .AddTypedef(type_10928, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >::const_reference"))
  .AddTypedef(type_10930, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >::iterator"))
  .AddTypedef(type_10932, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >::const_iterator"))
  .AddTypedef(type_5707, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >::const_reverse_iterator"))
  .AddTypedef(type_5708, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >::difference_type"))
  .AddTypedef(type_5082, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_10939, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_59307), Reflex::Literal("vector"), constructor_10940, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_10928, type_59307), Reflex::Literal("vector"), constructor_10941, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_59308), Reflex::Literal("vector"), constructor_10942, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_10943, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_922, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x84, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x85, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATPairFinalStateT_pat__Muon_pat__Muon_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATPairFinalStateT<pat::Muon, pat::Muon>,std::allocator<PATPairFinalStateT<pat::Muon, pat::Muon> > > -------------------
void __std__vector_PATPairFinalStateT_pat__Muon_pat__Muon_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATPairFinalStateT<pat::Muon, pat::Muon>,std::allocator<PATPairFinalStateT<pat::Muon, pat::Muon> > > -------------------
void __std__vector_PATPairFinalStateT_pat__Muon_pat__Muon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_59309, type_59308), Reflex::Literal("operator="), operator_10944, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_10928), Reflex::Literal("assign"), method_10945, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10930), Reflex::Literal("begin"), method_10946, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10932), Reflex::Literal("begin"), method_10947, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10930), Reflex::Literal("end"), method_10948, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10932), Reflex::Literal("end"), method_10949, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_10954, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_10955, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_1200), Reflex::Literal("resize"), method_10956, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_10957, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_10958, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_10959, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10926, type_5015), Reflex::Literal("operator[]"), operator_10960, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10928, type_5015), Reflex::Literal("operator[]"), operator_10961, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10926, type_5015), Reflex::Literal("at"), method_10963, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10928, type_5015), Reflex::Literal("at"), method_10964, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10926), Reflex::Literal("front"), method_10965, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10928), Reflex::Literal("front"), method_10966, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10926), Reflex::Literal("back"), method_10967, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10928), Reflex::Literal("back"), method_10968, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10922), Reflex::Literal("data"), method_10969, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10924), Reflex::Literal("data"), method_10970, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_10928), Reflex::Literal("push_back"), method_10971, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_10972, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10930, type_10930, type_10928), Reflex::Literal("insert"), method_10973, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_10930, type_5015, type_10928), Reflex::Literal("insert"), method_10974, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10930, type_10930), Reflex::Literal("erase"), method_10975, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10930, type_10930, type_10930), Reflex::Literal("erase"), method_10976, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_59309), Reflex::Literal("swap"), method_10977, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_10978, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > -------------------------------
static void constructor_11119( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >();
  else ::new(mem) ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >();
}

static void constructor_11120( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >(*(::std::size_t*)arg[0]);
}

static void constructor_11121( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >(*(const ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)arg[0]);
  else ::new(mem) ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >(*(const ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)arg[0]);
}

static void destructor_11122(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >::~OwnVector)();
}
static  void method_11123( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >::iterator)((((::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->begin)());
  else   (((::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->begin)();
}

static  void method_11124( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >::iterator)((((::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->end)());
  else   (((::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->end)();
}

static  void method_11125( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >::const_iterator)((((const ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->begin)());
  else   (((const ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->begin)();
}

static  void method_11126( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >::const_iterator)((((const ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->end)());
  else   (((const ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->end)();
}

static  void method_11127( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->size)());
  else   (((const ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->size)();
}

static  void method_11128( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->empty)());
  else   (((const ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->empty)();
}

static  void operator_11129( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_11130( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_11131( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->operator=)(*(const ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)arg[0]);
  else   (((::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->operator=)(*(const ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)arg[0]);
}

static  void method_11132( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->reserve)(*(::size_t*)arg[0]);
}

static  void method_11133( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->push_back)(*(const ::PATFinalState*)arg[0]);
}

static  void method_11134( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->is_back_safe)());
  else   (((const ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->is_back_safe)();
}

static  void method_11135( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->pop_back)();
}

static  void method_11136( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->back)();
  else   (((::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->back)();
}

static  void method_11137( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->back)();
  else   (((const ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->back)();
}

static  void method_11138( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->front)();
  else   (((::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->front)();
}

static  void method_11139( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->front)();
  else   (((const ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->front)();
}

static  void method_11140( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->data)();
  else   (((const ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->data)();
}

static  void method_11141( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->clear)();
}

static  void method_11142( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >::iterator)((((::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->erase)(*(::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >::iterator*)arg[0]));
  else   (((::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->erase)(*(::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >::iterator*)arg[0]);
}

static  void method_11143( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >::iterator)((((::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->erase)(*(::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >::iterator*)arg[0],
    *(::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >::iterator*)arg[1]));
  else   (((::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->erase)(*(::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >::iterator*)arg[0],
    *(::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >::iterator*)arg[1]);
}

static  void method_11145( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->swap)(*(::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)arg[0]);
}

static  void method_11146( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_11147( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_11148( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_11149( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->Class_Version)());
  else   (((::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)o)->Class_Version)();
}

static void method_newdel_951( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > -------------------------------
void __edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__db_datamem(Reflex::Class*);
void __edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__datamem_bld(&__edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__funcmem_bld(&__edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__db_funcmem);
void __edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >"), typeid(::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >), sizeof(::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >::Class_Version())
  .AddTypedef(type_4595, Reflex::Literal("edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >::base"))
  .AddTypedef(type_5015, Reflex::Literal("edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >::size_type"))
  .AddTypedef(type_466, Reflex::Literal("edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >::value_type"))
  .AddTypedef(type_11110, Reflex::Literal("edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >::pointer"))
  .AddTypedef(type_11112, Reflex::Literal("edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >::reference"))
  .AddTypedef(type_11114, Reflex::Literal("edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >::const_reference"))
  .AddTypedef(type_9906, Reflex::Literal("edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >::policy_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("OwnVector"), constructor_11119, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015), Reflex::Literal("OwnVector"), constructor_11120, 0, "n", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45908), Reflex::Literal("OwnVector"), constructor_11121, 0, "o", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~OwnVector"), destructor_11122, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_951, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__funcmem_bld);
}

//------Delayed data member builder for class OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > -------------------
void __edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4595, Reflex::Literal("data_"), OffsetOf(__shadow__::__edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s_, data_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > -------------------
void __edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11117), Reflex::Literal("begin"), method_11123, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11117), Reflex::Literal("end"), method_11124, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11118), Reflex::Literal("begin"), method_11125, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11118), Reflex::Literal("end"), method_11126, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_11127, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_11128, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11112, type_5015), Reflex::Literal("operator[]"), operator_11129, 0, "n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11114, type_5015), Reflex::Literal("operator[]"), operator_11130, 0, "n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_59599, type_45908), Reflex::Literal("operator="), operator_11131, 0, "o", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_3148), Reflex::Literal("reserve"), method_11132, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_11114), Reflex::Literal("push_back"), method_11133, 0, "d", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("is_back_safe"), method_11134, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_11135, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11112), Reflex::Literal("back"), method_11136, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11114), Reflex::Literal("back"), method_11137, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11112), Reflex::Literal("front"), method_11138, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11114), Reflex::Literal("front"), method_11139, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_59600), Reflex::Literal("data"), method_11140, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_11141, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11117, type_11117), Reflex::Literal("erase"), method_11142, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11117, type_11117, type_11117), Reflex::Literal("erase"), method_11143, 0, "first;last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_59599), Reflex::Literal("swap"), method_11145, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_45462), Reflex::Literal("fillView"), method_11146, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_11147, 0, "toType;index;ptr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_11148, 0, "toType;indices;ptrs", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_251), Reflex::Literal("Class_Version"), method_11149, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> -------------------------------
static  void operator_11160( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*)o)->operator=)(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*)arg[0]);
  else   (((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*)o)->operator=)(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*)arg[0]);
}

static void constructor_11161( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*)arg[0]);
  else ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*)arg[0]);
}

static void constructor_11162( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>();
  else ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>();
}

static void constructor_11163( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Electron>*)arg[1],
      *(const ::edm::Ptr<pat::Tau>*)arg[2],
      *(const ::edm::Ptr<pat::Tau>*)arg[3],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[4]);
  else ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Electron>*)arg[1],
      *(const ::edm::Ptr<pat::Tau>*)arg[2],
      *(const ::edm::Ptr<pat::Tau>*)arg[3],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[4]);
}

static  void method_11164( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*)o)->clone)());
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*)o)->clone)();
}

static  void method_11165( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_11166( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_11167( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*)o)->numberOfDaughters)());
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*)o)->numberOfDaughters)();
}

static  void method_11168( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_11169( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_11170(void*, void * o, const std::vector<void*>&, void *) {
(((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*)o)->::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>::~PATQuadFinalStateT)();
}
static void method_newdel_956( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x88( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> -------------------------------
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau__db_datamem(Reflex::Class*);
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau__datamem_bld(&__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau__db_datamem);
Reflex::GenreflexMemberBuilder __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau__funcmem_bld(&__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau__db_funcmem);
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>"), typeid(::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>), sizeof(::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6476, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>::daughter1_type"))
  .AddTypedef(type_6476, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>::daughter2_type"))
  .AddTypedef(type_7135, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>::daughter3_type"))
  .AddTypedef(type_7135, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>::daughter4_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14045, type_14047), Reflex::Literal("operator="), operator_11160, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14047), Reflex::Literal("PATQuadFinalStateT"), constructor_11161, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATQuadFinalStateT"), constructor_11162, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45636, type_45636, type_46321, type_46321, type_45406), Reflex::Literal("PATQuadFinalStateT"), constructor_11163, 0, "p1;p2;p3;p4;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATQuadFinalStateT"), destructor_11170, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_956, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x88, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau__funcmem_bld);
}

//------Delayed data member builder for class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> -------------------
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9785, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9785, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_, p2_), ::Reflex::PRIVATE)
  .AddDataMember(type_9787, Reflex::Literal("p3_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_, p3_), ::Reflex::PRIVATE)
  .AddDataMember(type_9787, Reflex::Literal("p4_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_, p4_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> -------------------
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14041), Reflex::Literal("clone"), method_11164, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_11165, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_11166, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_11167, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_11168, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_11169, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> -------------------------------
static  void operator_11261( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*)o)->operator=)(*(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*)arg[0]);
  else   (((::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*)o)->operator=)(*(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*)arg[0]);
}

static void constructor_11262( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>(*(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*)arg[0]);
  else ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>(*(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*)arg[0]);
}

static void constructor_11263( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>();
  else ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>();
}

static void constructor_11264( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Muon>*)arg[1],
      *(const ::edm::Ptr<pat::Tau>*)arg[2],
      *(const ::edm::Ptr<pat::Tau>*)arg[3],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[4]);
  else ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Muon>*)arg[1],
      *(const ::edm::Ptr<pat::Tau>*)arg[2],
      *(const ::edm::Ptr<pat::Tau>*)arg[3],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[4]);
}

static  void method_11265( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*)o)->clone)());
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*)o)->clone)();
}

static  void method_11266( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_11267( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_11268( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*)o)->numberOfDaughters)());
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*)o)->numberOfDaughters)();
}

static  void method_11269( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_11270( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_11271(void*, void * o, const std::vector<void*>&, void *) {
(((::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*)o)->::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>::~PATQuadFinalStateT)();
}
static void method_newdel_1022( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x90( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> -------------------------------
void __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau__db_datamem(Reflex::Class*);
void __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau__datamem_bld(&__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau__db_datamem);
Reflex::GenreflexMemberBuilder __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau__funcmem_bld(&__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau__db_funcmem);
void __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>"), typeid(::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>), sizeof(::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6476, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>::daughter1_type"))
  .AddTypedef(type_6497, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>::daughter2_type"))
  .AddTypedef(type_7135, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>::daughter3_type"))
  .AddTypedef(type_7135, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>::daughter4_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18467, type_18469), Reflex::Literal("operator="), operator_11261, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18469), Reflex::Literal("PATQuadFinalStateT"), constructor_11262, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATQuadFinalStateT"), constructor_11263, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45636, type_45727, type_46321, type_46321, type_45406), Reflex::Literal("PATQuadFinalStateT"), constructor_11264, 0, "p1;p2;p3;p4;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATQuadFinalStateT"), destructor_11271, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1022, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x90, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau__funcmem_bld);
}

//------Delayed data member builder for class PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> -------------------
void __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9785, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9782, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_, p2_), ::Reflex::PRIVATE)
  .AddDataMember(type_9787, Reflex::Literal("p3_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_, p3_), ::Reflex::PRIVATE)
  .AddDataMember(type_9787, Reflex::Literal("p4_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_, p4_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> -------------------
void __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18463), Reflex::Literal("clone"), method_11265, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_11266, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_11267, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_11268, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_11269, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_11270, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> -------------------------------
static  void operator_11365( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*)o)->operator=)(*(const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*)arg[0]);
  else   (((::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*)o)->operator=)(*(const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*)arg[0]);
}

static void constructor_11366( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>(*(const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*)arg[0]);
  else ::new(mem) ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>(*(const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*)arg[0]);
}

static void constructor_11367( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>();
  else ::new(mem) ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>();
}

static void constructor_11368( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>(*(const ::edm::Ptr<pat::Muon>*)arg[0],
      *(const ::edm::Ptr<pat::Muon>*)arg[1],
      *(const ::edm::Ptr<pat::Muon>*)arg[2],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[3]);
  else ::new(mem) ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>(*(const ::edm::Ptr<pat::Muon>*)arg[0],
      *(const ::edm::Ptr<pat::Muon>*)arg[1],
      *(const ::edm::Ptr<pat::Muon>*)arg[2],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[3]);
}

static  void method_11369( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*)o)->clone)());
  else   (((const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*)o)->clone)();
}

static  void method_11370( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_11371( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_11372( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*)o)->numberOfDaughters)());
  else   (((const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*)o)->numberOfDaughters)();
}

static  void method_11373( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_11374( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_11375(void*, void * o, const std::vector<void*>&, void *) {
(((::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*)o)->::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>::~PATTripletFinalStateT)();
}
static void method_newdel_1051( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x92( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> -------------------------------
void __PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon__db_datamem(Reflex::Class*);
void __PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon__datamem_bld(&__PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon__db_datamem);
Reflex::GenreflexMemberBuilder __PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon__funcmem_bld(&__PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon__db_funcmem);
void __PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>"), typeid(::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>), sizeof(::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6497, Reflex::Literal("PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>::daughter1_type"))
  .AddTypedef(type_6497, Reflex::Literal("PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>::daughter2_type"))
  .AddTypedef(type_6497, Reflex::Literal("PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>::daughter3_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17181, type_17183), Reflex::Literal("operator="), operator_11365, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17183), Reflex::Literal("PATTripletFinalStateT"), constructor_11366, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATTripletFinalStateT"), constructor_11367, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45727, type_45727, type_45727, type_45406), Reflex::Literal("PATTripletFinalStateT"), constructor_11368, 0, "p1;p2;p3;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATTripletFinalStateT"), destructor_11375, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1051, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x92, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon__funcmem_bld);
}

//------Delayed data member builder for class PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> -------------------
void __PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9782, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9782, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_, p2_), ::Reflex::PRIVATE)
  .AddDataMember(type_9782, Reflex::Literal("p3_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_, p3_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> -------------------
void __PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17177), Reflex::Literal("clone"), method_11369, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_11370, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_11371, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_11372, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_11373, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_11374, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> -------------------------------
static  void operator_11515( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*)o)->operator=)(*(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*)arg[0]);
  else   (((::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*)o)->operator=)(*(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*)arg[0]);
}

static void constructor_11516( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>(*(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*)arg[0]);
  else ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>(*(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*)arg[0]);
}

static void constructor_11517( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>();
  else ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>();
}

static void constructor_11518( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Electron>*)arg[1],
      *(const ::edm::Ptr<pat::Tau>*)arg[2],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[3]);
  else ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Electron>*)arg[1],
      *(const ::edm::Ptr<pat::Tau>*)arg[2],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[3]);
}

static  void method_11519( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*)o)->clone)());
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*)o)->clone)();
}

static  void method_11520( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_11521( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_11522( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*)o)->numberOfDaughters)());
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*)o)->numberOfDaughters)();
}

static  void method_11523( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_11524( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_11525(void*, void * o, const std::vector<void*>&, void *) {
(((::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*)o)->::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>::~PATTripletFinalStateT)();
}
static void method_newdel_1121( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x94( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> -------------------------------
void __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau__db_datamem(Reflex::Class*);
void __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau__datamem_bld(&__PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau__db_datamem);
Reflex::GenreflexMemberBuilder __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau__funcmem_bld(&__PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau__db_funcmem);
void __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>"), typeid(::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>), sizeof(::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6476, Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>::daughter1_type"))
  .AddTypedef(type_6476, Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>::daughter2_type"))
  .AddTypedef(type_7135, Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>::daughter3_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11869, type_11871), Reflex::Literal("operator="), operator_11515, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11871), Reflex::Literal("PATTripletFinalStateT"), constructor_11516, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATTripletFinalStateT"), constructor_11517, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45636, type_45636, type_46321, type_45406), Reflex::Literal("PATTripletFinalStateT"), constructor_11518, 0, "p1;p2;p3;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATTripletFinalStateT"), destructor_11525, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1121, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x94, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau__funcmem_bld);
}

//------Delayed data member builder for class PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> -------------------
void __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9785, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9785, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_, p2_), ::Reflex::PRIVATE)
  .AddDataMember(type_9787, Reflex::Literal("p3_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_, p3_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> -------------------
void __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11865), Reflex::Literal("clone"), method_11519, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_11520, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_11521, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_11522, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_11523, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_11524, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class PATPairFinalStateT<pat::Photon,pat::Photon> -------------------------------
static  void operator_11549( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATPairFinalStateT<pat::Photon,pat::Photon>*)o)->operator=)(*(const ::PATPairFinalStateT<pat::Photon,pat::Photon>*)arg[0]);
  else   (((::PATPairFinalStateT<pat::Photon,pat::Photon>*)o)->operator=)(*(const ::PATPairFinalStateT<pat::Photon,pat::Photon>*)arg[0]);
}

static void constructor_11550( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATPairFinalStateT<pat::Photon,pat::Photon>(*(const ::PATPairFinalStateT<pat::Photon,pat::Photon>*)arg[0]);
  else ::new(mem) ::PATPairFinalStateT<pat::Photon,pat::Photon>(*(const ::PATPairFinalStateT<pat::Photon,pat::Photon>*)arg[0]);
}

static void constructor_11551( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATPairFinalStateT<pat::Photon,pat::Photon>();
  else ::new(mem) ::PATPairFinalStateT<pat::Photon,pat::Photon>();
}

static void constructor_11552( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATPairFinalStateT<pat::Photon,pat::Photon>(*(const ::edm::Ptr<pat::Photon>*)arg[0],
      *(const ::edm::Ptr<pat::Photon>*)arg[1],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[2]);
  else ::new(mem) ::PATPairFinalStateT<pat::Photon,pat::Photon>(*(const ::edm::Ptr<pat::Photon>*)arg[0],
      *(const ::edm::Ptr<pat::Photon>*)arg[1],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[2]);
}

static  void method_11553( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATPairFinalStateT<pat::Photon,pat::Photon>*)o)->clone)());
  else   (((const ::PATPairFinalStateT<pat::Photon,pat::Photon>*)o)->clone)();
}

static  void method_11554( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATPairFinalStateT<pat::Photon,pat::Photon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATPairFinalStateT<pat::Photon,pat::Photon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_11555( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATPairFinalStateT<pat::Photon,pat::Photon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATPairFinalStateT<pat::Photon,pat::Photon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_11556( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATPairFinalStateT<pat::Photon,pat::Photon>*)o)->numberOfDaughters)());
  else   (((const ::PATPairFinalStateT<pat::Photon,pat::Photon>*)o)->numberOfDaughters)();
}

static  void method_11557( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATPairFinalStateT<pat::Photon,pat::Photon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATPairFinalStateT<pat::Photon,pat::Photon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_11558( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATPairFinalStateT<pat::Photon,pat::Photon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATPairFinalStateT<pat::Photon,pat::Photon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_11559(void*, void * o, const std::vector<void*>&, void *) {
(((::PATPairFinalStateT<pat::Photon,pat::Photon>*)o)->::PATPairFinalStateT<pat::Photon,pat::Photon>::~PATPairFinalStateT)();
}
static void method_newdel_1155( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Photon,pat::Photon> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Photon,pat::Photon> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Photon,pat::Photon> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Photon,pat::Photon> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Photon,pat::Photon> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x96( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Photon,pat::Photon>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Photon,pat::Photon>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Photon,pat::Photon>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Photon,pat::Photon>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATPairFinalStateT<pat::Photon,pat::Photon> -------------------------------
void __PATPairFinalStateT_pat__Photon_pat__Photon__db_datamem(Reflex::Class*);
void __PATPairFinalStateT_pat__Photon_pat__Photon__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATPairFinalStateT_pat__Photon_pat__Photon__datamem_bld(&__PATPairFinalStateT_pat__Photon_pat__Photon__db_datamem);
Reflex::GenreflexMemberBuilder __PATPairFinalStateT_pat__Photon_pat__Photon__funcmem_bld(&__PATPairFinalStateT_pat__Photon_pat__Photon__db_funcmem);
void __PATPairFinalStateT_pat__Photon_pat__Photon__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATPairFinalStateT<pat::Photon,pat::Photon>"), typeid(::PATPairFinalStateT<pat::Photon,pat::Photon>), sizeof(::PATPairFinalStateT<pat::Photon,pat::Photon>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Photon,pat::Photon>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6478, Reflex::Literal("PATPairFinalStateT<pat::Photon,pat::Photon>::daughter1_type"))
  .AddTypedef(type_6478, Reflex::Literal("PATPairFinalStateT<pat::Photon,pat::Photon>::daughter2_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11780, type_11782), Reflex::Literal("operator="), operator_11549, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11782), Reflex::Literal("PATPairFinalStateT"), constructor_11550, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATPairFinalStateT"), constructor_11551, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45637, type_45637, type_45406), Reflex::Literal("PATPairFinalStateT"), constructor_11552, 0, "p1;p2;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATPairFinalStateT"), destructor_11559, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1155, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x96, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATPairFinalStateT_pat__Photon_pat__Photon__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATPairFinalStateT_pat__Photon_pat__Photon__funcmem_bld);
}

//------Delayed data member builder for class PATPairFinalStateT<pat::Photon,pat::Photon> -------------------
void __PATPairFinalStateT_pat__Photon_pat__Photon__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9786, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATPairFinalStateT_pat__Photon_pat__Photon_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9786, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATPairFinalStateT_pat__Photon_pat__Photon_, p2_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATPairFinalStateT<pat::Photon,pat::Photon> -------------------
void __PATPairFinalStateT_pat__Photon_pat__Photon__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11776), Reflex::Literal("clone"), method_11553, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_11554, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_11555, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_11556, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_11557, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_11558, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> -------------------------------
static  void operator_12403( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*)o)->operator=)(*(const ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*)arg[0]);
  else   (((::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*)o)->operator=)(*(const ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*)arg[0]);
}

static void constructor_12404( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>(*(const ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*)arg[0]);
  else ::new(mem) ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>(*(const ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*)arg[0]);
}

static void constructor_12405( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>();
  else ::new(mem) ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>();
}

static void constructor_12406( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>(*(const ::edm::Ptr<pat::Muon>*)arg[0],
      *(const ::edm::Ptr<pat::Photon>*)arg[1],
      *(const ::edm::Ptr<pat::Photon>*)arg[2],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[3]);
  else ::new(mem) ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>(*(const ::edm::Ptr<pat::Muon>*)arg[0],
      *(const ::edm::Ptr<pat::Photon>*)arg[1],
      *(const ::edm::Ptr<pat::Photon>*)arg[2],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[3]);
}

static  void method_12407( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*)o)->clone)());
  else   (((const ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*)o)->clone)();
}

static  void method_12408( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_12409( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_12410( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*)o)->numberOfDaughters)());
  else   (((const ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*)o)->numberOfDaughters)();
}

static  void method_12411( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_12412( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_12413(void*, void * o, const std::vector<void*>&, void *) {
(((::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*)o)->::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>::~PATTripletFinalStateT)();
}
static void method_newdel_1517( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x98( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> -------------------------------
void __PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon__db_datamem(Reflex::Class*);
void __PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon__datamem_bld(&__PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon__db_datamem);
Reflex::GenreflexMemberBuilder __PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon__funcmem_bld(&__PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon__db_funcmem);
void __PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>"), typeid(::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>), sizeof(::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6497, Reflex::Literal("PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>::daughter1_type"))
  .AddTypedef(type_6478, Reflex::Literal("PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>::daughter2_type"))
  .AddTypedef(type_6478, Reflex::Literal("PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>::daughter3_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11569, type_11571), Reflex::Literal("operator="), operator_12403, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11571), Reflex::Literal("PATTripletFinalStateT"), constructor_12404, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATTripletFinalStateT"), constructor_12405, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45727, type_45637, type_45637, type_45406), Reflex::Literal("PATTripletFinalStateT"), constructor_12406, 0, "p1;p2;p3;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATTripletFinalStateT"), destructor_12413, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1517, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x98, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon__funcmem_bld);
}

//------Delayed data member builder for class PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> -------------------
void __PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9782, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9786, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_, p2_), ::Reflex::PRIVATE)
  .AddDataMember(type_9786, Reflex::Literal("p3_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_, p3_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> -------------------
void __PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11565), Reflex::Literal("clone"), method_12407, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_12408, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_12409, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_12410, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_12411, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_12412, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class vector<PATTripletFinalStateT<pat::Muon, pat::Photon, pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Muon, pat::Photon, pat::Photon> > > -------------------------------
static void constructor_11582( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >();
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >();
}

static void constructor_11583( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >(*(const ::std::allocator<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >(*(const ::std::allocator<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)arg[0]);
}

static void constructor_11584( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*)arg[1]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*)arg[1],
      *(const ::std::allocator<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)arg[2]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*)arg[1],
      *(const ::std::allocator<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)arg[2]);
  }
}

static void constructor_11585( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >(*(const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >(*(const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)arg[0]);
}

static void destructor_11586(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >::~vector)();
}
static  void operator_11587( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->operator=)(*(const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->operator=)(*(const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)arg[0]);
}

static  void method_11588( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*)arg[1]);
}

static  void method_11589( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >)((((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->begin)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->begin)();
}

static  void method_11590( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >)((((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->begin)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->begin)();
}

static  void method_11591( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >)((((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->end)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->end)();
}

static  void method_11592( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >)((((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->end)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->end)();
}

static  void method_11597( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->size)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->size)();
}

static  void method_11598( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->max_size)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->max_size)();
}

static  void method_11599( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*)arg[1]);
  }
}

static  void method_11600( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->capacity)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->capacity)();
}

static  void method_11601( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->empty)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->empty)();
}

static  void method_11602( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_11603( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_11604( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_11606( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_11607( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_11608( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->front)();
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->front)();
}

static  void method_11609( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->front)();
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->front)();
}

static  void method_11610( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->back)();
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->back)();
}

static  void method_11611( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->back)();
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->back)();
}

static  void method_11612( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->data)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->data)();
}

static  void method_11613( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->data)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->data)();
}

static  void method_11614( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->push_back)(*(const ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*)arg[0]);
}

static  void method_11615( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->pop_back)();
}

static  void method_11616( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >)((((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*)arg[1]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*)arg[1]);
}

static  void method_11617( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*)arg[2]);
}

static  void method_11618( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >)((((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >*)arg[0]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >*)arg[0]);
}

static  void method_11619( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >)((((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >*)arg[1]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >*)arg[1]);
}

static  void method_11620( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->swap)(*(::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)arg[0]);
}

static  void method_11621( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->clear)();
}

static void method_newdel_1163( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x100( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >")), ::Reflex::BaseOffset< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >,::std::_Vector_base<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x101( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >::Generate();
}

//------Dictionary for class vector<PATTripletFinalStateT<pat::Muon, pat::Photon, pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Muon, pat::Photon, pat::Photon> > > -------------------------------
void __std__vector_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s__db_datamem(Reflex::Class*);
void __std__vector_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s__datamem_bld(&__std__vector_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s__funcmem_bld(&__std__vector_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s__db_funcmem);
void __std__vector_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >"), typeid(::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >), sizeof(::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3706, ::Reflex::BaseOffset< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >, ::std::_Vector_base<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1517, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >::_Alloc_value_type"))
  .AddTypedef(type_3706, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >::_Base"))
  .AddTypedef(type_5061, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >::_Tp_alloc_type"))
  .AddTypedef(type_1517, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >::value_type"))
  .AddTypedef(type_11565, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >::pointer"))
  .AddTypedef(type_11567, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >::const_pointer"))
  .AddTypedef(type_11569, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >::reference"))
  .AddTypedef(type_11571, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >::const_reference"))
  .AddTypedef(type_11573, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >::iterator"))
  .AddTypedef(type_11575, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >::const_iterator"))
  .AddTypedef(type_5665, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >::const_reverse_iterator"))
  .AddTypedef(type_5666, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >::difference_type"))
  .AddTypedef(type_5061, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_11582, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_59757), Reflex::Literal("vector"), constructor_11583, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_11571, type_59757), Reflex::Literal("vector"), constructor_11584, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_59758), Reflex::Literal("vector"), constructor_11585, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_11586, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1163, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x100, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x101, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATTripletFinalStateT<pat::Muon, pat::Photon, pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Muon, pat::Photon, pat::Photon> > > -------------------
void __std__vector_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATTripletFinalStateT<pat::Muon, pat::Photon, pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Muon, pat::Photon, pat::Photon> > > -------------------
void __std__vector_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_59759, type_59758), Reflex::Literal("operator="), operator_11587, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_11571), Reflex::Literal("assign"), method_11588, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11573), Reflex::Literal("begin"), method_11589, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11575), Reflex::Literal("begin"), method_11590, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11573), Reflex::Literal("end"), method_11591, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11575), Reflex::Literal("end"), method_11592, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_11597, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_11598, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_1517), Reflex::Literal("resize"), method_11599, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_11600, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_11601, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_11602, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11569, type_5015), Reflex::Literal("operator[]"), operator_11603, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11571, type_5015), Reflex::Literal("operator[]"), operator_11604, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11569, type_5015), Reflex::Literal("at"), method_11606, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11571, type_5015), Reflex::Literal("at"), method_11607, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11569), Reflex::Literal("front"), method_11608, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11571), Reflex::Literal("front"), method_11609, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11569), Reflex::Literal("back"), method_11610, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11571), Reflex::Literal("back"), method_11611, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11565), Reflex::Literal("data"), method_11612, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11567), Reflex::Literal("data"), method_11613, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_11571), Reflex::Literal("push_back"), method_11614, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_11615, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11573, type_11573, type_11571), Reflex::Literal("insert"), method_11616, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_11573, type_5015, type_11571), Reflex::Literal("insert"), method_11617, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11573, type_11573), Reflex::Literal("erase"), method_11618, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11573, type_11573, type_11573), Reflex::Literal("erase"), method_11619, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_59759), Reflex::Literal("swap"), method_11620, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_11621, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<PATPairFinalStateT<pat::Photon, pat::Photon>,std::allocator<PATPairFinalStateT<pat::Photon, pat::Photon> > > -------------------------------
static void constructor_11793( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >();
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >();
}

static void constructor_11794( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >(*(const ::std::allocator<PATPairFinalStateT<pat::Photon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >(*(const ::std::allocator<PATPairFinalStateT<pat::Photon,pat::Photon> >*)arg[0]);
}

static void constructor_11795( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Photon,pat::Photon>*)arg[1]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Photon,pat::Photon>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Photon,pat::Photon>*)arg[1],
      *(const ::std::allocator<PATPairFinalStateT<pat::Photon,pat::Photon> >*)arg[2]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Photon,pat::Photon>*)arg[1],
      *(const ::std::allocator<PATPairFinalStateT<pat::Photon,pat::Photon> >*)arg[2]);
  }
}

static void constructor_11796( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >(*(const ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >(*(const ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)arg[0]);
}

static void destructor_11797(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >::~vector)();
}
static  void operator_11798( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->operator=)(*(const ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)arg[0]);
  else   (((::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->operator=)(*(const ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)arg[0]);
}

static  void method_11799( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATPairFinalStateT<pat::Photon,pat::Photon>*)arg[1]);
}

static  void method_11800( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Photon,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >)((((::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->begin)());
  else   (((::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->begin)();
}

static  void method_11801( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Photon,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >)((((const ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->begin)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->begin)();
}

static  void method_11802( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Photon,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >)((((::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->end)());
  else   (((::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->end)();
}

static  void method_11803( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Photon,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >)((((const ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->end)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->end)();
}

static  void method_11808( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->size)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->size)();
}

static  void method_11809( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->max_size)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->max_size)();
}

static  void method_11810( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATPairFinalStateT<pat::Photon,pat::Photon>*)arg[1]);
  }
}

static  void method_11811( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->capacity)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->capacity)();
}

static  void method_11812( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->empty)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->empty)();
}

static  void method_11813( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_11814( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_11815( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_11817( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_11818( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_11819( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->front)();
  else   (((::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->front)();
}

static  void method_11820( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->front)();
  else   (((const ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->front)();
}

static  void method_11821( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->back)();
  else   (((::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->back)();
}

static  void method_11822( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->back)();
  else   (((const ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->back)();
}

static  void method_11823( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->data)());
  else   (((::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->data)();
}

static  void method_11824( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->data)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->data)();
}

static  void method_11825( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->push_back)(*(const ::PATPairFinalStateT<pat::Photon,pat::Photon>*)arg[0]);
}

static  void method_11826( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->pop_back)();
}

static  void method_11827( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Photon,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >)((((::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Photon,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >*)arg[0],
    *(const ::PATPairFinalStateT<pat::Photon,pat::Photon>*)arg[1]));
  else   (((::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Photon,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >*)arg[0],
    *(const ::PATPairFinalStateT<pat::Photon,pat::Photon>*)arg[1]);
}

static  void method_11828( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Photon,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATPairFinalStateT<pat::Photon,pat::Photon>*)arg[2]);
}

static  void method_11829( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Photon,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >)((((::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Photon,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >*)arg[0]));
  else   (((::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Photon,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >*)arg[0]);
}

static  void method_11830( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Photon,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >)((((::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Photon,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Photon,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >*)arg[1]));
  else   (((::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Photon,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Photon,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >*)arg[1]);
}

static  void method_11831( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->swap)(*(::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)arg[0]);
}

static  void method_11832( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->clear)();
}

static void method_newdel_1251( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x103( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATPairFinalStateT<pat::Photon,pat::Photon>,std::allocator<PATPairFinalStateT<pat::Photon,pat::Photon> > >")), ::Reflex::BaseOffset< ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >,::std::_Vector_base<PATPairFinalStateT<pat::Photon,pat::Photon>,std::allocator<PATPairFinalStateT<pat::Photon,pat::Photon> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x104( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >::Generate();
}

//------Dictionary for class vector<PATPairFinalStateT<pat::Photon, pat::Photon>,std::allocator<PATPairFinalStateT<pat::Photon, pat::Photon> > > -------------------------------
void __std__vector_PATPairFinalStateT_pat__Photon_pat__Photon_s__db_datamem(Reflex::Class*);
void __std__vector_PATPairFinalStateT_pat__Photon_pat__Photon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATPairFinalStateT_pat__Photon_pat__Photon_s__datamem_bld(&__std__vector_PATPairFinalStateT_pat__Photon_pat__Photon_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATPairFinalStateT_pat__Photon_pat__Photon_s__funcmem_bld(&__std__vector_PATPairFinalStateT_pat__Photon_pat__Photon_s__db_funcmem);
void __std__vector_PATPairFinalStateT_pat__Photon_pat__Photon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >"), typeid(::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >), sizeof(::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3722, ::Reflex::BaseOffset< ::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >, ::std::_Vector_base<PATPairFinalStateT<pat::Photon,pat::Photon>,std::allocator<PATPairFinalStateT<pat::Photon,pat::Photon> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1155, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >::_Alloc_value_type"))
  .AddTypedef(type_3722, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >::_Base"))
  .AddTypedef(type_5077, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >::_Tp_alloc_type"))
  .AddTypedef(type_1155, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >::value_type"))
  .AddTypedef(type_11776, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >::pointer"))
  .AddTypedef(type_11778, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >::const_pointer"))
  .AddTypedef(type_11780, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >::reference"))
  .AddTypedef(type_11782, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >::const_reference"))
  .AddTypedef(type_11784, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >::iterator"))
  .AddTypedef(type_11786, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >::const_iterator"))
  .AddTypedef(type_5697, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >::const_reverse_iterator"))
  .AddTypedef(type_5698, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >::difference_type"))
  .AddTypedef(type_5077, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_11793, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_59784), Reflex::Literal("vector"), constructor_11794, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_11782, type_59784), Reflex::Literal("vector"), constructor_11795, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_59785), Reflex::Literal("vector"), constructor_11796, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_11797, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1251, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x103, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x104, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATPairFinalStateT_pat__Photon_pat__Photon_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATPairFinalStateT<pat::Photon, pat::Photon>,std::allocator<PATPairFinalStateT<pat::Photon, pat::Photon> > > -------------------
void __std__vector_PATPairFinalStateT_pat__Photon_pat__Photon_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATPairFinalStateT<pat::Photon, pat::Photon>,std::allocator<PATPairFinalStateT<pat::Photon, pat::Photon> > > -------------------
void __std__vector_PATPairFinalStateT_pat__Photon_pat__Photon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_59786, type_59785), Reflex::Literal("operator="), operator_11798, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_11782), Reflex::Literal("assign"), method_11799, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11784), Reflex::Literal("begin"), method_11800, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11786), Reflex::Literal("begin"), method_11801, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11784), Reflex::Literal("end"), method_11802, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11786), Reflex::Literal("end"), method_11803, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_11808, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_11809, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_1155), Reflex::Literal("resize"), method_11810, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_11811, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_11812, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_11813, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11780, type_5015), Reflex::Literal("operator[]"), operator_11814, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11782, type_5015), Reflex::Literal("operator[]"), operator_11815, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11780, type_5015), Reflex::Literal("at"), method_11817, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11782, type_5015), Reflex::Literal("at"), method_11818, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11780), Reflex::Literal("front"), method_11819, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11782), Reflex::Literal("front"), method_11820, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11780), Reflex::Literal("back"), method_11821, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11782), Reflex::Literal("back"), method_11822, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11776), Reflex::Literal("data"), method_11823, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11778), Reflex::Literal("data"), method_11824, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_11782), Reflex::Literal("push_back"), method_11825, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_11826, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11784, type_11784, type_11782), Reflex::Literal("insert"), method_11827, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_11784, type_5015, type_11782), Reflex::Literal("insert"), method_11828, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11784, type_11784), Reflex::Literal("erase"), method_11829, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11784, type_11784, type_11784), Reflex::Literal("erase"), method_11830, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_59786), Reflex::Literal("swap"), method_11831, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_11832, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Tau> > > -------------------------------
static void constructor_11882( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >();
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >();
}

static void constructor_11883( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >(*(const ::std::allocator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >(*(const ::std::allocator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)arg[0]);
}

static void constructor_11884( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*)arg[1]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*)arg[1],
      *(const ::std::allocator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)arg[2]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*)arg[1],
      *(const ::std::allocator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)arg[2]);
  }
}

static void constructor_11885( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >(*(const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >(*(const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)arg[0]);
}

static void destructor_11886(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >::~vector)();
}
static  void operator_11887( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->operator=)(*(const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->operator=)(*(const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)arg[0]);
}

static  void method_11888( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*)arg[1]);
}

static  void method_11889( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->begin)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->begin)();
}

static  void method_11890( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->begin)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->begin)();
}

static  void method_11891( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->end)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->end)();
}

static  void method_11892( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->end)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->end)();
}

static  void method_11897( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->size)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->size)();
}

static  void method_11898( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->max_size)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->max_size)();
}

static  void method_11899( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*)arg[1]);
  }
}

static  void method_11900( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->capacity)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->capacity)();
}

static  void method_11901( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->empty)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->empty)();
}

static  void method_11902( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_11903( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_11904( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_11906( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_11907( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_11908( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->front)();
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->front)();
}

static  void method_11909( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->front)();
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->front)();
}

static  void method_11910( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->back)();
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->back)();
}

static  void method_11911( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->back)();
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->back)();
}

static  void method_11912( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->data)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->data)();
}

static  void method_11913( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->data)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->data)();
}

static  void method_11914( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->push_back)(*(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*)arg[0]);
}

static  void method_11915( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->pop_back)();
}

static  void method_11916( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*)arg[1]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*)arg[1]);
}

static  void method_11917( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*)arg[2]);
}

static  void method_11918( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >*)arg[0]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >*)arg[0]);
}

static  void method_11919( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >*)arg[1]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >*)arg[1]);
}

static  void method_11920( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->swap)(*(::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)arg[0]);
}

static  void method_11921( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->clear)();
}

static void method_newdel_1270( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x106( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >")), ::Reflex::BaseOffset< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >,::std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x107( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >::Generate();
}

//------Dictionary for class vector<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Tau> > > -------------------------------
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s__db_datamem(Reflex::Class*);
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s__datamem_bld(&__std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s__funcmem_bld(&__std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s__db_funcmem);
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >"), typeid(::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >), sizeof(::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3717, ::Reflex::BaseOffset< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >, ::std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1121, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >::_Alloc_value_type"))
  .AddTypedef(type_3717, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >::_Base"))
  .AddTypedef(type_5072, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >::_Tp_alloc_type"))
  .AddTypedef(type_1121, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >::value_type"))
  .AddTypedef(type_11865, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >::pointer"))
  .AddTypedef(type_11867, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >::const_pointer"))
  .AddTypedef(type_11869, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >::reference"))
  .AddTypedef(type_11871, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >::const_reference"))
  .AddTypedef(type_11873, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >::iterator"))
  .AddTypedef(type_11875, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >::const_iterator"))
  .AddTypedef(type_5687, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >::const_reverse_iterator"))
  .AddTypedef(type_5688, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >::difference_type"))
  .AddTypedef(type_5072, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_11882, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_59788), Reflex::Literal("vector"), constructor_11883, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_11871, type_59788), Reflex::Literal("vector"), constructor_11884, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_59789), Reflex::Literal("vector"), constructor_11885, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_11886, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1270, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x106, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x107, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Tau> > > -------------------
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Tau> > > -------------------
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_59790, type_59789), Reflex::Literal("operator="), operator_11887, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_11871), Reflex::Literal("assign"), method_11888, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11873), Reflex::Literal("begin"), method_11889, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11875), Reflex::Literal("begin"), method_11890, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11873), Reflex::Literal("end"), method_11891, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11875), Reflex::Literal("end"), method_11892, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_11897, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_11898, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_1121), Reflex::Literal("resize"), method_11899, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_11900, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_11901, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_11902, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11869, type_5015), Reflex::Literal("operator[]"), operator_11903, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11871, type_5015), Reflex::Literal("operator[]"), operator_11904, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11869, type_5015), Reflex::Literal("at"), method_11906, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11871, type_5015), Reflex::Literal("at"), method_11907, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11869), Reflex::Literal("front"), method_11908, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11871), Reflex::Literal("front"), method_11909, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11869), Reflex::Literal("back"), method_11910, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11871), Reflex::Literal("back"), method_11911, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11865), Reflex::Literal("data"), method_11912, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11867), Reflex::Literal("data"), method_11913, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_11871), Reflex::Literal("push_back"), method_11914, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_11915, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11873, type_11873, type_11871), Reflex::Literal("insert"), method_11916, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_11873, type_5015, type_11871), Reflex::Literal("insert"), method_11917, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11873, type_11873), Reflex::Literal("erase"), method_11918, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11873, type_11873, type_11873), Reflex::Literal("erase"), method_11919, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_59790), Reflex::Literal("swap"), method_11920, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_11921, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Tau> > > -------------------------------
static void constructor_11968( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >();
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >();
}

static void constructor_11969( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >(*(const ::std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >(*(const ::std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)arg[0]);
}

static void constructor_11970( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*)arg[1]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*)arg[1],
      *(const ::std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)arg[2]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*)arg[1],
      *(const ::std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)arg[2]);
  }
}

static void constructor_11971( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >(*(const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >(*(const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)arg[0]);
}

static void destructor_11972(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >::~vector)();
}
static  void operator_11973( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->operator=)(*(const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->operator=)(*(const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)arg[0]);
}

static  void method_11974( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*)arg[1]);
}

static  void method_11975( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >)((((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->begin)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->begin)();
}

static  void method_11976( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >)((((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->begin)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->begin)();
}

static  void method_11977( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >)((((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->end)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->end)();
}

static  void method_11978( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >)((((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->end)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->end)();
}

static  void method_11983( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->size)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->size)();
}

static  void method_11984( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->max_size)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->max_size)();
}

static  void method_11985( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*)arg[1]);
  }
}

static  void method_11986( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->capacity)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->capacity)();
}

static  void method_11987( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->empty)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->empty)();
}

static  void method_11988( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_11989( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_11990( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_11992( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_11993( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_11994( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->front)();
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->front)();
}

static  void method_11995( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->front)();
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->front)();
}

static  void method_11996( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->back)();
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->back)();
}

static  void method_11997( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->back)();
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->back)();
}

static  void method_11998( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->data)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->data)();
}

static  void method_11999( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->data)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->data)();
}

static  void method_12000( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->push_back)(*(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*)arg[0]);
}

static  void method_12001( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->pop_back)();
}

static  void method_12002( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >)((((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*)arg[1]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*)arg[1]);
}

static  void method_12003( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*)arg[2]);
}

static  void method_12004( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >)((((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >*)arg[0]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >*)arg[0]);
}

static  void method_12005( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >)((((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >*)arg[1]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >*)arg[1]);
}

static  void method_12006( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->swap)(*(::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)arg[0]);
}

static  void method_12007( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->clear)();
}

static void method_newdel_1303( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x109( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >")), ::Reflex::BaseOffset< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >,::std::_Vector_base<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x110( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >::Generate();
}

//------Dictionary for class vector<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Tau> > > -------------------------------
void __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s__db_datamem(Reflex::Class*);
void __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s__datamem_bld(&__std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s__funcmem_bld(&__std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s__db_funcmem);
void __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >"), typeid(::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >), sizeof(::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3689, ::Reflex::BaseOffset< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >, ::std::_Vector_base<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_308, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >::_Alloc_value_type"))
  .AddTypedef(type_3689, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >::_Base"))
  .AddTypedef(type_5044, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >::_Tp_alloc_type"))
  .AddTypedef(type_308, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >::value_type"))
  .AddTypedef(type_11951, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >::pointer"))
  .AddTypedef(type_11953, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >::const_pointer"))
  .AddTypedef(type_11955, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >::reference"))
  .AddTypedef(type_11957, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >::const_reference"))
  .AddTypedef(type_11959, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >::iterator"))
  .AddTypedef(type_11961, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >::const_iterator"))
  .AddTypedef(type_5631, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >::const_reverse_iterator"))
  .AddTypedef(type_5632, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >::difference_type"))
  .AddTypedef(type_5044, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_11968, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_59799), Reflex::Literal("vector"), constructor_11969, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_11957, type_59799), Reflex::Literal("vector"), constructor_11970, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_59800), Reflex::Literal("vector"), constructor_11971, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_11972, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1303, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x109, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x110, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Tau> > > -------------------
void __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Tau> > > -------------------
void __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_59801, type_59800), Reflex::Literal("operator="), operator_11973, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_11957), Reflex::Literal("assign"), method_11974, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11959), Reflex::Literal("begin"), method_11975, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11961), Reflex::Literal("begin"), method_11976, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11959), Reflex::Literal("end"), method_11977, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11961), Reflex::Literal("end"), method_11978, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_11983, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_11984, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_308), Reflex::Literal("resize"), method_11985, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_11986, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_11987, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_11988, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11955, type_5015), Reflex::Literal("operator[]"), operator_11989, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11957, type_5015), Reflex::Literal("operator[]"), operator_11990, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11955, type_5015), Reflex::Literal("at"), method_11992, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11957, type_5015), Reflex::Literal("at"), method_11993, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11955), Reflex::Literal("front"), method_11994, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11957), Reflex::Literal("front"), method_11995, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11955), Reflex::Literal("back"), method_11996, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11957), Reflex::Literal("back"), method_11997, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11951), Reflex::Literal("data"), method_11998, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11953), Reflex::Literal("data"), method_11999, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_11957), Reflex::Literal("push_back"), method_12000, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_12001, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11959, type_11959, type_11957), Reflex::Literal("insert"), method_12002, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_11959, type_5015, type_11957), Reflex::Literal("insert"), method_12003, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11959, type_11959), Reflex::Literal("erase"), method_12004, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11959, type_11959, type_11959), Reflex::Literal("erase"), method_12005, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_59801), Reflex::Literal("swap"), method_12006, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_12007, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<PATTripletFinalStateT<pat::Electron, pat::Tau, pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Electron, pat::Tau, pat::Tau> > > -------------------------------
static void constructor_12077( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >();
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >();
}

static void constructor_12078( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >(*(const ::std::allocator<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >(*(const ::std::allocator<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)arg[0]);
}

static void constructor_12079( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*)arg[1]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*)arg[1],
      *(const ::std::allocator<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)arg[2]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*)arg[1],
      *(const ::std::allocator<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)arg[2]);
  }
}

static void constructor_12080( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >(*(const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >(*(const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)arg[0]);
}

static void destructor_12081(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >::~vector)();
}
static  void operator_12082( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->operator=)(*(const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->operator=)(*(const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)arg[0]);
}

static  void method_12083( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*)arg[1]);
}

static  void method_12084( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->begin)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->begin)();
}

static  void method_12085( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->begin)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->begin)();
}

static  void method_12086( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->end)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->end)();
}

static  void method_12087( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->end)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->end)();
}

static  void method_12092( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->size)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->size)();
}

static  void method_12093( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->max_size)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->max_size)();
}

static  void method_12094( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*)arg[1]);
  }
}

static  void method_12095( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->capacity)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->capacity)();
}

static  void method_12096( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->empty)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->empty)();
}

static  void method_12097( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_12098( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_12099( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_12101( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_12102( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_12103( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->front)();
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->front)();
}

static  void method_12104( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->front)();
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->front)();
}

static  void method_12105( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->back)();
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->back)();
}

static  void method_12106( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->back)();
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->back)();
}

static  void method_12107( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->data)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->data)();
}

static  void method_12108( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->data)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->data)();
}

static  void method_12109( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->push_back)(*(const ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*)arg[0]);
}

static  void method_12110( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->pop_back)();
}

static  void method_12111( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*)arg[1]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*)arg[1]);
}

static  void method_12112( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*)arg[2]);
}

static  void method_12113( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >*)arg[0]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >*)arg[0]);
}

static  void method_12114( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >*)arg[1]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >*)arg[1]);
}

static  void method_12115( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->swap)(*(::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)arg[0]);
}

static  void method_12116( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->clear)();
}

static void method_newdel_1352( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x112( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >")), ::Reflex::BaseOffset< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >,::std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x113( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >::Generate();
}

//------Dictionary for class vector<PATTripletFinalStateT<pat::Electron, pat::Tau, pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Electron, pat::Tau, pat::Tau> > > -------------------------------
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s__db_datamem(Reflex::Class*);
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s__datamem_bld(&__std__vector_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s__funcmem_bld(&__std__vector_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s__db_funcmem);
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >"), typeid(::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >), sizeof(::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3712, ::Reflex::BaseOffset< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >, ::std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_716, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >::_Alloc_value_type"))
  .AddTypedef(type_3712, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >::_Base"))
  .AddTypedef(type_5067, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >::_Tp_alloc_type"))
  .AddTypedef(type_716, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >::value_type"))
  .AddTypedef(type_12060, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >::pointer"))
  .AddTypedef(type_12062, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >::const_pointer"))
  .AddTypedef(type_12064, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >::reference"))
  .AddTypedef(type_12066, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >::const_reference"))
  .AddTypedef(type_12068, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >::iterator"))
  .AddTypedef(type_12070, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >::const_iterator"))
  .AddTypedef(type_5677, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >::const_reverse_iterator"))
  .AddTypedef(type_5678, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >::difference_type"))
  .AddTypedef(type_5067, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_12077, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_59804), Reflex::Literal("vector"), constructor_12078, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_12066, type_59804), Reflex::Literal("vector"), constructor_12079, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_59805), Reflex::Literal("vector"), constructor_12080, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_12081, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1352, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x112, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x113, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATTripletFinalStateT<pat::Electron, pat::Tau, pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Electron, pat::Tau, pat::Tau> > > -------------------
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATTripletFinalStateT<pat::Electron, pat::Tau, pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Electron, pat::Tau, pat::Tau> > > -------------------
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_59806, type_59805), Reflex::Literal("operator="), operator_12082, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_12066), Reflex::Literal("assign"), method_12083, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12068), Reflex::Literal("begin"), method_12084, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12070), Reflex::Literal("begin"), method_12085, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12068), Reflex::Literal("end"), method_12086, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12070), Reflex::Literal("end"), method_12087, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_12092, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_12093, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_716), Reflex::Literal("resize"), method_12094, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_12095, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_12096, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_12097, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12064, type_5015), Reflex::Literal("operator[]"), operator_12098, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12066, type_5015), Reflex::Literal("operator[]"), operator_12099, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12064, type_5015), Reflex::Literal("at"), method_12101, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12066, type_5015), Reflex::Literal("at"), method_12102, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12064), Reflex::Literal("front"), method_12103, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12066), Reflex::Literal("front"), method_12104, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12064), Reflex::Literal("back"), method_12105, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12066), Reflex::Literal("back"), method_12106, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12060), Reflex::Literal("data"), method_12107, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12062), Reflex::Literal("data"), method_12108, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_12066), Reflex::Literal("push_back"), method_12109, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_12110, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12068, type_12068, type_12066), Reflex::Literal("insert"), method_12111, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_12068, type_5015, type_12066), Reflex::Literal("insert"), method_12112, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12068, type_12068), Reflex::Literal("erase"), method_12113, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12068, type_12068, type_12068), Reflex::Literal("erase"), method_12114, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_59806), Reflex::Literal("swap"), method_12115, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_12116, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> -------------------------------
static  void operator_16372( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*)o)->operator=)(*(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*)arg[0]);
  else   (((::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*)o)->operator=)(*(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*)arg[0]);
}

static void constructor_16373( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>(*(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*)arg[0]);
  else ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>(*(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*)arg[0]);
}

static void constructor_16374( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>();
  else ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>();
}

static void constructor_16375( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Muon>*)arg[1],
      *(const ::edm::Ptr<pat::Muon>*)arg[2],
      *(const ::edm::Ptr<pat::Tau>*)arg[3],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[4]);
  else ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Muon>*)arg[1],
      *(const ::edm::Ptr<pat::Muon>*)arg[2],
      *(const ::edm::Ptr<pat::Tau>*)arg[3],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[4]);
}

static  void method_16376( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*)o)->clone)());
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*)o)->clone)();
}

static  void method_16377( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_16378( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_16379( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*)o)->numberOfDaughters)());
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*)o)->numberOfDaughters)();
}

static  void method_16380( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_16381( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_16382(void*, void * o, const std::vector<void*>&, void *) {
(((::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*)o)->::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>::~PATQuadFinalStateT)();
}
static void method_newdel_2810( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x115( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> -------------------------------
void __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau__db_datamem(Reflex::Class*);
void __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau__datamem_bld(&__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau__db_datamem);
Reflex::GenreflexMemberBuilder __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau__funcmem_bld(&__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau__db_funcmem);
void __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>"), typeid(::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>), sizeof(::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6476, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>::daughter1_type"))
  .AddTypedef(type_6497, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>::daughter2_type"))
  .AddTypedef(type_6497, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>::daughter3_type"))
  .AddTypedef(type_7135, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>::daughter4_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12144, type_12146), Reflex::Literal("operator="), operator_16372, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12146), Reflex::Literal("PATQuadFinalStateT"), constructor_16373, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATQuadFinalStateT"), constructor_16374, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45636, type_45727, type_45727, type_46321, type_45406), Reflex::Literal("PATQuadFinalStateT"), constructor_16375, 0, "p1;p2;p3;p4;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATQuadFinalStateT"), destructor_16382, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2810, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x115, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau__funcmem_bld);
}

//------Delayed data member builder for class PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> -------------------
void __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9785, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9782, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_, p2_), ::Reflex::PRIVATE)
  .AddDataMember(type_9782, Reflex::Literal("p3_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_, p3_), ::Reflex::PRIVATE)
  .AddDataMember(type_9787, Reflex::Literal("p4_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_, p4_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> -------------------
void __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12140), Reflex::Literal("clone"), method_16376, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_16377, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_16378, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_16379, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_16380, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_16381, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class vector<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Tau> > > -------------------------------
static void constructor_12157( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >();
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >();
}

static void constructor_12158( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >(*(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >(*(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)arg[0]);
}

static void constructor_12159( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*)arg[1]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*)arg[1],
      *(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)arg[2]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*)arg[1],
      *(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)arg[2]);
  }
}

static void constructor_12160( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)arg[0]);
}

static void destructor_12161(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >::~vector)();
}
static  void operator_12162( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->operator=)(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->operator=)(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)arg[0]);
}

static  void method_12163( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*)arg[1]);
}

static  void method_12164( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->begin)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->begin)();
}

static  void method_12165( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->begin)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->begin)();
}

static  void method_12166( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->end)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->end)();
}

static  void method_12167( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->end)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->end)();
}

static  void method_12172( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->size)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->size)();
}

static  void method_12173( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->max_size)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->max_size)();
}

static  void method_12174( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*)arg[1]);
  }
}

static  void method_12175( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->capacity)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->capacity)();
}

static  void method_12176( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->empty)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->empty)();
}

static  void method_12177( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_12178( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_12179( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_12181( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_12182( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_12183( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->front)();
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->front)();
}

static  void method_12184( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->front)();
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->front)();
}

static  void method_12185( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->back)();
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->back)();
}

static  void method_12186( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->back)();
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->back)();
}

static  void method_12187( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->data)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->data)();
}

static  void method_12188( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->data)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->data)();
}

static  void method_12189( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->push_back)(*(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*)arg[0]);
}

static  void method_12190( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->pop_back)();
}

static  void method_12191( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*)arg[1]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*)arg[1]);
}

static  void method_12192( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*)arg[2]);
}

static  void method_12193( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >*)arg[0]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >*)arg[0]);
}

static  void method_12194( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >*)arg[1]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >*)arg[1]);
}

static  void method_12195( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->swap)(*(::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)arg[0]);
}

static  void method_12196( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->clear)();
}

static void method_newdel_1381( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x117( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >")), ::Reflex::BaseOffset< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >,::std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x118( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >::Generate();
}

//------Dictionary for class vector<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Tau> > > -------------------------------
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s__db_datamem(Reflex::Class*);
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s__datamem_bld(&__std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s__funcmem_bld(&__std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s__db_funcmem);
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >"), typeid(::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >), sizeof(::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3694, ::Reflex::BaseOffset< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >, ::std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2810, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >::_Alloc_value_type"))
  .AddTypedef(type_3694, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >::_Base"))
  .AddTypedef(type_5049, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >::_Tp_alloc_type"))
  .AddTypedef(type_2810, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >::value_type"))
  .AddTypedef(type_12140, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >::pointer"))
  .AddTypedef(type_12142, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >::const_pointer"))
  .AddTypedef(type_12144, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >::reference"))
  .AddTypedef(type_12146, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >::const_reference"))
  .AddTypedef(type_12148, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >::iterator"))
  .AddTypedef(type_12150, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >::const_iterator"))
  .AddTypedef(type_5641, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >::const_reverse_iterator"))
  .AddTypedef(type_5642, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >::difference_type"))
  .AddTypedef(type_5049, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_12157, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_59809), Reflex::Literal("vector"), constructor_12158, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_12146, type_59809), Reflex::Literal("vector"), constructor_12159, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_59810), Reflex::Literal("vector"), constructor_12160, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_12161, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1381, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x117, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x118, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Tau> > > -------------------
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Tau> > > -------------------
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_59811, type_59810), Reflex::Literal("operator="), operator_12162, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_12146), Reflex::Literal("assign"), method_12163, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12148), Reflex::Literal("begin"), method_12164, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12150), Reflex::Literal("begin"), method_12165, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12148), Reflex::Literal("end"), method_12166, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12150), Reflex::Literal("end"), method_12167, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_12172, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_12173, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_2810), Reflex::Literal("resize"), method_12174, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_12175, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_12176, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_12177, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12144, type_5015), Reflex::Literal("operator[]"), operator_12178, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12146, type_5015), Reflex::Literal("operator[]"), operator_12179, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12144, type_5015), Reflex::Literal("at"), method_12181, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12146, type_5015), Reflex::Literal("at"), method_12182, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12144), Reflex::Literal("front"), method_12183, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12146), Reflex::Literal("front"), method_12184, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12144), Reflex::Literal("back"), method_12185, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12146), Reflex::Literal("back"), method_12186, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12140), Reflex::Literal("data"), method_12187, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12142), Reflex::Literal("data"), method_12188, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_12146), Reflex::Literal("push_back"), method_12189, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_12190, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12148, type_12148, type_12146), Reflex::Literal("insert"), method_12191, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_12148, type_5015, type_12146), Reflex::Literal("insert"), method_12192, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12148, type_12148), Reflex::Literal("erase"), method_12193, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12148, type_12148, type_12148), Reflex::Literal("erase"), method_12194, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_59811), Reflex::Literal("swap"), method_12195, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_12196, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> -------------------------------
static  void operator_12211( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*)o)->operator=)(*(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*)arg[0]);
  else   (((::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*)o)->operator=)(*(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*)arg[0]);
}

static void constructor_12212( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>(*(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*)arg[0]);
  else ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>(*(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*)arg[0]);
}

static void constructor_12213( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>();
  else ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>();
}

static void constructor_12214( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Electron>*)arg[1],
      *(const ::edm::Ptr<pat::Photon>*)arg[2],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[3]);
  else ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Electron>*)arg[1],
      *(const ::edm::Ptr<pat::Photon>*)arg[2],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[3]);
}

static  void method_12215( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*)o)->clone)());
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*)o)->clone)();
}

static  void method_12216( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_12217( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_12218( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*)o)->numberOfDaughters)());
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*)o)->numberOfDaughters)();
}

static  void method_12219( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_12220( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_12221(void*, void * o, const std::vector<void*>&, void *) {
(((::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*)o)->::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>::~PATTripletFinalStateT)();
}
static void method_newdel_1393( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x120( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> -------------------------------
void __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon__db_datamem(Reflex::Class*);
void __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon__datamem_bld(&__PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon__db_datamem);
Reflex::GenreflexMemberBuilder __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon__funcmem_bld(&__PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon__db_funcmem);
void __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>"), typeid(::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>), sizeof(::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6476, Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>::daughter1_type"))
  .AddTypedef(type_6476, Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>::daughter2_type"))
  .AddTypedef(type_6478, Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>::daughter3_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18603, type_18605), Reflex::Literal("operator="), operator_12211, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18605), Reflex::Literal("PATTripletFinalStateT"), constructor_12212, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATTripletFinalStateT"), constructor_12213, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45636, type_45636, type_45637, type_45406), Reflex::Literal("PATTripletFinalStateT"), constructor_12214, 0, "p1;p2;p3;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATTripletFinalStateT"), destructor_12221, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1393, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x120, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon__funcmem_bld);
}

//------Delayed data member builder for class PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> -------------------
void __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9785, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9785, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_, p2_), ::Reflex::PRIVATE)
  .AddDataMember(type_9786, Reflex::Literal("p3_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_, p3_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> -------------------
void __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18599), Reflex::Literal("clone"), method_12215, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_12216, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_12217, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_12218, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_12219, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_12220, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> -------------------------------
static  void operator_13834( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*)o)->operator=)(*(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*)arg[0]);
  else   (((::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*)o)->operator=)(*(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*)arg[0]);
}

static void constructor_13835( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>(*(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*)arg[0]);
  else ::new(mem) ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>(*(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*)arg[0]);
}

static void constructor_13836( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>();
  else ::new(mem) ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>();
}

static void constructor_13837( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>(*(const ::edm::Ptr<pat::Muon>*)arg[0],
      *(const ::edm::Ptr<pat::Muon>*)arg[1],
      *(const ::edm::Ptr<pat::Tau>*)arg[2],
      *(const ::edm::Ptr<pat::Tau>*)arg[3],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[4]);
  else ::new(mem) ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>(*(const ::edm::Ptr<pat::Muon>*)arg[0],
      *(const ::edm::Ptr<pat::Muon>*)arg[1],
      *(const ::edm::Ptr<pat::Tau>*)arg[2],
      *(const ::edm::Ptr<pat::Tau>*)arg[3],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[4]);
}

static  void method_13838( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*)o)->clone)());
  else   (((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*)o)->clone)();
}

static  void method_13839( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_13840( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_13841( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*)o)->numberOfDaughters)());
  else   (((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*)o)->numberOfDaughters)();
}

static  void method_13842( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_13843( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_13844(void*, void * o, const std::vector<void*>&, void *) {
(((::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*)o)->::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>::~PATQuadFinalStateT)();
}
static void method_newdel_1959( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x122( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> -------------------------------
void __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau__db_datamem(Reflex::Class*);
void __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau__datamem_bld(&__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau__db_datamem);
Reflex::GenreflexMemberBuilder __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau__funcmem_bld(&__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau__db_funcmem);
void __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>"), typeid(::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>), sizeof(::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6497, Reflex::Literal("PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>::daughter1_type"))
  .AddTypedef(type_6497, Reflex::Literal("PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>::daughter2_type"))
  .AddTypedef(type_7135, Reflex::Literal("PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>::daughter3_type"))
  .AddTypedef(type_7135, Reflex::Literal("PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>::daughter4_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12754, type_12756), Reflex::Literal("operator="), operator_13834, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12756), Reflex::Literal("PATQuadFinalStateT"), constructor_13835, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATQuadFinalStateT"), constructor_13836, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45727, type_45727, type_46321, type_46321, type_45406), Reflex::Literal("PATQuadFinalStateT"), constructor_13837, 0, "p1;p2;p3;p4;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATQuadFinalStateT"), destructor_13844, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1959, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x122, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau__funcmem_bld);
}

//------Delayed data member builder for class PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> -------------------
void __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9782, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9782, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_, p2_), ::Reflex::PRIVATE)
  .AddDataMember(type_9787, Reflex::Literal("p3_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_, p3_), ::Reflex::PRIVATE)
  .AddDataMember(type_9787, Reflex::Literal("p4_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_, p4_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> -------------------
void __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12750), Reflex::Literal("clone"), method_13838, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_13839, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_13840, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_13841, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_13842, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_13843, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class vector<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Tau, pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Tau, pat::Tau> > > -------------------------------
static void constructor_12767( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >();
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >();
}

static void constructor_12768( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >(*(const ::std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >(*(const ::std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)arg[0]);
}

static void constructor_12769( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*)arg[1]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*)arg[1],
      *(const ::std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)arg[2]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*)arg[1],
      *(const ::std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)arg[2]);
  }
}

static void constructor_12770( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >(*(const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >(*(const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)arg[0]);
}

static void destructor_12771(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >::~vector)();
}
static  void operator_12772( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->operator=)(*(const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->operator=)(*(const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)arg[0]);
}

static  void method_12773( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*)arg[1]);
}

static  void method_12774( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >)((((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->begin)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->begin)();
}

static  void method_12775( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >)((((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->begin)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->begin)();
}

static  void method_12776( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >)((((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->end)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->end)();
}

static  void method_12777( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >)((((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->end)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->end)();
}

static  void method_12782( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->size)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->size)();
}

static  void method_12783( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->max_size)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->max_size)();
}

static  void method_12784( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*)arg[1]);
  }
}

static  void method_12785( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->capacity)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->capacity)();
}

static  void method_12786( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->empty)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->empty)();
}

static  void method_12787( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_12788( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_12789( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_12791( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_12792( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_12793( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->front)();
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->front)();
}

static  void method_12794( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->front)();
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->front)();
}

static  void method_12795( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->back)();
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->back)();
}

static  void method_12796( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->back)();
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->back)();
}

static  void method_12797( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->data)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->data)();
}

static  void method_12798( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->data)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->data)();
}

static  void method_12799( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->push_back)(*(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*)arg[0]);
}

static  void method_12800( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->pop_back)();
}

static  void method_12801( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >)((((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*)arg[1]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*)arg[1]);
}

static  void method_12802( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*)arg[2]);
}

static  void method_12803( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >)((((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >*)arg[0]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >*)arg[0]);
}

static  void method_12804( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >)((((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >*)arg[1]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >*)arg[1]);
}

static  void method_12805( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->swap)(*(::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)arg[0]);
}

static  void method_12806( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->clear)();
}

static void method_newdel_1605( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x124( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >")), ::Reflex::BaseOffset< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >,::std::_Vector_base<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x125( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >::Generate();
}

//------Dictionary for class vector<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Tau, pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Tau, pat::Tau> > > -------------------------------
void __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s__db_datamem(Reflex::Class*);
void __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s__datamem_bld(&__std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s__funcmem_bld(&__std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s__db_funcmem);
void __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >"), typeid(::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >), sizeof(::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3687, ::Reflex::BaseOffset< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >, ::std::_Vector_base<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1959, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >::_Alloc_value_type"))
  .AddTypedef(type_3687, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >::_Base"))
  .AddTypedef(type_5042, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >::_Tp_alloc_type"))
  .AddTypedef(type_1959, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >::value_type"))
  .AddTypedef(type_12750, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >::pointer"))
  .AddTypedef(type_12752, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >::const_pointer"))
  .AddTypedef(type_12754, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >::reference"))
  .AddTypedef(type_12756, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >::const_reference"))
  .AddTypedef(type_12758, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >::iterator"))
  .AddTypedef(type_12760, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >::const_iterator"))
  .AddTypedef(type_5627, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >::const_reverse_iterator"))
  .AddTypedef(type_5628, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >::difference_type"))
  .AddTypedef(type_5042, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_12767, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60115), Reflex::Literal("vector"), constructor_12768, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_12756, type_60115), Reflex::Literal("vector"), constructor_12769, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60116), Reflex::Literal("vector"), constructor_12770, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_12771, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1605, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x124, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x125, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Tau, pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Tau, pat::Tau> > > -------------------
void __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Tau, pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Tau, pat::Tau> > > -------------------
void __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60117, type_60116), Reflex::Literal("operator="), operator_12772, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_12756), Reflex::Literal("assign"), method_12773, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12758), Reflex::Literal("begin"), method_12774, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12760), Reflex::Literal("begin"), method_12775, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12758), Reflex::Literal("end"), method_12776, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12760), Reflex::Literal("end"), method_12777, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_12782, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_12783, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_1959), Reflex::Literal("resize"), method_12784, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_12785, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_12786, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_12787, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12754, type_5015), Reflex::Literal("operator[]"), operator_12788, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12756, type_5015), Reflex::Literal("operator[]"), operator_12789, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12754, type_5015), Reflex::Literal("at"), method_12791, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12756, type_5015), Reflex::Literal("at"), method_12792, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12754), Reflex::Literal("front"), method_12793, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12756), Reflex::Literal("front"), method_12794, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12754), Reflex::Literal("back"), method_12795, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12756), Reflex::Literal("back"), method_12796, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12750), Reflex::Literal("data"), method_12797, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12752), Reflex::Literal("data"), method_12798, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_12756), Reflex::Literal("push_back"), method_12799, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_12800, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12758, type_12758, type_12756), Reflex::Literal("insert"), method_12801, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_12758, type_5015, type_12756), Reflex::Literal("insert"), method_12802, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12758, type_12758), Reflex::Literal("erase"), method_12803, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12758, type_12758, type_12758), Reflex::Literal("erase"), method_12804, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_60117), Reflex::Literal("swap"), method_12805, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_12806, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class PATPairFinalStateT<pat::Muon,pat::Photon> -------------------------------
static  void operator_12817( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATPairFinalStateT<pat::Muon,pat::Photon>*)o)->operator=)(*(const ::PATPairFinalStateT<pat::Muon,pat::Photon>*)arg[0]);
  else   (((::PATPairFinalStateT<pat::Muon,pat::Photon>*)o)->operator=)(*(const ::PATPairFinalStateT<pat::Muon,pat::Photon>*)arg[0]);
}

static void constructor_12818( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATPairFinalStateT<pat::Muon,pat::Photon>(*(const ::PATPairFinalStateT<pat::Muon,pat::Photon>*)arg[0]);
  else ::new(mem) ::PATPairFinalStateT<pat::Muon,pat::Photon>(*(const ::PATPairFinalStateT<pat::Muon,pat::Photon>*)arg[0]);
}

static void constructor_12819( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATPairFinalStateT<pat::Muon,pat::Photon>();
  else ::new(mem) ::PATPairFinalStateT<pat::Muon,pat::Photon>();
}

static void constructor_12820( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATPairFinalStateT<pat::Muon,pat::Photon>(*(const ::edm::Ptr<pat::Muon>*)arg[0],
      *(const ::edm::Ptr<pat::Photon>*)arg[1],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[2]);
  else ::new(mem) ::PATPairFinalStateT<pat::Muon,pat::Photon>(*(const ::edm::Ptr<pat::Muon>*)arg[0],
      *(const ::edm::Ptr<pat::Photon>*)arg[1],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[2]);
}

static  void method_12821( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATPairFinalStateT<pat::Muon,pat::Photon>*)o)->clone)());
  else   (((const ::PATPairFinalStateT<pat::Muon,pat::Photon>*)o)->clone)();
}

static  void method_12822( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATPairFinalStateT<pat::Muon,pat::Photon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATPairFinalStateT<pat::Muon,pat::Photon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_12823( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATPairFinalStateT<pat::Muon,pat::Photon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATPairFinalStateT<pat::Muon,pat::Photon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_12824( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATPairFinalStateT<pat::Muon,pat::Photon>*)o)->numberOfDaughters)());
  else   (((const ::PATPairFinalStateT<pat::Muon,pat::Photon>*)o)->numberOfDaughters)();
}

static  void method_12825( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATPairFinalStateT<pat::Muon,pat::Photon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATPairFinalStateT<pat::Muon,pat::Photon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_12826( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATPairFinalStateT<pat::Muon,pat::Photon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATPairFinalStateT<pat::Muon,pat::Photon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_12827(void*, void * o, const std::vector<void*>&, void *) {
(((::PATPairFinalStateT<pat::Muon,pat::Photon>*)o)->::PATPairFinalStateT<pat::Muon,pat::Photon>::~PATPairFinalStateT)();
}
static void method_newdel_1607( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Muon,pat::Photon> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Muon,pat::Photon> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Muon,pat::Photon> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Muon,pat::Photon> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Muon,pat::Photon> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x127( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Muon,pat::Photon>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Muon,pat::Photon>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Muon,pat::Photon>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Muon,pat::Photon>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATPairFinalStateT<pat::Muon,pat::Photon> -------------------------------
void __PATPairFinalStateT_pat__Muon_pat__Photon__db_datamem(Reflex::Class*);
void __PATPairFinalStateT_pat__Muon_pat__Photon__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATPairFinalStateT_pat__Muon_pat__Photon__datamem_bld(&__PATPairFinalStateT_pat__Muon_pat__Photon__db_datamem);
Reflex::GenreflexMemberBuilder __PATPairFinalStateT_pat__Muon_pat__Photon__funcmem_bld(&__PATPairFinalStateT_pat__Muon_pat__Photon__db_funcmem);
void __PATPairFinalStateT_pat__Muon_pat__Photon__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATPairFinalStateT<pat::Muon,pat::Photon>"), typeid(::PATPairFinalStateT<pat::Muon,pat::Photon>), sizeof(::PATPairFinalStateT<pat::Muon,pat::Photon>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Muon,pat::Photon>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6497, Reflex::Literal("PATPairFinalStateT<pat::Muon,pat::Photon>::daughter1_type"))
  .AddTypedef(type_6478, Reflex::Literal("PATPairFinalStateT<pat::Muon,pat::Photon>::daughter2_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19540, type_19542), Reflex::Literal("operator="), operator_12817, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19542), Reflex::Literal("PATPairFinalStateT"), constructor_12818, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATPairFinalStateT"), constructor_12819, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45727, type_45637, type_45406), Reflex::Literal("PATPairFinalStateT"), constructor_12820, 0, "p1;p2;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATPairFinalStateT"), destructor_12827, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1607, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x127, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATPairFinalStateT_pat__Muon_pat__Photon__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATPairFinalStateT_pat__Muon_pat__Photon__funcmem_bld);
}

//------Delayed data member builder for class PATPairFinalStateT<pat::Muon,pat::Photon> -------------------
void __PATPairFinalStateT_pat__Muon_pat__Photon__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9782, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATPairFinalStateT_pat__Muon_pat__Photon_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9786, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATPairFinalStateT_pat__Muon_pat__Photon_, p2_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATPairFinalStateT<pat::Muon,pat::Photon> -------------------
void __PATPairFinalStateT_pat__Muon_pat__Photon__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19536), Reflex::Literal("clone"), method_12821, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_12822, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_12823, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_12824, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_12825, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_12826, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class PATPairFinalStateT<pat::Muon,pat::Tau> -------------------------------
static  void operator_13685( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATPairFinalStateT<pat::Muon,pat::Tau>*)o)->operator=)(*(const ::PATPairFinalStateT<pat::Muon,pat::Tau>*)arg[0]);
  else   (((::PATPairFinalStateT<pat::Muon,pat::Tau>*)o)->operator=)(*(const ::PATPairFinalStateT<pat::Muon,pat::Tau>*)arg[0]);
}

static void constructor_13686( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATPairFinalStateT<pat::Muon,pat::Tau>(*(const ::PATPairFinalStateT<pat::Muon,pat::Tau>*)arg[0]);
  else ::new(mem) ::PATPairFinalStateT<pat::Muon,pat::Tau>(*(const ::PATPairFinalStateT<pat::Muon,pat::Tau>*)arg[0]);
}

static void constructor_13687( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATPairFinalStateT<pat::Muon,pat::Tau>();
  else ::new(mem) ::PATPairFinalStateT<pat::Muon,pat::Tau>();
}

static void constructor_13688( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATPairFinalStateT<pat::Muon,pat::Tau>(*(const ::edm::Ptr<pat::Muon>*)arg[0],
      *(const ::edm::Ptr<pat::Tau>*)arg[1],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[2]);
  else ::new(mem) ::PATPairFinalStateT<pat::Muon,pat::Tau>(*(const ::edm::Ptr<pat::Muon>*)arg[0],
      *(const ::edm::Ptr<pat::Tau>*)arg[1],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[2]);
}

static  void method_13689( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATPairFinalStateT<pat::Muon,pat::Tau>*)o)->clone)());
  else   (((const ::PATPairFinalStateT<pat::Muon,pat::Tau>*)o)->clone)();
}

static  void method_13690( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATPairFinalStateT<pat::Muon,pat::Tau>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATPairFinalStateT<pat::Muon,pat::Tau>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_13691( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATPairFinalStateT<pat::Muon,pat::Tau>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATPairFinalStateT<pat::Muon,pat::Tau>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_13692( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATPairFinalStateT<pat::Muon,pat::Tau>*)o)->numberOfDaughters)());
  else   (((const ::PATPairFinalStateT<pat::Muon,pat::Tau>*)o)->numberOfDaughters)();
}

static  void method_13693( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATPairFinalStateT<pat::Muon,pat::Tau>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATPairFinalStateT<pat::Muon,pat::Tau>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_13694( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATPairFinalStateT<pat::Muon,pat::Tau>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATPairFinalStateT<pat::Muon,pat::Tau>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_13695(void*, void * o, const std::vector<void*>&, void *) {
(((::PATPairFinalStateT<pat::Muon,pat::Tau>*)o)->::PATPairFinalStateT<pat::Muon,pat::Tau>::~PATPairFinalStateT)();
}
static void method_newdel_1885( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Muon,pat::Tau> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Muon,pat::Tau> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Muon,pat::Tau> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Muon,pat::Tau> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Muon,pat::Tau> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x129( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Muon,pat::Tau>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Muon,pat::Tau>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Muon,pat::Tau>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Muon,pat::Tau>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATPairFinalStateT<pat::Muon,pat::Tau> -------------------------------
void __PATPairFinalStateT_pat__Muon_pat__Tau__db_datamem(Reflex::Class*);
void __PATPairFinalStateT_pat__Muon_pat__Tau__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATPairFinalStateT_pat__Muon_pat__Tau__datamem_bld(&__PATPairFinalStateT_pat__Muon_pat__Tau__db_datamem);
Reflex::GenreflexMemberBuilder __PATPairFinalStateT_pat__Muon_pat__Tau__funcmem_bld(&__PATPairFinalStateT_pat__Muon_pat__Tau__db_funcmem);
void __PATPairFinalStateT_pat__Muon_pat__Tau__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATPairFinalStateT<pat::Muon,pat::Tau>"), typeid(::PATPairFinalStateT<pat::Muon,pat::Tau>), sizeof(::PATPairFinalStateT<pat::Muon,pat::Tau>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Muon,pat::Tau>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6497, Reflex::Literal("PATPairFinalStateT<pat::Muon,pat::Tau>::daughter1_type"))
  .AddTypedef(type_7135, Reflex::Literal("PATPairFinalStateT<pat::Muon,pat::Tau>::daughter2_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12948, type_12950), Reflex::Literal("operator="), operator_13685, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12950), Reflex::Literal("PATPairFinalStateT"), constructor_13686, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATPairFinalStateT"), constructor_13687, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45727, type_46321, type_45406), Reflex::Literal("PATPairFinalStateT"), constructor_13688, 0, "p1;p2;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATPairFinalStateT"), destructor_13695, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1885, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x129, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATPairFinalStateT_pat__Muon_pat__Tau__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATPairFinalStateT_pat__Muon_pat__Tau__funcmem_bld);
}

//------Delayed data member builder for class PATPairFinalStateT<pat::Muon,pat::Tau> -------------------
void __PATPairFinalStateT_pat__Muon_pat__Tau__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9782, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATPairFinalStateT_pat__Muon_pat__Tau_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9787, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATPairFinalStateT_pat__Muon_pat__Tau_, p2_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATPairFinalStateT<pat::Muon,pat::Tau> -------------------
void __PATPairFinalStateT_pat__Muon_pat__Tau__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12944), Reflex::Literal("clone"), method_13689, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_13690, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_13691, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_13692, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_13693, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_13694, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class vector<PATPairFinalStateT<pat::Muon, pat::Tau>,std::allocator<PATPairFinalStateT<pat::Muon, pat::Tau> > > -------------------------------
static void constructor_12961( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >();
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >();
}

static void constructor_12962( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >(*(const ::std::allocator<PATPairFinalStateT<pat::Muon,pat::Tau> >*)arg[0]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >(*(const ::std::allocator<PATPairFinalStateT<pat::Muon,pat::Tau> >*)arg[0]);
}

static void constructor_12963( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Muon,pat::Tau>*)arg[1]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Muon,pat::Tau>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Muon,pat::Tau>*)arg[1],
      *(const ::std::allocator<PATPairFinalStateT<pat::Muon,pat::Tau> >*)arg[2]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Muon,pat::Tau>*)arg[1],
      *(const ::std::allocator<PATPairFinalStateT<pat::Muon,pat::Tau> >*)arg[2]);
  }
}

static void constructor_12964( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >(*(const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)arg[0]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >(*(const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)arg[0]);
}

static void destructor_12965(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >::~vector)();
}
static  void operator_12966( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->operator=)(*(const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)arg[0]);
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->operator=)(*(const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)arg[0]);
}

static  void method_12967( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATPairFinalStateT<pat::Muon,pat::Tau>*)arg[1]);
}

static  void method_12968( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >)((((::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->begin)());
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->begin)();
}

static  void method_12969( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Muon,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >)((((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->begin)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->begin)();
}

static  void method_12970( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >)((((::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->end)());
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->end)();
}

static  void method_12971( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Muon,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >)((((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->end)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->end)();
}

static  void method_12976( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->size)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->size)();
}

static  void method_12977( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->max_size)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->max_size)();
}

static  void method_12978( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATPairFinalStateT<pat::Muon,pat::Tau>*)arg[1]);
  }
}

static  void method_12979( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->capacity)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->capacity)();
}

static  void method_12980( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->empty)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->empty)();
}

static  void method_12981( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_12982( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_12983( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_12985( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_12986( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_12987( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->front)();
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->front)();
}

static  void method_12988( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->front)();
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->front)();
}

static  void method_12989( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->back)();
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->back)();
}

static  void method_12990( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->back)();
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->back)();
}

static  void method_12991( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->data)());
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->data)();
}

static  void method_12992( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->data)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->data)();
}

static  void method_12993( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->push_back)(*(const ::PATPairFinalStateT<pat::Muon,pat::Tau>*)arg[0]);
}

static  void method_12994( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->pop_back)();
}

static  void method_12995( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >)((((::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >*)arg[0],
    *(const ::PATPairFinalStateT<pat::Muon,pat::Tau>*)arg[1]));
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >*)arg[0],
    *(const ::PATPairFinalStateT<pat::Muon,pat::Tau>*)arg[1]);
}

static  void method_12996( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATPairFinalStateT<pat::Muon,pat::Tau>*)arg[2]);
}

static  void method_12997( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >)((((::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >*)arg[0]));
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >*)arg[0]);
}

static  void method_12998( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >)((((::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >*)arg[1]));
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >*)arg[1]);
}

static  void method_12999( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->swap)(*(::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)arg[0]);
}

static  void method_13000( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->clear)();
}

static void method_newdel_1614( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x131( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATPairFinalStateT<pat::Muon,pat::Tau>,std::allocator<PATPairFinalStateT<pat::Muon,pat::Tau> > >")), ::Reflex::BaseOffset< ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >,::std::_Vector_base<PATPairFinalStateT<pat::Muon,pat::Tau>,std::allocator<PATPairFinalStateT<pat::Muon,pat::Tau> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x132( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >::Generate();
}

//------Dictionary for class vector<PATPairFinalStateT<pat::Muon, pat::Tau>,std::allocator<PATPairFinalStateT<pat::Muon, pat::Tau> > > -------------------------------
void __std__vector_PATPairFinalStateT_pat__Muon_pat__Tau_s__db_datamem(Reflex::Class*);
void __std__vector_PATPairFinalStateT_pat__Muon_pat__Tau_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATPairFinalStateT_pat__Muon_pat__Tau_s__datamem_bld(&__std__vector_PATPairFinalStateT_pat__Muon_pat__Tau_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATPairFinalStateT_pat__Muon_pat__Tau_s__funcmem_bld(&__std__vector_PATPairFinalStateT_pat__Muon_pat__Tau_s__db_funcmem);
void __std__vector_PATPairFinalStateT_pat__Muon_pat__Tau_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >"), typeid(::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >), sizeof(::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3726, ::Reflex::BaseOffset< ::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >, ::std::_Vector_base<PATPairFinalStateT<pat::Muon,pat::Tau>,std::allocator<PATPairFinalStateT<pat::Muon,pat::Tau> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1885, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >::_Alloc_value_type"))
  .AddTypedef(type_3726, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >::_Base"))
  .AddTypedef(type_5081, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >::_Tp_alloc_type"))
  .AddTypedef(type_1885, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >::value_type"))
  .AddTypedef(type_12944, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >::pointer"))
  .AddTypedef(type_12946, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >::const_pointer"))
  .AddTypedef(type_12948, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >::reference"))
  .AddTypedef(type_12950, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >::const_reference"))
  .AddTypedef(type_12952, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >::iterator"))
  .AddTypedef(type_12954, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >::const_iterator"))
  .AddTypedef(type_5705, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >::const_reverse_iterator"))
  .AddTypedef(type_5706, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >::difference_type"))
  .AddTypedef(type_5081, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_12961, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60132), Reflex::Literal("vector"), constructor_12962, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_12950, type_60132), Reflex::Literal("vector"), constructor_12963, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60133), Reflex::Literal("vector"), constructor_12964, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_12965, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1614, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x131, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x132, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATPairFinalStateT_pat__Muon_pat__Tau_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATPairFinalStateT<pat::Muon, pat::Tau>,std::allocator<PATPairFinalStateT<pat::Muon, pat::Tau> > > -------------------
void __std__vector_PATPairFinalStateT_pat__Muon_pat__Tau_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATPairFinalStateT<pat::Muon, pat::Tau>,std::allocator<PATPairFinalStateT<pat::Muon, pat::Tau> > > -------------------
void __std__vector_PATPairFinalStateT_pat__Muon_pat__Tau_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60134, type_60133), Reflex::Literal("operator="), operator_12966, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_12950), Reflex::Literal("assign"), method_12967, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12952), Reflex::Literal("begin"), method_12968, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12954), Reflex::Literal("begin"), method_12969, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12952), Reflex::Literal("end"), method_12970, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12954), Reflex::Literal("end"), method_12971, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_12976, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_12977, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_1885), Reflex::Literal("resize"), method_12978, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_12979, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_12980, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_12981, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12948, type_5015), Reflex::Literal("operator[]"), operator_12982, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12950, type_5015), Reflex::Literal("operator[]"), operator_12983, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12948, type_5015), Reflex::Literal("at"), method_12985, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12950, type_5015), Reflex::Literal("at"), method_12986, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12948), Reflex::Literal("front"), method_12987, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12950), Reflex::Literal("front"), method_12988, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12948), Reflex::Literal("back"), method_12989, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12950), Reflex::Literal("back"), method_12990, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12944), Reflex::Literal("data"), method_12991, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12946), Reflex::Literal("data"), method_12992, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_12950), Reflex::Literal("push_back"), method_12993, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_12994, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12952, type_12952, type_12950), Reflex::Literal("insert"), method_12995, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_12952, type_5015, type_12950), Reflex::Literal("insert"), method_12996, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12952, type_12952), Reflex::Literal("erase"), method_12997, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12952, type_12952, type_12952), Reflex::Literal("erase"), method_12998, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_60134), Reflex::Literal("swap"), method_12999, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_13000, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> -------------------------------
static  void operator_12471( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*)o)->operator=)(*(const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*)arg[0]);
  else   (((::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*)o)->operator=)(*(const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*)arg[0]);
}

static void constructor_12472( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>(*(const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*)arg[0]);
  else ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>(*(const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*)arg[0]);
}

static void constructor_12473( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>();
  else ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>();
}

static void constructor_12474( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Muon>*)arg[1],
      *(const ::edm::Ptr<pat::Tau>*)arg[2],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[3]);
  else ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Muon>*)arg[1],
      *(const ::edm::Ptr<pat::Tau>*)arg[2],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[3]);
}

static  void method_12475( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*)o)->clone)());
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*)o)->clone)();
}

static  void method_12476( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_12477( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_12478( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*)o)->numberOfDaughters)());
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*)o)->numberOfDaughters)();
}

static  void method_12479( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_12480( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_12481(void*, void * o, const std::vector<void*>&, void *) {
(((::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*)o)->::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>::~PATTripletFinalStateT)();
}
static void method_newdel_1521( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x134( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> -------------------------------
void __PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau__db_datamem(Reflex::Class*);
void __PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau__datamem_bld(&__PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau__db_datamem);
Reflex::GenreflexMemberBuilder __PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau__funcmem_bld(&__PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau__db_funcmem);
void __PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>"), typeid(::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>), sizeof(::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6476, Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>::daughter1_type"))
  .AddTypedef(type_6497, Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>::daughter2_type"))
  .AddTypedef(type_7135, Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>::daughter3_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19457, type_19459), Reflex::Literal("operator="), operator_12471, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19459), Reflex::Literal("PATTripletFinalStateT"), constructor_12472, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATTripletFinalStateT"), constructor_12473, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45636, type_45727, type_46321, type_45406), Reflex::Literal("PATTripletFinalStateT"), constructor_12474, 0, "p1;p2;p3;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATTripletFinalStateT"), destructor_12481, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1521, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x134, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau__funcmem_bld);
}

//------Delayed data member builder for class PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> -------------------
void __PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9785, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9782, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_, p2_), ::Reflex::PRIVATE)
  .AddDataMember(type_9787, Reflex::Literal("p3_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_, p3_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> -------------------
void __PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19453), Reflex::Literal("clone"), method_12475, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_12476, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_12477, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_12478, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_12479, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_12480, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class PATPairFinalStateT<pat::Electron,pat::Electron> -------------------------------
static  void operator_13745( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATPairFinalStateT<pat::Electron,pat::Electron>*)o)->operator=)(*(const ::PATPairFinalStateT<pat::Electron,pat::Electron>*)arg[0]);
  else   (((::PATPairFinalStateT<pat::Electron,pat::Electron>*)o)->operator=)(*(const ::PATPairFinalStateT<pat::Electron,pat::Electron>*)arg[0]);
}

static void constructor_13746( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATPairFinalStateT<pat::Electron,pat::Electron>(*(const ::PATPairFinalStateT<pat::Electron,pat::Electron>*)arg[0]);
  else ::new(mem) ::PATPairFinalStateT<pat::Electron,pat::Electron>(*(const ::PATPairFinalStateT<pat::Electron,pat::Electron>*)arg[0]);
}

static void constructor_13747( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATPairFinalStateT<pat::Electron,pat::Electron>();
  else ::new(mem) ::PATPairFinalStateT<pat::Electron,pat::Electron>();
}

static void constructor_13748( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATPairFinalStateT<pat::Electron,pat::Electron>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Electron>*)arg[1],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[2]);
  else ::new(mem) ::PATPairFinalStateT<pat::Electron,pat::Electron>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Electron>*)arg[1],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[2]);
}

static  void method_13749( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATPairFinalStateT<pat::Electron,pat::Electron>*)o)->clone)());
  else   (((const ::PATPairFinalStateT<pat::Electron,pat::Electron>*)o)->clone)();
}

static  void method_13750( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATPairFinalStateT<pat::Electron,pat::Electron>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATPairFinalStateT<pat::Electron,pat::Electron>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_13751( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATPairFinalStateT<pat::Electron,pat::Electron>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATPairFinalStateT<pat::Electron,pat::Electron>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_13752( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATPairFinalStateT<pat::Electron,pat::Electron>*)o)->numberOfDaughters)());
  else   (((const ::PATPairFinalStateT<pat::Electron,pat::Electron>*)o)->numberOfDaughters)();
}

static  void method_13753( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATPairFinalStateT<pat::Electron,pat::Electron>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATPairFinalStateT<pat::Electron,pat::Electron>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_13754( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATPairFinalStateT<pat::Electron,pat::Electron>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATPairFinalStateT<pat::Electron,pat::Electron>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_13755(void*, void * o, const std::vector<void*>&, void *) {
(((::PATPairFinalStateT<pat::Electron,pat::Electron>*)o)->::PATPairFinalStateT<pat::Electron,pat::Electron>::~PATPairFinalStateT)();
}
static void method_newdel_1889( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Electron,pat::Electron> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Electron,pat::Electron> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Electron,pat::Electron> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Electron,pat::Electron> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Electron,pat::Electron> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x136( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Electron,pat::Electron>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Electron,pat::Electron>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Electron,pat::Electron>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Electron,pat::Electron>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATPairFinalStateT<pat::Electron,pat::Electron> -------------------------------
void __PATPairFinalStateT_pat__Electron_pat__Electron__db_datamem(Reflex::Class*);
void __PATPairFinalStateT_pat__Electron_pat__Electron__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATPairFinalStateT_pat__Electron_pat__Electron__datamem_bld(&__PATPairFinalStateT_pat__Electron_pat__Electron__db_datamem);
Reflex::GenreflexMemberBuilder __PATPairFinalStateT_pat__Electron_pat__Electron__funcmem_bld(&__PATPairFinalStateT_pat__Electron_pat__Electron__db_funcmem);
void __PATPairFinalStateT_pat__Electron_pat__Electron__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATPairFinalStateT<pat::Electron,pat::Electron>"), typeid(::PATPairFinalStateT<pat::Electron,pat::Electron>), sizeof(::PATPairFinalStateT<pat::Electron,pat::Electron>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Electron,pat::Electron>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6476, Reflex::Literal("PATPairFinalStateT<pat::Electron,pat::Electron>::daughter1_type"))
  .AddTypedef(type_6476, Reflex::Literal("PATPairFinalStateT<pat::Electron,pat::Electron>::daughter2_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13124, type_13126), Reflex::Literal("operator="), operator_13745, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13126), Reflex::Literal("PATPairFinalStateT"), constructor_13746, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATPairFinalStateT"), constructor_13747, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45636, type_45636, type_45406), Reflex::Literal("PATPairFinalStateT"), constructor_13748, 0, "p1;p2;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATPairFinalStateT"), destructor_13755, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1889, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x136, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATPairFinalStateT_pat__Electron_pat__Electron__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATPairFinalStateT_pat__Electron_pat__Electron__funcmem_bld);
}

//------Delayed data member builder for class PATPairFinalStateT<pat::Electron,pat::Electron> -------------------
void __PATPairFinalStateT_pat__Electron_pat__Electron__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9785, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATPairFinalStateT_pat__Electron_pat__Electron_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9785, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATPairFinalStateT_pat__Electron_pat__Electron_, p2_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATPairFinalStateT<pat::Electron,pat::Electron> -------------------
void __PATPairFinalStateT_pat__Electron_pat__Electron__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13120), Reflex::Literal("clone"), method_13749, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_13750, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_13751, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_13752, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_13753, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_13754, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class vector<PATPairFinalStateT<pat::Electron, pat::Electron>,std::allocator<PATPairFinalStateT<pat::Electron, pat::Electron> > > -------------------------------
static void constructor_13137( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >();
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >();
}

static void constructor_13138( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >(*(const ::std::allocator<PATPairFinalStateT<pat::Electron,pat::Electron> >*)arg[0]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >(*(const ::std::allocator<PATPairFinalStateT<pat::Electron,pat::Electron> >*)arg[0]);
}

static void constructor_13139( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Electron,pat::Electron>*)arg[1]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Electron,pat::Electron>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Electron,pat::Electron>*)arg[1],
      *(const ::std::allocator<PATPairFinalStateT<pat::Electron,pat::Electron> >*)arg[2]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Electron,pat::Electron>*)arg[1],
      *(const ::std::allocator<PATPairFinalStateT<pat::Electron,pat::Electron> >*)arg[2]);
  }
}

static void constructor_13140( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >(*(const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)arg[0]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >(*(const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)arg[0]);
}

static void destructor_13141(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >::~vector)();
}
static  void operator_13142( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->operator=)(*(const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)arg[0]);
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->operator=)(*(const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)arg[0]);
}

static  void method_13143( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATPairFinalStateT<pat::Electron,pat::Electron>*)arg[1]);
}

static  void method_13144( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Electron>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >)((((::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->begin)());
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->begin)();
}

static  void method_13145( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Electron,pat::Electron>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >)((((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->begin)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->begin)();
}

static  void method_13146( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Electron>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >)((((::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->end)());
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->end)();
}

static  void method_13147( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Electron,pat::Electron>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >)((((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->end)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->end)();
}

static  void method_13152( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->size)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->size)();
}

static  void method_13153( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->max_size)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->max_size)();
}

static  void method_13154( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATPairFinalStateT<pat::Electron,pat::Electron>*)arg[1]);
  }
}

static  void method_13155( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->capacity)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->capacity)();
}

static  void method_13156( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->empty)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->empty)();
}

static  void method_13157( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_13158( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_13159( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_13161( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13162( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13163( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->front)();
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->front)();
}

static  void method_13164( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->front)();
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->front)();
}

static  void method_13165( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->back)();
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->back)();
}

static  void method_13166( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->back)();
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->back)();
}

static  void method_13167( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->data)());
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->data)();
}

static  void method_13168( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->data)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->data)();
}

static  void method_13169( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->push_back)(*(const ::PATPairFinalStateT<pat::Electron,pat::Electron>*)arg[0]);
}

static  void method_13170( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->pop_back)();
}

static  void method_13171( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Electron>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >)((((::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Electron>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >*)arg[0],
    *(const ::PATPairFinalStateT<pat::Electron,pat::Electron>*)arg[1]));
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Electron>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >*)arg[0],
    *(const ::PATPairFinalStateT<pat::Electron,pat::Electron>*)arg[1]);
}

static  void method_13172( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Electron>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATPairFinalStateT<pat::Electron,pat::Electron>*)arg[2]);
}

static  void method_13173( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Electron>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >)((((::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Electron>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >*)arg[0]));
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Electron>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >*)arg[0]);
}

static  void method_13174( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Electron>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >)((((::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Electron>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Electron>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >*)arg[1]));
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Electron>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Electron>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >*)arg[1]);
}

static  void method_13175( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->swap)(*(::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)arg[0]);
}

static  void method_13176( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->clear)();
}

static void method_newdel_1724( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x138( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATPairFinalStateT<pat::Electron,pat::Electron>,std::allocator<PATPairFinalStateT<pat::Electron,pat::Electron> > >")), ::Reflex::BaseOffset< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >,::std::_Vector_base<PATPairFinalStateT<pat::Electron,pat::Electron>,std::allocator<PATPairFinalStateT<pat::Electron,pat::Electron> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x139( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >::Generate();
}

//------Dictionary for class vector<PATPairFinalStateT<pat::Electron, pat::Electron>,std::allocator<PATPairFinalStateT<pat::Electron, pat::Electron> > > -------------------------------
void __std__vector_PATPairFinalStateT_pat__Electron_pat__Electron_s__db_datamem(Reflex::Class*);
void __std__vector_PATPairFinalStateT_pat__Electron_pat__Electron_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATPairFinalStateT_pat__Electron_pat__Electron_s__datamem_bld(&__std__vector_PATPairFinalStateT_pat__Electron_pat__Electron_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATPairFinalStateT_pat__Electron_pat__Electron_s__funcmem_bld(&__std__vector_PATPairFinalStateT_pat__Electron_pat__Electron_s__db_funcmem);
void __std__vector_PATPairFinalStateT_pat__Electron_pat__Electron_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >"), typeid(::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >), sizeof(::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3731, ::Reflex::BaseOffset< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >, ::std::_Vector_base<PATPairFinalStateT<pat::Electron,pat::Electron>,std::allocator<PATPairFinalStateT<pat::Electron,pat::Electron> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1889, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >::_Alloc_value_type"))
  .AddTypedef(type_3731, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >::_Base"))
  .AddTypedef(type_5086, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >::_Tp_alloc_type"))
  .AddTypedef(type_1889, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >::value_type"))
  .AddTypedef(type_13120, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >::pointer"))
  .AddTypedef(type_13122, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >::const_pointer"))
  .AddTypedef(type_13124, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >::reference"))
  .AddTypedef(type_13126, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >::const_reference"))
  .AddTypedef(type_13128, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >::iterator"))
  .AddTypedef(type_13130, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >::const_iterator"))
  .AddTypedef(type_5715, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >::const_reverse_iterator"))
  .AddTypedef(type_5716, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >::difference_type"))
  .AddTypedef(type_5086, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_13137, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60190), Reflex::Literal("vector"), constructor_13138, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_13126, type_60190), Reflex::Literal("vector"), constructor_13139, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60191), Reflex::Literal("vector"), constructor_13140, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_13141, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1724, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x138, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x139, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATPairFinalStateT_pat__Electron_pat__Electron_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATPairFinalStateT<pat::Electron, pat::Electron>,std::allocator<PATPairFinalStateT<pat::Electron, pat::Electron> > > -------------------
void __std__vector_PATPairFinalStateT_pat__Electron_pat__Electron_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATPairFinalStateT<pat::Electron, pat::Electron>,std::allocator<PATPairFinalStateT<pat::Electron, pat::Electron> > > -------------------
void __std__vector_PATPairFinalStateT_pat__Electron_pat__Electron_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60192, type_60191), Reflex::Literal("operator="), operator_13142, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_13126), Reflex::Literal("assign"), method_13143, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13128), Reflex::Literal("begin"), method_13144, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13130), Reflex::Literal("begin"), method_13145, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13128), Reflex::Literal("end"), method_13146, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13130), Reflex::Literal("end"), method_13147, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_13152, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_13153, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_1889), Reflex::Literal("resize"), method_13154, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_13155, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_13156, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_13157, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13124, type_5015), Reflex::Literal("operator[]"), operator_13158, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13126, type_5015), Reflex::Literal("operator[]"), operator_13159, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13124, type_5015), Reflex::Literal("at"), method_13161, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13126, type_5015), Reflex::Literal("at"), method_13162, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13124), Reflex::Literal("front"), method_13163, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13126), Reflex::Literal("front"), method_13164, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13124), Reflex::Literal("back"), method_13165, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13126), Reflex::Literal("back"), method_13166, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13120), Reflex::Literal("data"), method_13167, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13122), Reflex::Literal("data"), method_13168, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_13126), Reflex::Literal("push_back"), method_13169, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_13170, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13128, type_13128, type_13126), Reflex::Literal("insert"), method_13171, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_13128, type_5015, type_13126), Reflex::Literal("insert"), method_13172, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13128, type_13128), Reflex::Literal("erase"), method_13173, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13128, type_13128, type_13128), Reflex::Literal("erase"), method_13174, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_60192), Reflex::Literal("swap"), method_13175, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_13176, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> -------------------------------
static  void operator_12454( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*)o)->operator=)(*(const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*)arg[0]);
  else   (((::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*)o)->operator=)(*(const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*)arg[0]);
}

static void constructor_12455( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>(*(const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*)arg[0]);
  else ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>(*(const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*)arg[0]);
}

static void constructor_12456( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>();
  else ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>();
}

static void constructor_12457( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Muon>*)arg[1],
      *(const ::edm::Ptr<pat::Photon>*)arg[2],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[3]);
  else ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Muon>*)arg[1],
      *(const ::edm::Ptr<pat::Photon>*)arg[2],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[3]);
}

static  void method_12458( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*)o)->clone)());
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*)o)->clone)();
}

static  void method_12459( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_12460( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_12461( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*)o)->numberOfDaughters)());
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*)o)->numberOfDaughters)();
}

static  void method_12462( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_12463( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_12464(void*, void * o, const std::vector<void*>&, void *) {
(((::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*)o)->::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>::~PATTripletFinalStateT)();
}
static void method_newdel_1520( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x141( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> -------------------------------
void __PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon__db_datamem(Reflex::Class*);
void __PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon__datamem_bld(&__PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon__db_datamem);
Reflex::GenreflexMemberBuilder __PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon__funcmem_bld(&__PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon__db_funcmem);
void __PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>"), typeid(::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>), sizeof(::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6476, Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>::daughter1_type"))
  .AddTypedef(type_6497, Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>::daughter2_type"))
  .AddTypedef(type_6478, Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>::daughter3_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19343, type_19345), Reflex::Literal("operator="), operator_12454, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19345), Reflex::Literal("PATTripletFinalStateT"), constructor_12455, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATTripletFinalStateT"), constructor_12456, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45636, type_45727, type_45637, type_45406), Reflex::Literal("PATTripletFinalStateT"), constructor_12457, 0, "p1;p2;p3;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATTripletFinalStateT"), destructor_12464, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1520, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x141, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon__funcmem_bld);
}

//------Delayed data member builder for class PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> -------------------
void __PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9785, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9782, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_, p2_), ::Reflex::PRIVATE)
  .AddDataMember(type_9786, Reflex::Literal("p3_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_, p3_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> -------------------
void __PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19339), Reflex::Literal("clone"), method_12458, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_12459, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_12460, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_12461, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_12462, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_12463, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> -------------------------------
static  void operator_12522( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*)o)->operator=)(*(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*)arg[0]);
  else   (((::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*)o)->operator=)(*(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*)arg[0]);
}

static void constructor_12523( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>(*(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*)arg[0]);
  else ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>(*(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*)arg[0]);
}

static void constructor_12524( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>();
  else ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>();
}

static void constructor_12525( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Electron>*)arg[1],
      *(const ::edm::Ptr<pat::Electron>*)arg[2],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[3]);
  else ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Electron>*)arg[1],
      *(const ::edm::Ptr<pat::Electron>*)arg[2],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[3]);
}

static  void method_12526( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*)o)->clone)());
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*)o)->clone)();
}

static  void method_12527( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_12528( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_12529( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*)o)->numberOfDaughters)());
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*)o)->numberOfDaughters)();
}

static  void method_12530( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_12531( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_12532(void*, void * o, const std::vector<void*>&, void *) {
(((::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*)o)->::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>::~PATTripletFinalStateT)();
}
static void method_newdel_1524( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x143( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> -------------------------------
void __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron__db_datamem(Reflex::Class*);
void __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron__datamem_bld(&__PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron__db_datamem);
Reflex::GenreflexMemberBuilder __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron__funcmem_bld(&__PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron__db_funcmem);
void __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>"), typeid(::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>), sizeof(::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6476, Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>::daughter1_type"))
  .AddTypedef(type_6476, Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>::daughter2_type"))
  .AddTypedef(type_6476, Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>::daughter3_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18538, type_18540), Reflex::Literal("operator="), operator_12522, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18540), Reflex::Literal("PATTripletFinalStateT"), constructor_12523, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATTripletFinalStateT"), constructor_12524, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45636, type_45636, type_45636, type_45406), Reflex::Literal("PATTripletFinalStateT"), constructor_12525, 0, "p1;p2;p3;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATTripletFinalStateT"), destructor_12532, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1524, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x143, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron__funcmem_bld);
}

//------Delayed data member builder for class PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> -------------------
void __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9785, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9785, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_, p2_), ::Reflex::PRIVATE)
  .AddDataMember(type_9785, Reflex::Literal("p3_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_, p3_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> -------------------
void __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18534), Reflex::Literal("clone"), method_12526, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_12527, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_12528, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_12529, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_12530, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_12531, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class vector<PATTripletFinalStateT<pat::Muon, pat::Jet, pat::Jet>,std::allocator<PATTripletFinalStateT<pat::Muon, pat::Jet, pat::Jet> > > -------------------------------
static void constructor_13390( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >();
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >();
}

static void constructor_13391( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >(*(const ::std::allocator<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >(*(const ::std::allocator<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)arg[0]);
}

static void constructor_13392( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*)arg[1]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*)arg[1],
      *(const ::std::allocator<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)arg[2]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*)arg[1],
      *(const ::std::allocator<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)arg[2]);
  }
}

static void constructor_13393( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >(*(const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >(*(const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)arg[0]);
}

static void destructor_13394(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >::~vector)();
}
static  void operator_13395( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->operator=)(*(const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->operator=)(*(const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)arg[0]);
}

static  void method_13396( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*)arg[1]);
}

static  void method_13397( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >)((((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->begin)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->begin)();
}

static  void method_13398( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >)((((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->begin)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->begin)();
}

static  void method_13399( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >)((((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->end)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->end)();
}

static  void method_13400( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >)((((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->end)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->end)();
}

static  void method_13405( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->size)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->size)();
}

static  void method_13406( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->max_size)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->max_size)();
}

static  void method_13407( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*)arg[1]);
  }
}

static  void method_13408( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->capacity)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->capacity)();
}

static  void method_13409( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->empty)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->empty)();
}

static  void method_13410( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_13411( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_13412( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_13414( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13415( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13416( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->front)();
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->front)();
}

static  void method_13417( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->front)();
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->front)();
}

static  void method_13418( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->back)();
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->back)();
}

static  void method_13419( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->back)();
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->back)();
}

static  void method_13420( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->data)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->data)();
}

static  void method_13421( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->data)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->data)();
}

static  void method_13422( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->push_back)(*(const ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*)arg[0]);
}

static  void method_13423( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->pop_back)();
}

static  void method_13424( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >)((((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*)arg[1]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*)arg[1]);
}

static  void method_13425( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*)arg[2]);
}

static  void method_13426( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >)((((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >*)arg[0]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >*)arg[0]);
}

static  void method_13427( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >)((((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >*)arg[1]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >*)arg[1]);
}

static  void method_13428( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->swap)(*(::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)arg[0]);
}

static  void method_13429( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->clear)();
}

static void method_newdel_1842( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x145( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>,std::allocator<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >")), ::Reflex::BaseOffset< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >,::std::_Vector_base<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>,std::allocator<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x146( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >::Generate();
}

//------Dictionary for class vector<PATTripletFinalStateT<pat::Muon, pat::Jet, pat::Jet>,std::allocator<PATTripletFinalStateT<pat::Muon, pat::Jet, pat::Jet> > > -------------------------------
void __std__vector_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s__db_datamem(Reflex::Class*);
void __std__vector_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s__datamem_bld(&__std__vector_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s__funcmem_bld(&__std__vector_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s__db_funcmem);
void __std__vector_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >"), typeid(::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >), sizeof(::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3705, ::Reflex::BaseOffset< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >, ::std::_Vector_base<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>,std::allocator<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_634, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >::_Alloc_value_type"))
  .AddTypedef(type_3705, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >::_Base"))
  .AddTypedef(type_5060, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >::_Tp_alloc_type"))
  .AddTypedef(type_634, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >::value_type"))
  .AddTypedef(type_13373, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >::pointer"))
  .AddTypedef(type_13375, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >::const_pointer"))
  .AddTypedef(type_13377, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >::reference"))
  .AddTypedef(type_13379, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >::const_reference"))
  .AddTypedef(type_13381, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >::iterator"))
  .AddTypedef(type_13383, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >::const_iterator"))
  .AddTypedef(type_5663, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >::const_reverse_iterator"))
  .AddTypedef(type_5664, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >::difference_type"))
  .AddTypedef(type_5060, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_13390, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60214), Reflex::Literal("vector"), constructor_13391, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_13379, type_60214), Reflex::Literal("vector"), constructor_13392, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60215), Reflex::Literal("vector"), constructor_13393, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_13394, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1842, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x145, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x146, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATTripletFinalStateT<pat::Muon, pat::Jet, pat::Jet>,std::allocator<PATTripletFinalStateT<pat::Muon, pat::Jet, pat::Jet> > > -------------------
void __std__vector_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATTripletFinalStateT<pat::Muon, pat::Jet, pat::Jet>,std::allocator<PATTripletFinalStateT<pat::Muon, pat::Jet, pat::Jet> > > -------------------
void __std__vector_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60216, type_60215), Reflex::Literal("operator="), operator_13395, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_13379), Reflex::Literal("assign"), method_13396, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13381), Reflex::Literal("begin"), method_13397, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13383), Reflex::Literal("begin"), method_13398, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13381), Reflex::Literal("end"), method_13399, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13383), Reflex::Literal("end"), method_13400, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_13405, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_13406, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_634), Reflex::Literal("resize"), method_13407, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_13408, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_13409, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_13410, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13377, type_5015), Reflex::Literal("operator[]"), operator_13411, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13379, type_5015), Reflex::Literal("operator[]"), operator_13412, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13377, type_5015), Reflex::Literal("at"), method_13414, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13379, type_5015), Reflex::Literal("at"), method_13415, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13377), Reflex::Literal("front"), method_13416, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13379), Reflex::Literal("front"), method_13417, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13377), Reflex::Literal("back"), method_13418, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13379), Reflex::Literal("back"), method_13419, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13373), Reflex::Literal("data"), method_13420, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13375), Reflex::Literal("data"), method_13421, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_13379), Reflex::Literal("push_back"), method_13422, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_13423, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13381, type_13381, type_13379), Reflex::Literal("insert"), method_13424, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_13381, type_5015, type_13379), Reflex::Literal("insert"), method_13425, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13381, type_13381), Reflex::Literal("erase"), method_13426, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13381, type_13381, type_13381), Reflex::Literal("erase"), method_13427, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_60216), Reflex::Literal("swap"), method_13428, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_13429, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Photon> > > -------------------------------
static void constructor_13457( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >();
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >();
}

static void constructor_13458( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >(*(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >(*(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)arg[0]);
}

static void constructor_13459( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*)arg[1]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*)arg[1],
      *(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)arg[2]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*)arg[1],
      *(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)arg[2]);
  }
}

static void constructor_13460( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)arg[0]);
}

static void destructor_13461(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >::~vector)();
}
static  void operator_13462( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->operator=)(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->operator=)(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)arg[0]);
}

static  void method_13463( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*)arg[1]);
}

static  void method_13464( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->begin)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->begin)();
}

static  void method_13465( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->begin)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->begin)();
}

static  void method_13466( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->end)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->end)();
}

static  void method_13467( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->end)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->end)();
}

static  void method_13472( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->size)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->size)();
}

static  void method_13473( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->max_size)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->max_size)();
}

static  void method_13474( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*)arg[1]);
  }
}

static  void method_13475( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->capacity)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->capacity)();
}

static  void method_13476( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->empty)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->empty)();
}

static  void method_13477( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_13478( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_13479( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_13481( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13482( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13483( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->front)();
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->front)();
}

static  void method_13484( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->front)();
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->front)();
}

static  void method_13485( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->back)();
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->back)();
}

static  void method_13486( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->back)();
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->back)();
}

static  void method_13487( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->data)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->data)();
}

static  void method_13488( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->data)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->data)();
}

static  void method_13489( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->push_back)(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*)arg[0]);
}

static  void method_13490( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->pop_back)();
}

static  void method_13491( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*)arg[1]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*)arg[1]);
}

static  void method_13492( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*)arg[2]);
}

static  void method_13493( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >*)arg[0]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >*)arg[0]);
}

static  void method_13494( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >*)arg[1]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >*)arg[1]);
}

static  void method_13495( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->swap)(*(::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)arg[0]);
}

static  void method_13496( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->clear)();
}

static void method_newdel_1850( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x148( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >")), ::Reflex::BaseOffset< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >,::std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x149( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >::Generate();
}

//------Dictionary for class vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Photon> > > -------------------------------
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s__db_datamem(Reflex::Class*);
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s__datamem_bld(&__std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s__funcmem_bld(&__std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s__db_funcmem);
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >"), typeid(::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >), sizeof(::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3698, ::Reflex::BaseOffset< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >, ::std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_891, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >::_Alloc_value_type"))
  .AddTypedef(type_3698, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >::_Base"))
  .AddTypedef(type_5053, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >::_Tp_alloc_type"))
  .AddTypedef(type_891, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >::value_type"))
  .AddTypedef(type_13440, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >::pointer"))
  .AddTypedef(type_13442, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >::const_pointer"))
  .AddTypedef(type_13444, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >::reference"))
  .AddTypedef(type_13446, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >::const_reference"))
  .AddTypedef(type_13448, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >::iterator"))
  .AddTypedef(type_13450, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >::const_iterator"))
  .AddTypedef(type_5649, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >::const_reverse_iterator"))
  .AddTypedef(type_5650, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >::difference_type"))
  .AddTypedef(type_5053, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_13457, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60218), Reflex::Literal("vector"), constructor_13458, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_13446, type_60218), Reflex::Literal("vector"), constructor_13459, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60219), Reflex::Literal("vector"), constructor_13460, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_13461, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1850, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x148, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x149, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Photon> > > -------------------
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Photon> > > -------------------
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60220, type_60219), Reflex::Literal("operator="), operator_13462, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_13446), Reflex::Literal("assign"), method_13463, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13448), Reflex::Literal("begin"), method_13464, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13450), Reflex::Literal("begin"), method_13465, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13448), Reflex::Literal("end"), method_13466, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13450), Reflex::Literal("end"), method_13467, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_13472, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_13473, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_891), Reflex::Literal("resize"), method_13474, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_13475, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_13476, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_13477, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13444, type_5015), Reflex::Literal("operator[]"), operator_13478, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13446, type_5015), Reflex::Literal("operator[]"), operator_13479, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13444, type_5015), Reflex::Literal("at"), method_13481, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13446, type_5015), Reflex::Literal("at"), method_13482, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13444), Reflex::Literal("front"), method_13483, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13446), Reflex::Literal("front"), method_13484, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13444), Reflex::Literal("back"), method_13485, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13446), Reflex::Literal("back"), method_13486, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13440), Reflex::Literal("data"), method_13487, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13442), Reflex::Literal("data"), method_13488, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_13446), Reflex::Literal("push_back"), method_13489, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_13490, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13448, type_13448, type_13446), Reflex::Literal("insert"), method_13491, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_13448, type_5015, type_13446), Reflex::Literal("insert"), method_13492, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13448, type_13448), Reflex::Literal("erase"), method_13493, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13448, type_13448, type_13448), Reflex::Literal("erase"), method_13494, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_60220), Reflex::Literal("swap"), method_13495, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_13496, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> -------------------------------
static  void operator_16334( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*)o)->operator=)(*(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*)arg[0]);
  else   (((::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*)o)->operator=)(*(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*)arg[0]);
}

static void constructor_16335( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>(*(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*)arg[0]);
  else ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>(*(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*)arg[0]);
}

static void constructor_16336( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>();
  else ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>();
}

static void constructor_16337( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Muon>*)arg[1],
      *(const ::edm::Ptr<pat::Photon>*)arg[2],
      *(const ::edm::Ptr<pat::Photon>*)arg[3],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[4]);
  else ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Muon>*)arg[1],
      *(const ::edm::Ptr<pat::Photon>*)arg[2],
      *(const ::edm::Ptr<pat::Photon>*)arg[3],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[4]);
}

static  void method_16338( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*)o)->clone)());
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*)o)->clone)();
}

static  void method_16339( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_16340( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_16341( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*)o)->numberOfDaughters)());
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*)o)->numberOfDaughters)();
}

static  void method_16342( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_16343( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_16344(void*, void * o, const std::vector<void*>&, void *) {
(((::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*)o)->::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>::~PATQuadFinalStateT)();
}
static void method_newdel_2808( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x151( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> -------------------------------
void __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon__db_datamem(Reflex::Class*);
void __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon__datamem_bld(&__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon__db_datamem);
Reflex::GenreflexMemberBuilder __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon__funcmem_bld(&__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon__db_funcmem);
void __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>"), typeid(::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>), sizeof(::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6476, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>::daughter1_type"))
  .AddTypedef(type_6497, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>::daughter2_type"))
  .AddTypedef(type_6478, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>::daughter3_type"))
  .AddTypedef(type_6478, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>::daughter4_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13511, type_13513), Reflex::Literal("operator="), operator_16334, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13513), Reflex::Literal("PATQuadFinalStateT"), constructor_16335, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATQuadFinalStateT"), constructor_16336, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45636, type_45727, type_45637, type_45637, type_45406), Reflex::Literal("PATQuadFinalStateT"), constructor_16337, 0, "p1;p2;p3;p4;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATQuadFinalStateT"), destructor_16344, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2808, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x151, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon__funcmem_bld);
}

//------Delayed data member builder for class PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> -------------------
void __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9785, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9782, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_, p2_), ::Reflex::PRIVATE)
  .AddDataMember(type_9786, Reflex::Literal("p3_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_, p3_), ::Reflex::PRIVATE)
  .AddDataMember(type_9786, Reflex::Literal("p4_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_, p4_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> -------------------
void __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13507), Reflex::Literal("clone"), method_16338, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_16339, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_16340, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_16341, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_16342, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_16343, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class vector<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Photon, pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Photon, pat::Photon> > > -------------------------------
static void constructor_13524( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >();
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >();
}

static void constructor_13525( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >(*(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >(*(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)arg[0]);
}

static void constructor_13526( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*)arg[1]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*)arg[1],
      *(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)arg[2]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*)arg[1],
      *(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)arg[2]);
  }
}

static void constructor_13527( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)arg[0]);
}

static void destructor_13528(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >::~vector)();
}
static  void operator_13529( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->operator=)(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->operator=)(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)arg[0]);
}

static  void method_13530( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*)arg[1]);
}

static  void method_13531( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->begin)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->begin)();
}

static  void method_13532( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->begin)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->begin)();
}

static  void method_13533( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->end)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->end)();
}

static  void method_13534( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->end)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->end)();
}

static  void method_13539( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->size)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->size)();
}

static  void method_13540( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->max_size)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->max_size)();
}

static  void method_13541( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*)arg[1]);
  }
}

static  void method_13542( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->capacity)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->capacity)();
}

static  void method_13543( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->empty)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->empty)();
}

static  void method_13544( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_13545( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_13546( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_13548( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13549( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13550( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->front)();
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->front)();
}

static  void method_13551( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->front)();
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->front)();
}

static  void method_13552( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->back)();
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->back)();
}

static  void method_13553( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->back)();
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->back)();
}

static  void method_13554( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->data)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->data)();
}

static  void method_13555( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->data)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->data)();
}

static  void method_13556( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->push_back)(*(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*)arg[0]);
}

static  void method_13557( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->pop_back)();
}

static  void method_13558( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*)arg[1]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*)arg[1]);
}

static  void method_13559( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*)arg[2]);
}

static  void method_13560( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >*)arg[0]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >*)arg[0]);
}

static  void method_13561( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >*)arg[1]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >*)arg[1]);
}

static  void method_13562( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->swap)(*(::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)arg[0]);
}

static  void method_13563( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->clear)();
}

static void method_newdel_1852( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x153( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >")), ::Reflex::BaseOffset< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >,::std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x154( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >::Generate();
}

//------Dictionary for class vector<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Photon, pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Photon, pat::Photon> > > -------------------------------
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s__db_datamem(Reflex::Class*);
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s__datamem_bld(&__std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s__funcmem_bld(&__std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s__db_funcmem);
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >"), typeid(::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >), sizeof(::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3691, ::Reflex::BaseOffset< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >, ::std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2808, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >::_Alloc_value_type"))
  .AddTypedef(type_3691, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >::_Base"))
  .AddTypedef(type_5046, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >::_Tp_alloc_type"))
  .AddTypedef(type_2808, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >::value_type"))
  .AddTypedef(type_13507, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >::pointer"))
  .AddTypedef(type_13509, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >::const_pointer"))
  .AddTypedef(type_13511, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >::reference"))
  .AddTypedef(type_13513, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >::const_reference"))
  .AddTypedef(type_13515, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >::iterator"))
  .AddTypedef(type_13517, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >::const_iterator"))
  .AddTypedef(type_5635, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >::const_reverse_iterator"))
  .AddTypedef(type_5636, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >::difference_type"))
  .AddTypedef(type_5046, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_13524, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60222), Reflex::Literal("vector"), constructor_13525, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_13513, type_60222), Reflex::Literal("vector"), constructor_13526, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60223), Reflex::Literal("vector"), constructor_13527, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_13528, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1852, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x153, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x154, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Photon, pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Photon, pat::Photon> > > -------------------
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Photon, pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Photon, pat::Photon> > > -------------------
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60224, type_60223), Reflex::Literal("operator="), operator_13529, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_13513), Reflex::Literal("assign"), method_13530, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13515), Reflex::Literal("begin"), method_13531, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13517), Reflex::Literal("begin"), method_13532, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13515), Reflex::Literal("end"), method_13533, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13517), Reflex::Literal("end"), method_13534, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_13539, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_13540, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_2808), Reflex::Literal("resize"), method_13541, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_13542, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_13543, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_13544, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13511, type_5015), Reflex::Literal("operator[]"), operator_13545, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13513, type_5015), Reflex::Literal("operator[]"), operator_13546, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13511, type_5015), Reflex::Literal("at"), method_13548, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13513, type_5015), Reflex::Literal("at"), method_13549, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13511), Reflex::Literal("front"), method_13550, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13513), Reflex::Literal("front"), method_13551, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13511), Reflex::Literal("back"), method_13552, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13513), Reflex::Literal("back"), method_13553, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13507), Reflex::Literal("data"), method_13554, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13509), Reflex::Literal("data"), method_13555, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_13513), Reflex::Literal("push_back"), method_13556, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_13557, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13515, type_13515, type_13513), Reflex::Literal("insert"), method_13558, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_13515, type_5015, type_13513), Reflex::Literal("insert"), method_13559, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13515, type_13515), Reflex::Literal("erase"), method_13560, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13515, type_13515, type_13515), Reflex::Literal("erase"), method_13561, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_60224), Reflex::Literal("swap"), method_13562, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_13563, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<PATPairFinalStateT<pat::Muon, pat::Jet>,std::allocator<PATPairFinalStateT<pat::Muon, pat::Jet> > > -------------------------------
static void constructor_13632( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >();
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >();
}

static void constructor_13633( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >(*(const ::std::allocator<PATPairFinalStateT<pat::Muon,pat::Jet> >*)arg[0]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >(*(const ::std::allocator<PATPairFinalStateT<pat::Muon,pat::Jet> >*)arg[0]);
}

static void constructor_13634( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Muon,pat::Jet>*)arg[1]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Muon,pat::Jet>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Muon,pat::Jet>*)arg[1],
      *(const ::std::allocator<PATPairFinalStateT<pat::Muon,pat::Jet> >*)arg[2]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Muon,pat::Jet>*)arg[1],
      *(const ::std::allocator<PATPairFinalStateT<pat::Muon,pat::Jet> >*)arg[2]);
  }
}

static void constructor_13635( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >(*(const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)arg[0]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >(*(const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)arg[0]);
}

static void destructor_13636(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >::~vector)();
}
static  void operator_13637( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->operator=)(*(const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)arg[0]);
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->operator=)(*(const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)arg[0]);
}

static  void method_13638( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATPairFinalStateT<pat::Muon,pat::Jet>*)arg[1]);
}

static  void method_13639( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Jet>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >)((((::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->begin)());
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->begin)();
}

static  void method_13640( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Muon,pat::Jet>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >)((((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->begin)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->begin)();
}

static  void method_13641( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Jet>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >)((((::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->end)());
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->end)();
}

static  void method_13642( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Muon,pat::Jet>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >)((((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->end)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->end)();
}

static  void method_13647( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->size)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->size)();
}

static  void method_13648( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->max_size)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->max_size)();
}

static  void method_13649( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATPairFinalStateT<pat::Muon,pat::Jet>*)arg[1]);
  }
}

static  void method_13650( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->capacity)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->capacity)();
}

static  void method_13651( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->empty)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->empty)();
}

static  void method_13652( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_13653( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_13654( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_13656( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13657( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13658( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->front)();
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->front)();
}

static  void method_13659( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->front)();
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->front)();
}

static  void method_13660( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->back)();
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->back)();
}

static  void method_13661( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->back)();
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->back)();
}

static  void method_13662( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->data)());
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->data)();
}

static  void method_13663( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->data)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->data)();
}

static  void method_13664( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->push_back)(*(const ::PATPairFinalStateT<pat::Muon,pat::Jet>*)arg[0]);
}

static  void method_13665( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->pop_back)();
}

static  void method_13666( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Jet>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >)((((::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Jet>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >*)arg[0],
    *(const ::PATPairFinalStateT<pat::Muon,pat::Jet>*)arg[1]));
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Jet>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >*)arg[0],
    *(const ::PATPairFinalStateT<pat::Muon,pat::Jet>*)arg[1]);
}

static  void method_13667( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Jet>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATPairFinalStateT<pat::Muon,pat::Jet>*)arg[2]);
}

static  void method_13668( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Jet>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >)((((::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Jet>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >*)arg[0]));
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Jet>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >*)arg[0]);
}

static  void method_13669( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Jet>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >)((((::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Jet>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Jet>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >*)arg[1]));
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Jet>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Jet>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >*)arg[1]);
}

static  void method_13670( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->swap)(*(::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)arg[0]);
}

static  void method_13671( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->clear)();
}

static void method_newdel_1869( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x156( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATPairFinalStateT<pat::Muon,pat::Jet>,std::allocator<PATPairFinalStateT<pat::Muon,pat::Jet> > >")), ::Reflex::BaseOffset< ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >,::std::_Vector_base<PATPairFinalStateT<pat::Muon,pat::Jet>,std::allocator<PATPairFinalStateT<pat::Muon,pat::Jet> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x157( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >::Generate();
}

//------Dictionary for class vector<PATPairFinalStateT<pat::Muon, pat::Jet>,std::allocator<PATPairFinalStateT<pat::Muon, pat::Jet> > > -------------------------------
void __std__vector_PATPairFinalStateT_pat__Muon_pat__Jet_s__db_datamem(Reflex::Class*);
void __std__vector_PATPairFinalStateT_pat__Muon_pat__Jet_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATPairFinalStateT_pat__Muon_pat__Jet_s__datamem_bld(&__std__vector_PATPairFinalStateT_pat__Muon_pat__Jet_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATPairFinalStateT_pat__Muon_pat__Jet_s__funcmem_bld(&__std__vector_PATPairFinalStateT_pat__Muon_pat__Jet_s__db_funcmem);
void __std__vector_PATPairFinalStateT_pat__Muon_pat__Jet_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >"), typeid(::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >), sizeof(::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3721, ::Reflex::BaseOffset< ::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >, ::std::_Vector_base<PATPairFinalStateT<pat::Muon,pat::Jet>,std::allocator<PATPairFinalStateT<pat::Muon,pat::Jet> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_288, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >::_Alloc_value_type"))
  .AddTypedef(type_3721, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >::_Base"))
  .AddTypedef(type_5076, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >::_Tp_alloc_type"))
  .AddTypedef(type_288, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >::value_type"))
  .AddTypedef(type_13615, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >::pointer"))
  .AddTypedef(type_13617, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >::const_pointer"))
  .AddTypedef(type_13619, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >::reference"))
  .AddTypedef(type_13621, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >::const_reference"))
  .AddTypedef(type_13623, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >::iterator"))
  .AddTypedef(type_13625, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >::const_iterator"))
  .AddTypedef(type_5695, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >::const_reverse_iterator"))
  .AddTypedef(type_5696, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >::difference_type"))
  .AddTypedef(type_5076, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_13632, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60230), Reflex::Literal("vector"), constructor_13633, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_13621, type_60230), Reflex::Literal("vector"), constructor_13634, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60231), Reflex::Literal("vector"), constructor_13635, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_13636, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1869, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x156, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x157, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATPairFinalStateT_pat__Muon_pat__Jet_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATPairFinalStateT<pat::Muon, pat::Jet>,std::allocator<PATPairFinalStateT<pat::Muon, pat::Jet> > > -------------------
void __std__vector_PATPairFinalStateT_pat__Muon_pat__Jet_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATPairFinalStateT<pat::Muon, pat::Jet>,std::allocator<PATPairFinalStateT<pat::Muon, pat::Jet> > > -------------------
void __std__vector_PATPairFinalStateT_pat__Muon_pat__Jet_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60232, type_60231), Reflex::Literal("operator="), operator_13637, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_13621), Reflex::Literal("assign"), method_13638, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13623), Reflex::Literal("begin"), method_13639, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13625), Reflex::Literal("begin"), method_13640, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13623), Reflex::Literal("end"), method_13641, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13625), Reflex::Literal("end"), method_13642, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_13647, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_13648, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_288), Reflex::Literal("resize"), method_13649, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_13650, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_13651, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_13652, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13619, type_5015), Reflex::Literal("operator[]"), operator_13653, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13621, type_5015), Reflex::Literal("operator[]"), operator_13654, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13619, type_5015), Reflex::Literal("at"), method_13656, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13621, type_5015), Reflex::Literal("at"), method_13657, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13619), Reflex::Literal("front"), method_13658, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13621), Reflex::Literal("front"), method_13659, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13619), Reflex::Literal("back"), method_13660, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13621), Reflex::Literal("back"), method_13661, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13615), Reflex::Literal("data"), method_13662, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13617), Reflex::Literal("data"), method_13663, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_13621), Reflex::Literal("push_back"), method_13664, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_13665, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13623, type_13623, type_13621), Reflex::Literal("insert"), method_13666, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_13623, type_5015, type_13621), Reflex::Literal("insert"), method_13667, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13623, type_13623), Reflex::Literal("erase"), method_13668, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13623, type_13623, type_13623), Reflex::Literal("erase"), method_13669, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_60232), Reflex::Literal("swap"), method_13670, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_13671, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> -------------------------------
static  void operator_12505( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*)o)->operator=)(*(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*)arg[0]);
  else   (((::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*)o)->operator=)(*(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*)arg[0]);
}

static void constructor_12506( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>(*(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*)arg[0]);
  else ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>(*(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*)arg[0]);
}

static void constructor_12507( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>();
  else ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>();
}

static void constructor_12508( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Electron>*)arg[1],
      *(const ::edm::Ptr<pat::Muon>*)arg[2],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[3]);
  else ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Electron>*)arg[1],
      *(const ::edm::Ptr<pat::Muon>*)arg[2],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[3]);
}

static  void method_12509( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*)o)->clone)());
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*)o)->clone)();
}

static  void method_12510( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_12511( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_12512( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*)o)->numberOfDaughters)());
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*)o)->numberOfDaughters)();
}

static  void method_12513( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_12514( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_12515(void*, void * o, const std::vector<void*>&, void *) {
(((::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*)o)->::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>::~PATTripletFinalStateT)();
}
static void method_newdel_1523( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x159( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> -------------------------------
void __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon__db_datamem(Reflex::Class*);
void __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon__datamem_bld(&__PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon__db_datamem);
Reflex::GenreflexMemberBuilder __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon__funcmem_bld(&__PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon__db_funcmem);
void __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>"), typeid(::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>), sizeof(::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6476, Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>::daughter1_type"))
  .AddTypedef(type_6476, Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>::daughter2_type"))
  .AddTypedef(type_6497, Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>::daughter3_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13940, type_13942), Reflex::Literal("operator="), operator_12505, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13942), Reflex::Literal("PATTripletFinalStateT"), constructor_12506, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATTripletFinalStateT"), constructor_12507, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45636, type_45636, type_45727, type_45406), Reflex::Literal("PATTripletFinalStateT"), constructor_12508, 0, "p1;p2;p3;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATTripletFinalStateT"), destructor_12515, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1523, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x159, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon__funcmem_bld);
}

//------Delayed data member builder for class PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> -------------------
void __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9785, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9785, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_, p2_), ::Reflex::PRIVATE)
  .AddDataMember(type_9782, Reflex::Literal("p3_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_, p3_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> -------------------
void __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13936), Reflex::Literal("clone"), method_12509, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_12510, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_12511, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_12512, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_12513, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_12514, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class vector<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Muon>,std::allocator<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Muon> > > -------------------------------
static void constructor_13953( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >();
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >();
}

static void constructor_13954( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >(*(const ::std::allocator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >(*(const ::std::allocator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)arg[0]);
}

static void constructor_13955( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*)arg[1]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*)arg[1],
      *(const ::std::allocator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)arg[2]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*)arg[1],
      *(const ::std::allocator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)arg[2]);
  }
}

static void constructor_13956( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >(*(const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >(*(const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)arg[0]);
}

static void destructor_13957(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >::~vector)();
}
static  void operator_13958( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->operator=)(*(const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->operator=)(*(const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)arg[0]);
}

static  void method_13959( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*)arg[1]);
}

static  void method_13960( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->begin)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->begin)();
}

static  void method_13961( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->begin)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->begin)();
}

static  void method_13962( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->end)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->end)();
}

static  void method_13963( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->end)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->end)();
}

static  void method_13968( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->size)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->size)();
}

static  void method_13969( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->max_size)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->max_size)();
}

static  void method_13970( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*)arg[1]);
  }
}

static  void method_13971( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->capacity)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->capacity)();
}

static  void method_13972( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->empty)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->empty)();
}

static  void method_13973( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_13974( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_13975( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_13977( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13978( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13979( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->front)();
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->front)();
}

static  void method_13980( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->front)();
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->front)();
}

static  void method_13981( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->back)();
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->back)();
}

static  void method_13982( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->back)();
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->back)();
}

static  void method_13983( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->data)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->data)();
}

static  void method_13984( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->data)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->data)();
}

static  void method_13985( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->push_back)(*(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*)arg[0]);
}

static  void method_13986( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->pop_back)();
}

static  void method_13987( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*)arg[1]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*)arg[1]);
}

static  void method_13988( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*)arg[2]);
}

static  void method_13989( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >*)arg[0]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >*)arg[0]);
}

static  void method_13990( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >*)arg[1]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >*)arg[1]);
}

static  void method_13991( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->swap)(*(::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)arg[0]);
}

static  void method_13992( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->clear)();
}

static void method_newdel_1976( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x161( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >")), ::Reflex::BaseOffset< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >,::std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x162( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >::Generate();
}

//------Dictionary for class vector<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Muon>,std::allocator<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Muon> > > -------------------------------
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s__db_datamem(Reflex::Class*);
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s__datamem_bld(&__std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s__funcmem_bld(&__std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s__db_funcmem);
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >"), typeid(::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >), sizeof(::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3718, ::Reflex::BaseOffset< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >, ::std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1523, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >::_Alloc_value_type"))
  .AddTypedef(type_3718, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >::_Base"))
  .AddTypedef(type_5073, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >::_Tp_alloc_type"))
  .AddTypedef(type_1523, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >::value_type"))
  .AddTypedef(type_13936, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >::pointer"))
  .AddTypedef(type_13938, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >::const_pointer"))
  .AddTypedef(type_13940, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >::reference"))
  .AddTypedef(type_13942, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >::const_reference"))
  .AddTypedef(type_13944, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >::iterator"))
  .AddTypedef(type_13946, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >::const_iterator"))
  .AddTypedef(type_5689, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >::const_reverse_iterator"))
  .AddTypedef(type_5690, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >::difference_type"))
  .AddTypedef(type_5073, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_13953, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60356), Reflex::Literal("vector"), constructor_13954, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_13942, type_60356), Reflex::Literal("vector"), constructor_13955, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60357), Reflex::Literal("vector"), constructor_13956, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_13957, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1976, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x161, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x162, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Muon>,std::allocator<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Muon> > > -------------------
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Muon>,std::allocator<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Muon> > > -------------------
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60358, type_60357), Reflex::Literal("operator="), operator_13958, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_13942), Reflex::Literal("assign"), method_13959, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13944), Reflex::Literal("begin"), method_13960, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13946), Reflex::Literal("begin"), method_13961, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13944), Reflex::Literal("end"), method_13962, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13946), Reflex::Literal("end"), method_13963, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_13968, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_13969, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_1523), Reflex::Literal("resize"), method_13970, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_13971, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_13972, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_13973, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13940, type_5015), Reflex::Literal("operator[]"), operator_13974, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13942, type_5015), Reflex::Literal("operator[]"), operator_13975, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13940, type_5015), Reflex::Literal("at"), method_13977, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13942, type_5015), Reflex::Literal("at"), method_13978, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13940), Reflex::Literal("front"), method_13979, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13942), Reflex::Literal("front"), method_13980, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13940), Reflex::Literal("back"), method_13981, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13942), Reflex::Literal("back"), method_13982, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13936), Reflex::Literal("data"), method_13983, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13938), Reflex::Literal("data"), method_13984, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_13942), Reflex::Literal("push_back"), method_13985, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_13986, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13944, type_13944, type_13942), Reflex::Literal("insert"), method_13987, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_13944, type_5015, type_13942), Reflex::Literal("insert"), method_13988, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13944, type_13944), Reflex::Literal("erase"), method_13989, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13944, type_13944, type_13944), Reflex::Literal("erase"), method_13990, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_60358), Reflex::Literal("swap"), method_13991, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_13992, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Tau, pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Tau, pat::Tau> > > -------------------------------
static void constructor_14058( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >();
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >();
}

static void constructor_14059( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >(*(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >(*(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)arg[0]);
}

static void constructor_14060( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*)arg[1]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*)arg[1],
      *(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)arg[2]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*)arg[1],
      *(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)arg[2]);
  }
}

static void constructor_14061( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)arg[0]);
}

static void destructor_14062(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >::~vector)();
}
static  void operator_14063( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->operator=)(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->operator=)(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)arg[0]);
}

static  void method_14064( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*)arg[1]);
}

static  void method_14065( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->begin)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->begin)();
}

static  void method_14066( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->begin)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->begin)();
}

static  void method_14067( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->end)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->end)();
}

static  void method_14068( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->end)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->end)();
}

static  void method_14073( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->size)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->size)();
}

static  void method_14074( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->max_size)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->max_size)();
}

static  void method_14075( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*)arg[1]);
  }
}

static  void method_14076( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->capacity)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->capacity)();
}

static  void method_14077( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->empty)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->empty)();
}

static  void method_14078( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_14079( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_14080( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_14082( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14083( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14084( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->front)();
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->front)();
}

static  void method_14085( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->front)();
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->front)();
}

static  void method_14086( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->back)();
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->back)();
}

static  void method_14087( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->back)();
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->back)();
}

static  void method_14088( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->data)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->data)();
}

static  void method_14089( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->data)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->data)();
}

static  void method_14090( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->push_back)(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*)arg[0]);
}

static  void method_14091( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->pop_back)();
}

static  void method_14092( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*)arg[1]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*)arg[1]);
}

static  void method_14093( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*)arg[2]);
}

static  void method_14094( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >*)arg[0]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >*)arg[0]);
}

static  void method_14095( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >*)arg[1]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >*)arg[1]);
}

static  void method_14096( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->swap)(*(::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)arg[0]);
}

static  void method_14097( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->clear)();
}

static void method_newdel_1982( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x164( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >")), ::Reflex::BaseOffset< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >,::std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x165( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >::Generate();
}

//------Dictionary for class vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Tau, pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Tau, pat::Tau> > > -------------------------------
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s__db_datamem(Reflex::Class*);
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s__datamem_bld(&__std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s__funcmem_bld(&__std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s__db_funcmem);
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >"), typeid(::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >), sizeof(::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3697, ::Reflex::BaseOffset< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >, ::std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_956, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >::_Alloc_value_type"))
  .AddTypedef(type_3697, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >::_Base"))
  .AddTypedef(type_5052, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >::_Tp_alloc_type"))
  .AddTypedef(type_956, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >::value_type"))
  .AddTypedef(type_14041, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >::pointer"))
  .AddTypedef(type_14043, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >::const_pointer"))
  .AddTypedef(type_14045, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >::reference"))
  .AddTypedef(type_14047, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >::const_reference"))
  .AddTypedef(type_14049, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >::iterator"))
  .AddTypedef(type_14051, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >::const_iterator"))
  .AddTypedef(type_5647, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >::const_reverse_iterator"))
  .AddTypedef(type_5648, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >::difference_type"))
  .AddTypedef(type_5052, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_14058, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60363), Reflex::Literal("vector"), constructor_14059, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_14047, type_60363), Reflex::Literal("vector"), constructor_14060, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60364), Reflex::Literal("vector"), constructor_14061, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_14062, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1982, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x164, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x165, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Tau, pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Tau, pat::Tau> > > -------------------
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Tau, pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Tau, pat::Tau> > > -------------------
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60365, type_60364), Reflex::Literal("operator="), operator_14063, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_14047), Reflex::Literal("assign"), method_14064, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14049), Reflex::Literal("begin"), method_14065, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14051), Reflex::Literal("begin"), method_14066, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14049), Reflex::Literal("end"), method_14067, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14051), Reflex::Literal("end"), method_14068, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_14073, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_14074, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_956), Reflex::Literal("resize"), method_14075, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_14076, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_14077, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_14078, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14045, type_5015), Reflex::Literal("operator[]"), operator_14079, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14047, type_5015), Reflex::Literal("operator[]"), operator_14080, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14045, type_5015), Reflex::Literal("at"), method_14082, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14047, type_5015), Reflex::Literal("at"), method_14083, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14045), Reflex::Literal("front"), method_14084, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14047), Reflex::Literal("front"), method_14085, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14045), Reflex::Literal("back"), method_14086, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14047), Reflex::Literal("back"), method_14087, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14041), Reflex::Literal("data"), method_14088, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14043), Reflex::Literal("data"), method_14089, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_14047), Reflex::Literal("push_back"), method_14090, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_14091, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14049, type_14049, type_14047), Reflex::Literal("insert"), method_14092, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_14049, type_5015, type_14047), Reflex::Literal("insert"), method_14093, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14049, type_14049), Reflex::Literal("erase"), method_14094, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14049, type_14049, type_14049), Reflex::Literal("erase"), method_14095, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_60365), Reflex::Literal("swap"), method_14096, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_14097, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> -------------------------------
static  void operator_12488( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*)o)->operator=)(*(const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*)arg[0]);
  else   (((::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*)o)->operator=)(*(const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*)arg[0]);
}

static void constructor_12489( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>(*(const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*)arg[0]);
  else ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>(*(const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*)arg[0]);
}

static void constructor_12490( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>();
  else ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>();
}

static void constructor_12491( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Muon>*)arg[1],
      *(const ::edm::Ptr<pat::Muon>*)arg[2],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[3]);
  else ::new(mem) ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Muon>*)arg[1],
      *(const ::edm::Ptr<pat::Muon>*)arg[2],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[3]);
}

static  void method_12492( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*)o)->clone)());
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*)o)->clone)();
}

static  void method_12493( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_12494( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_12495( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*)o)->numberOfDaughters)());
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*)o)->numberOfDaughters)();
}

static  void method_12496( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_12497( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_12498(void*, void * o, const std::vector<void*>&, void *) {
(((::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*)o)->::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>::~PATTripletFinalStateT)();
}
static void method_newdel_1522( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x167( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> -------------------------------
void __PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon__db_datamem(Reflex::Class*);
void __PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon__datamem_bld(&__PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon__db_datamem);
Reflex::GenreflexMemberBuilder __PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon__funcmem_bld(&__PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon__db_funcmem);
void __PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>"), typeid(::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>), sizeof(::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6476, Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>::daughter1_type"))
  .AddTypedef(type_6497, Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>::daughter2_type"))
  .AddTypedef(type_6497, Reflex::Literal("PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>::daughter3_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14179, type_14181), Reflex::Literal("operator="), operator_12488, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14181), Reflex::Literal("PATTripletFinalStateT"), constructor_12489, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATTripletFinalStateT"), constructor_12490, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45636, type_45727, type_45727, type_45406), Reflex::Literal("PATTripletFinalStateT"), constructor_12491, 0, "p1;p2;p3;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATTripletFinalStateT"), destructor_12498, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1522, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x167, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon__funcmem_bld);
}

//------Delayed data member builder for class PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> -------------------
void __PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9785, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9782, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_, p2_), ::Reflex::PRIVATE)
  .AddDataMember(type_9782, Reflex::Literal("p3_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_, p3_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> -------------------
void __PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14175), Reflex::Literal("clone"), method_12492, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_12493, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_12494, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_12495, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_12496, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_12497, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class vector<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Muon>,std::allocator<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Muon> > > -------------------------------
static void constructor_14192( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >();
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >();
}

static void constructor_14193( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >(*(const ::std::allocator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >(*(const ::std::allocator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)arg[0]);
}

static void constructor_14194( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*)arg[1]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*)arg[1],
      *(const ::std::allocator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)arg[2]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*)arg[1],
      *(const ::std::allocator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)arg[2]);
  }
}

static void constructor_14195( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >(*(const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >(*(const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)arg[0]);
}

static void destructor_14196(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >::~vector)();
}
static  void operator_14197( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->operator=)(*(const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->operator=)(*(const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)arg[0]);
}

static  void method_14198( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*)arg[1]);
}

static  void method_14199( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->begin)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->begin)();
}

static  void method_14200( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->begin)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->begin)();
}

static  void method_14201( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->end)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->end)();
}

static  void method_14202( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->end)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->end)();
}

static  void method_14207( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->size)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->size)();
}

static  void method_14208( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->max_size)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->max_size)();
}

static  void method_14209( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*)arg[1]);
  }
}

static  void method_14210( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->capacity)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->capacity)();
}

static  void method_14211( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->empty)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->empty)();
}

static  void method_14212( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_14213( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_14214( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_14216( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14217( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14218( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->front)();
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->front)();
}

static  void method_14219( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->front)();
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->front)();
}

static  void method_14220( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->back)();
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->back)();
}

static  void method_14221( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->back)();
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->back)();
}

static  void method_14222( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->data)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->data)();
}

static  void method_14223( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->data)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->data)();
}

static  void method_14224( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->push_back)(*(const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*)arg[0]);
}

static  void method_14225( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->pop_back)();
}

static  void method_14226( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*)arg[1]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*)arg[1]);
}

static  void method_14227( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*)arg[2]);
}

static  void method_14228( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >*)arg[0]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >*)arg[0]);
}

static  void method_14229( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >*)arg[1]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >*)arg[1]);
}

static  void method_14230( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->swap)(*(::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)arg[0]);
}

static  void method_14231( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->clear)();
}

static void method_newdel_2030( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x169( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >")), ::Reflex::BaseOffset< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >,::std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x170( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >::Generate();
}

//------Dictionary for class vector<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Muon>,std::allocator<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Muon> > > -------------------------------
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s__db_datamem(Reflex::Class*);
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s__datamem_bld(&__std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s__funcmem_bld(&__std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s__db_funcmem);
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >"), typeid(::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >), sizeof(::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3715, ::Reflex::BaseOffset< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >, ::std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1522, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >::_Alloc_value_type"))
  .AddTypedef(type_3715, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >::_Base"))
  .AddTypedef(type_5070, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >::_Tp_alloc_type"))
  .AddTypedef(type_1522, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >::value_type"))
  .AddTypedef(type_14175, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >::pointer"))
  .AddTypedef(type_14177, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >::const_pointer"))
  .AddTypedef(type_14179, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >::reference"))
  .AddTypedef(type_14181, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >::const_reference"))
  .AddTypedef(type_14183, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >::iterator"))
  .AddTypedef(type_14185, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >::const_iterator"))
  .AddTypedef(type_5683, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >::const_reverse_iterator"))
  .AddTypedef(type_5684, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >::difference_type"))
  .AddTypedef(type_5070, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_14192, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60395), Reflex::Literal("vector"), constructor_14193, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_14181, type_60395), Reflex::Literal("vector"), constructor_14194, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60396), Reflex::Literal("vector"), constructor_14195, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_14196, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2030, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x169, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x170, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Muon>,std::allocator<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Muon> > > -------------------
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Muon>,std::allocator<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Muon> > > -------------------
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60397, type_60396), Reflex::Literal("operator="), operator_14197, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_14181), Reflex::Literal("assign"), method_14198, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14183), Reflex::Literal("begin"), method_14199, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14185), Reflex::Literal("begin"), method_14200, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14183), Reflex::Literal("end"), method_14201, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14185), Reflex::Literal("end"), method_14202, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_14207, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_14208, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_1522), Reflex::Literal("resize"), method_14209, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_14210, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_14211, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_14212, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14179, type_5015), Reflex::Literal("operator[]"), operator_14213, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14181, type_5015), Reflex::Literal("operator[]"), operator_14214, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14179, type_5015), Reflex::Literal("at"), method_14216, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14181, type_5015), Reflex::Literal("at"), method_14217, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14179), Reflex::Literal("front"), method_14218, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14181), Reflex::Literal("front"), method_14219, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14179), Reflex::Literal("back"), method_14220, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14181), Reflex::Literal("back"), method_14221, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14175), Reflex::Literal("data"), method_14222, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14177), Reflex::Literal("data"), method_14223, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_14181), Reflex::Literal("push_back"), method_14224, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_14225, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14183, type_14183, type_14181), Reflex::Literal("insert"), method_14226, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_14183, type_5015, type_14181), Reflex::Literal("insert"), method_14227, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14183, type_14183), Reflex::Literal("erase"), method_14228, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14183, type_14183, type_14183), Reflex::Literal("erase"), method_14229, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_60397), Reflex::Literal("swap"), method_14230, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_14231, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Electron>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Electron> > > -------------------------------
static void constructor_14259( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >();
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >();
}

static void constructor_14260( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >(*(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >(*(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)arg[0]);
}

static void constructor_14261( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*)arg[1]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*)arg[1],
      *(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)arg[2]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*)arg[1],
      *(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)arg[2]);
  }
}

static void constructor_14262( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)arg[0]);
}

static void destructor_14263(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >::~vector)();
}
static  void operator_14264( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->operator=)(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->operator=)(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)arg[0]);
}

static  void method_14265( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*)arg[1]);
}

static  void method_14266( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->begin)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->begin)();
}

static  void method_14267( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->begin)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->begin)();
}

static  void method_14268( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->end)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->end)();
}

static  void method_14269( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->end)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->end)();
}

static  void method_14274( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->size)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->size)();
}

static  void method_14275( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->max_size)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->max_size)();
}

static  void method_14276( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*)arg[1]);
  }
}

static  void method_14277( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->capacity)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->capacity)();
}

static  void method_14278( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->empty)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->empty)();
}

static  void method_14279( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_14280( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_14281( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_14283( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14284( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14285( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->front)();
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->front)();
}

static  void method_14286( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->front)();
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->front)();
}

static  void method_14287( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->back)();
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->back)();
}

static  void method_14288( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->back)();
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->back)();
}

static  void method_14289( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->data)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->data)();
}

static  void method_14290( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->data)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->data)();
}

static  void method_14291( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->push_back)(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*)arg[0]);
}

static  void method_14292( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->pop_back)();
}

static  void method_14293( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*)arg[1]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*)arg[1]);
}

static  void method_14294( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*)arg[2]);
}

static  void method_14295( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >*)arg[0]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >*)arg[0]);
}

static  void method_14296( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >*)arg[1]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >*)arg[1]);
}

static  void method_14297( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->swap)(*(::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)arg[0]);
}

static  void method_14298( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->clear)();
}

static void method_newdel_2037( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x172( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >")), ::Reflex::BaseOffset< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >,::std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x173( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >::Generate();
}

//------Dictionary for class vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Electron>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Electron> > > -------------------------------
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s__db_datamem(Reflex::Class*);
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s__datamem_bld(&__std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s__funcmem_bld(&__std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s__db_funcmem);
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >"), typeid(::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >), sizeof(::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3704, ::Reflex::BaseOffset< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >, ::std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_505, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >::_Alloc_value_type"))
  .AddTypedef(type_3704, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >::_Base"))
  .AddTypedef(type_5059, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >::_Tp_alloc_type"))
  .AddTypedef(type_505, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >::value_type"))
  .AddTypedef(type_14242, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >::pointer"))
  .AddTypedef(type_14244, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >::const_pointer"))
  .AddTypedef(type_14246, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >::reference"))
  .AddTypedef(type_14248, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >::const_reference"))
  .AddTypedef(type_14250, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >::iterator"))
  .AddTypedef(type_14252, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >::const_iterator"))
  .AddTypedef(type_5661, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >::const_reverse_iterator"))
  .AddTypedef(type_5662, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >::difference_type"))
  .AddTypedef(type_5059, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_14259, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60399), Reflex::Literal("vector"), constructor_14260, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_14248, type_60399), Reflex::Literal("vector"), constructor_14261, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60400), Reflex::Literal("vector"), constructor_14262, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_14263, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2037, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x172, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x173, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Electron>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Electron> > > -------------------
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Electron>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Electron> > > -------------------
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60401, type_60400), Reflex::Literal("operator="), operator_14264, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_14248), Reflex::Literal("assign"), method_14265, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14250), Reflex::Literal("begin"), method_14266, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14252), Reflex::Literal("begin"), method_14267, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14250), Reflex::Literal("end"), method_14268, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14252), Reflex::Literal("end"), method_14269, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_14274, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_14275, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_505), Reflex::Literal("resize"), method_14276, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_14277, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_14278, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_14279, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14246, type_5015), Reflex::Literal("operator[]"), operator_14280, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14248, type_5015), Reflex::Literal("operator[]"), operator_14281, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14246, type_5015), Reflex::Literal("at"), method_14283, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14248, type_5015), Reflex::Literal("at"), method_14284, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14246), Reflex::Literal("front"), method_14285, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14248), Reflex::Literal("front"), method_14286, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14246), Reflex::Literal("back"), method_14287, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14248), Reflex::Literal("back"), method_14288, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14242), Reflex::Literal("data"), method_14289, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14244), Reflex::Literal("data"), method_14290, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_14248), Reflex::Literal("push_back"), method_14291, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_14292, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14250, type_14250, type_14248), Reflex::Literal("insert"), method_14293, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_14250, type_5015, type_14248), Reflex::Literal("insert"), method_14294, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14250, type_14250), Reflex::Literal("erase"), method_14295, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14250, type_14250, type_14250), Reflex::Literal("erase"), method_14296, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_60401), Reflex::Literal("swap"), method_14297, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_14298, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> -------------------------------
static  void operator_16353( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*)o)->operator=)(*(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*)arg[0]);
  else   (((::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*)o)->operator=)(*(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*)arg[0]);
}

static void constructor_16354( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>(*(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*)arg[0]);
  else ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>(*(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*)arg[0]);
}

static void constructor_16355( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>();
  else ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>();
}

static void constructor_16356( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Muon>*)arg[1],
      *(const ::edm::Ptr<pat::Muon>*)arg[2],
      *(const ::edm::Ptr<pat::Photon>*)arg[3],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[4]);
  else ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Muon>*)arg[1],
      *(const ::edm::Ptr<pat::Muon>*)arg[2],
      *(const ::edm::Ptr<pat::Photon>*)arg[3],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[4]);
}

static  void method_16357( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*)o)->clone)());
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*)o)->clone)();
}

static  void method_16358( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_16359( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_16360( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*)o)->numberOfDaughters)());
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*)o)->numberOfDaughters)();
}

static  void method_16361( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_16362( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_16363(void*, void * o, const std::vector<void*>&, void *) {
(((::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*)o)->::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>::~PATQuadFinalStateT)();
}
static void method_newdel_2809( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x175( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> -------------------------------
void __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon__db_datamem(Reflex::Class*);
void __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon__datamem_bld(&__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon__db_datamem);
Reflex::GenreflexMemberBuilder __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon__funcmem_bld(&__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon__db_funcmem);
void __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>"), typeid(::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>), sizeof(::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6476, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>::daughter1_type"))
  .AddTypedef(type_6497, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>::daughter2_type"))
  .AddTypedef(type_6497, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>::daughter3_type"))
  .AddTypedef(type_6478, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>::daughter4_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14498, type_14500), Reflex::Literal("operator="), operator_16353, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14500), Reflex::Literal("PATQuadFinalStateT"), constructor_16354, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATQuadFinalStateT"), constructor_16355, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45636, type_45727, type_45727, type_45637, type_45406), Reflex::Literal("PATQuadFinalStateT"), constructor_16356, 0, "p1;p2;p3;p4;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATQuadFinalStateT"), destructor_16363, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2809, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x175, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon__funcmem_bld);
}

//------Delayed data member builder for class PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> -------------------
void __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9785, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9782, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_, p2_), ::Reflex::PRIVATE)
  .AddDataMember(type_9782, Reflex::Literal("p3_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_, p3_), ::Reflex::PRIVATE)
  .AddDataMember(type_9786, Reflex::Literal("p4_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_, p4_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> -------------------
void __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14494), Reflex::Literal("clone"), method_16357, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_16358, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_16359, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_16360, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_16361, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_16362, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class vector<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Photon> > > -------------------------------
static void constructor_14511( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >();
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >();
}

static void constructor_14512( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >(*(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >(*(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)arg[0]);
}

static void constructor_14513( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*)arg[1]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*)arg[1],
      *(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)arg[2]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*)arg[1],
      *(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)arg[2]);
  }
}

static void constructor_14514( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)arg[0]);
}

static void destructor_14515(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >::~vector)();
}
static  void operator_14516( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->operator=)(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->operator=)(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)arg[0]);
}

static  void method_14517( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*)arg[1]);
}

static  void method_14518( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->begin)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->begin)();
}

static  void method_14519( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->begin)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->begin)();
}

static  void method_14520( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->end)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->end)();
}

static  void method_14521( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->end)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->end)();
}

static  void method_14526( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->size)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->size)();
}

static  void method_14527( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->max_size)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->max_size)();
}

static  void method_14528( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*)arg[1]);
  }
}

static  void method_14529( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->capacity)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->capacity)();
}

static  void method_14530( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->empty)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->empty)();
}

static  void method_14531( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_14532( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_14533( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_14535( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14536( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14537( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->front)();
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->front)();
}

static  void method_14538( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->front)();
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->front)();
}

static  void method_14539( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->back)();
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->back)();
}

static  void method_14540( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->back)();
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->back)();
}

static  void method_14541( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->data)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->data)();
}

static  void method_14542( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->data)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->data)();
}

static  void method_14543( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->push_back)(*(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*)arg[0]);
}

static  void method_14544( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->pop_back)();
}

static  void method_14545( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*)arg[1]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*)arg[1]);
}

static  void method_14546( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*)arg[2]);
}

static  void method_14547( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >*)arg[0]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >*)arg[0]);
}

static  void method_14548( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >*)arg[1]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >*)arg[1]);
}

static  void method_14549( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->swap)(*(::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)arg[0]);
}

static  void method_14550( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->clear)();
}

static void method_newdel_2163( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x177( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >")), ::Reflex::BaseOffset< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >,::std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x178( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >::Generate();
}

//------Dictionary for class vector<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Photon> > > -------------------------------
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s__db_datamem(Reflex::Class*);
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s__datamem_bld(&__std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s__funcmem_bld(&__std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s__db_funcmem);
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >"), typeid(::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >), sizeof(::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3693, ::Reflex::BaseOffset< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >, ::std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2809, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >::_Alloc_value_type"))
  .AddTypedef(type_3693, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >::_Base"))
  .AddTypedef(type_5048, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >::_Tp_alloc_type"))
  .AddTypedef(type_2809, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >::value_type"))
  .AddTypedef(type_14494, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >::pointer"))
  .AddTypedef(type_14496, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >::const_pointer"))
  .AddTypedef(type_14498, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >::reference"))
  .AddTypedef(type_14500, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >::const_reference"))
  .AddTypedef(type_14502, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >::iterator"))
  .AddTypedef(type_14504, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >::const_iterator"))
  .AddTypedef(type_5639, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >::const_reverse_iterator"))
  .AddTypedef(type_5640, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >::difference_type"))
  .AddTypedef(type_5048, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_14511, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60791), Reflex::Literal("vector"), constructor_14512, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_14500, type_60791), Reflex::Literal("vector"), constructor_14513, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60792), Reflex::Literal("vector"), constructor_14514, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_14515, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2163, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x177, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x178, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Photon> > > -------------------
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Photon> > > -------------------
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60793, type_60792), Reflex::Literal("operator="), operator_14516, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_14500), Reflex::Literal("assign"), method_14517, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14502), Reflex::Literal("begin"), method_14518, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14504), Reflex::Literal("begin"), method_14519, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14502), Reflex::Literal("end"), method_14520, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14504), Reflex::Literal("end"), method_14521, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_14526, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_14527, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_2809), Reflex::Literal("resize"), method_14528, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_14529, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_14530, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_14531, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14498, type_5015), Reflex::Literal("operator[]"), operator_14532, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14500, type_5015), Reflex::Literal("operator[]"), operator_14533, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14498, type_5015), Reflex::Literal("at"), method_14535, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14500, type_5015), Reflex::Literal("at"), method_14536, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14498), Reflex::Literal("front"), method_14537, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14500), Reflex::Literal("front"), method_14538, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14498), Reflex::Literal("back"), method_14539, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14500), Reflex::Literal("back"), method_14540, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14494), Reflex::Literal("data"), method_14541, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14496), Reflex::Literal("data"), method_14542, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_14500), Reflex::Literal("push_back"), method_14543, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_14544, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14502, type_14502, type_14500), Reflex::Literal("insert"), method_14545, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_14502, type_5015, type_14500), Reflex::Literal("insert"), method_14546, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14502, type_14502), Reflex::Literal("erase"), method_14547, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14502, type_14502, type_14502), Reflex::Literal("erase"), method_14548, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_60793), Reflex::Literal("swap"), method_14549, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_14550, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Muon>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Muon> > > -------------------------------
static void constructor_14578( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >();
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >();
}

static void constructor_14579( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >(*(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >(*(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)arg[0]);
}

static void constructor_14580( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*)arg[1]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*)arg[1],
      *(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)arg[2]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*)arg[1],
      *(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)arg[2]);
  }
}

static void constructor_14581( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)arg[0]);
}

static void destructor_14582(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >::~vector)();
}
static  void operator_14583( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->operator=)(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->operator=)(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)arg[0]);
}

static  void method_14584( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*)arg[1]);
}

static  void method_14585( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->begin)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->begin)();
}

static  void method_14586( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->begin)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->begin)();
}

static  void method_14587( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->end)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->end)();
}

static  void method_14588( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->end)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->end)();
}

static  void method_14593( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->size)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->size)();
}

static  void method_14594( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->max_size)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->max_size)();
}

static  void method_14595( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*)arg[1]);
  }
}

static  void method_14596( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->capacity)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->capacity)();
}

static  void method_14597( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->empty)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->empty)();
}

static  void method_14598( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_14599( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_14600( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_14602( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14603( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14604( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->front)();
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->front)();
}

static  void method_14605( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->front)();
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->front)();
}

static  void method_14606( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->back)();
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->back)();
}

static  void method_14607( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->back)();
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->back)();
}

static  void method_14608( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->data)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->data)();
}

static  void method_14609( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->data)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->data)();
}

static  void method_14610( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->push_back)(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*)arg[0]);
}

static  void method_14611( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->pop_back)();
}

static  void method_14612( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*)arg[1]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*)arg[1]);
}

static  void method_14613( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*)arg[2]);
}

static  void method_14614( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >*)arg[0]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >*)arg[0]);
}

static  void method_14615( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >*)arg[1]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >*)arg[1]);
}

static  void method_14616( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->swap)(*(::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)arg[0]);
}

static  void method_14617( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->clear)();
}

static void method_newdel_2170( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x180( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >")), ::Reflex::BaseOffset< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >,::std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x181( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >::Generate();
}

//------Dictionary for class vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Muon>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Muon> > > -------------------------------
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s__db_datamem(Reflex::Class*);
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s__datamem_bld(&__std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s__funcmem_bld(&__std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s__db_funcmem);
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >"), typeid(::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >), sizeof(::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3700, ::Reflex::BaseOffset< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >, ::std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_803, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >::_Alloc_value_type"))
  .AddTypedef(type_3700, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >::_Base"))
  .AddTypedef(type_5055, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >::_Tp_alloc_type"))
  .AddTypedef(type_803, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >::value_type"))
  .AddTypedef(type_14561, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >::pointer"))
  .AddTypedef(type_14563, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >::const_pointer"))
  .AddTypedef(type_14565, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >::reference"))
  .AddTypedef(type_14567, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >::const_reference"))
  .AddTypedef(type_14569, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >::iterator"))
  .AddTypedef(type_14571, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >::const_iterator"))
  .AddTypedef(type_5653, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >::const_reverse_iterator"))
  .AddTypedef(type_5654, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >::difference_type"))
  .AddTypedef(type_5055, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_14578, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60795), Reflex::Literal("vector"), constructor_14579, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_14567, type_60795), Reflex::Literal("vector"), constructor_14580, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60796), Reflex::Literal("vector"), constructor_14581, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_14582, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2170, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x180, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x181, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Muon>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Muon> > > -------------------
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Muon>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Muon> > > -------------------
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60797, type_60796), Reflex::Literal("operator="), operator_14583, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_14567), Reflex::Literal("assign"), method_14584, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14569), Reflex::Literal("begin"), method_14585, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14571), Reflex::Literal("begin"), method_14586, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14569), Reflex::Literal("end"), method_14587, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14571), Reflex::Literal("end"), method_14588, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_14593, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_14594, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_803), Reflex::Literal("resize"), method_14595, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_14596, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_14597, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_14598, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14565, type_5015), Reflex::Literal("operator[]"), operator_14599, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14567, type_5015), Reflex::Literal("operator[]"), operator_14600, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14565, type_5015), Reflex::Literal("at"), method_14602, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14567, type_5015), Reflex::Literal("at"), method_14603, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14565), Reflex::Literal("front"), method_14604, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14567), Reflex::Literal("front"), method_14605, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14565), Reflex::Literal("back"), method_14606, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14567), Reflex::Literal("back"), method_14607, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14561), Reflex::Literal("data"), method_14608, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14563), Reflex::Literal("data"), method_14609, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_14567), Reflex::Literal("push_back"), method_14610, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_14611, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14569, type_14569, type_14567), Reflex::Literal("insert"), method_14612, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_14569, type_5015, type_14567), Reflex::Literal("insert"), method_14613, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14569, type_14569), Reflex::Literal("erase"), method_14614, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14569, type_14569, type_14569), Reflex::Literal("erase"), method_14615, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_60797), Reflex::Literal("swap"), method_14616, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_14617, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> -------------------------------
static  void operator_16210( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*)o)->operator=)(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*)arg[0]);
  else   (((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*)o)->operator=)(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*)arg[0]);
}

static void constructor_16211( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*)arg[0]);
  else ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*)arg[0]);
}

static void constructor_16212( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>();
  else ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>();
}

static void constructor_16213( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Electron>*)arg[1],
      *(const ::edm::Ptr<pat::Electron>*)arg[2],
      *(const ::edm::Ptr<pat::Photon>*)arg[3],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[4]);
  else ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Electron>*)arg[1],
      *(const ::edm::Ptr<pat::Electron>*)arg[2],
      *(const ::edm::Ptr<pat::Photon>*)arg[3],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[4]);
}

static  void method_16214( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*)o)->clone)());
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*)o)->clone)();
}

static  void method_16215( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_16216( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_16217( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*)o)->numberOfDaughters)());
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*)o)->numberOfDaughters)();
}

static  void method_16218( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_16219( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_16220(void*, void * o, const std::vector<void*>&, void *) {
(((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*)o)->::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>::~PATQuadFinalStateT)();
}
static void method_newdel_2684( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x183( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> -------------------------------
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon__db_datamem(Reflex::Class*);
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon__datamem_bld(&__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon__db_datamem);
Reflex::GenreflexMemberBuilder __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon__funcmem_bld(&__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon__db_funcmem);
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>"), typeid(::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>), sizeof(::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6476, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>::daughter1_type"))
  .AddTypedef(type_6476, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>::daughter2_type"))
  .AddTypedef(type_6476, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>::daughter3_type"))
  .AddTypedef(type_6478, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>::daughter4_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14660, type_14662), Reflex::Literal("operator="), operator_16210, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14662), Reflex::Literal("PATQuadFinalStateT"), constructor_16211, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATQuadFinalStateT"), constructor_16212, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45636, type_45636, type_45636, type_45637, type_45406), Reflex::Literal("PATQuadFinalStateT"), constructor_16213, 0, "p1;p2;p3;p4;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATQuadFinalStateT"), destructor_16220, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2684, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x183, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon__funcmem_bld);
}

//------Delayed data member builder for class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> -------------------
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9785, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9785, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_, p2_), ::Reflex::PRIVATE)
  .AddDataMember(type_9785, Reflex::Literal("p3_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_, p3_), ::Reflex::PRIVATE)
  .AddDataMember(type_9786, Reflex::Literal("p4_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_, p4_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> -------------------
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14656), Reflex::Literal("clone"), method_16214, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_16215, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_16216, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_16217, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_16218, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_16219, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Photon> > > -------------------------------
static void constructor_14673( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >();
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >();
}

static void constructor_14674( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >(*(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >(*(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)arg[0]);
}

static void constructor_14675( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*)arg[1]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*)arg[1],
      *(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)arg[2]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*)arg[1],
      *(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)arg[2]);
  }
}

static void constructor_14676( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)arg[0]);
}

static void destructor_14677(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >::~vector)();
}
static  void operator_14678( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->operator=)(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->operator=)(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)arg[0]);
}

static  void method_14679( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*)arg[1]);
}

static  void method_14680( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->begin)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->begin)();
}

static  void method_14681( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->begin)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->begin)();
}

static  void method_14682( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->end)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->end)();
}

static  void method_14683( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->end)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->end)();
}

static  void method_14688( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->size)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->size)();
}

static  void method_14689( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->max_size)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->max_size)();
}

static  void method_14690( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*)arg[1]);
  }
}

static  void method_14691( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->capacity)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->capacity)();
}

static  void method_14692( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->empty)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->empty)();
}

static  void method_14693( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_14694( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_14695( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_14697( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14698( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14699( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->front)();
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->front)();
}

static  void method_14700( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->front)();
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->front)();
}

static  void method_14701( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->back)();
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->back)();
}

static  void method_14702( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->back)();
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->back)();
}

static  void method_14703( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->data)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->data)();
}

static  void method_14704( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->data)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->data)();
}

static  void method_14705( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->push_back)(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*)arg[0]);
}

static  void method_14706( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->pop_back)();
}

static  void method_14707( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*)arg[1]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*)arg[1]);
}

static  void method_14708( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*)arg[2]);
}

static  void method_14709( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >*)arg[0]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >*)arg[0]);
}

static  void method_14710( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >*)arg[1]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >*)arg[1]);
}

static  void method_14711( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->swap)(*(::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)arg[0]);
}

static  void method_14712( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->clear)();
}

static void method_newdel_2188( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x185( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >")), ::Reflex::BaseOffset< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >,::std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x186( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >::Generate();
}

//------Dictionary for class vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Photon> > > -------------------------------
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s__db_datamem(Reflex::Class*);
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s__datamem_bld(&__std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s__funcmem_bld(&__std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s__db_funcmem);
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >"), typeid(::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >), sizeof(::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3701, ::Reflex::BaseOffset< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >, ::std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2684, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >::_Alloc_value_type"))
  .AddTypedef(type_3701, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >::_Base"))
  .AddTypedef(type_5056, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >::_Tp_alloc_type"))
  .AddTypedef(type_2684, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >::value_type"))
  .AddTypedef(type_14656, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >::pointer"))
  .AddTypedef(type_14658, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >::const_pointer"))
  .AddTypedef(type_14660, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >::reference"))
  .AddTypedef(type_14662, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >::const_reference"))
  .AddTypedef(type_14664, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >::iterator"))
  .AddTypedef(type_14666, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >::const_iterator"))
  .AddTypedef(type_5655, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >::const_reverse_iterator"))
  .AddTypedef(type_5656, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >::difference_type"))
  .AddTypedef(type_5056, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_14673, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60801), Reflex::Literal("vector"), constructor_14674, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_14662, type_60801), Reflex::Literal("vector"), constructor_14675, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60802), Reflex::Literal("vector"), constructor_14676, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_14677, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2188, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x185, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x186, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Photon> > > -------------------
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Photon> > > -------------------
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60803, type_60802), Reflex::Literal("operator="), operator_14678, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_14662), Reflex::Literal("assign"), method_14679, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14664), Reflex::Literal("begin"), method_14680, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14666), Reflex::Literal("begin"), method_14681, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14664), Reflex::Literal("end"), method_14682, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14666), Reflex::Literal("end"), method_14683, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_14688, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_14689, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_2684), Reflex::Literal("resize"), method_14690, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_14691, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_14692, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_14693, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14660, type_5015), Reflex::Literal("operator[]"), operator_14694, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14662, type_5015), Reflex::Literal("operator[]"), operator_14695, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14660, type_5015), Reflex::Literal("at"), method_14697, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14662, type_5015), Reflex::Literal("at"), method_14698, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14660), Reflex::Literal("front"), method_14699, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14662), Reflex::Literal("front"), method_14700, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14660), Reflex::Literal("back"), method_14701, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14662), Reflex::Literal("back"), method_14702, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14656), Reflex::Literal("data"), method_14703, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14658), Reflex::Literal("data"), method_14704, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_14662), Reflex::Literal("push_back"), method_14705, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_14706, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14664, type_14664, type_14662), Reflex::Literal("insert"), method_14707, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_14664, type_5015, type_14662), Reflex::Literal("insert"), method_14708, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14664, type_14664), Reflex::Literal("erase"), method_14709, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14664, type_14664, type_14664), Reflex::Literal("erase"), method_14710, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_60803), Reflex::Literal("swap"), method_14711, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_14712, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<PATFinalStateLS,std::allocator<PATFinalStateLS> > -------------------------------
static void constructor_14882( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATFinalStateLS>();
  else ::new(mem) ::std::vector<PATFinalStateLS>();
}

static void constructor_14883( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATFinalStateLS>(*(const ::std::allocator<PATFinalStateLS>*)arg[0]);
  else ::new(mem) ::std::vector<PATFinalStateLS>(*(const ::std::allocator<PATFinalStateLS>*)arg[0]);
}

static void constructor_14884( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATFinalStateLS>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATFinalStateLS>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATFinalStateLS>(*(::std::size_t*)arg[0],
      *(const ::PATFinalStateLS*)arg[1]);
  else ::new(mem) ::std::vector<PATFinalStateLS>(*(::std::size_t*)arg[0],
      *(const ::PATFinalStateLS*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATFinalStateLS>(*(::std::size_t*)arg[0],
      *(const ::PATFinalStateLS*)arg[1],
      *(const ::std::allocator<PATFinalStateLS>*)arg[2]);
  else ::new(mem) ::std::vector<PATFinalStateLS>(*(::std::size_t*)arg[0],
      *(const ::PATFinalStateLS*)arg[1],
      *(const ::std::allocator<PATFinalStateLS>*)arg[2]);
  }
}

static void constructor_14885( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATFinalStateLS>(*(const ::std::vector<PATFinalStateLS>*)arg[0]);
  else ::new(mem) ::std::vector<PATFinalStateLS>(*(const ::std::vector<PATFinalStateLS>*)arg[0]);
}

static void destructor_14886(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATFinalStateLS>*)o)->::std::vector<PATFinalStateLS>::~vector)();
}
static  void operator_14887( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATFinalStateLS>*)o)->operator=)(*(const ::std::vector<PATFinalStateLS>*)arg[0]);
  else   (((::std::vector<PATFinalStateLS>*)o)->operator=)(*(const ::std::vector<PATFinalStateLS>*)arg[0]);
}

static  void method_14888( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATFinalStateLS>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATFinalStateLS*)arg[1]);
}

static  void method_14889( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATFinalStateLS*,std::vector<PATFinalStateLS> >)((((::std::vector<PATFinalStateLS>*)o)->begin)());
  else   (((::std::vector<PATFinalStateLS>*)o)->begin)();
}

static  void method_14890( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATFinalStateLS*,std::vector<PATFinalStateLS> >)((((const ::std::vector<PATFinalStateLS>*)o)->begin)());
  else   (((const ::std::vector<PATFinalStateLS>*)o)->begin)();
}

static  void method_14891( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATFinalStateLS*,std::vector<PATFinalStateLS> >)((((::std::vector<PATFinalStateLS>*)o)->end)());
  else   (((::std::vector<PATFinalStateLS>*)o)->end)();
}

static  void method_14892( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATFinalStateLS*,std::vector<PATFinalStateLS> >)((((const ::std::vector<PATFinalStateLS>*)o)->end)());
  else   (((const ::std::vector<PATFinalStateLS>*)o)->end)();
}

static  void method_14897( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATFinalStateLS>*)o)->size)());
  else   (((const ::std::vector<PATFinalStateLS>*)o)->size)();
}

static  void method_14898( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATFinalStateLS>*)o)->max_size)());
  else   (((const ::std::vector<PATFinalStateLS>*)o)->max_size)();
}

static  void method_14899( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATFinalStateLS>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATFinalStateLS>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATFinalStateLS*)arg[1]);
  }
}

static  void method_14900( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATFinalStateLS>*)o)->capacity)());
  else   (((const ::std::vector<PATFinalStateLS>*)o)->capacity)();
}

static  void method_14901( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATFinalStateLS>*)o)->empty)());
  else   (((const ::std::vector<PATFinalStateLS>*)o)->empty)();
}

static  void method_14902( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATFinalStateLS>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_14903( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATFinalStateLS>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATFinalStateLS>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_14904( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATFinalStateLS>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATFinalStateLS>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_14906( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATFinalStateLS>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATFinalStateLS>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14907( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATFinalStateLS>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATFinalStateLS>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14908( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATFinalStateLS>*)o)->front)();
  else   (((::std::vector<PATFinalStateLS>*)o)->front)();
}

static  void method_14909( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATFinalStateLS>*)o)->front)();
  else   (((const ::std::vector<PATFinalStateLS>*)o)->front)();
}

static  void method_14910( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATFinalStateLS>*)o)->back)();
  else   (((::std::vector<PATFinalStateLS>*)o)->back)();
}

static  void method_14911( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATFinalStateLS>*)o)->back)();
  else   (((const ::std::vector<PATFinalStateLS>*)o)->back)();
}

static  void method_14912( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATFinalStateLS>*)o)->data)());
  else   (((::std::vector<PATFinalStateLS>*)o)->data)();
}

static  void method_14913( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATFinalStateLS>*)o)->data)());
  else   (((const ::std::vector<PATFinalStateLS>*)o)->data)();
}

static  void method_14914( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATFinalStateLS>*)o)->push_back)(*(const ::PATFinalStateLS*)arg[0]);
}

static  void method_14915( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATFinalStateLS>*)o)->pop_back)();
}

static  void method_14916( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATFinalStateLS*,std::vector<PATFinalStateLS> >)((((::std::vector<PATFinalStateLS>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATFinalStateLS*,std::vector<PATFinalStateLS> >*)arg[0],
    *(const ::PATFinalStateLS*)arg[1]));
  else   (((::std::vector<PATFinalStateLS>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATFinalStateLS*,std::vector<PATFinalStateLS> >*)arg[0],
    *(const ::PATFinalStateLS*)arg[1]);
}

static  void method_14917( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATFinalStateLS>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATFinalStateLS*,std::vector<PATFinalStateLS> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATFinalStateLS*)arg[2]);
}

static  void method_14918( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATFinalStateLS*,std::vector<PATFinalStateLS> >)((((::std::vector<PATFinalStateLS>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATFinalStateLS*,std::vector<PATFinalStateLS> >*)arg[0]));
  else   (((::std::vector<PATFinalStateLS>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATFinalStateLS*,std::vector<PATFinalStateLS> >*)arg[0]);
}

static  void method_14919( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATFinalStateLS*,std::vector<PATFinalStateLS> >)((((::std::vector<PATFinalStateLS>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATFinalStateLS*,std::vector<PATFinalStateLS> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATFinalStateLS*,std::vector<PATFinalStateLS> >*)arg[1]));
  else   (((::std::vector<PATFinalStateLS>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATFinalStateLS*,std::vector<PATFinalStateLS> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATFinalStateLS*,std::vector<PATFinalStateLS> >*)arg[1]);
}

static  void method_14920( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATFinalStateLS>*)o)->swap)(*(::std::vector<PATFinalStateLS>*)arg[0]);
}

static  void method_14921( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATFinalStateLS>*)o)->clear)();
}

static void method_newdel_2244( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATFinalStateLS> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATFinalStateLS> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATFinalStateLS> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATFinalStateLS> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATFinalStateLS> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x188( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATFinalStateLS,std::allocator<PATFinalStateLS> >")), ::Reflex::BaseOffset< ::std::vector<PATFinalStateLS>,::std::_Vector_base<PATFinalStateLS,std::allocator<PATFinalStateLS> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x189( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATFinalStateLS> >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATFinalStateLS> >::Generate();
}

//------Dictionary for class vector<PATFinalStateLS,std::allocator<PATFinalStateLS> > -------------------------------
void __std__vector_PATFinalStateLS__db_datamem(Reflex::Class*);
void __std__vector_PATFinalStateLS__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATFinalStateLS__datamem_bld(&__std__vector_PATFinalStateLS__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATFinalStateLS__funcmem_bld(&__std__vector_PATFinalStateLS__db_funcmem);
void __std__vector_PATFinalStateLS__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATFinalStateLS>"), typeid(::std::vector<PATFinalStateLS>), sizeof(::std::vector<PATFinalStateLS>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3732, ::Reflex::BaseOffset< ::std::vector<PATFinalStateLS>, ::std::_Vector_base<PATFinalStateLS,std::allocator<PATFinalStateLS> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3039, Reflex::Literal("std::vector<PATFinalStateLS>::_Alloc_value_type"))
  .AddTypedef(type_3732, Reflex::Literal("std::vector<PATFinalStateLS>::_Base"))
  .AddTypedef(type_5033, Reflex::Literal("std::vector<PATFinalStateLS>::_Tp_alloc_type"))
  .AddTypedef(type_3039, Reflex::Literal("std::vector<PATFinalStateLS>::value_type"))
  .AddTypedef(type_14865, Reflex::Literal("std::vector<PATFinalStateLS>::pointer"))
  .AddTypedef(type_14867, Reflex::Literal("std::vector<PATFinalStateLS>::const_pointer"))
  .AddTypedef(type_14869, Reflex::Literal("std::vector<PATFinalStateLS>::reference"))
  .AddTypedef(type_14871, Reflex::Literal("std::vector<PATFinalStateLS>::const_reference"))
  .AddTypedef(type_14873, Reflex::Literal("std::vector<PATFinalStateLS>::iterator"))
  .AddTypedef(type_14875, Reflex::Literal("std::vector<PATFinalStateLS>::const_iterator"))
  .AddTypedef(type_5717, Reflex::Literal("std::vector<PATFinalStateLS>::const_reverse_iterator"))
  .AddTypedef(type_5718, Reflex::Literal("std::vector<PATFinalStateLS>::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATFinalStateLS>::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATFinalStateLS>::difference_type"))
  .AddTypedef(type_5033, Reflex::Literal("std::vector<PATFinalStateLS>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_14882, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60811), Reflex::Literal("vector"), constructor_14883, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_14871, type_60811), Reflex::Literal("vector"), constructor_14884, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45953), Reflex::Literal("vector"), constructor_14885, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_14886, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2244, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x188, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x189, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATFinalStateLS__funcmem_bld);
}

//------Delayed data member builder for class vector<PATFinalStateLS,std::allocator<PATFinalStateLS> > -------------------
void __std__vector_PATFinalStateLS__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATFinalStateLS,std::allocator<PATFinalStateLS> > -------------------
void __std__vector_PATFinalStateLS__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60812, type_45953), Reflex::Literal("operator="), operator_14887, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_14871), Reflex::Literal("assign"), method_14888, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14873), Reflex::Literal("begin"), method_14889, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14875), Reflex::Literal("begin"), method_14890, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14873), Reflex::Literal("end"), method_14891, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14875), Reflex::Literal("end"), method_14892, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_14897, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_14898, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_3039), Reflex::Literal("resize"), method_14899, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_14900, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_14901, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_14902, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14869, type_5015), Reflex::Literal("operator[]"), operator_14903, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14871, type_5015), Reflex::Literal("operator[]"), operator_14904, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14869, type_5015), Reflex::Literal("at"), method_14906, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14871, type_5015), Reflex::Literal("at"), method_14907, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14869), Reflex::Literal("front"), method_14908, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14871), Reflex::Literal("front"), method_14909, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14869), Reflex::Literal("back"), method_14910, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14871), Reflex::Literal("back"), method_14911, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14865), Reflex::Literal("data"), method_14912, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14867), Reflex::Literal("data"), method_14913, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_14871), Reflex::Literal("push_back"), method_14914, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_14915, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14873, type_14873, type_14871), Reflex::Literal("insert"), method_14916, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_14873, type_5015, type_14871), Reflex::Literal("insert"), method_14917, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14873, type_14873), Reflex::Literal("erase"), method_14918, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14873, type_14873, type_14873), Reflex::Literal("erase"), method_14919, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_60812), Reflex::Literal("swap"), method_14920, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_14921, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> -------------------------------
static  void operator_16315( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*)o)->operator=)(*(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*)arg[0]);
  else   (((::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*)o)->operator=)(*(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*)arg[0]);
}

static void constructor_16316( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>(*(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*)arg[0]);
  else ::new(mem) ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>(*(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*)arg[0]);
}

static void constructor_16317( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>();
  else ::new(mem) ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>();
}

static void constructor_16318( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>(*(const ::edm::Ptr<pat::Muon>*)arg[0],
      *(const ::edm::Ptr<pat::Muon>*)arg[1],
      *(const ::edm::Ptr<pat::Muon>*)arg[2],
      *(const ::edm::Ptr<pat::Muon>*)arg[3],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[4]);
  else ::new(mem) ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>(*(const ::edm::Ptr<pat::Muon>*)arg[0],
      *(const ::edm::Ptr<pat::Muon>*)arg[1],
      *(const ::edm::Ptr<pat::Muon>*)arg[2],
      *(const ::edm::Ptr<pat::Muon>*)arg[3],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[4]);
}

static  void method_16319( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*)o)->clone)());
  else   (((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*)o)->clone)();
}

static  void method_16320( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_16321( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_16322( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*)o)->numberOfDaughters)());
  else   (((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*)o)->numberOfDaughters)();
}

static  void method_16323( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_16324( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_16325(void*, void * o, const std::vector<void*>&, void *) {
(((::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*)o)->::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>::~PATQuadFinalStateT)();
}
static void method_newdel_2807( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x191( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> -------------------------------
void __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon__db_datamem(Reflex::Class*);
void __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon__datamem_bld(&__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon__db_datamem);
Reflex::GenreflexMemberBuilder __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon__funcmem_bld(&__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon__db_funcmem);
void __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>"), typeid(::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>), sizeof(::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6497, Reflex::Literal("PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>::daughter1_type"))
  .AddTypedef(type_6497, Reflex::Literal("PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>::daughter2_type"))
  .AddTypedef(type_6497, Reflex::Literal("PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>::daughter3_type"))
  .AddTypedef(type_6497, Reflex::Literal("PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>::daughter4_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15099, type_15101), Reflex::Literal("operator="), operator_16315, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15101), Reflex::Literal("PATQuadFinalStateT"), constructor_16316, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATQuadFinalStateT"), constructor_16317, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45727, type_45727, type_45727, type_45727, type_45406), Reflex::Literal("PATQuadFinalStateT"), constructor_16318, 0, "p1;p2;p3;p4;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATQuadFinalStateT"), destructor_16325, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2807, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x191, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon__funcmem_bld);
}

//------Delayed data member builder for class PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> -------------------
void __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9782, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9782, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_, p2_), ::Reflex::PRIVATE)
  .AddDataMember(type_9782, Reflex::Literal("p3_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_, p3_), ::Reflex::PRIVATE)
  .AddDataMember(type_9782, Reflex::Literal("p4_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_, p4_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> -------------------
void __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15095), Reflex::Literal("clone"), method_16319, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_16320, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_16321, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_16322, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_16323, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_16324, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class vector<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Muon>,std::allocator<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Muon> > > -------------------------------
static void constructor_15112( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >();
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >();
}

static void constructor_15113( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >(*(const ::std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >(*(const ::std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)arg[0]);
}

static void constructor_15114( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*)arg[1]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*)arg[1],
      *(const ::std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)arg[2]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*)arg[1],
      *(const ::std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)arg[2]);
  }
}

static void constructor_15115( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >(*(const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >(*(const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)arg[0]);
}

static void destructor_15116(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >::~vector)();
}
static  void operator_15117( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->operator=)(*(const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->operator=)(*(const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)arg[0]);
}

static  void method_15118( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*)arg[1]);
}

static  void method_15119( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >)((((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->begin)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->begin)();
}

static  void method_15120( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >)((((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->begin)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->begin)();
}

static  void method_15121( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >)((((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->end)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->end)();
}

static  void method_15122( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >)((((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->end)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->end)();
}

static  void method_15127( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->size)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->size)();
}

static  void method_15128( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->max_size)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->max_size)();
}

static  void method_15129( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*)arg[1]);
  }
}

static  void method_15130( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->capacity)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->capacity)();
}

static  void method_15131( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->empty)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->empty)();
}

static  void method_15132( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_15133( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_15134( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_15136( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_15137( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_15138( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->front)();
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->front)();
}

static  void method_15139( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->front)();
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->front)();
}

static  void method_15140( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->back)();
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->back)();
}

static  void method_15141( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->back)();
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->back)();
}

static  void method_15142( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->data)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->data)();
}

static  void method_15143( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->data)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->data)();
}

static  void method_15144( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->push_back)(*(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*)arg[0]);
}

static  void method_15145( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->pop_back)();
}

static  void method_15146( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >)((((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*)arg[1]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*)arg[1]);
}

static  void method_15147( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*)arg[2]);
}

static  void method_15148( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >)((((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >*)arg[0]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >*)arg[0]);
}

static  void method_15149( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >)((((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >*)arg[1]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >*)arg[1]);
}

static  void method_15150( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->swap)(*(::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)arg[0]);
}

static  void method_15151( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->clear)();
}

static void method_newdel_2311( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x193( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>,std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >")), ::Reflex::BaseOffset< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >,::std::_Vector_base<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>,std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x194( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >::Generate();
}

//------Dictionary for class vector<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Muon>,std::allocator<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Muon> > > -------------------------------
void __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s__db_datamem(Reflex::Class*);
void __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s__datamem_bld(&__std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s__funcmem_bld(&__std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s__db_funcmem);
void __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >"), typeid(::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >), sizeof(::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3690, ::Reflex::BaseOffset< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >, ::std::_Vector_base<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>,std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2807, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >::_Alloc_value_type"))
  .AddTypedef(type_3690, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >::_Base"))
  .AddTypedef(type_5045, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >::_Tp_alloc_type"))
  .AddTypedef(type_2807, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >::value_type"))
  .AddTypedef(type_15095, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >::pointer"))
  .AddTypedef(type_15097, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >::const_pointer"))
  .AddTypedef(type_15099, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >::reference"))
  .AddTypedef(type_15101, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >::const_reference"))
  .AddTypedef(type_15103, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >::iterator"))
  .AddTypedef(type_15105, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >::const_iterator"))
  .AddTypedef(type_5633, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >::const_reverse_iterator"))
  .AddTypedef(type_5634, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >::difference_type"))
  .AddTypedef(type_5045, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_15112, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60863), Reflex::Literal("vector"), constructor_15113, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_15101, type_60863), Reflex::Literal("vector"), constructor_15114, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60864), Reflex::Literal("vector"), constructor_15115, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_15116, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2311, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x193, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x194, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Muon>,std::allocator<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Muon> > > -------------------
void __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Muon>,std::allocator<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Muon> > > -------------------
void __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60865, type_60864), Reflex::Literal("operator="), operator_15117, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_15101), Reflex::Literal("assign"), method_15118, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15103), Reflex::Literal("begin"), method_15119, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15105), Reflex::Literal("begin"), method_15120, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15103), Reflex::Literal("end"), method_15121, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15105), Reflex::Literal("end"), method_15122, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_15127, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_15128, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_2807), Reflex::Literal("resize"), method_15129, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_15130, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_15131, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_15132, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15099, type_5015), Reflex::Literal("operator[]"), operator_15133, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15101, type_5015), Reflex::Literal("operator[]"), operator_15134, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15099, type_5015), Reflex::Literal("at"), method_15136, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15101, type_5015), Reflex::Literal("at"), method_15137, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15099), Reflex::Literal("front"), method_15138, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15101), Reflex::Literal("front"), method_15139, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15099), Reflex::Literal("back"), method_15140, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15101), Reflex::Literal("back"), method_15141, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15095), Reflex::Literal("data"), method_15142, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15097), Reflex::Literal("data"), method_15143, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_15101), Reflex::Literal("push_back"), method_15144, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_15145, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15103, type_15103, type_15101), Reflex::Literal("insert"), method_15146, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_15103, type_5015, type_15101), Reflex::Literal("insert"), method_15147, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15103, type_15103), Reflex::Literal("erase"), method_15148, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15103, type_15103, type_15103), Reflex::Literal("erase"), method_15149, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_60865), Reflex::Literal("swap"), method_15150, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_15151, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Photon> > > -------------------------------
static void constructor_15250( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >();
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >();
}

static void constructor_15251( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >(*(const ::std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >(*(const ::std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)arg[0]);
}

static void constructor_15252( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*)arg[1]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*)arg[1],
      *(const ::std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)arg[2]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*)arg[1],
      *(const ::std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)arg[2]);
  }
}

static void constructor_15253( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >(*(const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >(*(const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)arg[0]);
}

static void destructor_15254(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >::~vector)();
}
static  void operator_15255( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->operator=)(*(const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->operator=)(*(const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)arg[0]);
}

static  void method_15256( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*)arg[1]);
}

static  void method_15257( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >)((((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->begin)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->begin)();
}

static  void method_15258( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >)((((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->begin)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->begin)();
}

static  void method_15259( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >)((((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->end)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->end)();
}

static  void method_15260( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >)((((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->end)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->end)();
}

static  void method_15265( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->size)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->size)();
}

static  void method_15266( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->max_size)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->max_size)();
}

static  void method_15267( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*)arg[1]);
  }
}

static  void method_15268( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->capacity)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->capacity)();
}

static  void method_15269( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->empty)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->empty)();
}

static  void method_15270( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_15271( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_15272( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_15274( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_15275( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_15276( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->front)();
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->front)();
}

static  void method_15277( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->front)();
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->front)();
}

static  void method_15278( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->back)();
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->back)();
}

static  void method_15279( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->back)();
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->back)();
}

static  void method_15280( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->data)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->data)();
}

static  void method_15281( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->data)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->data)();
}

static  void method_15282( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->push_back)(*(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*)arg[0]);
}

static  void method_15283( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->pop_back)();
}

static  void method_15284( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >)((((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*)arg[1]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*)arg[1]);
}

static  void method_15285( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*)arg[2]);
}

static  void method_15286( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >)((((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >*)arg[0]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >*)arg[0]);
}

static  void method_15287( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >)((((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >*)arg[1]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >*)arg[1]);
}

static  void method_15288( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->swap)(*(::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)arg[0]);
}

static  void method_15289( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->clear)();
}

static void method_newdel_2341( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x196( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >")), ::Reflex::BaseOffset< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >,::std::_Vector_base<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x197( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >::Generate();
}

//------Dictionary for class vector<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Photon> > > -------------------------------
void __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s__db_datamem(Reflex::Class*);
void __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s__datamem_bld(&__std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s__funcmem_bld(&__std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s__db_funcmem);
void __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >"), typeid(::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >), sizeof(::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3688, ::Reflex::BaseOffset< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >, ::std::_Vector_base<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_164, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >::_Alloc_value_type"))
  .AddTypedef(type_3688, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >::_Base"))
  .AddTypedef(type_5043, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >::_Tp_alloc_type"))
  .AddTypedef(type_164, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >::value_type"))
  .AddTypedef(type_15233, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >::pointer"))
  .AddTypedef(type_15235, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >::const_pointer"))
  .AddTypedef(type_15237, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >::reference"))
  .AddTypedef(type_15239, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >::const_reference"))
  .AddTypedef(type_15241, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >::iterator"))
  .AddTypedef(type_15243, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >::const_iterator"))
  .AddTypedef(type_5629, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >::const_reverse_iterator"))
  .AddTypedef(type_5630, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >::difference_type"))
  .AddTypedef(type_5043, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_15250, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60869), Reflex::Literal("vector"), constructor_15251, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_15239, type_60869), Reflex::Literal("vector"), constructor_15252, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60870), Reflex::Literal("vector"), constructor_15253, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_15254, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2341, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x196, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x197, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Photon> > > -------------------
void __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Photon> > > -------------------
void __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60871, type_60870), Reflex::Literal("operator="), operator_15255, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_15239), Reflex::Literal("assign"), method_15256, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15241), Reflex::Literal("begin"), method_15257, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15243), Reflex::Literal("begin"), method_15258, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15241), Reflex::Literal("end"), method_15259, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15243), Reflex::Literal("end"), method_15260, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_15265, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_15266, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_164), Reflex::Literal("resize"), method_15267, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_15268, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_15269, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_15270, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15237, type_5015), Reflex::Literal("operator[]"), operator_15271, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15239, type_5015), Reflex::Literal("operator[]"), operator_15272, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15237, type_5015), Reflex::Literal("at"), method_15274, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15239, type_5015), Reflex::Literal("at"), method_15275, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15237), Reflex::Literal("front"), method_15276, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15239), Reflex::Literal("front"), method_15277, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15237), Reflex::Literal("back"), method_15278, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15239), Reflex::Literal("back"), method_15279, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15233), Reflex::Literal("data"), method_15280, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15235), Reflex::Literal("data"), method_15281, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_15239), Reflex::Literal("push_back"), method_15282, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_15283, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15241, type_15241, type_15239), Reflex::Literal("insert"), method_15284, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_15241, type_5015, type_15239), Reflex::Literal("insert"), method_15285, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15241, type_15241), Reflex::Literal("erase"), method_15286, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15241, type_15241, type_15241), Reflex::Literal("erase"), method_15287, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_60871), Reflex::Literal("swap"), method_15288, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_15289, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> -------------------------------
static  void operator_12420( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*)o)->operator=)(*(const ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*)arg[0]);
  else   (((::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*)o)->operator=)(*(const ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*)arg[0]);
}

static void constructor_12421( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>(*(const ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*)arg[0]);
  else ::new(mem) ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>(*(const ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*)arg[0]);
}

static void constructor_12422( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>();
  else ::new(mem) ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>();
}

static void constructor_12423( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>(*(const ::edm::Ptr<pat::Muon>*)arg[0],
      *(const ::edm::Ptr<pat::Tau>*)arg[1],
      *(const ::edm::Ptr<pat::Tau>*)arg[2],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[3]);
  else ::new(mem) ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>(*(const ::edm::Ptr<pat::Muon>*)arg[0],
      *(const ::edm::Ptr<pat::Tau>*)arg[1],
      *(const ::edm::Ptr<pat::Tau>*)arg[2],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[3]);
}

static  void method_12424( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*)o)->clone)());
  else   (((const ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*)o)->clone)();
}

static  void method_12425( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_12426( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_12427( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*)o)->numberOfDaughters)());
  else   (((const ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*)o)->numberOfDaughters)();
}

static  void method_12428( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_12429( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_12430(void*, void * o, const std::vector<void*>&, void *) {
(((::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*)o)->::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>::~PATTripletFinalStateT)();
}
static void method_newdel_1518( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x199( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> -------------------------------
void __PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau__db_datamem(Reflex::Class*);
void __PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau__datamem_bld(&__PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau__db_datamem);
Reflex::GenreflexMemberBuilder __PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau__funcmem_bld(&__PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau__db_funcmem);
void __PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>"), typeid(::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>), sizeof(::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6497, Reflex::Literal("PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>::daughter1_type"))
  .AddTypedef(type_7135, Reflex::Literal("PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>::daughter2_type"))
  .AddTypedef(type_7135, Reflex::Literal("PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>::daughter3_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17248, type_17250), Reflex::Literal("operator="), operator_12420, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17250), Reflex::Literal("PATTripletFinalStateT"), constructor_12421, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATTripletFinalStateT"), constructor_12422, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45727, type_46321, type_46321, type_45406), Reflex::Literal("PATTripletFinalStateT"), constructor_12423, 0, "p1;p2;p3;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATTripletFinalStateT"), destructor_12430, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1518, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x199, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau__funcmem_bld);
}

//------Delayed data member builder for class PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> -------------------
void __PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9782, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9787, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_, p2_), ::Reflex::PRIVATE)
  .AddDataMember(type_9787, Reflex::Literal("p3_"), OffsetOf(__shadow__::__PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_, p3_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> -------------------
void __PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17244), Reflex::Literal("clone"), method_12424, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_12425, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_12426, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_12427, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_12428, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_12429, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class PATPairFinalStateT<pat::Electron,pat::Photon> -------------------------------
static  void operator_13700( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATPairFinalStateT<pat::Electron,pat::Photon>*)o)->operator=)(*(const ::PATPairFinalStateT<pat::Electron,pat::Photon>*)arg[0]);
  else   (((::PATPairFinalStateT<pat::Electron,pat::Photon>*)o)->operator=)(*(const ::PATPairFinalStateT<pat::Electron,pat::Photon>*)arg[0]);
}

static void constructor_13701( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATPairFinalStateT<pat::Electron,pat::Photon>(*(const ::PATPairFinalStateT<pat::Electron,pat::Photon>*)arg[0]);
  else ::new(mem) ::PATPairFinalStateT<pat::Electron,pat::Photon>(*(const ::PATPairFinalStateT<pat::Electron,pat::Photon>*)arg[0]);
}

static void constructor_13702( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATPairFinalStateT<pat::Electron,pat::Photon>();
  else ::new(mem) ::PATPairFinalStateT<pat::Electron,pat::Photon>();
}

static void constructor_13703( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATPairFinalStateT<pat::Electron,pat::Photon>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Photon>*)arg[1],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[2]);
  else ::new(mem) ::PATPairFinalStateT<pat::Electron,pat::Photon>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Photon>*)arg[1],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[2]);
}

static  void method_13704( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATPairFinalStateT<pat::Electron,pat::Photon>*)o)->clone)());
  else   (((const ::PATPairFinalStateT<pat::Electron,pat::Photon>*)o)->clone)();
}

static  void method_13705( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATPairFinalStateT<pat::Electron,pat::Photon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATPairFinalStateT<pat::Electron,pat::Photon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_13706( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATPairFinalStateT<pat::Electron,pat::Photon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATPairFinalStateT<pat::Electron,pat::Photon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_13707( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATPairFinalStateT<pat::Electron,pat::Photon>*)o)->numberOfDaughters)());
  else   (((const ::PATPairFinalStateT<pat::Electron,pat::Photon>*)o)->numberOfDaughters)();
}

static  void method_13708( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATPairFinalStateT<pat::Electron,pat::Photon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATPairFinalStateT<pat::Electron,pat::Photon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_13709( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATPairFinalStateT<pat::Electron,pat::Photon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATPairFinalStateT<pat::Electron,pat::Photon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_13710(void*, void * o, const std::vector<void*>&, void *) {
(((::PATPairFinalStateT<pat::Electron,pat::Photon>*)o)->::PATPairFinalStateT<pat::Electron,pat::Photon>::~PATPairFinalStateT)();
}
static void method_newdel_1886( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Electron,pat::Photon> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Electron,pat::Photon> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Electron,pat::Photon> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Electron,pat::Photon> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Electron,pat::Photon> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x201( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Electron,pat::Photon>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Electron,pat::Photon>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Electron,pat::Photon>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Electron,pat::Photon>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATPairFinalStateT<pat::Electron,pat::Photon> -------------------------------
void __PATPairFinalStateT_pat__Electron_pat__Photon__db_datamem(Reflex::Class*);
void __PATPairFinalStateT_pat__Electron_pat__Photon__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATPairFinalStateT_pat__Electron_pat__Photon__datamem_bld(&__PATPairFinalStateT_pat__Electron_pat__Photon__db_datamem);
Reflex::GenreflexMemberBuilder __PATPairFinalStateT_pat__Electron_pat__Photon__funcmem_bld(&__PATPairFinalStateT_pat__Electron_pat__Photon__db_funcmem);
void __PATPairFinalStateT_pat__Electron_pat__Photon__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATPairFinalStateT<pat::Electron,pat::Photon>"), typeid(::PATPairFinalStateT<pat::Electron,pat::Photon>), sizeof(::PATPairFinalStateT<pat::Electron,pat::Photon>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Electron,pat::Photon>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6476, Reflex::Literal("PATPairFinalStateT<pat::Electron,pat::Photon>::daughter1_type"))
  .AddTypedef(type_6478, Reflex::Literal("PATPairFinalStateT<pat::Electron,pat::Photon>::daughter2_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15469, type_15471), Reflex::Literal("operator="), operator_13700, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15471), Reflex::Literal("PATPairFinalStateT"), constructor_13701, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATPairFinalStateT"), constructor_13702, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45636, type_45637, type_45406), Reflex::Literal("PATPairFinalStateT"), constructor_13703, 0, "p1;p2;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATPairFinalStateT"), destructor_13710, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1886, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x201, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATPairFinalStateT_pat__Electron_pat__Photon__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATPairFinalStateT_pat__Electron_pat__Photon__funcmem_bld);
}

//------Delayed data member builder for class PATPairFinalStateT<pat::Electron,pat::Photon> -------------------
void __PATPairFinalStateT_pat__Electron_pat__Photon__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9785, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATPairFinalStateT_pat__Electron_pat__Photon_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9786, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATPairFinalStateT_pat__Electron_pat__Photon_, p2_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATPairFinalStateT<pat::Electron,pat::Photon> -------------------
void __PATPairFinalStateT_pat__Electron_pat__Photon__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15465), Reflex::Literal("clone"), method_13704, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_13705, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_13706, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_13707, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_13708, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_13709, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class vector<PATPairFinalStateT<pat::Electron, pat::Photon>,std::allocator<PATPairFinalStateT<pat::Electron, pat::Photon> > > -------------------------------
static void constructor_15482( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >();
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >();
}

static void constructor_15483( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >(*(const ::std::allocator<PATPairFinalStateT<pat::Electron,pat::Photon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >(*(const ::std::allocator<PATPairFinalStateT<pat::Electron,pat::Photon> >*)arg[0]);
}

static void constructor_15484( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Electron,pat::Photon>*)arg[1]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Electron,pat::Photon>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Electron,pat::Photon>*)arg[1],
      *(const ::std::allocator<PATPairFinalStateT<pat::Electron,pat::Photon> >*)arg[2]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Electron,pat::Photon>*)arg[1],
      *(const ::std::allocator<PATPairFinalStateT<pat::Electron,pat::Photon> >*)arg[2]);
  }
}

static void constructor_15485( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >(*(const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >(*(const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)arg[0]);
}

static void destructor_15486(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >::~vector)();
}
static  void operator_15487( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->operator=)(*(const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)arg[0]);
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->operator=)(*(const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)arg[0]);
}

static  void method_15488( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATPairFinalStateT<pat::Electron,pat::Photon>*)arg[1]);
}

static  void method_15489( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >)((((::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->begin)());
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->begin)();
}

static  void method_15490( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Electron,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >)((((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->begin)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->begin)();
}

static  void method_15491( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >)((((::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->end)());
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->end)();
}

static  void method_15492( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Electron,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >)((((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->end)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->end)();
}

static  void method_15497( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->size)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->size)();
}

static  void method_15498( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->max_size)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->max_size)();
}

static  void method_15499( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATPairFinalStateT<pat::Electron,pat::Photon>*)arg[1]);
  }
}

static  void method_15500( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->capacity)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->capacity)();
}

static  void method_15501( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->empty)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->empty)();
}

static  void method_15502( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_15503( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_15504( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_15506( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_15507( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_15508( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->front)();
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->front)();
}

static  void method_15509( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->front)();
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->front)();
}

static  void method_15510( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->back)();
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->back)();
}

static  void method_15511( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->back)();
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->back)();
}

static  void method_15512( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->data)());
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->data)();
}

static  void method_15513( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->data)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->data)();
}

static  void method_15514( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->push_back)(*(const ::PATPairFinalStateT<pat::Electron,pat::Photon>*)arg[0]);
}

static  void method_15515( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->pop_back)();
}

static  void method_15516( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >)((((::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >*)arg[0],
    *(const ::PATPairFinalStateT<pat::Electron,pat::Photon>*)arg[1]));
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >*)arg[0],
    *(const ::PATPairFinalStateT<pat::Electron,pat::Photon>*)arg[1]);
}

static  void method_15517( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATPairFinalStateT<pat::Electron,pat::Photon>*)arg[2]);
}

static  void method_15518( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >)((((::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >*)arg[0]));
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >*)arg[0]);
}

static  void method_15519( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >)((((::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >*)arg[1]));
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >*)arg[1]);
}

static  void method_15520( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->swap)(*(::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)arg[0]);
}

static  void method_15521( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->clear)();
}

static void method_newdel_2440( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x203( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATPairFinalStateT<pat::Electron,pat::Photon>,std::allocator<PATPairFinalStateT<pat::Electron,pat::Photon> > >")), ::Reflex::BaseOffset< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >,::std::_Vector_base<PATPairFinalStateT<pat::Electron,pat::Photon>,std::allocator<PATPairFinalStateT<pat::Electron,pat::Photon> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x204( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >::Generate();
}

//------Dictionary for class vector<PATPairFinalStateT<pat::Electron, pat::Photon>,std::allocator<PATPairFinalStateT<pat::Electron, pat::Photon> > > -------------------------------
void __std__vector_PATPairFinalStateT_pat__Electron_pat__Photon_s__db_datamem(Reflex::Class*);
void __std__vector_PATPairFinalStateT_pat__Electron_pat__Photon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATPairFinalStateT_pat__Electron_pat__Photon_s__datamem_bld(&__std__vector_PATPairFinalStateT_pat__Electron_pat__Photon_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATPairFinalStateT_pat__Electron_pat__Photon_s__funcmem_bld(&__std__vector_PATPairFinalStateT_pat__Electron_pat__Photon_s__db_funcmem);
void __std__vector_PATPairFinalStateT_pat__Electron_pat__Photon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >"), typeid(::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >), sizeof(::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3728, ::Reflex::BaseOffset< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >, ::std::_Vector_base<PATPairFinalStateT<pat::Electron,pat::Photon>,std::allocator<PATPairFinalStateT<pat::Electron,pat::Photon> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1886, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >::_Alloc_value_type"))
  .AddTypedef(type_3728, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >::_Base"))
  .AddTypedef(type_5083, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >::_Tp_alloc_type"))
  .AddTypedef(type_1886, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >::value_type"))
  .AddTypedef(type_15465, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >::pointer"))
  .AddTypedef(type_15467, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >::const_pointer"))
  .AddTypedef(type_15469, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >::reference"))
  .AddTypedef(type_15471, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >::const_reference"))
  .AddTypedef(type_15473, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >::iterator"))
  .AddTypedef(type_15475, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >::const_iterator"))
  .AddTypedef(type_5709, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >::const_reverse_iterator"))
  .AddTypedef(type_5710, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >::difference_type"))
  .AddTypedef(type_5083, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_15482, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60885), Reflex::Literal("vector"), constructor_15483, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_15471, type_60885), Reflex::Literal("vector"), constructor_15484, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60886), Reflex::Literal("vector"), constructor_15485, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_15486, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2440, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x203, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x204, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATPairFinalStateT_pat__Electron_pat__Photon_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATPairFinalStateT<pat::Electron, pat::Photon>,std::allocator<PATPairFinalStateT<pat::Electron, pat::Photon> > > -------------------
void __std__vector_PATPairFinalStateT_pat__Electron_pat__Photon_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATPairFinalStateT<pat::Electron, pat::Photon>,std::allocator<PATPairFinalStateT<pat::Electron, pat::Photon> > > -------------------
void __std__vector_PATPairFinalStateT_pat__Electron_pat__Photon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60887, type_60886), Reflex::Literal("operator="), operator_15487, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_15471), Reflex::Literal("assign"), method_15488, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15473), Reflex::Literal("begin"), method_15489, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15475), Reflex::Literal("begin"), method_15490, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15473), Reflex::Literal("end"), method_15491, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15475), Reflex::Literal("end"), method_15492, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_15497, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_15498, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_1886), Reflex::Literal("resize"), method_15499, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_15500, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_15501, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_15502, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15469, type_5015), Reflex::Literal("operator[]"), operator_15503, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15471, type_5015), Reflex::Literal("operator[]"), operator_15504, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15469, type_5015), Reflex::Literal("at"), method_15506, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15471, type_5015), Reflex::Literal("at"), method_15507, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15469), Reflex::Literal("front"), method_15508, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15471), Reflex::Literal("front"), method_15509, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15469), Reflex::Literal("back"), method_15510, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15471), Reflex::Literal("back"), method_15511, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15465), Reflex::Literal("data"), method_15512, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15467), Reflex::Literal("data"), method_15513, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_15471), Reflex::Literal("push_back"), method_15514, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_15515, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15473, type_15473, type_15471), Reflex::Literal("insert"), method_15516, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_15473, type_5015, type_15471), Reflex::Literal("insert"), method_15517, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15473, type_15473), Reflex::Literal("erase"), method_15518, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15473, type_15473, type_15473), Reflex::Literal("erase"), method_15519, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_60887), Reflex::Literal("swap"), method_15520, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_15521, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> -------------------------------
static  void operator_15637( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*)o)->operator=)(*(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*)arg[0]);
  else   (((::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*)o)->operator=)(*(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*)arg[0]);
}

static void constructor_15638( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>(*(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*)arg[0]);
  else ::new(mem) ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>(*(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*)arg[0]);
}

static void constructor_15639( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>();
  else ::new(mem) ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>();
}

static void constructor_15640( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>(*(const ::edm::Ptr<pat::Muon>*)arg[0],
      *(const ::edm::Ptr<pat::Muon>*)arg[1],
      *(const ::edm::Ptr<pat::Photon>*)arg[2],
      *(const ::edm::Ptr<pat::Photon>*)arg[3],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[4]);
  else ::new(mem) ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>(*(const ::edm::Ptr<pat::Muon>*)arg[0],
      *(const ::edm::Ptr<pat::Muon>*)arg[1],
      *(const ::edm::Ptr<pat::Photon>*)arg[2],
      *(const ::edm::Ptr<pat::Photon>*)arg[3],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[4]);
}

static  void method_15641( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*)o)->clone)());
  else   (((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*)o)->clone)();
}

static  void method_15642( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_15643( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_15644( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*)o)->numberOfDaughters)());
  else   (((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*)o)->numberOfDaughters)();
}

static  void method_15645( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_15646( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_15647(void*, void * o, const std::vector<void*>&, void *) {
(((::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*)o)->::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>::~PATQuadFinalStateT)();
}
static void method_newdel_2525( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x206( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> -------------------------------
void __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon__db_datamem(Reflex::Class*);
void __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon__datamem_bld(&__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon__db_datamem);
Reflex::GenreflexMemberBuilder __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon__funcmem_bld(&__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon__db_funcmem);
void __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>"), typeid(::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>), sizeof(::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6497, Reflex::Literal("PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>::daughter1_type"))
  .AddTypedef(type_6497, Reflex::Literal("PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>::daughter2_type"))
  .AddTypedef(type_6478, Reflex::Literal("PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>::daughter3_type"))
  .AddTypedef(type_6478, Reflex::Literal("PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>::daughter4_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18963, type_18965), Reflex::Literal("operator="), operator_15637, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18965), Reflex::Literal("PATQuadFinalStateT"), constructor_15638, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATQuadFinalStateT"), constructor_15639, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45727, type_45727, type_45637, type_45637, type_45406), Reflex::Literal("PATQuadFinalStateT"), constructor_15640, 0, "p1;p2;p3;p4;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATQuadFinalStateT"), destructor_15647, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2525, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x206, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon__funcmem_bld);
}

//------Delayed data member builder for class PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> -------------------
void __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9782, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9782, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_, p2_), ::Reflex::PRIVATE)
  .AddDataMember(type_9786, Reflex::Literal("p3_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_, p3_), ::Reflex::PRIVATE)
  .AddDataMember(type_9786, Reflex::Literal("p4_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_, p4_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> -------------------
void __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18959), Reflex::Literal("clone"), method_15641, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_15642, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_15643, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_15644, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_15645, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_15646, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> -------------------------------
static  void operator_15657( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*)o)->operator=)(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*)arg[0]);
  else   (((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*)o)->operator=)(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*)arg[0]);
}

static void constructor_15658( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*)arg[0]);
  else ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*)arg[0]);
}

static void constructor_15659( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>();
  else ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>();
}

static void constructor_15660( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Electron>*)arg[1],
      *(const ::edm::Ptr<pat::Electron>*)arg[2],
      *(const ::edm::Ptr<pat::Tau>*)arg[3],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[4]);
  else ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Electron>*)arg[1],
      *(const ::edm::Ptr<pat::Electron>*)arg[2],
      *(const ::edm::Ptr<pat::Tau>*)arg[3],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[4]);
}

static  void method_15661( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*)o)->clone)());
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*)o)->clone)();
}

static  void method_15662( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_15663( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_15664( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*)o)->numberOfDaughters)());
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*)o)->numberOfDaughters)();
}

static  void method_15665( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_15666( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_15667(void*, void * o, const std::vector<void*>&, void *) {
(((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*)o)->::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>::~PATQuadFinalStateT)();
}
static void method_newdel_2562( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x208( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> -------------------------------
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau__db_datamem(Reflex::Class*);
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau__datamem_bld(&__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau__db_datamem);
Reflex::GenreflexMemberBuilder __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau__funcmem_bld(&__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau__db_funcmem);
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>"), typeid(::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>), sizeof(::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6476, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>::daughter1_type"))
  .AddTypedef(type_6476, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>::daughter2_type"))
  .AddTypedef(type_6476, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>::daughter3_type"))
  .AddTypedef(type_7135, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>::daughter4_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19793, type_19795), Reflex::Literal("operator="), operator_15657, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19795), Reflex::Literal("PATQuadFinalStateT"), constructor_15658, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATQuadFinalStateT"), constructor_15659, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45636, type_45636, type_45636, type_46321, type_45406), Reflex::Literal("PATQuadFinalStateT"), constructor_15660, 0, "p1;p2;p3;p4;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATQuadFinalStateT"), destructor_15667, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2562, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x208, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau__funcmem_bld);
}

//------Delayed data member builder for class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> -------------------
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9785, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9785, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_, p2_), ::Reflex::PRIVATE)
  .AddDataMember(type_9785, Reflex::Literal("p3_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_, p3_), ::Reflex::PRIVATE)
  .AddDataMember(type_9787, Reflex::Literal("p4_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_, p4_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> -------------------
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19789), Reflex::Literal("clone"), method_15661, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_15662, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_15663, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_15664, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_15665, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_15666, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class PATPairFinalStateT<pat::Electron,pat::Tau> -------------------------------
static  void operator_13715( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATPairFinalStateT<pat::Electron,pat::Tau>*)o)->operator=)(*(const ::PATPairFinalStateT<pat::Electron,pat::Tau>*)arg[0]);
  else   (((::PATPairFinalStateT<pat::Electron,pat::Tau>*)o)->operator=)(*(const ::PATPairFinalStateT<pat::Electron,pat::Tau>*)arg[0]);
}

static void constructor_13716( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATPairFinalStateT<pat::Electron,pat::Tau>(*(const ::PATPairFinalStateT<pat::Electron,pat::Tau>*)arg[0]);
  else ::new(mem) ::PATPairFinalStateT<pat::Electron,pat::Tau>(*(const ::PATPairFinalStateT<pat::Electron,pat::Tau>*)arg[0]);
}

static void constructor_13717( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATPairFinalStateT<pat::Electron,pat::Tau>();
  else ::new(mem) ::PATPairFinalStateT<pat::Electron,pat::Tau>();
}

static void constructor_13718( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATPairFinalStateT<pat::Electron,pat::Tau>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Tau>*)arg[1],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[2]);
  else ::new(mem) ::PATPairFinalStateT<pat::Electron,pat::Tau>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Tau>*)arg[1],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[2]);
}

static  void method_13719( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATPairFinalStateT<pat::Electron,pat::Tau>*)o)->clone)());
  else   (((const ::PATPairFinalStateT<pat::Electron,pat::Tau>*)o)->clone)();
}

static  void method_13720( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATPairFinalStateT<pat::Electron,pat::Tau>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATPairFinalStateT<pat::Electron,pat::Tau>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_13721( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATPairFinalStateT<pat::Electron,pat::Tau>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATPairFinalStateT<pat::Electron,pat::Tau>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_13722( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATPairFinalStateT<pat::Electron,pat::Tau>*)o)->numberOfDaughters)());
  else   (((const ::PATPairFinalStateT<pat::Electron,pat::Tau>*)o)->numberOfDaughters)();
}

static  void method_13723( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATPairFinalStateT<pat::Electron,pat::Tau>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATPairFinalStateT<pat::Electron,pat::Tau>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_13724( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATPairFinalStateT<pat::Electron,pat::Tau>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATPairFinalStateT<pat::Electron,pat::Tau>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_13725(void*, void * o, const std::vector<void*>&, void *) {
(((::PATPairFinalStateT<pat::Electron,pat::Tau>*)o)->::PATPairFinalStateT<pat::Electron,pat::Tau>::~PATPairFinalStateT)();
}
static void method_newdel_1887( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Electron,pat::Tau> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Electron,pat::Tau> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Electron,pat::Tau> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Electron,pat::Tau> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATPairFinalStateT<pat::Electron,pat::Tau> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x210( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Electron,pat::Tau>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Electron,pat::Tau>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Electron,pat::Tau>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Electron,pat::Tau>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATPairFinalStateT<pat::Electron,pat::Tau> -------------------------------
void __PATPairFinalStateT_pat__Electron_pat__Tau__db_datamem(Reflex::Class*);
void __PATPairFinalStateT_pat__Electron_pat__Tau__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATPairFinalStateT_pat__Electron_pat__Tau__datamem_bld(&__PATPairFinalStateT_pat__Electron_pat__Tau__db_datamem);
Reflex::GenreflexMemberBuilder __PATPairFinalStateT_pat__Electron_pat__Tau__funcmem_bld(&__PATPairFinalStateT_pat__Electron_pat__Tau__db_funcmem);
void __PATPairFinalStateT_pat__Electron_pat__Tau__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATPairFinalStateT<pat::Electron,pat::Tau>"), typeid(::PATPairFinalStateT<pat::Electron,pat::Tau>), sizeof(::PATPairFinalStateT<pat::Electron,pat::Tau>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATPairFinalStateT<pat::Electron,pat::Tau>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6476, Reflex::Literal("PATPairFinalStateT<pat::Electron,pat::Tau>::daughter1_type"))
  .AddTypedef(type_7135, Reflex::Literal("PATPairFinalStateT<pat::Electron,pat::Tau>::daughter2_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16844, type_16846), Reflex::Literal("operator="), operator_13715, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16846), Reflex::Literal("PATPairFinalStateT"), constructor_13716, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATPairFinalStateT"), constructor_13717, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45636, type_46321, type_45406), Reflex::Literal("PATPairFinalStateT"), constructor_13718, 0, "p1;p2;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATPairFinalStateT"), destructor_13725, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1887, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x210, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATPairFinalStateT_pat__Electron_pat__Tau__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATPairFinalStateT_pat__Electron_pat__Tau__funcmem_bld);
}

//------Delayed data member builder for class PATPairFinalStateT<pat::Electron,pat::Tau> -------------------
void __PATPairFinalStateT_pat__Electron_pat__Tau__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9785, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATPairFinalStateT_pat__Electron_pat__Tau_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9787, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATPairFinalStateT_pat__Electron_pat__Tau_, p2_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATPairFinalStateT<pat::Electron,pat::Tau> -------------------
void __PATPairFinalStateT_pat__Electron_pat__Tau__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16840), Reflex::Literal("clone"), method_13719, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_13720, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_13721, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_13722, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_13723, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_13724, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class vector<PATPairFinalStateT<pat::Electron, pat::Tau>,std::allocator<PATPairFinalStateT<pat::Electron, pat::Tau> > > -------------------------------
static void constructor_16857( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >();
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >();
}

static void constructor_16858( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >(*(const ::std::allocator<PATPairFinalStateT<pat::Electron,pat::Tau> >*)arg[0]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >(*(const ::std::allocator<PATPairFinalStateT<pat::Electron,pat::Tau> >*)arg[0]);
}

static void constructor_16859( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Electron,pat::Tau>*)arg[1]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Electron,pat::Tau>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Electron,pat::Tau>*)arg[1],
      *(const ::std::allocator<PATPairFinalStateT<pat::Electron,pat::Tau> >*)arg[2]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Electron,pat::Tau>*)arg[1],
      *(const ::std::allocator<PATPairFinalStateT<pat::Electron,pat::Tau> >*)arg[2]);
  }
}

static void constructor_16860( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >(*(const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)arg[0]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >(*(const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)arg[0]);
}

static void destructor_16861(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >::~vector)();
}
static  void operator_16862( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->operator=)(*(const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)arg[0]);
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->operator=)(*(const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)arg[0]);
}

static  void method_16863( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATPairFinalStateT<pat::Electron,pat::Tau>*)arg[1]);
}

static  void method_16864( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >)((((::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->begin)());
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->begin)();
}

static  void method_16865( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Electron,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >)((((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->begin)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->begin)();
}

static  void method_16866( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >)((((::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->end)());
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->end)();
}

static  void method_16867( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Electron,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >)((((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->end)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->end)();
}

static  void method_16872( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->size)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->size)();
}

static  void method_16873( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->max_size)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->max_size)();
}

static  void method_16874( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATPairFinalStateT<pat::Electron,pat::Tau>*)arg[1]);
  }
}

static  void method_16875( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->capacity)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->capacity)();
}

static  void method_16876( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->empty)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->empty)();
}

static  void method_16877( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_16878( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_16879( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_16881( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_16882( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_16883( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->front)();
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->front)();
}

static  void method_16884( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->front)();
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->front)();
}

static  void method_16885( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->back)();
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->back)();
}

static  void method_16886( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->back)();
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->back)();
}

static  void method_16887( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->data)());
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->data)();
}

static  void method_16888( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->data)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->data)();
}

static  void method_16889( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->push_back)(*(const ::PATPairFinalStateT<pat::Electron,pat::Tau>*)arg[0]);
}

static  void method_16890( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->pop_back)();
}

static  void method_16891( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >)((((::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >*)arg[0],
    *(const ::PATPairFinalStateT<pat::Electron,pat::Tau>*)arg[1]));
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >*)arg[0],
    *(const ::PATPairFinalStateT<pat::Electron,pat::Tau>*)arg[1]);
}

static  void method_16892( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATPairFinalStateT<pat::Electron,pat::Tau>*)arg[2]);
}

static  void method_16893( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >)((((::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >*)arg[0]));
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >*)arg[0]);
}

static  void method_16894( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >)((((::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >*)arg[1]));
  else   (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Electron,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >*)arg[1]);
}

static  void method_16895( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->swap)(*(::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)arg[0]);
}

static  void method_16896( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->clear)();
}

static void method_newdel_2858( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x212( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATPairFinalStateT<pat::Electron,pat::Tau>,std::allocator<PATPairFinalStateT<pat::Electron,pat::Tau> > >")), ::Reflex::BaseOffset< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >,::std::_Vector_base<PATPairFinalStateT<pat::Electron,pat::Tau>,std::allocator<PATPairFinalStateT<pat::Electron,pat::Tau> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x213( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >::Generate();
}

//------Dictionary for class vector<PATPairFinalStateT<pat::Electron, pat::Tau>,std::allocator<PATPairFinalStateT<pat::Electron, pat::Tau> > > -------------------------------
void __std__vector_PATPairFinalStateT_pat__Electron_pat__Tau_s__db_datamem(Reflex::Class*);
void __std__vector_PATPairFinalStateT_pat__Electron_pat__Tau_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATPairFinalStateT_pat__Electron_pat__Tau_s__datamem_bld(&__std__vector_PATPairFinalStateT_pat__Electron_pat__Tau_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATPairFinalStateT_pat__Electron_pat__Tau_s__funcmem_bld(&__std__vector_PATPairFinalStateT_pat__Electron_pat__Tau_s__db_funcmem);
void __std__vector_PATPairFinalStateT_pat__Electron_pat__Tau_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >"), typeid(::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >), sizeof(::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3729, ::Reflex::BaseOffset< ::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >, ::std::_Vector_base<PATPairFinalStateT<pat::Electron,pat::Tau>,std::allocator<PATPairFinalStateT<pat::Electron,pat::Tau> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1887, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >::_Alloc_value_type"))
  .AddTypedef(type_3729, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >::_Base"))
  .AddTypedef(type_5084, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >::_Tp_alloc_type"))
  .AddTypedef(type_1887, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >::value_type"))
  .AddTypedef(type_16840, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >::pointer"))
  .AddTypedef(type_16842, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >::const_pointer"))
  .AddTypedef(type_16844, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >::reference"))
  .AddTypedef(type_16846, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >::const_reference"))
  .AddTypedef(type_16848, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >::iterator"))
  .AddTypedef(type_16850, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >::const_iterator"))
  .AddTypedef(type_5711, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >::const_reverse_iterator"))
  .AddTypedef(type_5712, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >::difference_type"))
  .AddTypedef(type_5084, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_16857, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63797), Reflex::Literal("vector"), constructor_16858, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_16846, type_63797), Reflex::Literal("vector"), constructor_16859, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63798), Reflex::Literal("vector"), constructor_16860, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_16861, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2858, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x212, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x213, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATPairFinalStateT_pat__Electron_pat__Tau_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATPairFinalStateT<pat::Electron, pat::Tau>,std::allocator<PATPairFinalStateT<pat::Electron, pat::Tau> > > -------------------
void __std__vector_PATPairFinalStateT_pat__Electron_pat__Tau_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATPairFinalStateT<pat::Electron, pat::Tau>,std::allocator<PATPairFinalStateT<pat::Electron, pat::Tau> > > -------------------
void __std__vector_PATPairFinalStateT_pat__Electron_pat__Tau_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63799, type_63798), Reflex::Literal("operator="), operator_16862, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_16846), Reflex::Literal("assign"), method_16863, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16848), Reflex::Literal("begin"), method_16864, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16850), Reflex::Literal("begin"), method_16865, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16848), Reflex::Literal("end"), method_16866, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16850), Reflex::Literal("end"), method_16867, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_16872, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_16873, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_1887), Reflex::Literal("resize"), method_16874, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_16875, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_16876, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_16877, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16844, type_5015), Reflex::Literal("operator[]"), operator_16878, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16846, type_5015), Reflex::Literal("operator[]"), operator_16879, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16844, type_5015), Reflex::Literal("at"), method_16881, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16846, type_5015), Reflex::Literal("at"), method_16882, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16844), Reflex::Literal("front"), method_16883, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16846), Reflex::Literal("front"), method_16884, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16844), Reflex::Literal("back"), method_16885, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16846), Reflex::Literal("back"), method_16886, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16840), Reflex::Literal("data"), method_16887, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16842), Reflex::Literal("data"), method_16888, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_16846), Reflex::Literal("push_back"), method_16889, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_16890, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16848, type_16848, type_16846), Reflex::Literal("insert"), method_16891, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_16848, type_5015, type_16846), Reflex::Literal("insert"), method_16892, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16848, type_16848), Reflex::Literal("erase"), method_16893, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16848, type_16848, type_16848), Reflex::Literal("erase"), method_16894, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_63799), Reflex::Literal("swap"), method_16895, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_16896, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<PATTripletFinalStateT<pat::Electron, pat::Photon, pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Electron, pat::Photon, pat::Photon> > > -------------------------------
static void constructor_17044( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >();
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >();
}

static void constructor_17045( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >(*(const ::std::allocator<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >(*(const ::std::allocator<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)arg[0]);
}

static void constructor_17046( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*)arg[1]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*)arg[1],
      *(const ::std::allocator<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)arg[2]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*)arg[1],
      *(const ::std::allocator<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)arg[2]);
  }
}

static void constructor_17047( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >(*(const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >(*(const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)arg[0]);
}

static void destructor_17048(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >::~vector)();
}
static  void operator_17049( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->operator=)(*(const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->operator=)(*(const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)arg[0]);
}

static  void method_17050( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*)arg[1]);
}

static  void method_17051( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->begin)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->begin)();
}

static  void method_17052( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->begin)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->begin)();
}

static  void method_17053( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->end)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->end)();
}

static  void method_17054( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->end)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->end)();
}

static  void method_17059( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->size)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->size)();
}

static  void method_17060( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->max_size)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->max_size)();
}

static  void method_17061( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*)arg[1]);
  }
}

static  void method_17062( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->capacity)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->capacity)();
}

static  void method_17063( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->empty)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->empty)();
}

static  void method_17064( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_17065( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_17066( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_17068( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_17069( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_17070( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->front)();
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->front)();
}

static  void method_17071( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->front)();
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->front)();
}

static  void method_17072( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->back)();
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->back)();
}

static  void method_17073( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->back)();
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->back)();
}

static  void method_17074( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->data)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->data)();
}

static  void method_17075( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->data)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->data)();
}

static  void method_17076( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->push_back)(*(const ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*)arg[0]);
}

static  void method_17077( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->pop_back)();
}

static  void method_17078( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*)arg[1]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*)arg[1]);
}

static  void method_17079( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*)arg[2]);
}

static  void method_17080( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >*)arg[0]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >*)arg[0]);
}

static  void method_17081( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >*)arg[1]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >*)arg[1]);
}

static  void method_17082( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->swap)(*(::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)arg[0]);
}

static  void method_17083( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->clear)();
}

static void method_newdel_2880( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x215( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >")), ::Reflex::BaseOffset< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >,::std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x216( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >::Generate();
}

//------Dictionary for class vector<PATTripletFinalStateT<pat::Electron, pat::Photon, pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Electron, pat::Photon, pat::Photon> > > -------------------------------
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s__db_datamem(Reflex::Class*);
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s__datamem_bld(&__std__vector_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s__funcmem_bld(&__std__vector_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s__db_funcmem);
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >"), typeid(::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >), sizeof(::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3711, ::Reflex::BaseOffset< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >, ::std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_110, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >::_Alloc_value_type"))
  .AddTypedef(type_3711, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >::_Base"))
  .AddTypedef(type_5066, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >::_Tp_alloc_type"))
  .AddTypedef(type_110, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >::value_type"))
  .AddTypedef(type_17027, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >::pointer"))
  .AddTypedef(type_17029, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >::const_pointer"))
  .AddTypedef(type_17031, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >::reference"))
  .AddTypedef(type_17033, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >::const_reference"))
  .AddTypedef(type_17035, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >::iterator"))
  .AddTypedef(type_17037, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >::const_iterator"))
  .AddTypedef(type_5675, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >::const_reverse_iterator"))
  .AddTypedef(type_5676, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >::difference_type"))
  .AddTypedef(type_5066, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_17044, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63812), Reflex::Literal("vector"), constructor_17045, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_17033, type_63812), Reflex::Literal("vector"), constructor_17046, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63813), Reflex::Literal("vector"), constructor_17047, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_17048, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2880, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x215, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x216, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATTripletFinalStateT<pat::Electron, pat::Photon, pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Electron, pat::Photon, pat::Photon> > > -------------------
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATTripletFinalStateT<pat::Electron, pat::Photon, pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Electron, pat::Photon, pat::Photon> > > -------------------
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63814, type_63813), Reflex::Literal("operator="), operator_17049, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_17033), Reflex::Literal("assign"), method_17050, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17035), Reflex::Literal("begin"), method_17051, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17037), Reflex::Literal("begin"), method_17052, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17035), Reflex::Literal("end"), method_17053, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17037), Reflex::Literal("end"), method_17054, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_17059, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_17060, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_110), Reflex::Literal("resize"), method_17061, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_17062, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_17063, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_17064, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17031, type_5015), Reflex::Literal("operator[]"), operator_17065, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17033, type_5015), Reflex::Literal("operator[]"), operator_17066, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17031, type_5015), Reflex::Literal("at"), method_17068, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17033, type_5015), Reflex::Literal("at"), method_17069, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17031), Reflex::Literal("front"), method_17070, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17033), Reflex::Literal("front"), method_17071, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17031), Reflex::Literal("back"), method_17072, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17033), Reflex::Literal("back"), method_17073, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17027), Reflex::Literal("data"), method_17074, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17029), Reflex::Literal("data"), method_17075, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_17033), Reflex::Literal("push_back"), method_17076, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_17077, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17035, type_17035, type_17033), Reflex::Literal("insert"), method_17078, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_17035, type_5015, type_17033), Reflex::Literal("insert"), method_17079, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17035, type_17035), Reflex::Literal("erase"), method_17080, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17035, type_17035, type_17035), Reflex::Literal("erase"), method_17081, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_63814), Reflex::Literal("swap"), method_17082, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_17083, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Muon>,std::allocator<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Muon> > > -------------------------------
static void constructor_17194( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >();
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >();
}

static void constructor_17195( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >(*(const ::std::allocator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >(*(const ::std::allocator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)arg[0]);
}

static void constructor_17196( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*)arg[1]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*)arg[1],
      *(const ::std::allocator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)arg[2]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*)arg[1],
      *(const ::std::allocator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)arg[2]);
  }
}

static void constructor_17197( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >(*(const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >(*(const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)arg[0]);
}

static void destructor_17198(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >::~vector)();
}
static  void operator_17199( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->operator=)(*(const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->operator=)(*(const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)arg[0]);
}

static  void method_17200( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*)arg[1]);
}

static  void method_17201( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >)((((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->begin)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->begin)();
}

static  void method_17202( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >)((((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->begin)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->begin)();
}

static  void method_17203( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >)((((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->end)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->end)();
}

static  void method_17204( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >)((((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->end)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->end)();
}

static  void method_17209( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->size)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->size)();
}

static  void method_17210( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->max_size)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->max_size)();
}

static  void method_17211( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*)arg[1]);
  }
}

static  void method_17212( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->capacity)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->capacity)();
}

static  void method_17213( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->empty)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->empty)();
}

static  void method_17214( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_17215( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_17216( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_17218( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_17219( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_17220( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->front)();
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->front)();
}

static  void method_17221( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->front)();
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->front)();
}

static  void method_17222( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->back)();
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->back)();
}

static  void method_17223( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->back)();
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->back)();
}

static  void method_17224( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->data)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->data)();
}

static  void method_17225( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->data)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->data)();
}

static  void method_17226( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->push_back)(*(const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*)arg[0]);
}

static  void method_17227( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->pop_back)();
}

static  void method_17228( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >)((((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*)arg[1]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*)arg[1]);
}

static  void method_17229( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*)arg[2]);
}

static  void method_17230( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >)((((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >*)arg[0]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >*)arg[0]);
}

static  void method_17231( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >)((((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >*)arg[1]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >*)arg[1]);
}

static  void method_17232( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->swap)(*(::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)arg[0]);
}

static  void method_17233( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->clear)();
}

static void method_newdel_2919( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x218( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>,std::allocator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >")), ::Reflex::BaseOffset< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >,::std::_Vector_base<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>,std::allocator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x219( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >::Generate();
}

//------Dictionary for class vector<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Muon>,std::allocator<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Muon> > > -------------------------------
void __std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s__db_datamem(Reflex::Class*);
void __std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s__datamem_bld(&__std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s__funcmem_bld(&__std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s__db_funcmem);
void __std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >"), typeid(::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >), sizeof(::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3710, ::Reflex::BaseOffset< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >, ::std::_Vector_base<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>,std::allocator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1051, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >::_Alloc_value_type"))
  .AddTypedef(type_3710, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >::_Base"))
  .AddTypedef(type_5065, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >::_Tp_alloc_type"))
  .AddTypedef(type_1051, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >::value_type"))
  .AddTypedef(type_17177, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >::pointer"))
  .AddTypedef(type_17179, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >::const_pointer"))
  .AddTypedef(type_17181, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >::reference"))
  .AddTypedef(type_17183, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >::const_reference"))
  .AddTypedef(type_17185, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >::iterator"))
  .AddTypedef(type_17187, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >::const_iterator"))
  .AddTypedef(type_5673, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >::const_reverse_iterator"))
  .AddTypedef(type_5674, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >::difference_type"))
  .AddTypedef(type_5065, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_17194, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63837), Reflex::Literal("vector"), constructor_17195, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_17183, type_63837), Reflex::Literal("vector"), constructor_17196, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63838), Reflex::Literal("vector"), constructor_17197, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_17198, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2919, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x218, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x219, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Muon>,std::allocator<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Muon> > > -------------------
void __std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Muon>,std::allocator<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Muon> > > -------------------
void __std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63839, type_63838), Reflex::Literal("operator="), operator_17199, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_17183), Reflex::Literal("assign"), method_17200, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17185), Reflex::Literal("begin"), method_17201, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17187), Reflex::Literal("begin"), method_17202, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17185), Reflex::Literal("end"), method_17203, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17187), Reflex::Literal("end"), method_17204, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_17209, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_17210, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_1051), Reflex::Literal("resize"), method_17211, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_17212, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_17213, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_17214, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17181, type_5015), Reflex::Literal("operator[]"), operator_17215, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17183, type_5015), Reflex::Literal("operator[]"), operator_17216, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17181, type_5015), Reflex::Literal("at"), method_17218, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17183, type_5015), Reflex::Literal("at"), method_17219, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17181), Reflex::Literal("front"), method_17220, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17183), Reflex::Literal("front"), method_17221, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17181), Reflex::Literal("back"), method_17222, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17183), Reflex::Literal("back"), method_17223, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17177), Reflex::Literal("data"), method_17224, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17179), Reflex::Literal("data"), method_17225, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_17183), Reflex::Literal("push_back"), method_17226, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_17227, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17185, type_17185, type_17183), Reflex::Literal("insert"), method_17228, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_17185, type_5015, type_17183), Reflex::Literal("insert"), method_17229, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17185, type_17185), Reflex::Literal("erase"), method_17230, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17185, type_17185, type_17185), Reflex::Literal("erase"), method_17231, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_63839), Reflex::Literal("swap"), method_17232, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_17233, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<PATTripletFinalStateT<pat::Muon, pat::Tau, pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Muon, pat::Tau, pat::Tau> > > -------------------------------
static void constructor_17261( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >();
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >();
}

static void constructor_17262( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >(*(const ::std::allocator<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >(*(const ::std::allocator<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)arg[0]);
}

static void constructor_17263( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*)arg[1]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*)arg[1],
      *(const ::std::allocator<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)arg[2]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*)arg[1],
      *(const ::std::allocator<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)arg[2]);
  }
}

static void constructor_17264( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >(*(const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >(*(const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)arg[0]);
}

static void destructor_17265(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >::~vector)();
}
static  void operator_17266( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->operator=)(*(const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->operator=)(*(const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)arg[0]);
}

static  void method_17267( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*)arg[1]);
}

static  void method_17268( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >)((((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->begin)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->begin)();
}

static  void method_17269( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >)((((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->begin)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->begin)();
}

static  void method_17270( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >)((((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->end)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->end)();
}

static  void method_17271( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >)((((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->end)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->end)();
}

static  void method_17276( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->size)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->size)();
}

static  void method_17277( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->max_size)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->max_size)();
}

static  void method_17278( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*)arg[1]);
  }
}

static  void method_17279( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->capacity)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->capacity)();
}

static  void method_17280( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->empty)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->empty)();
}

static  void method_17281( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_17282( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_17283( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_17285( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_17286( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_17287( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->front)();
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->front)();
}

static  void method_17288( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->front)();
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->front)();
}

static  void method_17289( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->back)();
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->back)();
}

static  void method_17290( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->back)();
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->back)();
}

static  void method_17291( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->data)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->data)();
}

static  void method_17292( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->data)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->data)();
}

static  void method_17293( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->push_back)(*(const ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*)arg[0]);
}

static  void method_17294( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->pop_back)();
}

static  void method_17295( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >)((((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*)arg[1]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*)arg[1]);
}

static  void method_17296( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*)arg[2]);
}

static  void method_17297( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >)((((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >*)arg[0]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >*)arg[0]);
}

static  void method_17298( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >)((((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >*)arg[1]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >*)arg[1]);
}

static  void method_17299( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->swap)(*(::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)arg[0]);
}

static  void method_17300( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->clear)();
}

static void method_newdel_2938( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x221( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >")), ::Reflex::BaseOffset< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >,::std::_Vector_base<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x222( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >::Generate();
}

//------Dictionary for class vector<PATTripletFinalStateT<pat::Muon, pat::Tau, pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Muon, pat::Tau, pat::Tau> > > -------------------------------
void __std__vector_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s__db_datamem(Reflex::Class*);
void __std__vector_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s__datamem_bld(&__std__vector_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s__funcmem_bld(&__std__vector_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s__db_funcmem);
void __std__vector_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >"), typeid(::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >), sizeof(::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3707, ::Reflex::BaseOffset< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >, ::std::_Vector_base<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1518, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >::_Alloc_value_type"))
  .AddTypedef(type_3707, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >::_Base"))
  .AddTypedef(type_5062, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >::_Tp_alloc_type"))
  .AddTypedef(type_1518, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >::value_type"))
  .AddTypedef(type_17244, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >::pointer"))
  .AddTypedef(type_17246, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >::const_pointer"))
  .AddTypedef(type_17248, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >::reference"))
  .AddTypedef(type_17250, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >::const_reference"))
  .AddTypedef(type_17252, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >::iterator"))
  .AddTypedef(type_17254, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >::const_iterator"))
  .AddTypedef(type_5667, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >::const_reverse_iterator"))
  .AddTypedef(type_5668, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >::difference_type"))
  .AddTypedef(type_5062, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_17261, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63841), Reflex::Literal("vector"), constructor_17262, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_17250, type_63841), Reflex::Literal("vector"), constructor_17263, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63842), Reflex::Literal("vector"), constructor_17264, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_17265, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2938, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x221, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x222, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATTripletFinalStateT<pat::Muon, pat::Tau, pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Muon, pat::Tau, pat::Tau> > > -------------------
void __std__vector_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATTripletFinalStateT<pat::Muon, pat::Tau, pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Muon, pat::Tau, pat::Tau> > > -------------------
void __std__vector_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63843, type_63842), Reflex::Literal("operator="), operator_17266, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_17250), Reflex::Literal("assign"), method_17267, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17252), Reflex::Literal("begin"), method_17268, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17254), Reflex::Literal("begin"), method_17269, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17252), Reflex::Literal("end"), method_17270, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17254), Reflex::Literal("end"), method_17271, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_17276, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_17277, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_1518), Reflex::Literal("resize"), method_17278, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_17279, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_17280, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_17281, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17248, type_5015), Reflex::Literal("operator[]"), operator_17282, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17250, type_5015), Reflex::Literal("operator[]"), operator_17283, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17248, type_5015), Reflex::Literal("at"), method_17285, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17250, type_5015), Reflex::Literal("at"), method_17286, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17248), Reflex::Literal("front"), method_17287, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17250), Reflex::Literal("front"), method_17288, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17248), Reflex::Literal("back"), method_17289, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17250), Reflex::Literal("back"), method_17290, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17244), Reflex::Literal("data"), method_17291, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17246), Reflex::Literal("data"), method_17292, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_17250), Reflex::Literal("push_back"), method_17293, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_17294, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17252, type_17252, type_17250), Reflex::Literal("insert"), method_17295, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_17252, type_5015, type_17250), Reflex::Literal("insert"), method_17296, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17252, type_17252), Reflex::Literal("erase"), method_17297, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17252, type_17252, type_17252), Reflex::Literal("erase"), method_17298, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_63843), Reflex::Literal("swap"), method_17299, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_17300, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Muon>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Muon> > > -------------------------------
static void constructor_17328( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >();
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >();
}

static void constructor_17329( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >(*(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >(*(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)arg[0]);
}

static void constructor_17330( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*)arg[1]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*)arg[1],
      *(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)arg[2]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*)arg[1],
      *(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)arg[2]);
  }
}

static void constructor_17331( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)arg[0]);
}

static void destructor_17332(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >::~vector)();
}
static  void operator_17333( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->operator=)(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->operator=)(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)arg[0]);
}

static  void method_17334( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*)arg[1]);
}

static  void method_17335( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->begin)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->begin)();
}

static  void method_17336( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->begin)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->begin)();
}

static  void method_17337( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->end)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->end)();
}

static  void method_17338( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->end)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->end)();
}

static  void method_17343( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->size)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->size)();
}

static  void method_17344( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->max_size)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->max_size)();
}

static  void method_17345( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*)arg[1]);
  }
}

static  void method_17346( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->capacity)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->capacity)();
}

static  void method_17347( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->empty)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->empty)();
}

static  void method_17348( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_17349( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_17350( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_17352( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_17353( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_17354( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->front)();
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->front)();
}

static  void method_17355( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->front)();
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->front)();
}

static  void method_17356( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->back)();
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->back)();
}

static  void method_17357( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->back)();
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->back)();
}

static  void method_17358( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->data)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->data)();
}

static  void method_17359( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->data)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->data)();
}

static  void method_17360( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->push_back)(*(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*)arg[0]);
}

static  void method_17361( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->pop_back)();
}

static  void method_17362( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*)arg[1]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*)arg[1]);
}

static  void method_17363( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*)arg[2]);
}

static  void method_17364( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >*)arg[0]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >*)arg[0]);
}

static  void method_17365( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >*)arg[1]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >*)arg[1]);
}

static  void method_17366( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->swap)(*(::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)arg[0]);
}

static  void method_17367( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->clear)();
}

static void method_newdel_2945( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x224( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >")), ::Reflex::BaseOffset< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >,::std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x225( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >::Generate();
}

//------Dictionary for class vector<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Muon>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Muon> > > -------------------------------
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s__db_datamem(Reflex::Class*);
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s__datamem_bld(&__std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s__funcmem_bld(&__std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s__db_funcmem);
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >"), typeid(::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >), sizeof(::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3695, ::Reflex::BaseOffset< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >, ::std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_113, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >::_Alloc_value_type"))
  .AddTypedef(type_3695, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >::_Base"))
  .AddTypedef(type_5050, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >::_Tp_alloc_type"))
  .AddTypedef(type_113, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >::value_type"))
  .AddTypedef(type_17311, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >::pointer"))
  .AddTypedef(type_17313, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >::const_pointer"))
  .AddTypedef(type_17315, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >::reference"))
  .AddTypedef(type_17317, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >::const_reference"))
  .AddTypedef(type_17319, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >::iterator"))
  .AddTypedef(type_17321, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >::const_iterator"))
  .AddTypedef(type_5643, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >::const_reverse_iterator"))
  .AddTypedef(type_5644, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >::difference_type"))
  .AddTypedef(type_5050, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_17328, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63845), Reflex::Literal("vector"), constructor_17329, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_17317, type_63845), Reflex::Literal("vector"), constructor_17330, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_63846), Reflex::Literal("vector"), constructor_17331, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_17332, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2945, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x224, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x225, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Muon>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Muon> > > -------------------
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Muon>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Muon> > > -------------------
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_63847, type_63846), Reflex::Literal("operator="), operator_17333, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_17317), Reflex::Literal("assign"), method_17334, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17319), Reflex::Literal("begin"), method_17335, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17321), Reflex::Literal("begin"), method_17336, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17319), Reflex::Literal("end"), method_17337, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17321), Reflex::Literal("end"), method_17338, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_17343, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_17344, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_113), Reflex::Literal("resize"), method_17345, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_17346, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_17347, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_17348, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17315, type_5015), Reflex::Literal("operator[]"), operator_17349, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17317, type_5015), Reflex::Literal("operator[]"), operator_17350, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17315, type_5015), Reflex::Literal("at"), method_17352, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17317, type_5015), Reflex::Literal("at"), method_17353, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17315), Reflex::Literal("front"), method_17354, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17317), Reflex::Literal("front"), method_17355, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17315), Reflex::Literal("back"), method_17356, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17317), Reflex::Literal("back"), method_17357, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17311), Reflex::Literal("data"), method_17358, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17313), Reflex::Literal("data"), method_17359, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_17317), Reflex::Literal("push_back"), method_17360, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_17361, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17319, type_17319, type_17317), Reflex::Literal("insert"), method_17362, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_17319, type_5015, type_17317), Reflex::Literal("insert"), method_17363, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17319, type_17319), Reflex::Literal("erase"), method_17364, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17319, type_17319, type_17319), Reflex::Literal("erase"), method_17365, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_63847), Reflex::Literal("swap"), method_17366, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_17367, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<PATMultiCandFinalState,std::allocator<PATMultiCandFinalState> > -------------------------------
static void constructor_18159( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATMultiCandFinalState>();
  else ::new(mem) ::std::vector<PATMultiCandFinalState>();
}

static void constructor_18160( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATMultiCandFinalState>(*(const ::std::allocator<PATMultiCandFinalState>*)arg[0]);
  else ::new(mem) ::std::vector<PATMultiCandFinalState>(*(const ::std::allocator<PATMultiCandFinalState>*)arg[0]);
}

static void constructor_18161( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATMultiCandFinalState>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATMultiCandFinalState>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATMultiCandFinalState>(*(::std::size_t*)arg[0],
      *(const ::PATMultiCandFinalState*)arg[1]);
  else ::new(mem) ::std::vector<PATMultiCandFinalState>(*(::std::size_t*)arg[0],
      *(const ::PATMultiCandFinalState*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATMultiCandFinalState>(*(::std::size_t*)arg[0],
      *(const ::PATMultiCandFinalState*)arg[1],
      *(const ::std::allocator<PATMultiCandFinalState>*)arg[2]);
  else ::new(mem) ::std::vector<PATMultiCandFinalState>(*(::std::size_t*)arg[0],
      *(const ::PATMultiCandFinalState*)arg[1],
      *(const ::std::allocator<PATMultiCandFinalState>*)arg[2]);
  }
}

static void constructor_18162( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATMultiCandFinalState>(*(const ::std::vector<PATMultiCandFinalState>*)arg[0]);
  else ::new(mem) ::std::vector<PATMultiCandFinalState>(*(const ::std::vector<PATMultiCandFinalState>*)arg[0]);
}

static void destructor_18163(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATMultiCandFinalState>*)o)->::std::vector<PATMultiCandFinalState>::~vector)();
}
static  void operator_18164( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATMultiCandFinalState>*)o)->operator=)(*(const ::std::vector<PATMultiCandFinalState>*)arg[0]);
  else   (((::std::vector<PATMultiCandFinalState>*)o)->operator=)(*(const ::std::vector<PATMultiCandFinalState>*)arg[0]);
}

static  void method_18165( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATMultiCandFinalState>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATMultiCandFinalState*)arg[1]);
}

static  void method_18166( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATMultiCandFinalState*,std::vector<PATMultiCandFinalState> >)((((::std::vector<PATMultiCandFinalState>*)o)->begin)());
  else   (((::std::vector<PATMultiCandFinalState>*)o)->begin)();
}

static  void method_18167( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATMultiCandFinalState*,std::vector<PATMultiCandFinalState> >)((((const ::std::vector<PATMultiCandFinalState>*)o)->begin)());
  else   (((const ::std::vector<PATMultiCandFinalState>*)o)->begin)();
}

static  void method_18168( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATMultiCandFinalState*,std::vector<PATMultiCandFinalState> >)((((::std::vector<PATMultiCandFinalState>*)o)->end)());
  else   (((::std::vector<PATMultiCandFinalState>*)o)->end)();
}

static  void method_18169( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATMultiCandFinalState*,std::vector<PATMultiCandFinalState> >)((((const ::std::vector<PATMultiCandFinalState>*)o)->end)());
  else   (((const ::std::vector<PATMultiCandFinalState>*)o)->end)();
}

static  void method_18174( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATMultiCandFinalState>*)o)->size)());
  else   (((const ::std::vector<PATMultiCandFinalState>*)o)->size)();
}

static  void method_18175( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATMultiCandFinalState>*)o)->max_size)());
  else   (((const ::std::vector<PATMultiCandFinalState>*)o)->max_size)();
}

static  void method_18176( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATMultiCandFinalState>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATMultiCandFinalState>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATMultiCandFinalState*)arg[1]);
  }
}

static  void method_18177( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATMultiCandFinalState>*)o)->capacity)());
  else   (((const ::std::vector<PATMultiCandFinalState>*)o)->capacity)();
}

static  void method_18178( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATMultiCandFinalState>*)o)->empty)());
  else   (((const ::std::vector<PATMultiCandFinalState>*)o)->empty)();
}

static  void method_18179( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATMultiCandFinalState>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_18180( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATMultiCandFinalState>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATMultiCandFinalState>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_18181( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATMultiCandFinalState>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATMultiCandFinalState>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_18183( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATMultiCandFinalState>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATMultiCandFinalState>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18184( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATMultiCandFinalState>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATMultiCandFinalState>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18185( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATMultiCandFinalState>*)o)->front)();
  else   (((::std::vector<PATMultiCandFinalState>*)o)->front)();
}

static  void method_18186( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATMultiCandFinalState>*)o)->front)();
  else   (((const ::std::vector<PATMultiCandFinalState>*)o)->front)();
}

static  void method_18187( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATMultiCandFinalState>*)o)->back)();
  else   (((::std::vector<PATMultiCandFinalState>*)o)->back)();
}

static  void method_18188( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATMultiCandFinalState>*)o)->back)();
  else   (((const ::std::vector<PATMultiCandFinalState>*)o)->back)();
}

static  void method_18189( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATMultiCandFinalState>*)o)->data)());
  else   (((::std::vector<PATMultiCandFinalState>*)o)->data)();
}

static  void method_18190( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATMultiCandFinalState>*)o)->data)());
  else   (((const ::std::vector<PATMultiCandFinalState>*)o)->data)();
}

static  void method_18191( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATMultiCandFinalState>*)o)->push_back)(*(const ::PATMultiCandFinalState*)arg[0]);
}

static  void method_18192( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATMultiCandFinalState>*)o)->pop_back)();
}

static  void method_18193( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATMultiCandFinalState*,std::vector<PATMultiCandFinalState> >)((((::std::vector<PATMultiCandFinalState>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATMultiCandFinalState*,std::vector<PATMultiCandFinalState> >*)arg[0],
    *(const ::PATMultiCandFinalState*)arg[1]));
  else   (((::std::vector<PATMultiCandFinalState>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATMultiCandFinalState*,std::vector<PATMultiCandFinalState> >*)arg[0],
    *(const ::PATMultiCandFinalState*)arg[1]);
}

static  void method_18194( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATMultiCandFinalState>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATMultiCandFinalState*,std::vector<PATMultiCandFinalState> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATMultiCandFinalState*)arg[2]);
}

static  void method_18195( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATMultiCandFinalState*,std::vector<PATMultiCandFinalState> >)((((::std::vector<PATMultiCandFinalState>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATMultiCandFinalState*,std::vector<PATMultiCandFinalState> >*)arg[0]));
  else   (((::std::vector<PATMultiCandFinalState>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATMultiCandFinalState*,std::vector<PATMultiCandFinalState> >*)arg[0]);
}

static  void method_18196( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATMultiCandFinalState*,std::vector<PATMultiCandFinalState> >)((((::std::vector<PATMultiCandFinalState>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATMultiCandFinalState*,std::vector<PATMultiCandFinalState> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATMultiCandFinalState*,std::vector<PATMultiCandFinalState> >*)arg[1]));
  else   (((::std::vector<PATMultiCandFinalState>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATMultiCandFinalState*,std::vector<PATMultiCandFinalState> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATMultiCandFinalState*,std::vector<PATMultiCandFinalState> >*)arg[1]);
}

static  void method_18197( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATMultiCandFinalState>*)o)->swap)(*(::std::vector<PATMultiCandFinalState>*)arg[0]);
}

static  void method_18198( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATMultiCandFinalState>*)o)->clear)();
}

static void method_newdel_3002( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATMultiCandFinalState> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATMultiCandFinalState> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATMultiCandFinalState> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATMultiCandFinalState> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATMultiCandFinalState> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x227( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATMultiCandFinalState,std::allocator<PATMultiCandFinalState> >")), ::Reflex::BaseOffset< ::std::vector<PATMultiCandFinalState>,::std::_Vector_base<PATMultiCandFinalState,std::allocator<PATMultiCandFinalState> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x228( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATMultiCandFinalState> >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATMultiCandFinalState> >::Generate();
}

//------Dictionary for class vector<PATMultiCandFinalState,std::allocator<PATMultiCandFinalState> > -------------------------------
void __std__vector_PATMultiCandFinalState__db_datamem(Reflex::Class*);
void __std__vector_PATMultiCandFinalState__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATMultiCandFinalState__datamem_bld(&__std__vector_PATMultiCandFinalState__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATMultiCandFinalState__funcmem_bld(&__std__vector_PATMultiCandFinalState__db_funcmem);
void __std__vector_PATMultiCandFinalState__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATMultiCandFinalState>"), typeid(::std::vector<PATMultiCandFinalState>), sizeof(::std::vector<PATMultiCandFinalState>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3735, ::Reflex::BaseOffset< ::std::vector<PATMultiCandFinalState>, ::std::_Vector_base<PATMultiCandFinalState,std::allocator<PATMultiCandFinalState> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_67, Reflex::Literal("std::vector<PATMultiCandFinalState>::_Alloc_value_type"))
  .AddTypedef(type_3735, Reflex::Literal("std::vector<PATMultiCandFinalState>::_Base"))
  .AddTypedef(type_5031, Reflex::Literal("std::vector<PATMultiCandFinalState>::_Tp_alloc_type"))
  .AddTypedef(type_67, Reflex::Literal("std::vector<PATMultiCandFinalState>::value_type"))
  .AddTypedef(type_18144, Reflex::Literal("std::vector<PATMultiCandFinalState>::pointer"))
  .AddTypedef(type_18146, Reflex::Literal("std::vector<PATMultiCandFinalState>::const_pointer"))
  .AddTypedef(type_18148, Reflex::Literal("std::vector<PATMultiCandFinalState>::reference"))
  .AddTypedef(type_18150, Reflex::Literal("std::vector<PATMultiCandFinalState>::const_reference"))
  .AddTypedef(type_17746, Reflex::Literal("std::vector<PATMultiCandFinalState>::iterator"))
  .AddTypedef(type_17747, Reflex::Literal("std::vector<PATMultiCandFinalState>::const_iterator"))
  .AddTypedef(type_5723, Reflex::Literal("std::vector<PATMultiCandFinalState>::const_reverse_iterator"))
  .AddTypedef(type_5724, Reflex::Literal("std::vector<PATMultiCandFinalState>::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATMultiCandFinalState>::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATMultiCandFinalState>::difference_type"))
  .AddTypedef(type_5031, Reflex::Literal("std::vector<PATMultiCandFinalState>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_18159, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_69772), Reflex::Literal("vector"), constructor_18160, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_18150, type_69772), Reflex::Literal("vector"), constructor_18161, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_47135), Reflex::Literal("vector"), constructor_18162, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_18163, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3002, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x227, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x228, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATMultiCandFinalState__funcmem_bld);
}

//------Delayed data member builder for class vector<PATMultiCandFinalState,std::allocator<PATMultiCandFinalState> > -------------------
void __std__vector_PATMultiCandFinalState__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATMultiCandFinalState,std::allocator<PATMultiCandFinalState> > -------------------
void __std__vector_PATMultiCandFinalState__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_69773, type_47135), Reflex::Literal("operator="), operator_18164, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_18150), Reflex::Literal("assign"), method_18165, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17746), Reflex::Literal("begin"), method_18166, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17747), Reflex::Literal("begin"), method_18167, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17746), Reflex::Literal("end"), method_18168, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17747), Reflex::Literal("end"), method_18169, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_18174, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_18175, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_67), Reflex::Literal("resize"), method_18176, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_18177, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_18178, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_18179, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18148, type_5015), Reflex::Literal("operator[]"), operator_18180, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18150, type_5015), Reflex::Literal("operator[]"), operator_18181, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18148, type_5015), Reflex::Literal("at"), method_18183, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18150, type_5015), Reflex::Literal("at"), method_18184, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18148), Reflex::Literal("front"), method_18185, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18150), Reflex::Literal("front"), method_18186, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18148), Reflex::Literal("back"), method_18187, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18150), Reflex::Literal("back"), method_18188, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18144), Reflex::Literal("data"), method_18189, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18146), Reflex::Literal("data"), method_18190, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_18150), Reflex::Literal("push_back"), method_18191, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_18192, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17746, type_17746, type_18150), Reflex::Literal("insert"), method_18193, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_17746, type_5015, type_18150), Reflex::Literal("insert"), method_18194, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17746, type_17746), Reflex::Literal("erase"), method_18195, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17746, type_17746, type_17746), Reflex::Literal("erase"), method_18196, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_69773), Reflex::Literal("swap"), method_18197, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_18198, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> -------------------------------
static  void operator_16391( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*)o)->operator=)(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*)arg[0]);
  else   (((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*)o)->operator=)(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*)arg[0]);
}

static void constructor_16392( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*)arg[0]);
  else ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*)arg[0]);
}

static void constructor_16393( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>();
  else ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>();
}

static void constructor_16394( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Electron>*)arg[1],
      *(const ::edm::Ptr<pat::Electron>*)arg[2],
      *(const ::edm::Ptr<pat::Muon>*)arg[3],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[4]);
  else ::new(mem) ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>(*(const ::edm::Ptr<pat::Electron>*)arg[0],
      *(const ::edm::Ptr<pat::Electron>*)arg[1],
      *(const ::edm::Ptr<pat::Electron>*)arg[2],
      *(const ::edm::Ptr<pat::Muon>*)arg[3],
      *(const ::edm::Ptr<PATFinalStateEvent>*)arg[4]);
}

static  void method_16395( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*)o)->clone)());
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*)o)->clone)();
}

static  void method_16396( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*)o)->daughterUnsafe)(*(::size_t*)arg[0]);
}

static  void method_16397( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]));
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*)o)->daughterPtrUnsafe)(*(::size_t*)arg[0]);
}

static  void method_16398( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*)o)->numberOfDaughters)());
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*)o)->numberOfDaughters)();
}

static  void method_16399( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::Candidate>)((((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*)o)->daughterUserCandUnsafe)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_16400( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*)o)->daughterOverlaps)(*(::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static void destructor_16401(void*, void * o, const std::vector<void*>&, void *) {
(((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*)o)->::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>::~PATQuadFinalStateT)();
}
static void method_newdel_2811( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x230( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("PATFinalState")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>,::PATFinalState >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("pat::PATObject<reco::LeafCandidate>")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>,::pat::PATObject<reco::LeafCandidate> >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> -------------------------------
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon__db_datamem(Reflex::Class*);
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon__datamem_bld(&__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon__db_datamem);
Reflex::GenreflexMemberBuilder __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon__funcmem_bld(&__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon__db_funcmem);
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>"), typeid(::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>), sizeof(::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddBase(type_466, ::Reflex::BaseOffset< ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>, ::PATFinalState >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_6476, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>::daughter1_type"))
  .AddTypedef(type_6476, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>::daughter2_type"))
  .AddTypedef(type_6476, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>::daughter3_type"))
  .AddTypedef(type_6497, Reflex::Literal("PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>::daughter4_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20125, type_20127), Reflex::Literal("operator="), operator_16391, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20127), Reflex::Literal("PATQuadFinalStateT"), constructor_16392, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PATQuadFinalStateT"), constructor_16393, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45636, type_45636, type_45636, type_45727, type_45406), Reflex::Literal("PATQuadFinalStateT"), constructor_16394, 0, "p1;p2;p3;p4;evt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PATQuadFinalStateT"), destructor_16401, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2811, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x230, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon__funcmem_bld);
}

//------Delayed data member builder for class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> -------------------
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9785, Reflex::Literal("p1_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_, p1_), ::Reflex::PRIVATE)
  .AddDataMember(type_9785, Reflex::Literal("p2_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_, p2_), ::Reflex::PRIVATE)
  .AddDataMember(type_9785, Reflex::Literal("p3_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_, p3_), ::Reflex::PRIVATE)
  .AddDataMember(type_9782, Reflex::Literal("p4_"), OffsetOf(__shadow__::__PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_, p4_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> -------------------
void __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20121), Reflex::Literal("clone"), method_16395, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45407, type_3148), Reflex::Literal("daughterUnsafe"), method_16396, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788c, type_3148), Reflex::Literal("daughterPtrUnsafe"), method_16397, 0, "i", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3148), Reflex::Literal("numberOfDaughters"), method_16398, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9788, type_3148, type_24234), Reflex::Literal("daughterUserCandUnsafe"), method_16399, 0, "i;tag", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_29484, type_3148, type_24234), Reflex::Literal("daughterOverlaps"), method_16400, 0, "i;label", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST);
}
//------Stub functions for class vector<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Photon> > > -------------------------------
static void constructor_18326( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >();
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >();
}

static void constructor_18327( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >(*(const ::std::allocator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >(*(const ::std::allocator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)arg[0]);
}

static void constructor_18328( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*)arg[1]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*)arg[1],
      *(const ::std::allocator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)arg[2]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*)arg[1],
      *(const ::std::allocator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)arg[2]);
  }
}

static void constructor_18329( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >(*(const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >(*(const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)arg[0]);
}

static void destructor_18330(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >::~vector)();
}
static  void operator_18331( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->operator=)(*(const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->operator=)(*(const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)arg[0]);
}

static  void method_18332( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*)arg[1]);
}

static  void method_18333( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >)((((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->begin)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->begin)();
}

static  void method_18334( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >)((((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->begin)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->begin)();
}

static  void method_18335( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >)((((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->end)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->end)();
}

static  void method_18336( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >)((((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->end)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->end)();
}

static  void method_18341( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->size)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->size)();
}

static  void method_18342( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->max_size)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->max_size)();
}

static  void method_18343( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*)arg[1]);
  }
}

static  void method_18344( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->capacity)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->capacity)();
}

static  void method_18345( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->empty)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->empty)();
}

static  void method_18346( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_18347( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_18348( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_18350( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18351( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18352( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->front)();
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->front)();
}

static  void method_18353( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->front)();
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->front)();
}

static  void method_18354( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->back)();
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->back)();
}

static  void method_18355( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->back)();
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->back)();
}

static  void method_18356( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->data)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->data)();
}

static  void method_18357( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->data)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->data)();
}

static  void method_18358( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->push_back)(*(const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*)arg[0]);
}

static  void method_18359( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->pop_back)();
}

static  void method_18360( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >)((((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*)arg[1]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*)arg[1]);
}

static  void method_18361( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*)arg[2]);
}

static  void method_18362( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >)((((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >*)arg[0]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >*)arg[0]);
}

static  void method_18363( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >)((((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >*)arg[1]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >*)arg[1]);
}

static  void method_18364( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->swap)(*(::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)arg[0]);
}

static  void method_18365( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->clear)();
}

static void method_newdel_3061( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x232( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >")), ::Reflex::BaseOffset< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >,::std::_Vector_base<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x233( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >::Generate();
}

//------Dictionary for class vector<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Photon> > > -------------------------------
void __std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s__db_datamem(Reflex::Class*);
void __std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s__datamem_bld(&__std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s__funcmem_bld(&__std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s__db_funcmem);
void __std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >"), typeid(::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >), sizeof(::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3708, ::Reflex::BaseOffset< ::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >, ::std::_Vector_base<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_912, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >::_Alloc_value_type"))
  .AddTypedef(type_3708, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >::_Base"))
  .AddTypedef(type_5063, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >::_Tp_alloc_type"))
  .AddTypedef(type_912, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >::value_type"))
  .AddTypedef(type_18311, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >::pointer"))
  .AddTypedef(type_18313, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >::const_pointer"))
  .AddTypedef(type_18315, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >::reference"))
  .AddTypedef(type_18317, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >::const_reference"))
  .AddTypedef(type_17728, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >::iterator"))
  .AddTypedef(type_17729, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >::const_iterator"))
  .AddTypedef(type_5669, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >::const_reverse_iterator"))
  .AddTypedef(type_5670, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >::difference_type"))
  .AddTypedef(type_5063, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_18326, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_69784), Reflex::Literal("vector"), constructor_18327, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_18317, type_69784), Reflex::Literal("vector"), constructor_18328, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_69785), Reflex::Literal("vector"), constructor_18329, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_18330, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3061, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x232, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x233, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Photon> > > -------------------
void __std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Photon> > > -------------------
void __std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_69786, type_69785), Reflex::Literal("operator="), operator_18331, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_18317), Reflex::Literal("assign"), method_18332, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17728), Reflex::Literal("begin"), method_18333, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17729), Reflex::Literal("begin"), method_18334, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17728), Reflex::Literal("end"), method_18335, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17729), Reflex::Literal("end"), method_18336, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_18341, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_18342, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_912), Reflex::Literal("resize"), method_18343, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_18344, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_18345, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_18346, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18315, type_5015), Reflex::Literal("operator[]"), operator_18347, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18317, type_5015), Reflex::Literal("operator[]"), operator_18348, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18315, type_5015), Reflex::Literal("at"), method_18350, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18317, type_5015), Reflex::Literal("at"), method_18351, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18315), Reflex::Literal("front"), method_18352, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18317), Reflex::Literal("front"), method_18353, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18315), Reflex::Literal("back"), method_18354, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18317), Reflex::Literal("back"), method_18355, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18311), Reflex::Literal("data"), method_18356, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18313), Reflex::Literal("data"), method_18357, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_18317), Reflex::Literal("push_back"), method_18358, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_18359, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17728, type_17728, type_18317), Reflex::Literal("insert"), method_18360, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_17728, type_5015, type_18317), Reflex::Literal("insert"), method_18361, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17728, type_17728), Reflex::Literal("erase"), method_18362, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17728, type_17728, type_17728), Reflex::Literal("erase"), method_18363, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_69786), Reflex::Literal("swap"), method_18364, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_18365, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Tau, pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Tau, pat::Tau> > > -------------------------------
static void constructor_18478( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >();
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >();
}

static void constructor_18479( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >(*(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >(*(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)arg[0]);
}

static void constructor_18480( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*)arg[1]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*)arg[1],
      *(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)arg[2]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*)arg[1],
      *(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)arg[2]);
  }
}

static void constructor_18481( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)arg[0]);
}

static void destructor_18482(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >::~vector)();
}
static  void operator_18483( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->operator=)(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->operator=)(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)arg[0]);
}

static  void method_18484( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*)arg[1]);
}

static  void method_18485( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->begin)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->begin)();
}

static  void method_18486( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->begin)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->begin)();
}

static  void method_18487( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->end)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->end)();
}

static  void method_18488( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->end)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->end)();
}

static  void method_18493( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->size)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->size)();
}

static  void method_18494( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->max_size)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->max_size)();
}

static  void method_18495( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*)arg[1]);
  }
}

static  void method_18496( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->capacity)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->capacity)();
}

static  void method_18497( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->empty)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->empty)();
}

static  void method_18498( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_18499( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_18500( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_18502( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18503( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18504( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->front)();
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->front)();
}

static  void method_18505( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->front)();
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->front)();
}

static  void method_18506( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->back)();
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->back)();
}

static  void method_18507( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->back)();
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->back)();
}

static  void method_18508( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->data)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->data)();
}

static  void method_18509( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->data)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->data)();
}

static  void method_18510( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->push_back)(*(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*)arg[0]);
}

static  void method_18511( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->pop_back)();
}

static  void method_18512( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*)arg[1]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*)arg[1]);
}

static  void method_18513( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*)arg[2]);
}

static  void method_18514( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >*)arg[0]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >*)arg[0]);
}

static  void method_18515( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >*)arg[1]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >*)arg[1]);
}

static  void method_18516( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->swap)(*(::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)arg[0]);
}

static  void method_18517( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->clear)();
}

static void method_newdel_3101( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x235( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >")), ::Reflex::BaseOffset< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >,::std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x236( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >::Generate();
}

//------Dictionary for class vector<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Tau, pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Tau, pat::Tau> > > -------------------------------
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s__db_datamem(Reflex::Class*);
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s__datamem_bld(&__std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s__funcmem_bld(&__std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s__db_funcmem);
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >"), typeid(::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >), sizeof(::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3692, ::Reflex::BaseOffset< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >, ::std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1022, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >::_Alloc_value_type"))
  .AddTypedef(type_3692, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >::_Base"))
  .AddTypedef(type_5047, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >::_Tp_alloc_type"))
  .AddTypedef(type_1022, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >::value_type"))
  .AddTypedef(type_18463, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >::pointer"))
  .AddTypedef(type_18465, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >::const_pointer"))
  .AddTypedef(type_18467, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >::reference"))
  .AddTypedef(type_18469, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >::const_reference"))
  .AddTypedef(type_17722, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >::iterator"))
  .AddTypedef(type_17723, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >::const_iterator"))
  .AddTypedef(type_5637, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >::const_reverse_iterator"))
  .AddTypedef(type_5638, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >::difference_type"))
  .AddTypedef(type_5047, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_18478, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_69790), Reflex::Literal("vector"), constructor_18479, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_18469, type_69790), Reflex::Literal("vector"), constructor_18480, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_69791), Reflex::Literal("vector"), constructor_18481, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_18482, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3101, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x235, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x236, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Tau, pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Tau, pat::Tau> > > -------------------
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Tau, pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Tau, pat::Tau> > > -------------------
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_69792, type_69791), Reflex::Literal("operator="), operator_18483, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_18469), Reflex::Literal("assign"), method_18484, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17722), Reflex::Literal("begin"), method_18485, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17723), Reflex::Literal("begin"), method_18486, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17722), Reflex::Literal("end"), method_18487, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17723), Reflex::Literal("end"), method_18488, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_18493, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_18494, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_1022), Reflex::Literal("resize"), method_18495, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_18496, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_18497, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_18498, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18467, type_5015), Reflex::Literal("operator[]"), operator_18499, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18469, type_5015), Reflex::Literal("operator[]"), operator_18500, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18467, type_5015), Reflex::Literal("at"), method_18502, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18469, type_5015), Reflex::Literal("at"), method_18503, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18467), Reflex::Literal("front"), method_18504, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18469), Reflex::Literal("front"), method_18505, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18467), Reflex::Literal("back"), method_18506, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18469), Reflex::Literal("back"), method_18507, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18463), Reflex::Literal("data"), method_18508, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18465), Reflex::Literal("data"), method_18509, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_18469), Reflex::Literal("push_back"), method_18510, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_18511, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17722, type_17722, type_18469), Reflex::Literal("insert"), method_18512, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_17722, type_5015, type_18469), Reflex::Literal("insert"), method_18513, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17722, type_17722), Reflex::Literal("erase"), method_18514, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17722, type_17722, type_17722), Reflex::Literal("erase"), method_18515, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_69792), Reflex::Literal("swap"), method_18516, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_18517, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Electron>,std::allocator<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Electron> > > -------------------------------
static void constructor_18549( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >();
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >();
}

static void constructor_18550( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >(*(const ::std::allocator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >(*(const ::std::allocator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)arg[0]);
}

static void constructor_18551( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*)arg[1]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*)arg[1],
      *(const ::std::allocator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)arg[2]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*)arg[1],
      *(const ::std::allocator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)arg[2]);
  }
}

static void constructor_18552( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >(*(const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >(*(const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)arg[0]);
}

static void destructor_18553(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >::~vector)();
}
static  void operator_18554( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->operator=)(*(const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->operator=)(*(const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)arg[0]);
}

static  void method_18555( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*)arg[1]);
}

static  void method_18556( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->begin)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->begin)();
}

static  void method_18557( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->begin)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->begin)();
}

static  void method_18558( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->end)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->end)();
}

static  void method_18559( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->end)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->end)();
}

static  void method_18564( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->size)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->size)();
}

static  void method_18565( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->max_size)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->max_size)();
}

static  void method_18566( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*)arg[1]);
  }
}

static  void method_18567( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->capacity)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->capacity)();
}

static  void method_18568( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->empty)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->empty)();
}

static  void method_18569( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_18570( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_18571( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_18573( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18574( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18575( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->front)();
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->front)();
}

static  void method_18576( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->front)();
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->front)();
}

static  void method_18577( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->back)();
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->back)();
}

static  void method_18578( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->back)();
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->back)();
}

static  void method_18579( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->data)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->data)();
}

static  void method_18580( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->data)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->data)();
}

static  void method_18581( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->push_back)(*(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*)arg[0]);
}

static  void method_18582( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->pop_back)();
}

static  void method_18583( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*)arg[1]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*)arg[1]);
}

static  void method_18584( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*)arg[2]);
}

static  void method_18585( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >*)arg[0]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >*)arg[0]);
}

static  void method_18586( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >*)arg[1]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >*)arg[1]);
}

static  void method_18587( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->swap)(*(::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)arg[0]);
}

static  void method_18588( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->clear)();
}

static void method_newdel_3126( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x238( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >")), ::Reflex::BaseOffset< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >,::std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x239( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >::Generate();
}

//------Dictionary for class vector<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Electron>,std::allocator<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Electron> > > -------------------------------
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s__db_datamem(Reflex::Class*);
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s__datamem_bld(&__std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s__funcmem_bld(&__std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s__db_funcmem);
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >"), typeid(::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >), sizeof(::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3719, ::Reflex::BaseOffset< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >, ::std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1524, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >::_Alloc_value_type"))
  .AddTypedef(type_3719, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >::_Base"))
  .AddTypedef(type_5074, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >::_Tp_alloc_type"))
  .AddTypedef(type_1524, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >::value_type"))
  .AddTypedef(type_18534, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >::pointer"))
  .AddTypedef(type_18536, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >::const_pointer"))
  .AddTypedef(type_18538, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >::reference"))
  .AddTypedef(type_18540, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >::const_reference"))
  .AddTypedef(type_17736, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >::iterator"))
  .AddTypedef(type_17737, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >::const_iterator"))
  .AddTypedef(type_5691, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >::const_reverse_iterator"))
  .AddTypedef(type_5692, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >::difference_type"))
  .AddTypedef(type_5074, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_18549, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_69797), Reflex::Literal("vector"), constructor_18550, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_18540, type_69797), Reflex::Literal("vector"), constructor_18551, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_69798), Reflex::Literal("vector"), constructor_18552, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_18553, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3126, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x238, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x239, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Electron>,std::allocator<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Electron> > > -------------------
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Electron>,std::allocator<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Electron> > > -------------------
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_69799, type_69798), Reflex::Literal("operator="), operator_18554, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_18540), Reflex::Literal("assign"), method_18555, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17736), Reflex::Literal("begin"), method_18556, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17737), Reflex::Literal("begin"), method_18557, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17736), Reflex::Literal("end"), method_18558, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17737), Reflex::Literal("end"), method_18559, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_18564, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_18565, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_1524), Reflex::Literal("resize"), method_18566, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_18567, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_18568, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_18569, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18538, type_5015), Reflex::Literal("operator[]"), operator_18570, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18540, type_5015), Reflex::Literal("operator[]"), operator_18571, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18538, type_5015), Reflex::Literal("at"), method_18573, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18540, type_5015), Reflex::Literal("at"), method_18574, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18538), Reflex::Literal("front"), method_18575, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18540), Reflex::Literal("front"), method_18576, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18538), Reflex::Literal("back"), method_18577, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18540), Reflex::Literal("back"), method_18578, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18534), Reflex::Literal("data"), method_18579, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18536), Reflex::Literal("data"), method_18580, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_18540), Reflex::Literal("push_back"), method_18581, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_18582, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17736, type_17736, type_18540), Reflex::Literal("insert"), method_18583, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_17736, type_5015, type_18540), Reflex::Literal("insert"), method_18584, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17736, type_17736), Reflex::Literal("erase"), method_18585, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17736, type_17736, type_17736), Reflex::Literal("erase"), method_18586, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_69799), Reflex::Literal("swap"), method_18587, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_18588, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Photon> > > -------------------------------
static void constructor_18614( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >();
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >();
}

static void constructor_18615( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >(*(const ::std::allocator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >(*(const ::std::allocator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)arg[0]);
}

static void constructor_18616( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*)arg[1]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*)arg[1],
      *(const ::std::allocator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)arg[2]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*)arg[1],
      *(const ::std::allocator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)arg[2]);
  }
}

static void constructor_18617( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >(*(const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >(*(const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)arg[0]);
}

static void destructor_18618(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >::~vector)();
}
static  void operator_18619( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->operator=)(*(const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->operator=)(*(const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)arg[0]);
}

static  void method_18620( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*)arg[1]);
}

static  void method_18621( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->begin)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->begin)();
}

static  void method_18622( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->begin)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->begin)();
}

static  void method_18623( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->end)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->end)();
}

static  void method_18624( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->end)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->end)();
}

static  void method_18629( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->size)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->size)();
}

static  void method_18630( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->max_size)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->max_size)();
}

static  void method_18631( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*)arg[1]);
  }
}

static  void method_18632( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->capacity)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->capacity)();
}

static  void method_18633( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->empty)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->empty)();
}

static  void method_18634( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_18635( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_18636( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_18638( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18639( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18640( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->front)();
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->front)();
}

static  void method_18641( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->front)();
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->front)();
}

static  void method_18642( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->back)();
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->back)();
}

static  void method_18643( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->back)();
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->back)();
}

static  void method_18644( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->data)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->data)();
}

static  void method_18645( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->data)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->data)();
}

static  void method_18646( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->push_back)(*(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*)arg[0]);
}

static  void method_18647( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->pop_back)();
}

static  void method_18648( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*)arg[1]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*)arg[1]);
}

static  void method_18649( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*)arg[2]);
}

static  void method_18650( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >*)arg[0]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >*)arg[0]);
}

static  void method_18651( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >*)arg[1]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >*)arg[1]);
}

static  void method_18652( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->swap)(*(::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)arg[0]);
}

static  void method_18653( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->clear)();
}

static void method_newdel_3132( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x241( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >")), ::Reflex::BaseOffset< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >,::std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x242( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >::Generate();
}

//------Dictionary for class vector<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Photon> > > -------------------------------
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s__db_datamem(Reflex::Class*);
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s__datamem_bld(&__std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s__funcmem_bld(&__std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s__db_funcmem);
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >"), typeid(::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >), sizeof(::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3716, ::Reflex::BaseOffset< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >, ::std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1393, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >::_Alloc_value_type"))
  .AddTypedef(type_3716, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >::_Base"))
  .AddTypedef(type_5071, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >::_Tp_alloc_type"))
  .AddTypedef(type_1393, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >::value_type"))
  .AddTypedef(type_18599, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >::pointer"))
  .AddTypedef(type_18601, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >::const_pointer"))
  .AddTypedef(type_18603, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >::reference"))
  .AddTypedef(type_18605, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >::const_reference"))
  .AddTypedef(type_17734, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >::iterator"))
  .AddTypedef(type_17735, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >::const_iterator"))
  .AddTypedef(type_5685, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >::const_reverse_iterator"))
  .AddTypedef(type_5686, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >::difference_type"))
  .AddTypedef(type_5071, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_18614, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_69801), Reflex::Literal("vector"), constructor_18615, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_18605, type_69801), Reflex::Literal("vector"), constructor_18616, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_69802), Reflex::Literal("vector"), constructor_18617, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_18618, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3132, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x241, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x242, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Photon> > > -------------------
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Photon> > > -------------------
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_69803, type_69802), Reflex::Literal("operator="), operator_18619, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_18605), Reflex::Literal("assign"), method_18620, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17734), Reflex::Literal("begin"), method_18621, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17735), Reflex::Literal("begin"), method_18622, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17734), Reflex::Literal("end"), method_18623, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17735), Reflex::Literal("end"), method_18624, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_18629, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_18630, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_1393), Reflex::Literal("resize"), method_18631, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_18632, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_18633, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_18634, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18603, type_5015), Reflex::Literal("operator[]"), operator_18635, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18605, type_5015), Reflex::Literal("operator[]"), operator_18636, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18603, type_5015), Reflex::Literal("at"), method_18638, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18605, type_5015), Reflex::Literal("at"), method_18639, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18603), Reflex::Literal("front"), method_18640, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18605), Reflex::Literal("front"), method_18641, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18603), Reflex::Literal("back"), method_18642, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18605), Reflex::Literal("back"), method_18643, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18599), Reflex::Literal("data"), method_18644, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18601), Reflex::Literal("data"), method_18645, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_18605), Reflex::Literal("push_back"), method_18646, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_18647, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17734, type_17734, type_18605), Reflex::Literal("insert"), method_18648, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_17734, type_5015, type_18605), Reflex::Literal("insert"), method_18649, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17734, type_17734), Reflex::Literal("erase"), method_18650, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17734, type_17734, type_17734), Reflex::Literal("erase"), method_18651, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_69803), Reflex::Literal("swap"), method_18652, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_18653, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Photon, pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Photon, pat::Photon> > > -------------------------------
static void constructor_18974( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >();
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >();
}

static void constructor_18975( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >(*(const ::std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >(*(const ::std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)arg[0]);
}

static void constructor_18976( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*)arg[1]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*)arg[1],
      *(const ::std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)arg[2]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*)arg[1],
      *(const ::std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)arg[2]);
  }
}

static void constructor_18977( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >(*(const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >(*(const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)arg[0]);
}

static void destructor_18978(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >::~vector)();
}
static  void operator_18979( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->operator=)(*(const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->operator=)(*(const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)arg[0]);
}

static  void method_18980( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*)arg[1]);
}

static  void method_18981( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >)((((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->begin)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->begin)();
}

static  void method_18982( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >)((((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->begin)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->begin)();
}

static  void method_18983( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >)((((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->end)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->end)();
}

static  void method_18984( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >)((((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->end)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->end)();
}

static  void method_18989( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->size)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->size)();
}

static  void method_18990( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->max_size)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->max_size)();
}

static  void method_18991( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*)arg[1]);
  }
}

static  void method_18992( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->capacity)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->capacity)();
}

static  void method_18993( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->empty)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->empty)();
}

static  void method_18994( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_18995( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_18996( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_18998( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_18999( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19000( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->front)();
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->front)();
}

static  void method_19001( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->front)();
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->front)();
}

static  void method_19002( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->back)();
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->back)();
}

static  void method_19003( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->back)();
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->back)();
}

static  void method_19004( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->data)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->data)();
}

static  void method_19005( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->data)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->data)();
}

static  void method_19006( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->push_back)(*(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*)arg[0]);
}

static  void method_19007( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->pop_back)();
}

static  void method_19008( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >)((((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*)arg[1]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*)arg[1]);
}

static  void method_19009( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*)arg[2]);
}

static  void method_19010( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >)((((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >*)arg[0]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >*)arg[0]);
}

static  void method_19011( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >)((((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >*)arg[1]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*,std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >*)arg[1]);
}

static  void method_19012( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->swap)(*(::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)arg[0]);
}

static  void method_19013( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->clear)();
}

static void method_newdel_3307( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x244( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >")), ::Reflex::BaseOffset< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >,::std::_Vector_base<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x245( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >::Generate();
}

//------Dictionary for class vector<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Photon, pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Photon, pat::Photon> > > -------------------------------
void __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s__db_datamem(Reflex::Class*);
void __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s__datamem_bld(&__std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s__funcmem_bld(&__std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s__db_funcmem);
void __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >"), typeid(::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >), sizeof(::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3686, ::Reflex::BaseOffset< ::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >, ::std::_Vector_base<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2525, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >::_Alloc_value_type"))
  .AddTypedef(type_3686, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >::_Base"))
  .AddTypedef(type_5041, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >::_Tp_alloc_type"))
  .AddTypedef(type_2525, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >::value_type"))
  .AddTypedef(type_18959, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >::pointer"))
  .AddTypedef(type_18961, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >::const_pointer"))
  .AddTypedef(type_18963, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >::reference"))
  .AddTypedef(type_18965, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >::const_reference"))
  .AddTypedef(type_17720, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >::iterator"))
  .AddTypedef(type_17721, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >::const_iterator"))
  .AddTypedef(type_5625, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >::const_reverse_iterator"))
  .AddTypedef(type_5626, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >::difference_type"))
  .AddTypedef(type_5041, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_18974, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70717), Reflex::Literal("vector"), constructor_18975, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_18965, type_70717), Reflex::Literal("vector"), constructor_18976, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70718), Reflex::Literal("vector"), constructor_18977, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_18978, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3307, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x244, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x245, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Photon, pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Photon, pat::Photon> > > -------------------
void __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Photon, pat::Photon>,std::allocator<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Photon, pat::Photon> > > -------------------
void __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70719, type_70718), Reflex::Literal("operator="), operator_18979, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_18965), Reflex::Literal("assign"), method_18980, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17720), Reflex::Literal("begin"), method_18981, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17721), Reflex::Literal("begin"), method_18982, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17720), Reflex::Literal("end"), method_18983, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17721), Reflex::Literal("end"), method_18984, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_18989, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_18990, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_2525), Reflex::Literal("resize"), method_18991, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_18992, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_18993, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_18994, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18963, type_5015), Reflex::Literal("operator[]"), operator_18995, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18965, type_5015), Reflex::Literal("operator[]"), operator_18996, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18963, type_5015), Reflex::Literal("at"), method_18998, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18965, type_5015), Reflex::Literal("at"), method_18999, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18963), Reflex::Literal("front"), method_19000, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18965), Reflex::Literal("front"), method_19001, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18963), Reflex::Literal("back"), method_19002, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18965), Reflex::Literal("back"), method_19003, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18959), Reflex::Literal("data"), method_19004, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18961), Reflex::Literal("data"), method_19005, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_18965), Reflex::Literal("push_back"), method_19006, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_19007, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17720, type_17720, type_18965), Reflex::Literal("insert"), method_19008, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_17720, type_5015, type_18965), Reflex::Literal("insert"), method_19009, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17720, type_17720), Reflex::Literal("erase"), method_19010, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17720, type_17720, type_17720), Reflex::Literal("erase"), method_19011, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_70719), Reflex::Literal("swap"), method_19012, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_19013, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<PATPairFinalStateT<pat::Tau, pat::Tau>,std::allocator<PATPairFinalStateT<pat::Tau, pat::Tau> > > -------------------------------
static void constructor_19158( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >();
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >();
}

static void constructor_19159( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >(*(const ::std::allocator<PATPairFinalStateT<pat::Tau,pat::Tau> >*)arg[0]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >(*(const ::std::allocator<PATPairFinalStateT<pat::Tau,pat::Tau> >*)arg[0]);
}

static void constructor_19160( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Tau,pat::Tau>*)arg[1]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Tau,pat::Tau>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Tau,pat::Tau>*)arg[1],
      *(const ::std::allocator<PATPairFinalStateT<pat::Tau,pat::Tau> >*)arg[2]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Tau,pat::Tau>*)arg[1],
      *(const ::std::allocator<PATPairFinalStateT<pat::Tau,pat::Tau> >*)arg[2]);
  }
}

static void constructor_19161( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >(*(const ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)arg[0]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >(*(const ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)arg[0]);
}

static void destructor_19162(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >::~vector)();
}
static  void operator_19163( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->operator=)(*(const ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)arg[0]);
  else   (((::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->operator=)(*(const ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)arg[0]);
}

static  void method_19164( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATPairFinalStateT<pat::Tau,pat::Tau>*)arg[1]);
}

static  void method_19165( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Tau,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >)((((::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->begin)());
  else   (((::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->begin)();
}

static  void method_19166( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Tau,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >)((((const ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->begin)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->begin)();
}

static  void method_19167( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Tau,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >)((((::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->end)());
  else   (((::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->end)();
}

static  void method_19168( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Tau,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >)((((const ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->end)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->end)();
}

static  void method_19173( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->size)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->size)();
}

static  void method_19174( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->max_size)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->max_size)();
}

static  void method_19175( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATPairFinalStateT<pat::Tau,pat::Tau>*)arg[1]);
  }
}

static  void method_19176( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->capacity)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->capacity)();
}

static  void method_19177( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->empty)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->empty)();
}

static  void method_19178( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_19179( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_19180( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_19182( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19183( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19184( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->front)();
  else   (((::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->front)();
}

static  void method_19185( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->front)();
  else   (((const ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->front)();
}

static  void method_19186( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->back)();
  else   (((::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->back)();
}

static  void method_19187( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->back)();
  else   (((const ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->back)();
}

static  void method_19188( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->data)());
  else   (((::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->data)();
}

static  void method_19189( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->data)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->data)();
}

static  void method_19190( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->push_back)(*(const ::PATPairFinalStateT<pat::Tau,pat::Tau>*)arg[0]);
}

static  void method_19191( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->pop_back)();
}

static  void method_19192( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Tau,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >)((((::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Tau,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >*)arg[0],
    *(const ::PATPairFinalStateT<pat::Tau,pat::Tau>*)arg[1]));
  else   (((::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Tau,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >*)arg[0],
    *(const ::PATPairFinalStateT<pat::Tau,pat::Tau>*)arg[1]);
}

static  void method_19193( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Tau,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATPairFinalStateT<pat::Tau,pat::Tau>*)arg[2]);
}

static  void method_19194( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Tau,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >)((((::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Tau,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >*)arg[0]));
  else   (((::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Tau,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >*)arg[0]);
}

static  void method_19195( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Tau,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >)((((::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Tau,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Tau,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >*)arg[1]));
  else   (((::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Tau,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Tau,pat::Tau>*,std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >*)arg[1]);
}

static  void method_19196( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->swap)(*(::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)arg[0]);
}

static  void method_19197( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->clear)();
}

static void method_newdel_3403( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x247( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATPairFinalStateT<pat::Tau,pat::Tau>,std::allocator<PATPairFinalStateT<pat::Tau,pat::Tau> > >")), ::Reflex::BaseOffset< ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >,::std::_Vector_base<PATPairFinalStateT<pat::Tau,pat::Tau>,std::allocator<PATPairFinalStateT<pat::Tau,pat::Tau> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x248( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >::Generate();
}

//------Dictionary for class vector<PATPairFinalStateT<pat::Tau, pat::Tau>,std::allocator<PATPairFinalStateT<pat::Tau, pat::Tau> > > -------------------------------
void __std__vector_PATPairFinalStateT_pat__Tau_pat__Tau_s__db_datamem(Reflex::Class*);
void __std__vector_PATPairFinalStateT_pat__Tau_pat__Tau_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATPairFinalStateT_pat__Tau_pat__Tau_s__datamem_bld(&__std__vector_PATPairFinalStateT_pat__Tau_pat__Tau_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATPairFinalStateT_pat__Tau_pat__Tau_s__funcmem_bld(&__std__vector_PATPairFinalStateT_pat__Tau_pat__Tau_s__db_funcmem);
void __std__vector_PATPairFinalStateT_pat__Tau_pat__Tau_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >"), typeid(::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >), sizeof(::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3724, ::Reflex::BaseOffset< ::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >, ::std::_Vector_base<PATPairFinalStateT<pat::Tau,pat::Tau>,std::allocator<PATPairFinalStateT<pat::Tau,pat::Tau> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_334, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >::_Alloc_value_type"))
  .AddTypedef(type_3724, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >::_Base"))
  .AddTypedef(type_5079, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >::_Tp_alloc_type"))
  .AddTypedef(type_334, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >::value_type"))
  .AddTypedef(type_19143, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >::pointer"))
  .AddTypedef(type_19145, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >::const_pointer"))
  .AddTypedef(type_19147, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >::reference"))
  .AddTypedef(type_19149, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >::const_reference"))
  .AddTypedef(type_17738, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >::iterator"))
  .AddTypedef(type_17739, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >::const_iterator"))
  .AddTypedef(type_5701, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >::const_reverse_iterator"))
  .AddTypedef(type_5702, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >::difference_type"))
  .AddTypedef(type_5079, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_19158, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70741), Reflex::Literal("vector"), constructor_19159, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_19149, type_70741), Reflex::Literal("vector"), constructor_19160, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_70742), Reflex::Literal("vector"), constructor_19161, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_19162, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3403, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x247, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x248, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATPairFinalStateT_pat__Tau_pat__Tau_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATPairFinalStateT<pat::Tau, pat::Tau>,std::allocator<PATPairFinalStateT<pat::Tau, pat::Tau> > > -------------------
void __std__vector_PATPairFinalStateT_pat__Tau_pat__Tau_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATPairFinalStateT<pat::Tau, pat::Tau>,std::allocator<PATPairFinalStateT<pat::Tau, pat::Tau> > > -------------------
void __std__vector_PATPairFinalStateT_pat__Tau_pat__Tau_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_70743, type_70742), Reflex::Literal("operator="), operator_19163, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_19149), Reflex::Literal("assign"), method_19164, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17738), Reflex::Literal("begin"), method_19165, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17739), Reflex::Literal("begin"), method_19166, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17738), Reflex::Literal("end"), method_19167, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17739), Reflex::Literal("end"), method_19168, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_19173, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_19174, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_334), Reflex::Literal("resize"), method_19175, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_19176, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_19177, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_19178, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19147, type_5015), Reflex::Literal("operator[]"), operator_19179, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19149, type_5015), Reflex::Literal("operator[]"), operator_19180, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19147, type_5015), Reflex::Literal("at"), method_19182, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19149, type_5015), Reflex::Literal("at"), method_19183, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19147), Reflex::Literal("front"), method_19184, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19149), Reflex::Literal("front"), method_19185, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19147), Reflex::Literal("back"), method_19186, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19149), Reflex::Literal("back"), method_19187, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19143), Reflex::Literal("data"), method_19188, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19145), Reflex::Literal("data"), method_19189, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_19149), Reflex::Literal("push_back"), method_19190, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_19191, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17738, type_17738, type_19149), Reflex::Literal("insert"), method_19192, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_17738, type_5015, type_19149), Reflex::Literal("insert"), method_19193, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17738, type_17738), Reflex::Literal("erase"), method_19194, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17738, type_17738, type_17738), Reflex::Literal("erase"), method_19195, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_70743), Reflex::Literal("swap"), method_19196, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_19197, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Photon> > > -------------------------------
static void constructor_19354( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >();
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >();
}

static void constructor_19355( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >(*(const ::std::allocator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >(*(const ::std::allocator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)arg[0]);
}

static void constructor_19356( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*)arg[1]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*)arg[1],
      *(const ::std::allocator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)arg[2]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*)arg[1],
      *(const ::std::allocator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)arg[2]);
  }
}

static void constructor_19357( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >(*(const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >(*(const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)arg[0]);
}

static void destructor_19358(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >::~vector)();
}
static  void operator_19359( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->operator=)(*(const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->operator=)(*(const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)arg[0]);
}

static  void method_19360( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*)arg[1]);
}

static  void method_19361( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->begin)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->begin)();
}

static  void method_19362( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->begin)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->begin)();
}

static  void method_19363( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->end)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->end)();
}

static  void method_19364( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->end)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->end)();
}

static  void method_19369( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->size)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->size)();
}

static  void method_19370( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->max_size)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->max_size)();
}

static  void method_19371( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*)arg[1]);
  }
}

static  void method_19372( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->capacity)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->capacity)();
}

static  void method_19373( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->empty)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->empty)();
}

static  void method_19374( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_19375( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_19376( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_19378( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19379( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19380( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->front)();
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->front)();
}

static  void method_19381( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->front)();
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->front)();
}

static  void method_19382( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->back)();
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->back)();
}

static  void method_19383( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->back)();
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->back)();
}

static  void method_19384( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->data)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->data)();
}

static  void method_19385( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->data)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->data)();
}

static  void method_19386( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->push_back)(*(const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*)arg[0]);
}

static  void method_19387( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->pop_back)();
}

static  void method_19388( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*)arg[1]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*)arg[1]);
}

static  void method_19389( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*)arg[2]);
}

static  void method_19390( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >*)arg[0]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >*)arg[0]);
}

static  void method_19391( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >*)arg[1]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >*)arg[1]);
}

static  void method_19392( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->swap)(*(::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)arg[0]);
}

static  void method_19393( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->clear)();
}

static void method_newdel_3510( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x250( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >")), ::Reflex::BaseOffset< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >,::std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x251( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >::Generate();
}

//------Dictionary for class vector<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Photon> > > -------------------------------
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s__db_datamem(Reflex::Class*);
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s__datamem_bld(&__std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s__funcmem_bld(&__std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s__db_funcmem);
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >"), typeid(::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >), sizeof(::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3713, ::Reflex::BaseOffset< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >, ::std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1520, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >::_Alloc_value_type"))
  .AddTypedef(type_3713, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >::_Base"))
  .AddTypedef(type_5068, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >::_Tp_alloc_type"))
  .AddTypedef(type_1520, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >::value_type"))
  .AddTypedef(type_19339, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >::pointer"))
  .AddTypedef(type_19341, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >::const_pointer"))
  .AddTypedef(type_19343, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >::reference"))
  .AddTypedef(type_19345, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >::const_reference"))
  .AddTypedef(type_17730, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >::iterator"))
  .AddTypedef(type_17731, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >::const_iterator"))
  .AddTypedef(type_5679, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >::const_reverse_iterator"))
  .AddTypedef(type_5680, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >::difference_type"))
  .AddTypedef(type_5068, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_19354, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72167), Reflex::Literal("vector"), constructor_19355, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_19345, type_72167), Reflex::Literal("vector"), constructor_19356, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72168), Reflex::Literal("vector"), constructor_19357, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_19358, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3510, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x250, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x251, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Photon> > > -------------------
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Photon>,std::allocator<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Photon> > > -------------------
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72169, type_72168), Reflex::Literal("operator="), operator_19359, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_19345), Reflex::Literal("assign"), method_19360, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17730), Reflex::Literal("begin"), method_19361, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17731), Reflex::Literal("begin"), method_19362, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17730), Reflex::Literal("end"), method_19363, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17731), Reflex::Literal("end"), method_19364, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_19369, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_19370, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_1520), Reflex::Literal("resize"), method_19371, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_19372, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_19373, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_19374, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19343, type_5015), Reflex::Literal("operator[]"), operator_19375, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19345, type_5015), Reflex::Literal("operator[]"), operator_19376, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19343, type_5015), Reflex::Literal("at"), method_19378, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19345, type_5015), Reflex::Literal("at"), method_19379, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19343), Reflex::Literal("front"), method_19380, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19345), Reflex::Literal("front"), method_19381, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19343), Reflex::Literal("back"), method_19382, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19345), Reflex::Literal("back"), method_19383, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19339), Reflex::Literal("data"), method_19384, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19341), Reflex::Literal("data"), method_19385, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_19345), Reflex::Literal("push_back"), method_19386, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_19387, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17730, type_17730, type_19345), Reflex::Literal("insert"), method_19388, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_17730, type_5015, type_19345), Reflex::Literal("insert"), method_19389, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17730, type_17730), Reflex::Literal("erase"), method_19390, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17730, type_17730, type_17730), Reflex::Literal("erase"), method_19391, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_72169), Reflex::Literal("swap"), method_19392, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_19393, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Tau> > > -------------------------------
static void constructor_19468( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >();
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >();
}

static void constructor_19469( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >(*(const ::std::allocator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >(*(const ::std::allocator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)arg[0]);
}

static void constructor_19470( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*)arg[1]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*)arg[1],
      *(const ::std::allocator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)arg[2]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*)arg[1],
      *(const ::std::allocator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)arg[2]);
  }
}

static void constructor_19471( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >(*(const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)arg[0]);
  else ::new(mem) ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >(*(const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)arg[0]);
}

static void destructor_19472(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >::~vector)();
}
static  void operator_19473( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->operator=)(*(const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->operator=)(*(const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)arg[0]);
}

static  void method_19474( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*)arg[1]);
}

static  void method_19475( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->begin)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->begin)();
}

static  void method_19476( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->begin)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->begin)();
}

static  void method_19477( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->end)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->end)();
}

static  void method_19478( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->end)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->end)();
}

static  void method_19483( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->size)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->size)();
}

static  void method_19484( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->max_size)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->max_size)();
}

static  void method_19485( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*)arg[1]);
  }
}

static  void method_19486( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->capacity)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->capacity)();
}

static  void method_19487( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->empty)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->empty)();
}

static  void method_19488( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_19489( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_19490( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_19492( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19493( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19494( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->front)();
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->front)();
}

static  void method_19495( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->front)();
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->front)();
}

static  void method_19496( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->back)();
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->back)();
}

static  void method_19497( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->back)();
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->back)();
}

static  void method_19498( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->data)());
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->data)();
}

static  void method_19499( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->data)());
  else   (((const ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->data)();
}

static  void method_19500( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->push_back)(*(const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*)arg[0]);
}

static  void method_19501( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->pop_back)();
}

static  void method_19502( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*)arg[1]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >*)arg[0],
    *(const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*)arg[1]);
}

static  void method_19503( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*)arg[2]);
}

static  void method_19504( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >*)arg[0]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >*)arg[0]);
}

static  void method_19505( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >)((((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >*)arg[1]));
  else   (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*,std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >*)arg[1]);
}

static  void method_19506( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->swap)(*(::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)arg[0]);
}

static  void method_19507( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->clear)();
}

static void method_newdel_3537( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x253( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >")), ::Reflex::BaseOffset< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >,::std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x254( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >::Generate();
}

//------Dictionary for class vector<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Tau> > > -------------------------------
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s__db_datamem(Reflex::Class*);
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s__datamem_bld(&__std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s__funcmem_bld(&__std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s__db_funcmem);
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >"), typeid(::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >), sizeof(::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3714, ::Reflex::BaseOffset< ::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >, ::std::_Vector_base<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1521, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >::_Alloc_value_type"))
  .AddTypedef(type_3714, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >::_Base"))
  .AddTypedef(type_5069, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >::_Tp_alloc_type"))
  .AddTypedef(type_1521, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >::value_type"))
  .AddTypedef(type_19453, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >::pointer"))
  .AddTypedef(type_19455, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >::const_pointer"))
  .AddTypedef(type_19457, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >::reference"))
  .AddTypedef(type_19459, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >::const_reference"))
  .AddTypedef(type_17732, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >::iterator"))
  .AddTypedef(type_17733, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >::const_iterator"))
  .AddTypedef(type_5681, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >::const_reverse_iterator"))
  .AddTypedef(type_5682, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >::difference_type"))
  .AddTypedef(type_5069, Reflex::Literal("std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_19468, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72177), Reflex::Literal("vector"), constructor_19469, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_19459, type_72177), Reflex::Literal("vector"), constructor_19470, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72178), Reflex::Literal("vector"), constructor_19471, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_19472, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3537, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x253, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x254, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Tau> > > -------------------
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Tau>,std::allocator<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Tau> > > -------------------
void __std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72179, type_72178), Reflex::Literal("operator="), operator_19473, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_19459), Reflex::Literal("assign"), method_19474, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17732), Reflex::Literal("begin"), method_19475, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17733), Reflex::Literal("begin"), method_19476, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17732), Reflex::Literal("end"), method_19477, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17733), Reflex::Literal("end"), method_19478, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_19483, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_19484, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_1521), Reflex::Literal("resize"), method_19485, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_19486, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_19487, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_19488, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19457, type_5015), Reflex::Literal("operator[]"), operator_19489, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19459, type_5015), Reflex::Literal("operator[]"), operator_19490, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19457, type_5015), Reflex::Literal("at"), method_19492, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19459, type_5015), Reflex::Literal("at"), method_19493, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19457), Reflex::Literal("front"), method_19494, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19459), Reflex::Literal("front"), method_19495, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19457), Reflex::Literal("back"), method_19496, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19459), Reflex::Literal("back"), method_19497, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19453), Reflex::Literal("data"), method_19498, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19455), Reflex::Literal("data"), method_19499, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_19459), Reflex::Literal("push_back"), method_19500, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_19501, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17732, type_17732, type_19459), Reflex::Literal("insert"), method_19502, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_17732, type_5015, type_19459), Reflex::Literal("insert"), method_19503, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17732, type_17732), Reflex::Literal("erase"), method_19504, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17732, type_17732, type_17732), Reflex::Literal("erase"), method_19505, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_72179), Reflex::Literal("swap"), method_19506, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_19507, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<PATPairFinalStateT<pat::Muon, pat::Photon>,std::allocator<PATPairFinalStateT<pat::Muon, pat::Photon> > > -------------------------------
static void constructor_19551( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >();
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >();
}

static void constructor_19552( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >(*(const ::std::allocator<PATPairFinalStateT<pat::Muon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >(*(const ::std::allocator<PATPairFinalStateT<pat::Muon,pat::Photon> >*)arg[0]);
}

static void constructor_19553( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Muon,pat::Photon>*)arg[1]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Muon,pat::Photon>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Muon,pat::Photon>*)arg[1],
      *(const ::std::allocator<PATPairFinalStateT<pat::Muon,pat::Photon> >*)arg[2]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >(*(::std::size_t*)arg[0],
      *(const ::PATPairFinalStateT<pat::Muon,pat::Photon>*)arg[1],
      *(const ::std::allocator<PATPairFinalStateT<pat::Muon,pat::Photon> >*)arg[2]);
  }
}

static void constructor_19554( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >(*(const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >(*(const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)arg[0]);
}

static void destructor_19555(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >::~vector)();
}
static  void operator_19556( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->operator=)(*(const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)arg[0]);
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->operator=)(*(const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)arg[0]);
}

static  void method_19557( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATPairFinalStateT<pat::Muon,pat::Photon>*)arg[1]);
}

static  void method_19558( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >)((((::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->begin)());
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->begin)();
}

static  void method_19559( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Muon,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >)((((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->begin)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->begin)();
}

static  void method_19560( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >)((((::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->end)());
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->end)();
}

static  void method_19561( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATPairFinalStateT<pat::Muon,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >)((((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->end)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->end)();
}

static  void method_19566( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->size)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->size)();
}

static  void method_19567( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->max_size)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->max_size)();
}

static  void method_19568( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATPairFinalStateT<pat::Muon,pat::Photon>*)arg[1]);
  }
}

static  void method_19569( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->capacity)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->capacity)();
}

static  void method_19570( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->empty)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->empty)();
}

static  void method_19571( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_19572( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_19573( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_19575( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19576( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19577( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->front)();
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->front)();
}

static  void method_19578( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->front)();
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->front)();
}

static  void method_19579( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->back)();
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->back)();
}

static  void method_19580( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->back)();
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->back)();
}

static  void method_19581( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->data)());
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->data)();
}

static  void method_19582( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->data)());
  else   (((const ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->data)();
}

static  void method_19583( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->push_back)(*(const ::PATPairFinalStateT<pat::Muon,pat::Photon>*)arg[0]);
}

static  void method_19584( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->pop_back)();
}

static  void method_19585( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >)((((::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >*)arg[0],
    *(const ::PATPairFinalStateT<pat::Muon,pat::Photon>*)arg[1]));
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >*)arg[0],
    *(const ::PATPairFinalStateT<pat::Muon,pat::Photon>*)arg[1]);
}

static  void method_19586( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATPairFinalStateT<pat::Muon,pat::Photon>*)arg[2]);
}

static  void method_19587( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >)((((::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >*)arg[0]));
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >*)arg[0]);
}

static  void method_19588( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >)((((::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >*)arg[1]));
  else   (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATPairFinalStateT<pat::Muon,pat::Photon>*,std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >*)arg[1]);
}

static  void method_19589( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->swap)(*(::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)arg[0]);
}

static  void method_19590( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->clear)();
}

static void method_newdel_3550( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x256( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATPairFinalStateT<pat::Muon,pat::Photon>,std::allocator<PATPairFinalStateT<pat::Muon,pat::Photon> > >")), ::Reflex::BaseOffset< ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >,::std::_Vector_base<PATPairFinalStateT<pat::Muon,pat::Photon>,std::allocator<PATPairFinalStateT<pat::Muon,pat::Photon> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x257( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >::Generate();
}

//------Dictionary for class vector<PATPairFinalStateT<pat::Muon, pat::Photon>,std::allocator<PATPairFinalStateT<pat::Muon, pat::Photon> > > -------------------------------
void __std__vector_PATPairFinalStateT_pat__Muon_pat__Photon_s__db_datamem(Reflex::Class*);
void __std__vector_PATPairFinalStateT_pat__Muon_pat__Photon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATPairFinalStateT_pat__Muon_pat__Photon_s__datamem_bld(&__std__vector_PATPairFinalStateT_pat__Muon_pat__Photon_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATPairFinalStateT_pat__Muon_pat__Photon_s__funcmem_bld(&__std__vector_PATPairFinalStateT_pat__Muon_pat__Photon_s__db_funcmem);
void __std__vector_PATPairFinalStateT_pat__Muon_pat__Photon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >"), typeid(::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >), sizeof(::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3725, ::Reflex::BaseOffset< ::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >, ::std::_Vector_base<PATPairFinalStateT<pat::Muon,pat::Photon>,std::allocator<PATPairFinalStateT<pat::Muon,pat::Photon> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1607, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >::_Alloc_value_type"))
  .AddTypedef(type_3725, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >::_Base"))
  .AddTypedef(type_5080, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >::_Tp_alloc_type"))
  .AddTypedef(type_1607, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >::value_type"))
  .AddTypedef(type_19536, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >::pointer"))
  .AddTypedef(type_19538, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >::const_pointer"))
  .AddTypedef(type_19540, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >::reference"))
  .AddTypedef(type_19542, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >::const_reference"))
  .AddTypedef(type_17740, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >::iterator"))
  .AddTypedef(type_17741, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >::const_iterator"))
  .AddTypedef(type_5703, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >::const_reverse_iterator"))
  .AddTypedef(type_5704, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >::difference_type"))
  .AddTypedef(type_5080, Reflex::Literal("std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_19551, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72184), Reflex::Literal("vector"), constructor_19552, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_19542, type_72184), Reflex::Literal("vector"), constructor_19553, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72185), Reflex::Literal("vector"), constructor_19554, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_19555, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3550, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x256, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x257, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATPairFinalStateT_pat__Muon_pat__Photon_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATPairFinalStateT<pat::Muon, pat::Photon>,std::allocator<PATPairFinalStateT<pat::Muon, pat::Photon> > > -------------------
void __std__vector_PATPairFinalStateT_pat__Muon_pat__Photon_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATPairFinalStateT<pat::Muon, pat::Photon>,std::allocator<PATPairFinalStateT<pat::Muon, pat::Photon> > > -------------------
void __std__vector_PATPairFinalStateT_pat__Muon_pat__Photon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72186, type_72185), Reflex::Literal("operator="), operator_19556, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_19542), Reflex::Literal("assign"), method_19557, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17740), Reflex::Literal("begin"), method_19558, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17741), Reflex::Literal("begin"), method_19559, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17740), Reflex::Literal("end"), method_19560, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17741), Reflex::Literal("end"), method_19561, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_19566, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_19567, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_1607), Reflex::Literal("resize"), method_19568, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_19569, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_19570, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_19571, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19540, type_5015), Reflex::Literal("operator[]"), operator_19572, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19542, type_5015), Reflex::Literal("operator[]"), operator_19573, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19540, type_5015), Reflex::Literal("at"), method_19575, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19542, type_5015), Reflex::Literal("at"), method_19576, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19540), Reflex::Literal("front"), method_19577, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19542), Reflex::Literal("front"), method_19578, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19540), Reflex::Literal("back"), method_19579, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19542), Reflex::Literal("back"), method_19580, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19536), Reflex::Literal("data"), method_19581, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19538), Reflex::Literal("data"), method_19582, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_19542), Reflex::Literal("push_back"), method_19583, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_19584, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17740, type_17740, type_19542), Reflex::Literal("insert"), method_19585, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_17740, type_5015, type_19542), Reflex::Literal("insert"), method_19586, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17740, type_17740), Reflex::Literal("erase"), method_19587, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17740, type_17740, type_17740), Reflex::Literal("erase"), method_19588, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_72186), Reflex::Literal("swap"), method_19589, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_19590, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Tau> > > -------------------------------
static void constructor_19804( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >();
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >();
}

static void constructor_19805( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >(*(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >(*(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)arg[0]);
}

static void constructor_19806( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*)arg[1]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*)arg[1],
      *(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)arg[2]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*)arg[1],
      *(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)arg[2]);
  }
}

static void constructor_19807( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)arg[0]);
}

static void destructor_19808(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >::~vector)();
}
static  void operator_19809( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->operator=)(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->operator=)(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)arg[0]);
}

static  void method_19810( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*)arg[1]);
}

static  void method_19811( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->begin)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->begin)();
}

static  void method_19812( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->begin)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->begin)();
}

static  void method_19813( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->end)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->end)();
}

static  void method_19814( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->end)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->end)();
}

static  void method_19819( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->size)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->size)();
}

static  void method_19820( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->max_size)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->max_size)();
}

static  void method_19821( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*)arg[1]);
  }
}

static  void method_19822( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->capacity)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->capacity)();
}

static  void method_19823( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->empty)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->empty)();
}

static  void method_19824( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_19825( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_19826( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_19828( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19829( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_19830( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->front)();
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->front)();
}

static  void method_19831( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->front)();
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->front)();
}

static  void method_19832( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->back)();
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->back)();
}

static  void method_19833( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->back)();
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->back)();
}

static  void method_19834( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->data)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->data)();
}

static  void method_19835( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->data)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->data)();
}

static  void method_19836( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->push_back)(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*)arg[0]);
}

static  void method_19837( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->pop_back)();
}

static  void method_19838( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*)arg[1]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*)arg[1]);
}

static  void method_19839( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*)arg[2]);
}

static  void method_19840( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >*)arg[0]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >*)arg[0]);
}

static  void method_19841( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >*)arg[1]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >*)arg[1]);
}

static  void method_19842( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->swap)(*(::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)arg[0]);
}

static  void method_19843( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->clear)();
}

static void method_newdel_3617( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x259( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >")), ::Reflex::BaseOffset< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >,::std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x260( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >::Generate();
}

//------Dictionary for class vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Tau> > > -------------------------------
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s__db_datamem(Reflex::Class*);
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s__datamem_bld(&__std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s__funcmem_bld(&__std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s__db_funcmem);
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >"), typeid(::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >), sizeof(::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3702, ::Reflex::BaseOffset< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >, ::std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2562, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >::_Alloc_value_type"))
  .AddTypedef(type_3702, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >::_Base"))
  .AddTypedef(type_5057, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >::_Tp_alloc_type"))
  .AddTypedef(type_2562, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >::value_type"))
  .AddTypedef(type_19789, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >::pointer"))
  .AddTypedef(type_19791, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >::const_pointer"))
  .AddTypedef(type_19793, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >::reference"))
  .AddTypedef(type_19795, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >::const_reference"))
  .AddTypedef(type_17724, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >::iterator"))
  .AddTypedef(type_17725, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >::const_iterator"))
  .AddTypedef(type_5657, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >::const_reverse_iterator"))
  .AddTypedef(type_5658, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >::difference_type"))
  .AddTypedef(type_5057, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_19804, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72441), Reflex::Literal("vector"), constructor_19805, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_19795, type_72441), Reflex::Literal("vector"), constructor_19806, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72442), Reflex::Literal("vector"), constructor_19807, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_19808, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3617, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x259, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x260, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Tau> > > -------------------
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Tau>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Tau> > > -------------------
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72443, type_72442), Reflex::Literal("operator="), operator_19809, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_19795), Reflex::Literal("assign"), method_19810, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17724), Reflex::Literal("begin"), method_19811, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17725), Reflex::Literal("begin"), method_19812, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17724), Reflex::Literal("end"), method_19813, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17725), Reflex::Literal("end"), method_19814, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_19819, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_19820, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_2562), Reflex::Literal("resize"), method_19821, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_19822, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_19823, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_19824, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19793, type_5015), Reflex::Literal("operator[]"), operator_19825, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19795, type_5015), Reflex::Literal("operator[]"), operator_19826, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19793, type_5015), Reflex::Literal("at"), method_19828, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19795, type_5015), Reflex::Literal("at"), method_19829, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19793), Reflex::Literal("front"), method_19830, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19795), Reflex::Literal("front"), method_19831, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19793), Reflex::Literal("back"), method_19832, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19795), Reflex::Literal("back"), method_19833, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19789), Reflex::Literal("data"), method_19834, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19791), Reflex::Literal("data"), method_19835, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_19795), Reflex::Literal("push_back"), method_19836, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_19837, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17724, type_17724, type_19795), Reflex::Literal("insert"), method_19838, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_17724, type_5015, type_19795), Reflex::Literal("insert"), method_19839, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17724, type_17724), Reflex::Literal("erase"), method_19840, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17724, type_17724, type_17724), Reflex::Literal("erase"), method_19841, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_72443), Reflex::Literal("swap"), method_19842, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_19843, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Muon>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Muon> > > -------------------------------
static void constructor_20136( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >();
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >();
}

static void constructor_20137( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >(*(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >(*(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)arg[0]);
}

static void constructor_20138( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*)arg[1]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*)arg[1],
      *(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)arg[2]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >(*(::std::size_t*)arg[0],
      *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*)arg[1],
      *(const ::std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)arg[2]);
  }
}

static void constructor_20139( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)arg[0]);
  else ::new(mem) ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)arg[0]);
}

static void destructor_20140(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >::~vector)();
}
static  void operator_20141( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->operator=)(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->operator=)(*(const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)arg[0]);
}

static  void method_20142( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*)arg[1]);
}

static  void method_20143( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->begin)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->begin)();
}

static  void method_20144( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->begin)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->begin)();
}

static  void method_20145( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->end)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->end)();
}

static  void method_20146( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->end)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->end)();
}

static  void method_20151( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->size)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->size)();
}

static  void method_20152( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->max_size)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->max_size)();
}

static  void method_20153( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*)arg[1]);
  }
}

static  void method_20154( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->capacity)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->capacity)();
}

static  void method_20155( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->empty)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->empty)();
}

static  void method_20156( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_20157( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_20158( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_20160( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_20161( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_20162( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->front)();
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->front)();
}

static  void method_20163( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->front)();
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->front)();
}

static  void method_20164( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->back)();
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->back)();
}

static  void method_20165( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->back)();
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->back)();
}

static  void method_20166( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->data)());
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->data)();
}

static  void method_20167( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->data)());
  else   (((const ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->data)();
}

static  void method_20168( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->push_back)(*(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*)arg[0]);
}

static  void method_20169( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->pop_back)();
}

static  void method_20170( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*)arg[1]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >*)arg[0],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*)arg[1]);
}

static  void method_20171( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*)arg[2]);
}

static  void method_20172( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >*)arg[0]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >*)arg[0]);
}

static  void method_20173( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >)((((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >*)arg[1]));
  else   (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*,std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >*)arg[1]);
}

static  void method_20174( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->swap)(*(::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)arg[0]);
}

static  void method_20175( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->clear)();
}

static void method_newdel_3645( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x262( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >")), ::Reflex::BaseOffset< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >,::std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x263( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >::Generate();
}

//------Dictionary for class vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Muon>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Muon> > > -------------------------------
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s__db_datamem(Reflex::Class*);
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s__datamem_bld(&__std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s__funcmem_bld(&__std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s__db_funcmem);
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >"), typeid(::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >), sizeof(::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_3703, ::Reflex::BaseOffset< ::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >, ::std::_Vector_base<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>,std::allocator<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2811, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >::_Alloc_value_type"))
  .AddTypedef(type_3703, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >::_Base"))
  .AddTypedef(type_5058, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >::_Tp_alloc_type"))
  .AddTypedef(type_2811, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >::value_type"))
  .AddTypedef(type_20121, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >::pointer"))
  .AddTypedef(type_20123, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >::const_pointer"))
  .AddTypedef(type_20125, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >::reference"))
  .AddTypedef(type_20127, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >::const_reference"))
  .AddTypedef(type_17726, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >::iterator"))
  .AddTypedef(type_17727, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >::const_iterator"))
  .AddTypedef(type_5659, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >::const_reverse_iterator"))
  .AddTypedef(type_5660, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >::reverse_iterator"))
  .AddTypedef(type_5015, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >::size_type"))
  .AddTypedef(type_4878, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >::difference_type"))
  .AddTypedef(type_5058, Reflex::Literal("std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_20136, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72486), Reflex::Literal("vector"), constructor_20137, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5015, type_20127, type_72486), Reflex::Literal("vector"), constructor_20138, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_72487), Reflex::Literal("vector"), constructor_20139, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_20140, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3645, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x262, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x263, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s__funcmem_bld);
}

//------Delayed data member builder for class vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Muon>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Muon> > > -------------------
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Muon>,std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Muon> > > -------------------
void __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72488, type_72487), Reflex::Literal("operator="), operator_20141, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_20127), Reflex::Literal("assign"), method_20142, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17726), Reflex::Literal("begin"), method_20143, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17727), Reflex::Literal("begin"), method_20144, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17726), Reflex::Literal("end"), method_20145, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17727), Reflex::Literal("end"), method_20146, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_20151, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("max_size"), method_20152, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015, type_2811), Reflex::Literal("resize"), method_20153, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_20154, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_20155, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_20156, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20125, type_5015), Reflex::Literal("operator[]"), operator_20157, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20127, type_5015), Reflex::Literal("operator[]"), operator_20158, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20125, type_5015), Reflex::Literal("at"), method_20160, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20127, type_5015), Reflex::Literal("at"), method_20161, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20125), Reflex::Literal("front"), method_20162, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20127), Reflex::Literal("front"), method_20163, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20125), Reflex::Literal("back"), method_20164, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20127), Reflex::Literal("back"), method_20165, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20121), Reflex::Literal("data"), method_20166, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20123), Reflex::Literal("data"), method_20167, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_20127), Reflex::Literal("push_back"), method_20168, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("pop_back"), method_20169, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17726, type_17726, type_20127), Reflex::Literal("insert"), method_20170, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_17726, type_5015, type_20127), Reflex::Literal("insert"), method_20171, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17726, type_17726), Reflex::Literal("erase"), method_20172, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17726, type_17726, type_17726), Reflex::Literal("erase"), method_20173, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_72488), Reflex::Literal("swap"), method_20174, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_20175, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class RefProd<std::vector<PATFinalStateEvent, std::allocator<PATFinalStateEvent> > > -------------------------------
static  void operator_6211( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefProd<std::vector<PATFinalStateEvent> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<PATFinalStateEvent> >*)arg[0]);
  else   (((::edm::RefProd<std::vector<PATFinalStateEvent> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<PATFinalStateEvent> >*)arg[0]);
}

static void constructor_6212( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<PATFinalStateEvent> >(*(const ::edm::RefProd<std::vector<PATFinalStateEvent> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<PATFinalStateEvent> >(*(const ::edm::RefProd<std::vector<PATFinalStateEvent> >*)arg[0]);
}

static void constructor_6213( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<PATFinalStateEvent> >();
  else ::new(mem) ::edm::RefProd<std::vector<PATFinalStateEvent> >();
}

static void constructor_6214( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<PATFinalStateEvent> >(*(const ::edm::Handle<std::vector<PATFinalStateEvent> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<PATFinalStateEvent> >(*(const ::edm::Handle<std::vector<PATFinalStateEvent> >*)arg[0]);
}

static void constructor_6215( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<PATFinalStateEvent> >(*(const ::edm::OrphanHandle<std::vector<PATFinalStateEvent> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<PATFinalStateEvent> >(*(const ::edm::OrphanHandle<std::vector<PATFinalStateEvent> >*)arg[0]);
}

static void constructor_6216( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<PATFinalStateEvent> >((const ::std::vector<PATFinalStateEvent>*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<PATFinalStateEvent> >((const ::std::vector<PATFinalStateEvent>*)arg[0]);
}

static void constructor_6217( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<PATFinalStateEvent> >(*(const ::edm::TestHandle<std::vector<PATFinalStateEvent> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<PATFinalStateEvent> >(*(const ::edm::TestHandle<std::vector<PATFinalStateEvent> >*)arg[0]);
}

static void constructor_6218( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<PATFinalStateEvent> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
  else ::new(mem) ::edm::RefProd<std::vector<PATFinalStateEvent> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
}

static void destructor_6219(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefProd<std::vector<PATFinalStateEvent> >*)o)->::edm::RefProd<std::vector<PATFinalStateEvent> >::~RefProd)();
}
static  void operator_6220( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<PATFinalStateEvent> >*)o)->operator*)();
  else   (((const ::edm::RefProd<std::vector<PATFinalStateEvent> >*)o)->operator*)();
}

static  void operator_6221( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<PATFinalStateEvent> >*)o)->operator->)());
  else   (((const ::edm::RefProd<std::vector<PATFinalStateEvent> >*)o)->operator->)();
}

static  void method_6222( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<PATFinalStateEvent> >*)o)->get)());
  else   (((const ::edm::RefProd<std::vector<PATFinalStateEvent> >*)o)->get)();
}

static  void method_6223( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<PATFinalStateEvent> >*)o)->product)());
  else   (((const ::edm::RefProd<std::vector<PATFinalStateEvent> >*)o)->product)();
}

static  void method_6224( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<PATFinalStateEvent> >*)o)->refCore)();
  else   (((const ::edm::RefProd<std::vector<PATFinalStateEvent> >*)o)->refCore)();
}

static  void method_6225( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<PATFinalStateEvent> >*)o)->isNull)());
  else   (((const ::edm::RefProd<std::vector<PATFinalStateEvent> >*)o)->isNull)();
}

static  void method_6226( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<PATFinalStateEvent> >*)o)->isNonnull)());
  else   (((const ::edm::RefProd<std::vector<PATFinalStateEvent> >*)o)->isNonnull)();
}

static  void operator_6227( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<PATFinalStateEvent> >*)o)->operator!)());
  else   (((const ::edm::RefProd<std::vector<PATFinalStateEvent> >*)o)->operator!)();
}

static  void method_6228( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefProd<std::vector<PATFinalStateEvent> >*)o)->id)());
  else   (((const ::edm::RefProd<std::vector<PATFinalStateEvent> >*)o)->id)();
}

static  void method_6229( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<PATFinalStateEvent> >*)o)->productGetter)());
  else   (((const ::edm::RefProd<std::vector<PATFinalStateEvent> >*)o)->productGetter)();
}

static  void method_6230( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<PATFinalStateEvent> >*)o)->hasCache)());
  else   (((const ::edm::RefProd<std::vector<PATFinalStateEvent> >*)o)->hasCache)();
}

static  void method_6231( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<PATFinalStateEvent> >*)o)->hasProductCache)());
  else   (((const ::edm::RefProd<std::vector<PATFinalStateEvent> >*)o)->hasProductCache)();
}

static  void method_6232( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<PATFinalStateEvent> >*)o)->isAvailable)());
  else   (((const ::edm::RefProd<std::vector<PATFinalStateEvent> >*)o)->isAvailable)();
}

static  void method_6233( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<PATFinalStateEvent> >*)o)->isTransient)());
  else   (((const ::edm::RefProd<std::vector<PATFinalStateEvent> >*)o)->isTransient)();
}

static  void method_6234( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefProd<std::vector<PATFinalStateEvent> >*)o)->swap)(*(::edm::RefProd<std::vector<PATFinalStateEvent> >*)arg[0]);
}

static  void method_6235( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefProd<std::vector<PATFinalStateEvent> >*)o)->Class_Version)());
  else   (((::edm::RefProd<std::vector<PATFinalStateEvent> >*)o)->Class_Version)();
}

static void method_newdel_80( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<PATFinalStateEvent> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<PATFinalStateEvent> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<PATFinalStateEvent> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<PATFinalStateEvent> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<PATFinalStateEvent> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefProd<std::vector<PATFinalStateEvent, std::allocator<PATFinalStateEvent> > > -------------------------------
void __edm__RefProd_std__vector_PATFinalStateEvent_s__db_datamem(Reflex::Class*);
void __edm__RefProd_std__vector_PATFinalStateEvent_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_PATFinalStateEvent_s__datamem_bld(&__edm__RefProd_std__vector_PATFinalStateEvent_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_PATFinalStateEvent_s__funcmem_bld(&__edm__RefProd_std__vector_PATFinalStateEvent_s__db_funcmem);
void __edm__RefProd_std__vector_PATFinalStateEvent_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefProd<std::vector<PATFinalStateEvent> >"), typeid(::edm::RefProd<std::vector<PATFinalStateEvent> >), sizeof(::edm::RefProd<std::vector<PATFinalStateEvent> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefProd<std::vector<PATFinalStateEvent> >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::RefProd<PATFinalStateEventCollection>")
  .AddTypedef(type_480, Reflex::Literal("edm::RefProd<std::vector<PATFinalStateEvent> >::product_type"))
  .AddTypedef(type_480, Reflex::Literal("edm::RefProd<std::vector<PATFinalStateEvent> >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45411, type_45412), Reflex::Literal("operator="), operator_6211, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45412), Reflex::Literal("RefProd"), constructor_6212, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefProd"), constructor_6213, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45413), Reflex::Literal("RefProd"), constructor_6214, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45414), Reflex::Literal("RefProd"), constructor_6215, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45415), Reflex::Literal("RefProd"), constructor_6216, 0, "iProduct", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45416), Reflex::Literal("RefProd"), constructor_6217, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417, type_45418), Reflex::Literal("RefProd"), constructor_6218, 0, "productID;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefProd"), destructor_6219, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_80, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefProd_std__vector_PATFinalStateEvent_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefProd_std__vector_PATFinalStateEvent_s__funcmem_bld);
}

//------Delayed data member builder for class RefProd<std::vector<PATFinalStateEvent, std::allocator<PATFinalStateEvent> > > -------------------
void __edm__RefProd_std__vector_PATFinalStateEvent_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9667, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefProd_std__vector_PATFinalStateEvent_s_, product_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefProd<std::vector<PATFinalStateEvent, std::allocator<PATFinalStateEvent> > > -------------------
void __edm__RefProd_std__vector_PATFinalStateEvent_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45419), Reflex::Literal("operator*"), operator_6220, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45415), Reflex::Literal("operator->"), operator_6221, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45415), Reflex::Literal("get"), method_6222, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45415), Reflex::Literal("product"), method_6223, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45420), Reflex::Literal("refCore"), method_6224, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNull"), method_6225, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNonnull"), method_6226, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("operator!"), operator_6227, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9664), Reflex::Literal("id"), method_6228, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45418), Reflex::Literal("productGetter"), method_6229, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("hasCache"), method_6230, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("hasProductCache"), method_6231, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isAvailable"), method_6232, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isTransient"), method_6233, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45411), Reflex::Literal("swap"), method_6234, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_251), Reflex::Literal("Class_Version"), method_6235, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefVector<std::vector<PATFinalStateEvent, std::allocator<PATFinalStateEvent> >,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent, std::allocator<PATFinalStateEvent> >, PATFinalStateEvent> > -------------------------------
static void destructor_6437(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >::~RefVector)();
}
static void constructor_6438( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >();
  else ::new(mem) ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >();
}

static void constructor_6439( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >(*(const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >(*(const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)arg[0]);
}

static void constructor_6440( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >(*(const ::edm::ProductID*)arg[0]);
}

static  void method_6441( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->push_back)(*(const ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)arg[0]);
}

static  void operator_6442( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >)((((const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_6443( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >)((((const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6444( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->refVector)();
  else   (((const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->refVector)();
}

static  void method_6445( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->empty)());
  else   (((const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->empty)();
}

static  void method_6446( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->size)());
  else   (((const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->size)();
}

static  void method_6447( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->capacity)());
  else   (((const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->capacity)();
}

static  void method_6448( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_6449( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >)((((const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->begin)());
  else   (((const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->begin)();
}

static  void method_6450( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >)((((const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->end)());
  else   (((const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->end)();
}

static  void method_6451( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->id)());
  else   (((const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->id)();
}

static  void method_6452( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->productGetter)());
  else   (((const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->productGetter)();
}

static  void method_6453( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->isNull)());
  else   (((const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->isNull)();
}

static  void method_6454( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->isNonnull)());
  else   (((const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->isNonnull)();
}

static  void operator_6455( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->operator!)());
  else   (((const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->operator!)();
}

static  void method_6456( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->product)());
  else   (((const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->product)();
}

static  void method_6457( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->isAvailable)());
  else   (((const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->isAvailable)();
}

static  void method_6458( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->isTransient)());
  else   (((const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->isTransient)();
}

static  void method_6459( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >)((((::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)arg[0]));
  else   (((::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)arg[0]);
}

static  void method_6460( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->clear)();
}

static  void method_6461( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->swap)(*(::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)arg[0]);
}

static  void operator_6462( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)arg[0]);
  else   (((::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)arg[0]);
}

static  void method_6463( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->hasProductCache)());
  else   (((const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->hasProductCache)();
}

static  void method_6464( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_6465( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->Class_Version)());
  else   (((::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->Class_Version)();
}

static void method_newdel_96( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefVector<std::vector<PATFinalStateEvent, std::allocator<PATFinalStateEvent> >,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent, std::allocator<PATFinalStateEvent> >, PATFinalStateEvent> > -------------------------------
void __edm__RefVector_std__vector_PATFinalStateEvent__PATFinalStateEvent_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateEvent__PATFinalStateEvent_s__db_datamem(Reflex::Class*);
void __edm__RefVector_std__vector_PATFinalStateEvent__PATFinalStateEvent_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateEvent__PATFinalStateEvent_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_PATFinalStateEvent__PATFinalStateEvent_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateEvent__PATFinalStateEvent_s__datamem_bld(&__edm__RefVector_std__vector_PATFinalStateEvent__PATFinalStateEvent_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateEvent__PATFinalStateEvent_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_PATFinalStateEvent__PATFinalStateEvent_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateEvent__PATFinalStateEvent_s__funcmem_bld(&__edm__RefVector_std__vector_PATFinalStateEvent__PATFinalStateEvent_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateEvent__PATFinalStateEvent_s__db_funcmem);
void __edm__RefVector_std__vector_PATFinalStateEvent__PATFinalStateEvent_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateEvent__PATFinalStateEvent_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >"), typeid(::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >), sizeof(::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::RefVector<PATFinalStateEventCollection,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<PATFinalStateEventCollection,PATFinalStateEvent> >")
  .AddTypedef(type_480, Reflex::Literal("edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >::collection_type"))
  .AddTypedef(type_583, Reflex::Literal("edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >::member_type"))
  .AddTypedef(type_6424, Reflex::Literal("edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >::finder_type"))
  .AddTypedef(type_6426, Reflex::Literal("edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >::iterator"))
  .AddTypedef(type_6426, Reflex::Literal("edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >::const_iterator"))
  .AddTypedef(type_3065, Reflex::Literal("edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >::value_type"))
  .AddTypedef(type_3065c, Reflex::Literal("edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >::const_reference"))
  .AddTypedef(type_3065c, Reflex::Literal("edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >::reference"))
  .AddTypedef(type_497, Reflex::Literal("edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >::key_type"))
  .AddTypedef(type_4591, Reflex::Literal("edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >::KeyVec"))
  .AddTypedef(type_5015, Reflex::Literal("edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >::size_type"))
  .AddTypedef(type_6435, Reflex::Literal("edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >::contents_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVector"), destructor_6437, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVector"), constructor_6438, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45456), Reflex::Literal("RefVector"), constructor_6439, 0, "rh", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417), Reflex::Literal("RefVector"), constructor_6440, 0, "iId", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_96, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVector_std__vector_PATFinalStateEvent__PATFinalStateEvent_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateEvent__PATFinalStateEvent_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVector_std__vector_PATFinalStateEvent__PATFinalStateEvent_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateEvent__PATFinalStateEvent_s__funcmem_bld);
}

//------Delayed data member builder for class RefVector<std::vector<PATFinalStateEvent, std::allocator<PATFinalStateEvent> >,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent, std::allocator<PATFinalStateEvent> >, PATFinalStateEvent> > -------------------
void __edm__RefVector_std__vector_PATFinalStateEvent__PATFinalStateEvent_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateEvent__PATFinalStateEvent_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_6435, Reflex::Literal("refVector_"), OffsetOf(__shadow__::__edm__RefVector_std__vector_PATFinalStateEvent__PATFinalStateEvent_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateEvent__PATFinalStateEvent_s_, refVector_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVector<std::vector<PATFinalStateEvent, std::allocator<PATFinalStateEvent> >,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent, std::allocator<PATFinalStateEvent> >, PATFinalStateEvent> > -------------------
void __edm__RefVector_std__vector_PATFinalStateEvent__PATFinalStateEvent_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateEvent__PATFinalStateEvent_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45457), Reflex::Literal("push_back"), method_6441, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3065c, type_5015), Reflex::Literal("operator[]"), operator_6442, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3065c, type_5015), Reflex::Literal("at"), method_6443, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45458), Reflex::Literal("refVector"), method_6444, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_6445, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_6446, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_6447, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_6448, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6426), Reflex::Literal("begin"), method_6449, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6426), Reflex::Literal("end"), method_6450, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9664), Reflex::Literal("id"), method_6451, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45418), Reflex::Literal("productGetter"), method_6452, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNull"), method_6453, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNonnull"), method_6454, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("operator!"), operator_6455, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45415), Reflex::Literal("product"), method_6456, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isAvailable"), method_6457, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isTransient"), method_6458, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6426, type_45459), Reflex::Literal("erase"), method_6459, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_6460, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45460), Reflex::Literal("swap"), method_6461, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45460, type_45456), Reflex::Literal("operator="), operator_6462, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("hasProductCache"), method_6463, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_45462), Reflex::Literal("fillView"), method_6464, 0, ";pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_251), Reflex::Literal("Class_Version"), method_6465, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefProd<edm::OwnVector<PATFinalState, edm::ClonePolicy<PATFinalState> > > -------------------------------
static  void operator_6849( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->operator=)(*(const ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)arg[0]);
  else   (((::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->operator=)(*(const ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)arg[0]);
}

static void constructor_6850( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >(*(const ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)arg[0]);
  else ::new(mem) ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >(*(const ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)arg[0]);
}

static void constructor_6851( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >();
  else ::new(mem) ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >();
}

static void constructor_6852( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >(*(const ::edm::Handle<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)arg[0]);
  else ::new(mem) ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >(*(const ::edm::Handle<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)arg[0]);
}

static void constructor_6853( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >(*(const ::edm::OrphanHandle<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)arg[0]);
  else ::new(mem) ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >(*(const ::edm::OrphanHandle<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)arg[0]);
}

static void constructor_6854( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >((const ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >((const ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)arg[0]);
}

static void constructor_6855( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >(*(const ::edm::TestHandle<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)arg[0]);
  else ::new(mem) ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >(*(const ::edm::TestHandle<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)arg[0]);
}

static void constructor_6856( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
  else ::new(mem) ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
}

static void destructor_6857(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >::~RefProd)();
}
static  void operator_6858( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->operator*)();
  else   (((const ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->operator*)();
}

static  void operator_6859( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->operator->)());
  else   (((const ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->operator->)();
}

static  void method_6860( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->get)());
  else   (((const ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->get)();
}

static  void method_6861( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->product)());
  else   (((const ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->product)();
}

static  void method_6862( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->refCore)();
  else   (((const ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->refCore)();
}

static  void method_6863( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->isNull)());
  else   (((const ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->isNull)();
}

static  void method_6864( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->isNonnull)());
  else   (((const ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->isNonnull)();
}

static  void operator_6865( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->operator!)());
  else   (((const ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->operator!)();
}

static  void method_6866( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->id)());
  else   (((const ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->id)();
}

static  void method_6867( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->productGetter)());
  else   (((const ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->productGetter)();
}

static  void method_6868( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->hasCache)());
  else   (((const ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->hasCache)();
}

static  void method_6869( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->hasProductCache)());
  else   (((const ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->hasProductCache)();
}

static  void method_6870( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->isAvailable)());
  else   (((const ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->isAvailable)();
}

static  void method_6871( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->isTransient)());
  else   (((const ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->isTransient)();
}

static  void method_6872( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->swap)(*(::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)arg[0]);
}

static  void method_6873( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->Class_Version)());
  else   (((::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->Class_Version)();
}

static void method_newdel_229( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefProd<edm::OwnVector<PATFinalState, edm::ClonePolicy<PATFinalState> > > -------------------------------
void __edm__RefProd_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s_s__db_datamem(Reflex::Class*);
void __edm__RefProd_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefProd_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s_s__datamem_bld(&__edm__RefProd_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefProd_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s_s__funcmem_bld(&__edm__RefProd_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s_s__db_funcmem);
void __edm__RefProd_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >"), typeid(::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >), sizeof(::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::RefProd<PATFinalStateCollection>")
  .AddTypedef(type_951, Reflex::Literal("edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >::product_type"))
  .AddTypedef(type_951, Reflex::Literal("edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45902, type_45903), Reflex::Literal("operator="), operator_6849, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45903), Reflex::Literal("RefProd"), constructor_6850, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefProd"), constructor_6851, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45904), Reflex::Literal("RefProd"), constructor_6852, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45905), Reflex::Literal("RefProd"), constructor_6853, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45906), Reflex::Literal("RefProd"), constructor_6854, 0, "iProduct", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45907), Reflex::Literal("RefProd"), constructor_6855, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417, type_45418), Reflex::Literal("RefProd"), constructor_6856, 0, "productID;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefProd"), destructor_6857, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_229, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefProd_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefProd_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s_s__funcmem_bld);
}

//------Delayed data member builder for class RefProd<edm::OwnVector<PATFinalState, edm::ClonePolicy<PATFinalState> > > -------------------
void __edm__RefProd_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9667, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefProd_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s_s_, product_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefProd<edm::OwnVector<PATFinalState, edm::ClonePolicy<PATFinalState> > > -------------------
void __edm__RefProd_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45908), Reflex::Literal("operator*"), operator_6858, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45906), Reflex::Literal("operator->"), operator_6859, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45906), Reflex::Literal("get"), method_6860, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45906), Reflex::Literal("product"), method_6861, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45420), Reflex::Literal("refCore"), method_6862, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNull"), method_6863, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNonnull"), method_6864, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("operator!"), operator_6865, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9664), Reflex::Literal("id"), method_6866, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45418), Reflex::Literal("productGetter"), method_6867, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("hasCache"), method_6868, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("hasProductCache"), method_6869, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isAvailable"), method_6870, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isTransient"), method_6871, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45902), Reflex::Literal("swap"), method_6872, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_251), Reflex::Literal("Class_Version"), method_6873, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefProd<std::vector<PATFinalStateLS, std::allocator<PATFinalStateLS> > > -------------------------------
static  void operator_6997( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefProd<std::vector<PATFinalStateLS> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<PATFinalStateLS> >*)arg[0]);
  else   (((::edm::RefProd<std::vector<PATFinalStateLS> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<PATFinalStateLS> >*)arg[0]);
}

static void constructor_6998( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<PATFinalStateLS> >(*(const ::edm::RefProd<std::vector<PATFinalStateLS> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<PATFinalStateLS> >(*(const ::edm::RefProd<std::vector<PATFinalStateLS> >*)arg[0]);
}

static void constructor_6999( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<PATFinalStateLS> >();
  else ::new(mem) ::edm::RefProd<std::vector<PATFinalStateLS> >();
}

static void constructor_7000( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<PATFinalStateLS> >(*(const ::edm::Handle<std::vector<PATFinalStateLS> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<PATFinalStateLS> >(*(const ::edm::Handle<std::vector<PATFinalStateLS> >*)arg[0]);
}

static void constructor_7001( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<PATFinalStateLS> >(*(const ::edm::OrphanHandle<std::vector<PATFinalStateLS> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<PATFinalStateLS> >(*(const ::edm::OrphanHandle<std::vector<PATFinalStateLS> >*)arg[0]);
}

static void constructor_7002( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<PATFinalStateLS> >((const ::std::vector<PATFinalStateLS>*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<PATFinalStateLS> >((const ::std::vector<PATFinalStateLS>*)arg[0]);
}

static void constructor_7003( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<PATFinalStateLS> >(*(const ::edm::TestHandle<std::vector<PATFinalStateLS> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<PATFinalStateLS> >(*(const ::edm::TestHandle<std::vector<PATFinalStateLS> >*)arg[0]);
}

static void constructor_7004( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<PATFinalStateLS> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
  else ::new(mem) ::edm::RefProd<std::vector<PATFinalStateLS> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
}

static void destructor_7005(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefProd<std::vector<PATFinalStateLS> >*)o)->::edm::RefProd<std::vector<PATFinalStateLS> >::~RefProd)();
}
static  void operator_7006( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<PATFinalStateLS> >*)o)->operator*)();
  else   (((const ::edm::RefProd<std::vector<PATFinalStateLS> >*)o)->operator*)();
}

static  void operator_7007( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<PATFinalStateLS> >*)o)->operator->)());
  else   (((const ::edm::RefProd<std::vector<PATFinalStateLS> >*)o)->operator->)();
}

static  void method_7008( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<PATFinalStateLS> >*)o)->get)());
  else   (((const ::edm::RefProd<std::vector<PATFinalStateLS> >*)o)->get)();
}

static  void method_7009( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<PATFinalStateLS> >*)o)->product)());
  else   (((const ::edm::RefProd<std::vector<PATFinalStateLS> >*)o)->product)();
}

static  void method_7010( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<PATFinalStateLS> >*)o)->refCore)();
  else   (((const ::edm::RefProd<std::vector<PATFinalStateLS> >*)o)->refCore)();
}

static  void method_7011( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<PATFinalStateLS> >*)o)->isNull)());
  else   (((const ::edm::RefProd<std::vector<PATFinalStateLS> >*)o)->isNull)();
}

static  void method_7012( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<PATFinalStateLS> >*)o)->isNonnull)());
  else   (((const ::edm::RefProd<std::vector<PATFinalStateLS> >*)o)->isNonnull)();
}

static  void operator_7013( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<PATFinalStateLS> >*)o)->operator!)());
  else   (((const ::edm::RefProd<std::vector<PATFinalStateLS> >*)o)->operator!)();
}

static  void method_7014( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefProd<std::vector<PATFinalStateLS> >*)o)->id)());
  else   (((const ::edm::RefProd<std::vector<PATFinalStateLS> >*)o)->id)();
}

static  void method_7015( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<PATFinalStateLS> >*)o)->productGetter)());
  else   (((const ::edm::RefProd<std::vector<PATFinalStateLS> >*)o)->productGetter)();
}

static  void method_7016( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<PATFinalStateLS> >*)o)->hasCache)());
  else   (((const ::edm::RefProd<std::vector<PATFinalStateLS> >*)o)->hasCache)();
}

static  void method_7017( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<PATFinalStateLS> >*)o)->hasProductCache)());
  else   (((const ::edm::RefProd<std::vector<PATFinalStateLS> >*)o)->hasProductCache)();
}

static  void method_7018( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<PATFinalStateLS> >*)o)->isAvailable)());
  else   (((const ::edm::RefProd<std::vector<PATFinalStateLS> >*)o)->isAvailable)();
}

static  void method_7019( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<PATFinalStateLS> >*)o)->isTransient)());
  else   (((const ::edm::RefProd<std::vector<PATFinalStateLS> >*)o)->isTransient)();
}

static  void method_7020( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefProd<std::vector<PATFinalStateLS> >*)o)->swap)(*(::edm::RefProd<std::vector<PATFinalStateLS> >*)arg[0]);
}

static  void method_7021( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefProd<std::vector<PATFinalStateLS> >*)o)->Class_Version)());
  else   (((::edm::RefProd<std::vector<PATFinalStateLS> >*)o)->Class_Version)();
}

static void method_newdel_263( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<PATFinalStateLS> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<PATFinalStateLS> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<PATFinalStateLS> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<PATFinalStateLS> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<PATFinalStateLS> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefProd<std::vector<PATFinalStateLS, std::allocator<PATFinalStateLS> > > -------------------------------
void __edm__RefProd_std__vector_PATFinalStateLS_s__db_datamem(Reflex::Class*);
void __edm__RefProd_std__vector_PATFinalStateLS_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_PATFinalStateLS_s__datamem_bld(&__edm__RefProd_std__vector_PATFinalStateLS_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_PATFinalStateLS_s__funcmem_bld(&__edm__RefProd_std__vector_PATFinalStateLS_s__db_funcmem);
void __edm__RefProd_std__vector_PATFinalStateLS_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefProd<std::vector<PATFinalStateLS> >"), typeid(::edm::RefProd<std::vector<PATFinalStateLS> >), sizeof(::edm::RefProd<std::vector<PATFinalStateLS> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefProd<std::vector<PATFinalStateLS> >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::RefProd<PATFinalStateLSCollection>")
  .AddTypedef(type_2244, Reflex::Literal("edm::RefProd<std::vector<PATFinalStateLS> >::product_type"))
  .AddTypedef(type_2244, Reflex::Literal("edm::RefProd<std::vector<PATFinalStateLS> >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45947, type_45948), Reflex::Literal("operator="), operator_6997, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45948), Reflex::Literal("RefProd"), constructor_6998, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefProd"), constructor_6999, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45949), Reflex::Literal("RefProd"), constructor_7000, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45950), Reflex::Literal("RefProd"), constructor_7001, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45951), Reflex::Literal("RefProd"), constructor_7002, 0, "iProduct", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45952), Reflex::Literal("RefProd"), constructor_7003, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417, type_45418), Reflex::Literal("RefProd"), constructor_7004, 0, "productID;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefProd"), destructor_7005, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_263, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefProd_std__vector_PATFinalStateLS_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefProd_std__vector_PATFinalStateLS_s__funcmem_bld);
}

//------Delayed data member builder for class RefProd<std::vector<PATFinalStateLS, std::allocator<PATFinalStateLS> > > -------------------
void __edm__RefProd_std__vector_PATFinalStateLS_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9667, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefProd_std__vector_PATFinalStateLS_s_, product_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefProd<std::vector<PATFinalStateLS, std::allocator<PATFinalStateLS> > > -------------------
void __edm__RefProd_std__vector_PATFinalStateLS_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45953), Reflex::Literal("operator*"), operator_7006, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45951), Reflex::Literal("operator->"), operator_7007, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45951), Reflex::Literal("get"), method_7008, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45951), Reflex::Literal("product"), method_7009, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45420), Reflex::Literal("refCore"), method_7010, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNull"), method_7011, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNonnull"), method_7012, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("operator!"), operator_7013, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9664), Reflex::Literal("id"), method_7014, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45418), Reflex::Literal("productGetter"), method_7015, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("hasCache"), method_7016, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("hasProductCache"), method_7017, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isAvailable"), method_7018, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isTransient"), method_7019, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45947), Reflex::Literal("swap"), method_7020, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_251), Reflex::Literal("Class_Version"), method_7021, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefVector<std::vector<PATFinalStateLS, std::allocator<PATFinalStateLS> >,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS, std::allocator<PATFinalStateLS> >, PATFinalStateLS> > -------------------------------
static void destructor_7039(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >::~RefVector)();
}
static void constructor_7040( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >();
  else ::new(mem) ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >();
}

static void constructor_7041( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >(*(const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >(*(const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)arg[0]);
}

static void constructor_7042( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >(*(const ::edm::ProductID*)arg[0]);
}

static  void method_7043( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->push_back)(*(const ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)arg[0]);
}

static  void operator_7044( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >)((((const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_7045( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >)((((const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_7046( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->refVector)();
  else   (((const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->refVector)();
}

static  void method_7047( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->empty)());
  else   (((const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->empty)();
}

static  void method_7048( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->size)());
  else   (((const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->size)();
}

static  void method_7049( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->capacity)());
  else   (((const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->capacity)();
}

static  void method_7050( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_7051( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >)((((const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->begin)());
  else   (((const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->begin)();
}

static  void method_7052( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >)((((const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->end)());
  else   (((const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->end)();
}

static  void method_7053( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->id)());
  else   (((const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->id)();
}

static  void method_7054( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->productGetter)());
  else   (((const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->productGetter)();
}

static  void method_7055( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->isNull)());
  else   (((const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->isNull)();
}

static  void method_7056( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->isNonnull)());
  else   (((const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->isNonnull)();
}

static  void operator_7057( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->operator!)());
  else   (((const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->operator!)();
}

static  void method_7058( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->product)());
  else   (((const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->product)();
}

static  void method_7059( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->isAvailable)());
  else   (((const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->isAvailable)();
}

static  void method_7060( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->isTransient)());
  else   (((const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->isTransient)();
}

static  void method_7061( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >)((((::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)arg[0]));
  else   (((::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)arg[0]);
}

static  void method_7062( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->clear)();
}

static  void method_7063( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->swap)(*(::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)arg[0]);
}

static  void operator_7064( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)arg[0]);
  else   (((::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)arg[0]);
}

static  void method_7065( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->hasProductCache)());
  else   (((const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->hasProductCache)();
}

static  void method_7066( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_7067( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->Class_Version)());
  else   (((::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->Class_Version)();
}

static void method_newdel_277( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefVector<std::vector<PATFinalStateLS, std::allocator<PATFinalStateLS> >,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS, std::allocator<PATFinalStateLS> >, PATFinalStateLS> > -------------------------------
void __edm__RefVector_std__vector_PATFinalStateLS__PATFinalStateLS_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateLS__PATFinalStateLS_s__db_datamem(Reflex::Class*);
void __edm__RefVector_std__vector_PATFinalStateLS__PATFinalStateLS_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateLS__PATFinalStateLS_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_PATFinalStateLS__PATFinalStateLS_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateLS__PATFinalStateLS_s__datamem_bld(&__edm__RefVector_std__vector_PATFinalStateLS__PATFinalStateLS_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateLS__PATFinalStateLS_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_PATFinalStateLS__PATFinalStateLS_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateLS__PATFinalStateLS_s__funcmem_bld(&__edm__RefVector_std__vector_PATFinalStateLS__PATFinalStateLS_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateLS__PATFinalStateLS_s__db_funcmem);
void __edm__RefVector_std__vector_PATFinalStateLS__PATFinalStateLS_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateLS__PATFinalStateLS_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >"), typeid(::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >), sizeof(::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::RefVector<PATFinalStateLSCollection,PATFinalStateLS,edm::refhelper::FindUsingAdvance<PATFinalStateLSCollection,PATFinalStateLS> >")
  .AddTypedef(type_2244, Reflex::Literal("edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >::collection_type"))
  .AddTypedef(type_3039, Reflex::Literal("edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >::member_type"))
  .AddTypedef(type_7027, Reflex::Literal("edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >::finder_type"))
  .AddTypedef(type_7029, Reflex::Literal("edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >::iterator"))
  .AddTypedef(type_7029, Reflex::Literal("edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >::const_iterator"))
  .AddTypedef(type_2230, Reflex::Literal("edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >::value_type"))
  .AddTypedef(type_2230c, Reflex::Literal("edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >::const_reference"))
  .AddTypedef(type_2230c, Reflex::Literal("edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >::reference"))
  .AddTypedef(type_497, Reflex::Literal("edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >::key_type"))
  .AddTypedef(type_4591, Reflex::Literal("edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >::KeyVec"))
  .AddTypedef(type_5015, Reflex::Literal("edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >::size_type"))
  .AddTypedef(type_6435, Reflex::Literal("edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >::contents_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVector"), destructor_7039, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVector"), constructor_7040, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45963), Reflex::Literal("RefVector"), constructor_7041, 0, "rh", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417), Reflex::Literal("RefVector"), constructor_7042, 0, "iId", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_277, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVector_std__vector_PATFinalStateLS__PATFinalStateLS_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateLS__PATFinalStateLS_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVector_std__vector_PATFinalStateLS__PATFinalStateLS_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateLS__PATFinalStateLS_s__funcmem_bld);
}

//------Delayed data member builder for class RefVector<std::vector<PATFinalStateLS, std::allocator<PATFinalStateLS> >,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS, std::allocator<PATFinalStateLS> >, PATFinalStateLS> > -------------------
void __edm__RefVector_std__vector_PATFinalStateLS__PATFinalStateLS_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateLS__PATFinalStateLS_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_6435, Reflex::Literal("refVector_"), OffsetOf(__shadow__::__edm__RefVector_std__vector_PATFinalStateLS__PATFinalStateLS_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateLS__PATFinalStateLS_s_, refVector_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVector<std::vector<PATFinalStateLS, std::allocator<PATFinalStateLS> >,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS, std::allocator<PATFinalStateLS> >, PATFinalStateLS> > -------------------
void __edm__RefVector_std__vector_PATFinalStateLS__PATFinalStateLS_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateLS__PATFinalStateLS_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45964), Reflex::Literal("push_back"), method_7043, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2230c, type_5015), Reflex::Literal("operator[]"), operator_7044, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2230c, type_5015), Reflex::Literal("at"), method_7045, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45458), Reflex::Literal("refVector"), method_7046, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_7047, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_7048, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_7049, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_7050, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7029), Reflex::Literal("begin"), method_7051, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7029), Reflex::Literal("end"), method_7052, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9664), Reflex::Literal("id"), method_7053, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45418), Reflex::Literal("productGetter"), method_7054, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNull"), method_7055, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNonnull"), method_7056, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("operator!"), operator_7057, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45951), Reflex::Literal("product"), method_7058, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isAvailable"), method_7059, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isTransient"), method_7060, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7029, type_45965), Reflex::Literal("erase"), method_7061, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_7062, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45966), Reflex::Literal("swap"), method_7063, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45966, type_45963), Reflex::Literal("operator="), operator_7064, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("hasProductCache"), method_7065, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_45462), Reflex::Literal("fillView"), method_7066, 0, ";pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_251), Reflex::Literal("Class_Version"), method_7067, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefVector<std::vector<PATMultiCandFinalState, std::allocator<PATMultiCandFinalState> >,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState, std::allocator<PATMultiCandFinalState> >, PATMultiCandFinalState> > -------------------------------
static void destructor_14320(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >::~RefVector)();
}
static void constructor_14321( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >();
  else ::new(mem) ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >();
}

static void constructor_14322( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >(*(const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >(*(const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)arg[0]);
}

static void constructor_14323( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >(*(const ::edm::ProductID*)arg[0]);
}

static  void method_14324( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->push_back)(*(const ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)arg[0]);
}

static  void operator_14325( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >)((((const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_14326( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >)((((const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14327( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->refVector)();
  else   (((const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->refVector)();
}

static  void method_14328( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->empty)());
  else   (((const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->empty)();
}

static  void method_14329( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->size)());
  else   (((const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->size)();
}

static  void method_14330( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->capacity)());
  else   (((const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->capacity)();
}

static  void method_14331( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_14332( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >)((((const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->begin)());
  else   (((const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->begin)();
}

static  void method_14333( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >)((((const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->end)());
  else   (((const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->end)();
}

static  void method_14334( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->id)());
  else   (((const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->id)();
}

static  void method_14335( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->productGetter)());
  else   (((const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->productGetter)();
}

static  void method_14336( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->isNull)());
  else   (((const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->isNull)();
}

static  void method_14337( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->isNonnull)());
  else   (((const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->isNonnull)();
}

static  void operator_14338( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->operator!)());
  else   (((const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->operator!)();
}

static  void method_14339( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->product)());
  else   (((const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->product)();
}

static  void method_14340( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->isAvailable)());
  else   (((const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->isAvailable)();
}

static  void method_14341( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->isTransient)());
  else   (((const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->isTransient)();
}

static  void method_14342( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >)((((::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)arg[0]));
  else   (((::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)arg[0]);
}

static  void method_14343( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->clear)();
}

static  void method_14344( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->swap)(*(::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)arg[0]);
}

static  void operator_14345( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)arg[0]);
  else   (((::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)arg[0]);
}

static  void method_14346( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->hasProductCache)());
  else   (((const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->hasProductCache)();
}

static  void method_14347( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_14348( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->Class_Version)());
  else   (((::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->Class_Version)();
}

static void method_newdel_2057( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefVector<std::vector<PATMultiCandFinalState, std::allocator<PATMultiCandFinalState> >,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState, std::allocator<PATMultiCandFinalState> >, PATMultiCandFinalState> > -------------------------------
void __edm__RefVector_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_edm__refhelper__FindUsingAdvance_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_s__db_datamem(Reflex::Class*);
void __edm__RefVector_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_edm__refhelper__FindUsingAdvance_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_edm__refhelper__FindUsingAdvance_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_s__datamem_bld(&__edm__RefVector_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_edm__refhelper__FindUsingAdvance_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_edm__refhelper__FindUsingAdvance_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_s__funcmem_bld(&__edm__RefVector_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_edm__refhelper__FindUsingAdvance_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_s__db_funcmem);
void __edm__RefVector_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_edm__refhelper__FindUsingAdvance_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >"), typeid(::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >), sizeof(::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::RefVector<PATMultiCandFinalStateCollection,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<PATMultiCandFinalStateCollection,PATMultiCandFinalState> >")
  .AddTypedef(type_3002, Reflex::Literal("edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >::collection_type"))
  .AddTypedef(type_67, Reflex::Literal("edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >::member_type"))
  .AddTypedef(type_14309, Reflex::Literal("edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >::finder_type"))
  .AddTypedef(type_8775, Reflex::Literal("edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >::iterator"))
  .AddTypedef(type_8775, Reflex::Literal("edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >::const_iterator"))
  .AddTypedef(type_2399, Reflex::Literal("edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >::value_type"))
  .AddTypedef(type_2399c, Reflex::Literal("edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >::const_reference"))
  .AddTypedef(type_2399c, Reflex::Literal("edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >::reference"))
  .AddTypedef(type_497, Reflex::Literal("edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >::key_type"))
  .AddTypedef(type_4591, Reflex::Literal("edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >::KeyVec"))
  .AddTypedef(type_5015, Reflex::Literal("edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >::size_type"))
  .AddTypedef(type_6435, Reflex::Literal("edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >::contents_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVector"), destructor_14320, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVector"), constructor_14321, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60411), Reflex::Literal("RefVector"), constructor_14322, 0, "rh", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417), Reflex::Literal("RefVector"), constructor_14323, 0, "iId", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2057, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVector_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_edm__refhelper__FindUsingAdvance_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVector_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_edm__refhelper__FindUsingAdvance_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_s__funcmem_bld);
}

//------Delayed data member builder for class RefVector<std::vector<PATMultiCandFinalState, std::allocator<PATMultiCandFinalState> >,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState, std::allocator<PATMultiCandFinalState> >, PATMultiCandFinalState> > -------------------
void __edm__RefVector_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_edm__refhelper__FindUsingAdvance_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_6435, Reflex::Literal("refVector_"), OffsetOf(__shadow__::__edm__RefVector_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_edm__refhelper__FindUsingAdvance_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_s_, refVector_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVector<std::vector<PATMultiCandFinalState, std::allocator<PATMultiCandFinalState> >,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState, std::allocator<PATMultiCandFinalState> >, PATMultiCandFinalState> > -------------------
void __edm__RefVector_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_edm__refhelper__FindUsingAdvance_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_60412), Reflex::Literal("push_back"), method_14324, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2399c, type_5015), Reflex::Literal("operator[]"), operator_14325, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2399c, type_5015), Reflex::Literal("at"), method_14326, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45458), Reflex::Literal("refVector"), method_14327, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_14328, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_14329, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_14330, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_14331, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8775), Reflex::Literal("begin"), method_14332, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8775), Reflex::Literal("end"), method_14333, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9664), Reflex::Literal("id"), method_14334, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45418), Reflex::Literal("productGetter"), method_14335, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNull"), method_14336, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNonnull"), method_14337, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("operator!"), operator_14338, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60413), Reflex::Literal("product"), method_14339, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isAvailable"), method_14340, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isTransient"), method_14341, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8775, type_60414), Reflex::Literal("erase"), method_14342, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_14343, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_60415), Reflex::Literal("swap"), method_14344, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60415, type_60411), Reflex::Literal("operator="), operator_14345, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("hasProductCache"), method_14346, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_45462), Reflex::Literal("fillView"), method_14347, 0, ";pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_251), Reflex::Literal("Class_Version"), method_14348, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefProd<std::vector<PATMultiCandFinalState, std::allocator<PATMultiCandFinalState> > > -------------------------------
static  void operator_14386( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefProd<std::vector<PATMultiCandFinalState> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<PATMultiCandFinalState> >*)arg[0]);
  else   (((::edm::RefProd<std::vector<PATMultiCandFinalState> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<PATMultiCandFinalState> >*)arg[0]);
}

static void constructor_14387( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<PATMultiCandFinalState> >(*(const ::edm::RefProd<std::vector<PATMultiCandFinalState> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<PATMultiCandFinalState> >(*(const ::edm::RefProd<std::vector<PATMultiCandFinalState> >*)arg[0]);
}

static void constructor_14388( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<PATMultiCandFinalState> >();
  else ::new(mem) ::edm::RefProd<std::vector<PATMultiCandFinalState> >();
}

static void constructor_14389( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<PATMultiCandFinalState> >(*(const ::edm::Handle<std::vector<PATMultiCandFinalState> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<PATMultiCandFinalState> >(*(const ::edm::Handle<std::vector<PATMultiCandFinalState> >*)arg[0]);
}

static void constructor_14390( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<PATMultiCandFinalState> >(*(const ::edm::OrphanHandle<std::vector<PATMultiCandFinalState> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<PATMultiCandFinalState> >(*(const ::edm::OrphanHandle<std::vector<PATMultiCandFinalState> >*)arg[0]);
}

static void constructor_14391( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<PATMultiCandFinalState> >((const ::std::vector<PATMultiCandFinalState>*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<PATMultiCandFinalState> >((const ::std::vector<PATMultiCandFinalState>*)arg[0]);
}

static void constructor_14392( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<PATMultiCandFinalState> >(*(const ::edm::TestHandle<std::vector<PATMultiCandFinalState> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<PATMultiCandFinalState> >(*(const ::edm::TestHandle<std::vector<PATMultiCandFinalState> >*)arg[0]);
}

static void constructor_14393( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<PATMultiCandFinalState> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
  else ::new(mem) ::edm::RefProd<std::vector<PATMultiCandFinalState> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
}

static void destructor_14394(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefProd<std::vector<PATMultiCandFinalState> >*)o)->::edm::RefProd<std::vector<PATMultiCandFinalState> >::~RefProd)();
}
static  void operator_14395( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<PATMultiCandFinalState> >*)o)->operator*)();
  else   (((const ::edm::RefProd<std::vector<PATMultiCandFinalState> >*)o)->operator*)();
}

static  void operator_14396( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<PATMultiCandFinalState> >*)o)->operator->)());
  else   (((const ::edm::RefProd<std::vector<PATMultiCandFinalState> >*)o)->operator->)();
}

static  void method_14397( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<PATMultiCandFinalState> >*)o)->get)());
  else   (((const ::edm::RefProd<std::vector<PATMultiCandFinalState> >*)o)->get)();
}

static  void method_14398( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<PATMultiCandFinalState> >*)o)->product)());
  else   (((const ::edm::RefProd<std::vector<PATMultiCandFinalState> >*)o)->product)();
}

static  void method_14399( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<PATMultiCandFinalState> >*)o)->refCore)();
  else   (((const ::edm::RefProd<std::vector<PATMultiCandFinalState> >*)o)->refCore)();
}

static  void method_14400( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<PATMultiCandFinalState> >*)o)->isNull)());
  else   (((const ::edm::RefProd<std::vector<PATMultiCandFinalState> >*)o)->isNull)();
}

static  void method_14401( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<PATMultiCandFinalState> >*)o)->isNonnull)());
  else   (((const ::edm::RefProd<std::vector<PATMultiCandFinalState> >*)o)->isNonnull)();
}

static  void operator_14402( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<PATMultiCandFinalState> >*)o)->operator!)());
  else   (((const ::edm::RefProd<std::vector<PATMultiCandFinalState> >*)o)->operator!)();
}

static  void method_14403( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefProd<std::vector<PATMultiCandFinalState> >*)o)->id)());
  else   (((const ::edm::RefProd<std::vector<PATMultiCandFinalState> >*)o)->id)();
}

static  void method_14404( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<PATMultiCandFinalState> >*)o)->productGetter)());
  else   (((const ::edm::RefProd<std::vector<PATMultiCandFinalState> >*)o)->productGetter)();
}

static  void method_14405( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<PATMultiCandFinalState> >*)o)->hasCache)());
  else   (((const ::edm::RefProd<std::vector<PATMultiCandFinalState> >*)o)->hasCache)();
}

static  void method_14406( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<PATMultiCandFinalState> >*)o)->hasProductCache)());
  else   (((const ::edm::RefProd<std::vector<PATMultiCandFinalState> >*)o)->hasProductCache)();
}

static  void method_14407( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<PATMultiCandFinalState> >*)o)->isAvailable)());
  else   (((const ::edm::RefProd<std::vector<PATMultiCandFinalState> >*)o)->isAvailable)();
}

static  void method_14408( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<PATMultiCandFinalState> >*)o)->isTransient)());
  else   (((const ::edm::RefProd<std::vector<PATMultiCandFinalState> >*)o)->isTransient)();
}

static  void method_14409( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefProd<std::vector<PATMultiCandFinalState> >*)o)->swap)(*(::edm::RefProd<std::vector<PATMultiCandFinalState> >*)arg[0]);
}

static  void method_14410( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefProd<std::vector<PATMultiCandFinalState> >*)o)->Class_Version)());
  else   (((::edm::RefProd<std::vector<PATMultiCandFinalState> >*)o)->Class_Version)();
}

static void method_newdel_2093( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<PATMultiCandFinalState> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<PATMultiCandFinalState> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<PATMultiCandFinalState> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<PATMultiCandFinalState> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<PATMultiCandFinalState> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefProd<std::vector<PATMultiCandFinalState, std::allocator<PATMultiCandFinalState> > > -------------------------------
void __edm__RefProd_std__vector_PATMultiCandFinalState_s__db_datamem(Reflex::Class*);
void __edm__RefProd_std__vector_PATMultiCandFinalState_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_PATMultiCandFinalState_s__datamem_bld(&__edm__RefProd_std__vector_PATMultiCandFinalState_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_PATMultiCandFinalState_s__funcmem_bld(&__edm__RefProd_std__vector_PATMultiCandFinalState_s__db_funcmem);
void __edm__RefProd_std__vector_PATMultiCandFinalState_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefProd<std::vector<PATMultiCandFinalState> >"), typeid(::edm::RefProd<std::vector<PATMultiCandFinalState> >), sizeof(::edm::RefProd<std::vector<PATMultiCandFinalState> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefProd<std::vector<PATMultiCandFinalState> >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::RefProd<PATMultiCandFinalStateCollection>")
  .AddTypedef(type_3002, Reflex::Literal("edm::RefProd<std::vector<PATMultiCandFinalState> >::product_type"))
  .AddTypedef(type_3002, Reflex::Literal("edm::RefProd<std::vector<PATMultiCandFinalState> >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60419, type_60420), Reflex::Literal("operator="), operator_14386, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60420), Reflex::Literal("RefProd"), constructor_14387, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefProd"), constructor_14388, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60421), Reflex::Literal("RefProd"), constructor_14389, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60422), Reflex::Literal("RefProd"), constructor_14390, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60413), Reflex::Literal("RefProd"), constructor_14391, 0, "iProduct", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60423), Reflex::Literal("RefProd"), constructor_14392, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417, type_45418), Reflex::Literal("RefProd"), constructor_14393, 0, "productID;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefProd"), destructor_14394, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2093, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefProd_std__vector_PATMultiCandFinalState_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefProd_std__vector_PATMultiCandFinalState_s__funcmem_bld);
}

//------Delayed data member builder for class RefProd<std::vector<PATMultiCandFinalState, std::allocator<PATMultiCandFinalState> > > -------------------
void __edm__RefProd_std__vector_PATMultiCandFinalState_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9667, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefProd_std__vector_PATMultiCandFinalState_s_, product_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefProd<std::vector<PATMultiCandFinalState, std::allocator<PATMultiCandFinalState> > > -------------------
void __edm__RefProd_std__vector_PATMultiCandFinalState_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_47135), Reflex::Literal("operator*"), operator_14395, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60413), Reflex::Literal("operator->"), operator_14396, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60413), Reflex::Literal("get"), method_14397, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60413), Reflex::Literal("product"), method_14398, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45420), Reflex::Literal("refCore"), method_14399, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNull"), method_14400, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNonnull"), method_14401, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("operator!"), operator_14402, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9664), Reflex::Literal("id"), method_14403, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45418), Reflex::Literal("productGetter"), method_14404, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("hasCache"), method_14405, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("hasProductCache"), method_14406, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isAvailable"), method_14407, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isTransient"), method_14408, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_60419), Reflex::Literal("swap"), method_14409, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_251), Reflex::Literal("Class_Version"), method_14410, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ref<std::vector<PATFinalStateLS, std::allocator<PATFinalStateLS> >,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS, std::allocator<PATFinalStateLS> >, PATFinalStateLS> > -------------------------------
static  void operator_14764( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->operator=)(*(const ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)arg[0]);
  else   (((::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->operator=)(*(const ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)arg[0]);
}

static void constructor_14765( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >(*(const ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >(*(const ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)arg[0]);
}

static void constructor_14766( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >();
  else ::new(mem) ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >();
}

static void constructor_14767( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >(*(const ::edm::Handle<std::vector<PATFinalStateLS> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >(*(const ::edm::Handle<std::vector<PATFinalStateLS> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >(*(const ::edm::Handle<std::vector<PATFinalStateLS> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >(*(const ::edm::Handle<std::vector<PATFinalStateLS> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_14768( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >(*(const ::edm::OrphanHandle<std::vector<PATFinalStateLS> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >(*(const ::edm::OrphanHandle<std::vector<PATFinalStateLS> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >(*(const ::edm::OrphanHandle<std::vector<PATFinalStateLS> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >(*(const ::edm::OrphanHandle<std::vector<PATFinalStateLS> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_14769( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >(*(const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >(*(const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >(*(const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >(*(const ::edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_14770( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >((const ::std::vector<PATFinalStateLS>*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >((const ::std::vector<PATFinalStateLS>*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >((const ::std::vector<PATFinalStateLS>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >((const ::std::vector<PATFinalStateLS>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_14771( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >(*(const ::edm::TestHandle<std::vector<PATFinalStateLS> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >(*(const ::edm::TestHandle<std::vector<PATFinalStateLS> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >(*(const ::edm::TestHandle<std::vector<PATFinalStateLS> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >(*(const ::edm::TestHandle<std::vector<PATFinalStateLS> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_14772( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_14773( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >(*(const ::edm::ProductID*)arg[0],
      (const ::PATFinalStateLS*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<PATFinalStateLS>*)arg[3]);
  else ::new(mem) ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >(*(const ::edm::ProductID*)arg[0],
      (const ::PATFinalStateLS*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<PATFinalStateLS>*)arg[3]);
}

static void constructor_14774( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_14775( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >(*(const ::edm::RefProd<std::vector<PATFinalStateLS> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >(*(const ::edm::RefProd<std::vector<PATFinalStateLS> >*)arg[0],
      *(unsigned int*)arg[1]);
}

static void destructor_14776(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >::~Ref)();
}
static  void operator_14777( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->operator*)();
  else   (((const ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->operator*)();
}

static  void operator_14778( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->operator->)());
  else   (((const ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->operator->)();
}

static  void method_14779( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->get)());
  else   (((const ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->get)();
}

static  void method_14780( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->isNull)());
  else   (((const ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->isNull)();
}

static  void method_14781( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->isNonnull)());
  else   (((const ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->isNonnull)();
}

static  void operator_14782( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->operator!)());
  else   (((const ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->operator!)();
}

static  void method_14783( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->id)());
  else   (((const ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->id)();
}

static  void method_14784( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->productGetter)());
  else   (((const ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->productGetter)();
}

static  void method_14785( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->product)());
  else   (((const ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->product)();
}

static  void method_14786( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->key)());
  else   (((const ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->key)();
}

static  void method_14787( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->index)());
  else   (((const ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->index)();
}

static  void method_14788( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->hasProductCache)());
  else   (((const ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->hasProductCache)();
}

static  void method_14789( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->isAvailable)());
  else   (((const ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->isAvailable)();
}

static  void method_14790( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->isTransient)());
  else   (((const ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->isTransient)();
}

static  void method_14791( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->refCore)();
  else   (((const ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->refCore)();
}

static  void method_14792( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->Class_Version)());
  else   (((::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >*)o)->Class_Version)();
}

static void constructor_14793( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_2230( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ref<std::vector<PATFinalStateLS, std::allocator<PATFinalStateLS> >,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS, std::allocator<PATFinalStateLS> >, PATFinalStateLS> > -------------------------------
void __edm__Ref_std__vector_PATFinalStateLS__PATFinalStateLS_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateLS__PATFinalStateLS_s__db_datamem(Reflex::Class*);
void __edm__Ref_std__vector_PATFinalStateLS__PATFinalStateLS_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateLS__PATFinalStateLS_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_PATFinalStateLS__PATFinalStateLS_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateLS__PATFinalStateLS_s__datamem_bld(&__edm__Ref_std__vector_PATFinalStateLS__PATFinalStateLS_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateLS__PATFinalStateLS_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_PATFinalStateLS__PATFinalStateLS_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateLS__PATFinalStateLS_s__funcmem_bld(&__edm__Ref_std__vector_PATFinalStateLS__PATFinalStateLS_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateLS__PATFinalStateLS_s__db_funcmem);
void __edm__Ref_std__vector_PATFinalStateLS__PATFinalStateLS_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateLS__PATFinalStateLS_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >"), typeid(::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >), sizeof(::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::Ref<PATFinalStateLSCollection,PATFinalStateLS,edm::refhelper::FindUsingAdvance<PATFinalStateLSCollection,PATFinalStateLS> >")
  .AddTypedef(type_3039, Reflex::Literal("edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >::T"))
  .AddTypedef(type_7027, Reflex::Literal("edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >::F"))
  .AddTypedef(type_14754, Reflex::Literal("edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >::VF"))
  .AddTypedef(type_14756, Reflex::Literal("edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >::VBF"))
  .AddTypedef(type_2244, Reflex::Literal("edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >::product_type"))
  .AddTypedef(type_3039, Reflex::Literal("edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >::value_type"))
  .AddTypedef(type_3039c, Reflex::Literal("edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >::element_type"))
  .AddTypedef(type_7027, Reflex::Literal("edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >::finder_type"))
  .AddTypedef(type_497, Reflex::Literal("edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >::argument_type"))
  .AddTypedef(type_497, Reflex::Literal("edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> >::key_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60808, type_45964), Reflex::Literal("operator="), operator_14764, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45964), Reflex::Literal("Ref"), constructor_14765, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ref"), constructor_14766, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45949, type_497, type_2301), Reflex::Literal("Ref"), constructor_14767, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45950, type_497, type_2301), Reflex::Literal("Ref"), constructor_14768, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45963, type_497, type_2301), Reflex::Literal("Ref"), constructor_14769, 0, "refvector;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45951, type_497, type_2301), Reflex::Literal("Ref"), constructor_14770, 0, "iProduct;iItemKey;iSetNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45952, type_497, type_2301), Reflex::Literal("Ref"), constructor_14771, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417, type_497, type_45418), Reflex::Literal("Ref"), constructor_14772, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417, type_14867, type_497, type_45951), Reflex::Literal("Ref"), constructor_14773, 0, "iProductID;;iItemKey;iProduct", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417), Reflex::Literal("Ref"), constructor_14774, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45948, type_497), Reflex::Literal("Ref"), constructor_14775, 0, "refProd;itemKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ref"), destructor_14776, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45420, type_24095), Reflex::Literal("Ref"), constructor_14793, 0, "iRefCore;iKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2230, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ref_std__vector_PATFinalStateLS__PATFinalStateLS_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateLS__PATFinalStateLS_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ref_std__vector_PATFinalStateLS__PATFinalStateLS_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateLS__PATFinalStateLS_s__funcmem_bld);
}

//------Delayed data member builder for class Ref<std::vector<PATFinalStateLS, std::allocator<PATFinalStateLS> >,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS, std::allocator<PATFinalStateLS> >, PATFinalStateLS> > -------------------
void __edm__Ref_std__vector_PATFinalStateLS__PATFinalStateLS_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateLS__PATFinalStateLS_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9920, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__Ref_std__vector_PATFinalStateLS__PATFinalStateLS_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateLS__PATFinalStateLS_s_, product_), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class Ref<std::vector<PATFinalStateLS, std::allocator<PATFinalStateLS> >,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS, std::allocator<PATFinalStateLS> >, PATFinalStateLS> > -------------------
void __edm__Ref_std__vector_PATFinalStateLS__PATFinalStateLS_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateLS__PATFinalStateLS_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14871), Reflex::Literal("operator*"), operator_14777, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14867), Reflex::Literal("operator->"), operator_14778, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14867), Reflex::Literal("get"), method_14779, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNull"), method_14780, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNonnull"), method_14781, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("operator!"), operator_14782, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9664), Reflex::Literal("id"), method_14783, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45418), Reflex::Literal("productGetter"), method_14784, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45951), Reflex::Literal("product"), method_14785, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_497), Reflex::Literal("key"), method_14786, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_497), Reflex::Literal("index"), method_14787, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("hasProductCache"), method_14788, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isAvailable"), method_14789, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isTransient"), method_14790, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45420), Reflex::Literal("refCore"), method_14791, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_251), Reflex::Literal("Class_Version"), method_14792, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ref<std::vector<PATMultiCandFinalState, std::allocator<PATMultiCandFinalState> >,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState, std::allocator<PATMultiCandFinalState> >, PATMultiCandFinalState> > -------------------------------
static  void operator_15335( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->operator=)(*(const ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)arg[0]);
  else   (((::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->operator=)(*(const ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)arg[0]);
}

static void constructor_15336( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >(*(const ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >(*(const ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)arg[0]);
}

static void constructor_15337( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >();
  else ::new(mem) ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >();
}

static void constructor_15338( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >(*(const ::edm::Handle<std::vector<PATMultiCandFinalState> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >(*(const ::edm::Handle<std::vector<PATMultiCandFinalState> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >(*(const ::edm::Handle<std::vector<PATMultiCandFinalState> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >(*(const ::edm::Handle<std::vector<PATMultiCandFinalState> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_15339( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >(*(const ::edm::OrphanHandle<std::vector<PATMultiCandFinalState> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >(*(const ::edm::OrphanHandle<std::vector<PATMultiCandFinalState> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >(*(const ::edm::OrphanHandle<std::vector<PATMultiCandFinalState> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >(*(const ::edm::OrphanHandle<std::vector<PATMultiCandFinalState> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_15340( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >(*(const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >(*(const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >(*(const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >(*(const ::edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_15341( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >((const ::std::vector<PATMultiCandFinalState>*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >((const ::std::vector<PATMultiCandFinalState>*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >((const ::std::vector<PATMultiCandFinalState>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >((const ::std::vector<PATMultiCandFinalState>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_15342( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >(*(const ::edm::TestHandle<std::vector<PATMultiCandFinalState> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >(*(const ::edm::TestHandle<std::vector<PATMultiCandFinalState> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >(*(const ::edm::TestHandle<std::vector<PATMultiCandFinalState> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >(*(const ::edm::TestHandle<std::vector<PATMultiCandFinalState> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_15343( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_15344( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >(*(const ::edm::ProductID*)arg[0],
      (const ::PATMultiCandFinalState*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<PATMultiCandFinalState>*)arg[3]);
  else ::new(mem) ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >(*(const ::edm::ProductID*)arg[0],
      (const ::PATMultiCandFinalState*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<PATMultiCandFinalState>*)arg[3]);
}

static void constructor_15345( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_15346( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >(*(const ::edm::RefProd<std::vector<PATMultiCandFinalState> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >(*(const ::edm::RefProd<std::vector<PATMultiCandFinalState> >*)arg[0],
      *(unsigned int*)arg[1]);
}

static void destructor_15347(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >::~Ref)();
}
static  void operator_15348( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->operator*)();
  else   (((const ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->operator*)();
}

static  void operator_15349( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->operator->)());
  else   (((const ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->operator->)();
}

static  void method_15350( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->get)());
  else   (((const ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->get)();
}

static  void method_15351( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->isNull)());
  else   (((const ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->isNull)();
}

static  void method_15352( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->isNonnull)());
  else   (((const ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->isNonnull)();
}

static  void operator_15353( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->operator!)());
  else   (((const ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->operator!)();
}

static  void method_15354( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->id)());
  else   (((const ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->id)();
}

static  void method_15355( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->productGetter)());
  else   (((const ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->productGetter)();
}

static  void method_15356( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->product)());
  else   (((const ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->product)();
}

static  void method_15357( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->key)());
  else   (((const ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->key)();
}

static  void method_15358( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->index)());
  else   (((const ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->index)();
}

static  void method_15359( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->hasProductCache)());
  else   (((const ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->hasProductCache)();
}

static  void method_15360( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->isAvailable)());
  else   (((const ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->isAvailable)();
}

static  void method_15361( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->isTransient)());
  else   (((const ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->isTransient)();
}

static  void method_15362( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->refCore)();
  else   (((const ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->refCore)();
}

static  void method_15363( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->Class_Version)());
  else   (((::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >*)o)->Class_Version)();
}

static void constructor_15364( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_2399( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ref<std::vector<PATMultiCandFinalState, std::allocator<PATMultiCandFinalState> >,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState, std::allocator<PATMultiCandFinalState> >, PATMultiCandFinalState> > -------------------------------
void __edm__Ref_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_edm__refhelper__FindUsingAdvance_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_s__db_datamem(Reflex::Class*);
void __edm__Ref_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_edm__refhelper__FindUsingAdvance_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_edm__refhelper__FindUsingAdvance_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_s__datamem_bld(&__edm__Ref_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_edm__refhelper__FindUsingAdvance_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_edm__refhelper__FindUsingAdvance_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_s__funcmem_bld(&__edm__Ref_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_edm__refhelper__FindUsingAdvance_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_s__db_funcmem);
void __edm__Ref_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_edm__refhelper__FindUsingAdvance_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >"), typeid(::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >), sizeof(::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::Ref<PATMultiCandFinalStateCollection,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<PATMultiCandFinalStateCollection,PATMultiCandFinalState> >")
  .AddTypedef(type_67, Reflex::Literal("edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >::T"))
  .AddTypedef(type_14309, Reflex::Literal("edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >::F"))
  .AddTypedef(type_15325, Reflex::Literal("edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >::VF"))
  .AddTypedef(type_15327, Reflex::Literal("edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >::VBF"))
  .AddTypedef(type_3002, Reflex::Literal("edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >::product_type"))
  .AddTypedef(type_67, Reflex::Literal("edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >::value_type"))
  .AddTypedef(type_67c, Reflex::Literal("edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >::element_type"))
  .AddTypedef(type_14309, Reflex::Literal("edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >::finder_type"))
  .AddTypedef(type_497, Reflex::Literal("edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >::argument_type"))
  .AddTypedef(type_497, Reflex::Literal("edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> >::key_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60877, type_60412), Reflex::Literal("operator="), operator_15335, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60412), Reflex::Literal("Ref"), constructor_15336, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ref"), constructor_15337, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60421, type_497, type_2301), Reflex::Literal("Ref"), constructor_15338, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60422, type_497, type_2301), Reflex::Literal("Ref"), constructor_15339, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60411, type_497, type_2301), Reflex::Literal("Ref"), constructor_15340, 0, "refvector;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60413, type_497, type_2301), Reflex::Literal("Ref"), constructor_15341, 0, "iProduct;iItemKey;iSetNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60423, type_497, type_2301), Reflex::Literal("Ref"), constructor_15342, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417, type_497, type_45418), Reflex::Literal("Ref"), constructor_15343, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417, type_18146, type_497, type_60413), Reflex::Literal("Ref"), constructor_15344, 0, "iProductID;;iItemKey;iProduct", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417), Reflex::Literal("Ref"), constructor_15345, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_60420, type_497), Reflex::Literal("Ref"), constructor_15346, 0, "refProd;itemKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ref"), destructor_15347, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45420, type_24095), Reflex::Literal("Ref"), constructor_15364, 0, "iRefCore;iKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2399, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ref_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_edm__refhelper__FindUsingAdvance_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ref_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_edm__refhelper__FindUsingAdvance_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_s__funcmem_bld);
}

//------Delayed data member builder for class Ref<std::vector<PATMultiCandFinalState, std::allocator<PATMultiCandFinalState> >,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState, std::allocator<PATMultiCandFinalState> >, PATMultiCandFinalState> > -------------------
void __edm__Ref_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_edm__refhelper__FindUsingAdvance_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9920, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__Ref_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_edm__refhelper__FindUsingAdvance_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_s_, product_), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class Ref<std::vector<PATMultiCandFinalState, std::allocator<PATMultiCandFinalState> >,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState, std::allocator<PATMultiCandFinalState> >, PATMultiCandFinalState> > -------------------
void __edm__Ref_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_edm__refhelper__FindUsingAdvance_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18150), Reflex::Literal("operator*"), operator_15348, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18146), Reflex::Literal("operator->"), operator_15349, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18146), Reflex::Literal("get"), method_15350, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNull"), method_15351, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNonnull"), method_15352, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("operator!"), operator_15353, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9664), Reflex::Literal("id"), method_15354, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45418), Reflex::Literal("productGetter"), method_15355, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60413), Reflex::Literal("product"), method_15356, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_497), Reflex::Literal("key"), method_15357, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_497), Reflex::Literal("index"), method_15358, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("hasProductCache"), method_15359, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isAvailable"), method_15360, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isTransient"), method_15361, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45420), Reflex::Literal("refCore"), method_15362, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_251), Reflex::Literal("Class_Version"), method_15363, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefVector<edm::OwnVector<PATFinalState, edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState, edm::ClonePolicy<PATFinalState> >, PATFinalState> > -------------------------------
static void destructor_16278(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >::~RefVector)();
}
static void constructor_16279( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >();
  else ::new(mem) ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >();
}

static void constructor_16280( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >(*(const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)arg[0]);
  else ::new(mem) ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >(*(const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)arg[0]);
}

static void constructor_16281( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >(*(const ::edm::ProductID*)arg[0]);
}

static  void method_16282( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->push_back)(*(const ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)arg[0]);
}

static  void operator_16283( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >)((((const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_16284( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >)((((const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_16285( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->refVector)();
  else   (((const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->refVector)();
}

static  void method_16286( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->empty)());
  else   (((const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->empty)();
}

static  void method_16287( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->size)());
  else   (((const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->size)();
}

static  void method_16288( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->capacity)());
  else   (((const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->capacity)();
}

static  void method_16289( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_16290( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >)((((const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->begin)());
  else   (((const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->begin)();
}

static  void method_16291( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >)((((const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->end)());
  else   (((const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->end)();
}

static  void method_16292( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->id)());
  else   (((const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->id)();
}

static  void method_16293( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->productGetter)());
  else   (((const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->productGetter)();
}

static  void method_16294( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->isNull)());
  else   (((const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->isNull)();
}

static  void method_16295( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->isNonnull)());
  else   (((const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->isNonnull)();
}

static  void operator_16296( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->operator!)());
  else   (((const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->operator!)();
}

static  void method_16297( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->product)());
  else   (((const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->product)();
}

static  void method_16298( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->isAvailable)());
  else   (((const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->isAvailable)();
}

static  void method_16299( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->isTransient)());
  else   (((const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->isTransient)();
}

static  void method_16300( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >)((((::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->erase)(*(const ::edm::RefVectorIterator<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)arg[0]));
  else   (((::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->erase)(*(const ::edm::RefVectorIterator<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)arg[0]);
}

static  void method_16301( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->clear)();
}

static  void method_16302( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->swap)(*(::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)arg[0]);
}

static  void operator_16303( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->operator=)(*(const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)arg[0]);
  else   (((::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->operator=)(*(const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)arg[0]);
}

static  void method_16304( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->hasProductCache)());
  else   (((const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->hasProductCache)();
}

static  void method_16305( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_16306( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->Class_Version)());
  else   (((::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->Class_Version)();
}

static void method_newdel_2787( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefVector<edm::OwnVector<PATFinalState, edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState, edm::ClonePolicy<PATFinalState> >, PATFinalState> > -------------------------------
void __edm__RefVector_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_edm__refhelper__FindUsingAdvance_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_s__db_datamem(Reflex::Class*);
void __edm__RefVector_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_edm__refhelper__FindUsingAdvance_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVector_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_edm__refhelper__FindUsingAdvance_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_s__datamem_bld(&__edm__RefVector_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_edm__refhelper__FindUsingAdvance_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVector_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_edm__refhelper__FindUsingAdvance_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_s__funcmem_bld(&__edm__RefVector_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_edm__refhelper__FindUsingAdvance_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_s__db_funcmem);
void __edm__RefVector_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_edm__refhelper__FindUsingAdvance_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >"), typeid(::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >), sizeof(::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::RefVector<PATFinalStateCollection,PATFinalState,edm::refhelper::FindUsingAdvance<PATFinalStateCollection,PATFinalState> >")
  .AddTypedef(type_951, Reflex::Literal("edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >::collection_type"))
  .AddTypedef(type_466, Reflex::Literal("edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >::member_type"))
  .AddTypedef(type_16267, Reflex::Literal("edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >::finder_type"))
  .AddTypedef(type_8776, Reflex::Literal("edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >::iterator"))
  .AddTypedef(type_8776, Reflex::Literal("edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >::const_iterator"))
  .AddTypedef(type_3090, Reflex::Literal("edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >::value_type"))
  .AddTypedef(type_3090c, Reflex::Literal("edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >::const_reference"))
  .AddTypedef(type_3090c, Reflex::Literal("edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >::reference"))
  .AddTypedef(type_497, Reflex::Literal("edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >::key_type"))
  .AddTypedef(type_4591, Reflex::Literal("edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >::KeyVec"))
  .AddTypedef(type_5015, Reflex::Literal("edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >::size_type"))
  .AddTypedef(type_6435, Reflex::Literal("edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >::contents_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVector"), destructor_16278, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVector"), constructor_16279, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_61014), Reflex::Literal("RefVector"), constructor_16280, 0, "rh", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417), Reflex::Literal("RefVector"), constructor_16281, 0, "iId", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2787, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVector_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_edm__refhelper__FindUsingAdvance_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVector_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_edm__refhelper__FindUsingAdvance_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_s__funcmem_bld);
}

//------Delayed data member builder for class RefVector<edm::OwnVector<PATFinalState, edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState, edm::ClonePolicy<PATFinalState> >, PATFinalState> > -------------------
void __edm__RefVector_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_edm__refhelper__FindUsingAdvance_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_6435, Reflex::Literal("refVector_"), OffsetOf(__shadow__::__edm__RefVector_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_edm__refhelper__FindUsingAdvance_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_s_, refVector_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVector<edm::OwnVector<PATFinalState, edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState, edm::ClonePolicy<PATFinalState> >, PATFinalState> > -------------------
void __edm__RefVector_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_edm__refhelper__FindUsingAdvance_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_61015), Reflex::Literal("push_back"), method_16282, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3090c, type_5015), Reflex::Literal("operator[]"), operator_16283, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3090c, type_5015), Reflex::Literal("at"), method_16284, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45458), Reflex::Literal("refVector"), method_16285, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("empty"), method_16286, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("size"), method_16287, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5015), Reflex::Literal("capacity"), method_16288, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_5015), Reflex::Literal("reserve"), method_16289, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8776), Reflex::Literal("begin"), method_16290, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8776), Reflex::Literal("end"), method_16291, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9664), Reflex::Literal("id"), method_16292, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45418), Reflex::Literal("productGetter"), method_16293, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNull"), method_16294, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNonnull"), method_16295, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("operator!"), operator_16296, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45906), Reflex::Literal("product"), method_16297, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isAvailable"), method_16298, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isTransient"), method_16299, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8776, type_61016), Reflex::Literal("erase"), method_16300, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539), Reflex::Literal("clear"), method_16301, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_61017), Reflex::Literal("swap"), method_16302, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_61017, type_61014), Reflex::Literal("operator="), operator_16303, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("hasProductCache"), method_16304, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_45462), Reflex::Literal("fillView"), method_16305, 0, ";pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_251), Reflex::Literal("Class_Version"), method_16306, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ref<std::vector<PATFinalStateEvent, std::allocator<PATFinalStateEvent> >,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent, std::allocator<PATFinalStateEvent> >, PATFinalStateEvent> > -------------------------------
static  void operator_18385( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->operator=)(*(const ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)arg[0]);
  else   (((::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->operator=)(*(const ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)arg[0]);
}

static void constructor_18386( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >(*(const ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >(*(const ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)arg[0]);
}

static void constructor_18387( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >();
  else ::new(mem) ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >();
}

static void constructor_18388( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >(*(const ::edm::Handle<std::vector<PATFinalStateEvent> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >(*(const ::edm::Handle<std::vector<PATFinalStateEvent> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >(*(const ::edm::Handle<std::vector<PATFinalStateEvent> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >(*(const ::edm::Handle<std::vector<PATFinalStateEvent> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_18389( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >(*(const ::edm::OrphanHandle<std::vector<PATFinalStateEvent> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >(*(const ::edm::OrphanHandle<std::vector<PATFinalStateEvent> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >(*(const ::edm::OrphanHandle<std::vector<PATFinalStateEvent> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >(*(const ::edm::OrphanHandle<std::vector<PATFinalStateEvent> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_18390( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >(*(const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >(*(const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >(*(const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >(*(const ::edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_18391( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >((const ::std::vector<PATFinalStateEvent>*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >((const ::std::vector<PATFinalStateEvent>*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >((const ::std::vector<PATFinalStateEvent>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >((const ::std::vector<PATFinalStateEvent>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_18392( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >(*(const ::edm::TestHandle<std::vector<PATFinalStateEvent> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >(*(const ::edm::TestHandle<std::vector<PATFinalStateEvent> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >(*(const ::edm::TestHandle<std::vector<PATFinalStateEvent> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >(*(const ::edm::TestHandle<std::vector<PATFinalStateEvent> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_18393( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_18394( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >(*(const ::edm::ProductID*)arg[0],
      (const ::PATFinalStateEvent*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<PATFinalStateEvent>*)arg[3]);
  else ::new(mem) ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >(*(const ::edm::ProductID*)arg[0],
      (const ::PATFinalStateEvent*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<PATFinalStateEvent>*)arg[3]);
}

static void constructor_18395( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_18396( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >(*(const ::edm::RefProd<std::vector<PATFinalStateEvent> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >(*(const ::edm::RefProd<std::vector<PATFinalStateEvent> >*)arg[0],
      *(unsigned int*)arg[1]);
}

static void destructor_18397(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >::~Ref)();
}
static  void operator_18398( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->operator*)();
  else   (((const ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->operator*)();
}

static  void operator_18399( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->operator->)());
  else   (((const ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->operator->)();
}

static  void method_18400( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->get)());
  else   (((const ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->get)();
}

static  void method_18401( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->isNull)());
  else   (((const ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->isNull)();
}

static  void method_18402( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->isNonnull)());
  else   (((const ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->isNonnull)();
}

static  void operator_18403( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->operator!)());
  else   (((const ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->operator!)();
}

static  void method_18404( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->id)());
  else   (((const ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->id)();
}

static  void method_18405( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->productGetter)());
  else   (((const ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->productGetter)();
}

static  void method_18406( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->product)());
  else   (((const ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->product)();
}

static  void method_18407( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->key)());
  else   (((const ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->key)();
}

static  void method_18408( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->index)());
  else   (((const ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->index)();
}

static  void method_18409( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->hasProductCache)());
  else   (((const ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->hasProductCache)();
}

static  void method_18410( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->isAvailable)());
  else   (((const ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->isAvailable)();
}

static  void method_18411( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->isTransient)());
  else   (((const ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->isTransient)();
}

static  void method_18412( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->refCore)();
  else   (((const ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->refCore)();
}

static  void method_18413( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->Class_Version)());
  else   (((::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >*)o)->Class_Version)();
}

static void constructor_18414( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_3065( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ref<std::vector<PATFinalStateEvent, std::allocator<PATFinalStateEvent> >,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent, std::allocator<PATFinalStateEvent> >, PATFinalStateEvent> > -------------------------------
void __edm__Ref_std__vector_PATFinalStateEvent__PATFinalStateEvent_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateEvent__PATFinalStateEvent_s__db_datamem(Reflex::Class*);
void __edm__Ref_std__vector_PATFinalStateEvent__PATFinalStateEvent_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateEvent__PATFinalStateEvent_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_PATFinalStateEvent__PATFinalStateEvent_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateEvent__PATFinalStateEvent_s__datamem_bld(&__edm__Ref_std__vector_PATFinalStateEvent__PATFinalStateEvent_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateEvent__PATFinalStateEvent_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_PATFinalStateEvent__PATFinalStateEvent_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateEvent__PATFinalStateEvent_s__funcmem_bld(&__edm__Ref_std__vector_PATFinalStateEvent__PATFinalStateEvent_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateEvent__PATFinalStateEvent_s__db_funcmem);
void __edm__Ref_std__vector_PATFinalStateEvent__PATFinalStateEvent_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateEvent__PATFinalStateEvent_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >"), typeid(::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >), sizeof(::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::Ref<PATFinalStateEventCollection,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<PATFinalStateEventCollection,PATFinalStateEvent> >")
  .AddTypedef(type_583, Reflex::Literal("edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >::T"))
  .AddTypedef(type_6424, Reflex::Literal("edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >::F"))
  .AddTypedef(type_18375, Reflex::Literal("edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >::VF"))
  .AddTypedef(type_18377, Reflex::Literal("edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >::VBF"))
  .AddTypedef(type_480, Reflex::Literal("edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >::product_type"))
  .AddTypedef(type_583, Reflex::Literal("edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >::value_type"))
  .AddTypedef(type_583c, Reflex::Literal("edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >::element_type"))
  .AddTypedef(type_6424, Reflex::Literal("edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >::finder_type"))
  .AddTypedef(type_497, Reflex::Literal("edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >::argument_type"))
  .AddTypedef(type_497, Reflex::Literal("edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> >::key_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_69787, type_45457), Reflex::Literal("operator="), operator_18385, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45457), Reflex::Literal("Ref"), constructor_18386, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ref"), constructor_18387, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45413, type_497, type_2301), Reflex::Literal("Ref"), constructor_18388, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45414, type_497, type_2301), Reflex::Literal("Ref"), constructor_18389, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45456, type_497, type_2301), Reflex::Literal("Ref"), constructor_18390, 0, "refvector;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45415, type_497, type_2301), Reflex::Literal("Ref"), constructor_18391, 0, "iProduct;iItemKey;iSetNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45416, type_497, type_2301), Reflex::Literal("Ref"), constructor_18392, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417, type_497, type_45418), Reflex::Literal("Ref"), constructor_18393, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417, type_7665, type_497, type_45415), Reflex::Literal("Ref"), constructor_18394, 0, "iProductID;;iItemKey;iProduct", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417), Reflex::Literal("Ref"), constructor_18395, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45412, type_497), Reflex::Literal("Ref"), constructor_18396, 0, "refProd;itemKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ref"), destructor_18397, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45420, type_24095), Reflex::Literal("Ref"), constructor_18414, 0, "iRefCore;iKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3065, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ref_std__vector_PATFinalStateEvent__PATFinalStateEvent_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateEvent__PATFinalStateEvent_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ref_std__vector_PATFinalStateEvent__PATFinalStateEvent_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateEvent__PATFinalStateEvent_s__funcmem_bld);
}

//------Delayed data member builder for class Ref<std::vector<PATFinalStateEvent, std::allocator<PATFinalStateEvent> >,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent, std::allocator<PATFinalStateEvent> >, PATFinalStateEvent> > -------------------
void __edm__Ref_std__vector_PATFinalStateEvent__PATFinalStateEvent_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateEvent__PATFinalStateEvent_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9920, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__Ref_std__vector_PATFinalStateEvent__PATFinalStateEvent_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateEvent__PATFinalStateEvent_s_, product_), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class Ref<std::vector<PATFinalStateEvent, std::allocator<PATFinalStateEvent> >,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent, std::allocator<PATFinalStateEvent> >, PATFinalStateEvent> > -------------------
void __edm__Ref_std__vector_PATFinalStateEvent__PATFinalStateEvent_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateEvent__PATFinalStateEvent_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7669), Reflex::Literal("operator*"), operator_18398, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7665), Reflex::Literal("operator->"), operator_18399, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7665), Reflex::Literal("get"), method_18400, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNull"), method_18401, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNonnull"), method_18402, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("operator!"), operator_18403, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9664), Reflex::Literal("id"), method_18404, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45418), Reflex::Literal("productGetter"), method_18405, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45415), Reflex::Literal("product"), method_18406, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_497), Reflex::Literal("key"), method_18407, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_497), Reflex::Literal("index"), method_18408, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("hasProductCache"), method_18409, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isAvailable"), method_18410, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isTransient"), method_18411, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45420), Reflex::Literal("refCore"), method_18412, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_251), Reflex::Literal("Class_Version"), method_18413, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ref<edm::OwnVector<PATFinalState, edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState, edm::ClonePolicy<PATFinalState> >, PATFinalState> > -------------------------------
static  void operator_18428( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->operator=)(*(const ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)arg[0]);
  else   (((::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->operator=)(*(const ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)arg[0]);
}

static void constructor_18429( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >(*(const ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)arg[0]);
  else ::new(mem) ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >(*(const ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)arg[0]);
}

static void constructor_18430( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >();
  else ::new(mem) ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >();
}

static void constructor_18431( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >(*(const ::edm::Handle<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >(*(const ::edm::Handle<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >(*(const ::edm::Handle<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >(*(const ::edm::Handle<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_18432( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >(*(const ::edm::OrphanHandle<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >(*(const ::edm::OrphanHandle<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >(*(const ::edm::OrphanHandle<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >(*(const ::edm::OrphanHandle<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_18433( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >(*(const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >(*(const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >(*(const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >(*(const ::edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_18434( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >((const ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >((const ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >((const ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >((const ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_18435( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >(*(const ::edm::TestHandle<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >(*(const ::edm::TestHandle<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >(*(const ::edm::TestHandle<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >(*(const ::edm::TestHandle<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_18436( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_18437( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >(*(const ::edm::ProductID*)arg[0],
      (const ::PATFinalState*)arg[1],
      *(unsigned int*)arg[2],
      (const ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)arg[3]);
  else ::new(mem) ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >(*(const ::edm::ProductID*)arg[0],
      (const ::PATFinalState*)arg[1],
      *(unsigned int*)arg[2],
      (const ::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)arg[3]);
}

static void constructor_18438( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_18439( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >(*(const ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >(*(const ::edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)arg[0],
      *(unsigned int*)arg[1]);
}

static void destructor_18440(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >::~Ref)();
}
static  void operator_18441( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->operator*)();
  else   (((const ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->operator*)();
}

static  void operator_18442( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->operator->)());
  else   (((const ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->operator->)();
}

static  void method_18443( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->get)());
  else   (((const ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->get)();
}

static  void method_18444( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->isNull)());
  else   (((const ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->isNull)();
}

static  void method_18445( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->isNonnull)());
  else   (((const ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->isNonnull)();
}

static  void operator_18446( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->operator!)());
  else   (((const ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->operator!)();
}

static  void method_18447( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->id)());
  else   (((const ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->id)();
}

static  void method_18448( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->productGetter)());
  else   (((const ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->productGetter)();
}

static  void method_18449( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->product)());
  else   (((const ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->product)();
}

static  void method_18450( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->key)());
  else   (((const ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->key)();
}

static  void method_18451( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->index)());
  else   (((const ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->index)();
}

static  void method_18452( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->hasProductCache)());
  else   (((const ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->hasProductCache)();
}

static  void method_18453( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->isAvailable)());
  else   (((const ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->isAvailable)();
}

static  void method_18454( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->isTransient)());
  else   (((const ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->isTransient)();
}

static  void method_18455( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->refCore)();
  else   (((const ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->refCore)();
}

static  void method_18456( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->Class_Version)());
  else   (((::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >*)o)->Class_Version)();
}

static void constructor_18457( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_3090( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ref<edm::OwnVector<PATFinalState, edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState, edm::ClonePolicy<PATFinalState> >, PATFinalState> > -------------------------------
void __edm__Ref_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_edm__refhelper__FindUsingAdvance_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_s__db_datamem(Reflex::Class*);
void __edm__Ref_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_edm__refhelper__FindUsingAdvance_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ref_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_edm__refhelper__FindUsingAdvance_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_s__datamem_bld(&__edm__Ref_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_edm__refhelper__FindUsingAdvance_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ref_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_edm__refhelper__FindUsingAdvance_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_s__funcmem_bld(&__edm__Ref_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_edm__refhelper__FindUsingAdvance_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_s__db_funcmem);
void __edm__Ref_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_edm__refhelper__FindUsingAdvance_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >"), typeid(::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >), sizeof(::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::Ref<PATFinalStateCollection,PATFinalState,edm::refhelper::FindUsingAdvance<PATFinalStateCollection,PATFinalState> >")
  .AddTypedef(type_18418, Reflex::Literal("edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >::VF"))
  .AddTypedef(type_18420, Reflex::Literal("edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >::VBF"))
  .AddTypedef(type_951, Reflex::Literal("edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >::product_type"))
  .AddTypedef(type_466, Reflex::Literal("edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >::value_type"))
  .AddTypedef(type_466c, Reflex::Literal("edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >::element_type"))
  .AddTypedef(type_16267, Reflex::Literal("edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >::finder_type"))
  .AddTypedef(type_497, Reflex::Literal("edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >::argument_type"))
  .AddTypedef(type_497, Reflex::Literal("edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> >::key_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_69788, type_61015), Reflex::Literal("operator="), operator_18428, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_61015), Reflex::Literal("Ref"), constructor_18429, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ref"), constructor_18430, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45904, type_497, type_2301), Reflex::Literal("Ref"), constructor_18431, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45905, type_497, type_2301), Reflex::Literal("Ref"), constructor_18432, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_61014, type_497, type_2301), Reflex::Literal("Ref"), constructor_18433, 0, "refvector;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45906, type_497, type_2301), Reflex::Literal("Ref"), constructor_18434, 0, "iProduct;iItemKey;iSetNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45907, type_497, type_2301), Reflex::Literal("Ref"), constructor_18435, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417, type_497, type_45418), Reflex::Literal("Ref"), constructor_18436, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417, type_47165, type_497, type_45906), Reflex::Literal("Ref"), constructor_18437, 0, "iProductID;;iItemKey;iProduct", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417), Reflex::Literal("Ref"), constructor_18438, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45903, type_497), Reflex::Literal("Ref"), constructor_18439, 0, "refProd;itemKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ref"), destructor_18440, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45420, type_24095), Reflex::Literal("Ref"), constructor_18457, 0, "iRefCore;iKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3090, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ref_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_edm__refhelper__FindUsingAdvance_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ref_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_edm__refhelper__FindUsingAdvance_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_s__funcmem_bld);
}

//------Delayed data member builder for class Ref<edm::OwnVector<PATFinalState, edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState, edm::ClonePolicy<PATFinalState> >, PATFinalState> > -------------------
void __edm__Ref_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_edm__refhelper__FindUsingAdvance_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9667, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__Ref_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_edm__refhelper__FindUsingAdvance_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_s_, product_), ::Reflex::PRIVATE | ::Reflex::MUTABLE)
  .AddDataMember(type_497, Reflex::Literal("index_"), OffsetOf(__shadow__::__edm__Ref_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_edm__refhelper__FindUsingAdvance_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_s_, index_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Ref<edm::OwnVector<PATFinalState, edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState, edm::ClonePolicy<PATFinalState> >, PATFinalState> > -------------------
void __edm__Ref_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_edm__refhelper__FindUsingAdvance_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11114), Reflex::Literal("operator*"), operator_18441, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_47165), Reflex::Literal("operator->"), operator_18442, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_47165), Reflex::Literal("get"), method_18443, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNull"), method_18444, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNonnull"), method_18445, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("operator!"), operator_18446, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9664), Reflex::Literal("id"), method_18447, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45418), Reflex::Literal("productGetter"), method_18448, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45906), Reflex::Literal("product"), method_18449, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_497), Reflex::Literal("key"), method_18450, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_497), Reflex::Literal("index"), method_18451, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("hasProductCache"), method_18452, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isAvailable"), method_18453, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isTransient"), method_18454, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45420), Reflex::Literal("refCore"), method_18455, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_251), Reflex::Literal("Class_Version"), method_18456, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Wrapper<std::vector<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Photon, pat::Photon>, std::allocator<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Photon, pat::Photon> > > > -------------------------------
static void constructor_52557( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >();
}

static void constructor_52558( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >(*(::std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >(*(::std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >*)arg[0]);
}

static void destructor_52559(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >*)o)->::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >::~Wrapper)();
}
static  void method_52560( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >*)o)->product)();
}

static  void operator_52561( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >*)o)->operator->)();
}

static  void method_52562( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >*)o)->productTypeInfo)();
}

static  void method_52563( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >*)o)->typeInfo)();
}

static void constructor_52564( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)arg[0]);
}

static  void method_52565( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >*)o)->getInterface)();
}

static  void method_52566( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_52567( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_52568( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_52569( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >*)o)->dynamicTypeInfo)();
}

static  void method_52570( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >*)o)->isPresent)();
}

static  void method_52571( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9142( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Photon, pat::Photon>, std::allocator<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Photon, pat::Photon> > > > -------------------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >"), typeid(::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >), sizeof(::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATMuMuPhoPhoFinalStateCollection>")
  .AddTypedef(type_3307, Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >::value_type"))
  .AddTypedef(type_3307, Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_52557, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4177), Reflex::Literal("Wrapper"), constructor_52558, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_52559, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85003), Reflex::Literal("Wrapper"), constructor_52564, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9142, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Photon, pat::Photon>, std::allocator<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Photon, pat::Photon> > > > -------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3307, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Photon, pat::Photon>, std::allocator<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Photon, pat::Photon> > > > -------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85002), Reflex::Literal("product"), method_52560, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85002), Reflex::Literal("operator->"), operator_52561, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_52562, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_52563, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85004), Reflex::Literal("getInterface"), method_52565, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_52566, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_52567, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_52568, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_52569, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_52570, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_52571, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Photon, pat::Photon> > -------------------------------
static void constructor_52578( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >();
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >();
}

static void constructor_52579( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >(*(::std::auto_ptr<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >(*(::std::auto_ptr<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)arg[0]);
}

static void destructor_52580(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >::~Wrapper)();
}
static  void method_52581( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->product)();
}

static  void operator_52582( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->operator->)();
}

static  void method_52583( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->productTypeInfo)();
}

static  void method_52584( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->typeInfo)();
}

static void constructor_52585( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >((::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >((::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon>*)arg[0]);
}

static  void method_52586( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->getInterface)();
}

static  void method_52587( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_52588( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_52589( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_52590( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->dynamicTypeInfo)();
}

static  void method_52591( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->isPresent)();
}

static  void method_52592( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9143( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Photon, pat::Photon> > -------------------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s__datamem_bld(&__edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s__funcmem_bld(&__edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s__db_funcmem);
void __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >"), typeid(::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >), sizeof(::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATMuMuPhoPhoFinalState>")
  .AddTypedef(type_2525, Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >::value_type"))
  .AddTypedef(type_2525, Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_52578, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4178), Reflex::Literal("Wrapper"), constructor_52579, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_52580, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18959), Reflex::Literal("Wrapper"), constructor_52585, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9143, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Photon, pat::Photon> > -------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2525, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Photon, pat::Photon> > -------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18961), Reflex::Literal("product"), method_52581, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18961), Reflex::Literal("operator->"), operator_52582, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_52583, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_52584, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85007), Reflex::Literal("getInterface"), method_52586, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_52587, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_52588, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_52589, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_52590, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_52591, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_52592, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Tau, pat::Tau>, std::allocator<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Tau, pat::Tau> > > > -------------------------------
static void constructor_52599( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >();
}

static void constructor_52600( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >(*(::std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >(*(::std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >*)arg[0]);
}

static void destructor_52601(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >*)o)->::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >::~Wrapper)();
}
static  void method_52602( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >*)o)->product)();
}

static  void operator_52603( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >*)o)->operator->)();
}

static  void method_52604( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >*)o)->productTypeInfo)();
}

static  void method_52605( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >*)o)->typeInfo)();
}

static void constructor_52606( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)arg[0]);
}

static  void method_52607( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >*)o)->getInterface)();
}

static  void method_52608( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_52609( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_52610( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_52611( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >*)o)->dynamicTypeInfo)();
}

static  void method_52612( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >*)o)->isPresent)();
}

static  void method_52613( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9144( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Tau, pat::Tau>, std::allocator<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Tau, pat::Tau> > > > -------------------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >"), typeid(::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >), sizeof(::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATMuMuTauTauFinalStateCollection>")
  .AddTypedef(type_1605, Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >::value_type"))
  .AddTypedef(type_1605, Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_52599, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4179), Reflex::Literal("Wrapper"), constructor_52600, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_52601, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85011), Reflex::Literal("Wrapper"), constructor_52606, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9144, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Tau, pat::Tau>, std::allocator<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Tau, pat::Tau> > > > -------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1605, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Tau, pat::Tau>, std::allocator<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Tau, pat::Tau> > > > -------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85010), Reflex::Literal("product"), method_52602, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85010), Reflex::Literal("operator->"), operator_52603, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_52604, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_52605, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85012), Reflex::Literal("getInterface"), method_52607, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_52608, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_52609, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_52610, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_52611, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_52612, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_52613, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Tau, pat::Tau> > -------------------------------
static void constructor_52620( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >();
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >();
}

static void constructor_52621( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >(*(::std::auto_ptr<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >(*(::std::auto_ptr<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)arg[0]);
}

static void destructor_52622(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >::~Wrapper)();
}
static  void method_52623( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->product)();
}

static  void operator_52624( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->operator->)();
}

static  void method_52625( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->productTypeInfo)();
}

static  void method_52626( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->typeInfo)();
}

static void constructor_52627( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >((::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >((::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau>*)arg[0]);
}

static  void method_52628( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->getInterface)();
}

static  void method_52629( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_52630( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_52631( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_52632( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->dynamicTypeInfo)();
}

static  void method_52633( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->isPresent)();
}

static  void method_52634( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9145( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Tau, pat::Tau> > -------------------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s__datamem_bld(&__edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s__funcmem_bld(&__edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s__db_funcmem);
void __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >"), typeid(::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >), sizeof(::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATMuMuTauTauFinalState>")
  .AddTypedef(type_1959, Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >::value_type"))
  .AddTypedef(type_1959, Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_52620, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4180), Reflex::Literal("Wrapper"), constructor_52621, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_52622, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12750), Reflex::Literal("Wrapper"), constructor_52627, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9145, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Tau, pat::Tau> > -------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1959, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Tau, pat::Tau> > -------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12752), Reflex::Literal("product"), method_52623, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12752), Reflex::Literal("operator->"), operator_52624, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_52625, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_52626, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85015), Reflex::Literal("getInterface"), method_52628, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_52629, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_52630, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_52631, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_52632, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_52633, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_52634, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Photon>, std::allocator<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Photon> > > > -------------------------------
static void constructor_52641( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >();
}

static void constructor_52642( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >(*(::std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >(*(::std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >*)arg[0]);
}

static void destructor_52643(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >*)o)->::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >::~Wrapper)();
}
static  void method_52644( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >*)o)->product)();
}

static  void operator_52645( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >*)o)->operator->)();
}

static  void method_52646( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >*)o)->productTypeInfo)();
}

static  void method_52647( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >*)o)->typeInfo)();
}

static void constructor_52648( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)arg[0]);
}

static  void method_52649( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >*)o)->getInterface)();
}

static  void method_52650( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_52651( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_52652( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_52653( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >*)o)->dynamicTypeInfo)();
}

static  void method_52654( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >*)o)->isPresent)();
}

static  void method_52655( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9146( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Photon>, std::allocator<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Photon> > > > -------------------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >"), typeid(::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >), sizeof(::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATMuMuMuPhoFinalStateCollection>")
  .AddTypedef(type_2341, Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >::value_type"))
  .AddTypedef(type_2341, Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_52641, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4181), Reflex::Literal("Wrapper"), constructor_52642, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_52643, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85019), Reflex::Literal("Wrapper"), constructor_52648, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9146, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Photon>, std::allocator<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Photon> > > > -------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2341, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Photon>, std::allocator<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Photon> > > > -------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85018), Reflex::Literal("product"), method_52644, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85018), Reflex::Literal("operator->"), operator_52645, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_52646, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_52647, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85020), Reflex::Literal("getInterface"), method_52649, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_52650, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_52651, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_52652, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_52653, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_52654, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_52655, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Photon> > -------------------------------
static void constructor_52662( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >();
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >();
}

static void constructor_52663( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >(*(::std::auto_ptr<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >(*(::std::auto_ptr<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)arg[0]);
}

static void destructor_52664(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >::~Wrapper)();
}
static  void method_52665( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->product)();
}

static  void operator_52666( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->operator->)();
}

static  void method_52667( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->productTypeInfo)();
}

static  void method_52668( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->typeInfo)();
}

static void constructor_52669( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >((::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >((::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon>*)arg[0]);
}

static  void method_52670( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->getInterface)();
}

static  void method_52671( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_52672( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_52673( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_52674( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->dynamicTypeInfo)();
}

static  void method_52675( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->isPresent)();
}

static  void method_52676( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9147( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Photon> > -------------------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s__datamem_bld(&__edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s__funcmem_bld(&__edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s__db_funcmem);
void __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >"), typeid(::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >), sizeof(::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATMuMuMuPhoFinalState>")
  .AddTypedef(type_164, Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >::value_type"))
  .AddTypedef(type_164, Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_52662, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4182), Reflex::Literal("Wrapper"), constructor_52663, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_52664, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15233), Reflex::Literal("Wrapper"), constructor_52669, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9147, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Photon> > -------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_164, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Photon> > -------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15235), Reflex::Literal("product"), method_52665, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15235), Reflex::Literal("operator->"), operator_52666, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_52667, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_52668, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85023), Reflex::Literal("getInterface"), method_52670, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_52671, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_52672, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_52673, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_52674, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_52675, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_52676, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Tau>, std::allocator<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Tau> > > > -------------------------------
static void constructor_52683( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >();
}

static void constructor_52684( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >(*(::std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >(*(::std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >*)arg[0]);
}

static void destructor_52685(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >*)o)->::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >::~Wrapper)();
}
static  void method_52686( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >*)o)->product)();
}

static  void operator_52687( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >*)o)->operator->)();
}

static  void method_52688( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >*)o)->productTypeInfo)();
}

static  void method_52689( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >*)o)->typeInfo)();
}

static void constructor_52690( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)arg[0]);
}

static  void method_52691( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >*)o)->getInterface)();
}

static  void method_52692( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_52693( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_52694( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_52695( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >*)o)->dynamicTypeInfo)();
}

static  void method_52696( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >*)o)->isPresent)();
}

static  void method_52697( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9148( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Tau>, std::allocator<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Tau> > > > -------------------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >"), typeid(::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >), sizeof(::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATMuMuMuTauFinalStateCollection>")
  .AddTypedef(type_1303, Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >::value_type"))
  .AddTypedef(type_1303, Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_52683, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4183), Reflex::Literal("Wrapper"), constructor_52684, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_52685, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85027), Reflex::Literal("Wrapper"), constructor_52690, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9148, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Tau>, std::allocator<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Tau> > > > -------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1303, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Tau>, std::allocator<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Tau> > > > -------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85026), Reflex::Literal("product"), method_52686, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85026), Reflex::Literal("operator->"), operator_52687, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_52688, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_52689, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85028), Reflex::Literal("getInterface"), method_52691, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_52692, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_52693, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_52694, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_52695, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_52696, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_52697, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Tau> > -------------------------------
static void constructor_52704( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >();
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >();
}

static void constructor_52705( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >(*(::std::auto_ptr<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >(*(::std::auto_ptr<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)arg[0]);
}

static void destructor_52706(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >::~Wrapper)();
}
static  void method_52707( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->product)();
}

static  void operator_52708( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->operator->)();
}

static  void method_52709( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->productTypeInfo)();
}

static  void method_52710( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->typeInfo)();
}

static void constructor_52711( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >((::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >((::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau>*)arg[0]);
}

static  void method_52712( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->getInterface)();
}

static  void method_52713( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_52714( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_52715( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_52716( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->dynamicTypeInfo)();
}

static  void method_52717( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->isPresent)();
}

static  void method_52718( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9149( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Tau> > -------------------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s__datamem_bld(&__edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s__funcmem_bld(&__edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s__db_funcmem);
void __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >"), typeid(::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >), sizeof(::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATMuMuMuTauFinalState>")
  .AddTypedef(type_308, Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >::value_type"))
  .AddTypedef(type_308, Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_52704, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4184), Reflex::Literal("Wrapper"), constructor_52705, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_52706, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11951), Reflex::Literal("Wrapper"), constructor_52711, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9149, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Tau> > -------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_308, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Tau> > -------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11953), Reflex::Literal("product"), method_52707, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11953), Reflex::Literal("operator->"), operator_52708, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_52709, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_52710, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85031), Reflex::Literal("getInterface"), method_52712, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_52713, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_52714, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_52715, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_52716, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_52717, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_52718, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Muon>, std::allocator<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Muon> > > > -------------------------------
static void constructor_52725( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >();
}

static void constructor_52726( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >(*(::std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >(*(::std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >*)arg[0]);
}

static void destructor_52727(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >*)o)->::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >::~Wrapper)();
}
static  void method_52728( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >*)o)->product)();
}

static  void operator_52729( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >*)o)->operator->)();
}

static  void method_52730( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >*)o)->productTypeInfo)();
}

static  void method_52731( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >*)o)->typeInfo)();
}

static void constructor_52732( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >((::std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)arg[0]);
}

static  void method_52733( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >*)o)->getInterface)();
}

static  void method_52734( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_52735( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_52736( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_52737( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >*)o)->dynamicTypeInfo)();
}

static  void method_52738( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >*)o)->isPresent)();
}

static  void method_52739( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9150( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Muon>, std::allocator<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Muon> > > > -------------------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >"), typeid(::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >), sizeof(::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATMuMuMuMuFinalStateCollection>")
  .AddTypedef(type_2311, Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >::value_type"))
  .AddTypedef(type_2311, Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_52725, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4185), Reflex::Literal("Wrapper"), constructor_52726, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_52727, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85035), Reflex::Literal("Wrapper"), constructor_52732, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9150, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Muon>, std::allocator<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Muon> > > > -------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2311, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Muon>, std::allocator<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Muon> > > > -------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85034), Reflex::Literal("product"), method_52728, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85034), Reflex::Literal("operator->"), operator_52729, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_52730, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_52731, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85036), Reflex::Literal("getInterface"), method_52733, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_52734, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_52735, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_52736, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_52737, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_52738, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_52739, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Muon> > -------------------------------
static void constructor_52746( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >();
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >();
}

static void constructor_52747( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >(*(::std::auto_ptr<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >(*(::std::auto_ptr<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)arg[0]);
}

static void destructor_52748(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >::~Wrapper)();
}
static  void method_52749( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->product)();
}

static  void operator_52750( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->operator->)();
}

static  void method_52751( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->productTypeInfo)();
}

static  void method_52752( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->typeInfo)();
}

static void constructor_52753( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >((::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >((::PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon>*)arg[0]);
}

static  void method_52754( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->getInterface)();
}

static  void method_52755( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_52756( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_52757( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_52758( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->dynamicTypeInfo)();
}

static  void method_52759( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->isPresent)();
}

static  void method_52760( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9151( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Muon> > -------------------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s__datamem_bld(&__edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s__funcmem_bld(&__edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s__db_funcmem);
void __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >"), typeid(::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >), sizeof(::edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATMuMuMuMuFinalState>")
  .AddTypedef(type_2807, Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >::value_type"))
  .AddTypedef(type_2807, Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_52746, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4186), Reflex::Literal("Wrapper"), constructor_52747, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_52748, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15095), Reflex::Literal("Wrapper"), constructor_52753, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9151, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Muon> > -------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2807, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATQuadFinalStateT<pat::Muon, pat::Muon, pat::Muon, pat::Muon> > -------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15097), Reflex::Literal("product"), method_52749, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15097), Reflex::Literal("operator->"), operator_52750, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_52751, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_52752, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85039), Reflex::Literal("getInterface"), method_52754, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_52755, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_52756, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_52757, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_52758, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_52759, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_52760, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Photon, pat::Photon>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Photon, pat::Photon> > > > -------------------------------
static void constructor_52767( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >();
}

static void constructor_52768( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >(*(::std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >(*(::std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >*)arg[0]);
}

static void destructor_52769(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >*)o)->::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >::~Wrapper)();
}
static  void method_52770( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >*)o)->product)();
}

static  void operator_52771( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >*)o)->operator->)();
}

static  void method_52772( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >*)o)->productTypeInfo)();
}

static  void method_52773( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >*)o)->typeInfo)();
}

static void constructor_52774( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)arg[0]);
}

static  void method_52775( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >*)o)->getInterface)();
}

static  void method_52776( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_52777( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_52778( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_52779( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >*)o)->dynamicTypeInfo)();
}

static  void method_52780( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >*)o)->isPresent)();
}

static  void method_52781( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9152( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Photon, pat::Photon>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Photon, pat::Photon> > > > -------------------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >"), typeid(::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >), sizeof(::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecMuPhoPhoFinalStateCollection>")
  .AddTypedef(type_1852, Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >::value_type"))
  .AddTypedef(type_1852, Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_52767, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4187), Reflex::Literal("Wrapper"), constructor_52768, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_52769, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85043), Reflex::Literal("Wrapper"), constructor_52774, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9152, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Photon, pat::Photon>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Photon, pat::Photon> > > > -------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1852, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Photon, pat::Photon>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Photon, pat::Photon> > > > -------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85042), Reflex::Literal("product"), method_52770, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85042), Reflex::Literal("operator->"), operator_52771, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_52772, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_52773, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85044), Reflex::Literal("getInterface"), method_52775, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_52776, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_52777, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_52778, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_52779, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_52780, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_52781, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Photon, pat::Photon> > -------------------------------
static void constructor_52788( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >();
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >();
}

static void constructor_52789( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >(*(::std::auto_ptr<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >(*(::std::auto_ptr<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)arg[0]);
}

static void destructor_52790(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >::~Wrapper)();
}
static  void method_52791( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->product)();
}

static  void operator_52792( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->operator->)();
}

static  void method_52793( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->productTypeInfo)();
}

static  void method_52794( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->typeInfo)();
}

static void constructor_52795( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >((::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >((::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon>*)arg[0]);
}

static  void method_52796( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->getInterface)();
}

static  void method_52797( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_52798( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_52799( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_52800( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->dynamicTypeInfo)();
}

static  void method_52801( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->isPresent)();
}

static  void method_52802( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9153( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Photon, pat::Photon> > -------------------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s__datamem_bld(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s__funcmem_bld(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s__db_funcmem);
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >"), typeid(::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >), sizeof(::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecMuPhoPhoFinalState>")
  .AddTypedef(type_2808, Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >::value_type"))
  .AddTypedef(type_2808, Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_52788, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4188), Reflex::Literal("Wrapper"), constructor_52789, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_52790, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13507), Reflex::Literal("Wrapper"), constructor_52795, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9153, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Photon, pat::Photon> > -------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2808, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Photon, pat::Photon> > -------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13509), Reflex::Literal("product"), method_52791, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13509), Reflex::Literal("operator->"), operator_52792, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_52793, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_52794, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85047), Reflex::Literal("getInterface"), method_52796, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_52797, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_52798, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_52799, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_52800, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_52801, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_52802, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Tau, pat::Tau>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Tau, pat::Tau> > > > -------------------------------
static void constructor_52809( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >();
}

static void constructor_52810( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >(*(::std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >(*(::std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >*)arg[0]);
}

static void destructor_52811(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >*)o)->::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >::~Wrapper)();
}
static  void method_52812( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >*)o)->product)();
}

static  void operator_52813( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >*)o)->operator->)();
}

static  void method_52814( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >*)o)->productTypeInfo)();
}

static  void method_52815( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >*)o)->typeInfo)();
}

static void constructor_52816( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)arg[0]);
}

static  void method_52817( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >*)o)->getInterface)();
}

static  void method_52818( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_52819( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_52820( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_52821( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >*)o)->dynamicTypeInfo)();
}

static  void method_52822( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >*)o)->isPresent)();
}

static  void method_52823( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9154( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Tau, pat::Tau>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Tau, pat::Tau> > > > -------------------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >"), typeid(::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >), sizeof(::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecMuTauTauFinalStateCollection>")
  .AddTypedef(type_3101, Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >::value_type"))
  .AddTypedef(type_3101, Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_52809, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4189), Reflex::Literal("Wrapper"), constructor_52810, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_52811, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85051), Reflex::Literal("Wrapper"), constructor_52816, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9154, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Tau, pat::Tau>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Tau, pat::Tau> > > > -------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3101, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Tau, pat::Tau>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Tau, pat::Tau> > > > -------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85050), Reflex::Literal("product"), method_52812, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85050), Reflex::Literal("operator->"), operator_52813, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_52814, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_52815, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85052), Reflex::Literal("getInterface"), method_52817, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_52818, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_52819, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_52820, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_52821, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_52822, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_52823, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Tau, pat::Tau> > -------------------------------
static void constructor_52830( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >();
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >();
}

static void constructor_52831( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >(*(::std::auto_ptr<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >(*(::std::auto_ptr<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)arg[0]);
}

static void destructor_52832(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >::~Wrapper)();
}
static  void method_52833( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->product)();
}

static  void operator_52834( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->operator->)();
}

static  void method_52835( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->productTypeInfo)();
}

static  void method_52836( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->typeInfo)();
}

static void constructor_52837( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >((::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >((::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau>*)arg[0]);
}

static  void method_52838( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->getInterface)();
}

static  void method_52839( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_52840( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_52841( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_52842( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->dynamicTypeInfo)();
}

static  void method_52843( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->isPresent)();
}

static  void method_52844( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9155( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Tau, pat::Tau> > -------------------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s__datamem_bld(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s__funcmem_bld(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s__db_funcmem);
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >"), typeid(::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >), sizeof(::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecMuTauTauFinalState>")
  .AddTypedef(type_1022, Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >::value_type"))
  .AddTypedef(type_1022, Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_52830, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4190), Reflex::Literal("Wrapper"), constructor_52831, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_52832, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18463), Reflex::Literal("Wrapper"), constructor_52837, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9155, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Tau, pat::Tau> > -------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1022, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Tau, pat::Tau> > -------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18465), Reflex::Literal("product"), method_52833, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18465), Reflex::Literal("operator->"), operator_52834, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_52835, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_52836, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85055), Reflex::Literal("getInterface"), method_52838, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_52839, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_52840, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_52841, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_52842, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_52843, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_52844, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Photon>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Photon> > > > -------------------------------
static void constructor_52851( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >();
}

static void constructor_52852( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >(*(::std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >(*(::std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >*)arg[0]);
}

static void destructor_52853(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >*)o)->::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >::~Wrapper)();
}
static  void method_52854( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >*)o)->product)();
}

static  void operator_52855( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >*)o)->operator->)();
}

static  void method_52856( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >*)o)->productTypeInfo)();
}

static  void method_52857( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >*)o)->typeInfo)();
}

static void constructor_52858( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)arg[0]);
}

static  void method_52859( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >*)o)->getInterface)();
}

static  void method_52860( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_52861( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_52862( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_52863( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >*)o)->dynamicTypeInfo)();
}

static  void method_52864( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >*)o)->isPresent)();
}

static  void method_52865( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9156( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Photon>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Photon> > > > -------------------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >"), typeid(::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >), sizeof(::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecMuMuPhoFinalStateCollection>")
  .AddTypedef(type_2163, Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >::value_type"))
  .AddTypedef(type_2163, Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_52851, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4191), Reflex::Literal("Wrapper"), constructor_52852, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_52853, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85059), Reflex::Literal("Wrapper"), constructor_52858, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9156, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Photon>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Photon> > > > -------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2163, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Photon>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Photon> > > > -------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85058), Reflex::Literal("product"), method_52854, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85058), Reflex::Literal("operator->"), operator_52855, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_52856, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_52857, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85060), Reflex::Literal("getInterface"), method_52859, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_52860, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_52861, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_52862, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_52863, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_52864, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_52865, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Photon> > -------------------------------
static void constructor_52872( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >();
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >();
}

static void constructor_52873( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >(*(::std::auto_ptr<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >(*(::std::auto_ptr<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)arg[0]);
}

static void destructor_52874(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >::~Wrapper)();
}
static  void method_52875( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->product)();
}

static  void operator_52876( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->operator->)();
}

static  void method_52877( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->productTypeInfo)();
}

static  void method_52878( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->typeInfo)();
}

static void constructor_52879( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >((::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >((::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon>*)arg[0]);
}

static  void method_52880( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->getInterface)();
}

static  void method_52881( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_52882( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_52883( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_52884( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->dynamicTypeInfo)();
}

static  void method_52885( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->isPresent)();
}

static  void method_52886( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9157( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Photon> > -------------------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s__datamem_bld(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s__funcmem_bld(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s__db_funcmem);
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >"), typeid(::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >), sizeof(::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecMuMuPhoFinalState>")
  .AddTypedef(type_2809, Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >::value_type"))
  .AddTypedef(type_2809, Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_52872, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4192), Reflex::Literal("Wrapper"), constructor_52873, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_52874, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14494), Reflex::Literal("Wrapper"), constructor_52879, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9157, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Photon> > -------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2809, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Photon> > -------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14496), Reflex::Literal("product"), method_52875, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14496), Reflex::Literal("operator->"), operator_52876, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_52877, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_52878, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85063), Reflex::Literal("getInterface"), method_52880, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_52881, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_52882, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_52883, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_52884, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_52885, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_52886, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Tau>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Tau> > > > -------------------------------
static void constructor_52893( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >();
}

static void constructor_52894( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >(*(::std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >(*(::std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >*)arg[0]);
}

static void destructor_52895(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >*)o)->::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >::~Wrapper)();
}
static  void method_52896( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >*)o)->product)();
}

static  void operator_52897( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >*)o)->operator->)();
}

static  void method_52898( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >*)o)->productTypeInfo)();
}

static  void method_52899( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >*)o)->typeInfo)();
}

static void constructor_52900( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)arg[0]);
}

static  void method_52901( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >*)o)->getInterface)();
}

static  void method_52902( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_52903( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_52904( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_52905( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >*)o)->dynamicTypeInfo)();
}

static  void method_52906( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >*)o)->isPresent)();
}

static  void method_52907( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9158( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Tau>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Tau> > > > -------------------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >"), typeid(::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >), sizeof(::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecMuMuTauFinalStateCollection>")
  .AddTypedef(type_1381, Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >::value_type"))
  .AddTypedef(type_1381, Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_52893, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4193), Reflex::Literal("Wrapper"), constructor_52894, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_52895, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85067), Reflex::Literal("Wrapper"), constructor_52900, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9158, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Tau>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Tau> > > > -------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1381, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Tau>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Tau> > > > -------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85066), Reflex::Literal("product"), method_52896, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85066), Reflex::Literal("operator->"), operator_52897, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_52898, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_52899, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85068), Reflex::Literal("getInterface"), method_52901, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_52902, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_52903, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_52904, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_52905, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_52906, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_52907, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Tau> > -------------------------------
static void constructor_52914( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >();
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >();
}

static void constructor_52915( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >(*(::std::auto_ptr<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >(*(::std::auto_ptr<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)arg[0]);
}

static void destructor_52916(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >::~Wrapper)();
}
static  void method_52917( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->product)();
}

static  void operator_52918( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->operator->)();
}

static  void method_52919( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->productTypeInfo)();
}

static  void method_52920( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->typeInfo)();
}

static void constructor_52921( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >((::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >((::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau>*)arg[0]);
}

static  void method_52922( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->getInterface)();
}

static  void method_52923( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_52924( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_52925( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_52926( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->dynamicTypeInfo)();
}

static  void method_52927( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->isPresent)();
}

static  void method_52928( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9159( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Tau> > -------------------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s__datamem_bld(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s__funcmem_bld(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s__db_funcmem);
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >"), typeid(::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >), sizeof(::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecMuMuTauFinalState>")
  .AddTypedef(type_2810, Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >::value_type"))
  .AddTypedef(type_2810, Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_52914, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4194), Reflex::Literal("Wrapper"), constructor_52915, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_52916, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12140), Reflex::Literal("Wrapper"), constructor_52921, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9159, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Tau> > -------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2810, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Tau> > -------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12142), Reflex::Literal("product"), method_52917, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12142), Reflex::Literal("operator->"), operator_52918, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_52919, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_52920, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85071), Reflex::Literal("getInterface"), method_52922, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_52923, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_52924, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_52925, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_52926, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_52927, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_52928, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Muon>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Muon> > > > -------------------------------
static void constructor_52935( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >();
}

static void constructor_52936( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >(*(::std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >(*(::std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >*)arg[0]);
}

static void destructor_52937(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >*)o)->::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >::~Wrapper)();
}
static  void method_52938( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >*)o)->product)();
}

static  void operator_52939( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >*)o)->operator->)();
}

static  void method_52940( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >*)o)->productTypeInfo)();
}

static  void method_52941( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >*)o)->typeInfo)();
}

static void constructor_52942( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)arg[0]);
}

static  void method_52943( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >*)o)->getInterface)();
}

static  void method_52944( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_52945( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_52946( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_52947( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >*)o)->dynamicTypeInfo)();
}

static  void method_52948( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >*)o)->isPresent)();
}

static  void method_52949( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9160( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Muon>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Muon> > > > -------------------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >"), typeid(::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >), sizeof(::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecMuMuMuFinalStateCollection>")
  .AddTypedef(type_2945, Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >::value_type"))
  .AddTypedef(type_2945, Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_52935, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4195), Reflex::Literal("Wrapper"), constructor_52936, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_52937, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85075), Reflex::Literal("Wrapper"), constructor_52942, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9160, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Muon>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Muon> > > > -------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2945, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Muon>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Muon> > > > -------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85074), Reflex::Literal("product"), method_52938, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85074), Reflex::Literal("operator->"), operator_52939, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_52940, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_52941, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85076), Reflex::Literal("getInterface"), method_52943, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_52944, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_52945, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_52946, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_52947, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_52948, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_52949, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Muon> > -------------------------------
static void constructor_52956( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >();
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >();
}

static void constructor_52957( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >(*(::std::auto_ptr<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >(*(::std::auto_ptr<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)arg[0]);
}

static void destructor_52958(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >::~Wrapper)();
}
static  void method_52959( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->product)();
}

static  void operator_52960( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->operator->)();
}

static  void method_52961( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->productTypeInfo)();
}

static  void method_52962( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->typeInfo)();
}

static void constructor_52963( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >((::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >((::PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon>*)arg[0]);
}

static  void method_52964( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->getInterface)();
}

static  void method_52965( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_52966( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_52967( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_52968( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->dynamicTypeInfo)();
}

static  void method_52969( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->isPresent)();
}

static  void method_52970( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9161( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Muon> > -------------------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s__datamem_bld(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s__funcmem_bld(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s__db_funcmem);
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >"), typeid(::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >), sizeof(::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecMuMuMuFinalState>")
  .AddTypedef(type_113, Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >::value_type"))
  .AddTypedef(type_113, Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_52956, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4196), Reflex::Literal("Wrapper"), constructor_52957, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_52958, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17311), Reflex::Literal("Wrapper"), constructor_52963, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9161, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Muon> > -------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_113, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Muon, pat::Muon, pat::Muon> > -------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17313), Reflex::Literal("product"), method_52959, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17313), Reflex::Literal("operator->"), operator_52960, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_52961, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_52962, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85079), Reflex::Literal("getInterface"), method_52964, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_52965, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_52966, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_52967, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_52968, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_52969, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_52970, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Photon, pat::Photon>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Photon, pat::Photon> > > > -------------------------------
static void constructor_52977( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >();
}

static void constructor_52978( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >(*(::std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >(*(::std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >*)arg[0]);
}

static void destructor_52979(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >*)o)->::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >::~Wrapper)();
}
static  void method_52980( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >*)o)->product)();
}

static  void operator_52981( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >*)o)->operator->)();
}

static  void method_52982( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >*)o)->productTypeInfo)();
}

static  void method_52983( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >*)o)->typeInfo)();
}

static void constructor_52984( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)arg[0]);
}

static  void method_52985( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >*)o)->getInterface)();
}

static  void method_52986( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_52987( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_52988( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_52989( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >*)o)->dynamicTypeInfo)();
}

static  void method_52990( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >*)o)->isPresent)();
}

static  void method_52991( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9162( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Photon, pat::Photon>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Photon, pat::Photon> > > > -------------------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >"), typeid(::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >), sizeof(::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecElecPhoPhoFinalStateCollection>")
  .AddTypedef(type_670, Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >::value_type"))
  .AddTypedef(type_670, Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_52977, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4197), Reflex::Literal("Wrapper"), constructor_52978, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_52979, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85083), Reflex::Literal("Wrapper"), constructor_52984, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9162, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Photon, pat::Photon>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Photon, pat::Photon> > > > -------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_670, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Photon, pat::Photon>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Photon, pat::Photon> > > > -------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85082), Reflex::Literal("product"), method_52980, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85082), Reflex::Literal("operator->"), operator_52981, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_52982, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_52983, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85084), Reflex::Literal("getInterface"), method_52985, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_52986, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_52987, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_52988, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_52989, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_52990, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_52991, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Photon, pat::Photon> > -------------------------------
static void constructor_52998( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >();
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >();
}

static void constructor_52999( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >(*(::std::auto_ptr<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >(*(::std::auto_ptr<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)arg[0]);
}

static void destructor_53000(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >::~Wrapper)();
}
static  void method_53001( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->product)();
}

static  void operator_53002( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->operator->)();
}

static  void method_53003( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->productTypeInfo)();
}

static  void method_53004( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->typeInfo)();
}

static void constructor_53005( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon>*)arg[0]);
}

static  void method_53006( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->getInterface)();
}

static  void method_53007( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53008( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53009( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53010( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->dynamicTypeInfo)();
}

static  void method_53011( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->isPresent)();
}

static  void method_53012( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9163( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Photon, pat::Photon> > -------------------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s__datamem_bld(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s__funcmem_bld(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s__db_funcmem);
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >"), typeid(::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >), sizeof(::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecElecPhoPhoFinalState>")
  .AddTypedef(type_473, Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >::value_type"))
  .AddTypedef(type_473, Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_52998, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4198), Reflex::Literal("Wrapper"), constructor_52999, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53000, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10025), Reflex::Literal("Wrapper"), constructor_53005, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9163, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Photon, pat::Photon> > -------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_473, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Photon, pat::Photon> > -------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10027), Reflex::Literal("product"), method_53001, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10027), Reflex::Literal("operator->"), operator_53002, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53003, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53004, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85087), Reflex::Literal("getInterface"), method_53006, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53007, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53008, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53009, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53010, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53011, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53012, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Tau, pat::Tau>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Tau, pat::Tau> > > > -------------------------------
static void constructor_53019( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >();
}

static void constructor_53020( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >(*(::std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >(*(::std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >*)arg[0]);
}

static void destructor_53021(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >*)o)->::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >::~Wrapper)();
}
static  void method_53022( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >*)o)->product)();
}

static  void operator_53023( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >*)o)->operator->)();
}

static  void method_53024( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >*)o)->productTypeInfo)();
}

static  void method_53025( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >*)o)->typeInfo)();
}

static void constructor_53026( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)arg[0]);
}

static  void method_53027( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >*)o)->getInterface)();
}

static  void method_53028( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53029( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53030( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53031( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >*)o)->dynamicTypeInfo)();
}

static  void method_53032( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >*)o)->isPresent)();
}

static  void method_53033( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9164( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Tau, pat::Tau>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Tau, pat::Tau> > > > -------------------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >"), typeid(::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >), sizeof(::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecElecTauTauFinalStateCollection>")
  .AddTypedef(type_1982, Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >::value_type"))
  .AddTypedef(type_1982, Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53019, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4199), Reflex::Literal("Wrapper"), constructor_53020, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53021, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85091), Reflex::Literal("Wrapper"), constructor_53026, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9164, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Tau, pat::Tau>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Tau, pat::Tau> > > > -------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1982, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Tau, pat::Tau>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Tau, pat::Tau> > > > -------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85090), Reflex::Literal("product"), method_53022, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85090), Reflex::Literal("operator->"), operator_53023, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53024, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53025, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85092), Reflex::Literal("getInterface"), method_53027, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53028, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53029, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53030, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53031, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53032, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53033, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Tau, pat::Tau> > -------------------------------
static void constructor_53040( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >();
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >();
}

static void constructor_53041( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >(*(::std::auto_ptr<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >(*(::std::auto_ptr<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)arg[0]);
}

static void destructor_53042(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >::~Wrapper)();
}
static  void method_53043( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->product)();
}

static  void operator_53044( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->operator->)();
}

static  void method_53045( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->productTypeInfo)();
}

static  void method_53046( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->typeInfo)();
}

static void constructor_53047( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau>*)arg[0]);
}

static  void method_53048( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->getInterface)();
}

static  void method_53049( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53050( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53051( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53052( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->dynamicTypeInfo)();
}

static  void method_53053( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->isPresent)();
}

static  void method_53054( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9165( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Tau, pat::Tau> > -------------------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s__datamem_bld(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s__funcmem_bld(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s__db_funcmem);
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >"), typeid(::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >), sizeof(::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecElecTauTauFinalState>")
  .AddTypedef(type_956, Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >::value_type"))
  .AddTypedef(type_956, Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53040, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4200), Reflex::Literal("Wrapper"), constructor_53041, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53042, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14041), Reflex::Literal("Wrapper"), constructor_53047, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9165, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Tau, pat::Tau> > -------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_956, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Tau, pat::Tau> > -------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14043), Reflex::Literal("product"), method_53043, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14043), Reflex::Literal("operator->"), operator_53044, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53045, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53046, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85095), Reflex::Literal("getInterface"), method_53048, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53049, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53050, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53051, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53052, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53053, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53054, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Photon>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Photon> > > > -------------------------------
static void constructor_53061( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >();
}

static void constructor_53062( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >(*(::std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >(*(::std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >*)arg[0]);
}

static void destructor_53063(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >*)o)->::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >::~Wrapper)();
}
static  void method_53064( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >*)o)->product)();
}

static  void operator_53065( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >*)o)->operator->)();
}

static  void method_53066( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >*)o)->productTypeInfo)();
}

static  void method_53067( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >*)o)->typeInfo)();
}

static void constructor_53068( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)arg[0]);
}

static  void method_53069( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >*)o)->getInterface)();
}

static  void method_53070( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53071( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53072( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53073( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >*)o)->dynamicTypeInfo)();
}

static  void method_53074( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >*)o)->isPresent)();
}

static  void method_53075( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9166( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Photon>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Photon> > > > -------------------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >"), typeid(::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >), sizeof(::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecElecMuPhoFinalStateCollection>")
  .AddTypedef(type_1850, Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >::value_type"))
  .AddTypedef(type_1850, Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53061, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4201), Reflex::Literal("Wrapper"), constructor_53062, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53063, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85099), Reflex::Literal("Wrapper"), constructor_53068, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9166, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Photon>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Photon> > > > -------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1850, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Photon>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Photon> > > > -------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85098), Reflex::Literal("product"), method_53064, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85098), Reflex::Literal("operator->"), operator_53065, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53066, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53067, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85100), Reflex::Literal("getInterface"), method_53069, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53070, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53071, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53072, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53073, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53074, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53075, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Photon> > -------------------------------
static void constructor_53082( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >();
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >();
}

static void constructor_53083( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >(*(::std::auto_ptr<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >(*(::std::auto_ptr<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)arg[0]);
}

static void destructor_53084(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >::~Wrapper)();
}
static  void method_53085( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->product)();
}

static  void operator_53086( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->operator->)();
}

static  void method_53087( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->productTypeInfo)();
}

static  void method_53088( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->typeInfo)();
}

static void constructor_53089( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon>*)arg[0]);
}

static  void method_53090( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->getInterface)();
}

static  void method_53091( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53092( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53093( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53094( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->dynamicTypeInfo)();
}

static  void method_53095( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->isPresent)();
}

static  void method_53096( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9167( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Photon> > -------------------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s__datamem_bld(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s__funcmem_bld(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s__db_funcmem);
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >"), typeid(::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >), sizeof(::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecElecMuPhoFinalState>")
  .AddTypedef(type_891, Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >::value_type"))
  .AddTypedef(type_891, Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53082, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4202), Reflex::Literal("Wrapper"), constructor_53083, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53084, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13440), Reflex::Literal("Wrapper"), constructor_53089, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9167, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Photon> > -------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_891, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Photon> > -------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13442), Reflex::Literal("product"), method_53085, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13442), Reflex::Literal("operator->"), operator_53086, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53087, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53088, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85103), Reflex::Literal("getInterface"), method_53090, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53091, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53092, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53093, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53094, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53095, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53096, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Tau>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Tau> > > > -------------------------------
static void constructor_53103( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >();
}

static void constructor_53104( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >(*(::std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >(*(::std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >*)arg[0]);
}

static void destructor_53105(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >*)o)->::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >::~Wrapper)();
}
static  void method_53106( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >*)o)->product)();
}

static  void operator_53107( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >*)o)->operator->)();
}

static  void method_53108( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >*)o)->productTypeInfo)();
}

static  void method_53109( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >*)o)->typeInfo)();
}

static void constructor_53110( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)arg[0]);
}

static  void method_53111( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >*)o)->getInterface)();
}

static  void method_53112( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53113( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53114( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53115( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >*)o)->dynamicTypeInfo)();
}

static  void method_53116( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >*)o)->isPresent)();
}

static  void method_53117( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9168( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Tau>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Tau> > > > -------------------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >"), typeid(::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >), sizeof(::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecElecMuTauFinalStateCollection>")
  .AddTypedef(type_556, Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >::value_type"))
  .AddTypedef(type_556, Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53103, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4203), Reflex::Literal("Wrapper"), constructor_53104, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53105, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85107), Reflex::Literal("Wrapper"), constructor_53110, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9168, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Tau>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Tau> > > > -------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_556, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Tau>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Tau> > > > -------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85106), Reflex::Literal("product"), method_53106, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85106), Reflex::Literal("operator->"), operator_53107, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53108, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53109, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85108), Reflex::Literal("getInterface"), method_53111, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53112, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53113, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53114, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53115, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53116, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53117, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Tau> > -------------------------------
static void constructor_53124( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >();
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >();
}

static void constructor_53125( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >(*(::std::auto_ptr<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >(*(::std::auto_ptr<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)arg[0]);
}

static void destructor_53126(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >::~Wrapper)();
}
static  void method_53127( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->product)();
}

static  void operator_53128( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->operator->)();
}

static  void method_53129( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->productTypeInfo)();
}

static  void method_53130( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->typeInfo)();
}

static void constructor_53131( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau>*)arg[0]);
}

static  void method_53132( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->getInterface)();
}

static  void method_53133( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53134( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53135( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53136( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->dynamicTypeInfo)();
}

static  void method_53137( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->isPresent)();
}

static  void method_53138( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9169( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Tau> > -------------------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s__datamem_bld(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s__funcmem_bld(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s__db_funcmem);
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >"), typeid(::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >), sizeof(::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecElecMuTauFinalState>")
  .AddTypedef(type_762, Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >::value_type"))
  .AddTypedef(type_762, Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53124, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4204), Reflex::Literal("Wrapper"), constructor_53125, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53126, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8559), Reflex::Literal("Wrapper"), constructor_53131, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9169, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Tau> > -------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_762, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Tau> > -------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8561), Reflex::Literal("product"), method_53127, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8561), Reflex::Literal("operator->"), operator_53128, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53129, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53130, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85111), Reflex::Literal("getInterface"), method_53132, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53133, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53134, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53135, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53136, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53137, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53138, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Muon>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Muon> > > > -------------------------------
static void constructor_53145( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >();
}

static void constructor_53146( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >(*(::std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >(*(::std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >*)arg[0]);
}

static void destructor_53147(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >*)o)->::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >::~Wrapper)();
}
static  void method_53148( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >*)o)->product)();
}

static  void operator_53149( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >*)o)->operator->)();
}

static  void method_53150( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >*)o)->productTypeInfo)();
}

static  void method_53151( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >*)o)->typeInfo)();
}

static void constructor_53152( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)arg[0]);
}

static  void method_53153( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >*)o)->getInterface)();
}

static  void method_53154( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53155( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53156( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53157( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >*)o)->dynamicTypeInfo)();
}

static  void method_53158( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >*)o)->isPresent)();
}

static  void method_53159( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9170( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Muon>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Muon> > > > -------------------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >"), typeid(::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >), sizeof(::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecElecMuMuFinalStateCollection>")
  .AddTypedef(type_2170, Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >::value_type"))
  .AddTypedef(type_2170, Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53145, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4205), Reflex::Literal("Wrapper"), constructor_53146, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53147, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85115), Reflex::Literal("Wrapper"), constructor_53152, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9170, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Muon>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Muon> > > > -------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2170, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Muon>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Muon> > > > -------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85114), Reflex::Literal("product"), method_53148, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85114), Reflex::Literal("operator->"), operator_53149, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53150, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53151, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85116), Reflex::Literal("getInterface"), method_53153, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53154, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53155, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53156, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53157, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53158, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53159, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Muon> > -------------------------------
static void constructor_53166( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >();
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >();
}

static void constructor_53167( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >(*(::std::auto_ptr<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >(*(::std::auto_ptr<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)arg[0]);
}

static void destructor_53168(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >::~Wrapper)();
}
static  void method_53169( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->product)();
}

static  void operator_53170( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->operator->)();
}

static  void method_53171( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->productTypeInfo)();
}

static  void method_53172( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->typeInfo)();
}

static void constructor_53173( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon>*)arg[0]);
}

static  void method_53174( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->getInterface)();
}

static  void method_53175( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53176( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53177( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53178( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->dynamicTypeInfo)();
}

static  void method_53179( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->isPresent)();
}

static  void method_53180( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9171( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Muon> > -------------------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s__datamem_bld(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s__funcmem_bld(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s__db_funcmem);
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >"), typeid(::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >), sizeof(::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecElecMuMuFinalState>")
  .AddTypedef(type_803, Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >::value_type"))
  .AddTypedef(type_803, Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53166, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4206), Reflex::Literal("Wrapper"), constructor_53167, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53168, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14561), Reflex::Literal("Wrapper"), constructor_53173, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9171, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Muon> > -------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_803, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Muon, pat::Muon> > -------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14563), Reflex::Literal("product"), method_53169, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14563), Reflex::Literal("operator->"), operator_53170, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53171, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53172, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85119), Reflex::Literal("getInterface"), method_53174, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53175, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53176, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53177, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53178, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53179, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53180, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Photon>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Photon> > > > -------------------------------
static void constructor_53187( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >();
}

static void constructor_53188( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >(*(::std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >(*(::std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >*)arg[0]);
}

static void destructor_53189(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >*)o)->::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >::~Wrapper)();
}
static  void method_53190( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >*)o)->product)();
}

static  void operator_53191( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >*)o)->operator->)();
}

static  void method_53192( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >*)o)->productTypeInfo)();
}

static  void method_53193( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >*)o)->typeInfo)();
}

static void constructor_53194( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)arg[0]);
}

static  void method_53195( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >*)o)->getInterface)();
}

static  void method_53196( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53197( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53198( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53199( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >*)o)->dynamicTypeInfo)();
}

static  void method_53200( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >*)o)->isPresent)();
}

static  void method_53201( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9172( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Photon>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Photon> > > > -------------------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >"), typeid(::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >), sizeof(::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecElecElecPhoFinalStateCollection>")
  .AddTypedef(type_2188, Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >::value_type"))
  .AddTypedef(type_2188, Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53187, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4207), Reflex::Literal("Wrapper"), constructor_53188, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53189, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85123), Reflex::Literal("Wrapper"), constructor_53194, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9172, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Photon>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Photon> > > > -------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2188, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Photon>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Photon> > > > -------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85122), Reflex::Literal("product"), method_53190, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85122), Reflex::Literal("operator->"), operator_53191, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53192, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53193, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85124), Reflex::Literal("getInterface"), method_53195, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53196, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53197, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53198, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53199, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53200, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53201, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Photon> > -------------------------------
static void constructor_53208( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >();
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >();
}

static void constructor_53209( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >(*(::std::auto_ptr<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >(*(::std::auto_ptr<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)arg[0]);
}

static void destructor_53210(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >::~Wrapper)();
}
static  void method_53211( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->product)();
}

static  void operator_53212( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->operator->)();
}

static  void method_53213( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->productTypeInfo)();
}

static  void method_53214( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->typeInfo)();
}

static void constructor_53215( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon>*)arg[0]);
}

static  void method_53216( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->getInterface)();
}

static  void method_53217( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53218( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53219( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53220( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->dynamicTypeInfo)();
}

static  void method_53221( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->isPresent)();
}

static  void method_53222( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9173( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Photon> > -------------------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s__datamem_bld(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s__funcmem_bld(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s__db_funcmem);
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >"), typeid(::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >), sizeof(::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecElecElecPhoFinalState>")
  .AddTypedef(type_2684, Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >::value_type"))
  .AddTypedef(type_2684, Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53208, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4208), Reflex::Literal("Wrapper"), constructor_53209, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53210, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14656), Reflex::Literal("Wrapper"), constructor_53215, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9173, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Photon> > -------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2684, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Photon> > -------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14658), Reflex::Literal("product"), method_53211, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14658), Reflex::Literal("operator->"), operator_53212, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53213, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53214, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85127), Reflex::Literal("getInterface"), method_53216, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53217, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53218, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53219, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53220, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53221, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53222, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Tau>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Tau> > > > -------------------------------
static void constructor_53229( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >();
}

static void constructor_53230( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >(*(::std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >(*(::std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >*)arg[0]);
}

static void destructor_53231(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >*)o)->::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >::~Wrapper)();
}
static  void method_53232( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >*)o)->product)();
}

static  void operator_53233( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >*)o)->operator->)();
}

static  void method_53234( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >*)o)->productTypeInfo)();
}

static  void method_53235( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >*)o)->typeInfo)();
}

static void constructor_53236( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)arg[0]);
}

static  void method_53237( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >*)o)->getInterface)();
}

static  void method_53238( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53239( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53240( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53241( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >*)o)->dynamicTypeInfo)();
}

static  void method_53242( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >*)o)->isPresent)();
}

static  void method_53243( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9174( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Tau>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Tau> > > > -------------------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >"), typeid(::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >), sizeof(::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecElecElecTauFinalStateCollection>")
  .AddTypedef(type_3617, Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >::value_type"))
  .AddTypedef(type_3617, Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53229, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4209), Reflex::Literal("Wrapper"), constructor_53230, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53231, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85131), Reflex::Literal("Wrapper"), constructor_53236, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9174, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Tau>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Tau> > > > -------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3617, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Tau>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Tau> > > > -------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85130), Reflex::Literal("product"), method_53232, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85130), Reflex::Literal("operator->"), operator_53233, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53234, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53235, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85132), Reflex::Literal("getInterface"), method_53237, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53238, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53239, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53240, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53241, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53242, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53243, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Tau> > -------------------------------
static void constructor_53250( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >();
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >();
}

static void constructor_53251( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >(*(::std::auto_ptr<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >(*(::std::auto_ptr<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)arg[0]);
}

static void destructor_53252(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >::~Wrapper)();
}
static  void method_53253( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->product)();
}

static  void operator_53254( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->operator->)();
}

static  void method_53255( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->productTypeInfo)();
}

static  void method_53256( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->typeInfo)();
}

static void constructor_53257( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau>*)arg[0]);
}

static  void method_53258( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->getInterface)();
}

static  void method_53259( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53260( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53261( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53262( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->dynamicTypeInfo)();
}

static  void method_53263( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->isPresent)();
}

static  void method_53264( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9175( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Tau> > -------------------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s__datamem_bld(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s__funcmem_bld(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s__db_funcmem);
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >"), typeid(::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >), sizeof(::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecElecElecTauFinalState>")
  .AddTypedef(type_2562, Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >::value_type"))
  .AddTypedef(type_2562, Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53250, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4210), Reflex::Literal("Wrapper"), constructor_53251, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53252, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19789), Reflex::Literal("Wrapper"), constructor_53257, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9175, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Tau> > -------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2562, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Tau> > -------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19791), Reflex::Literal("product"), method_53253, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19791), Reflex::Literal("operator->"), operator_53254, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53255, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53256, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85135), Reflex::Literal("getInterface"), method_53258, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53259, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53260, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53261, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53262, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53263, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53264, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Muon>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Muon> > > > -------------------------------
static void constructor_53271( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >();
}

static void constructor_53272( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >(*(::std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >(*(::std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >*)arg[0]);
}

static void destructor_53273(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >*)o)->::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >::~Wrapper)();
}
static  void method_53274( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >*)o)->product)();
}

static  void operator_53275( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >*)o)->operator->)();
}

static  void method_53276( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >*)o)->productTypeInfo)();
}

static  void method_53277( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >*)o)->typeInfo)();
}

static void constructor_53278( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)arg[0]);
}

static  void method_53279( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >*)o)->getInterface)();
}

static  void method_53280( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53281( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53282( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53283( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >*)o)->dynamicTypeInfo)();
}

static  void method_53284( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >*)o)->isPresent)();
}

static  void method_53285( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9176( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Muon>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Muon> > > > -------------------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >"), typeid(::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >), sizeof(::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecElecElecMuFinalStateCollection>")
  .AddTypedef(type_3645, Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >::value_type"))
  .AddTypedef(type_3645, Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53271, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4211), Reflex::Literal("Wrapper"), constructor_53272, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53273, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85139), Reflex::Literal("Wrapper"), constructor_53278, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9176, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Muon>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Muon> > > > -------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3645, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Muon>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Muon> > > > -------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85138), Reflex::Literal("product"), method_53274, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85138), Reflex::Literal("operator->"), operator_53275, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53276, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53277, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85140), Reflex::Literal("getInterface"), method_53279, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53280, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53281, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53282, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53283, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53284, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53285, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Muon> > -------------------------------
static void constructor_53292( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >();
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >();
}

static void constructor_53293( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >(*(::std::auto_ptr<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >(*(::std::auto_ptr<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)arg[0]);
}

static void destructor_53294(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >::~Wrapper)();
}
static  void method_53295( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->product)();
}

static  void operator_53296( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->operator->)();
}

static  void method_53297( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->productTypeInfo)();
}

static  void method_53298( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->typeInfo)();
}

static void constructor_53299( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon>*)arg[0]);
}

static  void method_53300( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->getInterface)();
}

static  void method_53301( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53302( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53303( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53304( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->dynamicTypeInfo)();
}

static  void method_53305( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->isPresent)();
}

static  void method_53306( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9177( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Muon> > -------------------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s__datamem_bld(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s__funcmem_bld(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s__db_funcmem);
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >"), typeid(::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >), sizeof(::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecElecElecMuFinalState>")
  .AddTypedef(type_2811, Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >::value_type"))
  .AddTypedef(type_2811, Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53292, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4212), Reflex::Literal("Wrapper"), constructor_53293, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53294, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20121), Reflex::Literal("Wrapper"), constructor_53299, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9177, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Muon> > -------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2811, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Muon> > -------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20123), Reflex::Literal("product"), method_53295, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20123), Reflex::Literal("operator->"), operator_53296, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53297, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53298, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85143), Reflex::Literal("getInterface"), method_53300, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53301, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53302, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53303, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53304, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53305, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53306, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Electron>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Electron> > > > -------------------------------
static void constructor_53313( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >();
}

static void constructor_53314( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >(*(::std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >(*(::std::auto_ptr<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >*)arg[0]);
}

static void destructor_53315(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >*)o)->::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >::~Wrapper)();
}
static  void method_53316( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >*)o)->product)();
}

static  void operator_53317( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >*)o)->operator->)();
}

static  void method_53318( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >*)o)->productTypeInfo)();
}

static  void method_53319( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >*)o)->typeInfo)();
}

static void constructor_53320( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >((::std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)arg[0]);
}

static  void method_53321( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >*)o)->getInterface)();
}

static  void method_53322( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53323( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53324( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53325( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >*)o)->dynamicTypeInfo)();
}

static  void method_53326( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >*)o)->isPresent)();
}

static  void method_53327( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9178( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Electron>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Electron> > > > -------------------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >"), typeid(::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >), sizeof(::edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecElecElecElecFinalStateCollection>")
  .AddTypedef(type_2037, Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >::value_type"))
  .AddTypedef(type_2037, Reflex::Literal("edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53313, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4213), Reflex::Literal("Wrapper"), constructor_53314, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53315, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85147), Reflex::Literal("Wrapper"), constructor_53320, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9178, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Electron>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Electron> > > > -------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2037, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Electron>, std::allocator<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Electron> > > > -------------------
void __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85146), Reflex::Literal("product"), method_53316, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85146), Reflex::Literal("operator->"), operator_53317, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53318, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53319, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85148), Reflex::Literal("getInterface"), method_53321, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53322, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53323, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53324, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53325, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53326, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53327, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Electron> > -------------------------------
static void constructor_53334( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >();
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >();
}

static void constructor_53335( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >(*(::std::auto_ptr<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >(*(::std::auto_ptr<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)arg[0]);
}

static void destructor_53336(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >::~Wrapper)();
}
static  void method_53337( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->product)();
}

static  void operator_53338( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->operator->)();
}

static  void method_53339( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->productTypeInfo)();
}

static  void method_53340( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->typeInfo)();
}

static void constructor_53341( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >((::PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron>*)arg[0]);
}

static  void method_53342( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->getInterface)();
}

static  void method_53343( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53344( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53345( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53346( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->dynamicTypeInfo)();
}

static  void method_53347( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->isPresent)();
}

static  void method_53348( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9179( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Electron> > -------------------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s__datamem_bld(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s__funcmem_bld(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s__db_funcmem);
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >"), typeid(::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >), sizeof(::edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecElecElecElecFinalState>")
  .AddTypedef(type_505, Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >::value_type"))
  .AddTypedef(type_505, Reflex::Literal("edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53334, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4214), Reflex::Literal("Wrapper"), constructor_53335, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53336, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14242), Reflex::Literal("Wrapper"), constructor_53341, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9179, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Electron> > -------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_505, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATQuadFinalStateT<pat::Electron, pat::Electron, pat::Electron, pat::Electron> > -------------------
void __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14244), Reflex::Literal("product"), method_53337, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14244), Reflex::Literal("operator->"), operator_53338, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53339, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53340, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85151), Reflex::Literal("getInterface"), method_53342, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53343, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53344, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53345, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53346, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53347, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53348, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATTripletFinalStateT<pat::Muon, pat::Jet, pat::Jet>, std::allocator<PATTripletFinalStateT<pat::Muon, pat::Jet, pat::Jet> > > > -------------------------------
static void constructor_53355( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >();
}

static void constructor_53356( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >(*(::std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >(*(::std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >*)arg[0]);
}

static void destructor_53357(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >*)o)->::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >::~Wrapper)();
}
static  void method_53358( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >*)o)->product)();
}

static  void operator_53359( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >*)o)->operator->)();
}

static  void method_53360( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >*)o)->productTypeInfo)();
}

static  void method_53361( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >*)o)->typeInfo)();
}

static void constructor_53362( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)arg[0]);
}

static  void method_53363( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >*)o)->getInterface)();
}

static  void method_53364( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53365( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53366( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53367( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >*)o)->dynamicTypeInfo)();
}

static  void method_53368( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >*)o)->isPresent)();
}

static  void method_53369( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9180( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATTripletFinalStateT<pat::Muon, pat::Jet, pat::Jet>, std::allocator<PATTripletFinalStateT<pat::Muon, pat::Jet, pat::Jet> > > > -------------------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >"), typeid(::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >), sizeof(::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATMuJetJetFinalStateCollection>")
  .AddTypedef(type_1842, Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >::value_type"))
  .AddTypedef(type_1842, Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53355, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4215), Reflex::Literal("Wrapper"), constructor_53356, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53357, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85155), Reflex::Literal("Wrapper"), constructor_53362, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9180, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATTripletFinalStateT<pat::Muon, pat::Jet, pat::Jet>, std::allocator<PATTripletFinalStateT<pat::Muon, pat::Jet, pat::Jet> > > > -------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1842, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATTripletFinalStateT<pat::Muon, pat::Jet, pat::Jet>, std::allocator<PATTripletFinalStateT<pat::Muon, pat::Jet, pat::Jet> > > > -------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85154), Reflex::Literal("product"), method_53358, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85154), Reflex::Literal("operator->"), operator_53359, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53360, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53361, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85156), Reflex::Literal("getInterface"), method_53363, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53364, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53365, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53366, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53367, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53368, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53369, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATTripletFinalStateT<pat::Muon, pat::Jet, pat::Jet> > -------------------------------
static void constructor_53376( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >();
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >();
}

static void constructor_53377( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >(*(::std::auto_ptr<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >(*(::std::auto_ptr<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)arg[0]);
}

static void destructor_53378(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >::~Wrapper)();
}
static  void method_53379( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->product)();
}

static  void operator_53380( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->operator->)();
}

static  void method_53381( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->productTypeInfo)();
}

static  void method_53382( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->typeInfo)();
}

static void constructor_53383( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >((::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >((::PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet>*)arg[0]);
}

static  void method_53384( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->getInterface)();
}

static  void method_53385( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53386( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53387( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53388( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->dynamicTypeInfo)();
}

static  void method_53389( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->isPresent)();
}

static  void method_53390( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9181( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATTripletFinalStateT<pat::Muon, pat::Jet, pat::Jet> > -------------------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s__datamem_bld(&__edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s__funcmem_bld(&__edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s__db_funcmem);
void __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >"), typeid(::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >), sizeof(::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATMuJetJetFinalState>")
  .AddTypedef(type_634, Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >::value_type"))
  .AddTypedef(type_634, Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53376, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4216), Reflex::Literal("Wrapper"), constructor_53377, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53378, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13373), Reflex::Literal("Wrapper"), constructor_53383, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9181, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATTripletFinalStateT<pat::Muon, pat::Jet, pat::Jet> > -------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_634, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATTripletFinalStateT<pat::Muon, pat::Jet, pat::Jet> > -------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13375), Reflex::Literal("product"), method_53379, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13375), Reflex::Literal("operator->"), operator_53380, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53381, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53382, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85159), Reflex::Literal("getInterface"), method_53384, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53385, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53386, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53387, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53388, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53389, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53390, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATTripletFinalStateT<pat::Muon, pat::Photon, pat::Photon>, std::allocator<PATTripletFinalStateT<pat::Muon, pat::Photon, pat::Photon> > > > -------------------------------
static void constructor_53397( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >();
}

static void constructor_53398( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >(*(::std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >(*(::std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >*)arg[0]);
}

static void destructor_53399(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >*)o)->::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >::~Wrapper)();
}
static  void method_53400( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >*)o)->product)();
}

static  void operator_53401( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >*)o)->operator->)();
}

static  void method_53402( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >*)o)->productTypeInfo)();
}

static  void method_53403( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >*)o)->typeInfo)();
}

static void constructor_53404( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)arg[0]);
}

static  void method_53405( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >*)o)->getInterface)();
}

static  void method_53406( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53407( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53408( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53409( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >*)o)->dynamicTypeInfo)();
}

static  void method_53410( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >*)o)->isPresent)();
}

static  void method_53411( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9182( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATTripletFinalStateT<pat::Muon, pat::Photon, pat::Photon>, std::allocator<PATTripletFinalStateT<pat::Muon, pat::Photon, pat::Photon> > > > -------------------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >"), typeid(::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >), sizeof(::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATMuPhoPhoFinalStateCollection>")
  .AddTypedef(type_1163, Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >::value_type"))
  .AddTypedef(type_1163, Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53397, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4217), Reflex::Literal("Wrapper"), constructor_53398, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53399, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85163), Reflex::Literal("Wrapper"), constructor_53404, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9182, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATTripletFinalStateT<pat::Muon, pat::Photon, pat::Photon>, std::allocator<PATTripletFinalStateT<pat::Muon, pat::Photon, pat::Photon> > > > -------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1163, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATTripletFinalStateT<pat::Muon, pat::Photon, pat::Photon>, std::allocator<PATTripletFinalStateT<pat::Muon, pat::Photon, pat::Photon> > > > -------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85162), Reflex::Literal("product"), method_53400, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85162), Reflex::Literal("operator->"), operator_53401, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53402, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53403, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85164), Reflex::Literal("getInterface"), method_53405, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53406, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53407, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53408, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53409, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53410, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53411, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATTripletFinalStateT<pat::Muon, pat::Photon, pat::Photon> > -------------------------------
static void constructor_53418( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >();
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >();
}

static void constructor_53419( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >(*(::std::auto_ptr<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >(*(::std::auto_ptr<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)arg[0]);
}

static void destructor_53420(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >::~Wrapper)();
}
static  void method_53421( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->product)();
}

static  void operator_53422( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->operator->)();
}

static  void method_53423( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->productTypeInfo)();
}

static  void method_53424( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->typeInfo)();
}

static void constructor_53425( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >((::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >((::PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon>*)arg[0]);
}

static  void method_53426( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->getInterface)();
}

static  void method_53427( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53428( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53429( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53430( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->dynamicTypeInfo)();
}

static  void method_53431( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->isPresent)();
}

static  void method_53432( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9183( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATTripletFinalStateT<pat::Muon, pat::Photon, pat::Photon> > -------------------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s__datamem_bld(&__edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s__funcmem_bld(&__edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s__db_funcmem);
void __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >"), typeid(::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >), sizeof(::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATMuPhoPhoFinalState>")
  .AddTypedef(type_1517, Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >::value_type"))
  .AddTypedef(type_1517, Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53418, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4218), Reflex::Literal("Wrapper"), constructor_53419, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53420, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11565), Reflex::Literal("Wrapper"), constructor_53425, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9183, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATTripletFinalStateT<pat::Muon, pat::Photon, pat::Photon> > -------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1517, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATTripletFinalStateT<pat::Muon, pat::Photon, pat::Photon> > -------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11567), Reflex::Literal("product"), method_53421, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11567), Reflex::Literal("operator->"), operator_53422, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53423, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53424, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85167), Reflex::Literal("getInterface"), method_53426, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53427, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53428, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53429, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53430, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53431, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53432, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATTripletFinalStateT<pat::Muon, pat::Tau, pat::Tau>, std::allocator<PATTripletFinalStateT<pat::Muon, pat::Tau, pat::Tau> > > > -------------------------------
static void constructor_53439( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >();
}

static void constructor_53440( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >(*(::std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >(*(::std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >*)arg[0]);
}

static void destructor_53441(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >*)o)->::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >::~Wrapper)();
}
static  void method_53442( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >*)o)->product)();
}

static  void operator_53443( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >*)o)->operator->)();
}

static  void method_53444( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >*)o)->productTypeInfo)();
}

static  void method_53445( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >*)o)->typeInfo)();
}

static void constructor_53446( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)arg[0]);
}

static  void method_53447( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >*)o)->getInterface)();
}

static  void method_53448( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53449( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53450( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53451( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >*)o)->dynamicTypeInfo)();
}

static  void method_53452( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >*)o)->isPresent)();
}

static  void method_53453( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9184( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATTripletFinalStateT<pat::Muon, pat::Tau, pat::Tau>, std::allocator<PATTripletFinalStateT<pat::Muon, pat::Tau, pat::Tau> > > > -------------------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >"), typeid(::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >), sizeof(::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATMuTauTauFinalStateCollection>")
  .AddTypedef(type_2938, Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >::value_type"))
  .AddTypedef(type_2938, Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53439, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4219), Reflex::Literal("Wrapper"), constructor_53440, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53441, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85171), Reflex::Literal("Wrapper"), constructor_53446, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9184, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATTripletFinalStateT<pat::Muon, pat::Tau, pat::Tau>, std::allocator<PATTripletFinalStateT<pat::Muon, pat::Tau, pat::Tau> > > > -------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2938, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATTripletFinalStateT<pat::Muon, pat::Tau, pat::Tau>, std::allocator<PATTripletFinalStateT<pat::Muon, pat::Tau, pat::Tau> > > > -------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85170), Reflex::Literal("product"), method_53442, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85170), Reflex::Literal("operator->"), operator_53443, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53444, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53445, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85172), Reflex::Literal("getInterface"), method_53447, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53448, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53449, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53450, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53451, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53452, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53453, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATTripletFinalStateT<pat::Muon, pat::Tau, pat::Tau> > -------------------------------
static void constructor_53460( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >();
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >();
}

static void constructor_53461( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >(*(::std::auto_ptr<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >(*(::std::auto_ptr<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)arg[0]);
}

static void destructor_53462(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >::~Wrapper)();
}
static  void method_53463( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->product)();
}

static  void operator_53464( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->operator->)();
}

static  void method_53465( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->productTypeInfo)();
}

static  void method_53466( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->typeInfo)();
}

static void constructor_53467( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >((::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >((::PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau>*)arg[0]);
}

static  void method_53468( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->getInterface)();
}

static  void method_53469( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53470( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53471( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53472( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->dynamicTypeInfo)();
}

static  void method_53473( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->isPresent)();
}

static  void method_53474( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9185( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATTripletFinalStateT<pat::Muon, pat::Tau, pat::Tau> > -------------------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s__datamem_bld(&__edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s__funcmem_bld(&__edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s__db_funcmem);
void __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >"), typeid(::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >), sizeof(::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATMuTauTauFinalState>")
  .AddTypedef(type_1518, Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >::value_type"))
  .AddTypedef(type_1518, Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53460, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4220), Reflex::Literal("Wrapper"), constructor_53461, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53462, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17244), Reflex::Literal("Wrapper"), constructor_53467, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9185, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATTripletFinalStateT<pat::Muon, pat::Tau, pat::Tau> > -------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1518, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATTripletFinalStateT<pat::Muon, pat::Tau, pat::Tau> > -------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17246), Reflex::Literal("product"), method_53463, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17246), Reflex::Literal("operator->"), operator_53464, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53465, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53466, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85175), Reflex::Literal("getInterface"), method_53468, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53469, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53470, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53471, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53472, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53473, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53474, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Photon>, std::allocator<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Photon> > > > -------------------------------
static void constructor_53481( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >();
}

static void constructor_53482( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >(*(::std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >(*(::std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >*)arg[0]);
}

static void destructor_53483(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >*)o)->::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >::~Wrapper)();
}
static  void method_53484( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >*)o)->product)();
}

static  void operator_53485( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >*)o)->operator->)();
}

static  void method_53486( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >*)o)->productTypeInfo)();
}

static  void method_53487( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >*)o)->typeInfo)();
}

static void constructor_53488( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)arg[0]);
}

static  void method_53489( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >*)o)->getInterface)();
}

static  void method_53490( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53491( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53492( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53493( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >*)o)->dynamicTypeInfo)();
}

static  void method_53494( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >*)o)->isPresent)();
}

static  void method_53495( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9186( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Photon>, std::allocator<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Photon> > > > -------------------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >"), typeid(::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >), sizeof(::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATMuMuPhoFinalStateCollection>")
  .AddTypedef(type_3061, Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >::value_type"))
  .AddTypedef(type_3061, Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53481, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4221), Reflex::Literal("Wrapper"), constructor_53482, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53483, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85179), Reflex::Literal("Wrapper"), constructor_53488, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9186, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Photon>, std::allocator<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Photon> > > > -------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3061, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Photon>, std::allocator<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Photon> > > > -------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85178), Reflex::Literal("product"), method_53484, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85178), Reflex::Literal("operator->"), operator_53485, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53486, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53487, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85180), Reflex::Literal("getInterface"), method_53489, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53490, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53491, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53492, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53493, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53494, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53495, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Photon> > -------------------------------
static void constructor_53502( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >();
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >();
}

static void constructor_53503( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >(*(::std::auto_ptr<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >(*(::std::auto_ptr<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)arg[0]);
}

static void destructor_53504(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >::~Wrapper)();
}
static  void method_53505( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->product)();
}

static  void operator_53506( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->operator->)();
}

static  void method_53507( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->productTypeInfo)();
}

static  void method_53508( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->typeInfo)();
}

static void constructor_53509( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >((::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >((::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon>*)arg[0]);
}

static  void method_53510( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->getInterface)();
}

static  void method_53511( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53512( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53513( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53514( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->dynamicTypeInfo)();
}

static  void method_53515( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->isPresent)();
}

static  void method_53516( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9187( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Photon> > -------------------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s__datamem_bld(&__edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s__funcmem_bld(&__edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s__db_funcmem);
void __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >"), typeid(::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >), sizeof(::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATMuMuPhoFinalState>")
  .AddTypedef(type_912, Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >::value_type"))
  .AddTypedef(type_912, Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53502, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4222), Reflex::Literal("Wrapper"), constructor_53503, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53504, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18311), Reflex::Literal("Wrapper"), constructor_53509, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9187, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Photon> > -------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_912, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Photon> > -------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18313), Reflex::Literal("product"), method_53505, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18313), Reflex::Literal("operator->"), operator_53506, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53507, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53508, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85183), Reflex::Literal("getInterface"), method_53510, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53511, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53512, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53513, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53514, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53515, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53516, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Tau>, std::allocator<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Tau> > > > -------------------------------
static void constructor_53523( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >();
}

static void constructor_53524( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >(*(::std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >(*(::std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >*)arg[0]);
}

static void destructor_53525(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >*)o)->::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >::~Wrapper)();
}
static  void method_53526( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >*)o)->product)();
}

static  void operator_53527( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >*)o)->operator->)();
}

static  void method_53528( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >*)o)->productTypeInfo)();
}

static  void method_53529( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >*)o)->typeInfo)();
}

static void constructor_53530( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)arg[0]);
}

static  void method_53531( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >*)o)->getInterface)();
}

static  void method_53532( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53533( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53534( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53535( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >*)o)->dynamicTypeInfo)();
}

static  void method_53536( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >*)o)->isPresent)();
}

static  void method_53537( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9188( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Tau>, std::allocator<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Tau> > > > -------------------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >"), typeid(::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >), sizeof(::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATMuMuTauFinalStateCollection>")
  .AddTypedef(type_260, Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >::value_type"))
  .AddTypedef(type_260, Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53523, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4223), Reflex::Literal("Wrapper"), constructor_53524, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53525, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85187), Reflex::Literal("Wrapper"), constructor_53530, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9188, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Tau>, std::allocator<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Tau> > > > -------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_260, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Tau>, std::allocator<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Tau> > > > -------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85186), Reflex::Literal("product"), method_53526, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85186), Reflex::Literal("operator->"), operator_53527, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53528, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53529, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85188), Reflex::Literal("getInterface"), method_53531, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53532, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53533, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53534, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53535, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53536, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53537, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Tau> > -------------------------------
static void constructor_53544( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >();
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >();
}

static void constructor_53545( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >(*(::std::auto_ptr<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >(*(::std::auto_ptr<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)arg[0]);
}

static void destructor_53546(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >::~Wrapper)();
}
static  void method_53547( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->product)();
}

static  void operator_53548( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->operator->)();
}

static  void method_53549( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->productTypeInfo)();
}

static  void method_53550( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->typeInfo)();
}

static void constructor_53551( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >((::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >((::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau>*)arg[0]);
}

static  void method_53552( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->getInterface)();
}

static  void method_53553( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53554( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53555( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53556( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->dynamicTypeInfo)();
}

static  void method_53557( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->isPresent)();
}

static  void method_53558( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9189( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Tau> > -------------------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s__datamem_bld(&__edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s__funcmem_bld(&__edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s__db_funcmem);
void __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >"), typeid(::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >), sizeof(::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATMuMuTauFinalState>")
  .AddTypedef(type_1519, Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >::value_type"))
  .AddTypedef(type_1519, Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53544, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4224), Reflex::Literal("Wrapper"), constructor_53545, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53546, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6931), Reflex::Literal("Wrapper"), constructor_53551, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9189, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Tau> > -------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1519, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Tau> > -------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6933), Reflex::Literal("product"), method_53547, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6933), Reflex::Literal("operator->"), operator_53548, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53549, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53550, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85191), Reflex::Literal("getInterface"), method_53552, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53553, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53554, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53555, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53556, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53557, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53558, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Muon>, std::allocator<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Muon> > > > -------------------------------
static void constructor_53565( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >();
}

static void constructor_53566( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >(*(::std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >(*(::std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >*)arg[0]);
}

static void destructor_53567(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >*)o)->::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >::~Wrapper)();
}
static  void method_53568( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >*)o)->product)();
}

static  void operator_53569( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >*)o)->operator->)();
}

static  void method_53570( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >*)o)->productTypeInfo)();
}

static  void method_53571( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >*)o)->typeInfo)();
}

static void constructor_53572( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >((::std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)arg[0]);
}

static  void method_53573( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >*)o)->getInterface)();
}

static  void method_53574( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53575( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53576( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53577( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >*)o)->dynamicTypeInfo)();
}

static  void method_53578( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >*)o)->isPresent)();
}

static  void method_53579( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9190( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Muon>, std::allocator<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Muon> > > > -------------------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >"), typeid(::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >), sizeof(::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATMuMuMuFinalStateCollection>")
  .AddTypedef(type_2919, Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >::value_type"))
  .AddTypedef(type_2919, Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53565, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4225), Reflex::Literal("Wrapper"), constructor_53566, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53567, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85195), Reflex::Literal("Wrapper"), constructor_53572, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9190, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Muon>, std::allocator<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Muon> > > > -------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2919, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Muon>, std::allocator<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Muon> > > > -------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85194), Reflex::Literal("product"), method_53568, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85194), Reflex::Literal("operator->"), operator_53569, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53570, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53571, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85196), Reflex::Literal("getInterface"), method_53573, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53574, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53575, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53576, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53577, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53578, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53579, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Muon> > -------------------------------
static void constructor_53586( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >();
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >();
}

static void constructor_53587( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >(*(::std::auto_ptr<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >(*(::std::auto_ptr<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)arg[0]);
}

static void destructor_53588(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >::~Wrapper)();
}
static  void method_53589( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->product)();
}

static  void operator_53590( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->operator->)();
}

static  void method_53591( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->productTypeInfo)();
}

static  void method_53592( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->typeInfo)();
}

static void constructor_53593( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >((::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >((::PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon>*)arg[0]);
}

static  void method_53594( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->getInterface)();
}

static  void method_53595( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53596( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53597( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53598( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->dynamicTypeInfo)();
}

static  void method_53599( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->isPresent)();
}

static  void method_53600( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9191( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Muon> > -------------------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s__datamem_bld(&__edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s__funcmem_bld(&__edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s__db_funcmem);
void __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >"), typeid(::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >), sizeof(::edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATMuMuMuFinalState>")
  .AddTypedef(type_1051, Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >::value_type"))
  .AddTypedef(type_1051, Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53586, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4226), Reflex::Literal("Wrapper"), constructor_53587, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53588, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17177), Reflex::Literal("Wrapper"), constructor_53593, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9191, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Muon> > -------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1051, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATTripletFinalStateT<pat::Muon, pat::Muon, pat::Muon> > -------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17179), Reflex::Literal("product"), method_53589, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17179), Reflex::Literal("operator->"), operator_53590, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53591, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53592, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85199), Reflex::Literal("getInterface"), method_53594, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53595, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53596, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53597, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53598, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53599, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53600, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATTripletFinalStateT<pat::Electron, pat::Photon, pat::Photon>, std::allocator<PATTripletFinalStateT<pat::Electron, pat::Photon, pat::Photon> > > > -------------------------------
static void constructor_53607( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >();
}

static void constructor_53608( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >(*(::std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >(*(::std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >*)arg[0]);
}

static void destructor_53609(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >*)o)->::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >::~Wrapper)();
}
static  void method_53610( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >*)o)->product)();
}

static  void operator_53611( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >*)o)->operator->)();
}

static  void method_53612( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >*)o)->productTypeInfo)();
}

static  void method_53613( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >*)o)->typeInfo)();
}

static void constructor_53614( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)arg[0]);
}

static  void method_53615( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >*)o)->getInterface)();
}

static  void method_53616( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53617( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53618( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53619( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >*)o)->dynamicTypeInfo)();
}

static  void method_53620( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >*)o)->isPresent)();
}

static  void method_53621( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9192( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATTripletFinalStateT<pat::Electron, pat::Photon, pat::Photon>, std::allocator<PATTripletFinalStateT<pat::Electron, pat::Photon, pat::Photon> > > > -------------------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >"), typeid(::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >), sizeof(::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecPhoPhoFinalStateCollection>")
  .AddTypedef(type_2880, Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >::value_type"))
  .AddTypedef(type_2880, Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53607, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4227), Reflex::Literal("Wrapper"), constructor_53608, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53609, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85203), Reflex::Literal("Wrapper"), constructor_53614, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9192, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATTripletFinalStateT<pat::Electron, pat::Photon, pat::Photon>, std::allocator<PATTripletFinalStateT<pat::Electron, pat::Photon, pat::Photon> > > > -------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2880, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATTripletFinalStateT<pat::Electron, pat::Photon, pat::Photon>, std::allocator<PATTripletFinalStateT<pat::Electron, pat::Photon, pat::Photon> > > > -------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85202), Reflex::Literal("product"), method_53610, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85202), Reflex::Literal("operator->"), operator_53611, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53612, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53613, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85204), Reflex::Literal("getInterface"), method_53615, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53616, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53617, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53618, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53619, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53620, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53621, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATTripletFinalStateT<pat::Electron, pat::Photon, pat::Photon> > -------------------------------
static void constructor_53628( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >();
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >();
}

static void constructor_53629( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >(*(::std::auto_ptr<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >(*(::std::auto_ptr<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)arg[0]);
}

static void destructor_53630(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >::~Wrapper)();
}
static  void method_53631( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->product)();
}

static  void operator_53632( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->operator->)();
}

static  void method_53633( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->productTypeInfo)();
}

static  void method_53634( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->typeInfo)();
}

static void constructor_53635( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >((::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >((::PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon>*)arg[0]);
}

static  void method_53636( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->getInterface)();
}

static  void method_53637( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53638( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53639( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53640( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->dynamicTypeInfo)();
}

static  void method_53641( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->isPresent)();
}

static  void method_53642( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9193( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATTripletFinalStateT<pat::Electron, pat::Photon, pat::Photon> > -------------------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s__datamem_bld(&__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s__funcmem_bld(&__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s__db_funcmem);
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >"), typeid(::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >), sizeof(::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecPhoPhoFinalState>")
  .AddTypedef(type_110, Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >::value_type"))
  .AddTypedef(type_110, Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53628, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4228), Reflex::Literal("Wrapper"), constructor_53629, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53630, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17027), Reflex::Literal("Wrapper"), constructor_53635, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9193, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATTripletFinalStateT<pat::Electron, pat::Photon, pat::Photon> > -------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_110, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATTripletFinalStateT<pat::Electron, pat::Photon, pat::Photon> > -------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17029), Reflex::Literal("product"), method_53631, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17029), Reflex::Literal("operator->"), operator_53632, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53633, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53634, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85207), Reflex::Literal("getInterface"), method_53636, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53637, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53638, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53639, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53640, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53641, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53642, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATTripletFinalStateT<pat::Electron, pat::Tau, pat::Tau>, std::allocator<PATTripletFinalStateT<pat::Electron, pat::Tau, pat::Tau> > > > -------------------------------
static void constructor_53649( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >();
}

static void constructor_53650( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >(*(::std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >(*(::std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >*)arg[0]);
}

static void destructor_53651(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >*)o)->::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >::~Wrapper)();
}
static  void method_53652( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >*)o)->product)();
}

static  void operator_53653( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >*)o)->operator->)();
}

static  void method_53654( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >*)o)->productTypeInfo)();
}

static  void method_53655( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >*)o)->typeInfo)();
}

static void constructor_53656( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)arg[0]);
}

static  void method_53657( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >*)o)->getInterface)();
}

static  void method_53658( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53659( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53660( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53661( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >*)o)->dynamicTypeInfo)();
}

static  void method_53662( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >*)o)->isPresent)();
}

static  void method_53663( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9194( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATTripletFinalStateT<pat::Electron, pat::Tau, pat::Tau>, std::allocator<PATTripletFinalStateT<pat::Electron, pat::Tau, pat::Tau> > > > -------------------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >"), typeid(::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >), sizeof(::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecTauTauFinalStateCollection>")
  .AddTypedef(type_1352, Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >::value_type"))
  .AddTypedef(type_1352, Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53649, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4229), Reflex::Literal("Wrapper"), constructor_53650, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53651, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85211), Reflex::Literal("Wrapper"), constructor_53656, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9194, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATTripletFinalStateT<pat::Electron, pat::Tau, pat::Tau>, std::allocator<PATTripletFinalStateT<pat::Electron, pat::Tau, pat::Tau> > > > -------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1352, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATTripletFinalStateT<pat::Electron, pat::Tau, pat::Tau>, std::allocator<PATTripletFinalStateT<pat::Electron, pat::Tau, pat::Tau> > > > -------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85210), Reflex::Literal("product"), method_53652, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85210), Reflex::Literal("operator->"), operator_53653, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53654, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53655, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85212), Reflex::Literal("getInterface"), method_53657, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53658, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53659, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53660, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53661, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53662, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53663, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATTripletFinalStateT<pat::Electron, pat::Tau, pat::Tau> > -------------------------------
static void constructor_53670( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >();
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >();
}

static void constructor_53671( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >(*(::std::auto_ptr<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >(*(::std::auto_ptr<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)arg[0]);
}

static void destructor_53672(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >::~Wrapper)();
}
static  void method_53673( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->product)();
}

static  void operator_53674( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->operator->)();
}

static  void method_53675( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->productTypeInfo)();
}

static  void method_53676( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->typeInfo)();
}

static void constructor_53677( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >((::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >((::PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau>*)arg[0]);
}

static  void method_53678( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->getInterface)();
}

static  void method_53679( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53680( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53681( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53682( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->dynamicTypeInfo)();
}

static  void method_53683( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->isPresent)();
}

static  void method_53684( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9195( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATTripletFinalStateT<pat::Electron, pat::Tau, pat::Tau> > -------------------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s__datamem_bld(&__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s__funcmem_bld(&__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s__db_funcmem);
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >"), typeid(::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >), sizeof(::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecTauTauFinalState>")
  .AddTypedef(type_716, Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >::value_type"))
  .AddTypedef(type_716, Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53670, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4230), Reflex::Literal("Wrapper"), constructor_53671, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53672, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12060), Reflex::Literal("Wrapper"), constructor_53677, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9195, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATTripletFinalStateT<pat::Electron, pat::Tau, pat::Tau> > -------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_716, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATTripletFinalStateT<pat::Electron, pat::Tau, pat::Tau> > -------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12062), Reflex::Literal("product"), method_53673, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12062), Reflex::Literal("operator->"), operator_53674, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53675, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53676, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85215), Reflex::Literal("getInterface"), method_53678, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53679, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53680, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53681, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53682, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53683, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53684, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Photon>, std::allocator<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Photon> > > > -------------------------------
static void constructor_53691( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >();
}

static void constructor_53692( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >(*(::std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >(*(::std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >*)arg[0]);
}

static void destructor_53693(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >*)o)->::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >::~Wrapper)();
}
static  void method_53694( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >*)o)->product)();
}

static  void operator_53695( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >*)o)->operator->)();
}

static  void method_53696( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >*)o)->productTypeInfo)();
}

static  void method_53697( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >*)o)->typeInfo)();
}

static void constructor_53698( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)arg[0]);
}

static  void method_53699( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >*)o)->getInterface)();
}

static  void method_53700( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53701( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53702( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53703( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >*)o)->dynamicTypeInfo)();
}

static  void method_53704( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >*)o)->isPresent)();
}

static  void method_53705( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9196( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Photon>, std::allocator<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Photon> > > > -------------------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >"), typeid(::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >), sizeof(::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecMuPhoFinalStateCollection>")
  .AddTypedef(type_3510, Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >::value_type"))
  .AddTypedef(type_3510, Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53691, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4231), Reflex::Literal("Wrapper"), constructor_53692, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53693, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85219), Reflex::Literal("Wrapper"), constructor_53698, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9196, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Photon>, std::allocator<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Photon> > > > -------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3510, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Photon>, std::allocator<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Photon> > > > -------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85218), Reflex::Literal("product"), method_53694, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85218), Reflex::Literal("operator->"), operator_53695, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53696, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53697, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85220), Reflex::Literal("getInterface"), method_53699, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53700, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53701, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53702, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53703, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53704, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53705, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Photon> > -------------------------------
static void constructor_53712( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >();
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >();
}

static void constructor_53713( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >(*(::std::auto_ptr<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >(*(::std::auto_ptr<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)arg[0]);
}

static void destructor_53714(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >::~Wrapper)();
}
static  void method_53715( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->product)();
}

static  void operator_53716( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->operator->)();
}

static  void method_53717( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->productTypeInfo)();
}

static  void method_53718( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->typeInfo)();
}

static void constructor_53719( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >((::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >((::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon>*)arg[0]);
}

static  void method_53720( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->getInterface)();
}

static  void method_53721( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53722( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53723( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53724( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->dynamicTypeInfo)();
}

static  void method_53725( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->isPresent)();
}

static  void method_53726( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9197( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Photon> > -------------------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s__datamem_bld(&__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s__funcmem_bld(&__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s__db_funcmem);
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >"), typeid(::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >), sizeof(::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecMuPhoFinalState>")
  .AddTypedef(type_1520, Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >::value_type"))
  .AddTypedef(type_1520, Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53712, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4232), Reflex::Literal("Wrapper"), constructor_53713, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53714, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19339), Reflex::Literal("Wrapper"), constructor_53719, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9197, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Photon> > -------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1520, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Photon> > -------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19341), Reflex::Literal("product"), method_53715, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19341), Reflex::Literal("operator->"), operator_53716, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53717, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53718, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85223), Reflex::Literal("getInterface"), method_53720, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53721, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53722, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53723, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53724, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53725, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53726, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Tau>, std::allocator<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Tau> > > > -------------------------------
static void constructor_53733( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >();
}

static void constructor_53734( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >(*(::std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >(*(::std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >*)arg[0]);
}

static void destructor_53735(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >*)o)->::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >::~Wrapper)();
}
static  void method_53736( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >*)o)->product)();
}

static  void operator_53737( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >*)o)->operator->)();
}

static  void method_53738( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >*)o)->productTypeInfo)();
}

static  void method_53739( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >*)o)->typeInfo)();
}

static void constructor_53740( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)arg[0]);
}

static  void method_53741( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >*)o)->getInterface)();
}

static  void method_53742( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53743( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53744( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53745( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >*)o)->dynamicTypeInfo)();
}

static  void method_53746( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >*)o)->isPresent)();
}

static  void method_53747( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9198( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Tau>, std::allocator<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Tau> > > > -------------------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >"), typeid(::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >), sizeof(::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecMuTauFinalStateCollection>")
  .AddTypedef(type_3537, Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >::value_type"))
  .AddTypedef(type_3537, Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53733, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4233), Reflex::Literal("Wrapper"), constructor_53734, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53735, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85227), Reflex::Literal("Wrapper"), constructor_53740, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9198, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Tau>, std::allocator<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Tau> > > > -------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3537, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Tau>, std::allocator<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Tau> > > > -------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85226), Reflex::Literal("product"), method_53736, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85226), Reflex::Literal("operator->"), operator_53737, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53738, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53739, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85228), Reflex::Literal("getInterface"), method_53741, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53742, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53743, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53744, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53745, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53746, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53747, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Tau> > -------------------------------
static void constructor_53754( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >();
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >();
}

static void constructor_53755( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >(*(::std::auto_ptr<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >(*(::std::auto_ptr<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)arg[0]);
}

static void destructor_53756(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >::~Wrapper)();
}
static  void method_53757( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->product)();
}

static  void operator_53758( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->operator->)();
}

static  void method_53759( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->productTypeInfo)();
}

static  void method_53760( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->typeInfo)();
}

static void constructor_53761( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >((::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >((::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau>*)arg[0]);
}

static  void method_53762( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->getInterface)();
}

static  void method_53763( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53764( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53765( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53766( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->dynamicTypeInfo)();
}

static  void method_53767( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->isPresent)();
}

static  void method_53768( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9199( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Tau> > -------------------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s__datamem_bld(&__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s__funcmem_bld(&__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s__db_funcmem);
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >"), typeid(::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >), sizeof(::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecMuTauFinalState>")
  .AddTypedef(type_1521, Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >::value_type"))
  .AddTypedef(type_1521, Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53754, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4234), Reflex::Literal("Wrapper"), constructor_53755, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53756, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19453), Reflex::Literal("Wrapper"), constructor_53761, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9199, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Tau> > -------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1521, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Tau> > -------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19455), Reflex::Literal("product"), method_53757, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19455), Reflex::Literal("operator->"), operator_53758, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53759, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53760, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85231), Reflex::Literal("getInterface"), method_53762, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53763, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53764, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53765, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53766, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53767, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53768, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Muon>, std::allocator<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Muon> > > > -------------------------------
static void constructor_53775( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >();
}

static void constructor_53776( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >(*(::std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >(*(::std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >*)arg[0]);
}

static void destructor_53777(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >*)o)->::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >::~Wrapper)();
}
static  void method_53778( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >*)o)->product)();
}

static  void operator_53779( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >*)o)->operator->)();
}

static  void method_53780( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >*)o)->productTypeInfo)();
}

static  void method_53781( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >*)o)->typeInfo)();
}

static void constructor_53782( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)arg[0]);
}

static  void method_53783( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >*)o)->getInterface)();
}

static  void method_53784( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53785( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53786( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53787( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >*)o)->dynamicTypeInfo)();
}

static  void method_53788( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >*)o)->isPresent)();
}

static  void method_53789( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9200( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Muon>, std::allocator<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Muon> > > > -------------------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >"), typeid(::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >), sizeof(::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecMuMuFinalStateCollection>")
  .AddTypedef(type_2030, Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >::value_type"))
  .AddTypedef(type_2030, Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53775, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4235), Reflex::Literal("Wrapper"), constructor_53776, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53777, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85235), Reflex::Literal("Wrapper"), constructor_53782, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9200, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Muon>, std::allocator<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Muon> > > > -------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2030, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Muon>, std::allocator<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Muon> > > > -------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85234), Reflex::Literal("product"), method_53778, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85234), Reflex::Literal("operator->"), operator_53779, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53780, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53781, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85236), Reflex::Literal("getInterface"), method_53783, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53784, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53785, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53786, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53787, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53788, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53789, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Muon> > -------------------------------
static void constructor_53796( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >();
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >();
}

static void constructor_53797( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >(*(::std::auto_ptr<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >(*(::std::auto_ptr<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)arg[0]);
}

static void destructor_53798(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >::~Wrapper)();
}
static  void method_53799( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->product)();
}

static  void operator_53800( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->operator->)();
}

static  void method_53801( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->productTypeInfo)();
}

static  void method_53802( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->typeInfo)();
}

static void constructor_53803( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >((::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >((::PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon>*)arg[0]);
}

static  void method_53804( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->getInterface)();
}

static  void method_53805( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53806( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53807( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53808( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->dynamicTypeInfo)();
}

static  void method_53809( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->isPresent)();
}

static  void method_53810( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9201( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Muon> > -------------------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s__datamem_bld(&__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s__funcmem_bld(&__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s__db_funcmem);
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >"), typeid(::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >), sizeof(::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecMuMuFinalState>")
  .AddTypedef(type_1522, Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >::value_type"))
  .AddTypedef(type_1522, Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53796, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4236), Reflex::Literal("Wrapper"), constructor_53797, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53798, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14175), Reflex::Literal("Wrapper"), constructor_53803, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9201, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Muon> > -------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1522, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATTripletFinalStateT<pat::Electron, pat::Muon, pat::Muon> > -------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14177), Reflex::Literal("product"), method_53799, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14177), Reflex::Literal("operator->"), operator_53800, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53801, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53802, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85239), Reflex::Literal("getInterface"), method_53804, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53805, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53806, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53807, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53808, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53809, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53810, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Photon>, std::allocator<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Photon> > > > -------------------------------
static void constructor_53817( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >();
}

static void constructor_53818( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >(*(::std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >(*(::std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >*)arg[0]);
}

static void destructor_53819(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >*)o)->::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >::~Wrapper)();
}
static  void method_53820( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >*)o)->product)();
}

static  void operator_53821( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >*)o)->operator->)();
}

static  void method_53822( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >*)o)->productTypeInfo)();
}

static  void method_53823( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >*)o)->typeInfo)();
}

static void constructor_53824( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)arg[0]);
}

static  void method_53825( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >*)o)->getInterface)();
}

static  void method_53826( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53827( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53828( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53829( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >*)o)->dynamicTypeInfo)();
}

static  void method_53830( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >*)o)->isPresent)();
}

static  void method_53831( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9202( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Photon>, std::allocator<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Photon> > > > -------------------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >"), typeid(::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >), sizeof(::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecElecPhoFinalStateCollection>")
  .AddTypedef(type_3132, Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >::value_type"))
  .AddTypedef(type_3132, Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53817, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4237), Reflex::Literal("Wrapper"), constructor_53818, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53819, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85243), Reflex::Literal("Wrapper"), constructor_53824, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9202, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Photon>, std::allocator<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Photon> > > > -------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3132, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Photon>, std::allocator<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Photon> > > > -------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85242), Reflex::Literal("product"), method_53820, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85242), Reflex::Literal("operator->"), operator_53821, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53822, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53823, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85244), Reflex::Literal("getInterface"), method_53825, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53826, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53827, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53828, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53829, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53830, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53831, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Photon> > -------------------------------
static void constructor_53838( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >();
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >();
}

static void constructor_53839( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >(*(::std::auto_ptr<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >(*(::std::auto_ptr<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)arg[0]);
}

static void destructor_53840(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >::~Wrapper)();
}
static  void method_53841( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->product)();
}

static  void operator_53842( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->operator->)();
}

static  void method_53843( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->productTypeInfo)();
}

static  void method_53844( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->typeInfo)();
}

static void constructor_53845( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >((::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >((::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon>*)arg[0]);
}

static  void method_53846( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->getInterface)();
}

static  void method_53847( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53848( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53849( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53850( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->dynamicTypeInfo)();
}

static  void method_53851( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->isPresent)();
}

static  void method_53852( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9203( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Photon> > -------------------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s__datamem_bld(&__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s__funcmem_bld(&__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s__db_funcmem);
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >"), typeid(::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >), sizeof(::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecElecPhoFinalState>")
  .AddTypedef(type_1393, Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >::value_type"))
  .AddTypedef(type_1393, Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53838, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4238), Reflex::Literal("Wrapper"), constructor_53839, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53840, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18599), Reflex::Literal("Wrapper"), constructor_53845, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9203, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Photon> > -------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1393, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Photon> > -------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18601), Reflex::Literal("product"), method_53841, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18601), Reflex::Literal("operator->"), operator_53842, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53843, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53844, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85247), Reflex::Literal("getInterface"), method_53846, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53847, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53848, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53849, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53850, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53851, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53852, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Tau>, std::allocator<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Tau> > > > -------------------------------
static void constructor_53859( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >();
}

static void constructor_53860( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >(*(::std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >(*(::std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >*)arg[0]);
}

static void destructor_53861(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >*)o)->::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >::~Wrapper)();
}
static  void method_53862( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >*)o)->product)();
}

static  void operator_53863( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >*)o)->operator->)();
}

static  void method_53864( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >*)o)->productTypeInfo)();
}

static  void method_53865( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >*)o)->typeInfo)();
}

static void constructor_53866( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)arg[0]);
}

static  void method_53867( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >*)o)->getInterface)();
}

static  void method_53868( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53869( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53870( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53871( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >*)o)->dynamicTypeInfo)();
}

static  void method_53872( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >*)o)->isPresent)();
}

static  void method_53873( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9204( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Tau>, std::allocator<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Tau> > > > -------------------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >"), typeid(::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >), sizeof(::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecElecTauFinalStateCollection>")
  .AddTypedef(type_1270, Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >::value_type"))
  .AddTypedef(type_1270, Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53859, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4239), Reflex::Literal("Wrapper"), constructor_53860, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53861, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85251), Reflex::Literal("Wrapper"), constructor_53866, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9204, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Tau>, std::allocator<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Tau> > > > -------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1270, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Tau>, std::allocator<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Tau> > > > -------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85250), Reflex::Literal("product"), method_53862, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85250), Reflex::Literal("operator->"), operator_53863, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53864, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53865, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85252), Reflex::Literal("getInterface"), method_53867, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53868, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53869, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53870, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53871, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53872, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53873, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Tau> > -------------------------------
static void constructor_53880( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >();
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >();
}

static void constructor_53881( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >(*(::std::auto_ptr<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >(*(::std::auto_ptr<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)arg[0]);
}

static void destructor_53882(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >::~Wrapper)();
}
static  void method_53883( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->product)();
}

static  void operator_53884( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->operator->)();
}

static  void method_53885( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->productTypeInfo)();
}

static  void method_53886( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->typeInfo)();
}

static void constructor_53887( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >((::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >((::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau>*)arg[0]);
}

static  void method_53888( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->getInterface)();
}

static  void method_53889( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53890( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53891( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53892( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->dynamicTypeInfo)();
}

static  void method_53893( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->isPresent)();
}

static  void method_53894( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9205( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Tau> > -------------------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s__datamem_bld(&__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s__funcmem_bld(&__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s__db_funcmem);
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >"), typeid(::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >), sizeof(::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecElecTauFinalState>")
  .AddTypedef(type_1121, Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >::value_type"))
  .AddTypedef(type_1121, Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53880, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4240), Reflex::Literal("Wrapper"), constructor_53881, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53882, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11865), Reflex::Literal("Wrapper"), constructor_53887, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9205, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Tau> > -------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1121, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Tau> > -------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11867), Reflex::Literal("product"), method_53883, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11867), Reflex::Literal("operator->"), operator_53884, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53885, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53886, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85255), Reflex::Literal("getInterface"), method_53888, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53889, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53890, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53891, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53892, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53893, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53894, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Muon>, std::allocator<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Muon> > > > -------------------------------
static void constructor_53901( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >();
}

static void constructor_53902( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >(*(::std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >(*(::std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >*)arg[0]);
}

static void destructor_53903(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >*)o)->::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >::~Wrapper)();
}
static  void method_53904( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >*)o)->product)();
}

static  void operator_53905( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >*)o)->operator->)();
}

static  void method_53906( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >*)o)->productTypeInfo)();
}

static  void method_53907( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >*)o)->typeInfo)();
}

static void constructor_53908( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)arg[0]);
}

static  void method_53909( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >*)o)->getInterface)();
}

static  void method_53910( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53911( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53912( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53913( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >*)o)->dynamicTypeInfo)();
}

static  void method_53914( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >*)o)->isPresent)();
}

static  void method_53915( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9206( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Muon>, std::allocator<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Muon> > > > -------------------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >"), typeid(::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >), sizeof(::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecElecMuFinalStateCollection>")
  .AddTypedef(type_1976, Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >::value_type"))
  .AddTypedef(type_1976, Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53901, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4241), Reflex::Literal("Wrapper"), constructor_53902, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53903, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85259), Reflex::Literal("Wrapper"), constructor_53908, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9206, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Muon>, std::allocator<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Muon> > > > -------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1976, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Muon>, std::allocator<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Muon> > > > -------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85258), Reflex::Literal("product"), method_53904, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85258), Reflex::Literal("operator->"), operator_53905, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53906, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53907, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85260), Reflex::Literal("getInterface"), method_53909, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53910, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53911, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53912, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53913, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53914, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53915, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Muon> > -------------------------------
static void constructor_53922( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >();
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >();
}

static void constructor_53923( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >(*(::std::auto_ptr<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >(*(::std::auto_ptr<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)arg[0]);
}

static void destructor_53924(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >::~Wrapper)();
}
static  void method_53925( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->product)();
}

static  void operator_53926( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->operator->)();
}

static  void method_53927( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->productTypeInfo)();
}

static  void method_53928( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->typeInfo)();
}

static void constructor_53929( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >((::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >((::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon>*)arg[0]);
}

static  void method_53930( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->getInterface)();
}

static  void method_53931( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53932( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53933( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53934( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->dynamicTypeInfo)();
}

static  void method_53935( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->isPresent)();
}

static  void method_53936( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9207( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Muon> > -------------------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s__datamem_bld(&__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s__funcmem_bld(&__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s__db_funcmem);
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >"), typeid(::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >), sizeof(::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecElecMuFinalState>")
  .AddTypedef(type_1523, Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >::value_type"))
  .AddTypedef(type_1523, Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53922, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4242), Reflex::Literal("Wrapper"), constructor_53923, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53924, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13936), Reflex::Literal("Wrapper"), constructor_53929, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9207, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Muon> > -------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1523, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Muon> > -------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13938), Reflex::Literal("product"), method_53925, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13938), Reflex::Literal("operator->"), operator_53926, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53927, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53928, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85263), Reflex::Literal("getInterface"), method_53930, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53931, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53932, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53933, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53934, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53935, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53936, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Electron>, std::allocator<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Electron> > > > -------------------------------
static void constructor_53943( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >();
}

static void constructor_53944( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >(*(::std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >(*(::std::auto_ptr<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >*)arg[0]);
}

static void destructor_53945(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >*)o)->::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >::~Wrapper)();
}
static  void method_53946( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >*)o)->product)();
}

static  void operator_53947( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >*)o)->operator->)();
}

static  void method_53948( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >*)o)->productTypeInfo)();
}

static  void method_53949( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >*)o)->typeInfo)();
}

static void constructor_53950( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >((::std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)arg[0]);
}

static  void method_53951( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >*)o)->getInterface)();
}

static  void method_53952( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53953( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53954( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53955( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >*)o)->dynamicTypeInfo)();
}

static  void method_53956( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >*)o)->isPresent)();
}

static  void method_53957( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9208( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Electron>, std::allocator<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Electron> > > > -------------------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >"), typeid(::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >), sizeof(::edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecElecElecFinalStateCollection>")
  .AddTypedef(type_3126, Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >::value_type"))
  .AddTypedef(type_3126, Reflex::Literal("edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53943, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4243), Reflex::Literal("Wrapper"), constructor_53944, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53945, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85267), Reflex::Literal("Wrapper"), constructor_53950, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9208, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Electron>, std::allocator<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Electron> > > > -------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3126, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Electron>, std::allocator<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Electron> > > > -------------------
void __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85266), Reflex::Literal("product"), method_53946, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85266), Reflex::Literal("operator->"), operator_53947, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53948, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53949, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85268), Reflex::Literal("getInterface"), method_53951, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53952, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53953, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53954, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53955, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53956, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53957, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Electron> > -------------------------------
static void constructor_53964( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >();
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >();
}

static void constructor_53965( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >(*(::std::auto_ptr<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >(*(::std::auto_ptr<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)arg[0]);
}

static void destructor_53966(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >::~Wrapper)();
}
static  void method_53967( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->product)();
}

static  void operator_53968( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->operator->)();
}

static  void method_53969( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->productTypeInfo)();
}

static  void method_53970( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->typeInfo)();
}

static void constructor_53971( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >((::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >((::PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron>*)arg[0]);
}

static  void method_53972( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->getInterface)();
}

static  void method_53973( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53974( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53975( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53976( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->dynamicTypeInfo)();
}

static  void method_53977( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->isPresent)();
}

static  void method_53978( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9209( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Electron> > -------------------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s__datamem_bld(&__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s__funcmem_bld(&__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s__db_funcmem);
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >"), typeid(::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >), sizeof(::edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecElecElecFinalState>")
  .AddTypedef(type_1524, Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >::value_type"))
  .AddTypedef(type_1524, Reflex::Literal("edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53964, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4244), Reflex::Literal("Wrapper"), constructor_53965, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53966, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18534), Reflex::Literal("Wrapper"), constructor_53971, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9209, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Electron> > -------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1524, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATTripletFinalStateT<pat::Electron, pat::Electron, pat::Electron> > -------------------
void __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18536), Reflex::Literal("product"), method_53967, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18536), Reflex::Literal("operator->"), operator_53968, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53969, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53970, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85271), Reflex::Literal("getInterface"), method_53972, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53973, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53974, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53975, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53976, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53977, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53978, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATPairFinalStateT<pat::Electron, pat::Jet>, std::allocator<PATPairFinalStateT<pat::Electron, pat::Jet> > > > -------------------------------
static void constructor_53985( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >();
}

static void constructor_53986( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >(*(::std::auto_ptr<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >(*(::std::auto_ptr<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >*)arg[0]);
}

static void destructor_53987(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >*)o)->::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >::~Wrapper)();
}
static  void method_53988( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >*)o)->product)();
}

static  void operator_53989( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >*)o)->operator->)();
}

static  void method_53990( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >*)o)->productTypeInfo)();
}

static  void method_53991( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >*)o)->typeInfo)();
}

static void constructor_53992( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >((::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >((::std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> >*)arg[0]);
}

static  void method_53993( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >*)o)->getInterface)();
}

static  void method_53994( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_53995( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_53996( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_53997( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >*)o)->dynamicTypeInfo)();
}

static  void method_53998( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >*)o)->isPresent)();
}

static  void method_53999( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9210( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATPairFinalStateT<pat::Electron, pat::Jet>, std::allocator<PATPairFinalStateT<pat::Electron, pat::Jet> > > > -------------------------------
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Jet_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Jet_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Jet_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Jet_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Jet_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Jet_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Jet_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >"), typeid(::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >), sizeof(::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecJetFinalStateCollection>")
  .AddTypedef(type_444, Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >::value_type"))
  .AddTypedef(type_444, Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_53985, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4245), Reflex::Literal("Wrapper"), constructor_53986, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_53987, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85275), Reflex::Literal("Wrapper"), constructor_53992, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9210, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Jet_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Jet_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATPairFinalStateT<pat::Electron, pat::Jet>, std::allocator<PATPairFinalStateT<pat::Electron, pat::Jet> > > > -------------------
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Jet_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Jet_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_444, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Jet_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATPairFinalStateT<pat::Electron, pat::Jet>, std::allocator<PATPairFinalStateT<pat::Electron, pat::Jet> > > > -------------------
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Jet_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85274), Reflex::Literal("product"), method_53988, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85274), Reflex::Literal("operator->"), operator_53989, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_53990, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_53991, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85276), Reflex::Literal("getInterface"), method_53993, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_53994, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_53995, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_53996, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_53997, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_53998, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_53999, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATPairFinalStateT<pat::Electron, pat::Jet> > -------------------------------
static void constructor_54006( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Jet> >();
  else ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Jet> >();
}

static void constructor_54007( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Jet> >(*(::std::auto_ptr<PATPairFinalStateT<pat::Electron,pat::Jet> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Jet> >(*(::std::auto_ptr<PATPairFinalStateT<pat::Electron,pat::Jet> >*)arg[0]);
}

static void destructor_54008(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Jet> >::~Wrapper)();
}
static  void method_54009( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->product)();
}

static  void operator_54010( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->operator->)();
}

static  void method_54011( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->productTypeInfo)();
}

static  void method_54012( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->typeInfo)();
}

static void constructor_54013( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Jet> >((::PATPairFinalStateT<pat::Electron,pat::Jet>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Jet> >((::PATPairFinalStateT<pat::Electron,pat::Jet>*)arg[0]);
}

static  void method_54014( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->getInterface)();
}

static  void method_54015( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_54016( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_54017( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_54018( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->dynamicTypeInfo)();
}

static  void method_54019( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->isPresent)();
}

static  void method_54020( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Jet> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9211( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Jet> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Jet> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Jet> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Jet> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Jet> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATPairFinalStateT<pat::Electron, pat::Jet> > -------------------------------
void __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Jet_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Jet_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Jet_s__datamem_bld(&__edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Jet_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Jet_s__funcmem_bld(&__edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Jet_s__db_funcmem);
void __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Jet_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Jet> >"), typeid(::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Jet> >), sizeof(::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Jet> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecJetFinalState>")
  .AddTypedef(type_1593, Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Jet> >::value_type"))
  .AddTypedef(type_1593, Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Jet> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_54006, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4246), Reflex::Literal("Wrapper"), constructor_54007, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_54008, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7349), Reflex::Literal("Wrapper"), constructor_54013, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9211, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Jet_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Jet_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATPairFinalStateT<pat::Electron, pat::Jet> > -------------------
void __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Jet_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Jet_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1593, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Jet_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATPairFinalStateT<pat::Electron, pat::Jet> > -------------------
void __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Jet_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7351), Reflex::Literal("product"), method_54009, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7351), Reflex::Literal("operator->"), operator_54010, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_54011, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_54012, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85279), Reflex::Literal("getInterface"), method_54014, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_54015, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_54016, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_54017, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_54018, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_54019, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_54020, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATPairFinalStateT<pat::Muon, pat::Jet>, std::allocator<PATPairFinalStateT<pat::Muon, pat::Jet> > > > -------------------------------
static void constructor_54027( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >();
}

static void constructor_54028( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >(*(::std::auto_ptr<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >(*(::std::auto_ptr<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >*)arg[0]);
}

static void destructor_54029(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >*)o)->::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >::~Wrapper)();
}
static  void method_54030( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >*)o)->product)();
}

static  void operator_54031( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >*)o)->operator->)();
}

static  void method_54032( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >*)o)->productTypeInfo)();
}

static  void method_54033( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >*)o)->typeInfo)();
}

static void constructor_54034( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >((::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >((::std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> >*)arg[0]);
}

static  void method_54035( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >*)o)->getInterface)();
}

static  void method_54036( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_54037( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_54038( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_54039( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >*)o)->dynamicTypeInfo)();
}

static  void method_54040( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >*)o)->isPresent)();
}

static  void method_54041( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9212( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATPairFinalStateT<pat::Muon, pat::Jet>, std::allocator<PATPairFinalStateT<pat::Muon, pat::Jet> > > > -------------------------------
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Jet_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Jet_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Jet_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Jet_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Jet_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Jet_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Jet_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >"), typeid(::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >), sizeof(::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATMuJetFinalStateCollection>")
  .AddTypedef(type_1869, Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >::value_type"))
  .AddTypedef(type_1869, Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_54027, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4247), Reflex::Literal("Wrapper"), constructor_54028, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_54029, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85283), Reflex::Literal("Wrapper"), constructor_54034, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9212, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Jet_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Jet_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATPairFinalStateT<pat::Muon, pat::Jet>, std::allocator<PATPairFinalStateT<pat::Muon, pat::Jet> > > > -------------------
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Jet_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Jet_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1869, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Jet_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATPairFinalStateT<pat::Muon, pat::Jet>, std::allocator<PATPairFinalStateT<pat::Muon, pat::Jet> > > > -------------------
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Jet_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85282), Reflex::Literal("product"), method_54030, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85282), Reflex::Literal("operator->"), operator_54031, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_54032, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_54033, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85284), Reflex::Literal("getInterface"), method_54035, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_54036, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_54037, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_54038, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_54039, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_54040, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_54041, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATPairFinalStateT<pat::Muon, pat::Jet> > -------------------------------
static void constructor_54048( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Jet> >();
  else ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Jet> >();
}

static void constructor_54049( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Jet> >(*(::std::auto_ptr<PATPairFinalStateT<pat::Muon,pat::Jet> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Jet> >(*(::std::auto_ptr<PATPairFinalStateT<pat::Muon,pat::Jet> >*)arg[0]);
}

static void destructor_54050(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Jet> >::~Wrapper)();
}
static  void method_54051( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->product)();
}

static  void operator_54052( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->operator->)();
}

static  void method_54053( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->productTypeInfo)();
}

static  void method_54054( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->typeInfo)();
}

static void constructor_54055( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Jet> >((::PATPairFinalStateT<pat::Muon,pat::Jet>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Jet> >((::PATPairFinalStateT<pat::Muon,pat::Jet>*)arg[0]);
}

static  void method_54056( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->getInterface)();
}

static  void method_54057( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_54058( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_54059( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_54060( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->dynamicTypeInfo)();
}

static  void method_54061( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->isPresent)();
}

static  void method_54062( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Jet> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9213( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Jet> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Jet> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Jet> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Jet> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Jet> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATPairFinalStateT<pat::Muon, pat::Jet> > -------------------------------
void __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Jet_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Jet_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Jet_s__datamem_bld(&__edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Jet_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Jet_s__funcmem_bld(&__edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Jet_s__db_funcmem);
void __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Jet_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Jet> >"), typeid(::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Jet> >), sizeof(::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Jet> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATMuJetFinalState>")
  .AddTypedef(type_288, Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Jet> >::value_type"))
  .AddTypedef(type_288, Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Jet> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_54048, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4248), Reflex::Literal("Wrapper"), constructor_54049, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_54050, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13615), Reflex::Literal("Wrapper"), constructor_54055, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9213, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Jet_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Jet_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATPairFinalStateT<pat::Muon, pat::Jet> > -------------------
void __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Jet_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Jet_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_288, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Jet_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATPairFinalStateT<pat::Muon, pat::Jet> > -------------------
void __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Jet_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13617), Reflex::Literal("product"), method_54051, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13617), Reflex::Literal("operator->"), operator_54052, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_54053, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_54054, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85287), Reflex::Literal("getInterface"), method_54056, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_54057, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_54058, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_54059, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_54060, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_54061, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_54062, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATPairFinalStateT<pat::Photon, pat::Photon>, std::allocator<PATPairFinalStateT<pat::Photon, pat::Photon> > > > -------------------------------
static void constructor_54069( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >();
}

static void constructor_54070( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >(*(::std::auto_ptr<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >(*(::std::auto_ptr<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >*)arg[0]);
}

static void destructor_54071(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >*)o)->::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >::~Wrapper)();
}
static  void method_54072( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >*)o)->product)();
}

static  void operator_54073( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >*)o)->operator->)();
}

static  void method_54074( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >*)o)->productTypeInfo)();
}

static  void method_54075( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >*)o)->typeInfo)();
}

static void constructor_54076( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >((::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >((::std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> >*)arg[0]);
}

static  void method_54077( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >*)o)->getInterface)();
}

static  void method_54078( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_54079( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_54080( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_54081( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >*)o)->dynamicTypeInfo)();
}

static  void method_54082( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >*)o)->isPresent)();
}

static  void method_54083( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9214( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATPairFinalStateT<pat::Photon, pat::Photon>, std::allocator<PATPairFinalStateT<pat::Photon, pat::Photon> > > > -------------------------------
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Photon_pat__Photon_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Photon_pat__Photon_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Photon_pat__Photon_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Photon_pat__Photon_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Photon_pat__Photon_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Photon_pat__Photon_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Photon_pat__Photon_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >"), typeid(::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >), sizeof(::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATPhoPhoFinalStateCollection>")
  .AddTypedef(type_1251, Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >::value_type"))
  .AddTypedef(type_1251, Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_54069, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4249), Reflex::Literal("Wrapper"), constructor_54070, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_54071, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85291), Reflex::Literal("Wrapper"), constructor_54076, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9214, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Photon_pat__Photon_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Photon_pat__Photon_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATPairFinalStateT<pat::Photon, pat::Photon>, std::allocator<PATPairFinalStateT<pat::Photon, pat::Photon> > > > -------------------
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Photon_pat__Photon_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Photon_pat__Photon_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1251, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Photon_pat__Photon_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATPairFinalStateT<pat::Photon, pat::Photon>, std::allocator<PATPairFinalStateT<pat::Photon, pat::Photon> > > > -------------------
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Photon_pat__Photon_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85290), Reflex::Literal("product"), method_54072, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85290), Reflex::Literal("operator->"), operator_54073, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_54074, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_54075, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85292), Reflex::Literal("getInterface"), method_54077, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_54078, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_54079, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_54080, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_54081, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_54082, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_54083, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATPairFinalStateT<pat::Photon, pat::Photon> > -------------------------------
static void constructor_54090( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Photon,pat::Photon> >();
  else ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Photon,pat::Photon> >();
}

static void constructor_54091( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Photon,pat::Photon> >(*(::std::auto_ptr<PATPairFinalStateT<pat::Photon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Photon,pat::Photon> >(*(::std::auto_ptr<PATPairFinalStateT<pat::Photon,pat::Photon> >*)arg[0]);
}

static void destructor_54092(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->::edm::Wrapper<PATPairFinalStateT<pat::Photon,pat::Photon> >::~Wrapper)();
}
static  void method_54093( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->product)();
}

static  void operator_54094( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->operator->)();
}

static  void method_54095( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->productTypeInfo)();
}

static  void method_54096( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->typeInfo)();
}

static void constructor_54097( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Photon,pat::Photon> >((::PATPairFinalStateT<pat::Photon,pat::Photon>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Photon,pat::Photon> >((::PATPairFinalStateT<pat::Photon,pat::Photon>*)arg[0]);
}

static  void method_54098( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->getInterface)();
}

static  void method_54099( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_54100( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_54101( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_54102( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->dynamicTypeInfo)();
}

static  void method_54103( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->isPresent)();
}

static  void method_54104( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Photon,pat::Photon> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9215( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Photon,pat::Photon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Photon,pat::Photon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Photon,pat::Photon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Photon,pat::Photon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Photon,pat::Photon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATPairFinalStateT<pat::Photon, pat::Photon> > -------------------------------
void __edm__Wrapper_PATPairFinalStateT_pat__Photon_pat__Photon_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATPairFinalStateT_pat__Photon_pat__Photon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATPairFinalStateT_pat__Photon_pat__Photon_s__datamem_bld(&__edm__Wrapper_PATPairFinalStateT_pat__Photon_pat__Photon_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATPairFinalStateT_pat__Photon_pat__Photon_s__funcmem_bld(&__edm__Wrapper_PATPairFinalStateT_pat__Photon_pat__Photon_s__db_funcmem);
void __edm__Wrapper_PATPairFinalStateT_pat__Photon_pat__Photon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Photon,pat::Photon> >"), typeid(::edm::Wrapper<PATPairFinalStateT<pat::Photon,pat::Photon> >), sizeof(::edm::Wrapper<PATPairFinalStateT<pat::Photon,pat::Photon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATPhoPhoFinalState>")
  .AddTypedef(type_1155, Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Photon,pat::Photon> >::value_type"))
  .AddTypedef(type_1155, Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Photon,pat::Photon> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_54090, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4250), Reflex::Literal("Wrapper"), constructor_54091, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_54092, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11776), Reflex::Literal("Wrapper"), constructor_54097, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9215, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATPairFinalStateT_pat__Photon_pat__Photon_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATPairFinalStateT_pat__Photon_pat__Photon_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATPairFinalStateT<pat::Photon, pat::Photon> > -------------------
void __edm__Wrapper_PATPairFinalStateT_pat__Photon_pat__Photon_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATPairFinalStateT_pat__Photon_pat__Photon_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1155, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATPairFinalStateT_pat__Photon_pat__Photon_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATPairFinalStateT<pat::Photon, pat::Photon> > -------------------
void __edm__Wrapper_PATPairFinalStateT_pat__Photon_pat__Photon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11778), Reflex::Literal("product"), method_54093, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11778), Reflex::Literal("operator->"), operator_54094, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_54095, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_54096, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85295), Reflex::Literal("getInterface"), method_54098, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_54099, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_54100, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_54101, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_54102, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_54103, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_54104, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATPairFinalStateT<pat::Tau, pat::Tau>, std::allocator<PATPairFinalStateT<pat::Tau, pat::Tau> > > > -------------------------------
static void constructor_54153( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >();
}

static void constructor_54154( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >(*(::std::auto_ptr<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >(*(::std::auto_ptr<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >*)arg[0]);
}

static void destructor_54155(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >*)o)->::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >::~Wrapper)();
}
static  void method_54156( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >*)o)->product)();
}

static  void operator_54157( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >*)o)->operator->)();
}

static  void method_54158( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >*)o)->productTypeInfo)();
}

static  void method_54159( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >*)o)->typeInfo)();
}

static void constructor_54160( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >((::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >((::std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> >*)arg[0]);
}

static  void method_54161( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >*)o)->getInterface)();
}

static  void method_54162( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_54163( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_54164( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_54165( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >*)o)->dynamicTypeInfo)();
}

static  void method_54166( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >*)o)->isPresent)();
}

static  void method_54167( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9218( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATPairFinalStateT<pat::Tau, pat::Tau>, std::allocator<PATPairFinalStateT<pat::Tau, pat::Tau> > > > -------------------------------
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Tau_pat__Tau_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Tau_pat__Tau_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Tau_pat__Tau_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Tau_pat__Tau_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Tau_pat__Tau_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Tau_pat__Tau_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Tau_pat__Tau_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >"), typeid(::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >), sizeof(::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATTauTauFinalStateCollection>")
  .AddTypedef(type_3403, Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >::value_type"))
  .AddTypedef(type_3403, Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_54153, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4253), Reflex::Literal("Wrapper"), constructor_54154, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_54155, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85307), Reflex::Literal("Wrapper"), constructor_54160, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9218, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Tau_pat__Tau_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Tau_pat__Tau_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATPairFinalStateT<pat::Tau, pat::Tau>, std::allocator<PATPairFinalStateT<pat::Tau, pat::Tau> > > > -------------------
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Tau_pat__Tau_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Tau_pat__Tau_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3403, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Tau_pat__Tau_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATPairFinalStateT<pat::Tau, pat::Tau>, std::allocator<PATPairFinalStateT<pat::Tau, pat::Tau> > > > -------------------
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Tau_pat__Tau_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85306), Reflex::Literal("product"), method_54156, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85306), Reflex::Literal("operator->"), operator_54157, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_54158, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_54159, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85308), Reflex::Literal("getInterface"), method_54161, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_54162, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_54163, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_54164, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_54165, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_54166, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_54167, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATPairFinalStateT<pat::Tau, pat::Tau> > -------------------------------
static void constructor_54174( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Tau,pat::Tau> >();
  else ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Tau,pat::Tau> >();
}

static void constructor_54175( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Tau,pat::Tau> >(*(::std::auto_ptr<PATPairFinalStateT<pat::Tau,pat::Tau> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Tau,pat::Tau> >(*(::std::auto_ptr<PATPairFinalStateT<pat::Tau,pat::Tau> >*)arg[0]);
}

static void destructor_54176(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->::edm::Wrapper<PATPairFinalStateT<pat::Tau,pat::Tau> >::~Wrapper)();
}
static  void method_54177( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->product)();
}

static  void operator_54178( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->operator->)();
}

static  void method_54179( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->productTypeInfo)();
}

static  void method_54180( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->typeInfo)();
}

static void constructor_54181( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Tau,pat::Tau> >((::PATPairFinalStateT<pat::Tau,pat::Tau>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Tau,pat::Tau> >((::PATPairFinalStateT<pat::Tau,pat::Tau>*)arg[0]);
}

static  void method_54182( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->getInterface)();
}

static  void method_54183( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_54184( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_54185( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_54186( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->dynamicTypeInfo)();
}

static  void method_54187( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->isPresent)();
}

static  void method_54188( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Tau,pat::Tau> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9219( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Tau,pat::Tau> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Tau,pat::Tau> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Tau,pat::Tau> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Tau,pat::Tau> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Tau,pat::Tau> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATPairFinalStateT<pat::Tau, pat::Tau> > -------------------------------
void __edm__Wrapper_PATPairFinalStateT_pat__Tau_pat__Tau_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATPairFinalStateT_pat__Tau_pat__Tau_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATPairFinalStateT_pat__Tau_pat__Tau_s__datamem_bld(&__edm__Wrapper_PATPairFinalStateT_pat__Tau_pat__Tau_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATPairFinalStateT_pat__Tau_pat__Tau_s__funcmem_bld(&__edm__Wrapper_PATPairFinalStateT_pat__Tau_pat__Tau_s__db_funcmem);
void __edm__Wrapper_PATPairFinalStateT_pat__Tau_pat__Tau_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Tau,pat::Tau> >"), typeid(::edm::Wrapper<PATPairFinalStateT<pat::Tau,pat::Tau> >), sizeof(::edm::Wrapper<PATPairFinalStateT<pat::Tau,pat::Tau> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATTauTauFinalState>")
  .AddTypedef(type_334, Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Tau,pat::Tau> >::value_type"))
  .AddTypedef(type_334, Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Tau,pat::Tau> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_54174, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4254), Reflex::Literal("Wrapper"), constructor_54175, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_54176, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19143), Reflex::Literal("Wrapper"), constructor_54181, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9219, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATPairFinalStateT_pat__Tau_pat__Tau_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATPairFinalStateT_pat__Tau_pat__Tau_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATPairFinalStateT<pat::Tau, pat::Tau> > -------------------
void __edm__Wrapper_PATPairFinalStateT_pat__Tau_pat__Tau_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATPairFinalStateT_pat__Tau_pat__Tau_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_334, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATPairFinalStateT_pat__Tau_pat__Tau_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATPairFinalStateT<pat::Tau, pat::Tau> > -------------------
void __edm__Wrapper_PATPairFinalStateT_pat__Tau_pat__Tau_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19145), Reflex::Literal("product"), method_54177, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19145), Reflex::Literal("operator->"), operator_54178, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_54179, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_54180, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85311), Reflex::Literal("getInterface"), method_54182, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_54183, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_54184, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_54185, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_54186, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_54187, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_54188, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATPairFinalStateT<pat::Muon, pat::Photon>, std::allocator<PATPairFinalStateT<pat::Muon, pat::Photon> > > > -------------------------------
static void constructor_54195( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >();
}

static void constructor_54196( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >(*(::std::auto_ptr<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >(*(::std::auto_ptr<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >*)arg[0]);
}

static void destructor_54197(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >*)o)->::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >::~Wrapper)();
}
static  void method_54198( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >*)o)->product)();
}

static  void operator_54199( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >*)o)->operator->)();
}

static  void method_54200( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >*)o)->productTypeInfo)();
}

static  void method_54201( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >*)o)->typeInfo)();
}

static void constructor_54202( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >((::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >((::std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> >*)arg[0]);
}

static  void method_54203( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >*)o)->getInterface)();
}

static  void method_54204( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_54205( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_54206( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_54207( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >*)o)->dynamicTypeInfo)();
}

static  void method_54208( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >*)o)->isPresent)();
}

static  void method_54209( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9220( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATPairFinalStateT<pat::Muon, pat::Photon>, std::allocator<PATPairFinalStateT<pat::Muon, pat::Photon> > > > -------------------------------
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Photon_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Photon_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Photon_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Photon_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Photon_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Photon_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Photon_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >"), typeid(::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >), sizeof(::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATMuPhoFinalStateCollection>")
  .AddTypedef(type_3550, Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >::value_type"))
  .AddTypedef(type_3550, Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_54195, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4255), Reflex::Literal("Wrapper"), constructor_54196, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_54197, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85315), Reflex::Literal("Wrapper"), constructor_54202, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9220, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Photon_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Photon_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATPairFinalStateT<pat::Muon, pat::Photon>, std::allocator<PATPairFinalStateT<pat::Muon, pat::Photon> > > > -------------------
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Photon_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Photon_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3550, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Photon_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATPairFinalStateT<pat::Muon, pat::Photon>, std::allocator<PATPairFinalStateT<pat::Muon, pat::Photon> > > > -------------------
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Photon_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85314), Reflex::Literal("product"), method_54198, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85314), Reflex::Literal("operator->"), operator_54199, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_54200, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_54201, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85316), Reflex::Literal("getInterface"), method_54203, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_54204, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_54205, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_54206, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_54207, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_54208, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_54209, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATPairFinalStateT<pat::Muon, pat::Photon> > -------------------------------
static void constructor_54216( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Photon> >();
  else ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Photon> >();
}

static void constructor_54217( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Photon> >(*(::std::auto_ptr<PATPairFinalStateT<pat::Muon,pat::Photon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Photon> >(*(::std::auto_ptr<PATPairFinalStateT<pat::Muon,pat::Photon> >*)arg[0]);
}

static void destructor_54218(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Photon> >::~Wrapper)();
}
static  void method_54219( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->product)();
}

static  void operator_54220( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->operator->)();
}

static  void method_54221( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->productTypeInfo)();
}

static  void method_54222( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->typeInfo)();
}

static void constructor_54223( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Photon> >((::PATPairFinalStateT<pat::Muon,pat::Photon>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Photon> >((::PATPairFinalStateT<pat::Muon,pat::Photon>*)arg[0]);
}

static  void method_54224( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->getInterface)();
}

static  void method_54225( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_54226( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_54227( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_54228( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->dynamicTypeInfo)();
}

static  void method_54229( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->isPresent)();
}

static  void method_54230( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Photon> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9221( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Photon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Photon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Photon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Photon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Photon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATPairFinalStateT<pat::Muon, pat::Photon> > -------------------------------
void __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Photon_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Photon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Photon_s__datamem_bld(&__edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Photon_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Photon_s__funcmem_bld(&__edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Photon_s__db_funcmem);
void __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Photon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Photon> >"), typeid(::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Photon> >), sizeof(::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Photon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATMuPhoFinalState>")
  .AddTypedef(type_1607, Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Photon> >::value_type"))
  .AddTypedef(type_1607, Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Photon> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_54216, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4256), Reflex::Literal("Wrapper"), constructor_54217, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_54218, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19536), Reflex::Literal("Wrapper"), constructor_54223, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9221, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Photon_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Photon_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATPairFinalStateT<pat::Muon, pat::Photon> > -------------------
void __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Photon_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Photon_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1607, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Photon_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATPairFinalStateT<pat::Muon, pat::Photon> > -------------------
void __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Photon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19538), Reflex::Literal("product"), method_54219, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19538), Reflex::Literal("operator->"), operator_54220, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_54221, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_54222, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85319), Reflex::Literal("getInterface"), method_54224, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_54225, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_54226, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_54227, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_54228, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_54229, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_54230, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATPairFinalStateT<pat::Muon, pat::Tau>, std::allocator<PATPairFinalStateT<pat::Muon, pat::Tau> > > > -------------------------------
static void constructor_54237( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >();
}

static void constructor_54238( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >(*(::std::auto_ptr<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >(*(::std::auto_ptr<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >*)arg[0]);
}

static void destructor_54239(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >*)o)->::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >::~Wrapper)();
}
static  void method_54240( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >*)o)->product)();
}

static  void operator_54241( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >*)o)->operator->)();
}

static  void method_54242( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >*)o)->productTypeInfo)();
}

static  void method_54243( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >*)o)->typeInfo)();
}

static void constructor_54244( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >((::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >((::std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> >*)arg[0]);
}

static  void method_54245( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >*)o)->getInterface)();
}

static  void method_54246( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_54247( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_54248( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_54249( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >*)o)->dynamicTypeInfo)();
}

static  void method_54250( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >*)o)->isPresent)();
}

static  void method_54251( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9222( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATPairFinalStateT<pat::Muon, pat::Tau>, std::allocator<PATPairFinalStateT<pat::Muon, pat::Tau> > > > -------------------------------
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Tau_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Tau_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Tau_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Tau_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Tau_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Tau_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Tau_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >"), typeid(::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >), sizeof(::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATMuTauFinalStateCollection>")
  .AddTypedef(type_1614, Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >::value_type"))
  .AddTypedef(type_1614, Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_54237, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4257), Reflex::Literal("Wrapper"), constructor_54238, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_54239, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85323), Reflex::Literal("Wrapper"), constructor_54244, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9222, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Tau_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Tau_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATPairFinalStateT<pat::Muon, pat::Tau>, std::allocator<PATPairFinalStateT<pat::Muon, pat::Tau> > > > -------------------
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Tau_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Tau_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1614, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Tau_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATPairFinalStateT<pat::Muon, pat::Tau>, std::allocator<PATPairFinalStateT<pat::Muon, pat::Tau> > > > -------------------
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Tau_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85322), Reflex::Literal("product"), method_54240, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85322), Reflex::Literal("operator->"), operator_54241, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_54242, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_54243, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85324), Reflex::Literal("getInterface"), method_54245, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_54246, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_54247, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_54248, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_54249, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_54250, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_54251, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATPairFinalStateT<pat::Muon, pat::Tau> > -------------------------------
static void constructor_54258( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Tau> >();
  else ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Tau> >();
}

static void constructor_54259( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Tau> >(*(::std::auto_ptr<PATPairFinalStateT<pat::Muon,pat::Tau> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Tau> >(*(::std::auto_ptr<PATPairFinalStateT<pat::Muon,pat::Tau> >*)arg[0]);
}

static void destructor_54260(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Tau> >::~Wrapper)();
}
static  void method_54261( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->product)();
}

static  void operator_54262( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->operator->)();
}

static  void method_54263( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->productTypeInfo)();
}

static  void method_54264( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->typeInfo)();
}

static void constructor_54265( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Tau> >((::PATPairFinalStateT<pat::Muon,pat::Tau>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Tau> >((::PATPairFinalStateT<pat::Muon,pat::Tau>*)arg[0]);
}

static  void method_54266( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->getInterface)();
}

static  void method_54267( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_54268( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_54269( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_54270( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->dynamicTypeInfo)();
}

static  void method_54271( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->isPresent)();
}

static  void method_54272( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Tau> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9223( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Tau> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Tau> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Tau> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Tau> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Tau> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATPairFinalStateT<pat::Muon, pat::Tau> > -------------------------------
void __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Tau_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Tau_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Tau_s__datamem_bld(&__edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Tau_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Tau_s__funcmem_bld(&__edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Tau_s__db_funcmem);
void __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Tau_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Tau> >"), typeid(::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Tau> >), sizeof(::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Tau> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATMuTauFinalState>")
  .AddTypedef(type_1885, Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Tau> >::value_type"))
  .AddTypedef(type_1885, Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Tau> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_54258, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4258), Reflex::Literal("Wrapper"), constructor_54259, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_54260, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_12944), Reflex::Literal("Wrapper"), constructor_54265, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9223, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Tau_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Tau_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATPairFinalStateT<pat::Muon, pat::Tau> > -------------------
void __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Tau_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Tau_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1885, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Tau_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATPairFinalStateT<pat::Muon, pat::Tau> > -------------------
void __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Tau_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12946), Reflex::Literal("product"), method_54261, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_12946), Reflex::Literal("operator->"), operator_54262, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_54263, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_54264, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85327), Reflex::Literal("getInterface"), method_54266, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_54267, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_54268, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_54269, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_54270, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_54271, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_54272, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATPairFinalStateT<pat::Muon, pat::Muon>, std::allocator<PATPairFinalStateT<pat::Muon, pat::Muon> > > > -------------------------------
static void constructor_54279( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >();
}

static void constructor_54280( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >(*(::std::auto_ptr<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >(*(::std::auto_ptr<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >*)arg[0]);
}

static void destructor_54281(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >*)o)->::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >::~Wrapper)();
}
static  void method_54282( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >*)o)->product)();
}

static  void operator_54283( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >*)o)->operator->)();
}

static  void method_54284( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >*)o)->productTypeInfo)();
}

static  void method_54285( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >*)o)->typeInfo)();
}

static void constructor_54286( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >((::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >((::std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> >*)arg[0]);
}

static  void method_54287( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >*)o)->getInterface)();
}

static  void method_54288( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_54289( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_54290( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_54291( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >*)o)->dynamicTypeInfo)();
}

static  void method_54292( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >*)o)->isPresent)();
}

static  void method_54293( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9224( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATPairFinalStateT<pat::Muon, pat::Muon>, std::allocator<PATPairFinalStateT<pat::Muon, pat::Muon> > > > -------------------------------
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Muon_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Muon_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Muon_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Muon_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Muon_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Muon_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Muon_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >"), typeid(::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >), sizeof(::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATMuMuFinalStateCollection>")
  .AddTypedef(type_922, Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >::value_type"))
  .AddTypedef(type_922, Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_54279, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4259), Reflex::Literal("Wrapper"), constructor_54280, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_54281, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85331), Reflex::Literal("Wrapper"), constructor_54286, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9224, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Muon_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Muon_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATPairFinalStateT<pat::Muon, pat::Muon>, std::allocator<PATPairFinalStateT<pat::Muon, pat::Muon> > > > -------------------
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Muon_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Muon_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_922, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Muon_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATPairFinalStateT<pat::Muon, pat::Muon>, std::allocator<PATPairFinalStateT<pat::Muon, pat::Muon> > > > -------------------
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Muon_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85330), Reflex::Literal("product"), method_54282, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85330), Reflex::Literal("operator->"), operator_54283, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_54284, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_54285, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85332), Reflex::Literal("getInterface"), method_54287, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_54288, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_54289, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_54290, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_54291, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_54292, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_54293, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATPairFinalStateT<pat::Muon, pat::Muon> > -------------------------------
static void constructor_54300( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Muon> >();
  else ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Muon> >();
}

static void constructor_54301( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Muon> >(*(::std::auto_ptr<PATPairFinalStateT<pat::Muon,pat::Muon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Muon> >(*(::std::auto_ptr<PATPairFinalStateT<pat::Muon,pat::Muon> >*)arg[0]);
}

static void destructor_54302(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Muon> >::~Wrapper)();
}
static  void method_54303( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->product)();
}

static  void operator_54304( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->operator->)();
}

static  void method_54305( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->productTypeInfo)();
}

static  void method_54306( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->typeInfo)();
}

static void constructor_54307( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Muon> >((::PATPairFinalStateT<pat::Muon,pat::Muon>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Muon> >((::PATPairFinalStateT<pat::Muon,pat::Muon>*)arg[0]);
}

static  void method_54308( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->getInterface)();
}

static  void method_54309( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_54310( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_54311( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_54312( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->dynamicTypeInfo)();
}

static  void method_54313( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->isPresent)();
}

static  void method_54314( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Muon> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9225( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Muon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Muon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Muon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Muon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Muon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATPairFinalStateT<pat::Muon, pat::Muon> > -------------------------------
void __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Muon_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Muon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Muon_s__datamem_bld(&__edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Muon_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Muon_s__funcmem_bld(&__edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Muon_s__db_funcmem);
void __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Muon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Muon> >"), typeid(::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Muon> >), sizeof(::edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Muon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATMuMuFinalState>")
  .AddTypedef(type_1200, Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Muon> >::value_type"))
  .AddTypedef(type_1200, Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Muon> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_54300, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4260), Reflex::Literal("Wrapper"), constructor_54301, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_54302, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10922), Reflex::Literal("Wrapper"), constructor_54307, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9225, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Muon_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Muon_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATPairFinalStateT<pat::Muon, pat::Muon> > -------------------
void __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Muon_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Muon_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1200, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Muon_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATPairFinalStateT<pat::Muon, pat::Muon> > -------------------
void __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Muon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10924), Reflex::Literal("product"), method_54303, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10924), Reflex::Literal("operator->"), operator_54304, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_54305, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_54306, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85335), Reflex::Literal("getInterface"), method_54308, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_54309, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_54310, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_54311, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_54312, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_54313, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_54314, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATPairFinalStateT<pat::Electron, pat::Photon>, std::allocator<PATPairFinalStateT<pat::Electron, pat::Photon> > > > -------------------------------
static void constructor_54321( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >();
}

static void constructor_54322( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >(*(::std::auto_ptr<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >(*(::std::auto_ptr<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >*)arg[0]);
}

static void destructor_54323(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >*)o)->::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >::~Wrapper)();
}
static  void method_54324( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >*)o)->product)();
}

static  void operator_54325( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >*)o)->operator->)();
}

static  void method_54326( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >*)o)->productTypeInfo)();
}

static  void method_54327( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >*)o)->typeInfo)();
}

static void constructor_54328( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >((::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >((::std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> >*)arg[0]);
}

static  void method_54329( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >*)o)->getInterface)();
}

static  void method_54330( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_54331( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_54332( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_54333( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >*)o)->dynamicTypeInfo)();
}

static  void method_54334( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >*)o)->isPresent)();
}

static  void method_54335( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9226( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATPairFinalStateT<pat::Electron, pat::Photon>, std::allocator<PATPairFinalStateT<pat::Electron, pat::Photon> > > > -------------------------------
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Photon_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Photon_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Photon_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Photon_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Photon_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Photon_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Photon_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >"), typeid(::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >), sizeof(::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecPhoFinalStateCollection>")
  .AddTypedef(type_2440, Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >::value_type"))
  .AddTypedef(type_2440, Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_54321, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4261), Reflex::Literal("Wrapper"), constructor_54322, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_54323, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85339), Reflex::Literal("Wrapper"), constructor_54328, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9226, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Photon_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Photon_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATPairFinalStateT<pat::Electron, pat::Photon>, std::allocator<PATPairFinalStateT<pat::Electron, pat::Photon> > > > -------------------
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Photon_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Photon_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2440, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Photon_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATPairFinalStateT<pat::Electron, pat::Photon>, std::allocator<PATPairFinalStateT<pat::Electron, pat::Photon> > > > -------------------
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Photon_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85338), Reflex::Literal("product"), method_54324, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85338), Reflex::Literal("operator->"), operator_54325, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_54326, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_54327, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85340), Reflex::Literal("getInterface"), method_54329, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_54330, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_54331, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_54332, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_54333, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_54334, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_54335, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATPairFinalStateT<pat::Electron, pat::Photon> > -------------------------------
static void constructor_54342( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Photon> >();
  else ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Photon> >();
}

static void constructor_54343( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Photon> >(*(::std::auto_ptr<PATPairFinalStateT<pat::Electron,pat::Photon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Photon> >(*(::std::auto_ptr<PATPairFinalStateT<pat::Electron,pat::Photon> >*)arg[0]);
}

static void destructor_54344(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Photon> >::~Wrapper)();
}
static  void method_54345( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->product)();
}

static  void operator_54346( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->operator->)();
}

static  void method_54347( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->productTypeInfo)();
}

static  void method_54348( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->typeInfo)();
}

static void constructor_54349( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Photon> >((::PATPairFinalStateT<pat::Electron,pat::Photon>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Photon> >((::PATPairFinalStateT<pat::Electron,pat::Photon>*)arg[0]);
}

static  void method_54350( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->getInterface)();
}

static  void method_54351( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_54352( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_54353( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_54354( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->dynamicTypeInfo)();
}

static  void method_54355( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->isPresent)();
}

static  void method_54356( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Photon> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9227( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Photon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Photon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Photon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Photon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Photon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATPairFinalStateT<pat::Electron, pat::Photon> > -------------------------------
void __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Photon_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Photon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Photon_s__datamem_bld(&__edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Photon_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Photon_s__funcmem_bld(&__edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Photon_s__db_funcmem);
void __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Photon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Photon> >"), typeid(::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Photon> >), sizeof(::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Photon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecPhoFinalState>")
  .AddTypedef(type_1886, Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Photon> >::value_type"))
  .AddTypedef(type_1886, Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Photon> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_54342, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4262), Reflex::Literal("Wrapper"), constructor_54343, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_54344, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_15465), Reflex::Literal("Wrapper"), constructor_54349, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9227, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Photon_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Photon_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATPairFinalStateT<pat::Electron, pat::Photon> > -------------------
void __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Photon_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Photon_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1886, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Photon_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATPairFinalStateT<pat::Electron, pat::Photon> > -------------------
void __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Photon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15467), Reflex::Literal("product"), method_54345, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_15467), Reflex::Literal("operator->"), operator_54346, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_54347, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_54348, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85343), Reflex::Literal("getInterface"), method_54350, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_54351, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_54352, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_54353, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_54354, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_54355, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_54356, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATPairFinalStateT<pat::Electron, pat::Tau>, std::allocator<PATPairFinalStateT<pat::Electron, pat::Tau> > > > -------------------------------
static void constructor_54363( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >();
}

static void constructor_54364( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >(*(::std::auto_ptr<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >(*(::std::auto_ptr<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >*)arg[0]);
}

static void destructor_54365(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >*)o)->::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >::~Wrapper)();
}
static  void method_54366( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >*)o)->product)();
}

static  void operator_54367( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >*)o)->operator->)();
}

static  void method_54368( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >*)o)->productTypeInfo)();
}

static  void method_54369( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >*)o)->typeInfo)();
}

static void constructor_54370( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >((::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >((::std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> >*)arg[0]);
}

static  void method_54371( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >*)o)->getInterface)();
}

static  void method_54372( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_54373( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_54374( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_54375( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >*)o)->dynamicTypeInfo)();
}

static  void method_54376( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >*)o)->isPresent)();
}

static  void method_54377( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9228( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATPairFinalStateT<pat::Electron, pat::Tau>, std::allocator<PATPairFinalStateT<pat::Electron, pat::Tau> > > > -------------------------------
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Tau_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Tau_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Tau_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Tau_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Tau_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Tau_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Tau_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >"), typeid(::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >), sizeof(::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecTauFinalStateCollection>")
  .AddTypedef(type_2858, Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >::value_type"))
  .AddTypedef(type_2858, Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_54363, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4263), Reflex::Literal("Wrapper"), constructor_54364, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_54365, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85347), Reflex::Literal("Wrapper"), constructor_54370, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9228, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Tau_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Tau_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATPairFinalStateT<pat::Electron, pat::Tau>, std::allocator<PATPairFinalStateT<pat::Electron, pat::Tau> > > > -------------------
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Tau_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Tau_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2858, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Tau_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATPairFinalStateT<pat::Electron, pat::Tau>, std::allocator<PATPairFinalStateT<pat::Electron, pat::Tau> > > > -------------------
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Tau_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85346), Reflex::Literal("product"), method_54366, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85346), Reflex::Literal("operator->"), operator_54367, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_54368, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_54369, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85348), Reflex::Literal("getInterface"), method_54371, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_54372, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_54373, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_54374, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_54375, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_54376, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_54377, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATPairFinalStateT<pat::Electron, pat::Tau> > -------------------------------
static void constructor_54384( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Tau> >();
  else ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Tau> >();
}

static void constructor_54385( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Tau> >(*(::std::auto_ptr<PATPairFinalStateT<pat::Electron,pat::Tau> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Tau> >(*(::std::auto_ptr<PATPairFinalStateT<pat::Electron,pat::Tau> >*)arg[0]);
}

static void destructor_54386(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Tau> >::~Wrapper)();
}
static  void method_54387( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->product)();
}

static  void operator_54388( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->operator->)();
}

static  void method_54389( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->productTypeInfo)();
}

static  void method_54390( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->typeInfo)();
}

static void constructor_54391( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Tau> >((::PATPairFinalStateT<pat::Electron,pat::Tau>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Tau> >((::PATPairFinalStateT<pat::Electron,pat::Tau>*)arg[0]);
}

static  void method_54392( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->getInterface)();
}

static  void method_54393( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_54394( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_54395( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_54396( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->dynamicTypeInfo)();
}

static  void method_54397( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->isPresent)();
}

static  void method_54398( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Tau> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9229( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Tau> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Tau> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Tau> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Tau> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Tau> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATPairFinalStateT<pat::Electron, pat::Tau> > -------------------------------
void __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Tau_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Tau_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Tau_s__datamem_bld(&__edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Tau_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Tau_s__funcmem_bld(&__edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Tau_s__db_funcmem);
void __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Tau_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Tau> >"), typeid(::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Tau> >), sizeof(::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Tau> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecTauFinalState>")
  .AddTypedef(type_1887, Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Tau> >::value_type"))
  .AddTypedef(type_1887, Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Tau> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_54384, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4264), Reflex::Literal("Wrapper"), constructor_54385, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_54386, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16840), Reflex::Literal("Wrapper"), constructor_54391, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9229, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Tau_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Tau_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATPairFinalStateT<pat::Electron, pat::Tau> > -------------------
void __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Tau_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Tau_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1887, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Tau_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATPairFinalStateT<pat::Electron, pat::Tau> > -------------------
void __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Tau_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16842), Reflex::Literal("product"), method_54387, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16842), Reflex::Literal("operator->"), operator_54388, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_54389, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_54390, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85351), Reflex::Literal("getInterface"), method_54392, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_54393, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_54394, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_54395, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_54396, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_54397, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_54398, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATPairFinalStateT<pat::Electron, pat::Muon>, std::allocator<PATPairFinalStateT<pat::Electron, pat::Muon> > > > -------------------------------
static void constructor_54405( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >();
}

static void constructor_54406( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >(*(::std::auto_ptr<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >(*(::std::auto_ptr<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >*)arg[0]);
}

static void destructor_54407(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >*)o)->::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >::~Wrapper)();
}
static  void method_54408( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >*)o)->product)();
}

static  void operator_54409( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >*)o)->operator->)();
}

static  void method_54410( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >*)o)->productTypeInfo)();
}

static  void method_54411( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >*)o)->typeInfo)();
}

static void constructor_54412( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >((::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >((::std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> >*)arg[0]);
}

static  void method_54413( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >*)o)->getInterface)();
}

static  void method_54414( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_54415( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_54416( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_54417( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >*)o)->dynamicTypeInfo)();
}

static  void method_54418( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >*)o)->isPresent)();
}

static  void method_54419( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9230( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATPairFinalStateT<pat::Electron, pat::Muon>, std::allocator<PATPairFinalStateT<pat::Electron, pat::Muon> > > > -------------------------------
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Muon_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Muon_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Muon_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Muon_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Muon_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Muon_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Muon_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >"), typeid(::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >), sizeof(::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecMuFinalStateCollection>")
  .AddTypedef(type_552, Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >::value_type"))
  .AddTypedef(type_552, Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_54405, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4265), Reflex::Literal("Wrapper"), constructor_54406, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_54407, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85355), Reflex::Literal("Wrapper"), constructor_54412, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9230, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Muon_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Muon_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATPairFinalStateT<pat::Electron, pat::Muon>, std::allocator<PATPairFinalStateT<pat::Electron, pat::Muon> > > > -------------------
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Muon_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Muon_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_552, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Muon_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATPairFinalStateT<pat::Electron, pat::Muon>, std::allocator<PATPairFinalStateT<pat::Electron, pat::Muon> > > > -------------------
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Muon_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85354), Reflex::Literal("product"), method_54408, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85354), Reflex::Literal("operator->"), operator_54409, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_54410, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_54411, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85356), Reflex::Literal("getInterface"), method_54413, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_54414, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_54415, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_54416, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_54417, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_54418, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_54419, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATPairFinalStateT<pat::Electron, pat::Muon> > -------------------------------
static void constructor_54426( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Muon> >();
  else ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Muon> >();
}

static void constructor_54427( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Muon> >(*(::std::auto_ptr<PATPairFinalStateT<pat::Electron,pat::Muon> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Muon> >(*(::std::auto_ptr<PATPairFinalStateT<pat::Electron,pat::Muon> >*)arg[0]);
}

static void destructor_54428(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Muon> >::~Wrapper)();
}
static  void method_54429( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->product)();
}

static  void operator_54430( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->operator->)();
}

static  void method_54431( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->productTypeInfo)();
}

static  void method_54432( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->typeInfo)();
}

static void constructor_54433( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Muon> >((::PATPairFinalStateT<pat::Electron,pat::Muon>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Muon> >((::PATPairFinalStateT<pat::Electron,pat::Muon>*)arg[0]);
}

static  void method_54434( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->getInterface)();
}

static  void method_54435( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_54436( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_54437( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_54438( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->dynamicTypeInfo)();
}

static  void method_54439( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->isPresent)();
}

static  void method_54440( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Muon> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9231( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Muon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Muon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Muon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Muon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Muon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATPairFinalStateT<pat::Electron, pat::Muon> > -------------------------------
void __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Muon_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Muon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Muon_s__datamem_bld(&__edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Muon_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Muon_s__funcmem_bld(&__edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Muon_s__db_funcmem);
void __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Muon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Muon> >"), typeid(::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Muon> >), sizeof(::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Muon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecMuFinalState>")
  .AddTypedef(type_1888, Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Muon> >::value_type"))
  .AddTypedef(type_1888, Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Muon> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_54426, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4266), Reflex::Literal("Wrapper"), constructor_54427, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_54428, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8492), Reflex::Literal("Wrapper"), constructor_54433, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9231, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Muon_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Muon_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATPairFinalStateT<pat::Electron, pat::Muon> > -------------------
void __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Muon_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Muon_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1888, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Muon_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATPairFinalStateT<pat::Electron, pat::Muon> > -------------------
void __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Muon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8494), Reflex::Literal("product"), method_54429, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8494), Reflex::Literal("operator->"), operator_54430, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_54431, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_54432, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85359), Reflex::Literal("getInterface"), method_54434, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_54435, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_54436, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_54437, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_54438, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_54439, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_54440, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATPairFinalStateT<pat::Electron, pat::Electron>, std::allocator<PATPairFinalStateT<pat::Electron, pat::Electron> > > > -------------------------------
static void constructor_54447( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >();
}

static void constructor_54448( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >(*(::std::auto_ptr<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >(*(::std::auto_ptr<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >*)arg[0]);
}

static void destructor_54449(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >*)o)->::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >::~Wrapper)();
}
static  void method_54450( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >*)o)->product)();
}

static  void operator_54451( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >*)o)->operator->)();
}

static  void method_54452( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >*)o)->productTypeInfo)();
}

static  void method_54453( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >*)o)->typeInfo)();
}

static void constructor_54454( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >((::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >((::std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> >*)arg[0]);
}

static  void method_54455( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >*)o)->getInterface)();
}

static  void method_54456( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_54457( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_54458( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_54459( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >*)o)->dynamicTypeInfo)();
}

static  void method_54460( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >*)o)->isPresent)();
}

static  void method_54461( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9232( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATPairFinalStateT<pat::Electron, pat::Electron>, std::allocator<PATPairFinalStateT<pat::Electron, pat::Electron> > > > -------------------------------
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Electron_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Electron_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Electron_s_s__datamem_bld(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Electron_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Electron_s_s__funcmem_bld(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Electron_s_s__db_funcmem);
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Electron_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >"), typeid(::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >), sizeof(::edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecElecFinalStateCollection>")
  .AddTypedef(type_1724, Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >::value_type"))
  .AddTypedef(type_1724, Reflex::Literal("edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_54447, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4267), Reflex::Literal("Wrapper"), constructor_54448, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_54449, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85363), Reflex::Literal("Wrapper"), constructor_54454, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9232, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Electron_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Electron_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATPairFinalStateT<pat::Electron, pat::Electron>, std::allocator<PATPairFinalStateT<pat::Electron, pat::Electron> > > > -------------------
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Electron_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Electron_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1724, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Electron_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATPairFinalStateT<pat::Electron, pat::Electron>, std::allocator<PATPairFinalStateT<pat::Electron, pat::Electron> > > > -------------------
void __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Electron_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85362), Reflex::Literal("product"), method_54450, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85362), Reflex::Literal("operator->"), operator_54451, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_54452, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_54453, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85364), Reflex::Literal("getInterface"), method_54455, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_54456, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_54457, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_54458, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_54459, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_54460, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_54461, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PATPairFinalStateT<pat::Electron, pat::Electron> > -------------------------------
static void constructor_54468( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Electron> >();
  else ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Electron> >();
}

static void constructor_54469( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Electron> >(*(::std::auto_ptr<PATPairFinalStateT<pat::Electron,pat::Electron> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Electron> >(*(::std::auto_ptr<PATPairFinalStateT<pat::Electron,pat::Electron> >*)arg[0]);
}

static void destructor_54470(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Electron> >::~Wrapper)();
}
static  void method_54471( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->product)());
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->product)();
}

static  void operator_54472( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->operator->)();
}

static  void method_54473( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->productTypeInfo)();
}

static  void method_54474( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->typeInfo)();
}

static void constructor_54475( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Electron> >((::PATPairFinalStateT<pat::Electron,pat::Electron>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Electron> >((::PATPairFinalStateT<pat::Electron,pat::Electron>*)arg[0]);
}

static  void method_54476( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->getInterface)());
  else   (((::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->getInterface)();
}

static  void method_54477( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_54478( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_54479( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_54480( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->dynamicTypeInfo)();
}

static  void method_54481( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->isPresent)();
}

static  void method_54482( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Electron> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9233( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Electron> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Electron> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Electron> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Electron> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Electron> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PATPairFinalStateT<pat::Electron, pat::Electron> > -------------------------------
void __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Electron_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Electron_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Electron_s__datamem_bld(&__edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Electron_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Electron_s__funcmem_bld(&__edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Electron_s__db_funcmem);
void __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Electron_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Electron> >"), typeid(::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Electron> >), sizeof(::edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Electron> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATElecElecFinalState>")
  .AddTypedef(type_1889, Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Electron> >::value_type"))
  .AddTypedef(type_1889, Reflex::Literal("edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Electron> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_54468, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4268), Reflex::Literal("Wrapper"), constructor_54469, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_54470, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13120), Reflex::Literal("Wrapper"), constructor_54475, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9233, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Electron_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Electron_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PATPairFinalStateT<pat::Electron, pat::Electron> > -------------------
void __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Electron_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Electron_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1889, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Electron_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PATPairFinalStateT<pat::Electron, pat::Electron> > -------------------
void __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Electron_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13122), Reflex::Literal("product"), method_54471, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13122), Reflex::Literal("operator->"), operator_54472, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_54473, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_54474, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85367), Reflex::Literal("getInterface"), method_54476, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_54477, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_54478, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_54479, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_54480, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_54481, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_54482, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATMultiCandFinalState, std::allocator<PATMultiCandFinalState> > > -------------------------------
static void constructor_54489( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATMultiCandFinalState> >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATMultiCandFinalState> >();
}

static void constructor_54490( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATMultiCandFinalState> >(*(::std::auto_ptr<std::vector<PATMultiCandFinalState> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATMultiCandFinalState> >(*(::std::auto_ptr<std::vector<PATMultiCandFinalState> >*)arg[0]);
}

static void destructor_54491(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATMultiCandFinalState> >*)o)->::edm::Wrapper<std::vector<PATMultiCandFinalState> >::~Wrapper)();
}
static  void method_54492( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATMultiCandFinalState> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATMultiCandFinalState> >*)o)->product)();
}

static  void operator_54493( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATMultiCandFinalState> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATMultiCandFinalState> >*)o)->operator->)();
}

static  void method_54494( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATMultiCandFinalState> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATMultiCandFinalState> >*)o)->productTypeInfo)();
}

static  void method_54495( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATMultiCandFinalState> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATMultiCandFinalState> >*)o)->typeInfo)();
}

static void constructor_54496( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATMultiCandFinalState> >((::std::vector<PATMultiCandFinalState>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATMultiCandFinalState> >((::std::vector<PATMultiCandFinalState>*)arg[0]);
}

static  void method_54497( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATMultiCandFinalState> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATMultiCandFinalState> >*)o)->getInterface)();
}

static  void method_54498( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATMultiCandFinalState> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_54499( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATMultiCandFinalState> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_54500( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATMultiCandFinalState> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_54501( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATMultiCandFinalState> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATMultiCandFinalState> >*)o)->dynamicTypeInfo)();
}

static  void method_54502( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATMultiCandFinalState> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATMultiCandFinalState> >*)o)->isPresent)();
}

static  void method_54503( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATMultiCandFinalState> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATMultiCandFinalState> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9234( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATMultiCandFinalState> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATMultiCandFinalState> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATMultiCandFinalState> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATMultiCandFinalState> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATMultiCandFinalState> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATMultiCandFinalState, std::allocator<PATMultiCandFinalState> > > -------------------------------
void __edm__Wrapper_std__vector_PATMultiCandFinalState_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATMultiCandFinalState_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATMultiCandFinalState_s__datamem_bld(&__edm__Wrapper_std__vector_PATMultiCandFinalState_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATMultiCandFinalState_s__funcmem_bld(&__edm__Wrapper_std__vector_PATMultiCandFinalState_s__db_funcmem);
void __edm__Wrapper_std__vector_PATMultiCandFinalState_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATMultiCandFinalState> >"), typeid(::edm::Wrapper<std::vector<PATMultiCandFinalState> >), sizeof(::edm::Wrapper<std::vector<PATMultiCandFinalState> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATMultiCandFinalStateCollection>")
  .AddTypedef(type_3002, Reflex::Literal("edm::Wrapper<std::vector<PATMultiCandFinalState> >::value_type"))
  .AddTypedef(type_3002, Reflex::Literal("edm::Wrapper<std::vector<PATMultiCandFinalState> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_54489, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4269), Reflex::Literal("Wrapper"), constructor_54490, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_54491, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85370), Reflex::Literal("Wrapper"), constructor_54496, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9234, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATMultiCandFinalState_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATMultiCandFinalState_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATMultiCandFinalState, std::allocator<PATMultiCandFinalState> > > -------------------
void __edm__Wrapper_std__vector_PATMultiCandFinalState_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATMultiCandFinalState_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3002, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATMultiCandFinalState_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATMultiCandFinalState, std::allocator<PATMultiCandFinalState> > > -------------------
void __edm__Wrapper_std__vector_PATMultiCandFinalState_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60413), Reflex::Literal("product"), method_54492, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60413), Reflex::Literal("operator->"), operator_54493, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_54494, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_54495, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85371), Reflex::Literal("getInterface"), method_54497, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_54498, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_54499, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_54500, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_54501, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_54502, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_54503, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATFinalStateLS, std::allocator<PATFinalStateLS> > > -------------------------------
static void constructor_54531( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATFinalStateLS> >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATFinalStateLS> >();
}

static void constructor_54532( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATFinalStateLS> >(*(::std::auto_ptr<std::vector<PATFinalStateLS> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATFinalStateLS> >(*(::std::auto_ptr<std::vector<PATFinalStateLS> >*)arg[0]);
}

static void destructor_54533(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATFinalStateLS> >*)o)->::edm::Wrapper<std::vector<PATFinalStateLS> >::~Wrapper)();
}
static  void method_54534( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATFinalStateLS> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATFinalStateLS> >*)o)->product)();
}

static  void operator_54535( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATFinalStateLS> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATFinalStateLS> >*)o)->operator->)();
}

static  void method_54536( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATFinalStateLS> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATFinalStateLS> >*)o)->productTypeInfo)();
}

static  void method_54537( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATFinalStateLS> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATFinalStateLS> >*)o)->typeInfo)();
}

static void constructor_54538( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATFinalStateLS> >((::std::vector<PATFinalStateLS>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATFinalStateLS> >((::std::vector<PATFinalStateLS>*)arg[0]);
}

static  void method_54539( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATFinalStateLS> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATFinalStateLS> >*)o)->getInterface)();
}

static  void method_54540( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATFinalStateLS> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_54541( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATFinalStateLS> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_54542( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATFinalStateLS> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_54543( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATFinalStateLS> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATFinalStateLS> >*)o)->dynamicTypeInfo)();
}

static  void method_54544( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATFinalStateLS> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATFinalStateLS> >*)o)->isPresent)();
}

static  void method_54545( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATFinalStateLS> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATFinalStateLS> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9236( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATFinalStateLS> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATFinalStateLS> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATFinalStateLS> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATFinalStateLS> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATFinalStateLS> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATFinalStateLS, std::allocator<PATFinalStateLS> > > -------------------------------
void __edm__Wrapper_std__vector_PATFinalStateLS_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATFinalStateLS_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATFinalStateLS_s__datamem_bld(&__edm__Wrapper_std__vector_PATFinalStateLS_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATFinalStateLS_s__funcmem_bld(&__edm__Wrapper_std__vector_PATFinalStateLS_s__db_funcmem);
void __edm__Wrapper_std__vector_PATFinalStateLS_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATFinalStateLS> >"), typeid(::edm::Wrapper<std::vector<PATFinalStateLS> >), sizeof(::edm::Wrapper<std::vector<PATFinalStateLS> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATFinalStateLSCollection>")
  .AddTypedef(type_2244, Reflex::Literal("edm::Wrapper<std::vector<PATFinalStateLS> >::value_type"))
  .AddTypedef(type_2244, Reflex::Literal("edm::Wrapper<std::vector<PATFinalStateLS> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_54531, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4271), Reflex::Literal("Wrapper"), constructor_54532, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_54533, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85377), Reflex::Literal("Wrapper"), constructor_54538, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9236, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATFinalStateLS_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATFinalStateLS_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATFinalStateLS, std::allocator<PATFinalStateLS> > > -------------------
void __edm__Wrapper_std__vector_PATFinalStateLS_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATFinalStateLS_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2244, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATFinalStateLS_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATFinalStateLS, std::allocator<PATFinalStateLS> > > -------------------
void __edm__Wrapper_std__vector_PATFinalStateLS_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45951), Reflex::Literal("product"), method_54534, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45951), Reflex::Literal("operator->"), operator_54535, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_54536, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_54537, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85378), Reflex::Literal("getInterface"), method_54539, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_54540, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_54541, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_54542, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_54543, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_54544, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_54545, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<PATFinalStateEvent, std::allocator<PATFinalStateEvent> > > -------------------------------
static void constructor_54573( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATFinalStateEvent> >();
  else ::new(mem) ::edm::Wrapper<std::vector<PATFinalStateEvent> >();
}

static void constructor_54574( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATFinalStateEvent> >(*(::std::auto_ptr<std::vector<PATFinalStateEvent> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATFinalStateEvent> >(*(::std::auto_ptr<std::vector<PATFinalStateEvent> >*)arg[0]);
}

static void destructor_54575(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<PATFinalStateEvent> >*)o)->::edm::Wrapper<std::vector<PATFinalStateEvent> >::~Wrapper)();
}
static  void method_54576( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATFinalStateEvent> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<PATFinalStateEvent> >*)o)->product)();
}

static  void operator_54577( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<PATFinalStateEvent> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<PATFinalStateEvent> >*)o)->operator->)();
}

static  void method_54578( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATFinalStateEvent> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<PATFinalStateEvent> >*)o)->productTypeInfo)();
}

static  void method_54579( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<PATFinalStateEvent> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<PATFinalStateEvent> >*)o)->typeInfo)();
}

static void constructor_54580( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<PATFinalStateEvent> >((::std::vector<PATFinalStateEvent>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<PATFinalStateEvent> >((::std::vector<PATFinalStateEvent>*)arg[0]);
}

static  void method_54581( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<PATFinalStateEvent> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<PATFinalStateEvent> >*)o)->getInterface)();
}

static  void method_54582( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATFinalStateEvent> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_54583( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATFinalStateEvent> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_54584( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<PATFinalStateEvent> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_54585( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATFinalStateEvent> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<PATFinalStateEvent> >*)o)->dynamicTypeInfo)();
}

static  void method_54586( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<PATFinalStateEvent> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<PATFinalStateEvent> >*)o)->isPresent)();
}

static  void method_54587( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<PATFinalStateEvent> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<PATFinalStateEvent> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9238( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATFinalStateEvent> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATFinalStateEvent> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATFinalStateEvent> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATFinalStateEvent> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<PATFinalStateEvent> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<PATFinalStateEvent, std::allocator<PATFinalStateEvent> > > -------------------------------
void __edm__Wrapper_std__vector_PATFinalStateEvent_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_PATFinalStateEvent_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATFinalStateEvent_s__datamem_bld(&__edm__Wrapper_std__vector_PATFinalStateEvent_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_PATFinalStateEvent_s__funcmem_bld(&__edm__Wrapper_std__vector_PATFinalStateEvent_s__db_funcmem);
void __edm__Wrapper_std__vector_PATFinalStateEvent_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<PATFinalStateEvent> >"), typeid(::edm::Wrapper<std::vector<PATFinalStateEvent> >), sizeof(::edm::Wrapper<std::vector<PATFinalStateEvent> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATFinalStateEventCollection>")
  .AddTypedef(type_480, Reflex::Literal("edm::Wrapper<std::vector<PATFinalStateEvent> >::value_type"))
  .AddTypedef(type_480, Reflex::Literal("edm::Wrapper<std::vector<PATFinalStateEvent> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_54573, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4273), Reflex::Literal("Wrapper"), constructor_54574, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_54575, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85384), Reflex::Literal("Wrapper"), constructor_54580, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9238, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_PATFinalStateEvent_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_PATFinalStateEvent_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<PATFinalStateEvent, std::allocator<PATFinalStateEvent> > > -------------------
void __edm__Wrapper_std__vector_PATFinalStateEvent_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATFinalStateEvent_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_480, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_PATFinalStateEvent_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<PATFinalStateEvent, std::allocator<PATFinalStateEvent> > > -------------------
void __edm__Wrapper_std__vector_PATFinalStateEvent_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45415), Reflex::Literal("product"), method_54576, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45415), Reflex::Literal("operator->"), operator_54577, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_54578, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_54579, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85385), Reflex::Literal("getInterface"), method_54581, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_54582, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_54583, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_54584, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_54585, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_54586, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_54587, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<edm::OwnVector<PATFinalState, edm::ClonePolicy<PATFinalState> > > -------------------------------
static void constructor_54615( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >();
  else ::new(mem) ::edm::Wrapper<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >();
}

static void constructor_54616( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >(*(::std::auto_ptr<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >(*(::std::auto_ptr<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)arg[0]);
}

static void destructor_54617(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->::edm::Wrapper<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >::~Wrapper)();
}
static  void method_54618( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->product)();
}

static  void operator_54619( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->operator->)();
}

static  void method_54620( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->productTypeInfo)();
}

static  void method_54621( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->typeInfo)();
}

static void constructor_54622( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >((::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >((::edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >*)arg[0]);
}

static  void method_54623( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->getInterface)();
}

static  void method_54624( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_54625( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_54626( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_54627( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->dynamicTypeInfo)();
}

static  void method_54628( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->isPresent)();
}

static  void method_54629( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_9240( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::OwnVector<PATFinalState, edm::ClonePolicy<PATFinalState> > > -------------------------------
void __edm__Wrapper_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s_s__datamem_bld(&__edm__Wrapper_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s_s__funcmem_bld(&__edm__Wrapper_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s_s__db_funcmem);
void __edm__Wrapper_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >"), typeid(::edm::Wrapper<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >), sizeof(::edm::Wrapper<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<PATFinalStateCollection>")
  .AddTypedef(type_951, Reflex::Literal("edm::Wrapper<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >::value_type"))
  .AddTypedef(type_951, Reflex::Literal("edm::Wrapper<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_54615, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4275), Reflex::Literal("Wrapper"), constructor_54616, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_54617, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85391), Reflex::Literal("Wrapper"), constructor_54622, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9240, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::OwnVector<PATFinalState, edm::ClonePolicy<PATFinalState> > > -------------------
void __edm__Wrapper_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2301, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_951, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::OwnVector<PATFinalState, edm::ClonePolicy<PATFinalState> > > -------------------
void __edm__Wrapper_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45906), Reflex::Literal("product"), method_54618, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45906), Reflex::Literal("operator->"), operator_54619, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("productTypeInfo"), method_54620, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("typeInfo"), method_54621, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85392), Reflex::Literal("getInterface"), method_54623, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_45417, type_45461, type_77636), Reflex::Literal("fillView"), method_54624, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_484, type_24201), Reflex::Literal("setPtr"), method_54625, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_8743, type_59093, type_45461), Reflex::Literal("fillPtrVector"), method_54626, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo"), method_54627, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isPresent"), method_54628, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8743), Reflex::Literal("dynamicTypeInfo_"), method_54629, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class RefProd<std::vector<pat::Photon, std::allocator<pat::Photon> > > -------------------------------
static  void operator_55643( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefProd<std::vector<pat::Photon> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<pat::Photon> >*)arg[0]);
  else   (((::edm::RefProd<std::vector<pat::Photon> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<pat::Photon> >*)arg[0]);
}

static void constructor_55644( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::Photon> >(*(const ::edm::RefProd<std::vector<pat::Photon> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::Photon> >(*(const ::edm::RefProd<std::vector<pat::Photon> >*)arg[0]);
}

static void constructor_55645( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::Photon> >();
  else ::new(mem) ::edm::RefProd<std::vector<pat::Photon> >();
}

static void constructor_55646( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::Photon> >(*(const ::edm::Handle<std::vector<pat::Photon> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::Photon> >(*(const ::edm::Handle<std::vector<pat::Photon> >*)arg[0]);
}

static void constructor_55647( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::Photon> >(*(const ::edm::OrphanHandle<std::vector<pat::Photon> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::Photon> >(*(const ::edm::OrphanHandle<std::vector<pat::Photon> >*)arg[0]);
}

static void constructor_55648( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::Photon> >((const ::std::vector<pat::Photon>*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::Photon> >((const ::std::vector<pat::Photon>*)arg[0]);
}

static void constructor_55649( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::Photon> >(*(const ::edm::TestHandle<std::vector<pat::Photon> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::Photon> >(*(const ::edm::TestHandle<std::vector<pat::Photon> >*)arg[0]);
}

static void constructor_55650( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::Photon> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::Photon> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
}

static void destructor_55651(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefProd<std::vector<pat::Photon> >*)o)->::edm::RefProd<std::vector<pat::Photon> >::~RefProd)();
}
static  void operator_55652( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<pat::Photon> >*)o)->operator*)();
  else   (((const ::edm::RefProd<std::vector<pat::Photon> >*)o)->operator*)();
}

static  void operator_55653( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::Photon> >*)o)->operator->)());
  else   (((const ::edm::RefProd<std::vector<pat::Photon> >*)o)->operator->)();
}

static  void method_55654( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::Photon> >*)o)->get)());
  else   (((const ::edm::RefProd<std::vector<pat::Photon> >*)o)->get)();
}

static  void method_55655( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::Photon> >*)o)->product)());
  else   (((const ::edm::RefProd<std::vector<pat::Photon> >*)o)->product)();
}

static  void method_55656( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<pat::Photon> >*)o)->refCore)();
  else   (((const ::edm::RefProd<std::vector<pat::Photon> >*)o)->refCore)();
}

static  void method_55657( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::Photon> >*)o)->isNull)());
  else   (((const ::edm::RefProd<std::vector<pat::Photon> >*)o)->isNull)();
}

static  void method_55658( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::Photon> >*)o)->isNonnull)());
  else   (((const ::edm::RefProd<std::vector<pat::Photon> >*)o)->isNonnull)();
}

static  void operator_55659( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::Photon> >*)o)->operator!)());
  else   (((const ::edm::RefProd<std::vector<pat::Photon> >*)o)->operator!)();
}

static  void method_55660( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefProd<std::vector<pat::Photon> >*)o)->id)());
  else   (((const ::edm::RefProd<std::vector<pat::Photon> >*)o)->id)();
}

static  void method_55661( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::Photon> >*)o)->productGetter)());
  else   (((const ::edm::RefProd<std::vector<pat::Photon> >*)o)->productGetter)();
}

static  void method_55662( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::Photon> >*)o)->hasCache)());
  else   (((const ::edm::RefProd<std::vector<pat::Photon> >*)o)->hasCache)();
}

static  void method_55663( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::Photon> >*)o)->hasProductCache)());
  else   (((const ::edm::RefProd<std::vector<pat::Photon> >*)o)->hasProductCache)();
}

static  void method_55664( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::Photon> >*)o)->isAvailable)());
  else   (((const ::edm::RefProd<std::vector<pat::Photon> >*)o)->isAvailable)();
}

static  void method_55665( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::Photon> >*)o)->isTransient)());
  else   (((const ::edm::RefProd<std::vector<pat::Photon> >*)o)->isTransient)();
}

static  void method_55666( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefProd<std::vector<pat::Photon> >*)o)->swap)(*(::edm::RefProd<std::vector<pat::Photon> >*)arg[0]);
}

static  void method_55667( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefProd<std::vector<pat::Photon> >*)o)->Class_Version)());
  else   (((::edm::RefProd<std::vector<pat::Photon> >*)o)->Class_Version)();
}

static void method_newdel_9696( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::Photon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::Photon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::Photon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::Photon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::Photon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefProd<std::vector<pat::Photon, std::allocator<pat::Photon> > > -------------------------------
void __edm__RefProd_std__vector_pat__Photon_s__db_datamem(Reflex::Class*);
void __edm__RefProd_std__vector_pat__Photon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_pat__Photon_s__datamem_bld(&__edm__RefProd_std__vector_pat__Photon_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_pat__Photon_s__funcmem_bld(&__edm__RefProd_std__vector_pat__Photon_s__db_funcmem);
void __edm__RefProd_std__vector_pat__Photon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefProd<std::vector<pat::Photon> >"), typeid(::edm::RefProd<std::vector<pat::Photon> >), sizeof(::edm::RefProd<std::vector<pat::Photon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefProd<std::vector<pat::Photon> >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::RefProd<pat::PhotonCollection>")
  .AddTypedef(type_4617, Reflex::Literal("edm::RefProd<std::vector<pat::Photon> >::product_type"))
  .AddTypedef(type_4617, Reflex::Literal("edm::RefProd<std::vector<pat::Photon> >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85660, type_50692), Reflex::Literal("operator="), operator_55643, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_50692), Reflex::Literal("RefProd"), constructor_55644, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefProd"), constructor_55645, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85661), Reflex::Literal("RefProd"), constructor_55646, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85564), Reflex::Literal("RefProd"), constructor_55647, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85490), Reflex::Literal("RefProd"), constructor_55648, 0, "iProduct", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85489), Reflex::Literal("RefProd"), constructor_55649, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417, type_45418), Reflex::Literal("RefProd"), constructor_55650, 0, "productID;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefProd"), destructor_55651, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9696, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefProd_std__vector_pat__Photon_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefProd_std__vector_pat__Photon_s__funcmem_bld);
}

//------Delayed data member builder for class RefProd<std::vector<pat::Photon, std::allocator<pat::Photon> > > -------------------
void __edm__RefProd_std__vector_pat__Photon_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9667, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefProd_std__vector_pat__Photon_s_, product_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefProd<std::vector<pat::Photon, std::allocator<pat::Photon> > > -------------------
void __edm__RefProd_std__vector_pat__Photon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75847), Reflex::Literal("operator*"), operator_55652, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85490), Reflex::Literal("operator->"), operator_55653, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85490), Reflex::Literal("get"), method_55654, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85490), Reflex::Literal("product"), method_55655, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45420), Reflex::Literal("refCore"), method_55656, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNull"), method_55657, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNonnull"), method_55658, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("operator!"), operator_55659, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9664), Reflex::Literal("id"), method_55660, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45418), Reflex::Literal("productGetter"), method_55661, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("hasCache"), method_55662, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("hasProductCache"), method_55663, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isAvailable"), method_55664, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isTransient"), method_55665, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_85660), Reflex::Literal("swap"), method_55666, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_251), Reflex::Literal("Class_Version"), method_55667, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefProd<std::vector<pat::Jet, std::allocator<pat::Jet> > > -------------------------------
static  void operator_55672( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefProd<std::vector<pat::Jet> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<pat::Jet> >*)arg[0]);
  else   (((::edm::RefProd<std::vector<pat::Jet> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<pat::Jet> >*)arg[0]);
}

static void constructor_55673( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::Jet> >(*(const ::edm::RefProd<std::vector<pat::Jet> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::Jet> >(*(const ::edm::RefProd<std::vector<pat::Jet> >*)arg[0]);
}

static void constructor_55674( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::Jet> >();
  else ::new(mem) ::edm::RefProd<std::vector<pat::Jet> >();
}

static void constructor_55675( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::Jet> >(*(const ::edm::Handle<std::vector<pat::Jet> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::Jet> >(*(const ::edm::Handle<std::vector<pat::Jet> >*)arg[0]);
}

static void constructor_55676( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::Jet> >(*(const ::edm::OrphanHandle<std::vector<pat::Jet> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::Jet> >(*(const ::edm::OrphanHandle<std::vector<pat::Jet> >*)arg[0]);
}

static void constructor_55677( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::Jet> >((const ::std::vector<pat::Jet>*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::Jet> >((const ::std::vector<pat::Jet>*)arg[0]);
}

static void constructor_55678( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::Jet> >(*(const ::edm::TestHandle<std::vector<pat::Jet> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::Jet> >(*(const ::edm::TestHandle<std::vector<pat::Jet> >*)arg[0]);
}

static void constructor_55679( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::Jet> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::Jet> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
}

static void destructor_55680(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefProd<std::vector<pat::Jet> >*)o)->::edm::RefProd<std::vector<pat::Jet> >::~RefProd)();
}
static  void operator_55681( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<pat::Jet> >*)o)->operator*)();
  else   (((const ::edm::RefProd<std::vector<pat::Jet> >*)o)->operator*)();
}

static  void operator_55682( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::Jet> >*)o)->operator->)());
  else   (((const ::edm::RefProd<std::vector<pat::Jet> >*)o)->operator->)();
}

static  void method_55683( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::Jet> >*)o)->get)());
  else   (((const ::edm::RefProd<std::vector<pat::Jet> >*)o)->get)();
}

static  void method_55684( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::Jet> >*)o)->product)());
  else   (((const ::edm::RefProd<std::vector<pat::Jet> >*)o)->product)();
}

static  void method_55685( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<pat::Jet> >*)o)->refCore)();
  else   (((const ::edm::RefProd<std::vector<pat::Jet> >*)o)->refCore)();
}

static  void method_55686( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::Jet> >*)o)->isNull)());
  else   (((const ::edm::RefProd<std::vector<pat::Jet> >*)o)->isNull)();
}

static  void method_55687( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::Jet> >*)o)->isNonnull)());
  else   (((const ::edm::RefProd<std::vector<pat::Jet> >*)o)->isNonnull)();
}

static  void operator_55688( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::Jet> >*)o)->operator!)());
  else   (((const ::edm::RefProd<std::vector<pat::Jet> >*)o)->operator!)();
}

static  void method_55689( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefProd<std::vector<pat::Jet> >*)o)->id)());
  else   (((const ::edm::RefProd<std::vector<pat::Jet> >*)o)->id)();
}

static  void method_55690( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::Jet> >*)o)->productGetter)());
  else   (((const ::edm::RefProd<std::vector<pat::Jet> >*)o)->productGetter)();
}

static  void method_55691( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::Jet> >*)o)->hasCache)());
  else   (((const ::edm::RefProd<std::vector<pat::Jet> >*)o)->hasCache)();
}

static  void method_55692( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::Jet> >*)o)->hasProductCache)());
  else   (((const ::edm::RefProd<std::vector<pat::Jet> >*)o)->hasProductCache)();
}

static  void method_55693( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::Jet> >*)o)->isAvailable)());
  else   (((const ::edm::RefProd<std::vector<pat::Jet> >*)o)->isAvailable)();
}

static  void method_55694( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::Jet> >*)o)->isTransient)());
  else   (((const ::edm::RefProd<std::vector<pat::Jet> >*)o)->isTransient)();
}

static  void method_55695( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefProd<std::vector<pat::Jet> >*)o)->swap)(*(::edm::RefProd<std::vector<pat::Jet> >*)arg[0]);
}

static  void method_55696( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefProd<std::vector<pat::Jet> >*)o)->Class_Version)());
  else   (((::edm::RefProd<std::vector<pat::Jet> >*)o)->Class_Version)();
}

static void method_newdel_9697( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::Jet> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::Jet> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::Jet> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::Jet> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::Jet> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefProd<std::vector<pat::Jet, std::allocator<pat::Jet> > > -------------------------------
void __edm__RefProd_std__vector_pat__Jet_s__db_datamem(Reflex::Class*);
void __edm__RefProd_std__vector_pat__Jet_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_pat__Jet_s__datamem_bld(&__edm__RefProd_std__vector_pat__Jet_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_pat__Jet_s__funcmem_bld(&__edm__RefProd_std__vector_pat__Jet_s__db_funcmem);
void __edm__RefProd_std__vector_pat__Jet_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefProd<std::vector<pat::Jet> >"), typeid(::edm::RefProd<std::vector<pat::Jet> >), sizeof(::edm::RefProd<std::vector<pat::Jet> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefProd<std::vector<pat::Jet> >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::RefProd<pat::JetCollection>")
  .AddTypedef(type_4641, Reflex::Literal("edm::RefProd<std::vector<pat::Jet> >::product_type"))
  .AddTypedef(type_4641, Reflex::Literal("edm::RefProd<std::vector<pat::Jet> >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85662, type_50691), Reflex::Literal("operator="), operator_55672, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_50691), Reflex::Literal("RefProd"), constructor_55673, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefProd"), constructor_55674, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85663), Reflex::Literal("RefProd"), constructor_55675, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85566), Reflex::Literal("RefProd"), constructor_55676, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85493), Reflex::Literal("RefProd"), constructor_55677, 0, "iProduct", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85492), Reflex::Literal("RefProd"), constructor_55678, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417, type_45418), Reflex::Literal("RefProd"), constructor_55679, 0, "productID;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefProd"), destructor_55680, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9697, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefProd_std__vector_pat__Jet_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefProd_std__vector_pat__Jet_s__funcmem_bld);
}

//------Delayed data member builder for class RefProd<std::vector<pat::Jet, std::allocator<pat::Jet> > > -------------------
void __edm__RefProd_std__vector_pat__Jet_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9667, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefProd_std__vector_pat__Jet_s_, product_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefProd<std::vector<pat::Jet, std::allocator<pat::Jet> > > -------------------
void __edm__RefProd_std__vector_pat__Jet_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75910), Reflex::Literal("operator*"), operator_55681, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85493), Reflex::Literal("operator->"), operator_55682, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85493), Reflex::Literal("get"), method_55683, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85493), Reflex::Literal("product"), method_55684, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45420), Reflex::Literal("refCore"), method_55685, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNull"), method_55686, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNonnull"), method_55687, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("operator!"), operator_55688, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9664), Reflex::Literal("id"), method_55689, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45418), Reflex::Literal("productGetter"), method_55690, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("hasCache"), method_55691, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("hasProductCache"), method_55692, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isAvailable"), method_55693, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isTransient"), method_55694, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_85662), Reflex::Literal("swap"), method_55695, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_251), Reflex::Literal("Class_Version"), method_55696, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefProd<std::vector<pat::Tau, std::allocator<pat::Tau> > > -------------------------------
static  void operator_55701( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefProd<std::vector<pat::Tau> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<pat::Tau> >*)arg[0]);
  else   (((::edm::RefProd<std::vector<pat::Tau> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<pat::Tau> >*)arg[0]);
}

static void constructor_55702( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::Tau> >(*(const ::edm::RefProd<std::vector<pat::Tau> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::Tau> >(*(const ::edm::RefProd<std::vector<pat::Tau> >*)arg[0]);
}

static void constructor_55703( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::Tau> >();
  else ::new(mem) ::edm::RefProd<std::vector<pat::Tau> >();
}

static void constructor_55704( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::Tau> >(*(const ::edm::Handle<std::vector<pat::Tau> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::Tau> >(*(const ::edm::Handle<std::vector<pat::Tau> >*)arg[0]);
}

static void constructor_55705( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::Tau> >(*(const ::edm::OrphanHandle<std::vector<pat::Tau> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::Tau> >(*(const ::edm::OrphanHandle<std::vector<pat::Tau> >*)arg[0]);
}

static void constructor_55706( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::Tau> >((const ::std::vector<pat::Tau>*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::Tau> >((const ::std::vector<pat::Tau>*)arg[0]);
}

static void constructor_55707( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::Tau> >(*(const ::edm::TestHandle<std::vector<pat::Tau> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::Tau> >(*(const ::edm::TestHandle<std::vector<pat::Tau> >*)arg[0]);
}

static void constructor_55708( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::Tau> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::Tau> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
}

static void destructor_55709(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefProd<std::vector<pat::Tau> >*)o)->::edm::RefProd<std::vector<pat::Tau> >::~RefProd)();
}
static  void operator_55710( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<pat::Tau> >*)o)->operator*)();
  else   (((const ::edm::RefProd<std::vector<pat::Tau> >*)o)->operator*)();
}

static  void operator_55711( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::Tau> >*)o)->operator->)());
  else   (((const ::edm::RefProd<std::vector<pat::Tau> >*)o)->operator->)();
}

static  void method_55712( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::Tau> >*)o)->get)());
  else   (((const ::edm::RefProd<std::vector<pat::Tau> >*)o)->get)();
}

static  void method_55713( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::Tau> >*)o)->product)());
  else   (((const ::edm::RefProd<std::vector<pat::Tau> >*)o)->product)();
}

static  void method_55714( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<pat::Tau> >*)o)->refCore)();
  else   (((const ::edm::RefProd<std::vector<pat::Tau> >*)o)->refCore)();
}

static  void method_55715( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::Tau> >*)o)->isNull)());
  else   (((const ::edm::RefProd<std::vector<pat::Tau> >*)o)->isNull)();
}

static  void method_55716( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::Tau> >*)o)->isNonnull)());
  else   (((const ::edm::RefProd<std::vector<pat::Tau> >*)o)->isNonnull)();
}

static  void operator_55717( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::Tau> >*)o)->operator!)());
  else   (((const ::edm::RefProd<std::vector<pat::Tau> >*)o)->operator!)();
}

static  void method_55718( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefProd<std::vector<pat::Tau> >*)o)->id)());
  else   (((const ::edm::RefProd<std::vector<pat::Tau> >*)o)->id)();
}

static  void method_55719( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::Tau> >*)o)->productGetter)());
  else   (((const ::edm::RefProd<std::vector<pat::Tau> >*)o)->productGetter)();
}

static  void method_55720( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::Tau> >*)o)->hasCache)());
  else   (((const ::edm::RefProd<std::vector<pat::Tau> >*)o)->hasCache)();
}

static  void method_55721( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::Tau> >*)o)->hasProductCache)());
  else   (((const ::edm::RefProd<std::vector<pat::Tau> >*)o)->hasProductCache)();
}

static  void method_55722( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::Tau> >*)o)->isAvailable)());
  else   (((const ::edm::RefProd<std::vector<pat::Tau> >*)o)->isAvailable)();
}

static  void method_55723( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::Tau> >*)o)->isTransient)());
  else   (((const ::edm::RefProd<std::vector<pat::Tau> >*)o)->isTransient)();
}

static  void method_55724( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefProd<std::vector<pat::Tau> >*)o)->swap)(*(::edm::RefProd<std::vector<pat::Tau> >*)arg[0]);
}

static  void method_55725( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefProd<std::vector<pat::Tau> >*)o)->Class_Version)());
  else   (((::edm::RefProd<std::vector<pat::Tau> >*)o)->Class_Version)();
}

static void method_newdel_9698( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::Tau> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::Tau> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::Tau> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::Tau> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::Tau> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefProd<std::vector<pat::Tau, std::allocator<pat::Tau> > > -------------------------------
void __edm__RefProd_std__vector_pat__Tau_s__db_datamem(Reflex::Class*);
void __edm__RefProd_std__vector_pat__Tau_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_pat__Tau_s__datamem_bld(&__edm__RefProd_std__vector_pat__Tau_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_pat__Tau_s__funcmem_bld(&__edm__RefProd_std__vector_pat__Tau_s__db_funcmem);
void __edm__RefProd_std__vector_pat__Tau_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefProd<std::vector<pat::Tau> >"), typeid(::edm::RefProd<std::vector<pat::Tau> >), sizeof(::edm::RefProd<std::vector<pat::Tau> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefProd<std::vector<pat::Tau> >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::RefProd<pat::TauCollection>")
  .AddTypedef(type_4671, Reflex::Literal("edm::RefProd<std::vector<pat::Tau> >::product_type"))
  .AddTypedef(type_4671, Reflex::Literal("edm::RefProd<std::vector<pat::Tau> >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85664, type_50690), Reflex::Literal("operator="), operator_55701, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_50690), Reflex::Literal("RefProd"), constructor_55702, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefProd"), constructor_55703, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85665), Reflex::Literal("RefProd"), constructor_55704, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85568), Reflex::Literal("RefProd"), constructor_55705, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85496), Reflex::Literal("RefProd"), constructor_55706, 0, "iProduct", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85495), Reflex::Literal("RefProd"), constructor_55707, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417, type_45418), Reflex::Literal("RefProd"), constructor_55708, 0, "productID;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefProd"), destructor_55709, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9698, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefProd_std__vector_pat__Tau_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefProd_std__vector_pat__Tau_s__funcmem_bld);
}

//------Delayed data member builder for class RefProd<std::vector<pat::Tau, std::allocator<pat::Tau> > > -------------------
void __edm__RefProd_std__vector_pat__Tau_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9667, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefProd_std__vector_pat__Tau_s_, product_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefProd<std::vector<pat::Tau, std::allocator<pat::Tau> > > -------------------
void __edm__RefProd_std__vector_pat__Tau_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_76063), Reflex::Literal("operator*"), operator_55710, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85496), Reflex::Literal("operator->"), operator_55711, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85496), Reflex::Literal("get"), method_55712, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85496), Reflex::Literal("product"), method_55713, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45420), Reflex::Literal("refCore"), method_55714, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNull"), method_55715, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNonnull"), method_55716, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("operator!"), operator_55717, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9664), Reflex::Literal("id"), method_55718, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45418), Reflex::Literal("productGetter"), method_55719, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("hasCache"), method_55720, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("hasProductCache"), method_55721, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isAvailable"), method_55722, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isTransient"), method_55723, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_85664), Reflex::Literal("swap"), method_55724, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_251), Reflex::Literal("Class_Version"), method_55725, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefProd<std::vector<pat::Muon, std::allocator<pat::Muon> > > -------------------------------
static  void operator_55730( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefProd<std::vector<pat::Muon> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<pat::Muon> >*)arg[0]);
  else   (((::edm::RefProd<std::vector<pat::Muon> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<pat::Muon> >*)arg[0]);
}

static void constructor_55731( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::Muon> >(*(const ::edm::RefProd<std::vector<pat::Muon> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::Muon> >(*(const ::edm::RefProd<std::vector<pat::Muon> >*)arg[0]);
}

static void constructor_55732( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::Muon> >();
  else ::new(mem) ::edm::RefProd<std::vector<pat::Muon> >();
}

static void constructor_55733( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::Muon> >(*(const ::edm::Handle<std::vector<pat::Muon> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::Muon> >(*(const ::edm::Handle<std::vector<pat::Muon> >*)arg[0]);
}

static void constructor_55734( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::Muon> >(*(const ::edm::OrphanHandle<std::vector<pat::Muon> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::Muon> >(*(const ::edm::OrphanHandle<std::vector<pat::Muon> >*)arg[0]);
}

static void constructor_55735( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::Muon> >((const ::std::vector<pat::Muon>*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::Muon> >((const ::std::vector<pat::Muon>*)arg[0]);
}

static void constructor_55736( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::Muon> >(*(const ::edm::TestHandle<std::vector<pat::Muon> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::Muon> >(*(const ::edm::TestHandle<std::vector<pat::Muon> >*)arg[0]);
}

static void constructor_55737( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::Muon> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::Muon> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
}

static void destructor_55738(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefProd<std::vector<pat::Muon> >*)o)->::edm::RefProd<std::vector<pat::Muon> >::~RefProd)();
}
static  void operator_55739( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<pat::Muon> >*)o)->operator*)();
  else   (((const ::edm::RefProd<std::vector<pat::Muon> >*)o)->operator*)();
}

static  void operator_55740( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::Muon> >*)o)->operator->)());
  else   (((const ::edm::RefProd<std::vector<pat::Muon> >*)o)->operator->)();
}

static  void method_55741( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::Muon> >*)o)->get)());
  else   (((const ::edm::RefProd<std::vector<pat::Muon> >*)o)->get)();
}

static  void method_55742( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::Muon> >*)o)->product)());
  else   (((const ::edm::RefProd<std::vector<pat::Muon> >*)o)->product)();
}

static  void method_55743( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<pat::Muon> >*)o)->refCore)();
  else   (((const ::edm::RefProd<std::vector<pat::Muon> >*)o)->refCore)();
}

static  void method_55744( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::Muon> >*)o)->isNull)());
  else   (((const ::edm::RefProd<std::vector<pat::Muon> >*)o)->isNull)();
}

static  void method_55745( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::Muon> >*)o)->isNonnull)());
  else   (((const ::edm::RefProd<std::vector<pat::Muon> >*)o)->isNonnull)();
}

static  void operator_55746( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::Muon> >*)o)->operator!)());
  else   (((const ::edm::RefProd<std::vector<pat::Muon> >*)o)->operator!)();
}

static  void method_55747( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefProd<std::vector<pat::Muon> >*)o)->id)());
  else   (((const ::edm::RefProd<std::vector<pat::Muon> >*)o)->id)();
}

static  void method_55748( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::Muon> >*)o)->productGetter)());
  else   (((const ::edm::RefProd<std::vector<pat::Muon> >*)o)->productGetter)();
}

static  void method_55749( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::Muon> >*)o)->hasCache)());
  else   (((const ::edm::RefProd<std::vector<pat::Muon> >*)o)->hasCache)();
}

static  void method_55750( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::Muon> >*)o)->hasProductCache)());
  else   (((const ::edm::RefProd<std::vector<pat::Muon> >*)o)->hasProductCache)();
}

static  void method_55751( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::Muon> >*)o)->isAvailable)());
  else   (((const ::edm::RefProd<std::vector<pat::Muon> >*)o)->isAvailable)();
}

static  void method_55752( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::Muon> >*)o)->isTransient)());
  else   (((const ::edm::RefProd<std::vector<pat::Muon> >*)o)->isTransient)();
}

static  void method_55753( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefProd<std::vector<pat::Muon> >*)o)->swap)(*(::edm::RefProd<std::vector<pat::Muon> >*)arg[0]);
}

static  void method_55754( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefProd<std::vector<pat::Muon> >*)o)->Class_Version)());
  else   (((::edm::RefProd<std::vector<pat::Muon> >*)o)->Class_Version)();
}

static void method_newdel_9699( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::Muon> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::Muon> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::Muon> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::Muon> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::Muon> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefProd<std::vector<pat::Muon, std::allocator<pat::Muon> > > -------------------------------
void __edm__RefProd_std__vector_pat__Muon_s__db_datamem(Reflex::Class*);
void __edm__RefProd_std__vector_pat__Muon_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_pat__Muon_s__datamem_bld(&__edm__RefProd_std__vector_pat__Muon_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_pat__Muon_s__funcmem_bld(&__edm__RefProd_std__vector_pat__Muon_s__db_funcmem);
void __edm__RefProd_std__vector_pat__Muon_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefProd<std::vector<pat::Muon> >"), typeid(::edm::RefProd<std::vector<pat::Muon> >), sizeof(::edm::RefProd<std::vector<pat::Muon> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefProd<std::vector<pat::Muon> >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::RefProd<pat::MuonCollection>")
  .AddTypedef(type_4694, Reflex::Literal("edm::RefProd<std::vector<pat::Muon> >::product_type"))
  .AddTypedef(type_4694, Reflex::Literal("edm::RefProd<std::vector<pat::Muon> >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85666, type_50689), Reflex::Literal("operator="), operator_55730, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_50689), Reflex::Literal("RefProd"), constructor_55731, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefProd"), constructor_55732, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85667), Reflex::Literal("RefProd"), constructor_55733, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85570), Reflex::Literal("RefProd"), constructor_55734, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85499), Reflex::Literal("RefProd"), constructor_55735, 0, "iProduct", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85498), Reflex::Literal("RefProd"), constructor_55736, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417, type_45418), Reflex::Literal("RefProd"), constructor_55737, 0, "productID;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefProd"), destructor_55738, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9699, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefProd_std__vector_pat__Muon_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefProd_std__vector_pat__Muon_s__funcmem_bld);
}

//------Delayed data member builder for class RefProd<std::vector<pat::Muon, std::allocator<pat::Muon> > > -------------------
void __edm__RefProd_std__vector_pat__Muon_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9667, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefProd_std__vector_pat__Muon_s_, product_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefProd<std::vector<pat::Muon, std::allocator<pat::Muon> > > -------------------
void __edm__RefProd_std__vector_pat__Muon_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_76097), Reflex::Literal("operator*"), operator_55739, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85499), Reflex::Literal("operator->"), operator_55740, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85499), Reflex::Literal("get"), method_55741, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85499), Reflex::Literal("product"), method_55742, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45420), Reflex::Literal("refCore"), method_55743, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNull"), method_55744, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNonnull"), method_55745, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("operator!"), operator_55746, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9664), Reflex::Literal("id"), method_55747, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45418), Reflex::Literal("productGetter"), method_55748, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("hasCache"), method_55749, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("hasProductCache"), method_55750, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isAvailable"), method_55751, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isTransient"), method_55752, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_85666), Reflex::Literal("swap"), method_55753, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_251), Reflex::Literal("Class_Version"), method_55754, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefProd<std::vector<pat::Electron, std::allocator<pat::Electron> > > -------------------------------
static  void operator_55759( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefProd<std::vector<pat::Electron> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<pat::Electron> >*)arg[0]);
  else   (((::edm::RefProd<std::vector<pat::Electron> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<pat::Electron> >*)arg[0]);
}

static void constructor_55760( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::Electron> >(*(const ::edm::RefProd<std::vector<pat::Electron> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::Electron> >(*(const ::edm::RefProd<std::vector<pat::Electron> >*)arg[0]);
}

static void constructor_55761( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::Electron> >();
  else ::new(mem) ::edm::RefProd<std::vector<pat::Electron> >();
}

static void constructor_55762( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::Electron> >(*(const ::edm::Handle<std::vector<pat::Electron> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::Electron> >(*(const ::edm::Handle<std::vector<pat::Electron> >*)arg[0]);
}

static void constructor_55763( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::Electron> >(*(const ::edm::OrphanHandle<std::vector<pat::Electron> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::Electron> >(*(const ::edm::OrphanHandle<std::vector<pat::Electron> >*)arg[0]);
}

static void constructor_55764( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::Electron> >((const ::std::vector<pat::Electron>*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::Electron> >((const ::std::vector<pat::Electron>*)arg[0]);
}

static void constructor_55765( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::Electron> >(*(const ::edm::TestHandle<std::vector<pat::Electron> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::Electron> >(*(const ::edm::TestHandle<std::vector<pat::Electron> >*)arg[0]);
}

static void constructor_55766( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<pat::Electron> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
  else ::new(mem) ::edm::RefProd<std::vector<pat::Electron> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
}

static void destructor_55767(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefProd<std::vector<pat::Electron> >*)o)->::edm::RefProd<std::vector<pat::Electron> >::~RefProd)();
}
static  void operator_55768( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<pat::Electron> >*)o)->operator*)();
  else   (((const ::edm::RefProd<std::vector<pat::Electron> >*)o)->operator*)();
}

static  void operator_55769( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::Electron> >*)o)->operator->)());
  else   (((const ::edm::RefProd<std::vector<pat::Electron> >*)o)->operator->)();
}

static  void method_55770( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::Electron> >*)o)->get)());
  else   (((const ::edm::RefProd<std::vector<pat::Electron> >*)o)->get)();
}

static  void method_55771( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::Electron> >*)o)->product)());
  else   (((const ::edm::RefProd<std::vector<pat::Electron> >*)o)->product)();
}

static  void method_55772( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<pat::Electron> >*)o)->refCore)();
  else   (((const ::edm::RefProd<std::vector<pat::Electron> >*)o)->refCore)();
}

static  void method_55773( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::Electron> >*)o)->isNull)());
  else   (((const ::edm::RefProd<std::vector<pat::Electron> >*)o)->isNull)();
}

static  void method_55774( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::Electron> >*)o)->isNonnull)());
  else   (((const ::edm::RefProd<std::vector<pat::Electron> >*)o)->isNonnull)();
}

static  void operator_55775( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::Electron> >*)o)->operator!)());
  else   (((const ::edm::RefProd<std::vector<pat::Electron> >*)o)->operator!)();
}

static  void method_55776( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefProd<std::vector<pat::Electron> >*)o)->id)());
  else   (((const ::edm::RefProd<std::vector<pat::Electron> >*)o)->id)();
}

static  void method_55777( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<pat::Electron> >*)o)->productGetter)());
  else   (((const ::edm::RefProd<std::vector<pat::Electron> >*)o)->productGetter)();
}

static  void method_55778( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::Electron> >*)o)->hasCache)());
  else   (((const ::edm::RefProd<std::vector<pat::Electron> >*)o)->hasCache)();
}

static  void method_55779( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::Electron> >*)o)->hasProductCache)());
  else   (((const ::edm::RefProd<std::vector<pat::Electron> >*)o)->hasProductCache)();
}

static  void method_55780( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::Electron> >*)o)->isAvailable)());
  else   (((const ::edm::RefProd<std::vector<pat::Electron> >*)o)->isAvailable)();
}

static  void method_55781( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<pat::Electron> >*)o)->isTransient)());
  else   (((const ::edm::RefProd<std::vector<pat::Electron> >*)o)->isTransient)();
}

static  void method_55782( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefProd<std::vector<pat::Electron> >*)o)->swap)(*(::edm::RefProd<std::vector<pat::Electron> >*)arg[0]);
}

static  void method_55783( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefProd<std::vector<pat::Electron> >*)o)->Class_Version)());
  else   (((::edm::RefProd<std::vector<pat::Electron> >*)o)->Class_Version)();
}

static void method_newdel_9700( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::Electron> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::Electron> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::Electron> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::Electron> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<pat::Electron> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefProd<std::vector<pat::Electron, std::allocator<pat::Electron> > > -------------------------------
void __edm__RefProd_std__vector_pat__Electron_s__db_datamem(Reflex::Class*);
void __edm__RefProd_std__vector_pat__Electron_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_pat__Electron_s__datamem_bld(&__edm__RefProd_std__vector_pat__Electron_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_pat__Electron_s__funcmem_bld(&__edm__RefProd_std__vector_pat__Electron_s__db_funcmem);
void __edm__RefProd_std__vector_pat__Electron_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefProd<std::vector<pat::Electron> >"), typeid(::edm::RefProd<std::vector<pat::Electron> >), sizeof(::edm::RefProd<std::vector<pat::Electron> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefProd<std::vector<pat::Electron> >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::RefProd<pat::ElectronCollection>")
  .AddTypedef(type_4715, Reflex::Literal("edm::RefProd<std::vector<pat::Electron> >::product_type"))
  .AddTypedef(type_4715, Reflex::Literal("edm::RefProd<std::vector<pat::Electron> >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85668, type_50688), Reflex::Literal("operator="), operator_55759, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_50688), Reflex::Literal("RefProd"), constructor_55760, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefProd"), constructor_55761, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85669), Reflex::Literal("RefProd"), constructor_55762, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85572), Reflex::Literal("RefProd"), constructor_55763, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85502), Reflex::Literal("RefProd"), constructor_55764, 0, "iProduct", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_85501), Reflex::Literal("RefProd"), constructor_55765, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_45417, type_45418), Reflex::Literal("RefProd"), constructor_55766, 0, "productID;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefProd"), destructor_55767, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_9700, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefProd_std__vector_pat__Electron_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefProd_std__vector_pat__Electron_s__funcmem_bld);
}

//------Delayed data member builder for class RefProd<std::vector<pat::Electron, std::allocator<pat::Electron> > > -------------------
void __edm__RefProd_std__vector_pat__Electron_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_9667, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefProd_std__vector_pat__Electron_s_, product_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefProd<std::vector<pat::Electron, std::allocator<pat::Electron> > > -------------------
void __edm__RefProd_std__vector_pat__Electron_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_76128), Reflex::Literal("operator*"), operator_55768, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85502), Reflex::Literal("operator->"), operator_55769, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85502), Reflex::Literal("get"), method_55770, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_85502), Reflex::Literal("product"), method_55771, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45420), Reflex::Literal("refCore"), method_55772, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNull"), method_55773, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isNonnull"), method_55774, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("operator!"), operator_55775, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9664), Reflex::Literal("id"), method_55776, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_45418), Reflex::Literal("productGetter"), method_55777, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("hasCache"), method_55778, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("hasProductCache"), method_55779, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isAvailable"), method_55780, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2301), Reflex::Literal("isTransient"), method_55781, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_539, type_85668), Reflex::Literal("swap"), method_55782, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_251), Reflex::Literal("Class_Version"), method_55783, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __PATMultiCandFinalState_dict(); 
      __PATFinalState_dict(); 
      __PATFinalStateEvent_dict(); 
      __PATFinalStateLS_dict(); 
      __edm__Ptr_PATFinalStateLS__dict(); 
      __edm__Ptr_PATFinalStateEvent__dict(); 
      __VBFVariables_dict(); 
      __PATFinalStateProxy_dict(); 
      __edm__Ptr_PATMultiCandFinalState__dict(); 
      __edm__Ptr_PATFinalState__dict(); 
      __std__pair_std__basic_string_char__int__dict(); 
      __std__pair_std__basic_string_char__float__dict(); 
      __std__vector_PATFinalStatep__dict(); 
      __std__map_std__basic_string_char__edm__Ptr_pat__MET_s__dict(); 
      __std__map_std__basic_string_char__int__dict(); 
      __std__map_std__basic_string_char__float__dict(); 
      __edm__PtrVector_reco__Vertex__dict(); 
      __edm__Wrapper_PATMultiCandFinalState__dict(); 
      __edm__Wrapper_PATFinalStateLS__dict(); 
      __edm__Wrapper_PATFinalStateEvent__dict(); 
      __edm__Ptr_reco__Vertex__dict(); 
      __edm__Ptr_pat__Photon__dict(); 
      __PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon__dict(); 
      __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon__dict(); 
      __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon__dict(); 
      __PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau__dict(); 
      __std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s__dict(); 
      __PATPairFinalStateT_pat__Muon_pat__Jet__dict(); 
      __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau__dict(); 
      __PATPairFinalStateT_pat__Tau_pat__Tau__dict(); 
      __PATPairFinalStateT_pat__Electron_pat__Jet__dict(); 
      __std__vector_PATPairFinalStateT_pat__Electron_pat__Jet_s__dict(); 
      __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon__dict(); 
      __std__vector_PATFinalStateEvent__dict(); 
      __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron__dict(); 
      __PATPairFinalStateT_pat__Electron_pat__Muon__dict(); 
      __std__vector_PATPairFinalStateT_pat__Electron_pat__Muon_s__dict(); 
      __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau__dict(); 
      __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s__dict(); 
      __PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet__dict(); 
      __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s__dict(); 
      __PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau__dict(); 
      __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon__dict(); 
      __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon__dict(); 
      __PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon__dict(); 
      __PATPairFinalStateT_pat__Muon_pat__Muon__dict(); 
      __std__vector_PATPairFinalStateT_pat__Muon_pat__Muon_s__dict(); 
      __edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__dict(); 
      __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau__dict(); 
      __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau__dict(); 
      __PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon__dict(); 
      __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau__dict(); 
      __PATPairFinalStateT_pat__Photon_pat__Photon__dict(); 
      __PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon__dict(); 
      __std__vector_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s__dict(); 
      __std__vector_PATPairFinalStateT_pat__Photon_pat__Photon_s__dict(); 
      __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s__dict(); 
      __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s__dict(); 
      __std__vector_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s__dict(); 
      __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau__dict(); 
      __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s__dict(); 
      __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon__dict(); 
      __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau__dict(); 
      __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s__dict(); 
      __PATPairFinalStateT_pat__Muon_pat__Photon__dict(); 
      __PATPairFinalStateT_pat__Muon_pat__Tau__dict(); 
      __std__vector_PATPairFinalStateT_pat__Muon_pat__Tau_s__dict(); 
      __PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau__dict(); 
      __PATPairFinalStateT_pat__Electron_pat__Electron__dict(); 
      __std__vector_PATPairFinalStateT_pat__Electron_pat__Electron_s__dict(); 
      __PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon__dict(); 
      __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron__dict(); 
      __std__vector_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s__dict(); 
      __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s__dict(); 
      __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon__dict(); 
      __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s__dict(); 
      __std__vector_PATPairFinalStateT_pat__Muon_pat__Jet_s__dict(); 
      __PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon__dict(); 
      __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s__dict(); 
      __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s__dict(); 
      __PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon__dict(); 
      __std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s__dict(); 
      __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s__dict(); 
      __PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon__dict(); 
      __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s__dict(); 
      __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s__dict(); 
      __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon__dict(); 
      __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s__dict(); 
      __std__vector_PATFinalStateLS__dict(); 
      __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon__dict(); 
      __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s__dict(); 
      __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s__dict(); 
      __PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau__dict(); 
      __PATPairFinalStateT_pat__Electron_pat__Photon__dict(); 
      __std__vector_PATPairFinalStateT_pat__Electron_pat__Photon_s__dict(); 
      __PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon__dict(); 
      __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau__dict(); 
      __PATPairFinalStateT_pat__Electron_pat__Tau__dict(); 
      __std__vector_PATPairFinalStateT_pat__Electron_pat__Tau_s__dict(); 
      __std__vector_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s__dict(); 
      __std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s__dict(); 
      __std__vector_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s__dict(); 
      __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s__dict(); 
      __std__vector_PATMultiCandFinalState__dict(); 
      __PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon__dict(); 
      __std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s__dict(); 
      __std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s__dict(); 
      __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s__dict(); 
      __std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s__dict(); 
      __std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s__dict(); 
      __std__vector_PATPairFinalStateT_pat__Tau_pat__Tau_s__dict(); 
      __std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s__dict(); 
      __std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s__dict(); 
      __std__vector_PATPairFinalStateT_pat__Muon_pat__Photon_s__dict(); 
      __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s__dict(); 
      __std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s__dict(); 
      __edm__RefProd_std__vector_PATFinalStateEvent_s__dict(); 
      __edm__RefVector_std__vector_PATFinalStateEvent__PATFinalStateEvent_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateEvent__PATFinalStateEvent_s__dict(); 
      __edm__RefProd_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s_s__dict(); 
      __edm__RefProd_std__vector_PATFinalStateLS_s__dict(); 
      __edm__RefVector_std__vector_PATFinalStateLS__PATFinalStateLS_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateLS__PATFinalStateLS_s__dict(); 
      __edm__RefVector_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_edm__refhelper__FindUsingAdvance_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_s__dict(); 
      __edm__RefProd_std__vector_PATMultiCandFinalState_s__dict(); 
      __edm__Ref_std__vector_PATFinalStateLS__PATFinalStateLS_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateLS__PATFinalStateLS_s__dict(); 
      __edm__Ref_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_edm__refhelper__FindUsingAdvance_std__vector_PATMultiCandFinalState__PATMultiCandFinalState_s__dict(); 
      __edm__RefVector_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_edm__refhelper__FindUsingAdvance_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_s__dict(); 
      __edm__Ref_std__vector_PATFinalStateEvent__PATFinalStateEvent_edm__refhelper__FindUsingAdvance_std__vector_PATFinalStateEvent__PATFinalStateEvent_s__dict(); 
      __edm__Ref_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_edm__refhelper__FindUsingAdvance_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s__PATFinalState_s__dict(); 
      __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s_s__dict(); 
      __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Photon_pat__Photon_s__dict(); 
      __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s_s__dict(); 
      __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Tau_pat__Tau_s__dict(); 
      __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s_s__dict(); 
      __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Photon_s__dict(); 
      __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s_s__dict(); 
      __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Tau_s__dict(); 
      __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s_s__dict(); 
      __edm__Wrapper_PATQuadFinalStateT_pat__Muon_pat__Muon_pat__Muon_pat__Muon_s__dict(); 
      __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s_s__dict(); 
      __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Photon_pat__Photon_s__dict(); 
      __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s_s__dict(); 
      __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Tau_pat__Tau_s__dict(); 
      __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s_s__dict(); 
      __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Photon_s__dict(); 
      __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s_s__dict(); 
      __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Tau_s__dict(); 
      __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s_s__dict(); 
      __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Muon_pat__Muon_pat__Muon_s__dict(); 
      __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s_s__dict(); 
      __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Photon_pat__Photon_s__dict(); 
      __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s_s__dict(); 
      __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Tau_pat__Tau_s__dict(); 
      __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s_s__dict(); 
      __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Photon_s__dict(); 
      __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s_s__dict(); 
      __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Tau_s__dict(); 
      __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s_s__dict(); 
      __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Muon_pat__Muon_s__dict(); 
      __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s_s__dict(); 
      __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Photon_s__dict(); 
      __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s_s__dict(); 
      __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Tau_s__dict(); 
      __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s_s__dict(); 
      __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Muon_s__dict(); 
      __edm__Wrapper_std__vector_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s_s__dict(); 
      __edm__Wrapper_PATQuadFinalStateT_pat__Electron_pat__Electron_pat__Electron_pat__Electron_s__dict(); 
      __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s_s__dict(); 
      __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Jet_pat__Jet_s__dict(); 
      __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s_s__dict(); 
      __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Photon_pat__Photon_s__dict(); 
      __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s_s__dict(); 
      __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Tau_pat__Tau_s__dict(); 
      __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s_s__dict(); 
      __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Photon_s__dict(); 
      __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s_s__dict(); 
      __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Tau_s__dict(); 
      __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s_s__dict(); 
      __edm__Wrapper_PATTripletFinalStateT_pat__Muon_pat__Muon_pat__Muon_s__dict(); 
      __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s_s__dict(); 
      __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Photon_pat__Photon_s__dict(); 
      __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s_s__dict(); 
      __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Tau_pat__Tau_s__dict(); 
      __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s_s__dict(); 
      __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Photon_s__dict(); 
      __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s_s__dict(); 
      __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Tau_s__dict(); 
      __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s_s__dict(); 
      __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Muon_pat__Muon_s__dict(); 
      __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s_s__dict(); 
      __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Photon_s__dict(); 
      __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s_s__dict(); 
      __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Tau_s__dict(); 
      __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s_s__dict(); 
      __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Muon_s__dict(); 
      __edm__Wrapper_std__vector_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s_s__dict(); 
      __edm__Wrapper_PATTripletFinalStateT_pat__Electron_pat__Electron_pat__Electron_s__dict(); 
      __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Jet_s_s__dict(); 
      __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Jet_s__dict(); 
      __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Jet_s_s__dict(); 
      __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Jet_s__dict(); 
      __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Photon_pat__Photon_s_s__dict(); 
      __edm__Wrapper_PATPairFinalStateT_pat__Photon_pat__Photon_s__dict(); 
      __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Tau_pat__Tau_s_s__dict(); 
      __edm__Wrapper_PATPairFinalStateT_pat__Tau_pat__Tau_s__dict(); 
      __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Photon_s_s__dict(); 
      __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Photon_s__dict(); 
      __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Tau_s_s__dict(); 
      __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Tau_s__dict(); 
      __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Muon_pat__Muon_s_s__dict(); 
      __edm__Wrapper_PATPairFinalStateT_pat__Muon_pat__Muon_s__dict(); 
      __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Photon_s_s__dict(); 
      __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Photon_s__dict(); 
      __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Tau_s_s__dict(); 
      __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Tau_s__dict(); 
      __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Muon_s_s__dict(); 
      __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Muon_s__dict(); 
      __edm__Wrapper_std__vector_PATPairFinalStateT_pat__Electron_pat__Electron_s_s__dict(); 
      __edm__Wrapper_PATPairFinalStateT_pat__Electron_pat__Electron_s__dict(); 
      __edm__Wrapper_std__vector_PATMultiCandFinalState_s__dict(); 
      __edm__Wrapper_std__vector_PATFinalStateLS_s__dict(); 
      __edm__Wrapper_std__vector_PATFinalStateEvent_s__dict(); 
      __edm__Wrapper_edm__OwnVector_PATFinalState_edm__ClonePolicy_PATFinalState_s_s__dict(); 
      __edm__RefProd_std__vector_pat__Photon_s__dict(); 
      __edm__RefProd_std__vector_pat__Jet_s__dict(); 
      __edm__RefProd_std__vector_pat__Tau_s__dict(); 
      __edm__RefProd_std__vector_pat__Muon_s__dict(); 
      __edm__RefProd_std__vector_pat__Electron_s__dict(); 
    }
    ~Dictionaries() {
      type_67.Unload(); // class PATMultiCandFinalState 
      type_466.Unload(); // class PATFinalState 
      type_583.Unload(); // class PATFinalStateEvent 
      type_3039.Unload(); // class PATFinalStateLS 
      type_1814.Unload(); // class edm::Ptr<PATFinalStateLS> 
      type_2414.Unload(); // class edm::Ptr<PATFinalStateEvent> 
      type_2448.Unload(); // class VBFVariables 
      type_2951.Unload(); // class PATFinalStateProxy 
      type_3318.Unload(); // class edm::Ptr<PATMultiCandFinalState> 
      type_3651.Unload(); // class edm::Ptr<PATFinalState> 
      type_4465.Unload(); // class std::pair<std::basic_string<char>,int> 
      type_4466.Unload(); // class std::pair<std::basic_string<char>,float> 
      type_4595.Unload(); // class std::vector<PATFinalState*> 
      type_4899.Unload(); // class std::map<std::basic_string<char>,edm::Ptr<pat::MET> > 
      type_4900.Unload(); // class std::map<std::basic_string<char>,int> 
      type_4901.Unload(); // class std::map<std::basic_string<char>,float> 
      type_8840.Unload(); // class edm::PtrVector<reco::Vertex> 
      type_9235.Unload(); // class edm::Wrapper<PATMultiCandFinalState> 
      type_9237.Unload(); // class edm::Wrapper<PATFinalStateLS> 
      type_9239.Unload(); // class edm::Wrapper<PATFinalStateEvent> 
      type_9784.Unload(); // class edm::Ptr<reco::Vertex> 
      type_9786.Unload(); // class edm::Ptr<pat::Photon> 
      type_110.Unload(); // class PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> 
      type_113.Unload(); // class PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> 
      type_164.Unload(); // class PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> 
      type_1519.Unload(); // class PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> 
      type_260.Unload(); // class std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > 
      type_288.Unload(); // class PATPairFinalStateT<pat::Muon,pat::Jet> 
      type_308.Unload(); // class PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> 
      type_334.Unload(); // class PATPairFinalStateT<pat::Tau,pat::Tau> 
      type_1593.Unload(); // class PATPairFinalStateT<pat::Electron,pat::Jet> 
      type_444.Unload(); // class std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > 
      type_473.Unload(); // class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> 
      type_480.Unload(); // class std::vector<PATFinalStateEvent> 
      type_505.Unload(); // class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> 
      type_1888.Unload(); // class PATPairFinalStateT<pat::Electron,pat::Muon> 
      type_552.Unload(); // class std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > 
      type_762.Unload(); // class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> 
      type_556.Unload(); // class std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > 
      type_634.Unload(); // class PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> 
      type_670.Unload(); // class std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > 
      type_716.Unload(); // class PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> 
      type_803.Unload(); // class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> 
      type_891.Unload(); // class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> 
      type_912.Unload(); // class PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> 
      type_1200.Unload(); // class PATPairFinalStateT<pat::Muon,pat::Muon> 
      type_922.Unload(); // class std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > 
      type_951.Unload(); // class edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > 
      type_956.Unload(); // class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> 
      type_1022.Unload(); // class PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> 
      type_1051.Unload(); // class PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> 
      type_1121.Unload(); // class PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> 
      type_1155.Unload(); // class PATPairFinalStateT<pat::Photon,pat::Photon> 
      type_1517.Unload(); // class PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> 
      type_1163.Unload(); // class std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > 
      type_1251.Unload(); // class std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > 
      type_1270.Unload(); // class std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > 
      type_1303.Unload(); // class std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > 
      type_1352.Unload(); // class std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > 
      type_2810.Unload(); // class PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> 
      type_1381.Unload(); // class std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > 
      type_1393.Unload(); // class PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> 
      type_1959.Unload(); // class PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> 
      type_1605.Unload(); // class std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > 
      type_1607.Unload(); // class PATPairFinalStateT<pat::Muon,pat::Photon> 
      type_1885.Unload(); // class PATPairFinalStateT<pat::Muon,pat::Tau> 
      type_1614.Unload(); // class std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > 
      type_1521.Unload(); // class PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> 
      type_1889.Unload(); // class PATPairFinalStateT<pat::Electron,pat::Electron> 
      type_1724.Unload(); // class std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > 
      type_1520.Unload(); // class PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> 
      type_1524.Unload(); // class PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> 
      type_1842.Unload(); // class std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > 
      type_1850.Unload(); // class std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > 
      type_2808.Unload(); // class PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> 
      type_1852.Unload(); // class std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > 
      type_1869.Unload(); // class std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > 
      type_1523.Unload(); // class PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> 
      type_1976.Unload(); // class std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > 
      type_1982.Unload(); // class std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > 
      type_1522.Unload(); // class PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> 
      type_2030.Unload(); // class std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > 
      type_2037.Unload(); // class std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > 
      type_2809.Unload(); // class PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> 
      type_2163.Unload(); // class std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > 
      type_2170.Unload(); // class std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > 
      type_2684.Unload(); // class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> 
      type_2188.Unload(); // class std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > 
      type_2244.Unload(); // class std::vector<PATFinalStateLS> 
      type_2807.Unload(); // class PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> 
      type_2311.Unload(); // class std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > 
      type_2341.Unload(); // class std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > 
      type_1518.Unload(); // class PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> 
      type_1886.Unload(); // class PATPairFinalStateT<pat::Electron,pat::Photon> 
      type_2440.Unload(); // class std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > 
      type_2525.Unload(); // class PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> 
      type_2562.Unload(); // class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> 
      type_1887.Unload(); // class PATPairFinalStateT<pat::Electron,pat::Tau> 
      type_2858.Unload(); // class std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > 
      type_2880.Unload(); // class std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > 
      type_2919.Unload(); // class std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > 
      type_2938.Unload(); // class std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > 
      type_2945.Unload(); // class std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > 
      type_3002.Unload(); // class std::vector<PATMultiCandFinalState> 
      type_2811.Unload(); // class PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> 
      type_3061.Unload(); // class std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > 
      type_3101.Unload(); // class std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > 
      type_3126.Unload(); // class std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > 
      type_3132.Unload(); // class std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > 
      type_3307.Unload(); // class std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > 
      type_3403.Unload(); // class std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > 
      type_3510.Unload(); // class std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > 
      type_3537.Unload(); // class std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > 
      type_3550.Unload(); // class std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > 
      type_3617.Unload(); // class std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > 
      type_3645.Unload(); // class std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > 
      type_80.Unload(); // class edm::RefProd<std::vector<PATFinalStateEvent> > 
      type_96.Unload(); // class edm::RefVector<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> > 
      type_229.Unload(); // class edm::RefProd<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > > 
      type_263.Unload(); // class edm::RefProd<std::vector<PATFinalStateLS> > 
      type_277.Unload(); // class edm::RefVector<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> > 
      type_2057.Unload(); // class edm::RefVector<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> > 
      type_2093.Unload(); // class edm::RefProd<std::vector<PATMultiCandFinalState> > 
      type_2230.Unload(); // class edm::Ref<std::vector<PATFinalStateLS>,PATFinalStateLS,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateLS>,PATFinalStateLS> > 
      type_2399.Unload(); // class edm::Ref<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState,edm::refhelper::FindUsingAdvance<std::vector<PATMultiCandFinalState>,PATMultiCandFinalState> > 
      type_2787.Unload(); // class edm::RefVector<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> > 
      type_3065.Unload(); // class edm::Ref<std::vector<PATFinalStateEvent>,PATFinalStateEvent,edm::refhelper::FindUsingAdvance<std::vector<PATFinalStateEvent>,PATFinalStateEvent> > 
      type_3090.Unload(); // class edm::Ref<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState,edm::refhelper::FindUsingAdvance<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> >,PATFinalState> > 
      type_9142.Unload(); // class edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > > 
      type_9143.Unload(); // class edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Photon,pat::Photon> > 
      type_9144.Unload(); // class edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > > 
      type_9145.Unload(); // class edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Tau,pat::Tau> > 
      type_9146.Unload(); // class edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > > 
      type_9147.Unload(); // class edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Photon> > 
      type_9148.Unload(); // class edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > > 
      type_9149.Unload(); // class edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Tau> > 
      type_9150.Unload(); // class edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > > 
      type_9151.Unload(); // class edm::Wrapper<PATQuadFinalStateT<pat::Muon,pat::Muon,pat::Muon,pat::Muon> > 
      type_9152.Unload(); // class edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > > 
      type_9153.Unload(); // class edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Photon,pat::Photon> > 
      type_9154.Unload(); // class edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > > 
      type_9155.Unload(); // class edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Tau,pat::Tau> > 
      type_9156.Unload(); // class edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > > 
      type_9157.Unload(); // class edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Photon> > 
      type_9158.Unload(); // class edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > > 
      type_9159.Unload(); // class edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Tau> > 
      type_9160.Unload(); // class edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > > 
      type_9161.Unload(); // class edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Muon,pat::Muon,pat::Muon> > 
      type_9162.Unload(); // class edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > > 
      type_9163.Unload(); // class edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Photon,pat::Photon> > 
      type_9164.Unload(); // class edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > > 
      type_9165.Unload(); // class edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Tau,pat::Tau> > 
      type_9166.Unload(); // class edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > > 
      type_9167.Unload(); // class edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Photon> > 
      type_9168.Unload(); // class edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > > 
      type_9169.Unload(); // class edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Tau> > 
      type_9170.Unload(); // class edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > > 
      type_9171.Unload(); // class edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Muon,pat::Muon> > 
      type_9172.Unload(); // class edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > > 
      type_9173.Unload(); // class edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Photon> > 
      type_9174.Unload(); // class edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > > 
      type_9175.Unload(); // class edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Tau> > 
      type_9176.Unload(); // class edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > > 
      type_9177.Unload(); // class edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Muon> > 
      type_9178.Unload(); // class edm::Wrapper<std::vector<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > > 
      type_9179.Unload(); // class edm::Wrapper<PATQuadFinalStateT<pat::Electron,pat::Electron,pat::Electron,pat::Electron> > 
      type_9180.Unload(); // class edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > > 
      type_9181.Unload(); // class edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Jet,pat::Jet> > 
      type_9182.Unload(); // class edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > > 
      type_9183.Unload(); // class edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Photon,pat::Photon> > 
      type_9184.Unload(); // class edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > > 
      type_9185.Unload(); // class edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Tau,pat::Tau> > 
      type_9186.Unload(); // class edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > > 
      type_9187.Unload(); // class edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Photon> > 
      type_9188.Unload(); // class edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > > 
      type_9189.Unload(); // class edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Tau> > 
      type_9190.Unload(); // class edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > > 
      type_9191.Unload(); // class edm::Wrapper<PATTripletFinalStateT<pat::Muon,pat::Muon,pat::Muon> > 
      type_9192.Unload(); // class edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > > 
      type_9193.Unload(); // class edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Photon,pat::Photon> > 
      type_9194.Unload(); // class edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > > 
      type_9195.Unload(); // class edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Tau,pat::Tau> > 
      type_9196.Unload(); // class edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > > 
      type_9197.Unload(); // class edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Photon> > 
      type_9198.Unload(); // class edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > > 
      type_9199.Unload(); // class edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Tau> > 
      type_9200.Unload(); // class edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > > 
      type_9201.Unload(); // class edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Muon,pat::Muon> > 
      type_9202.Unload(); // class edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > > 
      type_9203.Unload(); // class edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Photon> > 
      type_9204.Unload(); // class edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > > 
      type_9205.Unload(); // class edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Tau> > 
      type_9206.Unload(); // class edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > > 
      type_9207.Unload(); // class edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Muon> > 
      type_9208.Unload(); // class edm::Wrapper<std::vector<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > > 
      type_9209.Unload(); // class edm::Wrapper<PATTripletFinalStateT<pat::Electron,pat::Electron,pat::Electron> > 
      type_9210.Unload(); // class edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Jet> > > 
      type_9211.Unload(); // class edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Jet> > 
      type_9212.Unload(); // class edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Jet> > > 
      type_9213.Unload(); // class edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Jet> > 
      type_9214.Unload(); // class edm::Wrapper<std::vector<PATPairFinalStateT<pat::Photon,pat::Photon> > > 
      type_9215.Unload(); // class edm::Wrapper<PATPairFinalStateT<pat::Photon,pat::Photon> > 
      type_9218.Unload(); // class edm::Wrapper<std::vector<PATPairFinalStateT<pat::Tau,pat::Tau> > > 
      type_9219.Unload(); // class edm::Wrapper<PATPairFinalStateT<pat::Tau,pat::Tau> > 
      type_9220.Unload(); // class edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Photon> > > 
      type_9221.Unload(); // class edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Photon> > 
      type_9222.Unload(); // class edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Tau> > > 
      type_9223.Unload(); // class edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Tau> > 
      type_9224.Unload(); // class edm::Wrapper<std::vector<PATPairFinalStateT<pat::Muon,pat::Muon> > > 
      type_9225.Unload(); // class edm::Wrapper<PATPairFinalStateT<pat::Muon,pat::Muon> > 
      type_9226.Unload(); // class edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Photon> > > 
      type_9227.Unload(); // class edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Photon> > 
      type_9228.Unload(); // class edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Tau> > > 
      type_9229.Unload(); // class edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Tau> > 
      type_9230.Unload(); // class edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Muon> > > 
      type_9231.Unload(); // class edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Muon> > 
      type_9232.Unload(); // class edm::Wrapper<std::vector<PATPairFinalStateT<pat::Electron,pat::Electron> > > 
      type_9233.Unload(); // class edm::Wrapper<PATPairFinalStateT<pat::Electron,pat::Electron> > 
      type_9234.Unload(); // class edm::Wrapper<std::vector<PATMultiCandFinalState> > 
      type_9236.Unload(); // class edm::Wrapper<std::vector<PATFinalStateLS> > 
      type_9238.Unload(); // class edm::Wrapper<std::vector<PATFinalStateEvent> > 
      type_9240.Unload(); // class edm::Wrapper<edm::OwnVector<PATFinalState,edm::ClonePolicy<PATFinalState> > > 
      type_9696.Unload(); // class edm::RefProd<std::vector<pat::Photon> > 
      type_9697.Unload(); // class edm::RefProd<std::vector<pat::Jet> > 
      type_9698.Unload(); // class edm::RefProd<std::vector<pat::Tau> > 
      type_9699.Unload(); // class edm::RefProd<std::vector<pat::Muon> > 
      type_9700.Unload(); // class edm::RefProd<std::vector<pat::Electron> > 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
