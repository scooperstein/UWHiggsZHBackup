// Generated at Fri Feb 28 12:36:03 2014. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gccxml/20110825/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gccxml/20110825/bin/gccxml_cc1plus"
  GCCXML_CPP="/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gccxml/20110825/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='2' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='1' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.6.2"' -D__UINT64_C(c)='c ## UL' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__GNUC_MINOR__='6' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -iwrapper"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gccxml/20110825/share/gccxml-0.9/GCC/4.6" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../include/c++/4.6.2" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../include/c++/4.6.2/x86_64-unknown-linux-gnu" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../include/c++/4.6.2/backward" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/include" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/include-fixed" -isystem"/usr/local/include" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gccxml/20110825/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.6.2
Copyright (C) 2011 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "/afs/hep.wisc.edu/user/stephane/sync_setup/src/DataFormats/CaloRecHit/src/classes.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("edm") );
  ::Reflex::NamespaceBuilder nsb2( Reflex::Literal("reco") );
  ::Reflex::NamespaceBuilder nsb3( Reflex::Literal("edm::reftobase") );
  ::Reflex::Type type_61 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_11 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_780 = ::Reflex::TypeBuilder(Reflex::Literal("DetId"));
  ::Reflex::Type type_646 = ::Reflex::TypeBuilder(Reflex::Literal("float"));
  ::Reflex::Type type_2699 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_2734 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_973 = ::Reflex::TypeBuilder(Reflex::Literal("short"));
  ::Reflex::Type type_1669 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_994 = ::Reflex::TypeBuilder(Reflex::Literal("CaloRecHit"));
  ::Reflex::Type type_234 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_3845 = ::Reflex::TypeBuilder(Reflex::Literal("reco::CaloID"));
  ::Reflex::Type type_227 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_3410 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefCore"));
  ::Reflex::Type type_3408 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ProductID"));
  ::Reflex::Type type_1922 = ::Reflex::TypeBuilder(Reflex::Literal("std::type_info"));
  ::Reflex::Type type_3844 = ::Reflex::TypeBuilder(Reflex::Literal("reco::CaloCluster"));
  ::Reflex::Type type_2252 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<DetId>"));
  ::Reflex::Type type_3389 = ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVectorBase"));
  ::Reflex::Type type_3432 = ::Reflex::TypeBuilder(Reflex::Literal("edm::EDProductGetter"));
  ::Reflex::Type type_1817 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_2246 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const void*>"));
  ::Reflex::Type type_2247 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long>"));
  ::Reflex::Type type_3420 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefToBase<CaloRecHit>"));
  ::Reflex::Type type_3424 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<reco::CaloCluster>"));
  ::Reflex::Type type_14963 = ::Reflex::EnumTypeBuilder(Reflex::Literal("reco::CaloID::Detectors"));
  ::Reflex::Type type_6414 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolderBase"));
  ::Reflex::Type type_14919 = ::Reflex::EnumTypeBuilder(Reflex::Literal("reco::CaloCluster::AlgoId"));
  ::Reflex::Type type_2251 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::CaloCluster>"));
  ::Reflex::Type type_3357 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefToBaseProd<CaloRecHit>"));
  ::Reflex::Type type_3445 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ValueMap<reco::CaloCluster>"));
  ::Reflex::Type type_2474 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<reco::CaloCluster>"));
  ::Reflex::Type type_3335 = ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVector<reco::CaloCluster>"));
  ::Reflex::Type type_3441 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<edm::View<CaloRecHit> >"));
  ::Reflex::Type type_2248 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<DetId,float> >"));
  ::Reflex::Type type_3363 = ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVectorItr<reco::CaloCluster>"));
  ::Reflex::Type type_14107 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseHolder<CaloRecHit>"));
  ::Reflex::Type type_2249 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::Ptr<reco::CaloCluster> >"));
  ::Reflex::Type type_2472 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<edm::Ptr<reco::CaloCluster> >"));
  ::Reflex::Type type_2029 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::reftobase::RefHolderBase>"));
  ::Reflex::Type type_3348 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<reco::CaloCluster> >"));
  ::Reflex::Type type_2032 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<reco::CaloCluster> >"));
  ::Reflex::Type type_3347 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::ValueMap<reco::CaloCluster> >"));
  ::Reflex::Type type_2031 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::ValueMap<reco::CaloCluster> >"));
  ::Reflex::Type type_2859 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<edm::reftobase::RefHolderBase>"));
  ::Reflex::Type type_3346 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::PtrVector<reco::CaloCluster> >"));
  ::Reflex::Type type_2030 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::PtrVector<reco::CaloCluster> >"));
  ::Reflex::Type type_14544 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ValueMap<reco::CaloCluster>::const_iterator"));
  ::Reflex::Type type_2027 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_2250 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<edm::ProductID,unsigned int> >"));
  ::Reflex::Type type_2860 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_3352 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<reco::CaloCluster> >"));
  ::Reflex::Type type_14354 = ::Reflex::TypeBuilder(Reflex::Literal("edm::helper::Filler<edm::ValueMap<reco::CaloCluster> >"));
  ::Reflex::Type type_3351 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::ValueMap<reco::CaloCluster> >"));
  ::Reflex::Type type_3350 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::PtrVector<reco::CaloCluster> >"));
  ::Reflex::Type type_2028 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::reftobase::BaseVectorHolder<CaloRecHit> >"));
  ::Reflex::Type type_1792 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::CaloCluster,std::allocator<reco::CaloCluster> >"));
  ::Reflex::Type type_3925 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<reco::CaloCluster*,std::vector<reco::CaloCluster> >"));
  ::Reflex::Type type_3926 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const reco::CaloCluster*,std::vector<reco::CaloCluster> >"));
  ::Reflex::Type type_1791 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<edm::Ptr<reco::CaloCluster>,std::allocator<edm::Ptr<reco::CaloCluster> > >"));
  ::Reflex::Type type_3791 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>"));
  ::Reflex::Type type_3922 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<edm::Ptr<reco::CaloCluster>*,std::vector<edm::Ptr<reco::CaloCluster> > >"));
  ::Reflex::Type type_2586 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<reco::CaloCluster*,std::vector<reco::CaloCluster> > >"));
  ::Reflex::Type type_3923 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const edm::Ptr<reco::CaloCluster>*,std::vector<edm::Ptr<reco::CaloCluster> > >"));
  ::Reflex::Type type_2585 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const reco::CaloCluster*,std::vector<reco::CaloCluster> > >"));
  ::Reflex::Type type_2584 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<edm::Ptr<reco::CaloCluster>*,std::vector<edm::Ptr<reco::CaloCluster> > > >"));
  ::Reflex::Type type_2583 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const edm::Ptr<reco::CaloCluster>*,std::vector<edm::Ptr<reco::CaloCluster> > > >"));
  ::Reflex::Type type_1083 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("uint32_t"), type_234);
  ::Reflex::Type type_7231 = ::Reflex::ReferenceBuilder(type_994);
  ::Reflex::Type type_994c = ::Reflex::ConstBuilder(type_994);
  ::Reflex::Type type_3750 = ::Reflex::ReferenceBuilder(type_994c);
  ::Reflex::Type type_780c = ::Reflex::ConstBuilder(type_780);
  ::Reflex::Type type_7679 = ::Reflex::ReferenceBuilder(type_780c);
  ::Reflex::Type type_3792 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("math::XYZPointD"), type_3791);
  ::Reflex::Type type_3795 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("math::XYZPoint"), type_3792);
  ::Reflex::Type type_7612 = ::Reflex::ReferenceBuilder(type_3844);
  ::Reflex::Type type_3844c = ::Reflex::ConstBuilder(type_3844);
  ::Reflex::Type type_7614 = ::Reflex::ReferenceBuilder(type_3844c);
  ::Reflex::Type type_3795c = ::Reflex::ConstBuilder(type_3795);
  ::Reflex::Type type_22726 = ::Reflex::ReferenceBuilder(type_3795c);
  ::Reflex::Type type_3845c = ::Reflex::ConstBuilder(type_3845);
  ::Reflex::Type type_14909 = ::Reflex::ReferenceBuilder(type_3845c);
  ::Reflex::Type type_14919c = ::Reflex::ConstBuilder(type_14919);
  ::Reflex::Type type_22727 = ::Reflex::ReferenceBuilder(type_14919c);
  ::Reflex::Type type_2248c = ::Reflex::ConstBuilder(type_2248);
  ::Reflex::Type type_18206 = ::Reflex::ReferenceBuilder(type_2248c);
  ::Reflex::Type type_2252c = ::Reflex::ConstBuilder(type_2252);
  ::Reflex::Type type_18217 = ::Reflex::ReferenceBuilder(type_2252c);
  ::Reflex::Type type_1501 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("size_t"), type_227);
  ::Reflex::Type type_1818 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::string"), type_1817);
  ::Reflex::Type type_7484 = ::Reflex::ReferenceBuilder(type_3424);
  ::Reflex::Type type_3424c = ::Reflex::ConstBuilder(type_3424);
  ::Reflex::Type type_7486 = ::Reflex::ReferenceBuilder(type_3424c);
  ::Reflex::Type type_3408c = ::Reflex::ConstBuilder(type_3408);
  ::Reflex::Type type_11208 = ::Reflex::ReferenceBuilder(type_3408c);
  ::Reflex::Type type_3432c = ::Reflex::ConstBuilder(type_3432);
  ::Reflex::Type type_14436 = ::Reflex::PointerBuilder(type_3432c);
  ::Reflex::Type type_7610 = ::Reflex::PointerBuilder(type_3844c);
  ::Reflex::Type type_3410c = ::Reflex::ConstBuilder(type_3410);
  ::Reflex::Type type_14151 = ::Reflex::ReferenceBuilder(type_3410c);
  ::Reflex::Type type_2699c = ::Reflex::ConstBuilder(type_2699);
  ::Reflex::Type type_2769 = ::Reflex::PointerBuilder(type_2699c);
  ::Reflex::Type type_7480 = ::Reflex::PointerBuilder(type_3424);
  ::Reflex::Type type_7482 = ::Reflex::PointerBuilder(type_3424c);
  ::Reflex::Type type_2454 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_227);
  ::Reflex::Type type_2353 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_11);
  ::Reflex::Type type_2472c = ::Reflex::ConstBuilder(type_2472);
  ::Reflex::Type type_17474 = ::Reflex::ReferenceBuilder(type_2472c);
  ::Reflex::Type type_2249c = ::Reflex::ConstBuilder(type_2249);
  ::Reflex::Type type_18209 = ::Reflex::ReferenceBuilder(type_2249c);
  ::Reflex::Type type_18210 = ::Reflex::ReferenceBuilder(type_2249);
  ::Reflex::Type type_7608 = ::Reflex::PointerBuilder(type_3844);
  ::Reflex::Type type_2474c = ::Reflex::ConstBuilder(type_2474);
  ::Reflex::Type type_17486 = ::Reflex::ReferenceBuilder(type_2474c);
  ::Reflex::Type type_2251c = ::Reflex::ConstBuilder(type_2251);
  ::Reflex::Type type_18214 = ::Reflex::ReferenceBuilder(type_2251c);
  ::Reflex::Type type_18215 = ::Reflex::ReferenceBuilder(type_2251);
  ::Reflex::Type type_3335c = ::Reflex::ConstBuilder(type_3335);
  ::Reflex::Type type_22444 = ::Reflex::ReferenceBuilder(type_3335c);
  ::Reflex::Type type_227c = ::Reflex::ConstBuilder(type_227);
  ::Reflex::Type type_22445 = ::Reflex::ReferenceBuilder(type_3335);
  ::Reflex::Type type_18202 = ::Reflex::ReferenceBuilder(type_2246);
  ::Reflex::Type type_22446 = ::Reflex::PointerBuilder(type_3335c);
  ::Reflex::Type type_1922c = ::Reflex::ConstBuilder(type_1922);
  ::Reflex::Type type_3322 = ::Reflex::ReferenceBuilder(type_1922c);
  ::Reflex::Type type_22447 = ::Reflex::PointerBuilder(type_3335);
  ::Reflex::Type type_3350c = ::Reflex::ConstBuilder(type_3350);
  ::Reflex::Type type_22448 = ::Reflex::PointerBuilder(type_3350c);
  ::Reflex::Type type_18759 = ::Reflex::ReferenceBuilder(type_2860);
  ::Reflex::Type type_5021 = ::Reflex::ReferenceBuilder(type_2769);
  ::Reflex::Type type_2247c = ::Reflex::ConstBuilder(type_2247);
  ::Reflex::Type type_18203 = ::Reflex::ReferenceBuilder(type_2247c);
  ::Reflex::Type type_3445c = ::Reflex::ConstBuilder(type_3445);
  ::Reflex::Type type_22612 = ::Reflex::ReferenceBuilder(type_3445c);
  ::Reflex::Type type_22613 = ::Reflex::ReferenceBuilder(type_3445);
  ::Reflex::Type type_2250c = ::Reflex::ConstBuilder(type_2250);
  ::Reflex::Type type_18211 = ::Reflex::ReferenceBuilder(type_2250c);
  ::Reflex::Type type_22451 = ::Reflex::PointerBuilder(type_3445c);
  ::Reflex::Type type_22452 = ::Reflex::PointerBuilder(type_3445);
  ::Reflex::Type type_3351c = ::Reflex::ConstBuilder(type_3351);
  ::Reflex::Type type_22453 = ::Reflex::PointerBuilder(type_3351c);
  ::Reflex::Type type_22456 = ::Reflex::PointerBuilder(type_2251c);
  ::Reflex::Type type_22457 = ::Reflex::PointerBuilder(type_2251);
  ::Reflex::Type type_3352c = ::Reflex::ConstBuilder(type_3352);
  ::Reflex::Type type_22458 = ::Reflex::PointerBuilder(type_3352c);
  ::Reflex::Type type_22584 = ::Reflex::PointerBuilder(type_14107);
  ::Reflex::Type type_3420c = ::Reflex::ConstBuilder(type_3420);
  ::Reflex::Type type_22585 = ::Reflex::ReferenceBuilder(type_3420c);
  ::Reflex::Type type_3357c = ::Reflex::ConstBuilder(type_3357);
  ::Reflex::Type type_22586 = ::Reflex::ReferenceBuilder(type_3357c);
  ::Reflex::Type type_3441c = ::Reflex::ConstBuilder(type_3441);
  ::Reflex::Type type_22587 = ::Reflex::ReferenceBuilder(type_3441c);
  ::Reflex::Type type_22588 = ::Reflex::ReferenceBuilder(type_3420);
  ::Reflex::Type type_7229 = ::Reflex::PointerBuilder(type_994c);
  ::Reflex::Type type_22729 = ::Reflex::ReferenceBuilder(type_3845);
  ::Reflex::Type type_25458 = ::Reflex::ReferenceBuilder(type_14107);
  ::Reflex::Type type_14107c = ::Reflex::ConstBuilder(type_14107);
  ::Reflex::Type type_25459 = ::Reflex::ReferenceBuilder(type_14107c);
  ::Reflex::Type type_11492 = ::Reflex::ReferenceBuilder(type_6414);
  ::Reflex::Type type_4837 = ::Reflex::ReferenceBuilder(type_1817);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __CaloRecHit
#undef __CaloRecHit
#endif
class __CaloRecHit {
  public:
  __CaloRecHit();
  ::DetId id_;
  float energy_;
  float time_;
  ::uint32_t flags_;
  ::uint32_t aux_;
};
#ifdef __reco__CaloCluster
#undef __reco__CaloCluster
#endif
class __reco__CaloCluster {
  public:
  __reco__CaloCluster();
  virtual ~__reco__CaloCluster() throw();
  double energy_;
  ::math::XYZPoint position_;
  ::reco::CaloID caloID_;
  ::std::vector<std::pair<DetId,float> > hitsAndFractions_;
  ::reco::CaloCluster::AlgoId algoID_;
  ::DetId seedId_;
  ::uint32_t flags_;
};
#ifdef __edm__Ptr_reco__CaloCluster_
#undef __edm__Ptr_reco__CaloCluster_
#endif
class __edm__Ptr_reco__CaloCluster_ {
  public:
  __edm__Ptr_reco__CaloCluster_();
  ::edm::RefCore core_;
  unsigned long key_;
};
#ifdef __std__vector_edm__Ptr_reco__CaloCluster_s_
#undef __std__vector_edm__Ptr_reco__CaloCluster_s_
#endif
class __std__vector_edm__Ptr_reco__CaloCluster_s_ : protected ::std::_Vector_base<edm::Ptr<reco::CaloCluster>,std::allocator<edm::Ptr<reco::CaloCluster> > > {
  public:
  __std__vector_edm__Ptr_reco__CaloCluster_s_();
};
#ifdef __std__vector_reco__CaloCluster_
#undef __std__vector_reco__CaloCluster_
#endif
class __std__vector_reco__CaloCluster_ : protected ::std::_Vector_base<reco::CaloCluster,std::allocator<reco::CaloCluster> > {
  public:
  __std__vector_reco__CaloCluster_();
};
#ifdef __edm__PtrVector_reco__CaloCluster_
#undef __edm__PtrVector_reco__CaloCluster_
#endif
class __edm__PtrVector_reco__CaloCluster_ : public ::edm::PtrVectorBase {
  public:
  __edm__PtrVector_reco__CaloCluster_();
  virtual ~__edm__PtrVector_reco__CaloCluster_() throw();
};
#ifdef __edm__Wrapper_edm__PtrVector_reco__CaloCluster_s_
#undef __edm__Wrapper_edm__PtrVector_reco__CaloCluster_s_
#endif
class __edm__Wrapper_edm__PtrVector_reco__CaloCluster_s_ {
  public:
  __edm__Wrapper_edm__PtrVector_reco__CaloCluster_s_();
  bool present;
  ::edm::PtrVector<reco::CaloCluster> obj;
};
#ifdef __edm__ValueMap_reco__CaloCluster_
#undef __edm__ValueMap_reco__CaloCluster_
#endif
class __edm__ValueMap_reco__CaloCluster_ {
  public:
  __edm__ValueMap_reco__CaloCluster_();
#ifdef __edm__ValueMap_reco__CaloCluster___IDComparator
#undef __edm__ValueMap_reco__CaloCluster___IDComparator
#endif
  struct __edm__ValueMap_reco__CaloCluster___IDComparator {
    public:
    __edm__ValueMap_reco__CaloCluster___IDComparator();
  };
  ::std::vector<reco::CaloCluster> values_;
  ::std::vector<std::pair<edm::ProductID,unsigned int> > ids_;
};
#ifdef __edm__Wrapper_edm__ValueMap_reco__CaloCluster_s_
#undef __edm__Wrapper_edm__ValueMap_reco__CaloCluster_s_
#endif
class __edm__Wrapper_edm__ValueMap_reco__CaloCluster_s_ {
  public:
  __edm__Wrapper_edm__ValueMap_reco__CaloCluster_s_();
  bool present;
  ::edm::ValueMap<reco::CaloCluster> obj;
};
#ifdef __edm__Wrapper_std__vector_reco__CaloCluster_s_
#undef __edm__Wrapper_std__vector_reco__CaloCluster_s_
#endif
class __edm__Wrapper_std__vector_reco__CaloCluster_s_ {
  public:
  __edm__Wrapper_std__vector_reco__CaloCluster_s_();
  bool present;
  ::std::vector<reco::CaloCluster> obj;
};
#ifdef __edm__RefToBase_CaloRecHit_
#undef __edm__RefToBase_CaloRecHit_
#endif
class __edm__RefToBase_CaloRecHit_ {
  public:
  __edm__RefToBase_CaloRecHit_();
  void* holder_;
};
#ifdef __reco__CaloID
#undef __reco__CaloID
#endif
class __reco__CaloID {
  public:
  __reco__CaloID();
  virtual ~__reco__CaloID() throw();
  unsigned int detectors_;
};
#ifdef __edm__reftobase__BaseHolder_CaloRecHit_
#undef __edm__reftobase__BaseHolder_CaloRecHit_
#endif
class __edm__reftobase__BaseHolder_CaloRecHit_ {
  public:
  __edm__reftobase__BaseHolder_CaloRecHit_();
  virtual ~__edm__reftobase__BaseHolder_CaloRecHit_() throw();
};
}


#endif // __CINT__
namespace {
//------Stub functions for class CaloRecHit -------------------------------
static void destructor_3773(void*, void * o, const std::vector<void*>&, void *) {
(((::CaloRecHit*)o)->::CaloRecHit::~CaloRecHit)();
}
static  void operator_3774( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CaloRecHit*)o)->operator=)(*(const ::CaloRecHit*)arg[0]);
  else   (((::CaloRecHit*)o)->operator=)(*(const ::CaloRecHit*)arg[0]);
}

static void constructor_3775( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CaloRecHit(*(const ::CaloRecHit*)arg[0]);
  else ::new(mem) ::CaloRecHit(*(const ::CaloRecHit*)arg[0]);
}

static void constructor_3776( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CaloRecHit();
  else ::new(mem) ::CaloRecHit();
}

static void constructor_3777( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::CaloRecHit(*(const ::DetId*)arg[0],
      *(float*)arg[1],
      *(float*)arg[2]);
  else ::new(mem) ::CaloRecHit(*(const ::DetId*)arg[0],
      *(float*)arg[1],
      *(float*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::CaloRecHit(*(const ::DetId*)arg[0],
      *(float*)arg[1],
      *(float*)arg[2],
      *(::uint32_t*)arg[3]);
  else ::new(mem) ::CaloRecHit(*(const ::DetId*)arg[0],
      *(float*)arg[1],
      *(float*)arg[2],
      *(::uint32_t*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::CaloRecHit(*(const ::DetId*)arg[0],
      *(float*)arg[1],
      *(float*)arg[2],
      *(::uint32_t*)arg[3],
      *(::uint32_t*)arg[4]);
  else ::new(mem) ::CaloRecHit(*(const ::DetId*)arg[0],
      *(float*)arg[1],
      *(float*)arg[2],
      *(::uint32_t*)arg[3],
      *(::uint32_t*)arg[4]);
  }
}

static  void method_3778( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::CaloRecHit*)o)->energy)());
  else   (((const ::CaloRecHit*)o)->energy)();
}

static  void method_3779( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CaloRecHit*)o)->setEnergy)(*(float*)arg[0]);
}

static  void method_3780( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::CaloRecHit*)o)->time)());
  else   (((const ::CaloRecHit*)o)->time)();
}

static  void method_3781( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::CaloRecHit*)o)->detid)();
  else   (((const ::CaloRecHit*)o)->detid)();
}

static  void method_3782( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::CaloRecHit*)o)->flags)());
  else   (((const ::CaloRecHit*)o)->flags)();
}

static  void method_3783( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CaloRecHit*)o)->setFlags)(*(::uint32_t*)arg[0]);
}

static  void method_3784( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    (((::CaloRecHit*)o)->setFlagField)(*(::uint32_t*)arg[0],
      *(int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    (((::CaloRecHit*)o)->setFlagField)(*(::uint32_t*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2]);
  }
}

static  void method_3785( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (uint32_t)((((const ::CaloRecHit*)o)->flagField)(*(int*)arg[0]));
    else     (((const ::CaloRecHit*)o)->flagField)(*(int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (uint32_t)((((const ::CaloRecHit*)o)->flagField)(*(int*)arg[0],
      *(int*)arg[1]));
    else     (((const ::CaloRecHit*)o)->flagField)(*(int*)arg[0],
      *(int*)arg[1]);
  }
}

static  void method_3786( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::CaloRecHit*)o)->setAux)(*(::uint32_t*)arg[0]);
}

static  void method_3787( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::CaloRecHit*)o)->aux)());
  else   (((const ::CaloRecHit*)o)->aux)();
}

static void method_newdel_994( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::CaloRecHit >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::CaloRecHit >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::CaloRecHit >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::CaloRecHit >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::CaloRecHit >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class CaloRecHit -------------------------------
void __CaloRecHit_db_datamem(Reflex::Class*);
void __CaloRecHit_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __CaloRecHit_datamem_bld(&__CaloRecHit_db_datamem);
Reflex::GenreflexMemberBuilder __CaloRecHit_funcmem_bld(&__CaloRecHit_db_funcmem);
void __CaloRecHit_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("CaloRecHit"), typeid(::CaloRecHit), sizeof(::CaloRecHit), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~CaloRecHit"), destructor_3773, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7231, type_3750), Reflex::Literal("operator="), operator_3774, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3750), Reflex::Literal("CaloRecHit"), constructor_3775, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("CaloRecHit"), constructor_3776, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7679, type_646, type_646, type_1083, type_1083), Reflex::Literal("CaloRecHit"), constructor_3777, 0, "id;energy;time;flags=0;aux=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_994, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__CaloRecHit_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__CaloRecHit_funcmem_bld);
}

//------Delayed data member builder for class CaloRecHit -------------------
void __CaloRecHit_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_780, Reflex::Literal("id_"), OffsetOf(__shadow__::__CaloRecHit, id_), ::Reflex::PRIVATE)
  .AddDataMember(type_646, Reflex::Literal("energy_"), OffsetOf(__shadow__::__CaloRecHit, energy_), ::Reflex::PRIVATE)
  .AddDataMember(type_646, Reflex::Literal("time_"), OffsetOf(__shadow__::__CaloRecHit, time_), ::Reflex::PRIVATE)
  .AddDataMember(type_1083, Reflex::Literal("flags_"), OffsetOf(__shadow__::__CaloRecHit, flags_), ::Reflex::PRIVATE)
  .AddDataMember(type_1083, Reflex::Literal("aux_"), OffsetOf(__shadow__::__CaloRecHit, aux_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class CaloRecHit -------------------
void __CaloRecHit_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_646), Reflex::Literal("energy"), method_3778, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699, type_646), Reflex::Literal("setEnergy"), method_3779, 0, "energy", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_646), Reflex::Literal("time"), method_3780, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7679), Reflex::Literal("detid"), method_3781, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1083), Reflex::Literal("flags"), method_3782, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699, type_1083), Reflex::Literal("setFlags"), method_3783, 0, "flags", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699, type_1083, type_61, type_61), Reflex::Literal("setFlagField"), method_3784, 0, "value;base;width=1", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1083, type_61, type_61), Reflex::Literal("flagField"), method_3785, 0, "base;width=1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699, type_1083), Reflex::Literal("setAux"), method_3786, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1083), Reflex::Literal("aux"), method_3787, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class CaloCluster -------------------------------
static  void operator_14922( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::CaloCluster*)o)->operator=)(*(const ::reco::CaloCluster*)arg[0]);
  else   (((::reco::CaloCluster*)o)->operator=)(*(const ::reco::CaloCluster*)arg[0]);
}

static void constructor_14923( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::CaloCluster(*(const ::reco::CaloCluster*)arg[0]);
  else ::new(mem) ::reco::CaloCluster(*(const ::reco::CaloCluster*)arg[0]);
}

static void constructor_14924( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::CaloCluster();
  else ::new(mem) ::reco::CaloCluster();
}

static void constructor_14925( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::CaloCluster(*(::reco::CaloCluster::AlgoId*)arg[0]);
  else ::new(mem) ::reco::CaloCluster(*(::reco::CaloCluster::AlgoId*)arg[0]);
}

static void constructor_14926( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::CaloCluster(*(double*)arg[0],
      *(const ::math::XYZPoint*)arg[1],
      *(const ::reco::CaloID*)arg[2]);
  else ::new(mem) ::reco::CaloCluster(*(double*)arg[0],
      *(const ::math::XYZPoint*)arg[1],
      *(const ::reco::CaloID*)arg[2]);
}

static  void method_14927( void*, void* o, const std::vector<void*>&, void*)
{
  (((::reco::CaloCluster*)o)->reset)();
}

static void constructor_14928( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::CaloCluster(*(double*)arg[0],
      *(const ::math::XYZPoint*)arg[1]);
  else ::new(mem) ::reco::CaloCluster(*(double*)arg[0],
      *(const ::math::XYZPoint*)arg[1]);
}

static void constructor_14929( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 4 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::reco::CaloCluster(*(double*)arg[0],
      *(const ::math::XYZPoint*)arg[1],
      *(const ::reco::CaloID*)arg[2],
      *(const ::reco::CaloCluster::AlgoId*)arg[3]);
  else ::new(mem) ::reco::CaloCluster(*(double*)arg[0],
      *(const ::math::XYZPoint*)arg[1],
      *(const ::reco::CaloID*)arg[2],
      *(const ::reco::CaloCluster::AlgoId*)arg[3]);
  }
  else if ( arg.size() == 5 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::reco::CaloCluster(*(double*)arg[0],
      *(const ::math::XYZPoint*)arg[1],
      *(const ::reco::CaloID*)arg[2],
      *(const ::reco::CaloCluster::AlgoId*)arg[3],
      *(::uint32_t*)arg[4]);
  else ::new(mem) ::reco::CaloCluster(*(double*)arg[0],
      *(const ::math::XYZPoint*)arg[1],
      *(const ::reco::CaloID*)arg[2],
      *(const ::reco::CaloCluster::AlgoId*)arg[3],
      *(::uint32_t*)arg[4]);
  }
}

static void constructor_14930( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 5 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::reco::CaloCluster(*(double*)arg[0],
      *(const ::math::XYZPoint*)arg[1],
      *(const ::reco::CaloID*)arg[2],
      *(const ::std::vector<std::pair<DetId,float> >*)arg[3],
      *(const ::reco::CaloCluster::AlgoId*)arg[4]);
  else ::new(mem) ::reco::CaloCluster(*(double*)arg[0],
      *(const ::math::XYZPoint*)arg[1],
      *(const ::reco::CaloID*)arg[2],
      *(const ::std::vector<std::pair<DetId,float> >*)arg[3],
      *(const ::reco::CaloCluster::AlgoId*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::reco::CaloCluster(*(double*)arg[0],
      *(const ::math::XYZPoint*)arg[1],
      *(const ::reco::CaloID*)arg[2],
      *(const ::std::vector<std::pair<DetId,float> >*)arg[3],
      *(const ::reco::CaloCluster::AlgoId*)arg[4],
      *(const ::DetId*)arg[5]);
  else ::new(mem) ::reco::CaloCluster(*(double*)arg[0],
      *(const ::math::XYZPoint*)arg[1],
      *(const ::reco::CaloID*)arg[2],
      *(const ::std::vector<std::pair<DetId,float> >*)arg[3],
      *(const ::reco::CaloCluster::AlgoId*)arg[4],
      *(const ::DetId*)arg[5]);
  }
  else if ( arg.size() == 7 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::reco::CaloCluster(*(double*)arg[0],
      *(const ::math::XYZPoint*)arg[1],
      *(const ::reco::CaloID*)arg[2],
      *(const ::std::vector<std::pair<DetId,float> >*)arg[3],
      *(const ::reco::CaloCluster::AlgoId*)arg[4],
      *(const ::DetId*)arg[5],
      *(::uint32_t*)arg[6]);
  else ::new(mem) ::reco::CaloCluster(*(double*)arg[0],
      *(const ::math::XYZPoint*)arg[1],
      *(const ::reco::CaloID*)arg[2],
      *(const ::std::vector<std::pair<DetId,float> >*)arg[3],
      *(const ::reco::CaloCluster::AlgoId*)arg[4],
      *(const ::DetId*)arg[5],
      *(::uint32_t*)arg[6]);
  }
}

static void constructor_14931( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 5 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::reco::CaloCluster(*(double*)arg[0],
      *(const ::math::XYZPoint*)arg[1],
      *(float*)arg[2],
      *(const ::std::vector<DetId>*)arg[3],
      *(const ::reco::CaloCluster::AlgoId*)arg[4]);
  else ::new(mem) ::reco::CaloCluster(*(double*)arg[0],
      *(const ::math::XYZPoint*)arg[1],
      *(float*)arg[2],
      *(const ::std::vector<DetId>*)arg[3],
      *(const ::reco::CaloCluster::AlgoId*)arg[4]);
  }
  else if ( arg.size() == 6 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::reco::CaloCluster(*(double*)arg[0],
      *(const ::math::XYZPoint*)arg[1],
      *(float*)arg[2],
      *(const ::std::vector<DetId>*)arg[3],
      *(const ::reco::CaloCluster::AlgoId*)arg[4],
      *(::uint32_t*)arg[5]);
  else ::new(mem) ::reco::CaloCluster(*(double*)arg[0],
      *(const ::math::XYZPoint*)arg[1],
      *(float*)arg[2],
      *(const ::std::vector<DetId>*)arg[3],
      *(const ::reco::CaloCluster::AlgoId*)arg[4],
      *(::uint32_t*)arg[5]);
  }
}

static void destructor_14932(void*, void * o, const std::vector<void*>&, void *) {
(((::reco::CaloCluster*)o)->::reco::CaloCluster::~CaloCluster)();
}
static  void method_14933( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::CaloCluster*)o)->setEnergy)(*(double*)arg[0]);
}

static  void method_14934( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::CaloCluster*)o)->setPosition)(*(const ::math::XYZPoint*)arg[0]);
}

static  void method_14935( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::CaloCluster*)o)->setCaloId)(*(const ::reco::CaloID*)arg[0]);
}

static  void method_14936( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::CaloCluster*)o)->setAlgoId)(*(const ::reco::CaloCluster::AlgoId*)arg[0]);
}

static  void method_14937( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::CaloCluster*)o)->setSeed)(*(const ::DetId*)arg[0]);
}

static  void method_14938( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::CaloCluster*)o)->energy)());
  else   (((const ::reco::CaloCluster*)o)->energy)();
}

static  void method_14939( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::reco::CaloCluster*)o)->position)();
  else   (((const ::reco::CaloCluster*)o)->position)();
}

static  void operator_14940( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::reco::CaloCluster*)o)->operator>=)(*(const ::reco::CaloCluster*)arg[0]));
  else   (((const ::reco::CaloCluster*)o)->operator>=)(*(const ::reco::CaloCluster*)arg[0]);
}

static  void operator_14941( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::reco::CaloCluster*)o)->operator>)(*(const ::reco::CaloCluster*)arg[0]));
  else   (((const ::reco::CaloCluster*)o)->operator>)(*(const ::reco::CaloCluster*)arg[0]);
}

static  void operator_14942( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::reco::CaloCluster*)o)->operator<=)(*(const ::reco::CaloCluster*)arg[0]));
  else   (((const ::reco::CaloCluster*)o)->operator<=)(*(const ::reco::CaloCluster*)arg[0]);
}

static  void operator_14943( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::reco::CaloCluster*)o)->operator<)(*(const ::reco::CaloCluster*)arg[0]));
  else   (((const ::reco::CaloCluster*)o)->operator<)(*(const ::reco::CaloCluster*)arg[0]);
}

static  void operator_14944( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::reco::CaloCluster*)o)->operator==)(*(const ::reco::CaloCluster*)arg[0]));
  else   (((const ::reco::CaloCluster*)o)->operator==)(*(const ::reco::CaloCluster*)arg[0]);
}

static  void method_14945( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::CaloCluster*)o)->x)());
  else   (((const ::reco::CaloCluster*)o)->x)();
}

static  void method_14946( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::CaloCluster*)o)->y)());
  else   (((const ::reco::CaloCluster*)o)->y)();
}

static  void method_14947( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::CaloCluster*)o)->z)());
  else   (((const ::reco::CaloCluster*)o)->z)();
}

static  void method_14948( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::CaloCluster*)o)->eta)());
  else   (((const ::reco::CaloCluster*)o)->eta)();
}

static  void method_14949( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::CaloCluster*)o)->phi)());
  else   (((const ::reco::CaloCluster*)o)->phi)();
}

static  void method_14950( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::reco::CaloCluster*)o)->size)());
  else   (((const ::reco::CaloCluster*)o)->size)();
}

static  void method_14951( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::reco::CaloCluster*)o)->algo)());
  else   (((const ::reco::CaloCluster*)o)->algo)();
}

static  void method_14952( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::reco::CaloCluster*)o)->algoID)());
  else   (((const ::reco::CaloCluster*)o)->algoID)();
}

static  void method_14953( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (uint32_t)((((const ::reco::CaloCluster*)o)->flags)());
  else   (((const ::reco::CaloCluster*)o)->flags)();
}

static  void method_14954( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::CaloCluster*)o)->setFlags)(*(::uint32_t*)arg[0]);
}

static  void method_14955( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::reco::CaloCluster*)o)->isInClean)());
  else   (((const ::reco::CaloCluster*)o)->isInClean)();
}

static  void method_14956( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::reco::CaloCluster*)o)->isInUnclean)());
  else   (((const ::reco::CaloCluster*)o)->isInUnclean)();
}

static  void method_14957( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::reco::CaloCluster*)o)->caloID)();
  else   (((const ::reco::CaloCluster*)o)->caloID)();
}

static  void method_14958( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::CaloCluster*)o)->addHitAndFraction)(*(::DetId*)arg[0],
    *(float*)arg[1]);
}

static  void method_14959( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::reco::CaloCluster*)o)->hitsAndFractions)();
  else   (((const ::reco::CaloCluster*)o)->hitsAndFractions)();
}

static  void method_14960( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::reco::CaloCluster*)o)->printHitAndFraction)(*(unsigned int*)arg[0]));
  else   (((const ::reco::CaloCluster*)o)->printHitAndFraction)(*(unsigned int*)arg[0]);
}

static  void method_14961( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (DetId)((((const ::reco::CaloCluster*)o)->seed)());
  else   (((const ::reco::CaloCluster*)o)->seed)();
}

static void method_newdel_3844( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::reco::CaloCluster >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::reco::CaloCluster >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::reco::CaloCluster >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::reco::CaloCluster >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::reco::CaloCluster >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class CaloCluster -------------------------------
void __reco__CaloCluster_db_datamem(Reflex::Class*);
void __reco__CaloCluster_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __reco__CaloCluster_datamem_bld(&__reco__CaloCluster_db_datamem);
Reflex::GenreflexMemberBuilder __reco__CaloCluster_funcmem_bld(&__reco__CaloCluster_db_funcmem);
void __reco__CaloCluster_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("reco::CaloCluster"), typeid(::reco::CaloCluster), sizeof(::reco::CaloCluster), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddEnum(Reflex::Literal("reco::CaloCluster::AlgoId"), Reflex::Literal("island=0;hybrid=1;fixedMatrix=2;dynamicHybrid=3;multi5x5=4;particleFlow=5;undefined=1000"), &typeid(reco::CaloCluster::AlgoId), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddEnum(Reflex::Literal("reco::CaloCluster::SCFlags"), Reflex::Literal("cleanOnly=0;common=100;uncleanOnly=200"), &typeid(reco::CaloCluster::SCFlags), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddTypedef(type_14919, Reflex::Literal("reco::CaloCluster::AlgoID"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7612, type_7614), Reflex::Literal("operator="), operator_14922, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7614), Reflex::Literal("CaloCluster"), constructor_14923, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("CaloCluster"), constructor_14924, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14919), Reflex::Literal("CaloCluster"), constructor_14925, 0, "algoID", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1669, type_22726, type_14909), Reflex::Literal("CaloCluster"), constructor_14926, 0, "energy;position;caloID", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1669, type_22726), Reflex::Literal("CaloCluster"), constructor_14928, 0, "energy;position", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1669, type_22726, type_14909, type_22727, type_1083), Reflex::Literal("CaloCluster"), constructor_14929, 0, "energy;position;caloID;algoID;flags=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1669, type_22726, type_14909, type_18206, type_14919c, type_780c, type_1083), Reflex::Literal("CaloCluster"), constructor_14930, 0, "energy;position;caloID;usedHitsAndFractions;algoId;seedId=DetId(0u);flags=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1669, type_22726, type_646, type_18217, type_14919c, type_1083), Reflex::Literal("CaloCluster"), constructor_14931, 0, "energy;position;chi2;usedHits;algoId;flags=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~CaloCluster"), destructor_14932, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3844, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__reco__CaloCluster_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__reco__CaloCluster_funcmem_bld);
}

//------Delayed data member builder for class CaloCluster -------------------
void __reco__CaloCluster_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1669, Reflex::Literal("energy_"), OffsetOf(__shadow__::__reco__CaloCluster, energy_), ::Reflex::PROTECTED)
  .AddDataMember(type_3795, Reflex::Literal("position_"), OffsetOf(__shadow__::__reco__CaloCluster, position_), ::Reflex::PROTECTED)
  .AddDataMember(type_3845, Reflex::Literal("caloID_"), OffsetOf(__shadow__::__reco__CaloCluster, caloID_), ::Reflex::PROTECTED)
  .AddDataMember(type_2248, Reflex::Literal("hitsAndFractions_"), OffsetOf(__shadow__::__reco__CaloCluster, hitsAndFractions_), ::Reflex::PROTECTED)
  .AddDataMember(type_14919, Reflex::Literal("algoID_"), OffsetOf(__shadow__::__reco__CaloCluster, algoID_), ::Reflex::PROTECTED)
  .AddDataMember(type_780, Reflex::Literal("seedId_"), OffsetOf(__shadow__::__reco__CaloCluster, seedId_), ::Reflex::PROTECTED)
  .AddDataMember(type_1083, Reflex::Literal("flags_"), OffsetOf(__shadow__::__reco__CaloCluster, flags_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class CaloCluster -------------------
void __reco__CaloCluster_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699), Reflex::Literal("reset"), method_14927, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699, type_1669), Reflex::Literal("setEnergy"), method_14933, 0, "energy", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699, type_22726), Reflex::Literal("setPosition"), method_14934, 0, "p", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699, type_14909), Reflex::Literal("setCaloId"), method_14935, 0, "id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699, type_22727), Reflex::Literal("setAlgoId"), method_14936, 0, "id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699, type_7679), Reflex::Literal("setSeed"), method_14937, 0, "id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1669), Reflex::Literal("energy"), method_14938, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22726), Reflex::Literal("position"), method_14939, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2734, type_7614), Reflex::Literal("operator>="), operator_14940, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2734, type_7614), Reflex::Literal("operator>"), operator_14941, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2734, type_7614), Reflex::Literal("operator<="), operator_14942, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2734, type_7614), Reflex::Literal("operator<"), operator_14943, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2734, type_7614), Reflex::Literal("operator=="), operator_14944, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1669), Reflex::Literal("x"), method_14945, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1669), Reflex::Literal("y"), method_14946, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1669), Reflex::Literal("z"), method_14947, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1669), Reflex::Literal("eta"), method_14948, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1669), Reflex::Literal("phi"), method_14949, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1501), Reflex::Literal("size"), method_14950, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14919), Reflex::Literal("algo"), method_14951, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14919), Reflex::Literal("algoID"), method_14952, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1083), Reflex::Literal("flags"), method_14953, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699, type_1083), Reflex::Literal("setFlags"), method_14954, 0, "flags", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2734), Reflex::Literal("isInClean"), method_14955, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2734), Reflex::Literal("isInUnclean"), method_14956, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14909), Reflex::Literal("caloID"), method_14957, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699, type_780, type_646), Reflex::Literal("addHitAndFraction"), method_14958, 0, "id;fraction", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18206), Reflex::Literal("hitsAndFractions"), method_14959, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1818, type_234), Reflex::Literal("printHitAndFraction"), method_14960, 0, "i", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_780), Reflex::Literal("seed"), method_14961, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Ptr<reco::CaloCluster> -------------------------------
static  void operator_14404( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ptr<reco::CaloCluster>*)o)->operator=)(*(const ::edm::Ptr<reco::CaloCluster>*)arg[0]);
  else   (((::edm::Ptr<reco::CaloCluster>*)o)->operator=)(*(const ::edm::Ptr<reco::CaloCluster>*)arg[0]);
}

static void constructor_14405( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::CaloCluster>(*(const ::edm::Ptr<reco::CaloCluster>*)arg[0]);
  else ::new(mem) ::edm::Ptr<reco::CaloCluster>(*(const ::edm::Ptr<reco::CaloCluster>*)arg[0]);
}

static void constructor_14406( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::CaloCluster>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ptr<reco::CaloCluster>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_14407( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::CaloCluster>(*(const ::edm::ProductID*)arg[0],
      (const ::reco::CaloCluster*)arg[1],
      *(unsigned long*)arg[2]);
  else ::new(mem) ::edm::Ptr<reco::CaloCluster>(*(const ::edm::ProductID*)arg[0],
      (const ::reco::CaloCluster*)arg[1],
      *(unsigned long*)arg[2]);
}

static void constructor_14408( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::CaloCluster>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ptr<reco::CaloCluster>(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_14409( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::CaloCluster>();
  else ::new(mem) ::edm::Ptr<reco::CaloCluster>();
}

static void destructor_14410(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ptr<reco::CaloCluster>*)o)->::edm::Ptr<reco::CaloCluster>::~Ptr)();
}
static  void operator_14411( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<reco::CaloCluster>*)o)->operator*)();
  else   (((const ::edm::Ptr<reco::CaloCluster>*)o)->operator*)();
}

static  void operator_14412( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::CaloCluster>*)o)->operator->)());
  else   (((const ::edm::Ptr<reco::CaloCluster>*)o)->operator->)();
}

static  void method_14413( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::CaloCluster>*)o)->get)());
  else   (((const ::edm::Ptr<reco::CaloCluster>*)o)->get)();
}

static  void method_14414( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::CaloCluster>*)o)->isNull)());
  else   (((const ::edm::Ptr<reco::CaloCluster>*)o)->isNull)();
}

static  void method_14415( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::CaloCluster>*)o)->isNonnull)());
  else   (((const ::edm::Ptr<reco::CaloCluster>*)o)->isNonnull)();
}

static  void operator_14416( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::CaloCluster>*)o)->operator!)());
  else   (((const ::edm::Ptr<reco::CaloCluster>*)o)->operator!)();
}

static  void method_14417( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::CaloCluster>*)o)->isAvailable)());
  else   (((const ::edm::Ptr<reco::CaloCluster>*)o)->isAvailable)();
}

static  void method_14418( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::CaloCluster>*)o)->isTransient)());
  else   (((const ::edm::Ptr<reco::CaloCluster>*)o)->isTransient)();
}

static  void method_14419( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ptr<reco::CaloCluster>*)o)->id)());
  else   (((const ::edm::Ptr<reco::CaloCluster>*)o)->id)();
}

static  void method_14420( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::CaloCluster>*)o)->productGetter)());
  else   (((const ::edm::Ptr<reco::CaloCluster>*)o)->productGetter)();
}

static  void method_14421( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::edm::Ptr<reco::CaloCluster>*)o)->key)());
  else   (((const ::edm::Ptr<reco::CaloCluster>*)o)->key)();
}

static  void method_14422( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::CaloCluster>*)o)->hasProductCache)());
  else   (((const ::edm::Ptr<reco::CaloCluster>*)o)->hasProductCache)();
}

static  void method_14423( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<reco::CaloCluster>*)o)->refCore)();
  else   (((const ::edm::Ptr<reco::CaloCluster>*)o)->refCore)();
}

static  void method_14424( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::CaloCluster>*)o)->product)());
  else   (((const ::edm::Ptr<reco::CaloCluster>*)o)->product)();
}

static  void method_14425( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ptr<reco::CaloCluster>*)o)->Class_Version)());
  else   (((::edm::Ptr<reco::CaloCluster>*)o)->Class_Version)();
}

static void method_newdel_3424( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::CaloCluster> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::CaloCluster> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::CaloCluster> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::CaloCluster> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::CaloCluster> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ptr<reco::CaloCluster> -------------------------------
void __edm__Ptr_reco__CaloCluster__db_datamem(Reflex::Class*);
void __edm__Ptr_reco__CaloCluster__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ptr_reco__CaloCluster__datamem_bld(&__edm__Ptr_reco__CaloCluster__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ptr_reco__CaloCluster__funcmem_bld(&__edm__Ptr_reco__CaloCluster__db_funcmem);
void __edm__Ptr_reco__CaloCluster__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ptr<reco::CaloCluster>"), typeid(::edm::Ptr<reco::CaloCluster>), sizeof(::edm::Ptr<reco::CaloCluster>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ptr<reco::CaloCluster>::Class_Version())
  .AddTypedef(type_227, Reflex::Literal("edm::Ptr<reco::CaloCluster>::key_type"))
  .AddTypedef(type_3844, Reflex::Literal("edm::Ptr<reco::CaloCluster>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7484, type_7486), Reflex::Literal("operator="), operator_14404, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7486), Reflex::Literal("Ptr"), constructor_14405, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11208, type_227, type_14436), Reflex::Literal("Ptr"), constructor_14406, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11208, type_7610, type_227), Reflex::Literal("Ptr"), constructor_14407, 0, "productID;item;item_key", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11208), Reflex::Literal("Ptr"), constructor_14408, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ptr"), constructor_14409, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ptr"), destructor_14410, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3424, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ptr_reco__CaloCluster__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ptr_reco__CaloCluster__funcmem_bld);
}

//------Delayed data member builder for class Ptr<reco::CaloCluster> -------------------
void __edm__Ptr_reco__CaloCluster__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3410, Reflex::Literal("core_"), OffsetOf(__shadow__::__edm__Ptr_reco__CaloCluster_, core_), ::Reflex::PRIVATE)
  .AddDataMember(type_227, Reflex::Literal("key_"), OffsetOf(__shadow__::__edm__Ptr_reco__CaloCluster_, key_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Ptr<reco::CaloCluster> -------------------
void __edm__Ptr_reco__CaloCluster__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7614), Reflex::Literal("operator*"), operator_14411, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7610), Reflex::Literal("operator->"), operator_14412, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7610), Reflex::Literal("get"), method_14413, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2734), Reflex::Literal("isNull"), method_14414, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2734), Reflex::Literal("isNonnull"), method_14415, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2734), Reflex::Literal("operator!"), operator_14416, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2734), Reflex::Literal("isAvailable"), method_14417, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2734), Reflex::Literal("isTransient"), method_14418, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3408), Reflex::Literal("id"), method_14419, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14436), Reflex::Literal("productGetter"), method_14420, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_227), Reflex::Literal("key"), method_14421, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2734), Reflex::Literal("hasProductCache"), method_14422, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14151), Reflex::Literal("refCore"), method_14423, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2769), Reflex::Literal("product"), method_14424, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_973), Reflex::Literal("Class_Version"), method_14425, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class vector<edm::Ptr<reco::CaloCluster>,std::allocator<edm::Ptr<reco::CaloCluster> > > -------------------------------
static void constructor_7495( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ptr<reco::CaloCluster> >();
  else ::new(mem) ::std::vector<edm::Ptr<reco::CaloCluster> >();
}

static void constructor_7496( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ptr<reco::CaloCluster> >(*(const ::std::allocator<edm::Ptr<reco::CaloCluster> >*)arg[0]);
  else ::new(mem) ::std::vector<edm::Ptr<reco::CaloCluster> >(*(const ::std::allocator<edm::Ptr<reco::CaloCluster> >*)arg[0]);
}

static void constructor_7497( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ptr<reco::CaloCluster> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<edm::Ptr<reco::CaloCluster> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ptr<reco::CaloCluster> >(*(::std::size_t*)arg[0],
      *(const ::edm::Ptr<reco::CaloCluster>*)arg[1]);
  else ::new(mem) ::std::vector<edm::Ptr<reco::CaloCluster> >(*(::std::size_t*)arg[0],
      *(const ::edm::Ptr<reco::CaloCluster>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ptr<reco::CaloCluster> >(*(::std::size_t*)arg[0],
      *(const ::edm::Ptr<reco::CaloCluster>*)arg[1],
      *(const ::std::allocator<edm::Ptr<reco::CaloCluster> >*)arg[2]);
  else ::new(mem) ::std::vector<edm::Ptr<reco::CaloCluster> >(*(::std::size_t*)arg[0],
      *(const ::edm::Ptr<reco::CaloCluster>*)arg[1],
      *(const ::std::allocator<edm::Ptr<reco::CaloCluster> >*)arg[2]);
  }
}

static void constructor_7498( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ptr<reco::CaloCluster> >(*(const ::std::vector<edm::Ptr<reco::CaloCluster> >*)arg[0]);
  else ::new(mem) ::std::vector<edm::Ptr<reco::CaloCluster> >(*(const ::std::vector<edm::Ptr<reco::CaloCluster> >*)arg[0]);
}

static void destructor_7499(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->::std::vector<edm::Ptr<reco::CaloCluster> >::~vector)();
}
static  void operator_7500( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->operator=)(*(const ::std::vector<edm::Ptr<reco::CaloCluster> >*)arg[0]);
  else   (((::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->operator=)(*(const ::std::vector<edm::Ptr<reco::CaloCluster> >*)arg[0]);
}

static  void method_7501( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::edm::Ptr<reco::CaloCluster>*)arg[1]);
}

static  void method_7502( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ptr<reco::CaloCluster>*,std::vector<edm::Ptr<reco::CaloCluster> > >)((((::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->begin)());
  else   (((::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->begin)();
}

static  void method_7503( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::Ptr<reco::CaloCluster>*,std::vector<edm::Ptr<reco::CaloCluster> > >)((((const ::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->begin)());
  else   (((const ::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->begin)();
}

static  void method_7504( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ptr<reco::CaloCluster>*,std::vector<edm::Ptr<reco::CaloCluster> > >)((((::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->end)());
  else   (((::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->end)();
}

static  void method_7505( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::Ptr<reco::CaloCluster>*,std::vector<edm::Ptr<reco::CaloCluster> > >)((((const ::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->end)());
  else   (((const ::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->end)();
}

static  void method_7510( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->size)());
  else   (((const ::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->size)();
}

static  void method_7511( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->max_size)());
  else   (((const ::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->max_size)();
}

static  void method_7512( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::edm::Ptr<reco::CaloCluster>*)arg[1]);
  }
}

static  void method_7513( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->capacity)());
  else   (((const ::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->capacity)();
}

static  void method_7514( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->empty)());
  else   (((const ::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->empty)();
}

static  void method_7515( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_7516( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_7517( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_7519( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_7520( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_7521( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->front)();
  else   (((::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->front)();
}

static  void method_7522( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->front)();
  else   (((const ::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->front)();
}

static  void method_7523( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->back)();
  else   (((::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->back)();
}

static  void method_7524( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->back)();
  else   (((const ::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->back)();
}

static  void method_7525( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->data)());
  else   (((::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->data)();
}

static  void method_7526( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->data)());
  else   (((const ::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->data)();
}

static  void method_7527( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->push_back)(*(const ::edm::Ptr<reco::CaloCluster>*)arg[0]);
}

static  void method_7528( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->pop_back)();
}

static  void method_7529( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ptr<reco::CaloCluster>*,std::vector<edm::Ptr<reco::CaloCluster> > >)((((::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::Ptr<reco::CaloCluster>*,std::vector<edm::Ptr<reco::CaloCluster> > >*)arg[0],
    *(const ::edm::Ptr<reco::CaloCluster>*)arg[1]));
  else   (((::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::Ptr<reco::CaloCluster>*,std::vector<edm::Ptr<reco::CaloCluster> > >*)arg[0],
    *(const ::edm::Ptr<reco::CaloCluster>*)arg[1]);
}

static  void method_7530( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::Ptr<reco::CaloCluster>*,std::vector<edm::Ptr<reco::CaloCluster> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::edm::Ptr<reco::CaloCluster>*)arg[2]);
}

static  void method_7531( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ptr<reco::CaloCluster>*,std::vector<edm::Ptr<reco::CaloCluster> > >)((((::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::Ptr<reco::CaloCluster>*,std::vector<edm::Ptr<reco::CaloCluster> > >*)arg[0]));
  else   (((::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::Ptr<reco::CaloCluster>*,std::vector<edm::Ptr<reco::CaloCluster> > >*)arg[0]);
}

static  void method_7532( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ptr<reco::CaloCluster>*,std::vector<edm::Ptr<reco::CaloCluster> > >)((((::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::Ptr<reco::CaloCluster>*,std::vector<edm::Ptr<reco::CaloCluster> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<edm::Ptr<reco::CaloCluster>*,std::vector<edm::Ptr<reco::CaloCluster> > >*)arg[1]));
  else   (((::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::Ptr<reco::CaloCluster>*,std::vector<edm::Ptr<reco::CaloCluster> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<edm::Ptr<reco::CaloCluster>*,std::vector<edm::Ptr<reco::CaloCluster> > >*)arg[1]);
}

static  void method_7533( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->swap)(*(::std::vector<edm::Ptr<reco::CaloCluster> >*)arg[0]);
}

static  void method_7534( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<edm::Ptr<reco::CaloCluster> >*)o)->clear)();
}

static void method_newdel_2249( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ptr<reco::CaloCluster> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ptr<reco::CaloCluster> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ptr<reco::CaloCluster> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ptr<reco::CaloCluster> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ptr<reco::CaloCluster> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x4( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<edm::Ptr<reco::CaloCluster>,std::allocator<edm::Ptr<reco::CaloCluster> > >")), ::Reflex::BaseOffset< ::std::vector<edm::Ptr<reco::CaloCluster> >,::std::_Vector_base<edm::Ptr<reco::CaloCluster>,std::allocator<edm::Ptr<reco::CaloCluster> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x5( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<edm::Ptr<reco::CaloCluster> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<edm::Ptr<reco::CaloCluster> > >::Generate();
}

//------Dictionary for class vector<edm::Ptr<reco::CaloCluster>,std::allocator<edm::Ptr<reco::CaloCluster> > > -------------------------------
void __std__vector_edm__Ptr_reco__CaloCluster_s__db_datamem(Reflex::Class*);
void __std__vector_edm__Ptr_reco__CaloCluster_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_edm__Ptr_reco__CaloCluster_s__datamem_bld(&__std__vector_edm__Ptr_reco__CaloCluster_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_edm__Ptr_reco__CaloCluster_s__funcmem_bld(&__std__vector_edm__Ptr_reco__CaloCluster_s__db_funcmem);
void __std__vector_edm__Ptr_reco__CaloCluster_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<edm::Ptr<reco::CaloCluster> >"), typeid(::std::vector<edm::Ptr<reco::CaloCluster> >), sizeof(::std::vector<edm::Ptr<reco::CaloCluster> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1791, ::Reflex::BaseOffset< ::std::vector<edm::Ptr<reco::CaloCluster> >, ::std::_Vector_base<edm::Ptr<reco::CaloCluster>,std::allocator<edm::Ptr<reco::CaloCluster> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3424, Reflex::Literal("std::vector<edm::Ptr<reco::CaloCluster> >::_Alloc_value_type"))
  .AddTypedef(type_1791, Reflex::Literal("std::vector<edm::Ptr<reco::CaloCluster> >::_Base"))
  .AddTypedef(type_2472, Reflex::Literal("std::vector<edm::Ptr<reco::CaloCluster> >::_Tp_alloc_type"))
  .AddTypedef(type_3424, Reflex::Literal("std::vector<edm::Ptr<reco::CaloCluster> >::value_type"))
  .AddTypedef(type_7480, Reflex::Literal("std::vector<edm::Ptr<reco::CaloCluster> >::pointer"))
  .AddTypedef(type_7482, Reflex::Literal("std::vector<edm::Ptr<reco::CaloCluster> >::const_pointer"))
  .AddTypedef(type_7484, Reflex::Literal("std::vector<edm::Ptr<reco::CaloCluster> >::reference"))
  .AddTypedef(type_7486, Reflex::Literal("std::vector<edm::Ptr<reco::CaloCluster> >::const_reference"))
  .AddTypedef(type_3922, Reflex::Literal("std::vector<edm::Ptr<reco::CaloCluster> >::iterator"))
  .AddTypedef(type_3923, Reflex::Literal("std::vector<edm::Ptr<reco::CaloCluster> >::const_iterator"))
  .AddTypedef(type_2583, Reflex::Literal("std::vector<edm::Ptr<reco::CaloCluster> >::const_reverse_iterator"))
  .AddTypedef(type_2584, Reflex::Literal("std::vector<edm::Ptr<reco::CaloCluster> >::reverse_iterator"))
  .AddTypedef(type_2454, Reflex::Literal("std::vector<edm::Ptr<reco::CaloCluster> >::size_type"))
  .AddTypedef(type_2353, Reflex::Literal("std::vector<edm::Ptr<reco::CaloCluster> >::difference_type"))
  .AddTypedef(type_2472, Reflex::Literal("std::vector<edm::Ptr<reco::CaloCluster> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_7495, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17474), Reflex::Literal("vector"), constructor_7496, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2454, type_7486, type_17474), Reflex::Literal("vector"), constructor_7497, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18209), Reflex::Literal("vector"), constructor_7498, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_7499, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2249, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x4, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x5, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_edm__Ptr_reco__CaloCluster_s__funcmem_bld);
}

//------Delayed data member builder for class vector<edm::Ptr<reco::CaloCluster>,std::allocator<edm::Ptr<reco::CaloCluster> > > -------------------
void __std__vector_edm__Ptr_reco__CaloCluster_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<edm::Ptr<reco::CaloCluster>,std::allocator<edm::Ptr<reco::CaloCluster> > > -------------------
void __std__vector_edm__Ptr_reco__CaloCluster_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18210, type_18209), Reflex::Literal("operator="), operator_7500, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699, type_2454, type_7486), Reflex::Literal("assign"), method_7501, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3922), Reflex::Literal("begin"), method_7502, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3923), Reflex::Literal("begin"), method_7503, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3922), Reflex::Literal("end"), method_7504, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3923), Reflex::Literal("end"), method_7505, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2454), Reflex::Literal("size"), method_7510, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2454), Reflex::Literal("max_size"), method_7511, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699, type_2454, type_3424), Reflex::Literal("resize"), method_7512, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2454), Reflex::Literal("capacity"), method_7513, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2734), Reflex::Literal("empty"), method_7514, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699, type_2454), Reflex::Literal("reserve"), method_7515, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7484, type_2454), Reflex::Literal("operator[]"), operator_7516, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7486, type_2454), Reflex::Literal("operator[]"), operator_7517, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7484, type_2454), Reflex::Literal("at"), method_7519, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7486, type_2454), Reflex::Literal("at"), method_7520, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7484), Reflex::Literal("front"), method_7521, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7486), Reflex::Literal("front"), method_7522, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7484), Reflex::Literal("back"), method_7523, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7486), Reflex::Literal("back"), method_7524, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7480), Reflex::Literal("data"), method_7525, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7482), Reflex::Literal("data"), method_7526, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699, type_7486), Reflex::Literal("push_back"), method_7527, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699), Reflex::Literal("pop_back"), method_7528, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3922, type_3922, type_7486), Reflex::Literal("insert"), method_7529, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699, type_3922, type_2454, type_7486), Reflex::Literal("insert"), method_7530, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3922, type_3922), Reflex::Literal("erase"), method_7531, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3922, type_3922, type_3922), Reflex::Literal("erase"), method_7532, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699, type_18210), Reflex::Literal("swap"), method_7533, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699), Reflex::Literal("clear"), method_7534, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<reco::CaloCluster,std::allocator<reco::CaloCluster> > -------------------------------
static void constructor_7623( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::CaloCluster>();
  else ::new(mem) ::std::vector<reco::CaloCluster>();
}

static void constructor_7624( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::CaloCluster>(*(const ::std::allocator<reco::CaloCluster>*)arg[0]);
  else ::new(mem) ::std::vector<reco::CaloCluster>(*(const ::std::allocator<reco::CaloCluster>*)arg[0]);
}

static void constructor_7625( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::CaloCluster>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<reco::CaloCluster>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::CaloCluster>(*(::std::size_t*)arg[0],
      *(const ::reco::CaloCluster*)arg[1]);
  else ::new(mem) ::std::vector<reco::CaloCluster>(*(::std::size_t*)arg[0],
      *(const ::reco::CaloCluster*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::CaloCluster>(*(::std::size_t*)arg[0],
      *(const ::reco::CaloCluster*)arg[1],
      *(const ::std::allocator<reco::CaloCluster>*)arg[2]);
  else ::new(mem) ::std::vector<reco::CaloCluster>(*(::std::size_t*)arg[0],
      *(const ::reco::CaloCluster*)arg[1],
      *(const ::std::allocator<reco::CaloCluster>*)arg[2]);
  }
}

static void constructor_7626( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::CaloCluster>(*(const ::std::vector<reco::CaloCluster>*)arg[0]);
  else ::new(mem) ::std::vector<reco::CaloCluster>(*(const ::std::vector<reco::CaloCluster>*)arg[0]);
}

static void destructor_7627(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<reco::CaloCluster>*)o)->::std::vector<reco::CaloCluster>::~vector)();
}
static  void operator_7628( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::CaloCluster>*)o)->operator=)(*(const ::std::vector<reco::CaloCluster>*)arg[0]);
  else   (((::std::vector<reco::CaloCluster>*)o)->operator=)(*(const ::std::vector<reco::CaloCluster>*)arg[0]);
}

static  void method_7629( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::CaloCluster>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::reco::CaloCluster*)arg[1]);
}

static  void method_7630( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::CaloCluster*,std::vector<reco::CaloCluster> >)((((::std::vector<reco::CaloCluster>*)o)->begin)());
  else   (((::std::vector<reco::CaloCluster>*)o)->begin)();
}

static  void method_7631( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::CaloCluster*,std::vector<reco::CaloCluster> >)((((const ::std::vector<reco::CaloCluster>*)o)->begin)());
  else   (((const ::std::vector<reco::CaloCluster>*)o)->begin)();
}

static  void method_7632( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::CaloCluster*,std::vector<reco::CaloCluster> >)((((::std::vector<reco::CaloCluster>*)o)->end)());
  else   (((::std::vector<reco::CaloCluster>*)o)->end)();
}

static  void method_7633( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::CaloCluster*,std::vector<reco::CaloCluster> >)((((const ::std::vector<reco::CaloCluster>*)o)->end)());
  else   (((const ::std::vector<reco::CaloCluster>*)o)->end)();
}

static  void method_7638( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::CaloCluster>*)o)->size)());
  else   (((const ::std::vector<reco::CaloCluster>*)o)->size)();
}

static  void method_7639( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::CaloCluster>*)o)->max_size)());
  else   (((const ::std::vector<reco::CaloCluster>*)o)->max_size)();
}

static  void method_7640( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<reco::CaloCluster>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<reco::CaloCluster>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::reco::CaloCluster*)arg[1]);
  }
}

static  void method_7641( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::CaloCluster>*)o)->capacity)());
  else   (((const ::std::vector<reco::CaloCluster>*)o)->capacity)();
}

static  void method_7642( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<reco::CaloCluster>*)o)->empty)());
  else   (((const ::std::vector<reco::CaloCluster>*)o)->empty)();
}

static  void method_7643( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::CaloCluster>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_7644( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::CaloCluster>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::CaloCluster>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_7645( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::CaloCluster>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::CaloCluster>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_7647( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::CaloCluster>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::CaloCluster>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_7648( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::CaloCluster>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::CaloCluster>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_7649( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::CaloCluster>*)o)->front)();
  else   (((::std::vector<reco::CaloCluster>*)o)->front)();
}

static  void method_7650( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::CaloCluster>*)o)->front)();
  else   (((const ::std::vector<reco::CaloCluster>*)o)->front)();
}

static  void method_7651( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::CaloCluster>*)o)->back)();
  else   (((::std::vector<reco::CaloCluster>*)o)->back)();
}

static  void method_7652( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::CaloCluster>*)o)->back)();
  else   (((const ::std::vector<reco::CaloCluster>*)o)->back)();
}

static  void method_7653( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<reco::CaloCluster>*)o)->data)());
  else   (((::std::vector<reco::CaloCluster>*)o)->data)();
}

static  void method_7654( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<reco::CaloCluster>*)o)->data)());
  else   (((const ::std::vector<reco::CaloCluster>*)o)->data)();
}

static  void method_7655( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::CaloCluster>*)o)->push_back)(*(const ::reco::CaloCluster*)arg[0]);
}

static  void method_7656( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::CaloCluster>*)o)->pop_back)();
}

static  void method_7657( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::CaloCluster*,std::vector<reco::CaloCluster> >)((((::std::vector<reco::CaloCluster>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::CaloCluster*,std::vector<reco::CaloCluster> >*)arg[0],
    *(const ::reco::CaloCluster*)arg[1]));
  else   (((::std::vector<reco::CaloCluster>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::CaloCluster*,std::vector<reco::CaloCluster> >*)arg[0],
    *(const ::reco::CaloCluster*)arg[1]);
}

static  void method_7658( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::CaloCluster>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::CaloCluster*,std::vector<reco::CaloCluster> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::reco::CaloCluster*)arg[2]);
}

static  void method_7659( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::CaloCluster*,std::vector<reco::CaloCluster> >)((((::std::vector<reco::CaloCluster>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::CaloCluster*,std::vector<reco::CaloCluster> >*)arg[0]));
  else   (((::std::vector<reco::CaloCluster>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::CaloCluster*,std::vector<reco::CaloCluster> >*)arg[0]);
}

static  void method_7660( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::CaloCluster*,std::vector<reco::CaloCluster> >)((((::std::vector<reco::CaloCluster>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::CaloCluster*,std::vector<reco::CaloCluster> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::CaloCluster*,std::vector<reco::CaloCluster> >*)arg[1]));
  else   (((::std::vector<reco::CaloCluster>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::CaloCluster*,std::vector<reco::CaloCluster> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::CaloCluster*,std::vector<reco::CaloCluster> >*)arg[1]);
}

static  void method_7661( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::CaloCluster>*)o)->swap)(*(::std::vector<reco::CaloCluster>*)arg[0]);
}

static  void method_7662( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::CaloCluster>*)o)->clear)();
}

static void method_newdel_2251( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<reco::CaloCluster> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<reco::CaloCluster> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<reco::CaloCluster> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<reco::CaloCluster> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<reco::CaloCluster> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x7( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::CaloCluster,std::allocator<reco::CaloCluster> >")), ::Reflex::BaseOffset< ::std::vector<reco::CaloCluster>,::std::_Vector_base<reco::CaloCluster,std::allocator<reco::CaloCluster> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x8( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<reco::CaloCluster> >::Generate();
  else ::Reflex::Proxy< ::std::vector<reco::CaloCluster> >::Generate();
}

//------Dictionary for class vector<reco::CaloCluster,std::allocator<reco::CaloCluster> > -------------------------------
void __std__vector_reco__CaloCluster__db_datamem(Reflex::Class*);
void __std__vector_reco__CaloCluster__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_reco__CaloCluster__datamem_bld(&__std__vector_reco__CaloCluster__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_reco__CaloCluster__funcmem_bld(&__std__vector_reco__CaloCluster__db_funcmem);
void __std__vector_reco__CaloCluster__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<reco::CaloCluster>"), typeid(::std::vector<reco::CaloCluster>), sizeof(::std::vector<reco::CaloCluster>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1792, ::Reflex::BaseOffset< ::std::vector<reco::CaloCluster>, ::std::_Vector_base<reco::CaloCluster,std::allocator<reco::CaloCluster> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3844, Reflex::Literal("std::vector<reco::CaloCluster>::_Alloc_value_type"))
  .AddTypedef(type_1792, Reflex::Literal("std::vector<reco::CaloCluster>::_Base"))
  .AddTypedef(type_2474, Reflex::Literal("std::vector<reco::CaloCluster>::_Tp_alloc_type"))
  .AddTypedef(type_3844, Reflex::Literal("std::vector<reco::CaloCluster>::value_type"))
  .AddTypedef(type_7608, Reflex::Literal("std::vector<reco::CaloCluster>::pointer"))
  .AddTypedef(type_7610, Reflex::Literal("std::vector<reco::CaloCluster>::const_pointer"))
  .AddTypedef(type_7612, Reflex::Literal("std::vector<reco::CaloCluster>::reference"))
  .AddTypedef(type_7614, Reflex::Literal("std::vector<reco::CaloCluster>::const_reference"))
  .AddTypedef(type_3925, Reflex::Literal("std::vector<reco::CaloCluster>::iterator"))
  .AddTypedef(type_3926, Reflex::Literal("std::vector<reco::CaloCluster>::const_iterator"))
  .AddTypedef(type_2585, Reflex::Literal("std::vector<reco::CaloCluster>::const_reverse_iterator"))
  .AddTypedef(type_2586, Reflex::Literal("std::vector<reco::CaloCluster>::reverse_iterator"))
  .AddTypedef(type_2454, Reflex::Literal("std::vector<reco::CaloCluster>::size_type"))
  .AddTypedef(type_2353, Reflex::Literal("std::vector<reco::CaloCluster>::difference_type"))
  .AddTypedef(type_2474, Reflex::Literal("std::vector<reco::CaloCluster>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_7623, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_17486), Reflex::Literal("vector"), constructor_7624, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2454, type_7614, type_17486), Reflex::Literal("vector"), constructor_7625, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_18214), Reflex::Literal("vector"), constructor_7626, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_7627, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2251, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x7, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x8, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_reco__CaloCluster__funcmem_bld);
}

//------Delayed data member builder for class vector<reco::CaloCluster,std::allocator<reco::CaloCluster> > -------------------
void __std__vector_reco__CaloCluster__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<reco::CaloCluster,std::allocator<reco::CaloCluster> > -------------------
void __std__vector_reco__CaloCluster__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18215, type_18214), Reflex::Literal("operator="), operator_7628, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699, type_2454, type_7614), Reflex::Literal("assign"), method_7629, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3925), Reflex::Literal("begin"), method_7630, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3926), Reflex::Literal("begin"), method_7631, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3925), Reflex::Literal("end"), method_7632, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3926), Reflex::Literal("end"), method_7633, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2454), Reflex::Literal("size"), method_7638, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2454), Reflex::Literal("max_size"), method_7639, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699, type_2454, type_3844), Reflex::Literal("resize"), method_7640, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2454), Reflex::Literal("capacity"), method_7641, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2734), Reflex::Literal("empty"), method_7642, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699, type_2454), Reflex::Literal("reserve"), method_7643, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7612, type_2454), Reflex::Literal("operator[]"), operator_7644, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7614, type_2454), Reflex::Literal("operator[]"), operator_7645, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7612, type_2454), Reflex::Literal("at"), method_7647, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7614, type_2454), Reflex::Literal("at"), method_7648, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7612), Reflex::Literal("front"), method_7649, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7614), Reflex::Literal("front"), method_7650, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7612), Reflex::Literal("back"), method_7651, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7614), Reflex::Literal("back"), method_7652, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7608), Reflex::Literal("data"), method_7653, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7610), Reflex::Literal("data"), method_7654, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699, type_7614), Reflex::Literal("push_back"), method_7655, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699), Reflex::Literal("pop_back"), method_7656, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3925, type_3925, type_7614), Reflex::Literal("insert"), method_7657, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699, type_3925, type_2454, type_7614), Reflex::Literal("insert"), method_7658, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3925, type_3925), Reflex::Literal("erase"), method_7659, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3925, type_3925, type_3925), Reflex::Literal("erase"), method_7660, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699, type_18215), Reflex::Literal("swap"), method_7661, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699), Reflex::Literal("clear"), method_7662, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class PtrVector<reco::CaloCluster> -------------------------------
static void constructor_14030( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<reco::CaloCluster>();
  else ::new(mem) ::edm::PtrVector<reco::CaloCluster>();
}

static void constructor_14031( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<reco::CaloCluster>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::PtrVector<reco::CaloCluster>(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_14032( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<reco::CaloCluster>(*(const ::edm::PtrVector<reco::CaloCluster>*)arg[0]);
  else ::new(mem) ::edm::PtrVector<reco::CaloCluster>(*(const ::edm::PtrVector<reco::CaloCluster>*)arg[0]);
}

static  void operator_14033( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::CaloCluster>)((((const ::edm::PtrVector<reco::CaloCluster>*)o)->operator[])(*(const unsigned long*)arg[0]));
  else   (((const ::edm::PtrVector<reco::CaloCluster>*)o)->operator[])(*(const unsigned long*)arg[0]);
}

static  void method_14034( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::PtrVectorItr<reco::CaloCluster>)((((const ::edm::PtrVector<reco::CaloCluster>*)o)->begin)());
  else   (((const ::edm::PtrVector<reco::CaloCluster>*)o)->begin)();
}

static  void method_14035( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::PtrVectorItr<reco::CaloCluster>)((((const ::edm::PtrVector<reco::CaloCluster>*)o)->end)());
  else   (((const ::edm::PtrVector<reco::CaloCluster>*)o)->end)();
}

static  void method_14036( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::PtrVector<reco::CaloCluster>*)o)->push_back)(*(const ::edm::Ptr<reco::CaloCluster>*)arg[0]);
}

static  void method_14037( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::PtrVector<reco::CaloCluster>*)o)->swap)(*(::edm::PtrVector<reco::CaloCluster>*)arg[0]);
}

static  void operator_14038( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::PtrVector<reco::CaloCluster>*)o)->operator=)(*(const ::edm::PtrVector<reco::CaloCluster>*)arg[0]);
  else   (((::edm::PtrVector<reco::CaloCluster>*)o)->operator=)(*(const ::edm::PtrVector<reco::CaloCluster>*)arg[0]);
}

static  void method_14039( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::PtrVector<reco::CaloCluster>*)o)->fillView)(*(::std::vector<const void*>*)arg[0]);
}

static  void method_14040( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::PtrVector<reco::CaloCluster>*)o)->Class_Version)());
  else   (((::edm::PtrVector<reco::CaloCluster>*)o)->Class_Version)();
}

static void destructor_14043(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::PtrVector<reco::CaloCluster>*)o)->::edm::PtrVector<reco::CaloCluster>::~PtrVector)();
}
static void method_newdel_3335( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::CaloCluster> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::CaloCluster> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::CaloCluster> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::CaloCluster> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::CaloCluster> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x10( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVectorBase")), ::Reflex::BaseOffset< ::edm::PtrVector<reco::CaloCluster>,::edm::PtrVectorBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PtrVector<reco::CaloCluster> -------------------------------
void __edm__PtrVector_reco__CaloCluster__db_datamem(Reflex::Class*);
void __edm__PtrVector_reco__CaloCluster__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__PtrVector_reco__CaloCluster__datamem_bld(&__edm__PtrVector_reco__CaloCluster__db_datamem);
Reflex::GenreflexMemberBuilder __edm__PtrVector_reco__CaloCluster__funcmem_bld(&__edm__PtrVector_reco__CaloCluster__db_funcmem);
void __edm__PtrVector_reco__CaloCluster__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::PtrVector<reco::CaloCluster>"), typeid(::edm::PtrVector<reco::CaloCluster>), sizeof(::edm::PtrVector<reco::CaloCluster>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::PtrVector<reco::CaloCluster>::Class_Version())
  .AddBase(type_3389, ::Reflex::BaseOffset< ::edm::PtrVector<reco::CaloCluster>, ::edm::PtrVectorBase >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_3363, Reflex::Literal("edm::PtrVector<reco::CaloCluster>::const_iterator"))
  .AddTypedef(type_3363, Reflex::Literal("edm::PtrVector<reco::CaloCluster>::iterator"))
  .AddTypedef(type_3424, Reflex::Literal("edm::PtrVector<reco::CaloCluster>::value_type"))
  .AddTypedef(type_2699, Reflex::Literal("edm::PtrVector<reco::CaloCluster>::collection_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PtrVector"), constructor_14030, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11208), Reflex::Literal("PtrVector"), constructor_14031, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_22444), Reflex::Literal("PtrVector"), constructor_14032, 0, "iOther", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PtrVector"), destructor_14043, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3335, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x10, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__edm__PtrVector_reco__CaloCluster__funcmem_bld);
}

//------Delayed data member builder for class PtrVector<reco::CaloCluster> -------------------
void __edm__PtrVector_reco__CaloCluster__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class PtrVector<reco::CaloCluster> -------------------
void __edm__PtrVector_reco__CaloCluster__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3424, type_227c), Reflex::Literal("operator[]"), operator_14033, 0, "iIndex", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3363), Reflex::Literal("begin"), method_14034, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3363), Reflex::Literal("end"), method_14035, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699, type_7486), Reflex::Literal("push_back"), method_14036, 0, "iPtr", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699, type_22445), Reflex::Literal("swap"), method_14037, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22445, type_22444), Reflex::Literal("operator="), operator_14038, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699, type_18202), Reflex::Literal("fillView"), method_14039, 0, "pointers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_973), Reflex::Literal("Class_Version"), method_14040, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Wrapper<edm::PtrVector<reco::CaloCluster> > -------------------------------
static void constructor_14048( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::PtrVector<reco::CaloCluster> >();
  else ::new(mem) ::edm::Wrapper<edm::PtrVector<reco::CaloCluster> >();
}

static void constructor_14049( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::PtrVector<reco::CaloCluster> >(*(::std::auto_ptr<edm::PtrVector<reco::CaloCluster> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::PtrVector<reco::CaloCluster> >(*(::std::auto_ptr<edm::PtrVector<reco::CaloCluster> >*)arg[0]);
}

static void destructor_14050(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::PtrVector<reco::CaloCluster> >*)o)->::edm::Wrapper<edm::PtrVector<reco::CaloCluster> >::~Wrapper)();
}
static  void method_14051( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::PtrVector<reco::CaloCluster> >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::PtrVector<reco::CaloCluster> >*)o)->product)();
}

static  void operator_14052( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::PtrVector<reco::CaloCluster> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::PtrVector<reco::CaloCluster> >*)o)->operator->)();
}

static  void method_14053( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::PtrVector<reco::CaloCluster> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::PtrVector<reco::CaloCluster> >*)o)->productTypeInfo)();
}

static  void method_14054( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::PtrVector<reco::CaloCluster> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::PtrVector<reco::CaloCluster> >*)o)->typeInfo)();
}

static void constructor_14055( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::PtrVector<reco::CaloCluster> >((::edm::PtrVector<reco::CaloCluster>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::PtrVector<reco::CaloCluster> >((::edm::PtrVector<reco::CaloCluster>*)arg[0]);
}

static  void method_14056( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::PtrVector<reco::CaloCluster> >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::PtrVector<reco::CaloCluster> >*)o)->getInterface)();
}

static  void method_14057( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::PtrVector<reco::CaloCluster> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_14058( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::PtrVector<reco::CaloCluster> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_14059( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::PtrVector<reco::CaloCluster> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_14060( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::PtrVector<reco::CaloCluster> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::PtrVector<reco::CaloCluster> >*)o)->dynamicTypeInfo)();
}

static  void method_14061( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::PtrVector<reco::CaloCluster> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::PtrVector<reco::CaloCluster> >*)o)->isPresent)();
}

static  void method_14062( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::PtrVector<reco::CaloCluster> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::PtrVector<reco::CaloCluster> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3346( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::PtrVector<reco::CaloCluster> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::PtrVector<reco::CaloCluster> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::PtrVector<reco::CaloCluster> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::PtrVector<reco::CaloCluster> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::PtrVector<reco::CaloCluster> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::PtrVector<reco::CaloCluster> > -------------------------------
void __edm__Wrapper_edm__PtrVector_reco__CaloCluster_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__PtrVector_reco__CaloCluster_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__PtrVector_reco__CaloCluster_s__datamem_bld(&__edm__Wrapper_edm__PtrVector_reco__CaloCluster_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__PtrVector_reco__CaloCluster_s__funcmem_bld(&__edm__Wrapper_edm__PtrVector_reco__CaloCluster_s__db_funcmem);
void __edm__Wrapper_edm__PtrVector_reco__CaloCluster_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::PtrVector<reco::CaloCluster> >"), typeid(::edm::Wrapper<edm::PtrVector<reco::CaloCluster> >), sizeof(::edm::Wrapper<edm::PtrVector<reco::CaloCluster> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3335, Reflex::Literal("edm::Wrapper<edm::PtrVector<reco::CaloCluster> >::value_type"))
  .AddTypedef(type_3335, Reflex::Literal("edm::Wrapper<edm::PtrVector<reco::CaloCluster> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_14048, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2030), Reflex::Literal("Wrapper"), constructor_14049, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_14050, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_22447), Reflex::Literal("Wrapper"), constructor_14055, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3346, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__PtrVector_reco__CaloCluster_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__PtrVector_reco__CaloCluster_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::PtrVector<reco::CaloCluster> > -------------------
void __edm__Wrapper_edm__PtrVector_reco__CaloCluster_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2734, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__PtrVector_reco__CaloCluster_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3335, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__PtrVector_reco__CaloCluster_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::PtrVector<reco::CaloCluster> > -------------------
void __edm__Wrapper_edm__PtrVector_reco__CaloCluster_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22446), Reflex::Literal("product"), method_14051, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22446), Reflex::Literal("operator->"), operator_14052, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3322), Reflex::Literal("productTypeInfo"), method_14053, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3322), Reflex::Literal("typeInfo"), method_14054, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22448), Reflex::Literal("getInterface"), method_14056, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699, type_11208, type_18202, type_18759), Reflex::Literal("fillView"), method_14057, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699, type_3322, type_227, type_5021), Reflex::Literal("setPtr"), method_14058, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699, type_3322, type_18203, type_18202), Reflex::Literal("fillPtrVector"), method_14059, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3322), Reflex::Literal("dynamicTypeInfo"), method_14060, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2734), Reflex::Literal("isPresent"), method_14061, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3322), Reflex::Literal("dynamicTypeInfo_"), method_14062, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class ValueMap<reco::CaloCluster> -------------------------------
static void destructor_14546(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::ValueMap<reco::CaloCluster>*)o)->::edm::ValueMap<reco::CaloCluster>::~ValueMap)();
}
static void constructor_14547( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::ValueMap<reco::CaloCluster>(*(const ::edm::ValueMap<reco::CaloCluster>*)arg[0]);
  else ::new(mem) ::edm::ValueMap<reco::CaloCluster>(*(const ::edm::ValueMap<reco::CaloCluster>*)arg[0]);
}

static void constructor_14548( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::ValueMap<reco::CaloCluster>();
  else ::new(mem) ::edm::ValueMap<reco::CaloCluster>();
}

static  void method_14549( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::ValueMap<reco::CaloCluster>*)o)->swap)(*(::edm::ValueMap<reco::CaloCluster>*)arg[0]);
}

static  void operator_14550( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ValueMap<reco::CaloCluster>*)o)->operator=)(*(const ::edm::ValueMap<reco::CaloCluster>*)arg[0]);
  else   (((::edm::ValueMap<reco::CaloCluster>*)o)->operator=)(*(const ::edm::ValueMap<reco::CaloCluster>*)arg[0]);
}

static  void method_14551( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::ValueMap<reco::CaloCluster>*)o)->rawIndexOf)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]));
  else   (((const ::edm::ValueMap<reco::CaloCluster>*)o)->rawIndexOf)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void method_14552( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::ValueMap<reco::CaloCluster>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
  else   (((const ::edm::ValueMap<reco::CaloCluster>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void method_14553( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ValueMap<reco::CaloCluster>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
  else   (((::edm::ValueMap<reco::CaloCluster>*)o)->get)(*(::edm::ProductID*)arg[0],
    *(::size_t*)arg[1]);
}

static  void operator_14554( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ValueMap<reco::CaloCluster>*)o)->operator+=)(*(const ::edm::ValueMap<reco::CaloCluster>*)arg[0]);
  else   (((::edm::ValueMap<reco::CaloCluster>*)o)->operator+=)(*(const ::edm::ValueMap<reco::CaloCluster>*)arg[0]);
}

static  void method_14555( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::ValueMap<reco::CaloCluster>*)o)->contains)(*(::edm::ProductID*)arg[0]));
  else   (((const ::edm::ValueMap<reco::CaloCluster>*)o)->contains)(*(::edm::ProductID*)arg[0]);
}

static  void method_14556( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::ValueMap<reco::CaloCluster>*)o)->size)());
  else   (((const ::edm::ValueMap<reco::CaloCluster>*)o)->size)();
}

static  void method_14557( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::ValueMap<reco::CaloCluster>*)o)->idSize)());
  else   (((const ::edm::ValueMap<reco::CaloCluster>*)o)->idSize)();
}

static  void method_14558( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::ValueMap<reco::CaloCluster>*)o)->empty)());
  else   (((const ::edm::ValueMap<reco::CaloCluster>*)o)->empty)();
}

static  void method_14559( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::ValueMap<reco::CaloCluster>*)o)->clear)();
}

static  void method_14560( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ValueMap<reco::CaloCluster>::const_iterator)((((const ::edm::ValueMap<reco::CaloCluster>*)o)->begin)());
  else   (((const ::edm::ValueMap<reco::CaloCluster>*)o)->begin)();
}

static  void method_14561( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ValueMap<reco::CaloCluster>::const_iterator)((((const ::edm::ValueMap<reco::CaloCluster>*)o)->end)());
  else   (((const ::edm::ValueMap<reco::CaloCluster>*)o)->end)();
}

static  void method_14562( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::ValueMap<reco::CaloCluster>*)o)->ids)();
  else   (((const ::edm::ValueMap<reco::CaloCluster>*)o)->ids)();
}

static  void method_14563( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::ValueMap<reco::CaloCluster>*)o)->get)(*(::size_t*)arg[0]);
  else   (((const ::edm::ValueMap<reco::CaloCluster>*)o)->get)(*(::size_t*)arg[0]);
}

static  void method_14564( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::ValueMap<reco::CaloCluster>*)o)->Class_Version)());
  else   (((::edm::ValueMap<reco::CaloCluster>*)o)->Class_Version)();
}

static void method_newdel_3445( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<reco::CaloCluster> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<reco::CaloCluster> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<reco::CaloCluster> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<reco::CaloCluster> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::ValueMap<reco::CaloCluster> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class ValueMap<reco::CaloCluster> -------------------------------
void __edm__ValueMap_reco__CaloCluster__db_datamem(Reflex::Class*);
void __edm__ValueMap_reco__CaloCluster__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__ValueMap_reco__CaloCluster__datamem_bld(&__edm__ValueMap_reco__CaloCluster__db_datamem);
Reflex::GenreflexMemberBuilder __edm__ValueMap_reco__CaloCluster__funcmem_bld(&__edm__ValueMap_reco__CaloCluster__db_funcmem);
void __edm__ValueMap_reco__CaloCluster__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::ValueMap<reco::CaloCluster>"), typeid(::edm::ValueMap<reco::CaloCluster>), sizeof(::edm::ValueMap<reco::CaloCluster>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::ValueMap<reco::CaloCluster>::Class_Version())
  .AddTypedef(type_3844, Reflex::Literal("edm::ValueMap<reco::CaloCluster>::value_type"))
  .AddTypedef(type_2251, Reflex::Literal("edm::ValueMap<reco::CaloCluster>::container"))
  .AddTypedef(type_234, Reflex::Literal("edm::ValueMap<reco::CaloCluster>::offset"))
  .AddTypedef(type_2250, Reflex::Literal("edm::ValueMap<reco::CaloCluster>::id_offset_vector"))
  .AddTypedef(type_7612, Reflex::Literal("edm::ValueMap<reco::CaloCluster>::reference_type"))
  .AddTypedef(type_7614, Reflex::Literal("edm::ValueMap<reco::CaloCluster>::const_reference_type"))
  .AddTypedef(type_14354, Reflex::Literal("edm::ValueMap<reco::CaloCluster>::Filler"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ValueMap"), destructor_14546, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_22612), Reflex::Literal("ValueMap"), constructor_14547, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("ValueMap"), constructor_14548, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3445, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__ValueMap_reco__CaloCluster__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__ValueMap_reco__CaloCluster__funcmem_bld);
}

//------Delayed data member builder for class ValueMap<reco::CaloCluster> -------------------
void __edm__ValueMap_reco__CaloCluster__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2251, Reflex::Literal("values_"), OffsetOf(__shadow__::__edm__ValueMap_reco__CaloCluster_, values_), ::Reflex::PROTECTED)
  .AddDataMember(type_2250, Reflex::Literal("ids_"), OffsetOf(__shadow__::__edm__ValueMap_reco__CaloCluster_, ids_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class ValueMap<reco::CaloCluster> -------------------
void __edm__ValueMap_reco__CaloCluster__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699, type_22613), Reflex::Literal("swap"), method_14549, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22613, type_22612), Reflex::Literal("operator="), operator_14550, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1501, type_3408, type_1501), Reflex::Literal("rawIndexOf"), method_14551, 0, "id;idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7614, type_3408, type_1501), Reflex::Literal("get"), method_14552, 0, "id;idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7612, type_3408, type_1501), Reflex::Literal("get"), method_14553, 0, "id;idx", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22613, type_22612), Reflex::Literal("operator+="), operator_14554, 0, "o", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2734, type_3408), Reflex::Literal("contains"), method_14555, 0, "id", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1501), Reflex::Literal("size"), method_14556, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1501), Reflex::Literal("idSize"), method_14557, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2734), Reflex::Literal("empty"), method_14558, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699), Reflex::Literal("clear"), method_14559, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14544), Reflex::Literal("begin"), method_14560, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14544), Reflex::Literal("end"), method_14561, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_18211), Reflex::Literal("ids"), method_14562, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7614, type_1501), Reflex::Literal("get"), method_14563, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_973), Reflex::Literal("Class_Version"), method_14564, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Wrapper<edm::ValueMap<reco::CaloCluster> > -------------------------------
static void constructor_14069( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ValueMap<reco::CaloCluster> >();
  else ::new(mem) ::edm::Wrapper<edm::ValueMap<reco::CaloCluster> >();
}

static void constructor_14070( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ValueMap<reco::CaloCluster> >(*(::std::auto_ptr<edm::ValueMap<reco::CaloCluster> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::ValueMap<reco::CaloCluster> >(*(::std::auto_ptr<edm::ValueMap<reco::CaloCluster> >*)arg[0]);
}

static void destructor_14071(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::ValueMap<reco::CaloCluster> >*)o)->::edm::Wrapper<edm::ValueMap<reco::CaloCluster> >::~Wrapper)();
}
static  void method_14072( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::ValueMap<reco::CaloCluster> >*)o)->product)());
  else   (((const ::edm::Wrapper<edm::ValueMap<reco::CaloCluster> >*)o)->product)();
}

static  void operator_14073( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::ValueMap<reco::CaloCluster> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::ValueMap<reco::CaloCluster> >*)o)->operator->)();
}

static  void method_14074( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::ValueMap<reco::CaloCluster> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::ValueMap<reco::CaloCluster> >*)o)->productTypeInfo)();
}

static  void method_14075( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::ValueMap<reco::CaloCluster> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::ValueMap<reco::CaloCluster> >*)o)->typeInfo)();
}

static void constructor_14076( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::ValueMap<reco::CaloCluster> >((::edm::ValueMap<reco::CaloCluster>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::ValueMap<reco::CaloCluster> >((::edm::ValueMap<reco::CaloCluster>*)arg[0]);
}

static  void method_14077( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::ValueMap<reco::CaloCluster> >*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::ValueMap<reco::CaloCluster> >*)o)->getInterface)();
}

static  void method_14078( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ValueMap<reco::CaloCluster> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_14079( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ValueMap<reco::CaloCluster> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_14080( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::ValueMap<reco::CaloCluster> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_14081( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::ValueMap<reco::CaloCluster> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::ValueMap<reco::CaloCluster> >*)o)->dynamicTypeInfo)();
}

static  void method_14082( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::ValueMap<reco::CaloCluster> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::ValueMap<reco::CaloCluster> >*)o)->isPresent)();
}

static  void method_14083( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::ValueMap<reco::CaloCluster> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::ValueMap<reco::CaloCluster> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3347( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<reco::CaloCluster> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<reco::CaloCluster> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<reco::CaloCluster> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<reco::CaloCluster> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::ValueMap<reco::CaloCluster> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::ValueMap<reco::CaloCluster> > -------------------------------
void __edm__Wrapper_edm__ValueMap_reco__CaloCluster_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__ValueMap_reco__CaloCluster_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__ValueMap_reco__CaloCluster_s__datamem_bld(&__edm__Wrapper_edm__ValueMap_reco__CaloCluster_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__ValueMap_reco__CaloCluster_s__funcmem_bld(&__edm__Wrapper_edm__ValueMap_reco__CaloCluster_s__db_funcmem);
void __edm__Wrapper_edm__ValueMap_reco__CaloCluster_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::ValueMap<reco::CaloCluster> >"), typeid(::edm::Wrapper<edm::ValueMap<reco::CaloCluster> >), sizeof(::edm::Wrapper<edm::ValueMap<reco::CaloCluster> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3445, Reflex::Literal("edm::Wrapper<edm::ValueMap<reco::CaloCluster> >::value_type"))
  .AddTypedef(type_3445, Reflex::Literal("edm::Wrapper<edm::ValueMap<reco::CaloCluster> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_14069, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2031), Reflex::Literal("Wrapper"), constructor_14070, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_14071, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_22452), Reflex::Literal("Wrapper"), constructor_14076, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3347, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__ValueMap_reco__CaloCluster_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__ValueMap_reco__CaloCluster_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::ValueMap<reco::CaloCluster> > -------------------
void __edm__Wrapper_edm__ValueMap_reco__CaloCluster_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2734, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__ValueMap_reco__CaloCluster_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3445, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__ValueMap_reco__CaloCluster_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::ValueMap<reco::CaloCluster> > -------------------
void __edm__Wrapper_edm__ValueMap_reco__CaloCluster_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22451), Reflex::Literal("product"), method_14072, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22451), Reflex::Literal("operator->"), operator_14073, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3322), Reflex::Literal("productTypeInfo"), method_14074, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3322), Reflex::Literal("typeInfo"), method_14075, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22453), Reflex::Literal("getInterface"), method_14077, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699, type_11208, type_18202, type_18759), Reflex::Literal("fillView"), method_14078, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699, type_3322, type_227, type_5021), Reflex::Literal("setPtr"), method_14079, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699, type_3322, type_18203, type_18202), Reflex::Literal("fillPtrVector"), method_14080, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3322), Reflex::Literal("dynamicTypeInfo"), method_14081, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2734), Reflex::Literal("isPresent"), method_14082, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3322), Reflex::Literal("dynamicTypeInfo_"), method_14083, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<reco::CaloCluster, std::allocator<reco::CaloCluster> > > -------------------------------
static void constructor_14090( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::CaloCluster> >();
  else ::new(mem) ::edm::Wrapper<std::vector<reco::CaloCluster> >();
}

static void constructor_14091( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::CaloCluster> >(*(::std::auto_ptr<std::vector<reco::CaloCluster> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<reco::CaloCluster> >(*(::std::auto_ptr<std::vector<reco::CaloCluster> >*)arg[0]);
}

static void destructor_14092(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<reco::CaloCluster> >*)o)->::edm::Wrapper<std::vector<reco::CaloCluster> >::~Wrapper)();
}
static  void method_14093( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<reco::CaloCluster> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<reco::CaloCluster> >*)o)->product)();
}

static  void operator_14094( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<reco::CaloCluster> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<reco::CaloCluster> >*)o)->operator->)();
}

static  void method_14095( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<reco::CaloCluster> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<reco::CaloCluster> >*)o)->productTypeInfo)();
}

static  void method_14096( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<reco::CaloCluster> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<reco::CaloCluster> >*)o)->typeInfo)();
}

static void constructor_14097( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::CaloCluster> >((::std::vector<reco::CaloCluster>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<reco::CaloCluster> >((::std::vector<reco::CaloCluster>*)arg[0]);
}

static  void method_14098( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<reco::CaloCluster> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<reco::CaloCluster> >*)o)->getInterface)();
}

static  void method_14099( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::CaloCluster> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_14100( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::CaloCluster> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_14101( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::CaloCluster> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_14102( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<reco::CaloCluster> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<reco::CaloCluster> >*)o)->dynamicTypeInfo)();
}

static  void method_14103( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<reco::CaloCluster> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<reco::CaloCluster> >*)o)->isPresent)();
}

static  void method_14104( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<reco::CaloCluster> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<reco::CaloCluster> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3348( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::CaloCluster> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::CaloCluster> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::CaloCluster> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::CaloCluster> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::CaloCluster> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<reco::CaloCluster, std::allocator<reco::CaloCluster> > > -------------------------------
void __edm__Wrapper_std__vector_reco__CaloCluster_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_reco__CaloCluster_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_reco__CaloCluster_s__datamem_bld(&__edm__Wrapper_std__vector_reco__CaloCluster_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_reco__CaloCluster_s__funcmem_bld(&__edm__Wrapper_std__vector_reco__CaloCluster_s__db_funcmem);
void __edm__Wrapper_std__vector_reco__CaloCluster_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<reco::CaloCluster> >"), typeid(::edm::Wrapper<std::vector<reco::CaloCluster> >), sizeof(::edm::Wrapper<std::vector<reco::CaloCluster> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2251, Reflex::Literal("edm::Wrapper<std::vector<reco::CaloCluster> >::value_type"))
  .AddTypedef(type_2251, Reflex::Literal("edm::Wrapper<std::vector<reco::CaloCluster> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_14090, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2032), Reflex::Literal("Wrapper"), constructor_14091, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_14092, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_22457), Reflex::Literal("Wrapper"), constructor_14097, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3348, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_reco__CaloCluster_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_reco__CaloCluster_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<reco::CaloCluster, std::allocator<reco::CaloCluster> > > -------------------
void __edm__Wrapper_std__vector_reco__CaloCluster_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2734, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_reco__CaloCluster_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2251, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_reco__CaloCluster_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<reco::CaloCluster, std::allocator<reco::CaloCluster> > > -------------------
void __edm__Wrapper_std__vector_reco__CaloCluster_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22456), Reflex::Literal("product"), method_14093, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22456), Reflex::Literal("operator->"), operator_14094, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3322), Reflex::Literal("productTypeInfo"), method_14095, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3322), Reflex::Literal("typeInfo"), method_14096, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22458), Reflex::Literal("getInterface"), method_14098, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699, type_11208, type_18202, type_18759), Reflex::Literal("fillView"), method_14099, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699, type_3322, type_227, type_5021), Reflex::Literal("setPtr"), method_14100, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699, type_3322, type_18203, type_18202), Reflex::Literal("fillPtrVector"), method_14101, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3322), Reflex::Literal("dynamicTypeInfo"), method_14102, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2734), Reflex::Literal("isPresent"), method_14103, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3322), Reflex::Literal("dynamicTypeInfo_"), method_14104, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class RefToBase<CaloRecHit> -------------------------------
static void constructor_14357( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefToBase<CaloRecHit>();
  else ::new(mem) ::edm::RefToBase<CaloRecHit>();
}

static void constructor_14358( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefToBase<CaloRecHit>(*(const ::edm::RefToBase<CaloRecHit>*)arg[0]);
  else ::new(mem) ::edm::RefToBase<CaloRecHit>(*(const ::edm::RefToBase<CaloRecHit>*)arg[0]);
}

static void constructor_14359( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefToBase<CaloRecHit>(*(const ::edm::RefToBaseProd<CaloRecHit>*)arg[0],
      *(::size_t*)arg[1]);
  else ::new(mem) ::edm::RefToBase<CaloRecHit>(*(const ::edm::RefToBaseProd<CaloRecHit>*)arg[0],
      *(::size_t*)arg[1]);
}

static void constructor_14360( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefToBase<CaloRecHit>(*(const ::edm::Handle<edm::View<CaloRecHit> >*)arg[0],
      *(::size_t*)arg[1]);
  else ::new(mem) ::edm::RefToBase<CaloRecHit>(*(const ::edm::Handle<edm::View<CaloRecHit> >*)arg[0],
      *(::size_t*)arg[1]);
}

static void constructor_14361( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefToBase<CaloRecHit>(*(::boost::shared_ptr<edm::reftobase::RefHolderBase>*)arg[0]);
  else ::new(mem) ::edm::RefToBase<CaloRecHit>(*(::boost::shared_ptr<edm::reftobase::RefHolderBase>*)arg[0]);
}

static void destructor_14362(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefToBase<CaloRecHit>*)o)->::edm::RefToBase<CaloRecHit>::~RefToBase)();
}
static  void operator_14363( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefToBase<CaloRecHit>*)o)->operator=)(*(const ::edm::RefToBase<CaloRecHit>*)arg[0]);
  else   (((::edm::RefToBase<CaloRecHit>*)o)->operator=)(*(const ::edm::RefToBase<CaloRecHit>*)arg[0]);
}

static  void operator_14364( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefToBase<CaloRecHit>*)o)->operator*)();
  else   (((const ::edm::RefToBase<CaloRecHit>*)o)->operator*)();
}

static  void operator_14365( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefToBase<CaloRecHit>*)o)->operator->)());
  else   (((const ::edm::RefToBase<CaloRecHit>*)o)->operator->)();
}

static  void method_14366( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefToBase<CaloRecHit>*)o)->get)());
  else   (((const ::edm::RefToBase<CaloRecHit>*)o)->get)();
}

static  void method_14367( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefToBase<CaloRecHit>*)o)->id)());
  else   (((const ::edm::RefToBase<CaloRecHit>*)o)->id)();
}

static  void method_14368( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::RefToBase<CaloRecHit>*)o)->key)());
  else   (((const ::edm::RefToBase<CaloRecHit>*)o)->key)();
}

static  void method_14369( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefToBase<CaloRecHit>*)o)->isNull)());
  else   (((const ::edm::RefToBase<CaloRecHit>*)o)->isNull)();
}

static  void method_14370( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefToBase<CaloRecHit>*)o)->isNonnull)());
  else   (((const ::edm::RefToBase<CaloRecHit>*)o)->isNonnull)();
}

static  void operator_14371( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefToBase<CaloRecHit>*)o)->operator!)());
  else   (((const ::edm::RefToBase<CaloRecHit>*)o)->operator!)();
}

static  void operator_14372( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefToBase<CaloRecHit>*)o)->operator==)(*(const ::edm::RefToBase<CaloRecHit>*)arg[0]));
  else   (((const ::edm::RefToBase<CaloRecHit>*)o)->operator==)(*(const ::edm::RefToBase<CaloRecHit>*)arg[0]);
}

static  void operator_14373( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefToBase<CaloRecHit>*)o)->operator!=)(*(const ::edm::RefToBase<CaloRecHit>*)arg[0]));
  else   (((const ::edm::RefToBase<CaloRecHit>*)o)->operator!=)(*(const ::edm::RefToBase<CaloRecHit>*)arg[0]);
}

static  void method_14374( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefToBase<CaloRecHit>*)o)->swap)(*(::edm::RefToBase<CaloRecHit>*)arg[0]);
}

static  void method_14375( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefHolderBase>)((((const ::edm::RefToBase<CaloRecHit>*)o)->holder)());
  else   (((const ::edm::RefToBase<CaloRecHit>*)o)->holder)();
}

static  void method_14376( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefToBase<CaloRecHit>*)o)->productGetter)());
  else   (((const ::edm::RefToBase<CaloRecHit>*)o)->productGetter)();
}

static  void method_14377( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefToBase<CaloRecHit>*)o)->hasProductCache)());
  else   (((const ::edm::RefToBase<CaloRecHit>*)o)->hasProductCache)();
}

static  void method_14378( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefToBase<CaloRecHit>*)o)->product)());
  else   (((const ::edm::RefToBase<CaloRecHit>*)o)->product)();
}

static  void method_14379( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefToBase<CaloRecHit>*)o)->isAvailable)());
  else   (((const ::edm::RefToBase<CaloRecHit>*)o)->isAvailable)();
}

static  void method_14380( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefToBase<CaloRecHit>*)o)->Class_Version)());
  else   (((::edm::RefToBase<CaloRecHit>*)o)->Class_Version)();
}

static void method_newdel_3420( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefToBase<CaloRecHit> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefToBase<CaloRecHit> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefToBase<CaloRecHit> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefToBase<CaloRecHit> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefToBase<CaloRecHit> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefToBase<CaloRecHit> -------------------------------
void __edm__RefToBase_CaloRecHit__db_datamem(Reflex::Class*);
void __edm__RefToBase_CaloRecHit__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefToBase_CaloRecHit__datamem_bld(&__edm__RefToBase_CaloRecHit__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefToBase_CaloRecHit__funcmem_bld(&__edm__RefToBase_CaloRecHit__db_funcmem);
void __edm__RefToBase_CaloRecHit__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefToBase<CaloRecHit>"), typeid(::edm::RefToBase<CaloRecHit>), sizeof(::edm::RefToBase<CaloRecHit>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefToBase<CaloRecHit>::Class_Version())
  .AddTypedef(type_994, Reflex::Literal("edm::RefToBase<CaloRecHit>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefToBase"), constructor_14357, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_22585), Reflex::Literal("RefToBase"), constructor_14358, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_22586, type_1501), Reflex::Literal("RefToBase"), constructor_14359, 0, "r;i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_22587, type_1501), Reflex::Literal("RefToBase"), constructor_14360, 0, "handle;i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2859), Reflex::Literal("RefToBase"), constructor_14361, 0, "p", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefToBase"), destructor_14362, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3420, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefToBase_CaloRecHit__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefToBase_CaloRecHit__funcmem_bld);
}

//------Delayed data member builder for class RefToBase<CaloRecHit> -------------------
void __edm__RefToBase_CaloRecHit__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_22584, Reflex::Literal("holder_"), OffsetOf(__shadow__::__edm__RefToBase_CaloRecHit_, holder_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefToBase<CaloRecHit> -------------------
void __edm__RefToBase_CaloRecHit__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22588, type_22585), Reflex::Literal("operator="), operator_14363, 0, "iRHS", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3750), Reflex::Literal("operator*"), operator_14364, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7229), Reflex::Literal("operator->"), operator_14365, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7229), Reflex::Literal("get"), method_14366, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3408), Reflex::Literal("id"), method_14367, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1501), Reflex::Literal("key"), method_14368, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2734), Reflex::Literal("isNull"), method_14369, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2734), Reflex::Literal("isNonnull"), method_14370, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2734), Reflex::Literal("operator!"), operator_14371, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2734, type_22585), Reflex::Literal("operator=="), operator_14372, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2734, type_22585), Reflex::Literal("operator!="), operator_14373, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699, type_22588), Reflex::Literal("swap"), method_14374, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2029), Reflex::Literal("holder"), method_14375, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14436), Reflex::Literal("productGetter"), method_14376, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2734), Reflex::Literal("hasProductCache"), method_14377, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2769), Reflex::Literal("product"), method_14378, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2734), Reflex::Literal("isAvailable"), method_14379, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_973), Reflex::Literal("Class_Version"), method_14380, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class CaloID -------------------------------
static void constructor_14964( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::CaloID(*(const ::reco::CaloID*)arg[0]);
  else ::new(mem) ::reco::CaloID(*(const ::reco::CaloID*)arg[0]);
}

static void constructor_14965( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::CaloID();
  else ::new(mem) ::reco::CaloID();
}

static void constructor_14966( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::CaloID(*(::reco::CaloID::Detectors*)arg[0]);
  else ::new(mem) ::reco::CaloID(*(::reco::CaloID::Detectors*)arg[0]);
}

static void destructor_14967(void*, void * o, const std::vector<void*>&, void *) {
(((::reco::CaloID*)o)->::reco::CaloID::~CaloID)();
}
static  void method_14968( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::CaloID*)o)->setDetector)(*(::reco::CaloID::Detectors*)arg[0],
    *(bool*)arg[1]);
}

static  void method_14969( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::reco::CaloID*)o)->detectors)());
  else   (((const ::reco::CaloID*)o)->detectors)();
}

static  void method_14970( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::reco::CaloID*)o)->detector)(*(::reco::CaloID::Detectors*)arg[0]));
  else   (((const ::reco::CaloID*)o)->detector)(*(::reco::CaloID::Detectors*)arg[0]);
}

static  void method_14971( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::reco::CaloID*)o)->isSingleDetector)());
  else   (((const ::reco::CaloID*)o)->isSingleDetector)();
}

static  void method_14972( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::reco::CaloID*)o)->detector)());
  else   (((const ::reco::CaloID*)o)->detector)();
}

static  void operator_14973( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::CaloID*)o)->operator=)(*(const ::reco::CaloID*)arg[0]);
  else   (((::reco::CaloID*)o)->operator=)(*(const ::reco::CaloID*)arg[0]);
}

static void method_newdel_3845( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::reco::CaloID >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::reco::CaloID >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::reco::CaloID >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::reco::CaloID >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::reco::CaloID >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class CaloID -------------------------------
void __reco__CaloID_db_datamem(Reflex::Class*);
void __reco__CaloID_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __reco__CaloID_datamem_bld(&__reco__CaloID_db_datamem);
Reflex::GenreflexMemberBuilder __reco__CaloID_funcmem_bld(&__reco__CaloID_db_funcmem);
void __reco__CaloID_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("reco::CaloID"), typeid(::reco::CaloID), sizeof(::reco::CaloID), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddEnum(Reflex::Literal("reco::CaloID::Detectors"), Reflex::Literal("DET_ECAL_BARREL=0;DET_ECAL_ENDCAP=1;DET_PS1=2;DET_PS2=3;DET_HCAL_BARREL=4;DET_HCAL_ENDCAP=5;DET_HF=6;DET_HF_EM=7;DET_HF_HAD=8;DET_HO=9;DET_NONE=10"), &typeid(reco::CaloID::Detectors), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14909), Reflex::Literal("CaloID"), constructor_14964, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("CaloID"), constructor_14965, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14963), Reflex::Literal("CaloID"), constructor_14966, 0, "det", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~CaloID"), destructor_14967, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3845, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__reco__CaloID_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__reco__CaloID_funcmem_bld);
}

//------Delayed data member builder for class CaloID -------------------
void __reco__CaloID_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_234, Reflex::Literal("detectors_"), OffsetOf(__shadow__::__reco__CaloID, detectors_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class CaloID -------------------
void __reco__CaloID_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699, type_14963, type_2734), Reflex::Literal("setDetector"), method_14968, 0, "theDetector;value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_234), Reflex::Literal("detectors"), method_14969, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2734, type_14963), Reflex::Literal("detector"), method_14970, 0, "theDetector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2734), Reflex::Literal("isSingleDetector"), method_14971, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14963), Reflex::Literal("detector"), method_14972, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22729, type_14909), Reflex::Literal("operator="), operator_14973, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR);
}
//------Stub functions for class BaseHolder<CaloRecHit> -------------------------------
static void destructor_22462(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::BaseHolder<CaloRecHit>*)o)->::edm::reftobase::BaseHolder<CaloRecHit>::~BaseHolder)();
}
static  void method_22463( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::BaseHolder<CaloRecHit>*)o)->clone)());
  else   (((const ::edm::reftobase::BaseHolder<CaloRecHit>*)o)->clone)();
}

static  void method_22464( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::BaseHolder<CaloRecHit>*)o)->swap)(*(::edm::reftobase::BaseHolder<CaloRecHit>*)arg[0]);
}

static  void method_22465( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::BaseHolder<CaloRecHit>*)o)->getPtr)());
  else   (((const ::edm::reftobase::BaseHolder<CaloRecHit>*)o)->getPtr)();
}

static  void method_22466( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::BaseHolder<CaloRecHit>*)o)->id)());
  else   (((const ::edm::reftobase::BaseHolder<CaloRecHit>*)o)->id)();
}

static  void method_22467( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::BaseHolder<CaloRecHit>*)o)->key)());
  else   (((const ::edm::reftobase::BaseHolder<CaloRecHit>*)o)->key)();
}

static  void method_22468( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::BaseHolder<CaloRecHit>*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<CaloRecHit>*)arg[0]));
  else   (((const ::edm::reftobase::BaseHolder<CaloRecHit>*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<CaloRecHit>*)arg[0]);
}

static  void method_22469( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::BaseHolder<CaloRecHit>*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::BaseHolder<CaloRecHit>*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_22470( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefHolderBase>)((((const ::edm::reftobase::BaseHolder<CaloRecHit>*)o)->holder)());
  else   (((const ::edm::reftobase::BaseHolder<CaloRecHit>*)o)->holder)();
}

static  void method_22471( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::BaseVectorHolder<CaloRecHit> >)((((const ::edm::reftobase::BaseHolder<CaloRecHit>*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::BaseHolder<CaloRecHit>*)o)->makeVectorHolder)();
}

static  void method_22472( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::BaseHolder<CaloRecHit>*)o)->makeVectorBaseHolder)());
  else   (((const ::edm::reftobase::BaseHolder<CaloRecHit>*)o)->makeVectorBaseHolder)();
}

static  void method_22473( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::BaseHolder<CaloRecHit>*)o)->productGetter)());
  else   (((const ::edm::reftobase::BaseHolder<CaloRecHit>*)o)->productGetter)();
}

static  void method_22474( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::BaseHolder<CaloRecHit>*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::BaseHolder<CaloRecHit>*)o)->hasProductCache)();
}

static  void method_22475( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::BaseHolder<CaloRecHit>*)o)->product)());
  else   (((const ::edm::reftobase::BaseHolder<CaloRecHit>*)o)->product)();
}

static  void method_22476( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::BaseHolder<CaloRecHit>*)o)->isAvailable)());
  else   (((const ::edm::reftobase::BaseHolder<CaloRecHit>*)o)->isAvailable)();
}

static  void method_22477( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::BaseHolder<CaloRecHit>*)o)->Class_Version)());
  else   (((::edm::reftobase::BaseHolder<CaloRecHit>*)o)->Class_Version)();
}

//------Dictionary for class BaseHolder<CaloRecHit> -------------------------------
void __edm__reftobase__BaseHolder_CaloRecHit__db_datamem(Reflex::Class*);
void __edm__reftobase__BaseHolder_CaloRecHit__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__BaseHolder_CaloRecHit__datamem_bld(&__edm__reftobase__BaseHolder_CaloRecHit__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__BaseHolder_CaloRecHit__funcmem_bld(&__edm__reftobase__BaseHolder_CaloRecHit__db_funcmem);
void __edm__reftobase__BaseHolder_CaloRecHit__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::BaseHolder<CaloRecHit>"), typeid(::edm::reftobase::BaseHolder<CaloRecHit>), sizeof(::edm::reftobase::BaseHolder<CaloRecHit>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::ABSTRACT | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::BaseHolder<CaloRecHit>::Class_Version())
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~BaseHolder"), destructor_22462, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__BaseHolder_CaloRecHit__funcmem_bld);
}

//------Delayed data member builder for class BaseHolder<CaloRecHit> -------------------
void __edm__reftobase__BaseHolder_CaloRecHit__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class BaseHolder<CaloRecHit> -------------------
void __edm__reftobase__BaseHolder_CaloRecHit__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22584), Reflex::Literal("clone"), method_22463, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2699, type_25458), Reflex::Literal("swap"), method_22464, 0, "", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7229), Reflex::Literal("getPtr"), method_22465, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3408), Reflex::Literal("id"), method_22466, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1501), Reflex::Literal("key"), method_22467, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2734, type_25459), Reflex::Literal("isEqualTo"), method_22468, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2734, type_11492, type_4837), Reflex::Literal("fillRefIfMyTypeMatches"), method_22469, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2029), Reflex::Literal("holder"), method_22470, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2028), Reflex::Literal("makeVectorHolder"), method_22471, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2027), Reflex::Literal("makeVectorBaseHolder"), method_22472, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14436), Reflex::Literal("productGetter"), method_22473, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2734), Reflex::Literal("hasProductCache"), method_22474, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2769), Reflex::Literal("product"), method_22475, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2734), Reflex::Literal("isAvailable"), method_22476, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ABSTRACT | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_973), Reflex::Literal("Class_Version"), method_22477, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __CaloRecHit_dict(); 
      __reco__CaloCluster_dict(); 
      __edm__Ptr_reco__CaloCluster__dict(); 
      __std__vector_edm__Ptr_reco__CaloCluster_s__dict(); 
      __std__vector_reco__CaloCluster__dict(); 
      __edm__PtrVector_reco__CaloCluster__dict(); 
      __edm__Wrapper_edm__PtrVector_reco__CaloCluster_s__dict(); 
      __edm__ValueMap_reco__CaloCluster__dict(); 
      __edm__Wrapper_edm__ValueMap_reco__CaloCluster_s__dict(); 
      __edm__Wrapper_std__vector_reco__CaloCluster_s__dict(); 
      __edm__RefToBase_CaloRecHit__dict(); 
      __reco__CaloID_dict(); 
      __edm__reftobase__BaseHolder_CaloRecHit__dict(); 
    }
    ~Dictionaries() {
      type_994.Unload(); // class CaloRecHit 
      type_3844.Unload(); // class reco::CaloCluster 
      type_3424.Unload(); // class edm::Ptr<reco::CaloCluster> 
      type_2249.Unload(); // class std::vector<edm::Ptr<reco::CaloCluster> > 
      type_2251.Unload(); // class std::vector<reco::CaloCluster> 
      type_3335.Unload(); // class edm::PtrVector<reco::CaloCluster> 
      type_3346.Unload(); // class edm::Wrapper<edm::PtrVector<reco::CaloCluster> > 
      type_3445.Unload(); // class edm::ValueMap<reco::CaloCluster> 
      type_3347.Unload(); // class edm::Wrapper<edm::ValueMap<reco::CaloCluster> > 
      type_3348.Unload(); // class edm::Wrapper<std::vector<reco::CaloCluster> > 
      type_3420.Unload(); // class edm::RefToBase<CaloRecHit> 
      type_3845.Unload(); // class reco::CaloID 
      type_14107.Unload(); // class edm::reftobase::BaseHolder<CaloRecHit> 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
