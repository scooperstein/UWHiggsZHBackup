// Generated at Fri Feb 28 12:35:58 2014. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gccxml/20110825/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gccxml/20110825/bin/gccxml_cc1plus"
  GCCXML_CPP="/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gccxml/20110825/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='2' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='1' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.6.2"' -D__UINT64_C(c)='c ## UL' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__GNUC_MINOR__='6' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -iwrapper"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gccxml/20110825/share/gccxml-0.9/GCC/4.6" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../include/c++/4.6.2" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../include/c++/4.6.2/x86_64-unknown-linux-gnu" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../include/c++/4.6.2/backward" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/include" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/include-fixed" -isystem"/usr/local/include" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gccxml/20110825/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.6.2
Copyright (C) 2011 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "/afs/hep.wisc.edu/user/stephane/sync_setup/src/DataFormats/StdDictionaries/src/classes.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("__gnu_cxx") );
  ::Reflex::Type type_22 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_48 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_2083 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_113 = ::Reflex::TypeBuilder(Reflex::Literal("short"));
  ::Reflex::Type type_2150 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_2616 = ::Reflex::TypeBuilder(Reflex::Literal("char"));
  ::Reflex::Type type_2058 = ::Reflex::TypeBuilder(Reflex::Literal("float"));
  ::Reflex::Type type_2052 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_2087 = ::Reflex::TypeBuilder(Reflex::Literal("long long"));
  ::Reflex::Type type_78 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_75 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_2059 = ::Reflex::TypeBuilder(Reflex::Literal("long double"));
  ::Reflex::Type type_528 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned char"));
  ::Reflex::Type type_167 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned short"));
  ::Reflex::Type type_1586 = ::Reflex::TypeBuilder(Reflex::Literal("std::set<int>"));
  ::Reflex::Type type_2024 = ::Reflex::TypeBuilder(Reflex::Literal("std::less<int>"));
  ::Reflex::Type type_1603 = ::Reflex::TypeBuilder(Reflex::Literal("std::list<int>"));
  ::Reflex::Type type_1929 = ::Reflex::TypeBuilder(Reflex::Literal("std::bitset<7>"));
  ::Reflex::Type type_1888 = ::Reflex::TypeBuilder(Reflex::Literal("std::deque<int>"));
  ::Reflex::Type type_1061 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<int>"));
  ::Reflex::Type type_2022 = ::Reflex::TypeBuilder(Reflex::Literal("std::less<short>"));
  ::Reflex::Type type_825 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<int,int>"));
  ::Reflex::Type type_1087 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<long>"));
  ::Reflex::Type type_1090 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<char>"));
  ::Reflex::Type type_1092 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<bool>"));
  ::Reflex::Type type_1650 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<int,int>"));
  ::Reflex::Type type_2025 = ::Reflex::TypeBuilder(Reflex::Literal("std::less<double>"));
  ::Reflex::Type type_2144 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long long"));
  ::Reflex::Type type_1065 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<short>"));
  ::Reflex::Type type_1067 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<float>"));
  ::Reflex::Type type_1091 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<char*>"));
  ::Reflex::Type type_1297 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Bit_iterator"));
  ::Reflex::Type type_1069 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<double>"));
  ::Reflex::Type type_1339 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<int>"));
  ::Reflex::Type type_1110 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Bit_reference"));
  ::Reflex::Type type_812 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<int,double>"));
  ::Reflex::Type type_1350 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<char>"));
  ::Reflex::Type type_1367 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<long>"));
  ::Reflex::Type type_1371 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<bool>"));
  ::Reflex::Type type_1287 = ::Reflex::TypeBuilder(Reflex::Literal("std::_List_node<int>"));
  ::Reflex::Type type_2044 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Base_bitset<1>"));
  ::Reflex::Type type_826 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<float,float>"));
  ::Reflex::Type type_851 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<short,short>"));
  ::Reflex::Type type_1343 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<short>"));
  ::Reflex::Type type_1345 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<float>"));
  ::Reflex::Type type_1614 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<short,short>"));
  ::Reflex::Type type_1370 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<char*>"));
  ::Reflex::Type type_1347 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<double>"));
  ::Reflex::Type type_1605 = ::Reflex::TypeBuilder(Reflex::Literal("std::char_traits<char>"));
  ::Reflex::Type type_1088 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<long long>"));
  ::Reflex::Type type_1104 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_827 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<double,double>"));
  ::Reflex::Type type_896 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const int,int>"));
  ::Reflex::Type type_1018 = ::Reflex::TypeBuilder(Reflex::Literal("std::input_iterator_tag"));
  ::Reflex::Type type_2029 = ::Reflex::TypeBuilder(Reflex::Literal("std::less<unsigned int>"));
  ::Reflex::Type type_1049 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const void*>"));
  ::Reflex::Type type_1089 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<long double>"));
  ::Reflex::Type type_1886 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Bit_const_iterator"));
  ::Reflex::Type type_1589 = ::Reflex::TypeBuilder(Reflex::Literal("std::output_iterator_tag"));
  ::Reflex::Type type_2041 = ::Reflex::TypeBuilder(Reflex::Literal("std::_List_iterator<int>"));
  ::Reflex::Type type_2027 = ::Reflex::TypeBuilder(Reflex::Literal("std::less<unsigned long>"));
  ::Reflex::Type type_1054 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned int>"));
  ::Reflex::Type type_1368 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<long long>"));
  ::Reflex::Type type_1292 = ::Reflex::TypeBuilder(Reflex::Literal("std::forward_iterator_tag"));
  ::Reflex::Type type_2026 = ::Reflex::TypeBuilder(Reflex::Literal("std::less<unsigned short>"));
  ::Reflex::Type type_815 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<unsigned int,int>"));
  ::Reflex::Type type_1052 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long>"));
  ::Reflex::Type type_861 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<int,unsigned int>"));
  ::Reflex::Type type_1055 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned char>"));
  ::Reflex::Type type_1630 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,int>"));
  ::Reflex::Type type_1646 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<int,unsigned int>"));
  ::Reflex::Type type_16133 = ::Reflex::TypeBuilder(Reflex::Literal("std::bitset<7>::reference"));
  ::Reflex::Type type_818 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<unsigned int,bool>"));
  ::Reflex::Type type_828 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const short,short>"));
  ::Reflex::Type type_1051 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned short>"));
  ::Reflex::Type type_1327 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<const void*>"));
  ::Reflex::Type type_1056 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned char*>"));
  ::Reflex::Type type_1369 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<long double>"));
  ::Reflex::Type type_1633 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,bool>"));
  ::Reflex::Type type_816 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<unsigned int,float>"));
  ::Reflex::Type type_848 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<unsigned int,short>"));
  ::Reflex::Type type_860 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<short,unsigned int>"));
  ::Reflex::Type type_1332 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<unsigned int>"));
  ::Reflex::Type type_1629 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,short>"));
  ::Reflex::Type type_1631 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,float>"));
  ::Reflex::Type type_1645 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<short,unsigned int>"));
  ::Reflex::Type type_2039 = ::Reflex::TypeBuilder(Reflex::Literal("std::multimap<double,double>"));
  ::Reflex::Type type_817 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<unsigned int,double>"));
  ::Reflex::Type type_1330 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<unsigned long>"));
  ::Reflex::Type type_1333 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<unsigned char>"));
  ::Reflex::Type type_2280 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<int>"));
  ::Reflex::Type type_798 = ::Reflex::TypeBuilder(Reflex::Literal("std::_List_const_iterator<int>"));
  ::Reflex::Type type_2028 = ::Reflex::TypeBuilder(Reflex::Literal("std::less<unsigned long long>"));
  ::Reflex::Type type_1632 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,double>"));
  ::Reflex::Type type_898 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const double,double>"));
  ::Reflex::Type type_839 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<unsigned short,float>"));
  ::Reflex::Type type_1329 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<unsigned short>"));
  ::Reflex::Type type_1334 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<unsigned char*>"));
  ::Reflex::Type type_1060 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::vector<int> >"));
  ::Reflex::Type type_2283 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<char>"));
  ::Reflex::Type type_1618 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned short,float>"));
  ::Reflex::Type type_2031 = ::Reflex::TypeBuilder(Reflex::Literal("std::less<std::pair<int,int> >"));
  ::Reflex::Type type_1053 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long long>"));
  ::Reflex::Type type_2006 = ::Reflex::TypeBuilder(Reflex::Literal("std::bidirectional_iterator_tag"));
  ::Reflex::Type type_1326 = ::Reflex::TypeBuilder(Reflex::Literal("std::random_access_iterator_tag"));
  ::Reflex::Type type_2279 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<short>"));
  ::Reflex::Type type_852 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::pair<int,int>,int>"));
  ::Reflex::Type type_878 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned int,int>"));
  ::Reflex::Type type_892 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const int,unsigned int>"));
  ::Reflex::Type type_1064 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::vector<short> >"));
  ::Reflex::Type type_1066 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::vector<float> >"));
  ::Reflex::Type type_1083 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<int,int> >"));
  ::Reflex::Type type_2281 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<double>"));
  ::Reflex::Type type_1635 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::pair<int,int>,int>"));
  ::Reflex::Type type_881 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned int,bool>"));
  ::Reflex::Type type_1338 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::vector<int> >"));
  ::Reflex::Type type_1068 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::vector<double> >"));
  ::Reflex::Type type_1890 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<int>"));
  ::Reflex::Type type_877 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned int,short>"));
  ::Reflex::Type type_879 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned int,float>"));
  ::Reflex::Type type_891 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const short,unsigned int>"));
  ::Reflex::Type type_1331 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<unsigned long long>"));
  ::Reflex::Type type_1585 = ::Reflex::TypeBuilder(Reflex::Literal("std::set<std::basic_string<char> >"));
  ::Reflex::Type type_2030 = ::Reflex::TypeBuilder(Reflex::Literal("std::less<std::pair<short,short> >"));
  ::Reflex::Type type_1664 = ::Reflex::TypeBuilder(Reflex::Literal("std::binary_function<int,int,bool>"));
  ::Reflex::Type type_814 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<unsigned int,unsigned int>"));
  ::Reflex::Type type_850 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<short,std::vector<short> >"));
  ::Reflex::Type type_880 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned int,double>"));
  ::Reflex::Type type_1063 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<int,double> >"));
  ::Reflex::Type type_1342 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::vector<short> >"));
  ::Reflex::Type type_1344 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::vector<float> >"));
  ::Reflex::Type type_1362 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<int,int> >"));
  ::Reflex::Type type_1086 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::map<short,short> >"));
  ::Reflex::Type type_2023 = ::Reflex::TypeBuilder(Reflex::Literal("std::less<std::basic_string<char> >"));
  ::Reflex::Type type_1622 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,unsigned int>"));
  ::Reflex::Type type_1636 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::pair<int,int>,double>"));
  ::Reflex::Type type_1309 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Deque_iterator<int,int&,int*>"));
  ::Reflex::Type type_842 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<unsigned int,unsigned long>"));
  ::Reflex::Type type_867 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned short,float>"));
  ::Reflex::Type type_1346 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::vector<double> >"));
  ::Reflex::Type type_1084 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<float,float> >"));
  ::Reflex::Type type_820 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<double,std::vector<double> >"));
  ::Reflex::Type type_821 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,int>"));
  ::Reflex::Type type_840 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<unsigned long,unsigned long>"));
  ::Reflex::Type type_1070 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::basic_string<char> >"));
  ::Reflex::Type type_6481 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>::_Alloc_hider"));
  ::Reflex::Type type_1619 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned long,unsigned long>"));
  ::Reflex::Type type_1643 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,int>"));
  ::Reflex::Type type_824 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,bool>"));
  ::Reflex::Type type_883 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const std::pair<int,int>,int>"));
  ::Reflex::Type type_1341 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<int,double> >"));
  ::Reflex::Type type_1085 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<double,double> >"));
  ::Reflex::Type type_1365 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::map<short,short> >"));
  ::Reflex::Type type_1644 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,bool>"));
  ::Reflex::Type type_822 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,float>"));
  ::Reflex::Type type_837 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<unsigned short,unsigned short>"));
  ::Reflex::Type type_864 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<int,std::pair<double,double> >"));
  ::Reflex::Type type_1058 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::vector<unsigned int> >"));
  ::Reflex::Type type_1363 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<float,float> >"));
  ::Reflex::Type type_1616 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned short,unsigned short>"));
  ::Reflex::Type type_1649 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<int,std::pair<double,double> >"));
  ::Reflex::Type type_823 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,double>"));
  ::Reflex::Type type_1348 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::basic_string<char> >"));
  ::Reflex::Type type_871 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned int,unsigned int>"));
  ::Reflex::Type type_1057 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::vector<unsigned short> >"));
  ::Reflex::Type type_1073 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<unsigned int,int> >"));
  ::Reflex::Type type_1364 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<double,double> >"));
  ::Reflex::Type type_1588 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Bvector_base<std::allocator<bool> >"));
  ::Reflex::Type type_1773 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Bit_iterator>"));
  ::Reflex::Type type_1191 = ::Reflex::TypeBuilder(Reflex::Literal("std::_List_base<int,std::allocator<int> >"));
  ::Reflex::Type type_966 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const std::pair<int,int>,double>"));
  ::Reflex::Type type_1448 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const int,int> >"));
  ::Reflex::Type type_1076 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<unsigned int,bool> >"));
  ::Reflex::Type type_1336 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::vector<unsigned int> >"));
  ::Reflex::Type type_1311 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Deque_base<int,std::allocator<int> >"));
  ::Reflex::Type type_868 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned long,unsigned long>"));
  ::Reflex::Type type_889 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const std::basic_string<char>,int>"));
  ::Reflex::Type type_1975 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<int,std::allocator<int> >"));
  ::Reflex::Type type_1074 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<unsigned int,float> >"));
  ::Reflex::Type type_1075 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<unsigned int,double> >"));
  ::Reflex::Type type_890 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const std::basic_string<char>,bool>"));
  ::Reflex::Type type_1335 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::vector<unsigned short> >"));
  ::Reflex::Type type_1059 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::vector<std::vector<int> > >"));
  ::Reflex::Type type_1352 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<unsigned int,int> >"));
  ::Reflex::Type type_865 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned short,unsigned short>"));
  ::Reflex::Type type_895 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const int,std::pair<double,double> >"));
  ::Reflex::Type type_1355 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<unsigned int,bool> >"));
  ::Reflex::Type type_1366 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const short,short> >"));
  ::Reflex::Type type_1972 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<long,std::allocator<long> >"));
  ::Reflex::Type type_1977 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<char,std::allocator<char> >"));
  ::Reflex::Type type_853 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,unsigned int>"));
  ::Reflex::Type type_1353 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<unsigned int,float> >"));
  ::Reflex::Type type_1638 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,unsigned int>"));
  ::Reflex::Type type_1038 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator_traits<std::basic_string<char>*>"));
  ::Reflex::Type type_847 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<unsigned int,std::basic_string<char> >"));
  ::Reflex::Type type_1337 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::vector<std::vector<int> > >"));
  ::Reflex::Type type_1986 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<short,std::allocator<short> >"));
  ::Reflex::Type type_1976 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<float,std::allocator<float> >"));
  ::Reflex::Type type_1354 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<unsigned int,double> >"));
  ::Reflex::Type type_1978 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<char*,std::allocator<char*> >"));
  ::Reflex::Type type_1772 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Bit_const_iterator>"));
  ::Reflex::Type type_1628 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,std::basic_string<char> >"));
  ::Reflex::Type type_1637 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,unsigned long>"));
  ::Reflex::Type type_1310 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Deque_iterator<int,const int&,const int*>"));
  ::Reflex::Type type_1376 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const double,double> >"));
  ::Reflex::Type type_834 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<int>,bool>"));
  ::Reflex::Type type_1875 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_List_iterator<int> >"));
  ::Reflex::Type type_843 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<unsigned int,std::vector<unsigned int> >"));
  ::Reflex::Type type_1062 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::vector<std::pair<int,double> > >"));
  ::Reflex::Type type_1980 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<double,std::allocator<double> >"));
  ::Reflex::Type type_1623 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,std::vector<unsigned int> >"));
  ::Reflex::Type type_1286 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const int,int> >"));
  ::Reflex::Type type_1072 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<unsigned int,unsigned int> >"));
  ::Reflex::Type type_1406 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned int,int> >"));
  ::Reflex::Type type_1440 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const int,unsigned int> >"));
  ::Reflex::Type type_841 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<unsigned long,std::vector<unsigned long> >"));
  ::Reflex::Type type_863 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<int,std::pair<unsigned int,unsigned int> >"));
  ::Reflex::Type type_1620 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned long,std::vector<unsigned long> >"));
  ::Reflex::Type type_1412 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned int,bool> >"));
  ::Reflex::Type type_1648 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<int,std::pair<unsigned int,unsigned int> >"));
  ::Reflex::Type type_1078 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<double,std::vector<double> > >"));
  ::Reflex::Type type_884 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const std::basic_string<char>,unsigned int>"));
  ::Reflex::Type type_2371 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<int*,std::vector<int> >"));
  ::Reflex::Type type_1340 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::vector<std::pair<int,double> > >"));
  ::Reflex::Type type_1079 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >"));
  ::Reflex::Type type_1404 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned int,short> >"));
  ::Reflex::Type type_1408 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned int,float> >"));
  ::Reflex::Type type_1437 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const short,unsigned int> >"));
  ::Reflex::Type type_813 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<unsigned long long,std::basic_string<char> >"));
  ::Reflex::Type type_838 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<unsigned short,std::vector<unsigned short> >"));
  ::Reflex::Type type_862 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<int,std::pair<unsigned long,unsigned long> >"));
  ::Reflex::Type type_876 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned int,std::basic_string<char> >"));
  ::Reflex::Type type_1351 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<unsigned int,unsigned int> >"));
  ::Reflex::Type type_1082 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,bool> >"));
  ::Reflex::Type type_1281 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const short,short> >"));
  ::Reflex::Type type_1617 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned short,std::vector<unsigned short> >"));
  ::Reflex::Type type_1621 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned long long,std::basic_string<char> >"));
  ::Reflex::Type type_1410 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned int,double> >"));
  ::Reflex::Type type_970 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const std::basic_string<char>,unsigned long>"));
  ::Reflex::Type type_1647 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<int,std::pair<unsigned long,unsigned long> >"));
  ::Reflex::Type type_1080 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,float> >"));
  ::Reflex::Type type_2365 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<long*,std::vector<long> >"));
  ::Reflex::Type type_2376 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<char*,std::vector<char> >"));
  ::Reflex::Type type_1889 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::basic_string<char> >"));
  ::Reflex::Type type_1874 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_List_const_iterator<int> >"));
  ::Reflex::Type type_1382 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned short,float> >"));
  ::Reflex::Type type_1081 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,double> >"));
  ::Reflex::Type type_872 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned int,std::vector<unsigned int> >"));
  ::Reflex::Type type_1357 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<double,std::vector<double> > >"));
  ::Reflex::Type type_1358 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<std::basic_string<char>,int> >"));
  ::Reflex::Type type_1973 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<long long,std::allocator<long long> >"));
  ::Reflex::Type type_1928 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const int,int> >"));
  ::Reflex::Type type_1249 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const double,double> >"));
  ::Reflex::Type type_2364 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<short*,std::vector<short> >"));
  ::Reflex::Type type_2373 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<float*,std::vector<float> >"));
  ::Reflex::Type type_1361 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<std::basic_string<char>,bool> >"));
  ::Reflex::Type type_2378 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<char**,std::vector<char*> >"));
  ::Reflex::Type type_1417 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const std::pair<int,int>,int> >"));
  ::Reflex::Type type_869 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned long,std::vector<unsigned long> >"));
  ::Reflex::Type type_894 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const int,std::pair<unsigned int,unsigned int> >"));
  ::Reflex::Type type_1359 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<std::basic_string<char>,float> >"));
  ::Reflex::Type type_1776 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<int> >"));
  ::Reflex::Type type_1615 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,std::basic_string<char> >"));
  ::Reflex::Type type_859 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,std::basic_string<char> >"));
  ::Reflex::Type type_2372 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const int*,std::vector<int> >"));
  ::Reflex::Type type_2375 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<double*,std::vector<double> >"));
  ::Reflex::Type type_1360 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<std::basic_string<char>,double> >"));
  ::Reflex::Type type_1264 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,int> >"));
  ::Reflex::Type type_1282 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const int,unsigned int> >"));
  ::Reflex::Type type_866 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned short,std::vector<unsigned short> >"));
  ::Reflex::Type type_870 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned long long,std::basic_string<char> >"));
  ::Reflex::Type type_893 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const int,std::pair<unsigned long,unsigned long> >"));
  ::Reflex::Type type_1946 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<const void*,std::allocator<const void*> >"));
  ::Reflex::Type type_1923 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const short,short> >"));
  ::Reflex::Type type_1974 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<long double,std::allocator<long double> >"));
  ::Reflex::Type type_1390 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned int,unsigned int> >"));
  ::Reflex::Type type_1267 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,bool> >"));
  ::Reflex::Type type_1419 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const std::pair<int,int>,double> >"));
  ::Reflex::Type type_1877 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Deque_iterator<int,int&,int*> >"));
  ::Reflex::Type type_846 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<unsigned int,std::pair<unsigned int,unsigned int> >"));
  ::Reflex::Type type_2396 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >"));
  ::Reflex::Type type_2366 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const long*,std::vector<long> >"));
  ::Reflex::Type type_2377 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const char*,std::vector<char> >"));
  ::Reflex::Type type_1627 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,std::pair<unsigned int,unsigned int> >"));
  ::Reflex::Type type_1263 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,short> >"));
  ::Reflex::Type type_1265 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,float> >"));
  ::Reflex::Type type_1280 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const short,unsigned int> >"));
  ::Reflex::Type type_1983 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<unsigned int,std::allocator<unsigned int> >"));
  ::Reflex::Type type_1384 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned long,unsigned long> >"));
  ::Reflex::Type type_1266 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,double> >"));
  ::Reflex::Type type_1433 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const std::basic_string<char>,int> >"));
  ::Reflex::Type type_1891 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const double,double> >"));
  ::Reflex::Type type_2390 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const short*,std::vector<short> >"));
  ::Reflex::Type type_2374 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const float*,std::vector<float> >"));
  ::Reflex::Type type_2379 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<char* const*,std::vector<char*> >"));
  ::Reflex::Type type_1252 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned short,float> >"));
  ::Reflex::Type type_1435 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const std::basic_string<char>,bool> >"));
  ::Reflex::Type type_1982 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<unsigned long,std::allocator<unsigned long> >"));
  ::Reflex::Type type_1949 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<unsigned char,std::allocator<unsigned char> >"));
  ::Reflex::Type type_1378 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned short,unsigned short> >"));
  ::Reflex::Type type_1446 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const int,std::pair<double,double> > >"));
  ::Reflex::Type type_858 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const std::basic_string<char>,std::basic_string<char> >"));
  ::Reflex::Type type_2382 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const double*,std::vector<double> >"));
  ::Reflex::Type type_2367 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >"));
  ::Reflex::Type type_1906 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,int> >"));
  ::Reflex::Type type_1270 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,int> >"));
  ::Reflex::Type type_1924 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const int,unsigned int> >"));
  ::Reflex::Type type_1981 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<unsigned short,std::allocator<unsigned short> >"));
  ::Reflex::Type type_1950 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<unsigned char*,std::allocator<unsigned char*> >"));
  ::Reflex::Type type_1909 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,bool> >"));
  ::Reflex::Type type_1014 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const int,int> >,bool>"));
  ::Reflex::Type type_845 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<unsigned int,std::vector<std::pair<unsigned int,bool> > >"));
  ::Reflex::Type type_875 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned int,std::pair<unsigned int,unsigned int> >"));
  ::Reflex::Type type_2397 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >"));
  ::Reflex::Type type_1626 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >"));
  ::Reflex::Type type_1905 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,short> >"));
  ::Reflex::Type type_1907 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,float> >"));
  ::Reflex::Type type_1922 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const short,unsigned int> >"));
  ::Reflex::Type type_819 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>"));
  ::Reflex::Type type_1256 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,unsigned int> >"));
  ::Reflex::Type type_1624 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >"));
  ::Reflex::Type type_1908 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,double> >"));
  ::Reflex::Type type_1271 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,double> >"));
  ::Reflex::Type type_844 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<unsigned int,std::vector<std::pair<unsigned int,double> > >"));
  ::Reflex::Type type_2308 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const void**,std::vector<const void*> >"));
  ::Reflex::Type type_1071 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<unsigned long long,std::basic_string<char> > >"));
  ::Reflex::Type type_999 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const short,short> >,bool>"));
  ::Reflex::Type type_2369 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<long double*,std::vector<long double> >"));
  ::Reflex::Type type_1894 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned short,float> >"));
  ::Reflex::Type type_1625 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >"));
  ::Reflex::Type type_830 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::basic_string<char> >,bool>"));
  ::Reflex::Type type_1253 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned long,unsigned long> >"));
  ::Reflex::Type type_1278 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,int> >"));
  ::Reflex::Type type_849 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::pair<short,short>,std::pair<short,std::vector<short> > >"));
  ::Reflex::Type type_2316 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >"));
  ::Reflex::Type type_1956 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::vector<int>,std::allocator<std::vector<int> > >"));
  ::Reflex::Type type_2368 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const long long*,std::vector<long long> >"));
  ::Reflex::Type type_1634 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >"));
  ::Reflex::Type type_1912 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const std::pair<int,int>,int> >"));
  ::Reflex::Type type_1423 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const std::basic_string<char>,unsigned int> >"));
  ::Reflex::Type type_1279 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,bool> >"));
  ::Reflex::Type type_856 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,std::pair<unsigned int,unsigned int> >"));
  ::Reflex::Type type_1349 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<unsigned long long,std::basic_string<char> > >"));
  ::Reflex::Type type_1250 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned short,unsigned short> >"));
  ::Reflex::Type type_1402 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned int,std::basic_string<char> > >"));
  ::Reflex::Type type_1421 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const std::basic_string<char>,unsigned long> >"));
  ::Reflex::Type type_1641 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >"));
  ::Reflex::Type type_1285 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const int,std::pair<double,double> > >"));
  ::Reflex::Type type_1876 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Deque_iterator<int,const int&,const int*> >"));
  ::Reflex::Type type_855 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,std::vector<std::basic_string<char> > >"));
  ::Reflex::Type type_874 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > >"));
  ::Reflex::Type type_2313 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >"));
  ::Reflex::Type type_2317 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >"));
  ::Reflex::Type type_1640 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >"));
  ::Reflex::Type type_1948 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<unsigned long long,std::allocator<unsigned long long> >"));
  ::Reflex::Type type_1898 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,unsigned int> >"));
  ::Reflex::Type type_1392 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned int,std::vector<unsigned int> > >"));
  ::Reflex::Type type_926 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > >"));
  ::Reflex::Type type_946 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,int> >,bool>"));
  ::Reflex::Type type_1913 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const std::pair<int,int>,double> >"));
  ::Reflex::Type type_1873 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const int,int> > >"));
  ::Reflex::Type type_873 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > >"));
  ::Reflex::Type type_2309 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const void* const*,std::vector<const void*> >"));
  ::Reflex::Type type_2312 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >"));
  ::Reflex::Type type_2319 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<unsigned char**,std::vector<unsigned char*> >"));
  ::Reflex::Type type_1955 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::vector<short>,std::allocator<std::vector<short> > >"));
  ::Reflex::Type type_1957 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::vector<float>,std::allocator<std::vector<float> > >"));
  ::Reflex::Type type_1967 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<int,int>,std::allocator<std::pair<int,int> > >"));
  ::Reflex::Type type_2370 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const long double*,std::vector<long double> >"));
  ::Reflex::Type type_955 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,bool> >,bool>"));
  ::Reflex::Type type_1002 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const int,unsigned int> >,bool>"));
  ::Reflex::Type type_1895 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned long,unsigned long> >"));
  ::Reflex::Type type_1386 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned long,std::vector<unsigned long> > >"));
  ::Reflex::Type type_943 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,short> >,bool>"));
  ::Reflex::Type type_949 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,float> >,bool>"));
  ::Reflex::Type type_1920 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,int> >"));
  ::Reflex::Type type_996 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const short,unsigned int> >,bool>"));
  ::Reflex::Type type_1444 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const int,std::pair<unsigned int,unsigned int> > >"));
  ::Reflex::Type type_882 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > >"));
  ::Reflex::Type type_2385 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> >"));
  ::Reflex::Type type_1765 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<int*,std::vector<int> > >"));
  ::Reflex::Type type_1958 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::vector<double>,std::allocator<std::vector<double> > >"));
  ::Reflex::Type type_952 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,double> >,bool>"));
  ::Reflex::Type type_1921 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,bool> >"));
  ::Reflex::Type type_887 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> >"));
  ::Reflex::Type type_1863 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const short,short> > >"));
  ::Reflex::Type type_1892 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned short,unsigned short> >"));
  ::Reflex::Type type_1380 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned short,std::vector<unsigned short> > >"));
  ::Reflex::Type type_909 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned short,float> >,bool>"));
  ::Reflex::Type type_1388 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned long long,std::basic_string<char> > >"));
  ::Reflex::Type type_1442 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const int,std::pair<unsigned long,unsigned long> > >"));
  ::Reflex::Type type_1927 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const int,std::pair<double,double> > >"));
  ::Reflex::Type type_886 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > >"));
  ::Reflex::Type type_2384 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const unsigned long*,std::vector<unsigned long> >"));
  ::Reflex::Type type_2318 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const unsigned char*,std::vector<unsigned char> >"));
  ::Reflex::Type type_1759 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<long*,std::vector<long> > >"));
  ::Reflex::Type type_1769 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<char*,std::vector<char> > >"));
  ::Reflex::Type type_1774 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::basic_string<char> > >"));
  ::Reflex::Type type_1112 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<int,int,std::_Identity<int>,std::less<int>,std::allocator<int> >"));
  ::Reflex::Type type_833 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<int>,std::_Rb_tree_const_iterator<int> >"));
  ::Reflex::Type type_1273 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,unsigned int> >"));
  ::Reflex::Type type_2331 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >"));
  ::Reflex::Type type_1262 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >"));
  ::Reflex::Type type_964 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,int> >,bool>"));
  ::Reflex::Type type_1272 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,unsigned long> >"));
  ::Reflex::Type type_1872 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const int,int> > >"));
  ::Reflex::Type type_1799 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const double,double> > >"));
  ::Reflex::Type type_2383 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const unsigned short*,std::vector<unsigned short> >"));
  ::Reflex::Type type_2320 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<unsigned char* const*,std::vector<unsigned char*> >"));
  ::Reflex::Type type_1968 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<int,double>,std::allocator<std::pair<int,double> > >"));
  ::Reflex::Type type_1793 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<short*,std::vector<short> > >"));
  ::Reflex::Type type_1767 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<float*,std::vector<float> > >"));
  ::Reflex::Type type_1971 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::map<short,short>,std::allocator<std::map<short,short> > >"));
  ::Reflex::Type type_1771 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<char**,std::vector<char*> > >"));
  ::Reflex::Type type_1257 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<unsigned int> > >"));
  ::Reflex::Type type_2314 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >"));
  ::Reflex::Type type_1764 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const int*,std::vector<int> > >"));
  ::Reflex::Type type_1781 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<double*,std::vector<double> > >"));
  ::Reflex::Type type_1077 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >"));
  ::Reflex::Type type_1969 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<float,float>,std::allocator<std::pair<float,float> > >"));
  ::Reflex::Type type_1374 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const std::basic_string<char>,std::basic_string<char> > >"));
  ::Reflex::Type type_921 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,unsigned int> >,bool>"));
  ::Reflex::Type type_1829 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned int,int> > >"));
  ::Reflex::Type type_968 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,double> >,bool>"));
  ::Reflex::Type type_1865 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const int,unsigned int> > >"));
  ::Reflex::Type type_2329 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::vector<short>*,std::vector<std::vector<short> > >"));
  ::Reflex::Type type_2333 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::vector<float>*,std::vector<std::vector<float> > >"));
  ::Reflex::Type type_2354 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::pair<int,int>*,std::vector<std::pair<int,int> > >"));
  ::Reflex::Type type_1862 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const short,short> > >"));
  ::Reflex::Type type_1254 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned long,std::vector<unsigned long> > >"));
  ::Reflex::Type type_1835 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned int,bool> > >"));
  ::Reflex::Type type_1284 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const int,std::pair<unsigned int,unsigned int> > >"));
  ::Reflex::Type type_1881 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<char*,std::basic_string<char> > >"));
  ::Reflex::Type type_1988 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::basic_string<char>,std::allocator<std::basic_string<char> > >"));
  ::Reflex::Type type_1758 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const long*,std::vector<long> > >"));
  ::Reflex::Type type_1768 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const char*,std::vector<char> > >"));
  ::Reflex::Type type_912 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned long,unsigned long> >,bool>"));
  ::Reflex::Type type_1400 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > >"));
  ::Reflex::Type type_1827 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned int,short> > >"));
  ::Reflex::Type type_1831 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned int,float> > >"));
  ::Reflex::Type type_1915 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,unsigned int> >"));
  ::Reflex::Type type_990 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,int> >,bool>"));
  ::Reflex::Type type_1861 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const short,unsigned int> > >"));
  ::Reflex::Type type_2332 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::vector<int>*,std::vector<std::vector<int> > >"));
  ::Reflex::Type type_2335 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >"));
  ::Reflex::Type type_1356 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >"));
  ::Reflex::Type type_1251 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned short,std::vector<unsigned short> > >"));
  ::Reflex::Type type_1255 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned long long,std::basic_string<char> > >"));
  ::Reflex::Type type_1904 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >"));
  ::Reflex::Type type_1833 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned int,double> > >"));
  ::Reflex::Type type_1914 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,unsigned long> >"));
  ::Reflex::Type type_993 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,bool> >,bool>"));
  ::Reflex::Type type_1283 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const int,std::pair<unsigned long,unsigned long> > >"));
  ::Reflex::Type type_1798 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const double,double> > >"));
  ::Reflex::Type type_1792 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const short*,std::vector<short> > >"));
  ::Reflex::Type type_1766 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const float*,std::vector<float> > >"));
  ::Reflex::Type type_1970 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<double,double>,std::allocator<std::pair<double,double> > >"));
  ::Reflex::Type type_1770 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<char* const*,std::vector<char*> > >"));
  ::Reflex::Type type_903 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned short,unsigned short> >,bool>"));
  ::Reflex::Type type_1805 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned short,float> > >"));
  ::Reflex::Type type_1899 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<unsigned int> > >"));
  ::Reflex::Type type_1011 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const int,std::pair<double,double> > >,bool>"));
  ::Reflex::Type type_2315 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const unsigned long long*,std::vector<unsigned long long> >"));
  ::Reflex::Type type_1952 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::vector<unsigned int>,std::allocator<std::vector<unsigned int> > >"));
  ::Reflex::Type type_1780 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const double*,std::vector<double> > >"));
  ::Reflex::Type type_1761 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<long long*,std::vector<long long> > >"));
  ::Reflex::Type type_1828 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned int,int> > >"));
  ::Reflex::Type type_1841 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,int> > >"));
  ::Reflex::Type type_1864 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const int,unsigned int> > >"));
  ::Reflex::Type type_2356 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::pair<int,double>*,std::vector<std::pair<int,double> > >"));
  ::Reflex::Type type_2330 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::vector<short>*,std::vector<std::vector<short> > >"));
  ::Reflex::Type type_2334 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::vector<float>*,std::vector<std::vector<float> > >"));
  ::Reflex::Type type_2355 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::pair<int,int>*,std::vector<std::pair<int,int> > >"));
  ::Reflex::Type type_2362 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::map<short,short>*,std::vector<std::map<short,short> > >"));
  ::Reflex::Type type_1896 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned long,std::vector<unsigned long> > >"));
  ::Reflex::Type type_1834 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned int,bool> > >"));
  ::Reflex::Type type_1926 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const int,std::pair<unsigned int,unsigned int> > >"));
  ::Reflex::Type type_854 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >"));
  ::Reflex::Type type_1880 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> > >"));
  ::Reflex::Type type_1268 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::basic_string<char> > >"));
  ::Reflex::Type type_1398 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > >"));
  ::Reflex::Type type_1826 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned int,short> > >"));
  ::Reflex::Type type_1830 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned int,float> > >"));
  ::Reflex::Type type_1639 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >"));
  ::Reflex::Type type_1860 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const short,unsigned int> > >"));
  ::Reflex::Type type_2336 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::vector<double>*,std::vector<std::vector<double> > >"));
  ::Reflex::Type type_2358 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::pair<float,float>*,std::vector<std::pair<float,float> > >"));
  ::Reflex::Type type_1893 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned short,std::vector<unsigned short> > >"));
  ::Reflex::Type type_1897 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned long long,std::basic_string<char> > >"));
  ::Reflex::Type type_1813 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned int,unsigned int> > >"));
  ::Reflex::Type type_1394 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > > >"));
  ::Reflex::Type type_1832 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned int,double> > >"));
  ::Reflex::Type type_1843 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,double> > >"));
  ::Reflex::Type type_1925 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const int,std::pair<unsigned long,unsigned long> > >"));
  ::Reflex::Type type_1707 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const void**,std::vector<const void*> > >"));
  ::Reflex::Type type_1951 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::vector<unsigned short>,std::allocator<std::vector<unsigned short> > >"));
  ::Reflex::Type type_1961 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<unsigned int,int>,std::allocator<std::pair<unsigned int,int> > >"));
  ::Reflex::Type type_1763 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<long double*,std::vector<long double> > >"));
  ::Reflex::Type type_1804 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned short,float> > >"));
  ::Reflex::Type type_1396 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > >"));
  ::Reflex::Type type_1261 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > >"));
  ::Reflex::Type type_2337 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >"));
  ::Reflex::Type type_857 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >"));
  ::Reflex::Type type_1807 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned long,unsigned long> > >"));
  ::Reflex::Type type_975 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,unsigned int> >,bool>"));
  ::Reflex::Type type_1642 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >"));
  ::Reflex::Type type_1857 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,int> > >"));
  ::Reflex::Type type_1787 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> > >"));
  ::Reflex::Type type_1985 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<unsigned int,bool>,std::allocator<std::pair<unsigned int,bool> > >"));
  ::Reflex::Type type_1760 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const long long*,std::vector<long long> > >"));
  ::Reflex::Type type_940 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >,bool>"));
  ::Reflex::Type type_1415 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > >"));
  ::Reflex::Type type_1840 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const std::pair<int,int>,int> > >"));
  ::Reflex::Type type_972 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,unsigned long> >,bool>"));
  ::Reflex::Type type_1859 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,bool> > >"));
  ::Reflex::Type type_2357 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::pair<int,double>*,std::vector<std::pair<int,double> > >"));
  ::Reflex::Type type_2360 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::pair<double,double>*,std::vector<std::pair<double,double> > >"));
  ::Reflex::Type type_2363 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::map<short,short>*,std::vector<std::map<short,short> > >"));
  ::Reflex::Type type_1801 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned short,unsigned short> > >"));
  ::Reflex::Type type_1429 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > >"));
  ::Reflex::Type type_1871 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const int,std::pair<double,double> > > >"));
  ::Reflex::Type type_885 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >"));
  ::Reflex::Type type_1785 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> > >"));
  ::Reflex::Type type_1713 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> > >"));
  ::Reflex::Type type_1962 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<unsigned int,float>,std::allocator<std::pair<unsigned int,float> > >"));
  ::Reflex::Type type_1910 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::basic_string<char> > >"));
  ::Reflex::Type type_924 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<unsigned int> > >,bool>"));
  ::Reflex::Type type_1427 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > >"));
  ::Reflex::Type type_2323 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::vector<unsigned int>*,std::vector<std::vector<unsigned int> > >"));
  ::Reflex::Type type_2359 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::pair<float,float>*,std::vector<std::pair<float,float> > >"));
  ::Reflex::Type type_1812 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned int,unsigned int> > >"));
  ::Reflex::Type type_1842 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const std::pair<int,int>,double> > >"));
  ::Reflex::Type type_1706 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const void* const*,std::vector<const void*> > >"));
  ::Reflex::Type type_1783 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> > >"));
  ::Reflex::Type type_1715 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<unsigned char**,std::vector<unsigned char*> > >"));
  ::Reflex::Type type_1953 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::vector<std::vector<int> >,std::allocator<std::vector<std::vector<int> > > >"));
  ::Reflex::Type type_1984 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<unsigned int,double>,std::allocator<std::pair<unsigned int,double> > >"));
  ::Reflex::Type type_1762 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const long double*,std::vector<long double> > >"));
  ::Reflex::Type type_915 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned long,std::vector<unsigned long> > >,bool>"));
  ::Reflex::Type type_1260 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > >"));
  ::Reflex::Type type_1903 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > >"));
  ::Reflex::Type type_2393 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::basic_string<char>*,std::vector<std::basic_string<char> > >"));
  ::Reflex::Type type_888 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >"));
  ::Reflex::Type type_1806 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned long,unsigned long> > >"));
  ::Reflex::Type type_1258 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > > >"));
  ::Reflex::Type type_1856 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,int> > >"));
  ::Reflex::Type type_1008 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const int,std::pair<unsigned int,unsigned int> > >,bool>"));
  ::Reflex::Type type_1786 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> > >"));
  ::Reflex::Type type_906 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned short,std::vector<unsigned short> > >,bool>"));
  ::Reflex::Type type_918 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned long long,std::basic_string<char> > >,bool>"));
  ::Reflex::Type type_1259 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > >"));
  ::Reflex::Type type_1858 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,bool> > >"));
  ::Reflex::Type type_2321 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::vector<unsigned short>*,std::vector<std::vector<unsigned short> > >"));
  ::Reflex::Type type_2342 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::pair<unsigned int,int>*,std::vector<std::pair<unsigned int,int> > >"));
  ::Reflex::Type type_2361 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::pair<double,double>*,std::vector<std::pair<double,double> > >"));
  ::Reflex::Type type_1800 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned short,unsigned short> > >"));
  ::Reflex::Type type_1005 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const int,std::pair<unsigned long,unsigned long> > >,bool>"));
  ::Reflex::Type type_1870 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const int,std::pair<double,double> > > >"));
  ::Reflex::Type type_1784 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const unsigned long*,std::vector<unsigned long> > >"));
  ::Reflex::Type type_1712 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const unsigned char*,std::vector<unsigned char> > >"));
  ::Reflex::Type type_1269 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > >"));
  ::Reflex::Type type_1847 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,unsigned int> > >"));
  ::Reflex::Type type_2324 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::vector<unsigned int>*,std::vector<std::vector<unsigned int> > >"));
  ::Reflex::Type type_1727 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > > >"));
  ::Reflex::Type type_2388 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::pair<unsigned int,bool>*,std::vector<std::pair<unsigned int,bool> > >"));
  ::Reflex::Type type_1825 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > > >"));
  ::Reflex::Type type_1845 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,unsigned long> > >"));
  ::Reflex::Type type_1276 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > >"));
  ::Reflex::Type type_1782 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const unsigned short*,std::vector<unsigned short> > >"));
  ::Reflex::Type type_1714 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<unsigned char* const*,std::vector<unsigned char*> > >"));
  ::Reflex::Type type_1902 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > >"));
  ::Reflex::Type type_1275 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > >"));
  ::Reflex::Type type_2344 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::pair<unsigned int,float>*,std::vector<std::pair<unsigned int,float> > >"));
  ::Reflex::Type type_958 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::basic_string<char> > >,bool>"));
  ::Reflex::Type type_1815 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<unsigned int> > > >"));
  ::Reflex::Type type_1900 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > > >"));
  ::Reflex::Type type_1711 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> > >"));
  ::Reflex::Type type_1901 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > >"));
  ::Reflex::Type type_2322 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::vector<unsigned short>*,std::vector<std::vector<unsigned short> > >"));
  ::Reflex::Type type_2325 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::vector<std::vector<int> >*,std::vector<std::vector<std::vector<int> > > >"));
  ::Reflex::Type type_1725 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::vector<short>*,std::vector<std::vector<short> > > >"));
  ::Reflex::Type type_1729 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::vector<float>*,std::vector<std::vector<float> > > >"));
  ::Reflex::Type type_2343 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::pair<unsigned int,int>*,std::vector<std::pair<unsigned int,int> > >"));
  ::Reflex::Type type_2386 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::pair<unsigned int,double>*,std::vector<std::pair<unsigned int,double> > >"));
  ::Reflex::Type type_1749 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::pair<int,int>*,std::vector<std::pair<int,int> > > >"));
  ::Reflex::Type type_1809 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned long,std::vector<unsigned long> > > >"));
  ::Reflex::Type type_937 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > >,bool>"));
  ::Reflex::Type type_1869 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const int,std::pair<unsigned int,unsigned int> > > >"));
  ::Reflex::Type type_1954 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::vector<std::pair<int,double> >,std::allocator<std::vector<std::pair<int,double> > > >"));
  ::Reflex::Type type_1911 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > >"));
  ::Reflex::Type type_1846 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,unsigned int> > >"));
  ::Reflex::Type type_1726 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::vector<int>*,std::vector<std::vector<int> > > >"));
  ::Reflex::Type type_1731 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > > >"));
  ::Reflex::Type type_2389 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::pair<unsigned int,bool>*,std::vector<std::pair<unsigned int,bool> > >"));
  ::Reflex::Type type_1803 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned short,std::vector<unsigned short> > > >"));
  ::Reflex::Type type_1811 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned long long,std::basic_string<char> > > >"));
  ::Reflex::Type type_1824 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > > >"));
  ::Reflex::Type type_1844 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,unsigned long> > >"));
  ::Reflex::Type type_1918 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > >"));
  ::Reflex::Type type_1867 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const int,std::pair<unsigned long,unsigned long> > > >"));
  ::Reflex::Type type_1960 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >"));
  ::Reflex::Type type_1917 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > >"));
  ::Reflex::Type type_2345 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::pair<unsigned int,float>*,std::vector<std::pair<unsigned int,float> > >"));
  ::Reflex::Type type_1814 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<unsigned int> > > >"));
  ::Reflex::Type type_1013 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const int,int> >,std::_Rb_tree_iterator<std::pair<const int,int> > >"));
  ::Reflex::Type type_1710 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const unsigned long long*,std::vector<unsigned long long> > >"));
  ::Reflex::Type type_2326 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::vector<std::vector<int> >*,std::vector<std::vector<std::vector<int> > > >"));
  ::Reflex::Type type_1751 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::pair<int,double>*,std::vector<std::pair<int,double> > > >"));
  ::Reflex::Type type_1724 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::vector<short>*,std::vector<std::vector<short> > > >"));
  ::Reflex::Type type_1728 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::vector<float>*,std::vector<std::vector<float> > > >"));
  ::Reflex::Type type_2387 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::pair<unsigned int,double>*,std::vector<std::pair<unsigned int,double> > >"));
  ::Reflex::Type type_1748 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::pair<int,int>*,std::vector<std::pair<int,int> > > >"));
  ::Reflex::Type type_1757 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::map<short,short>*,std::vector<std::map<short,short> > > >"));
  ::Reflex::Type type_1808 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned long,std::vector<unsigned long> > > >"));
  ::Reflex::Type type_934 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > >,bool>"));
  ::Reflex::Type type_1868 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const int,std::pair<unsigned int,unsigned int> > > >"));
  ::Reflex::Type type_1979 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<double,std::vector<double> >,std::allocator<std::pair<double,std::vector<double> > > >"));
  ::Reflex::Type type_1964 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<std::basic_string<char>,int>,std::allocator<std::pair<std::basic_string<char>,int> > >"));
  ::Reflex::Type type_1837 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::basic_string<char> > > >"));
  ::Reflex::Type type_928 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > > >,bool>"));
  ::Reflex::Type type_1425 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >"));
  ::Reflex::Type type_1730 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::vector<double>*,std::vector<std::vector<double> > > >"));
  ::Reflex::Type type_1753 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::pair<float,float>*,std::vector<std::pair<float,float> > > >"));
  ::Reflex::Type type_1802 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned short,std::vector<unsigned short> > > >"));
  ::Reflex::Type type_1810 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned long long,std::basic_string<char> > > >"));
  ::Reflex::Type type_931 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > >,bool>"));
  ::Reflex::Type type_1866 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const int,std::pair<unsigned long,unsigned long> > > >"));
  ::Reflex::Type type_1966 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<std::basic_string<char>,bool>,std::allocator<std::pair<std::basic_string<char>,bool> > >"));
  ::Reflex::Type type_1823 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > > >"));
  ::Reflex::Type type_2327 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::vector<std::pair<int,double> >*,std::vector<std::vector<std::pair<int,double> > > >"));
  ::Reflex::Type type_1797 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > > >"));
  ::Reflex::Type type_961 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > >,bool>"));
  ::Reflex::Type type_1431 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >"));
  ::Reflex::Type type_1965 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<std::basic_string<char>,float>,std::allocator<std::pair<std::basic_string<char>,float> > >"));
  ::Reflex::Type type_998 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const short,short> >,std::_Rb_tree_iterator<std::pair<const short,short> > >"));
  ::Reflex::Type type_984 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > >,bool>"));
  ::Reflex::Type type_1750 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::pair<int,double>*,std::vector<std::pair<int,double> > > >"));
  ::Reflex::Type type_2340 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::pair<unsigned int,unsigned int>*,std::vector<std::pair<unsigned int,unsigned int> > >"));
  ::Reflex::Type type_1755 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::pair<double,double>*,std::vector<std::pair<double,double> > > >"));
  ::Reflex::Type type_1756 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::map<short,short>*,std::vector<std::map<short,short> > > >"));
  ::Reflex::Type type_981 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > >,bool>"));
  ::Reflex::Type type_1987 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<std::basic_string<char>,double>,std::allocator<std::pair<std::basic_string<char>,double> > >"));
  ::Reflex::Type type_829 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::basic_string<char> >,std::_Rb_tree_const_iterator<std::basic_string<char> > >"));
  ::Reflex::Type type_1836 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::basic_string<char> > > >"));
  ::Reflex::Type type_1719 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::vector<unsigned int>*,std::vector<std::vector<unsigned int> > > >"));
  ::Reflex::Type type_1752 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::pair<float,float>*,std::vector<std::pair<float,float> > > >"));
  ::Reflex::Type type_1821 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > > >"));
  ::Reflex::Type type_1822 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > > >"));
  ::Reflex::Type type_1274 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >"));
  ::Reflex::Type type_899 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const double,double> >,std::_Rb_tree_iterator<std::pair<const double,double> > >"));
  ::Reflex::Type type_2328 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::vector<std::pair<int,double> >*,std::vector<std::vector<std::pair<int,double> > > >"));
  ::Reflex::Type type_1796 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::basic_string<char>*,std::vector<std::basic_string<char> > > >"));
  ::Reflex::Type type_2380 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::pair<double,std::vector<double> >*,std::vector<std::pair<double,std::vector<double> > > >"));
  ::Reflex::Type type_2348 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >"));
  ::Reflex::Type type_1817 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > > > >"));
  ::Reflex::Type type_1012 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const int,int> >,std::_Rb_tree_const_iterator<std::pair<const int,int> > >"));
  ::Reflex::Type type_1819 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > > >"));
  ::Reflex::Type type_1717 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::vector<unsigned short>*,std::vector<std::vector<unsigned short> > > >"));
  ::Reflex::Type type_2341 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::pair<unsigned int,unsigned int>*,std::vector<std::pair<unsigned int,unsigned int> > >"));
  ::Reflex::Type type_1737 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::pair<unsigned int,int>*,std::vector<std::pair<unsigned int,int> > > >"));
  ::Reflex::Type type_2352 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,bool>*,std::vector<std::pair<std::basic_string<char>,bool> > >"));
  ::Reflex::Type type_1754 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::pair<double,double>*,std::vector<std::pair<double,double> > > >"));
  ::Reflex::Type type_1277 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >"));
  ::Reflex::Type type_1839 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > > >"));
  ::Reflex::Type type_1718 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::vector<unsigned int>*,std::vector<std::vector<unsigned int> > > >"));
  ::Reflex::Type type_1791 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::pair<unsigned int,bool>*,std::vector<std::pair<unsigned int,bool> > > >"));
  ::Reflex::Type type_2350 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,float>*,std::vector<std::pair<std::basic_string<char>,float> > >"));
  ::Reflex::Type type_1853 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > > >"));
  ::Reflex::Type type_1820 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > > >"));
  ::Reflex::Type type_945 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,int> >,std::_Rb_tree_iterator<std::pair<const unsigned int,int> > >"));
  ::Reflex::Type type_1916 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >"));
  ::Reflex::Type type_1851 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > > >"));
  ::Reflex::Type type_1739 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::pair<unsigned int,float>*,std::vector<std::pair<unsigned int,float> > > >"));
  ::Reflex::Type type_2381 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::pair<double,std::vector<double> >*,std::vector<std::pair<double,std::vector<double> > > >"));
  ::Reflex::Type type_2349 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >"));
  ::Reflex::Type type_2391 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,double>*,std::vector<std::pair<std::basic_string<char>,double> > >"));
  ::Reflex::Type type_1816 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > > > >"));
  ::Reflex::Type type_1001 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const int,unsigned int> >,std::_Rb_tree_iterator<std::pair<const int,unsigned int> > >"));
  ::Reflex::Type type_997 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const short,short> >,std::_Rb_tree_const_iterator<std::pair<const short,short> > >"));
  ::Reflex::Type type_1818 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > > >"));
  ::Reflex::Type type_954 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,bool> >,std::_Rb_tree_iterator<std::pair<const unsigned int,bool> > >"));
  ::Reflex::Type type_1716 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::vector<unsigned short>*,std::vector<std::vector<unsigned short> > > >"));
  ::Reflex::Type type_1721 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::vector<std::vector<int> >*,std::vector<std::vector<std::vector<int> > > > >"));
  ::Reflex::Type type_1736 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::pair<unsigned int,int>*,std::vector<std::pair<unsigned int,int> > > >"));
  ::Reflex::Type type_1789 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::pair<unsigned int,double>*,std::vector<std::pair<unsigned int,double> > > >"));
  ::Reflex::Type type_2353 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,bool>*,std::vector<std::pair<std::basic_string<char>,bool> > >"));
  ::Reflex::Type type_1919 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >"));
  ::Reflex::Type type_942 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,short> >,std::_Rb_tree_iterator<std::pair<const unsigned int,short> > >"));
  ::Reflex::Type type_948 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,float> >,std::_Rb_tree_iterator<std::pair<const unsigned int,float> > >"));
  ::Reflex::Type type_1838 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > > >"));
  ::Reflex::Type type_995 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const short,unsigned int> >,std::_Rb_tree_iterator<std::pair<const short,unsigned int> > >"));
  ::Reflex::Type type_1790 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::pair<unsigned int,bool>*,std::vector<std::pair<unsigned int,bool> > > >"));
  ::Reflex::Type type_2351 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,float>*,std::vector<std::pair<std::basic_string<char>,float> > >"));
  ::Reflex::Type type_1852 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > > >"));
  ::Reflex::Type type_951 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,double> >,std::_Rb_tree_iterator<std::pair<const unsigned int,double> > >"));
  ::Reflex::Type type_1850 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > > >"));
  ::Reflex::Type type_897 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const double,double> >,std::_Rb_tree_const_iterator<std::pair<const double,double> > >"));
  ::Reflex::Type type_1738 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::pair<unsigned int,float>*,std::vector<std::pair<unsigned int,float> > > >"));
  ::Reflex::Type type_2392 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,double>*,std::vector<std::pair<std::basic_string<char>,double> > >"));
  ::Reflex::Type type_908 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned short,float> >,std::_Rb_tree_iterator<std::pair<const unsigned short,float> > >"));
  ::Reflex::Type type_1720 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::vector<std::vector<int> >*,std::vector<std::vector<std::vector<int> > > > >"));
  ::Reflex::Type type_1788 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::pair<unsigned int,double>*,std::vector<std::pair<unsigned int,double> > > >"));
  ::Reflex::Type type_978 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >,bool>"));
  ::Reflex::Type type_944 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,int> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,int> > >"));
  ::Reflex::Type type_963 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,int> >,std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,int> > >"));
  ::Reflex::Type type_987 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >,bool>"));
  ::Reflex::Type type_1723 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::vector<std::pair<int,double> >*,std::vector<std::vector<std::pair<int,double> > > > >"));
  ::Reflex::Type type_1000 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const int,unsigned int> >,std::_Rb_tree_const_iterator<std::pair<const int,unsigned int> > >"));
  ::Reflex::Type type_953 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,bool> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,bool> > >"));
  ::Reflex::Type type_1735 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::pair<unsigned int,unsigned int>*,std::vector<std::pair<unsigned int,unsigned int> > > >"));
  ::Reflex::Type type_941 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,short> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,short> > >"));
  ::Reflex::Type type_947 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,float> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,float> > >"));
  ::Reflex::Type type_994 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const short,unsigned int> >,std::_Rb_tree_const_iterator<std::pair<const short,unsigned int> > >"));
  ::Reflex::Type type_1150 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<int,std::pair<const int,int>,std::_Select1st<std::pair<const int,int> >,std::less<int>,std::allocator<std::pair<const int,int> > >"));
  ::Reflex::Type type_1959 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<unsigned long long,std::basic_string<char> >,std::allocator<std::pair<unsigned long long,std::basic_string<char> > > >"));
  ::Reflex::Type type_920 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,unsigned int> >,std::_Rb_tree_iterator<std::pair<const unsigned int,unsigned int> > >"));
  ::Reflex::Type type_950 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,double> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,double> > >"));
  ::Reflex::Type type_967 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,double> >,std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,double> > >"));
  ::Reflex::Type type_1849 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > > >"));
  ::Reflex::Type type_1722 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::vector<std::pair<int,double> >*,std::vector<std::vector<std::pair<int,double> > > > >"));
  ::Reflex::Type type_1779 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::pair<double,std::vector<double> >*,std::vector<std::pair<double,std::vector<double> > > > >"));
  ::Reflex::Type type_1743 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > > >"));
  ::Reflex::Type type_907 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned short,float> >,std::_Rb_tree_const_iterator<std::pair<const unsigned short,float> > >"));
  ::Reflex::Type type_1734 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::pair<unsigned int,unsigned int>*,std::vector<std::pair<unsigned int,unsigned int> > > >"));
  ::Reflex::Type type_1747 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,bool>*,std::vector<std::pair<std::basic_string<char>,bool> > > >"));
  ::Reflex::Type type_1855 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > > >"));
  ::Reflex::Type type_911 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned long,unsigned long> >,std::_Rb_tree_iterator<std::pair<const unsigned long,unsigned long> > >"));
  ::Reflex::Type type_989 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,int> >,std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,int> > >"));
  ::Reflex::Type type_1745 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,float>*,std::vector<std::pair<std::basic_string<char>,float> > > >"));
  ::Reflex::Type type_962 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const std::pair<int,int>,int> >,std::_Rb_tree_const_iterator<std::pair<const std::pair<int,int>,int> > >"));
  ::Reflex::Type type_1848 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > > >"));
  ::Reflex::Type type_992 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,bool> >,std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,bool> > >"));
  ::Reflex::Type type_1778 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::pair<double,std::vector<double> >*,std::vector<std::pair<double,std::vector<double> > > > >"));
  ::Reflex::Type type_1742 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > > >"));
  ::Reflex::Type type_1795 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,double>*,std::vector<std::pair<std::basic_string<char>,double> > > >"));
  ::Reflex::Type type_902 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned short,unsigned short> >,std::_Rb_tree_iterator<std::pair<const unsigned short,unsigned short> > >"));
  ::Reflex::Type type_2338 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::pair<unsigned long long,std::basic_string<char> >*,std::vector<std::pair<unsigned long long,std::basic_string<char> > > >"));
  ::Reflex::Type type_1746 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,bool>*,std::vector<std::pair<std::basic_string<char>,bool> > > >"));
  ::Reflex::Type type_1854 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > > >"));
  ::Reflex::Type type_1010 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const int,std::pair<double,double> > >,std::_Rb_tree_iterator<std::pair<const int,std::pair<double,double> > > >"));
  ::Reflex::Type type_1744 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,float>*,std::vector<std::pair<std::basic_string<char>,float> > > >"));
  ::Reflex::Type type_919 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,unsigned int> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,unsigned int> > >"));
  ::Reflex::Type type_965 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const std::pair<int,int>,double> >,std::_Rb_tree_const_iterator<std::pair<const std::pair<int,int>,double> > >"));
  ::Reflex::Type type_1794 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,double>*,std::vector<std::pair<std::basic_string<char>,double> > > >"));
  ::Reflex::Type type_1145 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<short,std::pair<const short,short>,std::_Select1st<std::pair<const short,short> >,std::less<short>,std::allocator<std::pair<const short,short> > >"));
  ::Reflex::Type type_2339 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::pair<unsigned long long,std::basic_string<char> >*,std::vector<std::pair<unsigned long long,std::basic_string<char> > > >"));
  ::Reflex::Type type_910 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned long,unsigned long> >,std::_Rb_tree_const_iterator<std::pair<const unsigned long,unsigned long> > >"));
  ::Reflex::Type type_988 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,int> >,std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,int> > >"));
  ::Reflex::Type type_991 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,bool> >,std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,bool> > >"));
  ::Reflex::Type type_901 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned short,unsigned short> >,std::_Rb_tree_const_iterator<std::pair<const unsigned short,unsigned short> > >"));
  ::Reflex::Type type_1009 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const int,std::pair<double,double> > >,std::_Rb_tree_const_iterator<std::pair<const int,std::pair<double,double> > > >"));
  ::Reflex::Type type_974 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,unsigned int> >,std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,unsigned int> > >"));
  ::Reflex::Type type_1113 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<double,std::pair<const double,double>,std::_Select1st<std::pair<const double,double> >,std::less<double>,std::allocator<std::pair<const double,double> > >"));
  ::Reflex::Type type_939 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >,std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > > >"));
  ::Reflex::Type type_971 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,unsigned long> >,std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,unsigned long> > >"));
  ::Reflex::Type type_1146 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<int,std::pair<const int,unsigned int>,std::_Select1st<std::pair<const int,unsigned int> >,std::less<int>,std::allocator<std::pair<const int,unsigned int> > >"));
  ::Reflex::Type type_1963 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>,std::allocator<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> > >"));
  ::Reflex::Type type_923 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<unsigned int> > >,std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<unsigned int> > > >"));
  ::Reflex::Type type_914 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned long,std::vector<unsigned long> > >,std::_Rb_tree_iterator<std::pair<const unsigned long,std::vector<unsigned long> > > >"));
  ::Reflex::Type type_1733 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::pair<unsigned long long,std::basic_string<char> >*,std::vector<std::pair<unsigned long long,std::basic_string<char> > > > >"));
  ::Reflex::Type type_1007 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const int,std::pair<unsigned int,unsigned int> > >,std::_Rb_tree_iterator<std::pair<const int,std::pair<unsigned int,unsigned int> > > >"));
  ::Reflex::Type type_973 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,unsigned int> >,std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,unsigned int> > >"));
  ::Reflex::Type type_1111 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<std::basic_string<char>,std::basic_string<char>,std::_Identity<std::basic_string<char> >,std::less<std::basic_string<char> >,std::allocator<std::basic_string<char> > >"));
  ::Reflex::Type type_1144 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<short,std::pair<const short,unsigned int>,std::_Select1st<std::pair<const short,unsigned int> >,std::less<short>,std::allocator<std::pair<const short,unsigned int> > >"));
  ::Reflex::Type type_905 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned short,std::vector<unsigned short> > >,std::_Rb_tree_iterator<std::pair<const unsigned short,std::vector<unsigned short> > > >"));
  ::Reflex::Type type_917 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned long long,std::basic_string<char> > >,std::_Rb_tree_iterator<std::pair<const unsigned long long,std::basic_string<char> > > >"));
  ::Reflex::Type type_938 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > > >"));
  ::Reflex::Type type_969 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,unsigned long> >,std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,unsigned long> > >"));
  ::Reflex::Type type_2346 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>*,std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> > >"));
  ::Reflex::Type type_1004 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const int,std::pair<unsigned long,unsigned long> > >,std::_Rb_tree_iterator<std::pair<const int,std::pair<unsigned long,unsigned long> > > >"));
  ::Reflex::Type type_1732 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::pair<unsigned long long,std::basic_string<char> >*,std::vector<std::pair<unsigned long long,std::basic_string<char> > > > >"));
  ::Reflex::Type type_922 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<unsigned int> > >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<unsigned int> > > >"));
  ::Reflex::Type type_2347 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>*,std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> > >"));
  ::Reflex::Type type_1128 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned int,std::pair<const unsigned int,int>,std::_Select1st<std::pair<const unsigned int,int> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,int> > >"));
  ::Reflex::Type type_913 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned long,std::vector<unsigned long> > >,std::_Rb_tree_const_iterator<std::pair<const unsigned long,std::vector<unsigned long> > > >"));
  ::Reflex::Type type_1006 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const int,std::pair<unsigned int,unsigned int> > >,std::_Rb_tree_const_iterator<std::pair<const int,std::pair<unsigned int,unsigned int> > > >"));
  ::Reflex::Type type_957 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::basic_string<char> > >,std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::basic_string<char> > > >"));
  ::Reflex::Type type_1131 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned int,std::pair<const unsigned int,bool>,std::_Select1st<std::pair<const unsigned int,bool> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,bool> > >"));
  ::Reflex::Type type_904 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned short,std::vector<unsigned short> > >,std::_Rb_tree_const_iterator<std::pair<const unsigned short,std::vector<unsigned short> > > >"));
  ::Reflex::Type type_916 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned long long,std::basic_string<char> > >,std::_Rb_tree_const_iterator<std::pair<const unsigned long long,std::basic_string<char> > > >"));
  ::Reflex::Type type_1127 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned int,std::pair<const unsigned int,short>,std::_Select1st<std::pair<const unsigned int,short> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,short> > >"));
  ::Reflex::Type type_1129 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned int,std::pair<const unsigned int,float>,std::_Select1st<std::pair<const unsigned int,float> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,float> > >"));
  ::Reflex::Type type_1003 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const int,std::pair<unsigned long,unsigned long> > >,std::_Rb_tree_const_iterator<std::pair<const int,std::pair<unsigned long,unsigned long> > > >"));
  ::Reflex::Type type_936 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > >,std::_Rb_tree_iterator<std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > > >"));
  ::Reflex::Type type_1130 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned int,std::pair<const unsigned int,double>,std::_Select1st<std::pair<const unsigned int,double> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,double> > >"));
  ::Reflex::Type type_956 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::basic_string<char> > >,std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::basic_string<char> > > >"));
  ::Reflex::Type type_1116 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned short,std::pair<const unsigned short,float>,std::_Select1st<std::pair<const unsigned short,float> >,std::less<unsigned short>,std::allocator<std::pair<const unsigned short,float> > >"));
  ::Reflex::Type type_1741 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>*,std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> > > >"));
  ::Reflex::Type type_933 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > >,std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > > >"));
  ::Reflex::Type type_935 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > > >"));
  ::Reflex::Type type_927 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > > >,std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > > > >"));
  ::Reflex::Type type_1149 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<int,std::pair<const int,std::pair<double,double> >,std::_Select1st<std::pair<const int,std::pair<double,double> > >,std::less<int>,std::allocator<std::pair<const int,std::pair<double,double> > > >"));
  ::Reflex::Type type_930 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > >,std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > > >"));
  ::Reflex::Type type_1740 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>*,std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> > > >"));
  ::Reflex::Type type_1120 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned int,std::pair<const unsigned int,unsigned int>,std::_Select1st<std::pair<const unsigned int,unsigned int> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,unsigned int> > >"));
  ::Reflex::Type type_960 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > >,std::_Rb_tree_iterator<std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > > >"));
  ::Reflex::Type type_983 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > >,std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > > >"));
  ::Reflex::Type type_932 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > > >"));
  ::Reflex::Type type_1134 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<std::pair<int,int>,std::pair<const std::pair<int,int>,int>,std::_Select1st<std::pair<const std::pair<int,int>,int> >,std::less<std::pair<int,int> >,std::allocator<std::pair<const std::pair<int,int>,int> > >"));
  ::Reflex::Type type_980 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > >,std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > > >"));
  ::Reflex::Type type_925 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > > >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > > > >"));
  ::Reflex::Type type_1117 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned long,std::pair<const unsigned long,unsigned long>,std::_Select1st<std::pair<const unsigned long,unsigned long> >,std::less<unsigned long>,std::allocator<std::pair<const unsigned long,unsigned long> > >"));
  ::Reflex::Type type_929 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > > >"));
  ::Reflex::Type type_959 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > >,std::_Rb_tree_const_iterator<std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > > >"));
  ::Reflex::Type type_1135 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<std::pair<int,int>,std::pair<const std::pair<int,int>,double>,std::_Select1st<std::pair<const std::pair<int,int>,double> >,std::less<std::pair<int,int> >,std::allocator<std::pair<const std::pair<int,int>,double> > >"));
  ::Reflex::Type type_982 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > >,std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > > >"));
  ::Reflex::Type type_1114 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned short,std::pair<const unsigned short,unsigned short>,std::_Select1st<std::pair<const unsigned short,unsigned short> >,std::less<unsigned short>,std::allocator<std::pair<const unsigned short,unsigned short> > >"));
  ::Reflex::Type type_979 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > >,std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > > >"));
  ::Reflex::Type type_1142 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<std::basic_string<char>,std::pair<const std::basic_string<char>,int>,std::_Select1st<std::pair<const std::basic_string<char>,int> >,std::less<std::basic_string<char> >,std::allocator<std::pair<const std::basic_string<char>,int> > >"));
  ::Reflex::Type type_1148 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<int,std::pair<const int,std::pair<unsigned int,unsigned int> >,std::_Select1st<std::pair<const int,std::pair<unsigned int,unsigned int> > >,std::less<int>,std::allocator<std::pair<const int,std::pair<unsigned int,unsigned int> > > >"));
  ::Reflex::Type type_1143 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<std::basic_string<char>,std::pair<const std::basic_string<char>,bool>,std::_Select1st<std::pair<const std::basic_string<char>,bool> >,std::less<std::basic_string<char> >,std::allocator<std::pair<const std::basic_string<char>,bool> > >"));
  ::Reflex::Type type_1126 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned int,std::pair<const unsigned int,std::basic_string<char> >,std::_Select1st<std::pair<const unsigned int,std::basic_string<char> > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,std::basic_string<char> > > >"));
  ::Reflex::Type type_1147 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<int,std::pair<const int,std::pair<unsigned long,unsigned long> >,std::_Select1st<std::pair<const int,std::pair<unsigned long,unsigned long> > >,std::less<int>,std::allocator<std::pair<const int,std::pair<unsigned long,unsigned long> > > >"));
  ::Reflex::Type type_977 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >,std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > > >"));
  ::Reflex::Type type_1121 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned int,std::pair<const unsigned int,std::vector<unsigned int> >,std::_Select1st<std::pair<const unsigned int,std::vector<unsigned int> > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,std::vector<unsigned int> > > >"));
  ::Reflex::Type type_986 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >,std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > > >"));
  ::Reflex::Type type_1118 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned long,std::pair<const unsigned long,std::vector<unsigned long> >,std::_Select1st<std::pair<const unsigned long,std::vector<unsigned long> > >,std::less<unsigned long>,std::allocator<std::pair<const unsigned long,std::vector<unsigned long> > > >"));
  ::Reflex::Type type_976 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >,std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > > >"));
  ::Reflex::Type type_1137 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<std::basic_string<char>,std::pair<const std::basic_string<char>,unsigned int>,std::_Select1st<std::pair<const std::basic_string<char>,unsigned int> >,std::less<std::basic_string<char> >,std::allocator<std::pair<const std::basic_string<char>,unsigned int> > >"));
  ::Reflex::Type type_1115 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned short,std::pair<const unsigned short,std::vector<unsigned short> >,std::_Select1st<std::pair<const unsigned short,std::vector<unsigned short> > >,std::less<unsigned short>,std::allocator<std::pair<const unsigned short,std::vector<unsigned short> > > >"));
  ::Reflex::Type type_985 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >,std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > > >"));
  ::Reflex::Type type_1136 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<std::basic_string<char>,std::pair<const std::basic_string<char>,unsigned long>,std::_Select1st<std::pair<const std::basic_string<char>,unsigned long> >,std::less<std::basic_string<char> >,std::allocator<std::pair<const std::basic_string<char>,unsigned long> > >"));
  ::Reflex::Type type_1119 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned long long,std::pair<const unsigned long long,std::basic_string<char> >,std::_Select1st<std::pair<const unsigned long long,std::basic_string<char> > >,std::less<unsigned long long>,std::allocator<std::pair<const unsigned long long,std::basic_string<char> > > >"));
  ::Reflex::Type type_1125 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned int,std::pair<const unsigned int,std::pair<unsigned int,unsigned int> >,std::_Select1st<std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > > >"));
  ::Reflex::Type type_1132 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<std::basic_string<char>,std::pair<const std::basic_string<char>,std::basic_string<char> >,std::_Select1st<std::pair<const std::basic_string<char>,std::basic_string<char> > >,std::less<std::basic_string<char> >,std::allocator<std::pair<const std::basic_string<char>,std::basic_string<char> > > >"));
  ::Reflex::Type type_1124 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned int,std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > >,std::_Select1st<std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > > >"));
  ::Reflex::Type type_1122 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned int,std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > >,std::_Select1st<std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > > > >"));
  ::Reflex::Type type_1123 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<unsigned int,std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > >,std::_Select1st<std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > > >"));
  ::Reflex::Type type_1133 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<std::pair<short,short>,std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > >,std::_Select1st<std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > >,std::less<std::pair<short,short> >,std::allocator<std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > > >"));
  ::Reflex::Type type_1140 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<std::basic_string<char>,std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> >,std::_Select1st<std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > >,std::less<std::basic_string<char> >,std::allocator<std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > > >"));
  ::Reflex::Type type_1139 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<std::basic_string<char>,std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > >,std::_Select1st<std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > >,std::less<std::basic_string<char> >,std::allocator<std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > > >"));
  ::Reflex::Type type_1138 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<std::basic_string<char>,std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >,std::_Select1st<std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >,std::less<std::basic_string<char> >,std::allocator<std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > > >"));
  ::Reflex::Type type_1141 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<std::basic_string<char>,std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >,std::_Select1st<std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >,std::less<std::basic_string<char> >,std::allocator<std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > > >"));
  ::Reflex::Type type_4983 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<std::basic_string<char> >::iterator"), type_2337);
  ::Reflex::Type type_4984 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<std::basic_string<char> >::const_iterator"), type_2393);
  ::Reflex::Type type_4532 = ::Reflex::ReferenceBuilder(type_812);
  ::Reflex::Type type_812c = ::Reflex::ConstBuilder(type_812);
  ::Reflex::Type type_4534 = ::Reflex::ReferenceBuilder(type_812c);
  ::Reflex::Type type_22c = ::Reflex::ConstBuilder(type_22);
  ::Reflex::Type type_4404 = ::Reflex::ReferenceBuilder(type_22c);
  ::Reflex::Type type_2052c = ::Reflex::ConstBuilder(type_2052);
  ::Reflex::Type type_4918 = ::Reflex::ReferenceBuilder(type_2052c);
  ::Reflex::Type type_5044 = ::Reflex::ReferenceBuilder(type_813);
  ::Reflex::Type type_813c = ::Reflex::ConstBuilder(type_813);
  ::Reflex::Type type_5046 = ::Reflex::ReferenceBuilder(type_813c);
  ::Reflex::Type type_2144c = ::Reflex::ConstBuilder(type_2144);
  ::Reflex::Type type_3888 = ::Reflex::ReferenceBuilder(type_2144c);
  ::Reflex::Type type_1104c = ::Reflex::ConstBuilder(type_1104);
  ::Reflex::Type type_4981 = ::Reflex::ReferenceBuilder(type_1104c);
  ::Reflex::Type type_5109 = ::Reflex::ReferenceBuilder(type_814);
  ::Reflex::Type type_814c = ::Reflex::ConstBuilder(type_814);
  ::Reflex::Type type_5111 = ::Reflex::ReferenceBuilder(type_814c);
  ::Reflex::Type type_78c = ::Reflex::ConstBuilder(type_78);
  ::Reflex::Type type_3951 = ::Reflex::ReferenceBuilder(type_78c);
  ::Reflex::Type type_5174 = ::Reflex::ReferenceBuilder(type_815);
  ::Reflex::Type type_815c = ::Reflex::ConstBuilder(type_815);
  ::Reflex::Type type_5176 = ::Reflex::ReferenceBuilder(type_815c);
  ::Reflex::Type type_5239 = ::Reflex::ReferenceBuilder(type_816);
  ::Reflex::Type type_816c = ::Reflex::ConstBuilder(type_816);
  ::Reflex::Type type_5241 = ::Reflex::ReferenceBuilder(type_816c);
  ::Reflex::Type type_2058c = ::Reflex::ConstBuilder(type_2058);
  ::Reflex::Type type_4790 = ::Reflex::ReferenceBuilder(type_2058c);
  ::Reflex::Type type_5304 = ::Reflex::ReferenceBuilder(type_817);
  ::Reflex::Type type_817c = ::Reflex::ConstBuilder(type_817);
  ::Reflex::Type type_5306 = ::Reflex::ReferenceBuilder(type_817c);
  ::Reflex::Type type_5369 = ::Reflex::ReferenceBuilder(type_818);
  ::Reflex::Type type_818c = ::Reflex::ConstBuilder(type_818);
  ::Reflex::Type type_5371 = ::Reflex::ReferenceBuilder(type_818c);
  ::Reflex::Type type_2083c = ::Reflex::ConstBuilder(type_2083);
  ::Reflex::Type type_11878 = ::Reflex::ReferenceBuilder(type_2083c);
  ::Reflex::Type type_5499 = ::Reflex::ReferenceBuilder(type_820);
  ::Reflex::Type type_820c = ::Reflex::ConstBuilder(type_820);
  ::Reflex::Type type_5501 = ::Reflex::ReferenceBuilder(type_820c);
  ::Reflex::Type type_1069c = ::Reflex::ConstBuilder(type_1069);
  ::Reflex::Type type_4855 = ::Reflex::ReferenceBuilder(type_1069c);
  ::Reflex::Type type_5434 = ::Reflex::ReferenceBuilder(type_819);
  ::Reflex::Type type_819c = ::Reflex::ConstBuilder(type_819);
  ::Reflex::Type type_5436 = ::Reflex::ReferenceBuilder(type_819c);
  ::Reflex::Type type_1078c = ::Reflex::ConstBuilder(type_1078);
  ::Reflex::Type type_20175 = ::Reflex::ReferenceBuilder(type_1078c);
  ::Reflex::Type type_5564 = ::Reflex::ReferenceBuilder(type_821);
  ::Reflex::Type type_821c = ::Reflex::ConstBuilder(type_821);
  ::Reflex::Type type_5566 = ::Reflex::ReferenceBuilder(type_821c);
  ::Reflex::Type type_5629 = ::Reflex::ReferenceBuilder(type_822);
  ::Reflex::Type type_822c = ::Reflex::ConstBuilder(type_822);
  ::Reflex::Type type_5631 = ::Reflex::ReferenceBuilder(type_822c);
  ::Reflex::Type type_5694 = ::Reflex::ReferenceBuilder(type_823);
  ::Reflex::Type type_823c = ::Reflex::ConstBuilder(type_823);
  ::Reflex::Type type_5696 = ::Reflex::ReferenceBuilder(type_823c);
  ::Reflex::Type type_5759 = ::Reflex::ReferenceBuilder(type_824);
  ::Reflex::Type type_824c = ::Reflex::ConstBuilder(type_824);
  ::Reflex::Type type_5761 = ::Reflex::ReferenceBuilder(type_824c);
  ::Reflex::Type type_5824 = ::Reflex::ReferenceBuilder(type_825);
  ::Reflex::Type type_825c = ::Reflex::ConstBuilder(type_825);
  ::Reflex::Type type_5826 = ::Reflex::ReferenceBuilder(type_825c);
  ::Reflex::Type type_5889 = ::Reflex::ReferenceBuilder(type_826);
  ::Reflex::Type type_826c = ::Reflex::ConstBuilder(type_826);
  ::Reflex::Type type_5891 = ::Reflex::ReferenceBuilder(type_826c);
  ::Reflex::Type type_5954 = ::Reflex::ReferenceBuilder(type_827);
  ::Reflex::Type type_827c = ::Reflex::ConstBuilder(type_827);
  ::Reflex::Type type_5956 = ::Reflex::ReferenceBuilder(type_827c);
  ::Reflex::Type type_113c = ::Reflex::ConstBuilder(type_113);
  ::Reflex::Type type_828c = ::Reflex::ConstBuilder(type_828);
  ::Reflex::Type type_10200 = ::Reflex::ReferenceBuilder(type_828c);
  ::Reflex::Type type_4662 = ::Reflex::ReferenceBuilder(type_113c);
  ::Reflex::Type type_20177 = ::Reflex::ReferenceBuilder(type_837);
  ::Reflex::Type type_837c = ::Reflex::ConstBuilder(type_837);
  ::Reflex::Type type_20178 = ::Reflex::ReferenceBuilder(type_837c);
  ::Reflex::Type type_167c = ::Reflex::ConstBuilder(type_167);
  ::Reflex::Type type_3762 = ::Reflex::ReferenceBuilder(type_167c);
  ::Reflex::Type type_20179 = ::Reflex::ReferenceBuilder(type_838);
  ::Reflex::Type type_838c = ::Reflex::ConstBuilder(type_838);
  ::Reflex::Type type_20180 = ::Reflex::ReferenceBuilder(type_838c);
  ::Reflex::Type type_1051c = ::Reflex::ConstBuilder(type_1051);
  ::Reflex::Type type_4146 = ::Reflex::ReferenceBuilder(type_1051c);
  ::Reflex::Type type_20181 = ::Reflex::ReferenceBuilder(type_839);
  ::Reflex::Type type_839c = ::Reflex::ConstBuilder(type_839);
  ::Reflex::Type type_20182 = ::Reflex::ReferenceBuilder(type_839c);
  ::Reflex::Type type_20183 = ::Reflex::ReferenceBuilder(type_840);
  ::Reflex::Type type_840c = ::Reflex::ConstBuilder(type_840);
  ::Reflex::Type type_20184 = ::Reflex::ReferenceBuilder(type_840c);
  ::Reflex::Type type_75c = ::Reflex::ConstBuilder(type_75);
  ::Reflex::Type type_3825 = ::Reflex::ReferenceBuilder(type_75c);
  ::Reflex::Type type_20185 = ::Reflex::ReferenceBuilder(type_841);
  ::Reflex::Type type_841c = ::Reflex::ConstBuilder(type_841);
  ::Reflex::Type type_20186 = ::Reflex::ReferenceBuilder(type_841c);
  ::Reflex::Type type_1052c = ::Reflex::ConstBuilder(type_1052);
  ::Reflex::Type type_20187 = ::Reflex::ReferenceBuilder(type_1052c);
  ::Reflex::Type type_20188 = ::Reflex::ReferenceBuilder(type_842);
  ::Reflex::Type type_842c = ::Reflex::ConstBuilder(type_842);
  ::Reflex::Type type_20189 = ::Reflex::ReferenceBuilder(type_842c);
  ::Reflex::Type type_20190 = ::Reflex::ReferenceBuilder(type_843);
  ::Reflex::Type type_843c = ::Reflex::ConstBuilder(type_843);
  ::Reflex::Type type_20191 = ::Reflex::ReferenceBuilder(type_843c);
  ::Reflex::Type type_1054c = ::Reflex::ConstBuilder(type_1054);
  ::Reflex::Type type_4211 = ::Reflex::ReferenceBuilder(type_1054c);
  ::Reflex::Type type_20192 = ::Reflex::ReferenceBuilder(type_844);
  ::Reflex::Type type_844c = ::Reflex::ConstBuilder(type_844);
  ::Reflex::Type type_20193 = ::Reflex::ReferenceBuilder(type_844c);
  ::Reflex::Type type_1075c = ::Reflex::ConstBuilder(type_1075);
  ::Reflex::Type type_20194 = ::Reflex::ReferenceBuilder(type_1075c);
  ::Reflex::Type type_20195 = ::Reflex::ReferenceBuilder(type_845);
  ::Reflex::Type type_845c = ::Reflex::ConstBuilder(type_845);
  ::Reflex::Type type_20196 = ::Reflex::ReferenceBuilder(type_845c);
  ::Reflex::Type type_1076c = ::Reflex::ConstBuilder(type_1076);
  ::Reflex::Type type_20197 = ::Reflex::ReferenceBuilder(type_1076c);
  ::Reflex::Type type_20198 = ::Reflex::ReferenceBuilder(type_846);
  ::Reflex::Type type_846c = ::Reflex::ConstBuilder(type_846);
  ::Reflex::Type type_20199 = ::Reflex::ReferenceBuilder(type_846c);
  ::Reflex::Type type_20200 = ::Reflex::ReferenceBuilder(type_847);
  ::Reflex::Type type_847c = ::Reflex::ConstBuilder(type_847);
  ::Reflex::Type type_20201 = ::Reflex::ReferenceBuilder(type_847c);
  ::Reflex::Type type_20202 = ::Reflex::ReferenceBuilder(type_848);
  ::Reflex::Type type_848c = ::Reflex::ConstBuilder(type_848);
  ::Reflex::Type type_20203 = ::Reflex::ReferenceBuilder(type_848c);
  ::Reflex::Type type_20204 = ::Reflex::ReferenceBuilder(type_849);
  ::Reflex::Type type_849c = ::Reflex::ConstBuilder(type_849);
  ::Reflex::Type type_20205 = ::Reflex::ReferenceBuilder(type_849c);
  ::Reflex::Type type_851c = ::Reflex::ConstBuilder(type_851);
  ::Reflex::Type type_20206 = ::Reflex::ReferenceBuilder(type_851c);
  ::Reflex::Type type_850c = ::Reflex::ConstBuilder(type_850);
  ::Reflex::Type type_20207 = ::Reflex::ReferenceBuilder(type_850c);
  ::Reflex::Type type_20208 = ::Reflex::ReferenceBuilder(type_850);
  ::Reflex::Type type_1065c = ::Reflex::ConstBuilder(type_1065);
  ::Reflex::Type type_4599 = ::Reflex::ReferenceBuilder(type_1065c);
  ::Reflex::Type type_20209 = ::Reflex::ReferenceBuilder(type_851);
  ::Reflex::Type type_20210 = ::Reflex::ReferenceBuilder(type_852);
  ::Reflex::Type type_852c = ::Reflex::ConstBuilder(type_852);
  ::Reflex::Type type_20211 = ::Reflex::ReferenceBuilder(type_852c);
  ::Reflex::Type type_20212 = ::Reflex::ReferenceBuilder(type_853);
  ::Reflex::Type type_853c = ::Reflex::ConstBuilder(type_853);
  ::Reflex::Type type_20213 = ::Reflex::ReferenceBuilder(type_853c);
  ::Reflex::Type type_20214 = ::Reflex::ReferenceBuilder(type_854);
  ::Reflex::Type type_854c = ::Reflex::ConstBuilder(type_854);
  ::Reflex::Type type_20215 = ::Reflex::ReferenceBuilder(type_854c);
  ::Reflex::Type type_1081c = ::Reflex::ConstBuilder(type_1081);
  ::Reflex::Type type_20216 = ::Reflex::ReferenceBuilder(type_1081c);
  ::Reflex::Type type_20217 = ::Reflex::ReferenceBuilder(type_855);
  ::Reflex::Type type_855c = ::Reflex::ConstBuilder(type_855);
  ::Reflex::Type type_20218 = ::Reflex::ReferenceBuilder(type_855c);
  ::Reflex::Type type_1070c = ::Reflex::ConstBuilder(type_1070);
  ::Reflex::Type type_20219 = ::Reflex::ReferenceBuilder(type_1070c);
  ::Reflex::Type type_20220 = ::Reflex::ReferenceBuilder(type_856);
  ::Reflex::Type type_856c = ::Reflex::ConstBuilder(type_856);
  ::Reflex::Type type_20221 = ::Reflex::ReferenceBuilder(type_856c);
  ::Reflex::Type type_20222 = ::Reflex::ReferenceBuilder(type_857);
  ::Reflex::Type type_857c = ::Reflex::ConstBuilder(type_857);
  ::Reflex::Type type_20223 = ::Reflex::ReferenceBuilder(type_857c);
  ::Reflex::Type type_1615c = ::Reflex::ConstBuilder(type_1615);
  ::Reflex::Type type_20224 = ::Reflex::ReferenceBuilder(type_1615c);
  ::Reflex::Type type_858c = ::Reflex::ConstBuilder(type_858);
  ::Reflex::Type type_8835 = ::Reflex::ReferenceBuilder(type_858c);
  ::Reflex::Type type_20226 = ::Reflex::ReferenceBuilder(type_859);
  ::Reflex::Type type_859c = ::Reflex::ConstBuilder(type_859);
  ::Reflex::Type type_20227 = ::Reflex::ReferenceBuilder(type_859c);
  ::Reflex::Type type_20228 = ::Reflex::ReferenceBuilder(type_860);
  ::Reflex::Type type_860c = ::Reflex::ConstBuilder(type_860);
  ::Reflex::Type type_20229 = ::Reflex::ReferenceBuilder(type_860c);
  ::Reflex::Type type_20230 = ::Reflex::ReferenceBuilder(type_861);
  ::Reflex::Type type_861c = ::Reflex::ConstBuilder(type_861);
  ::Reflex::Type type_20231 = ::Reflex::ReferenceBuilder(type_861c);
  ::Reflex::Type type_20232 = ::Reflex::ReferenceBuilder(type_862);
  ::Reflex::Type type_862c = ::Reflex::ConstBuilder(type_862);
  ::Reflex::Type type_20233 = ::Reflex::ReferenceBuilder(type_862c);
  ::Reflex::Type type_20234 = ::Reflex::ReferenceBuilder(type_863);
  ::Reflex::Type type_863c = ::Reflex::ConstBuilder(type_863);
  ::Reflex::Type type_20235 = ::Reflex::ReferenceBuilder(type_863c);
  ::Reflex::Type type_20236 = ::Reflex::ReferenceBuilder(type_864);
  ::Reflex::Type type_864c = ::Reflex::ConstBuilder(type_864);
  ::Reflex::Type type_20237 = ::Reflex::ReferenceBuilder(type_864c);
  ::Reflex::Type type_865c = ::Reflex::ConstBuilder(type_865);
  ::Reflex::Type type_6945 = ::Reflex::ReferenceBuilder(type_865c);
  ::Reflex::Type type_866c = ::Reflex::ConstBuilder(type_866);
  ::Reflex::Type type_7050 = ::Reflex::ReferenceBuilder(type_866c);
  ::Reflex::Type type_867c = ::Reflex::ConstBuilder(type_867);
  ::Reflex::Type type_7155 = ::Reflex::ReferenceBuilder(type_867c);
  ::Reflex::Type type_868c = ::Reflex::ConstBuilder(type_868);
  ::Reflex::Type type_7260 = ::Reflex::ReferenceBuilder(type_868c);
  ::Reflex::Type type_869c = ::Reflex::ConstBuilder(type_869);
  ::Reflex::Type type_7365 = ::Reflex::ReferenceBuilder(type_869c);
  ::Reflex::Type type_870c = ::Reflex::ConstBuilder(type_870);
  ::Reflex::Type type_7470 = ::Reflex::ReferenceBuilder(type_870c);
  ::Reflex::Type type_871c = ::Reflex::ConstBuilder(type_871);
  ::Reflex::Type type_7575 = ::Reflex::ReferenceBuilder(type_871c);
  ::Reflex::Type type_872c = ::Reflex::ConstBuilder(type_872);
  ::Reflex::Type type_7680 = ::Reflex::ReferenceBuilder(type_872c);
  ::Reflex::Type type_873c = ::Reflex::ConstBuilder(type_873);
  ::Reflex::Type type_7890 = ::Reflex::ReferenceBuilder(type_873c);
  ::Reflex::Type type_874c = ::Reflex::ConstBuilder(type_874);
  ::Reflex::Type type_7995 = ::Reflex::ReferenceBuilder(type_874c);
  ::Reflex::Type type_875c = ::Reflex::ConstBuilder(type_875);
  ::Reflex::Type type_8100 = ::Reflex::ReferenceBuilder(type_875c);
  ::Reflex::Type type_876c = ::Reflex::ConstBuilder(type_876);
  ::Reflex::Type type_8205 = ::Reflex::ReferenceBuilder(type_876c);
  ::Reflex::Type type_877c = ::Reflex::ConstBuilder(type_877);
  ::Reflex::Type type_8310 = ::Reflex::ReferenceBuilder(type_877c);
  ::Reflex::Type type_878c = ::Reflex::ConstBuilder(type_878);
  ::Reflex::Type type_8415 = ::Reflex::ReferenceBuilder(type_878c);
  ::Reflex::Type type_879c = ::Reflex::ConstBuilder(type_879);
  ::Reflex::Type type_8520 = ::Reflex::ReferenceBuilder(type_879c);
  ::Reflex::Type type_880c = ::Reflex::ConstBuilder(type_880);
  ::Reflex::Type type_8625 = ::Reflex::ReferenceBuilder(type_880c);
  ::Reflex::Type type_881c = ::Reflex::ConstBuilder(type_881);
  ::Reflex::Type type_8730 = ::Reflex::ReferenceBuilder(type_881c);
  ::Reflex::Type type_882c = ::Reflex::ConstBuilder(type_882);
  ::Reflex::Type type_8940 = ::Reflex::ReferenceBuilder(type_882c);
  ::Reflex::Type type_883c = ::Reflex::ConstBuilder(type_883);
  ::Reflex::Type type_9045 = ::Reflex::ReferenceBuilder(type_883c);
  ::Reflex::Type type_884c = ::Reflex::ConstBuilder(type_884);
  ::Reflex::Type type_9360 = ::Reflex::ReferenceBuilder(type_884c);
  ::Reflex::Type type_885c = ::Reflex::ConstBuilder(type_885);
  ::Reflex::Type type_9465 = ::Reflex::ReferenceBuilder(type_885c);
  ::Reflex::Type type_886c = ::Reflex::ConstBuilder(type_886);
  ::Reflex::Type type_9570 = ::Reflex::ReferenceBuilder(type_886c);
  ::Reflex::Type type_887c = ::Reflex::ConstBuilder(type_887);
  ::Reflex::Type type_9675 = ::Reflex::ReferenceBuilder(type_887c);
  ::Reflex::Type type_888c = ::Reflex::ConstBuilder(type_888);
  ::Reflex::Type type_9780 = ::Reflex::ReferenceBuilder(type_888c);
  ::Reflex::Type type_889c = ::Reflex::ConstBuilder(type_889);
  ::Reflex::Type type_9885 = ::Reflex::ReferenceBuilder(type_889c);
  ::Reflex::Type type_890c = ::Reflex::ConstBuilder(type_890);
  ::Reflex::Type type_9990 = ::Reflex::ReferenceBuilder(type_890c);
  ::Reflex::Type type_891c = ::Reflex::ConstBuilder(type_891);
  ::Reflex::Type type_10095 = ::Reflex::ReferenceBuilder(type_891c);
  ::Reflex::Type type_892c = ::Reflex::ConstBuilder(type_892);
  ::Reflex::Type type_10305 = ::Reflex::ReferenceBuilder(type_892c);
  ::Reflex::Type type_893c = ::Reflex::ConstBuilder(type_893);
  ::Reflex::Type type_10410 = ::Reflex::ReferenceBuilder(type_893c);
  ::Reflex::Type type_894c = ::Reflex::ConstBuilder(type_894);
  ::Reflex::Type type_10515 = ::Reflex::ReferenceBuilder(type_894c);
  ::Reflex::Type type_895c = ::Reflex::ConstBuilder(type_895);
  ::Reflex::Type type_10620 = ::Reflex::ReferenceBuilder(type_895c);
  ::Reflex::Type type_896c = ::Reflex::ConstBuilder(type_896);
  ::Reflex::Type type_10725 = ::Reflex::ReferenceBuilder(type_896c);
  ::Reflex::Type type_20244 = ::Reflex::ReferenceBuilder(type_1018);
  ::Reflex::Type type_1018c = ::Reflex::ConstBuilder(type_1018);
  ::Reflex::Type type_20245 = ::Reflex::ReferenceBuilder(type_1018c);
  ::Reflex::Type type_2150c = ::Reflex::ConstBuilder(type_2150);
  ::Reflex::Type type_2418 = ::Reflex::PointerBuilder(type_2150c);
  ::Reflex::Type type_3630 = ::Reflex::PointerBuilder(type_2418);
  ::Reflex::Type type_2418c = ::Reflex::ConstBuilder(type_2418);
  ::Reflex::Type type_3632 = ::Reflex::PointerBuilder(type_2418c);
  ::Reflex::Type type_3634 = ::Reflex::ReferenceBuilder(type_2418);
  ::Reflex::Type type_3636 = ::Reflex::ReferenceBuilder(type_2418c);
  ::Reflex::Type type_1654 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_75);
  ::Reflex::Type type_1592 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_48);
  ::Reflex::Type type_1327c = ::Reflex::ConstBuilder(type_1327);
  ::Reflex::Type type_20283 = ::Reflex::ReferenceBuilder(type_1327c);
  ::Reflex::Type type_1049c = ::Reflex::ConstBuilder(type_1049);
  ::Reflex::Type type_20284 = ::Reflex::ReferenceBuilder(type_1049c);
  ::Reflex::Type type_20285 = ::Reflex::ReferenceBuilder(type_1049);
  ::Reflex::Type type_2472 = ::Reflex::PointerBuilder(type_167);
  ::Reflex::Type type_3759 = ::Reflex::PointerBuilder(type_167c);
  ::Reflex::Type type_3472 = ::Reflex::ReferenceBuilder(type_167);
  ::Reflex::Type type_1329c = ::Reflex::ConstBuilder(type_1329);
  ::Reflex::Type type_20290 = ::Reflex::ReferenceBuilder(type_1329c);
  ::Reflex::Type type_4144 = ::Reflex::ReferenceBuilder(type_1051);
  ::Reflex::Type type_3481 = ::Reflex::PointerBuilder(type_75);
  ::Reflex::Type type_3822 = ::Reflex::PointerBuilder(type_75c);
  ::Reflex::Type type_3483 = ::Reflex::ReferenceBuilder(type_75);
  ::Reflex::Type type_1330c = ::Reflex::ConstBuilder(type_1330);
  ::Reflex::Type type_20291 = ::Reflex::ReferenceBuilder(type_1330c);
  ::Reflex::Type type_20292 = ::Reflex::ReferenceBuilder(type_1052);
  ::Reflex::Type type_3492 = ::Reflex::PointerBuilder(type_2144);
  ::Reflex::Type type_3885 = ::Reflex::PointerBuilder(type_2144c);
  ::Reflex::Type type_3494 = ::Reflex::ReferenceBuilder(type_2144);
  ::Reflex::Type type_1331c = ::Reflex::ConstBuilder(type_1331);
  ::Reflex::Type type_20293 = ::Reflex::ReferenceBuilder(type_1331c);
  ::Reflex::Type type_1053c = ::Reflex::ConstBuilder(type_1053);
  ::Reflex::Type type_20294 = ::Reflex::ReferenceBuilder(type_1053c);
  ::Reflex::Type type_20295 = ::Reflex::ReferenceBuilder(type_1053);
  ::Reflex::Type type_3503 = ::Reflex::PointerBuilder(type_78);
  ::Reflex::Type type_3948 = ::Reflex::PointerBuilder(type_78c);
  ::Reflex::Type type_3505 = ::Reflex::ReferenceBuilder(type_78);
  ::Reflex::Type type_1332c = ::Reflex::ConstBuilder(type_1332);
  ::Reflex::Type type_20296 = ::Reflex::ReferenceBuilder(type_1332c);
  ::Reflex::Type type_4209 = ::Reflex::ReferenceBuilder(type_1054);
  ::Reflex::Type type_4010 = ::Reflex::PointerBuilder(type_528);
  ::Reflex::Type type_528c = ::Reflex::ConstBuilder(type_528);
  ::Reflex::Type type_4012 = ::Reflex::PointerBuilder(type_528c);
  ::Reflex::Type type_4014 = ::Reflex::ReferenceBuilder(type_528);
  ::Reflex::Type type_4016 = ::Reflex::ReferenceBuilder(type_528c);
  ::Reflex::Type type_1333c = ::Reflex::ConstBuilder(type_1333);
  ::Reflex::Type type_20298 = ::Reflex::ReferenceBuilder(type_1333c);
  ::Reflex::Type type_1055c = ::Reflex::ConstBuilder(type_1055);
  ::Reflex::Type type_20299 = ::Reflex::ReferenceBuilder(type_1055c);
  ::Reflex::Type type_20300 = ::Reflex::ReferenceBuilder(type_1055);
  ::Reflex::Type type_4075 = ::Reflex::PointerBuilder(type_4010);
  ::Reflex::Type type_4010c = ::Reflex::ConstBuilder(type_4010);
  ::Reflex::Type type_4077 = ::Reflex::PointerBuilder(type_4010c);
  ::Reflex::Type type_4079 = ::Reflex::ReferenceBuilder(type_4010);
  ::Reflex::Type type_4081 = ::Reflex::ReferenceBuilder(type_4010c);
  ::Reflex::Type type_1334c = ::Reflex::ConstBuilder(type_1334);
  ::Reflex::Type type_20302 = ::Reflex::ReferenceBuilder(type_1334c);
  ::Reflex::Type type_1056c = ::Reflex::ConstBuilder(type_1056);
  ::Reflex::Type type_20303 = ::Reflex::ReferenceBuilder(type_1056c);
  ::Reflex::Type type_20304 = ::Reflex::ReferenceBuilder(type_1056);
  ::Reflex::Type type_4140 = ::Reflex::PointerBuilder(type_1051);
  ::Reflex::Type type_4142 = ::Reflex::PointerBuilder(type_1051c);
  ::Reflex::Type type_1335c = ::Reflex::ConstBuilder(type_1335);
  ::Reflex::Type type_20306 = ::Reflex::ReferenceBuilder(type_1335c);
  ::Reflex::Type type_1057c = ::Reflex::ConstBuilder(type_1057);
  ::Reflex::Type type_20307 = ::Reflex::ReferenceBuilder(type_1057c);
  ::Reflex::Type type_20308 = ::Reflex::ReferenceBuilder(type_1057);
  ::Reflex::Type type_4205 = ::Reflex::PointerBuilder(type_1054);
  ::Reflex::Type type_4207 = ::Reflex::PointerBuilder(type_1054c);
  ::Reflex::Type type_1336c = ::Reflex::ConstBuilder(type_1336);
  ::Reflex::Type type_20310 = ::Reflex::ReferenceBuilder(type_1336c);
  ::Reflex::Type type_1058c = ::Reflex::ConstBuilder(type_1058);
  ::Reflex::Type type_20311 = ::Reflex::ReferenceBuilder(type_1058c);
  ::Reflex::Type type_20312 = ::Reflex::ReferenceBuilder(type_1058);
  ::Reflex::Type type_2054 = ::Reflex::PointerBuilder(type_22);
  ::Reflex::Type type_4401 = ::Reflex::PointerBuilder(type_22c);
  ::Reflex::Type type_3569 = ::Reflex::ReferenceBuilder(type_22);
  ::Reflex::Type type_1339c = ::Reflex::ConstBuilder(type_1339);
  ::Reflex::Type type_20319 = ::Reflex::ReferenceBuilder(type_1339c);
  ::Reflex::Type type_1061c = ::Reflex::ConstBuilder(type_1061);
  ::Reflex::Type type_4341 = ::Reflex::ReferenceBuilder(type_1061c);
  ::Reflex::Type type_4339 = ::Reflex::ReferenceBuilder(type_1061);
  ::Reflex::Type type_4335 = ::Reflex::PointerBuilder(type_1061);
  ::Reflex::Type type_4337 = ::Reflex::PointerBuilder(type_1061c);
  ::Reflex::Type type_1338c = ::Reflex::ConstBuilder(type_1338);
  ::Reflex::Type type_20318 = ::Reflex::ReferenceBuilder(type_1338c);
  ::Reflex::Type type_1060c = ::Reflex::ConstBuilder(type_1060);
  ::Reflex::Type type_4276 = ::Reflex::ReferenceBuilder(type_1060c);
  ::Reflex::Type type_4274 = ::Reflex::ReferenceBuilder(type_1060);
  ::Reflex::Type type_4270 = ::Reflex::PointerBuilder(type_1060);
  ::Reflex::Type type_4272 = ::Reflex::PointerBuilder(type_1060c);
  ::Reflex::Type type_1337c = ::Reflex::ConstBuilder(type_1337);
  ::Reflex::Type type_20314 = ::Reflex::ReferenceBuilder(type_1337c);
  ::Reflex::Type type_1059c = ::Reflex::ConstBuilder(type_1059);
  ::Reflex::Type type_20315 = ::Reflex::ReferenceBuilder(type_1059c);
  ::Reflex::Type type_20316 = ::Reflex::ReferenceBuilder(type_1059);
  ::Reflex::Type type_4528 = ::Reflex::PointerBuilder(type_812);
  ::Reflex::Type type_4530 = ::Reflex::PointerBuilder(type_812c);
  ::Reflex::Type type_1341c = ::Reflex::ConstBuilder(type_1341);
  ::Reflex::Type type_20325 = ::Reflex::ReferenceBuilder(type_1341c);
  ::Reflex::Type type_1063c = ::Reflex::ConstBuilder(type_1063);
  ::Reflex::Type type_4469 = ::Reflex::ReferenceBuilder(type_1063c);
  ::Reflex::Type type_4467 = ::Reflex::ReferenceBuilder(type_1063);
  ::Reflex::Type type_4463 = ::Reflex::PointerBuilder(type_1063);
  ::Reflex::Type type_4465 = ::Reflex::PointerBuilder(type_1063c);
  ::Reflex::Type type_1340c = ::Reflex::ConstBuilder(type_1340);
  ::Reflex::Type type_20321 = ::Reflex::ReferenceBuilder(type_1340c);
  ::Reflex::Type type_1062c = ::Reflex::ConstBuilder(type_1062);
  ::Reflex::Type type_20322 = ::Reflex::ReferenceBuilder(type_1062c);
  ::Reflex::Type type_20323 = ::Reflex::ReferenceBuilder(type_1062);
  ::Reflex::Type type_3525 = ::Reflex::PointerBuilder(type_113);
  ::Reflex::Type type_4659 = ::Reflex::PointerBuilder(type_113c);
  ::Reflex::Type type_3527 = ::Reflex::ReferenceBuilder(type_113);
  ::Reflex::Type type_1343c = ::Reflex::ConstBuilder(type_1343);
  ::Reflex::Type type_20330 = ::Reflex::ReferenceBuilder(type_1343c);
  ::Reflex::Type type_4597 = ::Reflex::ReferenceBuilder(type_1065);
  ::Reflex::Type type_4593 = ::Reflex::PointerBuilder(type_1065);
  ::Reflex::Type type_4595 = ::Reflex::PointerBuilder(type_1065c);
  ::Reflex::Type type_1342c = ::Reflex::ConstBuilder(type_1342);
  ::Reflex::Type type_20327 = ::Reflex::ReferenceBuilder(type_1342c);
  ::Reflex::Type type_1064c = ::Reflex::ConstBuilder(type_1064);
  ::Reflex::Type type_20328 = ::Reflex::ReferenceBuilder(type_1064c);
  ::Reflex::Type type_20329 = ::Reflex::ReferenceBuilder(type_1064);
  ::Reflex::Type type_2462 = ::Reflex::PointerBuilder(type_2058);
  ::Reflex::Type type_4787 = ::Reflex::PointerBuilder(type_2058c);
  ::Reflex::Type type_3579 = ::Reflex::ReferenceBuilder(type_2058);
  ::Reflex::Type type_1345c = ::Reflex::ConstBuilder(type_1345);
  ::Reflex::Type type_20336 = ::Reflex::ReferenceBuilder(type_1345c);
  ::Reflex::Type type_1067c = ::Reflex::ConstBuilder(type_1067);
  ::Reflex::Type type_4727 = ::Reflex::ReferenceBuilder(type_1067c);
  ::Reflex::Type type_4725 = ::Reflex::ReferenceBuilder(type_1067);
  ::Reflex::Type type_4721 = ::Reflex::PointerBuilder(type_1067);
  ::Reflex::Type type_4723 = ::Reflex::PointerBuilder(type_1067c);
  ::Reflex::Type type_1344c = ::Reflex::ConstBuilder(type_1344);
  ::Reflex::Type type_20332 = ::Reflex::ReferenceBuilder(type_1344c);
  ::Reflex::Type type_1066c = ::Reflex::ConstBuilder(type_1066);
  ::Reflex::Type type_20333 = ::Reflex::ReferenceBuilder(type_1066c);
  ::Reflex::Type type_20334 = ::Reflex::ReferenceBuilder(type_1066);
  ::Reflex::Type type_3588 = ::Reflex::PointerBuilder(type_2052);
  ::Reflex::Type type_4915 = ::Reflex::PointerBuilder(type_2052c);
  ::Reflex::Type type_3590 = ::Reflex::ReferenceBuilder(type_2052);
  ::Reflex::Type type_1347c = ::Reflex::ConstBuilder(type_1347);
  ::Reflex::Type type_20342 = ::Reflex::ReferenceBuilder(type_1347c);
  ::Reflex::Type type_4853 = ::Reflex::ReferenceBuilder(type_1069);
  ::Reflex::Type type_4849 = ::Reflex::PointerBuilder(type_1069);
  ::Reflex::Type type_4851 = ::Reflex::PointerBuilder(type_1069c);
  ::Reflex::Type type_1346c = ::Reflex::ConstBuilder(type_1346);
  ::Reflex::Type type_20338 = ::Reflex::ReferenceBuilder(type_1346c);
  ::Reflex::Type type_1068c = ::Reflex::ConstBuilder(type_1068);
  ::Reflex::Type type_20339 = ::Reflex::ReferenceBuilder(type_1068c);
  ::Reflex::Type type_20340 = ::Reflex::ReferenceBuilder(type_1068);
  ::Reflex::Type type_1654c = ::Reflex::ConstBuilder(type_1654);
  ::Reflex::Type type_3600 = ::Reflex::ReferenceBuilder(type_2616);
  ::Reflex::Type type_2616c = ::Reflex::ConstBuilder(type_2616);
  ::Reflex::Type type_6272 = ::Reflex::ReferenceBuilder(type_2616c);
  ::Reflex::Type type_791 = ::Reflex::PointerBuilder(type_2616);
  ::Reflex::Type type_2053 = ::Reflex::PointerBuilder(type_2616c);
  ::Reflex::Type type_1350c = ::Reflex::ConstBuilder(type_1350);
  ::Reflex::Type type_20416 = ::Reflex::ReferenceBuilder(type_1350c);
  ::Reflex::Type type_3516 = ::Reflex::ReferenceBuilder(type_1104);
  ::Reflex::Type type_3514 = ::Reflex::PointerBuilder(type_1104);
  ::Reflex::Type type_4978 = ::Reflex::PointerBuilder(type_1104c);
  ::Reflex::Type type_1348c = ::Reflex::ConstBuilder(type_1348);
  ::Reflex::Type type_20343 = ::Reflex::ReferenceBuilder(type_1348c);
  ::Reflex::Type type_20344 = ::Reflex::ReferenceBuilder(type_1070);
  ::Reflex::Type type_5040 = ::Reflex::PointerBuilder(type_813);
  ::Reflex::Type type_5042 = ::Reflex::PointerBuilder(type_813c);
  ::Reflex::Type type_1349c = ::Reflex::ConstBuilder(type_1349);
  ::Reflex::Type type_20346 = ::Reflex::ReferenceBuilder(type_1349c);
  ::Reflex::Type type_1071c = ::Reflex::ConstBuilder(type_1071);
  ::Reflex::Type type_20347 = ::Reflex::ReferenceBuilder(type_1071c);
  ::Reflex::Type type_20348 = ::Reflex::ReferenceBuilder(type_1071);
  ::Reflex::Type type_5105 = ::Reflex::PointerBuilder(type_814);
  ::Reflex::Type type_5107 = ::Reflex::PointerBuilder(type_814c);
  ::Reflex::Type type_1351c = ::Reflex::ConstBuilder(type_1351);
  ::Reflex::Type type_20350 = ::Reflex::ReferenceBuilder(type_1351c);
  ::Reflex::Type type_1072c = ::Reflex::ConstBuilder(type_1072);
  ::Reflex::Type type_20351 = ::Reflex::ReferenceBuilder(type_1072c);
  ::Reflex::Type type_20352 = ::Reflex::ReferenceBuilder(type_1072);
  ::Reflex::Type type_5170 = ::Reflex::PointerBuilder(type_815);
  ::Reflex::Type type_5172 = ::Reflex::PointerBuilder(type_815c);
  ::Reflex::Type type_1352c = ::Reflex::ConstBuilder(type_1352);
  ::Reflex::Type type_20354 = ::Reflex::ReferenceBuilder(type_1352c);
  ::Reflex::Type type_1073c = ::Reflex::ConstBuilder(type_1073);
  ::Reflex::Type type_20355 = ::Reflex::ReferenceBuilder(type_1073c);
  ::Reflex::Type type_20356 = ::Reflex::ReferenceBuilder(type_1073);
  ::Reflex::Type type_5235 = ::Reflex::PointerBuilder(type_816);
  ::Reflex::Type type_5237 = ::Reflex::PointerBuilder(type_816c);
  ::Reflex::Type type_1353c = ::Reflex::ConstBuilder(type_1353);
  ::Reflex::Type type_20358 = ::Reflex::ReferenceBuilder(type_1353c);
  ::Reflex::Type type_1074c = ::Reflex::ConstBuilder(type_1074);
  ::Reflex::Type type_20359 = ::Reflex::ReferenceBuilder(type_1074c);
  ::Reflex::Type type_20360 = ::Reflex::ReferenceBuilder(type_1074);
  ::Reflex::Type type_5300 = ::Reflex::PointerBuilder(type_817);
  ::Reflex::Type type_5302 = ::Reflex::PointerBuilder(type_817c);
  ::Reflex::Type type_1354c = ::Reflex::ConstBuilder(type_1354);
  ::Reflex::Type type_20362 = ::Reflex::ReferenceBuilder(type_1354c);
  ::Reflex::Type type_20363 = ::Reflex::ReferenceBuilder(type_1075);
  ::Reflex::Type type_5365 = ::Reflex::PointerBuilder(type_818);
  ::Reflex::Type type_5367 = ::Reflex::PointerBuilder(type_818c);
  ::Reflex::Type type_1355c = ::Reflex::ConstBuilder(type_1355);
  ::Reflex::Type type_20365 = ::Reflex::ReferenceBuilder(type_1355c);
  ::Reflex::Type type_20366 = ::Reflex::ReferenceBuilder(type_1076);
  ::Reflex::Type type_5430 = ::Reflex::PointerBuilder(type_819);
  ::Reflex::Type type_5432 = ::Reflex::PointerBuilder(type_819c);
  ::Reflex::Type type_1356c = ::Reflex::ConstBuilder(type_1356);
  ::Reflex::Type type_20368 = ::Reflex::ReferenceBuilder(type_1356c);
  ::Reflex::Type type_1077c = ::Reflex::ConstBuilder(type_1077);
  ::Reflex::Type type_20369 = ::Reflex::ReferenceBuilder(type_1077c);
  ::Reflex::Type type_20370 = ::Reflex::ReferenceBuilder(type_1077);
  ::Reflex::Type type_5495 = ::Reflex::PointerBuilder(type_820);
  ::Reflex::Type type_5497 = ::Reflex::PointerBuilder(type_820c);
  ::Reflex::Type type_1357c = ::Reflex::ConstBuilder(type_1357);
  ::Reflex::Type type_20372 = ::Reflex::ReferenceBuilder(type_1357c);
  ::Reflex::Type type_20373 = ::Reflex::ReferenceBuilder(type_1078);
  ::Reflex::Type type_5560 = ::Reflex::PointerBuilder(type_821);
  ::Reflex::Type type_5562 = ::Reflex::PointerBuilder(type_821c);
  ::Reflex::Type type_1358c = ::Reflex::ConstBuilder(type_1358);
  ::Reflex::Type type_20375 = ::Reflex::ReferenceBuilder(type_1358c);
  ::Reflex::Type type_1079c = ::Reflex::ConstBuilder(type_1079);
  ::Reflex::Type type_20376 = ::Reflex::ReferenceBuilder(type_1079c);
  ::Reflex::Type type_20377 = ::Reflex::ReferenceBuilder(type_1079);
  ::Reflex::Type type_5625 = ::Reflex::PointerBuilder(type_822);
  ::Reflex::Type type_5627 = ::Reflex::PointerBuilder(type_822c);
  ::Reflex::Type type_1359c = ::Reflex::ConstBuilder(type_1359);
  ::Reflex::Type type_20379 = ::Reflex::ReferenceBuilder(type_1359c);
  ::Reflex::Type type_1080c = ::Reflex::ConstBuilder(type_1080);
  ::Reflex::Type type_20380 = ::Reflex::ReferenceBuilder(type_1080c);
  ::Reflex::Type type_20381 = ::Reflex::ReferenceBuilder(type_1080);
  ::Reflex::Type type_5690 = ::Reflex::PointerBuilder(type_823);
  ::Reflex::Type type_5692 = ::Reflex::PointerBuilder(type_823c);
  ::Reflex::Type type_1360c = ::Reflex::ConstBuilder(type_1360);
  ::Reflex::Type type_20383 = ::Reflex::ReferenceBuilder(type_1360c);
  ::Reflex::Type type_20384 = ::Reflex::ReferenceBuilder(type_1081);
  ::Reflex::Type type_5755 = ::Reflex::PointerBuilder(type_824);
  ::Reflex::Type type_5757 = ::Reflex::PointerBuilder(type_824c);
  ::Reflex::Type type_1361c = ::Reflex::ConstBuilder(type_1361);
  ::Reflex::Type type_20386 = ::Reflex::ReferenceBuilder(type_1361c);
  ::Reflex::Type type_1082c = ::Reflex::ConstBuilder(type_1082);
  ::Reflex::Type type_20387 = ::Reflex::ReferenceBuilder(type_1082c);
  ::Reflex::Type type_20388 = ::Reflex::ReferenceBuilder(type_1082);
  ::Reflex::Type type_5820 = ::Reflex::PointerBuilder(type_825);
  ::Reflex::Type type_5822 = ::Reflex::PointerBuilder(type_825c);
  ::Reflex::Type type_1362c = ::Reflex::ConstBuilder(type_1362);
  ::Reflex::Type type_20389 = ::Reflex::ReferenceBuilder(type_1362c);
  ::Reflex::Type type_1083c = ::Reflex::ConstBuilder(type_1083);
  ::Reflex::Type type_20390 = ::Reflex::ReferenceBuilder(type_1083c);
  ::Reflex::Type type_20391 = ::Reflex::ReferenceBuilder(type_1083);
  ::Reflex::Type type_5885 = ::Reflex::PointerBuilder(type_826);
  ::Reflex::Type type_5887 = ::Reflex::PointerBuilder(type_826c);
  ::Reflex::Type type_1363c = ::Reflex::ConstBuilder(type_1363);
  ::Reflex::Type type_20393 = ::Reflex::ReferenceBuilder(type_1363c);
  ::Reflex::Type type_1084c = ::Reflex::ConstBuilder(type_1084);
  ::Reflex::Type type_20394 = ::Reflex::ReferenceBuilder(type_1084c);
  ::Reflex::Type type_20395 = ::Reflex::ReferenceBuilder(type_1084);
  ::Reflex::Type type_5950 = ::Reflex::PointerBuilder(type_827);
  ::Reflex::Type type_5952 = ::Reflex::PointerBuilder(type_827c);
  ::Reflex::Type type_1364c = ::Reflex::ConstBuilder(type_1364);
  ::Reflex::Type type_20397 = ::Reflex::ReferenceBuilder(type_1364c);
  ::Reflex::Type type_1085c = ::Reflex::ConstBuilder(type_1085);
  ::Reflex::Type type_20398 = ::Reflex::ReferenceBuilder(type_1085c);
  ::Reflex::Type type_20399 = ::Reflex::ReferenceBuilder(type_1085);
  ::Reflex::Type type_10194 = ::Reflex::PointerBuilder(type_828);
  ::Reflex::Type type_10196 = ::Reflex::PointerBuilder(type_828c);
  ::Reflex::Type type_10198 = ::Reflex::ReferenceBuilder(type_828);
  ::Reflex::Type type_2022c = ::Reflex::ConstBuilder(type_2022);
  ::Reflex::Type type_20709 = ::Reflex::ReferenceBuilder(type_2022c);
  ::Reflex::Type type_1366c = ::Reflex::ConstBuilder(type_1366);
  ::Reflex::Type type_20717 = ::Reflex::ReferenceBuilder(type_1366c);
  ::Reflex::Type type_1614c = ::Reflex::ConstBuilder(type_1614);
  ::Reflex::Type type_6021 = ::Reflex::ReferenceBuilder(type_1614c);
  ::Reflex::Type type_6019 = ::Reflex::ReferenceBuilder(type_1614);
  ::Reflex::Type type_6015 = ::Reflex::PointerBuilder(type_1614);
  ::Reflex::Type type_6017 = ::Reflex::PointerBuilder(type_1614c);
  ::Reflex::Type type_1365c = ::Reflex::ConstBuilder(type_1365);
  ::Reflex::Type type_20401 = ::Reflex::ReferenceBuilder(type_1365c);
  ::Reflex::Type type_1086c = ::Reflex::ConstBuilder(type_1086);
  ::Reflex::Type type_20402 = ::Reflex::ReferenceBuilder(type_1086c);
  ::Reflex::Type type_20403 = ::Reflex::ReferenceBuilder(type_1086);
  ::Reflex::Type type_3536 = ::Reflex::PointerBuilder(type_48);
  ::Reflex::Type type_48c = ::Reflex::ConstBuilder(type_48);
  ::Reflex::Type type_6081 = ::Reflex::PointerBuilder(type_48c);
  ::Reflex::Type type_3538 = ::Reflex::ReferenceBuilder(type_48);
  ::Reflex::Type type_6084 = ::Reflex::ReferenceBuilder(type_48c);
  ::Reflex::Type type_1367c = ::Reflex::ConstBuilder(type_1367);
  ::Reflex::Type type_20405 = ::Reflex::ReferenceBuilder(type_1367c);
  ::Reflex::Type type_1087c = ::Reflex::ConstBuilder(type_1087);
  ::Reflex::Type type_20406 = ::Reflex::ReferenceBuilder(type_1087c);
  ::Reflex::Type type_20407 = ::Reflex::ReferenceBuilder(type_1087);
  ::Reflex::Type type_3547 = ::Reflex::PointerBuilder(type_2087);
  ::Reflex::Type type_2087c = ::Reflex::ConstBuilder(type_2087);
  ::Reflex::Type type_6144 = ::Reflex::PointerBuilder(type_2087c);
  ::Reflex::Type type_3549 = ::Reflex::ReferenceBuilder(type_2087);
  ::Reflex::Type type_6147 = ::Reflex::ReferenceBuilder(type_2087c);
  ::Reflex::Type type_1368c = ::Reflex::ConstBuilder(type_1368);
  ::Reflex::Type type_20409 = ::Reflex::ReferenceBuilder(type_1368c);
  ::Reflex::Type type_1088c = ::Reflex::ConstBuilder(type_1088);
  ::Reflex::Type type_20410 = ::Reflex::ReferenceBuilder(type_1088c);
  ::Reflex::Type type_20411 = ::Reflex::ReferenceBuilder(type_1088);
  ::Reflex::Type type_2463 = ::Reflex::PointerBuilder(type_2059);
  ::Reflex::Type type_2059c = ::Reflex::ConstBuilder(type_2059);
  ::Reflex::Type type_6207 = ::Reflex::PointerBuilder(type_2059c);
  ::Reflex::Type type_3559 = ::Reflex::ReferenceBuilder(type_2059);
  ::Reflex::Type type_6210 = ::Reflex::ReferenceBuilder(type_2059c);
  ::Reflex::Type type_1369c = ::Reflex::ConstBuilder(type_1369);
  ::Reflex::Type type_20413 = ::Reflex::ReferenceBuilder(type_1369c);
  ::Reflex::Type type_1089c = ::Reflex::ConstBuilder(type_1089);
  ::Reflex::Type type_20414 = ::Reflex::ReferenceBuilder(type_1089c);
  ::Reflex::Type type_20415 = ::Reflex::ReferenceBuilder(type_1089);
  ::Reflex::Type type_1090c = ::Reflex::ConstBuilder(type_1090);
  ::Reflex::Type type_20417 = ::Reflex::ReferenceBuilder(type_1090c);
  ::Reflex::Type type_20418 = ::Reflex::ReferenceBuilder(type_1090);
  ::Reflex::Type type_2549 = ::Reflex::PointerBuilder(type_791);
  ::Reflex::Type type_791c = ::Reflex::ConstBuilder(type_791);
  ::Reflex::Type type_2100 = ::Reflex::PointerBuilder(type_791c);
  ::Reflex::Type type_6333 = ::Reflex::ReferenceBuilder(type_791);
  ::Reflex::Type type_6335 = ::Reflex::ReferenceBuilder(type_791c);
  ::Reflex::Type type_1370c = ::Reflex::ConstBuilder(type_1370);
  ::Reflex::Type type_20419 = ::Reflex::ReferenceBuilder(type_1370c);
  ::Reflex::Type type_1091c = ::Reflex::ConstBuilder(type_1091);
  ::Reflex::Type type_20420 = ::Reflex::ReferenceBuilder(type_1091c);
  ::Reflex::Type type_20421 = ::Reflex::ReferenceBuilder(type_1091);
  ::Reflex::Type type_3619 = ::Reflex::PointerBuilder(type_1110);
  ::Reflex::Type type_3609 = ::Reflex::PointerBuilder(type_2083c);
  ::Reflex::Type type_1371c = ::Reflex::ConstBuilder(type_1371);
  ::Reflex::Type type_20422 = ::Reflex::ReferenceBuilder(type_1371c);
  ::Reflex::Type type_1092c = ::Reflex::ConstBuilder(type_1092);
  ::Reflex::Type type_20423 = ::Reflex::ReferenceBuilder(type_1092c);
  ::Reflex::Type type_20424 = ::Reflex::ReferenceBuilder(type_1092);
  ::Reflex::Type type_20877 = ::Reflex::ReferenceBuilder(type_1292);
  ::Reflex::Type type_1292c = ::Reflex::ConstBuilder(type_1292);
  ::Reflex::Type type_20878 = ::Reflex::ReferenceBuilder(type_1292c);
  ::Reflex::Type type_20899 = ::Reflex::ReferenceBuilder(type_1326);
  ::Reflex::Type type_1326c = ::Reflex::ConstBuilder(type_1326);
  ::Reflex::Type type_20900 = ::Reflex::ReferenceBuilder(type_1326c);
  ::Reflex::Type type_20896 = ::Reflex::ReferenceBuilder(type_1339);
  ::Reflex::Type type_20916 = ::Reflex::ReferenceBuilder(type_1343);
  ::Reflex::Type type_20920 = ::Reflex::ReferenceBuilder(type_1347);
  ::Reflex::Type type_20923 = ::Reflex::ReferenceBuilder(type_1350);
  ::Reflex::Type type_2023c = ::Reflex::ConstBuilder(type_2023);
  ::Reflex::Type type_20471 = ::Reflex::ReferenceBuilder(type_2023c);
  ::Reflex::Type type_1585c = ::Reflex::ConstBuilder(type_1585);
  ::Reflex::Type type_21247 = ::Reflex::ReferenceBuilder(type_1585c);
  ::Reflex::Type type_21248 = ::Reflex::ReferenceBuilder(type_1585);
  ::Reflex::Type type_2024c = ::Reflex::ConstBuilder(type_2024);
  ::Reflex::Type type_20477 = ::Reflex::ReferenceBuilder(type_2024c);
  ::Reflex::Type type_1586c = ::Reflex::ConstBuilder(type_1586);
  ::Reflex::Type type_21249 = ::Reflex::ReferenceBuilder(type_1586c);
  ::Reflex::Type type_21250 = ::Reflex::ReferenceBuilder(type_1586);
  ::Reflex::Type type_21272 = ::Reflex::ReferenceBuilder(type_1589);
  ::Reflex::Type type_1589c = ::Reflex::ConstBuilder(type_1589);
  ::Reflex::Type type_21273 = ::Reflex::ReferenceBuilder(type_1589c);
  ::Reflex::Type type_1603c = ::Reflex::ConstBuilder(type_1603);
  ::Reflex::Type type_21275 = ::Reflex::ReferenceBuilder(type_1603c);
  ::Reflex::Type type_21276 = ::Reflex::ReferenceBuilder(type_1603);
  ::Reflex::Type type_8829 = ::Reflex::PointerBuilder(type_858);
  ::Reflex::Type type_8831 = ::Reflex::PointerBuilder(type_858c);
  ::Reflex::Type type_8833 = ::Reflex::ReferenceBuilder(type_858);
  ::Reflex::Type type_1374c = ::Reflex::ConstBuilder(type_1374);
  ::Reflex::Type type_20622 = ::Reflex::ReferenceBuilder(type_1374c);
  ::Reflex::Type type_21285 = ::Reflex::ReferenceBuilder(type_1615);
  ::Reflex::Type type_6939 = ::Reflex::PointerBuilder(type_865);
  ::Reflex::Type type_6941 = ::Reflex::PointerBuilder(type_865c);
  ::Reflex::Type type_6943 = ::Reflex::ReferenceBuilder(type_865);
  ::Reflex::Type type_2026c = ::Reflex::ConstBuilder(type_2026);
  ::Reflex::Type type_20492 = ::Reflex::ReferenceBuilder(type_2026c);
  ::Reflex::Type type_1378c = ::Reflex::ConstBuilder(type_1378);
  ::Reflex::Type type_20493 = ::Reflex::ReferenceBuilder(type_1378c);
  ::Reflex::Type type_1616c = ::Reflex::ConstBuilder(type_1616);
  ::Reflex::Type type_21286 = ::Reflex::ReferenceBuilder(type_1616c);
  ::Reflex::Type type_21287 = ::Reflex::ReferenceBuilder(type_1616);
  ::Reflex::Type type_7044 = ::Reflex::PointerBuilder(type_866);
  ::Reflex::Type type_7046 = ::Reflex::PointerBuilder(type_866c);
  ::Reflex::Type type_7048 = ::Reflex::ReferenceBuilder(type_866);
  ::Reflex::Type type_1380c = ::Reflex::ConstBuilder(type_1380);
  ::Reflex::Type type_20500 = ::Reflex::ReferenceBuilder(type_1380c);
  ::Reflex::Type type_1617c = ::Reflex::ConstBuilder(type_1617);
  ::Reflex::Type type_21288 = ::Reflex::ReferenceBuilder(type_1617c);
  ::Reflex::Type type_21289 = ::Reflex::ReferenceBuilder(type_1617);
  ::Reflex::Type type_7149 = ::Reflex::PointerBuilder(type_867);
  ::Reflex::Type type_7151 = ::Reflex::PointerBuilder(type_867c);
  ::Reflex::Type type_7153 = ::Reflex::ReferenceBuilder(type_867);
  ::Reflex::Type type_1382c = ::Reflex::ConstBuilder(type_1382);
  ::Reflex::Type type_20507 = ::Reflex::ReferenceBuilder(type_1382c);
  ::Reflex::Type type_1618c = ::Reflex::ConstBuilder(type_1618);
  ::Reflex::Type type_21290 = ::Reflex::ReferenceBuilder(type_1618c);
  ::Reflex::Type type_21291 = ::Reflex::ReferenceBuilder(type_1618);
  ::Reflex::Type type_7254 = ::Reflex::PointerBuilder(type_868);
  ::Reflex::Type type_7256 = ::Reflex::PointerBuilder(type_868c);
  ::Reflex::Type type_7258 = ::Reflex::ReferenceBuilder(type_868);
  ::Reflex::Type type_2027c = ::Reflex::ConstBuilder(type_2027);
  ::Reflex::Type type_20514 = ::Reflex::ReferenceBuilder(type_2027c);
  ::Reflex::Type type_1384c = ::Reflex::ConstBuilder(type_1384);
  ::Reflex::Type type_20515 = ::Reflex::ReferenceBuilder(type_1384c);
  ::Reflex::Type type_1619c = ::Reflex::ConstBuilder(type_1619);
  ::Reflex::Type type_21292 = ::Reflex::ReferenceBuilder(type_1619c);
  ::Reflex::Type type_21293 = ::Reflex::ReferenceBuilder(type_1619);
  ::Reflex::Type type_7359 = ::Reflex::PointerBuilder(type_869);
  ::Reflex::Type type_7361 = ::Reflex::PointerBuilder(type_869c);
  ::Reflex::Type type_7363 = ::Reflex::ReferenceBuilder(type_869);
  ::Reflex::Type type_1386c = ::Reflex::ConstBuilder(type_1386);
  ::Reflex::Type type_20522 = ::Reflex::ReferenceBuilder(type_1386c);
  ::Reflex::Type type_1620c = ::Reflex::ConstBuilder(type_1620);
  ::Reflex::Type type_21294 = ::Reflex::ReferenceBuilder(type_1620c);
  ::Reflex::Type type_21295 = ::Reflex::ReferenceBuilder(type_1620);
  ::Reflex::Type type_7464 = ::Reflex::PointerBuilder(type_870);
  ::Reflex::Type type_7466 = ::Reflex::PointerBuilder(type_870c);
  ::Reflex::Type type_7468 = ::Reflex::ReferenceBuilder(type_870);
  ::Reflex::Type type_2028c = ::Reflex::ConstBuilder(type_2028);
  ::Reflex::Type type_20529 = ::Reflex::ReferenceBuilder(type_2028c);
  ::Reflex::Type type_1388c = ::Reflex::ConstBuilder(type_1388);
  ::Reflex::Type type_20530 = ::Reflex::ReferenceBuilder(type_1388c);
  ::Reflex::Type type_1621c = ::Reflex::ConstBuilder(type_1621);
  ::Reflex::Type type_21296 = ::Reflex::ReferenceBuilder(type_1621c);
  ::Reflex::Type type_21297 = ::Reflex::ReferenceBuilder(type_1621);
  ::Reflex::Type type_7569 = ::Reflex::PointerBuilder(type_871);
  ::Reflex::Type type_7571 = ::Reflex::PointerBuilder(type_871c);
  ::Reflex::Type type_7573 = ::Reflex::ReferenceBuilder(type_871);
  ::Reflex::Type type_2029c = ::Reflex::ConstBuilder(type_2029);
  ::Reflex::Type type_20537 = ::Reflex::ReferenceBuilder(type_2029c);
  ::Reflex::Type type_1390c = ::Reflex::ConstBuilder(type_1390);
  ::Reflex::Type type_20538 = ::Reflex::ReferenceBuilder(type_1390c);
  ::Reflex::Type type_1622c = ::Reflex::ConstBuilder(type_1622);
  ::Reflex::Type type_21298 = ::Reflex::ReferenceBuilder(type_1622c);
  ::Reflex::Type type_21299 = ::Reflex::ReferenceBuilder(type_1622);
  ::Reflex::Type type_7674 = ::Reflex::PointerBuilder(type_872);
  ::Reflex::Type type_7676 = ::Reflex::PointerBuilder(type_872c);
  ::Reflex::Type type_7678 = ::Reflex::ReferenceBuilder(type_872);
  ::Reflex::Type type_1392c = ::Reflex::ConstBuilder(type_1392);
  ::Reflex::Type type_20545 = ::Reflex::ReferenceBuilder(type_1392c);
  ::Reflex::Type type_1623c = ::Reflex::ConstBuilder(type_1623);
  ::Reflex::Type type_21300 = ::Reflex::ReferenceBuilder(type_1623c);
  ::Reflex::Type type_21301 = ::Reflex::ReferenceBuilder(type_1623);
  ::Reflex::Type type_7779 = ::Reflex::PointerBuilder(type_926);
  ::Reflex::Type type_926c = ::Reflex::ConstBuilder(type_926);
  ::Reflex::Type type_7781 = ::Reflex::PointerBuilder(type_926c);
  ::Reflex::Type type_7783 = ::Reflex::ReferenceBuilder(type_926);
  ::Reflex::Type type_7785 = ::Reflex::ReferenceBuilder(type_926c);
  ::Reflex::Type type_1394c = ::Reflex::ConstBuilder(type_1394);
  ::Reflex::Type type_20552 = ::Reflex::ReferenceBuilder(type_1394c);
  ::Reflex::Type type_1624c = ::Reflex::ConstBuilder(type_1624);
  ::Reflex::Type type_21302 = ::Reflex::ReferenceBuilder(type_1624c);
  ::Reflex::Type type_21303 = ::Reflex::ReferenceBuilder(type_1624);
  ::Reflex::Type type_7884 = ::Reflex::PointerBuilder(type_873);
  ::Reflex::Type type_7886 = ::Reflex::PointerBuilder(type_873c);
  ::Reflex::Type type_7888 = ::Reflex::ReferenceBuilder(type_873);
  ::Reflex::Type type_1396c = ::Reflex::ConstBuilder(type_1396);
  ::Reflex::Type type_20559 = ::Reflex::ReferenceBuilder(type_1396c);
  ::Reflex::Type type_1625c = ::Reflex::ConstBuilder(type_1625);
  ::Reflex::Type type_21304 = ::Reflex::ReferenceBuilder(type_1625c);
  ::Reflex::Type type_21305 = ::Reflex::ReferenceBuilder(type_1625);
  ::Reflex::Type type_7989 = ::Reflex::PointerBuilder(type_874);
  ::Reflex::Type type_7991 = ::Reflex::PointerBuilder(type_874c);
  ::Reflex::Type type_7993 = ::Reflex::ReferenceBuilder(type_874);
  ::Reflex::Type type_1398c = ::Reflex::ConstBuilder(type_1398);
  ::Reflex::Type type_20566 = ::Reflex::ReferenceBuilder(type_1398c);
  ::Reflex::Type type_1626c = ::Reflex::ConstBuilder(type_1626);
  ::Reflex::Type type_21306 = ::Reflex::ReferenceBuilder(type_1626c);
  ::Reflex::Type type_21307 = ::Reflex::ReferenceBuilder(type_1626);
  ::Reflex::Type type_8094 = ::Reflex::PointerBuilder(type_875);
  ::Reflex::Type type_8096 = ::Reflex::PointerBuilder(type_875c);
  ::Reflex::Type type_8098 = ::Reflex::ReferenceBuilder(type_875);
  ::Reflex::Type type_1400c = ::Reflex::ConstBuilder(type_1400);
  ::Reflex::Type type_20573 = ::Reflex::ReferenceBuilder(type_1400c);
  ::Reflex::Type type_1627c = ::Reflex::ConstBuilder(type_1627);
  ::Reflex::Type type_21308 = ::Reflex::ReferenceBuilder(type_1627c);
  ::Reflex::Type type_21309 = ::Reflex::ReferenceBuilder(type_1627);
  ::Reflex::Type type_8199 = ::Reflex::PointerBuilder(type_876);
  ::Reflex::Type type_8201 = ::Reflex::PointerBuilder(type_876c);
  ::Reflex::Type type_8203 = ::Reflex::ReferenceBuilder(type_876);
  ::Reflex::Type type_1402c = ::Reflex::ConstBuilder(type_1402);
  ::Reflex::Type type_20580 = ::Reflex::ReferenceBuilder(type_1402c);
  ::Reflex::Type type_1628c = ::Reflex::ConstBuilder(type_1628);
  ::Reflex::Type type_21310 = ::Reflex::ReferenceBuilder(type_1628c);
  ::Reflex::Type type_21311 = ::Reflex::ReferenceBuilder(type_1628);
  ::Reflex::Type type_8304 = ::Reflex::PointerBuilder(type_877);
  ::Reflex::Type type_8306 = ::Reflex::PointerBuilder(type_877c);
  ::Reflex::Type type_8308 = ::Reflex::ReferenceBuilder(type_877);
  ::Reflex::Type type_1404c = ::Reflex::ConstBuilder(type_1404);
  ::Reflex::Type type_20587 = ::Reflex::ReferenceBuilder(type_1404c);
  ::Reflex::Type type_1629c = ::Reflex::ConstBuilder(type_1629);
  ::Reflex::Type type_21312 = ::Reflex::ReferenceBuilder(type_1629c);
  ::Reflex::Type type_21313 = ::Reflex::ReferenceBuilder(type_1629);
  ::Reflex::Type type_8409 = ::Reflex::PointerBuilder(type_878);
  ::Reflex::Type type_8411 = ::Reflex::PointerBuilder(type_878c);
  ::Reflex::Type type_8413 = ::Reflex::ReferenceBuilder(type_878);
  ::Reflex::Type type_1406c = ::Reflex::ConstBuilder(type_1406);
  ::Reflex::Type type_20594 = ::Reflex::ReferenceBuilder(type_1406c);
  ::Reflex::Type type_1630c = ::Reflex::ConstBuilder(type_1630);
  ::Reflex::Type type_21314 = ::Reflex::ReferenceBuilder(type_1630c);
  ::Reflex::Type type_21315 = ::Reflex::ReferenceBuilder(type_1630);
  ::Reflex::Type type_8514 = ::Reflex::PointerBuilder(type_879);
  ::Reflex::Type type_8516 = ::Reflex::PointerBuilder(type_879c);
  ::Reflex::Type type_8518 = ::Reflex::ReferenceBuilder(type_879);
  ::Reflex::Type type_1408c = ::Reflex::ConstBuilder(type_1408);
  ::Reflex::Type type_20601 = ::Reflex::ReferenceBuilder(type_1408c);
  ::Reflex::Type type_1631c = ::Reflex::ConstBuilder(type_1631);
  ::Reflex::Type type_21316 = ::Reflex::ReferenceBuilder(type_1631c);
  ::Reflex::Type type_21317 = ::Reflex::ReferenceBuilder(type_1631);
  ::Reflex::Type type_8619 = ::Reflex::PointerBuilder(type_880);
  ::Reflex::Type type_8621 = ::Reflex::PointerBuilder(type_880c);
  ::Reflex::Type type_8623 = ::Reflex::ReferenceBuilder(type_880);
  ::Reflex::Type type_1410c = ::Reflex::ConstBuilder(type_1410);
  ::Reflex::Type type_20608 = ::Reflex::ReferenceBuilder(type_1410c);
  ::Reflex::Type type_1632c = ::Reflex::ConstBuilder(type_1632);
  ::Reflex::Type type_21318 = ::Reflex::ReferenceBuilder(type_1632c);
  ::Reflex::Type type_21319 = ::Reflex::ReferenceBuilder(type_1632);
  ::Reflex::Type type_8724 = ::Reflex::PointerBuilder(type_881);
  ::Reflex::Type type_8726 = ::Reflex::PointerBuilder(type_881c);
  ::Reflex::Type type_8728 = ::Reflex::ReferenceBuilder(type_881);
  ::Reflex::Type type_1412c = ::Reflex::ConstBuilder(type_1412);
  ::Reflex::Type type_20615 = ::Reflex::ReferenceBuilder(type_1412c);
  ::Reflex::Type type_1633c = ::Reflex::ConstBuilder(type_1633);
  ::Reflex::Type type_21320 = ::Reflex::ReferenceBuilder(type_1633c);
  ::Reflex::Type type_21321 = ::Reflex::ReferenceBuilder(type_1633);
  ::Reflex::Type type_11876 = ::Reflex::ReferenceBuilder(type_2083);
  ::Reflex::Type type_8934 = ::Reflex::PointerBuilder(type_882);
  ::Reflex::Type type_8936 = ::Reflex::PointerBuilder(type_882c);
  ::Reflex::Type type_8938 = ::Reflex::ReferenceBuilder(type_882);
  ::Reflex::Type type_2030c = ::Reflex::ConstBuilder(type_2030);
  ::Reflex::Type type_20629 = ::Reflex::ReferenceBuilder(type_2030c);
  ::Reflex::Type type_1415c = ::Reflex::ConstBuilder(type_1415);
  ::Reflex::Type type_20630 = ::Reflex::ReferenceBuilder(type_1415c);
  ::Reflex::Type type_1634c = ::Reflex::ConstBuilder(type_1634);
  ::Reflex::Type type_21322 = ::Reflex::ReferenceBuilder(type_1634c);
  ::Reflex::Type type_21323 = ::Reflex::ReferenceBuilder(type_1634);
  ::Reflex::Type type_9039 = ::Reflex::PointerBuilder(type_883);
  ::Reflex::Type type_9041 = ::Reflex::PointerBuilder(type_883c);
  ::Reflex::Type type_9043 = ::Reflex::ReferenceBuilder(type_883);
  ::Reflex::Type type_2031c = ::Reflex::ConstBuilder(type_2031);
  ::Reflex::Type type_20638 = ::Reflex::ReferenceBuilder(type_2031c);
  ::Reflex::Type type_1417c = ::Reflex::ConstBuilder(type_1417);
  ::Reflex::Type type_20639 = ::Reflex::ReferenceBuilder(type_1417c);
  ::Reflex::Type type_1635c = ::Reflex::ConstBuilder(type_1635);
  ::Reflex::Type type_21324 = ::Reflex::ReferenceBuilder(type_1635c);
  ::Reflex::Type type_21325 = ::Reflex::ReferenceBuilder(type_1635);
  ::Reflex::Type type_9144 = ::Reflex::PointerBuilder(type_966);
  ::Reflex::Type type_966c = ::Reflex::ConstBuilder(type_966);
  ::Reflex::Type type_9146 = ::Reflex::PointerBuilder(type_966c);
  ::Reflex::Type type_9148 = ::Reflex::ReferenceBuilder(type_966);
  ::Reflex::Type type_9150 = ::Reflex::ReferenceBuilder(type_966c);
  ::Reflex::Type type_1419c = ::Reflex::ConstBuilder(type_1419);
  ::Reflex::Type type_20646 = ::Reflex::ReferenceBuilder(type_1419c);
  ::Reflex::Type type_1636c = ::Reflex::ConstBuilder(type_1636);
  ::Reflex::Type type_21326 = ::Reflex::ReferenceBuilder(type_1636c);
  ::Reflex::Type type_21327 = ::Reflex::ReferenceBuilder(type_1636);
  ::Reflex::Type type_9249 = ::Reflex::PointerBuilder(type_970);
  ::Reflex::Type type_970c = ::Reflex::ConstBuilder(type_970);
  ::Reflex::Type type_9251 = ::Reflex::PointerBuilder(type_970c);
  ::Reflex::Type type_9253 = ::Reflex::ReferenceBuilder(type_970);
  ::Reflex::Type type_9255 = ::Reflex::ReferenceBuilder(type_970c);
  ::Reflex::Type type_1421c = ::Reflex::ConstBuilder(type_1421);
  ::Reflex::Type type_20653 = ::Reflex::ReferenceBuilder(type_1421c);
  ::Reflex::Type type_1637c = ::Reflex::ConstBuilder(type_1637);
  ::Reflex::Type type_21328 = ::Reflex::ReferenceBuilder(type_1637c);
  ::Reflex::Type type_21329 = ::Reflex::ReferenceBuilder(type_1637);
  ::Reflex::Type type_9354 = ::Reflex::PointerBuilder(type_884);
  ::Reflex::Type type_9356 = ::Reflex::PointerBuilder(type_884c);
  ::Reflex::Type type_9358 = ::Reflex::ReferenceBuilder(type_884);
  ::Reflex::Type type_1423c = ::Reflex::ConstBuilder(type_1423);
  ::Reflex::Type type_20660 = ::Reflex::ReferenceBuilder(type_1423c);
  ::Reflex::Type type_1638c = ::Reflex::ConstBuilder(type_1638);
  ::Reflex::Type type_21330 = ::Reflex::ReferenceBuilder(type_1638c);
  ::Reflex::Type type_21331 = ::Reflex::ReferenceBuilder(type_1638);
  ::Reflex::Type type_9459 = ::Reflex::PointerBuilder(type_885);
  ::Reflex::Type type_9461 = ::Reflex::PointerBuilder(type_885c);
  ::Reflex::Type type_9463 = ::Reflex::ReferenceBuilder(type_885);
  ::Reflex::Type type_1425c = ::Reflex::ConstBuilder(type_1425);
  ::Reflex::Type type_20667 = ::Reflex::ReferenceBuilder(type_1425c);
  ::Reflex::Type type_1639c = ::Reflex::ConstBuilder(type_1639);
  ::Reflex::Type type_21332 = ::Reflex::ReferenceBuilder(type_1639c);
  ::Reflex::Type type_21333 = ::Reflex::ReferenceBuilder(type_1639);
  ::Reflex::Type type_9564 = ::Reflex::PointerBuilder(type_886);
  ::Reflex::Type type_9566 = ::Reflex::PointerBuilder(type_886c);
  ::Reflex::Type type_9568 = ::Reflex::ReferenceBuilder(type_886);
  ::Reflex::Type type_1427c = ::Reflex::ConstBuilder(type_1427);
  ::Reflex::Type type_20674 = ::Reflex::ReferenceBuilder(type_1427c);
  ::Reflex::Type type_1640c = ::Reflex::ConstBuilder(type_1640);
  ::Reflex::Type type_21334 = ::Reflex::ReferenceBuilder(type_1640c);
  ::Reflex::Type type_21335 = ::Reflex::ReferenceBuilder(type_1640);
  ::Reflex::Type type_9669 = ::Reflex::PointerBuilder(type_887);
  ::Reflex::Type type_9671 = ::Reflex::PointerBuilder(type_887c);
  ::Reflex::Type type_9673 = ::Reflex::ReferenceBuilder(type_887);
  ::Reflex::Type type_1429c = ::Reflex::ConstBuilder(type_1429);
  ::Reflex::Type type_20681 = ::Reflex::ReferenceBuilder(type_1429c);
  ::Reflex::Type type_1641c = ::Reflex::ConstBuilder(type_1641);
  ::Reflex::Type type_21336 = ::Reflex::ReferenceBuilder(type_1641c);
  ::Reflex::Type type_21337 = ::Reflex::ReferenceBuilder(type_1641);
  ::Reflex::Type type_9774 = ::Reflex::PointerBuilder(type_888);
  ::Reflex::Type type_9776 = ::Reflex::PointerBuilder(type_888c);
  ::Reflex::Type type_9778 = ::Reflex::ReferenceBuilder(type_888);
  ::Reflex::Type type_1431c = ::Reflex::ConstBuilder(type_1431);
  ::Reflex::Type type_20688 = ::Reflex::ReferenceBuilder(type_1431c);
  ::Reflex::Type type_1642c = ::Reflex::ConstBuilder(type_1642);
  ::Reflex::Type type_21338 = ::Reflex::ReferenceBuilder(type_1642c);
  ::Reflex::Type type_21339 = ::Reflex::ReferenceBuilder(type_1642);
  ::Reflex::Type type_9879 = ::Reflex::PointerBuilder(type_889);
  ::Reflex::Type type_9881 = ::Reflex::PointerBuilder(type_889c);
  ::Reflex::Type type_9883 = ::Reflex::ReferenceBuilder(type_889);
  ::Reflex::Type type_1433c = ::Reflex::ConstBuilder(type_1433);
  ::Reflex::Type type_20695 = ::Reflex::ReferenceBuilder(type_1433c);
  ::Reflex::Type type_1643c = ::Reflex::ConstBuilder(type_1643);
  ::Reflex::Type type_21340 = ::Reflex::ReferenceBuilder(type_1643c);
  ::Reflex::Type type_21341 = ::Reflex::ReferenceBuilder(type_1643);
  ::Reflex::Type type_9984 = ::Reflex::PointerBuilder(type_890);
  ::Reflex::Type type_9986 = ::Reflex::PointerBuilder(type_890c);
  ::Reflex::Type type_9988 = ::Reflex::ReferenceBuilder(type_890);
  ::Reflex::Type type_1435c = ::Reflex::ConstBuilder(type_1435);
  ::Reflex::Type type_20702 = ::Reflex::ReferenceBuilder(type_1435c);
  ::Reflex::Type type_1644c = ::Reflex::ConstBuilder(type_1644);
  ::Reflex::Type type_21342 = ::Reflex::ReferenceBuilder(type_1644c);
  ::Reflex::Type type_21343 = ::Reflex::ReferenceBuilder(type_1644);
  ::Reflex::Type type_10089 = ::Reflex::PointerBuilder(type_891);
  ::Reflex::Type type_10091 = ::Reflex::PointerBuilder(type_891c);
  ::Reflex::Type type_10093 = ::Reflex::ReferenceBuilder(type_891);
  ::Reflex::Type type_1437c = ::Reflex::ConstBuilder(type_1437);
  ::Reflex::Type type_20710 = ::Reflex::ReferenceBuilder(type_1437c);
  ::Reflex::Type type_1645c = ::Reflex::ConstBuilder(type_1645);
  ::Reflex::Type type_21344 = ::Reflex::ReferenceBuilder(type_1645c);
  ::Reflex::Type type_21345 = ::Reflex::ReferenceBuilder(type_1645);
  ::Reflex::Type type_10299 = ::Reflex::PointerBuilder(type_892);
  ::Reflex::Type type_10301 = ::Reflex::PointerBuilder(type_892c);
  ::Reflex::Type type_10303 = ::Reflex::ReferenceBuilder(type_892);
  ::Reflex::Type type_1440c = ::Reflex::ConstBuilder(type_1440);
  ::Reflex::Type type_20724 = ::Reflex::ReferenceBuilder(type_1440c);
  ::Reflex::Type type_1646c = ::Reflex::ConstBuilder(type_1646);
  ::Reflex::Type type_21346 = ::Reflex::ReferenceBuilder(type_1646c);
  ::Reflex::Type type_21347 = ::Reflex::ReferenceBuilder(type_1646);
  ::Reflex::Type type_10404 = ::Reflex::PointerBuilder(type_893);
  ::Reflex::Type type_10406 = ::Reflex::PointerBuilder(type_893c);
  ::Reflex::Type type_10408 = ::Reflex::ReferenceBuilder(type_893);
  ::Reflex::Type type_1442c = ::Reflex::ConstBuilder(type_1442);
  ::Reflex::Type type_20731 = ::Reflex::ReferenceBuilder(type_1442c);
  ::Reflex::Type type_1647c = ::Reflex::ConstBuilder(type_1647);
  ::Reflex::Type type_21348 = ::Reflex::ReferenceBuilder(type_1647c);
  ::Reflex::Type type_21349 = ::Reflex::ReferenceBuilder(type_1647);
  ::Reflex::Type type_10509 = ::Reflex::PointerBuilder(type_894);
  ::Reflex::Type type_10511 = ::Reflex::PointerBuilder(type_894c);
  ::Reflex::Type type_10513 = ::Reflex::ReferenceBuilder(type_894);
  ::Reflex::Type type_1444c = ::Reflex::ConstBuilder(type_1444);
  ::Reflex::Type type_20738 = ::Reflex::ReferenceBuilder(type_1444c);
  ::Reflex::Type type_1648c = ::Reflex::ConstBuilder(type_1648);
  ::Reflex::Type type_21350 = ::Reflex::ReferenceBuilder(type_1648c);
  ::Reflex::Type type_21351 = ::Reflex::ReferenceBuilder(type_1648);
  ::Reflex::Type type_10614 = ::Reflex::PointerBuilder(type_895);
  ::Reflex::Type type_10616 = ::Reflex::PointerBuilder(type_895c);
  ::Reflex::Type type_10618 = ::Reflex::ReferenceBuilder(type_895);
  ::Reflex::Type type_1446c = ::Reflex::ConstBuilder(type_1446);
  ::Reflex::Type type_20745 = ::Reflex::ReferenceBuilder(type_1446c);
  ::Reflex::Type type_1649c = ::Reflex::ConstBuilder(type_1649);
  ::Reflex::Type type_21352 = ::Reflex::ReferenceBuilder(type_1649c);
  ::Reflex::Type type_21353 = ::Reflex::ReferenceBuilder(type_1649);
  ::Reflex::Type type_10719 = ::Reflex::PointerBuilder(type_896);
  ::Reflex::Type type_10721 = ::Reflex::PointerBuilder(type_896c);
  ::Reflex::Type type_10723 = ::Reflex::ReferenceBuilder(type_896);
  ::Reflex::Type type_1448c = ::Reflex::ConstBuilder(type_1448);
  ::Reflex::Type type_20752 = ::Reflex::ReferenceBuilder(type_1448c);
  ::Reflex::Type type_1650c = ::Reflex::ConstBuilder(type_1650);
  ::Reflex::Type type_21354 = ::Reflex::ReferenceBuilder(type_1650c);
  ::Reflex::Type type_21355 = ::Reflex::ReferenceBuilder(type_1650);
  ::Reflex::Type type_11330 = ::Reflex::PointerBuilder(type_2054);
  ::Reflex::Type type_1888c = ::Reflex::ConstBuilder(type_1888);
  ::Reflex::Type type_21384 = ::Reflex::ReferenceBuilder(type_1888c);
  ::Reflex::Type type_21385 = ::Reflex::ReferenceBuilder(type_1888);
  ::Reflex::Type type_21386 = ::Reflex::ReferenceBuilder(type_1929);
  ::Reflex::Type type_1929c = ::Reflex::ConstBuilder(type_1929);
  ::Reflex::Type type_21387 = ::Reflex::ReferenceBuilder(type_1929c);
  ::Reflex::Type type_21837 = ::Reflex::ReferenceBuilder(type_2006);
  ::Reflex::Type type_2006c = ::Reflex::ConstBuilder(type_2006);
  ::Reflex::Type type_21838 = ::Reflex::ReferenceBuilder(type_2006c);
  ::Reflex::Type type_21847 = ::Reflex::ReferenceBuilder(type_2024);
  ::Reflex::Type type_6834 = ::Reflex::PointerBuilder(type_898);
  ::Reflex::Type type_898c = ::Reflex::ConstBuilder(type_898);
  ::Reflex::Type type_6836 = ::Reflex::PointerBuilder(type_898c);
  ::Reflex::Type type_6838 = ::Reflex::ReferenceBuilder(type_898);
  ::Reflex::Type type_6840 = ::Reflex::ReferenceBuilder(type_898c);
  ::Reflex::Type type_2025c = ::Reflex::ConstBuilder(type_2025);
  ::Reflex::Type type_20484 = ::Reflex::ReferenceBuilder(type_2025c);
  ::Reflex::Type type_1376c = ::Reflex::ConstBuilder(type_1376);
  ::Reflex::Type type_20485 = ::Reflex::ReferenceBuilder(type_1376c);
  ::Reflex::Type type_2039c = ::Reflex::ConstBuilder(type_2039);
  ::Reflex::Type type_21861 = ::Reflex::ReferenceBuilder(type_2039c);
  ::Reflex::Type type_21862 = ::Reflex::ReferenceBuilder(type_2039);
  ::Reflex::Type type_22171 = ::Reflex::ReferenceBuilder(type_2337);
  ::Reflex::Type type_2337c = ::Reflex::ConstBuilder(type_2337);
  ::Reflex::Type type_22172 = ::Reflex::ReferenceBuilder(type_2337c);
  ::Reflex::Type type_3514c = ::Reflex::ConstBuilder(type_3514);
  ::Reflex::Type type_22173 = ::Reflex::ReferenceBuilder(type_3514c);
  ::Reflex::Type type_1592c = ::Reflex::ConstBuilder(type_1592);
  ::Reflex::Type type_22158 = ::Reflex::ReferenceBuilder(type_1592c);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __std__pair_int_double_
#undef __std__pair_int_double_
#endif
struct __std__pair_int_double_ {
  public:
  __std__pair_int_double_();
  int first;
  double second;
};
#ifdef __std__pair_unsignedslongslong_std__basic_string_char_s_
#undef __std__pair_unsignedslongslong_std__basic_string_char_s_
#endif
struct __std__pair_unsignedslongslong_std__basic_string_char_s_ {
  public:
  __std__pair_unsignedslongslong_std__basic_string_char_s_();
  unsigned long long first;
  ::std::basic_string<char> second;
};
#ifdef __std__pair_unsignedsint_unsignedsint_
#undef __std__pair_unsignedsint_unsignedsint_
#endif
struct __std__pair_unsignedsint_unsignedsint_ {
  public:
  __std__pair_unsignedsint_unsignedsint_();
  unsigned int first;
  unsigned int second;
};
#ifdef __std__pair_unsignedsint_int_
#undef __std__pair_unsignedsint_int_
#endif
struct __std__pair_unsignedsint_int_ {
  public:
  __std__pair_unsignedsint_int_();
  unsigned int first;
  int second;
};
#ifdef __std__pair_unsignedsint_float_
#undef __std__pair_unsignedsint_float_
#endif
struct __std__pair_unsignedsint_float_ {
  public:
  __std__pair_unsignedsint_float_();
  unsigned int first;
  float second;
};
#ifdef __std__pair_unsignedsint_double_
#undef __std__pair_unsignedsint_double_
#endif
struct __std__pair_unsignedsint_double_ {
  public:
  __std__pair_unsignedsint_double_();
  unsigned int first;
  double second;
};
#ifdef __std__pair_unsignedsint_bool_
#undef __std__pair_unsignedsint_bool_
#endif
struct __std__pair_unsignedsint_bool_ {
  public:
  __std__pair_unsignedsint_bool_();
  unsigned int first;
  bool second;
};
#ifdef __std__pair_double_std__vector_double_s_
#undef __std__pair_double_std__vector_double_s_
#endif
struct __std__pair_double_std__vector_double_s_ {
  public:
  __std__pair_double_std__vector_double_s_();
  double first;
  ::std::vector<double> second;
};
#ifdef __std__pair_std__vector_std__pair_double_std__vector_double_s_s__bool_
#undef __std__pair_std__vector_std__pair_double_std__vector_double_s_s__bool_
#endif
struct __std__pair_std__vector_std__pair_double_std__vector_double_s_s__bool_ {
  public:
  __std__pair_std__vector_std__pair_double_std__vector_double_s_s__bool_();
  ::std::vector<std::pair<double,std::vector<double> > > first;
  bool second;
};
#ifdef __std__pair_std__basic_string_char__int_
#undef __std__pair_std__basic_string_char__int_
#endif
struct __std__pair_std__basic_string_char__int_ {
  public:
  __std__pair_std__basic_string_char__int_();
  ::std::basic_string<char> first;
  int second;
};
#ifdef __std__pair_std__basic_string_char__float_
#undef __std__pair_std__basic_string_char__float_
#endif
struct __std__pair_std__basic_string_char__float_ {
  public:
  __std__pair_std__basic_string_char__float_();
  ::std::basic_string<char> first;
  float second;
};
#ifdef __std__pair_std__basic_string_char__double_
#undef __std__pair_std__basic_string_char__double_
#endif
struct __std__pair_std__basic_string_char__double_ {
  public:
  __std__pair_std__basic_string_char__double_();
  ::std::basic_string<char> first;
  double second;
};
#ifdef __std__pair_std__basic_string_char__bool_
#undef __std__pair_std__basic_string_char__bool_
#endif
struct __std__pair_std__basic_string_char__bool_ {
  public:
  __std__pair_std__basic_string_char__bool_();
  ::std::basic_string<char> first;
  bool second;
};
#ifdef __std__pair_int_int_
#undef __std__pair_int_int_
#endif
struct __std__pair_int_int_ {
  public:
  __std__pair_int_int_();
  int first;
  int second;
};
#ifdef __std__pair_float_float_
#undef __std__pair_float_float_
#endif
struct __std__pair_float_float_ {
  public:
  __std__pair_float_float_();
  float first;
  float second;
};
#ifdef __std__pair_double_double_
#undef __std__pair_double_double_
#endif
struct __std__pair_double_double_ {
  public:
  __std__pair_double_double_();
  double first;
  double second;
};
#ifdef __std__pair_constsshort_short_
#undef __std__pair_constsshort_short_
#endif
struct __std__pair_constsshort_short_ {
  public:
  __std__pair_constsshort_short_();
  short first;
  short second;
};
#ifdef __std__pair_unsignedsshort_unsignedsshort_
#undef __std__pair_unsignedsshort_unsignedsshort_
#endif
struct __std__pair_unsignedsshort_unsignedsshort_ {
  public:
  __std__pair_unsignedsshort_unsignedsshort_();
  unsigned short first;
  unsigned short second;
};
#ifdef __std__pair_unsignedsshort_std__vector_unsignedsshort_s_
#undef __std__pair_unsignedsshort_std__vector_unsignedsshort_s_
#endif
struct __std__pair_unsignedsshort_std__vector_unsignedsshort_s_ {
  public:
  __std__pair_unsignedsshort_std__vector_unsignedsshort_s_();
  unsigned short first;
  ::std::vector<unsigned short> second;
};
#ifdef __std__pair_unsignedsshort_float_
#undef __std__pair_unsignedsshort_float_
#endif
struct __std__pair_unsignedsshort_float_ {
  public:
  __std__pair_unsignedsshort_float_();
  unsigned short first;
  float second;
};
#ifdef __std__pair_unsignedslong_unsignedslong_
#undef __std__pair_unsignedslong_unsignedslong_
#endif
struct __std__pair_unsignedslong_unsignedslong_ {
  public:
  __std__pair_unsignedslong_unsignedslong_();
  unsigned long first;
  unsigned long second;
};
#ifdef __std__pair_unsignedslong_std__vector_unsignedslong_s_
#undef __std__pair_unsignedslong_std__vector_unsignedslong_s_
#endif
struct __std__pair_unsignedslong_std__vector_unsignedslong_s_ {
  public:
  __std__pair_unsignedslong_std__vector_unsignedslong_s_();
  unsigned long first;
  ::std::vector<unsigned long> second;
};
#ifdef __std__pair_unsignedsint_unsignedslong_
#undef __std__pair_unsignedsint_unsignedslong_
#endif
struct __std__pair_unsignedsint_unsignedslong_ {
  public:
  __std__pair_unsignedsint_unsignedslong_();
  unsigned int first;
  unsigned long second;
};
#ifdef __std__pair_unsignedsint_std__vector_unsignedsint_s_
#undef __std__pair_unsignedsint_std__vector_unsignedsint_s_
#endif
struct __std__pair_unsignedsint_std__vector_unsignedsint_s_ {
  public:
  __std__pair_unsignedsint_std__vector_unsignedsint_s_();
  unsigned int first;
  ::std::vector<unsigned int> second;
};
#ifdef __std__pair_unsignedsint_std__vector_std__pair_unsignedsint_double_s_s_
#undef __std__pair_unsignedsint_std__vector_std__pair_unsignedsint_double_s_s_
#endif
struct __std__pair_unsignedsint_std__vector_std__pair_unsignedsint_double_s_s_ {
  public:
  __std__pair_unsignedsint_std__vector_std__pair_unsignedsint_double_s_s_();
  unsigned int first;
  ::std::vector<std::pair<unsigned int,double> > second;
};
#ifdef __std__pair_unsignedsint_std__vector_std__pair_unsignedsint_bool_s_s_
#undef __std__pair_unsignedsint_std__vector_std__pair_unsignedsint_bool_s_s_
#endif
struct __std__pair_unsignedsint_std__vector_std__pair_unsignedsint_bool_s_s_ {
  public:
  __std__pair_unsignedsint_std__vector_std__pair_unsignedsint_bool_s_s_();
  unsigned int first;
  ::std::vector<std::pair<unsigned int,bool> > second;
};
#ifdef __std__pair_unsignedsint_std__pair_unsignedsint_unsignedsint_s_
#undef __std__pair_unsignedsint_std__pair_unsignedsint_unsignedsint_s_
#endif
struct __std__pair_unsignedsint_std__pair_unsignedsint_unsignedsint_s_ {
  public:
  __std__pair_unsignedsint_std__pair_unsignedsint_unsignedsint_s_();
  unsigned int first;
  ::std::pair<unsigned int,unsigned int> second;
};
#ifdef __std__pair_unsignedsint_std__basic_string_char_s_
#undef __std__pair_unsignedsint_std__basic_string_char_s_
#endif
struct __std__pair_unsignedsint_std__basic_string_char_s_ {
  public:
  __std__pair_unsignedsint_std__basic_string_char_s_();
  unsigned int first;
  ::std::basic_string<char> second;
};
#ifdef __std__pair_unsignedsint_short_
#undef __std__pair_unsignedsint_short_
#endif
struct __std__pair_unsignedsint_short_ {
  public:
  __std__pair_unsignedsint_short_();
  unsigned int first;
  short second;
};
#ifdef __std__pair_std__pair_short_short__std__pair_short_std__vector_short_s_s_
#undef __std__pair_std__pair_short_short__std__pair_short_std__vector_short_s_s_
#endif
struct __std__pair_std__pair_short_short__std__pair_short_std__vector_short_s_s_ {
  public:
  __std__pair_std__pair_short_short__std__pair_short_std__vector_short_s_s_();
  ::std::pair<short,short> first;
  ::std::pair<short,std::vector<short> > second;
};
#ifdef __std__pair_short_std__vector_short_s_
#undef __std__pair_short_std__vector_short_s_
#endif
struct __std__pair_short_std__vector_short_s_ {
  public:
  __std__pair_short_std__vector_short_s_();
  short first;
  ::std::vector<short> second;
};
#ifdef __std__pair_short_short_
#undef __std__pair_short_short_
#endif
struct __std__pair_short_short_ {
  public:
  __std__pair_short_short_();
  short first;
  short second;
};
#ifdef __std__pair_std__pair_int_int__int_
#undef __std__pair_std__pair_int_int__int_
#endif
struct __std__pair_std__pair_int_int__int_ {
  public:
  __std__pair_std__pair_int_int__int_();
  ::std::pair<int,int> first;
  int second;
};
#ifdef __std__pair_std__basic_string_char__unsignedsint_
#undef __std__pair_std__basic_string_char__unsignedsint_
#endif
struct __std__pair_std__basic_string_char__unsignedsint_ {
  public:
  __std__pair_std__basic_string_char__unsignedsint_();
  ::std::basic_string<char> first;
  unsigned int second;
};
#ifdef __std__pair_std__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s_
#undef __std__pair_std__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s_
#endif
struct __std__pair_std__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s_ {
  public:
  __std__pair_std__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s_();
  ::std::basic_string<char> first;
  ::std::vector<std::pair<std::basic_string<char>,double> > second;
};
#ifdef __std__pair_std__basic_string_char__std__vector_std__basic_string_char_s_s_
#undef __std__pair_std__basic_string_char__std__vector_std__basic_string_char_s_s_
#endif
struct __std__pair_std__basic_string_char__std__vector_std__basic_string_char_s_s_ {
  public:
  __std__pair_std__basic_string_char__std__vector_std__basic_string_char_s_s_();
  ::std::basic_string<char> first;
  ::std::vector<std::basic_string<char> > second;
};
#ifdef __std__pair_std__basic_string_char__std__pair_unsignedsint_unsignedsint_s_
#undef __std__pair_std__basic_string_char__std__pair_unsignedsint_unsignedsint_s_
#endif
struct __std__pair_std__basic_string_char__std__pair_unsignedsint_unsignedsint_s_ {
  public:
  __std__pair_std__basic_string_char__std__pair_unsignedsint_unsignedsint_s_();
  ::std::basic_string<char> first;
  ::std::pair<unsigned int,unsigned int> second;
};
#ifdef __std__pair_std__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s_
#undef __std__pair_std__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s_
#endif
struct __std__pair_std__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s_ {
  public:
  __std__pair_std__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s_();
  ::std::basic_string<char> first;
  ::std::map<std::basic_string<char>,std::basic_string<char> > second;
};
#ifdef __std__pair_constsstd__basic_string_char__std__basic_string_char_s_
#undef __std__pair_constsstd__basic_string_char__std__basic_string_char_s_
#endif
struct __std__pair_constsstd__basic_string_char__std__basic_string_char_s_ {
  public:
  __std__pair_constsstd__basic_string_char__std__basic_string_char_s_();
  ::std::basic_string<char> first;
  ::std::basic_string<char> second;
};
#ifdef __std__pair_std__basic_string_char__std__basic_string_char_s_
#undef __std__pair_std__basic_string_char__std__basic_string_char_s_
#endif
struct __std__pair_std__basic_string_char__std__basic_string_char_s_ {
  public:
  __std__pair_std__basic_string_char__std__basic_string_char_s_();
  ::std::basic_string<char> first;
  ::std::basic_string<char> second;
};
#ifdef __std__pair_short_unsignedsint_
#undef __std__pair_short_unsignedsint_
#endif
struct __std__pair_short_unsignedsint_ {
  public:
  __std__pair_short_unsignedsint_();
  short first;
  unsigned int second;
};
#ifdef __std__pair_int_unsignedsint_
#undef __std__pair_int_unsignedsint_
#endif
struct __std__pair_int_unsignedsint_ {
  public:
  __std__pair_int_unsignedsint_();
  int first;
  unsigned int second;
};
#ifdef __std__pair_int_std__pair_unsignedslong_unsignedslong_s_
#undef __std__pair_int_std__pair_unsignedslong_unsignedslong_s_
#endif
struct __std__pair_int_std__pair_unsignedslong_unsignedslong_s_ {
  public:
  __std__pair_int_std__pair_unsignedslong_unsignedslong_s_();
  int first;
  ::std::pair<unsigned long,unsigned long> second;
};
#ifdef __std__pair_int_std__pair_unsignedsint_unsignedsint_s_
#undef __std__pair_int_std__pair_unsignedsint_unsignedsint_s_
#endif
struct __std__pair_int_std__pair_unsignedsint_unsignedsint_s_ {
  public:
  __std__pair_int_std__pair_unsignedsint_unsignedsint_s_();
  int first;
  ::std::pair<unsigned int,unsigned int> second;
};
#ifdef __std__pair_int_std__pair_double_double_s_
#undef __std__pair_int_std__pair_double_double_s_
#endif
struct __std__pair_int_std__pair_double_double_s_ {
  public:
  __std__pair_int_std__pair_double_double_s_();
  int first;
  ::std::pair<double,double> second;
};
#ifdef __std__pair_constsunsignedsshort_unsignedsshort_
#undef __std__pair_constsunsignedsshort_unsignedsshort_
#endif
struct __std__pair_constsunsignedsshort_unsignedsshort_ {
  public:
  __std__pair_constsunsignedsshort_unsignedsshort_();
  unsigned short first;
  unsigned short second;
};
#ifdef __std__pair_constsunsignedsshort_std__vector_unsignedsshort_s_
#undef __std__pair_constsunsignedsshort_std__vector_unsignedsshort_s_
#endif
struct __std__pair_constsunsignedsshort_std__vector_unsignedsshort_s_ {
  public:
  __std__pair_constsunsignedsshort_std__vector_unsignedsshort_s_();
  unsigned short first;
  ::std::vector<unsigned short> second;
};
#ifdef __std__pair_constsunsignedsshort_float_
#undef __std__pair_constsunsignedsshort_float_
#endif
struct __std__pair_constsunsignedsshort_float_ {
  public:
  __std__pair_constsunsignedsshort_float_();
  unsigned short first;
  float second;
};
#ifdef __std__pair_constsunsignedslong_unsignedslong_
#undef __std__pair_constsunsignedslong_unsignedslong_
#endif
struct __std__pair_constsunsignedslong_unsignedslong_ {
  public:
  __std__pair_constsunsignedslong_unsignedslong_();
  unsigned long first;
  unsigned long second;
};
#ifdef __std__pair_constsunsignedslong_std__vector_unsignedslong_s_
#undef __std__pair_constsunsignedslong_std__vector_unsignedslong_s_
#endif
struct __std__pair_constsunsignedslong_std__vector_unsignedslong_s_ {
  public:
  __std__pair_constsunsignedslong_std__vector_unsignedslong_s_();
  unsigned long first;
  ::std::vector<unsigned long> second;
};
#ifdef __std__pair_constsunsignedslongslong_std__basic_string_char_s_
#undef __std__pair_constsunsignedslongslong_std__basic_string_char_s_
#endif
struct __std__pair_constsunsignedslongslong_std__basic_string_char_s_ {
  public:
  __std__pair_constsunsignedslongslong_std__basic_string_char_s_();
  unsigned long long first;
  ::std::basic_string<char> second;
};
#ifdef __std__pair_constsunsignedsint_unsignedsint_
#undef __std__pair_constsunsignedsint_unsignedsint_
#endif
struct __std__pair_constsunsignedsint_unsignedsint_ {
  public:
  __std__pair_constsunsignedsint_unsignedsint_();
  unsigned int first;
  unsigned int second;
};
#ifdef __std__pair_constsunsignedsint_std__vector_unsignedsint_s_
#undef __std__pair_constsunsignedsint_std__vector_unsignedsint_s_
#endif
struct __std__pair_constsunsignedsint_std__vector_unsignedsint_s_ {
  public:
  __std__pair_constsunsignedsint_std__vector_unsignedsint_s_();
  unsigned int first;
  ::std::vector<unsigned int> second;
};
#ifdef __std__pair_constsunsignedsint_std__vector_std__pair_unsignedsint_double_s_s_
#undef __std__pair_constsunsignedsint_std__vector_std__pair_unsignedsint_double_s_s_
#endif
struct __std__pair_constsunsignedsint_std__vector_std__pair_unsignedsint_double_s_s_ {
  public:
  __std__pair_constsunsignedsint_std__vector_std__pair_unsignedsint_double_s_s_();
  unsigned int first;
  ::std::vector<std::pair<unsigned int,double> > second;
};
#ifdef __std__pair_constsunsignedsint_std__vector_std__pair_unsignedsint_bool_s_s_
#undef __std__pair_constsunsignedsint_std__vector_std__pair_unsignedsint_bool_s_s_
#endif
struct __std__pair_constsunsignedsint_std__vector_std__pair_unsignedsint_bool_s_s_ {
  public:
  __std__pair_constsunsignedsint_std__vector_std__pair_unsignedsint_bool_s_s_();
  unsigned int first;
  ::std::vector<std::pair<unsigned int,bool> > second;
};
#ifdef __std__pair_constsunsignedsint_std__pair_unsignedsint_unsignedsint_s_
#undef __std__pair_constsunsignedsint_std__pair_unsignedsint_unsignedsint_s_
#endif
struct __std__pair_constsunsignedsint_std__pair_unsignedsint_unsignedsint_s_ {
  public:
  __std__pair_constsunsignedsint_std__pair_unsignedsint_unsignedsint_s_();
  unsigned int first;
  ::std::pair<unsigned int,unsigned int> second;
};
#ifdef __std__pair_constsunsignedsint_std__basic_string_char_s_
#undef __std__pair_constsunsignedsint_std__basic_string_char_s_
#endif
struct __std__pair_constsunsignedsint_std__basic_string_char_s_ {
  public:
  __std__pair_constsunsignedsint_std__basic_string_char_s_();
  unsigned int first;
  ::std::basic_string<char> second;
};
#ifdef __std__pair_constsunsignedsint_short_
#undef __std__pair_constsunsignedsint_short_
#endif
struct __std__pair_constsunsignedsint_short_ {
  public:
  __std__pair_constsunsignedsint_short_();
  unsigned int first;
  short second;
};
#ifdef __std__pair_constsunsignedsint_int_
#undef __std__pair_constsunsignedsint_int_
#endif
struct __std__pair_constsunsignedsint_int_ {
  public:
  __std__pair_constsunsignedsint_int_();
  unsigned int first;
  int second;
};
#ifdef __std__pair_constsunsignedsint_float_
#undef __std__pair_constsunsignedsint_float_
#endif
struct __std__pair_constsunsignedsint_float_ {
  public:
  __std__pair_constsunsignedsint_float_();
  unsigned int first;
  float second;
};
#ifdef __std__pair_constsunsignedsint_double_
#undef __std__pair_constsunsignedsint_double_
#endif
struct __std__pair_constsunsignedsint_double_ {
  public:
  __std__pair_constsunsignedsint_double_();
  unsigned int first;
  double second;
};
#ifdef __std__pair_constsunsignedsint_bool_
#undef __std__pair_constsunsignedsint_bool_
#endif
struct __std__pair_constsunsignedsint_bool_ {
  public:
  __std__pair_constsunsignedsint_bool_();
  unsigned int first;
  bool second;
};
#ifdef __std__pair_constsstd__pair_short_short__std__pair_short_std__vector_short_s_s_
#undef __std__pair_constsstd__pair_short_short__std__pair_short_std__vector_short_s_s_
#endif
struct __std__pair_constsstd__pair_short_short__std__pair_short_std__vector_short_s_s_ {
  public:
  __std__pair_constsstd__pair_short_short__std__pair_short_std__vector_short_s_s_();
  ::std::pair<short,short> first;
  ::std::pair<short,std::vector<short> > second;
};
#ifdef __std__pair_constsstd__pair_int_int__int_
#undef __std__pair_constsstd__pair_int_int__int_
#endif
struct __std__pair_constsstd__pair_int_int__int_ {
  public:
  __std__pair_constsstd__pair_int_int__int_();
  ::std::pair<int,int> first;
  int second;
};
#ifdef __std__pair_constsstd__basic_string_char__unsignedsint_
#undef __std__pair_constsstd__basic_string_char__unsignedsint_
#endif
struct __std__pair_constsstd__basic_string_char__unsignedsint_ {
  public:
  __std__pair_constsstd__basic_string_char__unsignedsint_();
  ::std::basic_string<char> first;
  unsigned int second;
};
#ifdef __std__pair_constsstd__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s_
#undef __std__pair_constsstd__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s_
#endif
struct __std__pair_constsstd__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s_ {
  public:
  __std__pair_constsstd__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s_();
  ::std::basic_string<char> first;
  ::std::vector<std::pair<std::basic_string<char>,double> > second;
};
#ifdef __std__pair_constsstd__basic_string_char__std__vector_std__basic_string_char_s_s_
#undef __std__pair_constsstd__basic_string_char__std__vector_std__basic_string_char_s_s_
#endif
struct __std__pair_constsstd__basic_string_char__std__vector_std__basic_string_char_s_s_ {
  public:
  __std__pair_constsstd__basic_string_char__std__vector_std__basic_string_char_s_s_();
  ::std::basic_string<char> first;
  ::std::vector<std::basic_string<char> > second;
};
#ifdef __std__pair_constsstd__basic_string_char__std__pair_unsignedsint_unsignedsint_s_
#undef __std__pair_constsstd__basic_string_char__std__pair_unsignedsint_unsignedsint_s_
#endif
struct __std__pair_constsstd__basic_string_char__std__pair_unsignedsint_unsignedsint_s_ {
  public:
  __std__pair_constsstd__basic_string_char__std__pair_unsignedsint_unsignedsint_s_();
  ::std::basic_string<char> first;
  ::std::pair<unsigned int,unsigned int> second;
};
#ifdef __std__pair_constsstd__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s_
#undef __std__pair_constsstd__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s_
#endif
struct __std__pair_constsstd__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s_ {
  public:
  __std__pair_constsstd__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s_();
  ::std::basic_string<char> first;
  ::std::map<std::basic_string<char>,std::basic_string<char> > second;
};
#ifdef __std__pair_constsstd__basic_string_char__int_
#undef __std__pair_constsstd__basic_string_char__int_
#endif
struct __std__pair_constsstd__basic_string_char__int_ {
  public:
  __std__pair_constsstd__basic_string_char__int_();
  ::std::basic_string<char> first;
  int second;
};
#ifdef __std__pair_constsstd__basic_string_char__bool_
#undef __std__pair_constsstd__basic_string_char__bool_
#endif
struct __std__pair_constsstd__basic_string_char__bool_ {
  public:
  __std__pair_constsstd__basic_string_char__bool_();
  ::std::basic_string<char> first;
  bool second;
};
#ifdef __std__pair_constsshort_unsignedsint_
#undef __std__pair_constsshort_unsignedsint_
#endif
struct __std__pair_constsshort_unsignedsint_ {
  public:
  __std__pair_constsshort_unsignedsint_();
  short first;
  unsigned int second;
};
#ifdef __std__pair_constsint_unsignedsint_
#undef __std__pair_constsint_unsignedsint_
#endif
struct __std__pair_constsint_unsignedsint_ {
  public:
  __std__pair_constsint_unsignedsint_();
  int first;
  unsigned int second;
};
#ifdef __std__pair_constsint_std__pair_unsignedslong_unsignedslong_s_
#undef __std__pair_constsint_std__pair_unsignedslong_unsignedslong_s_
#endif
struct __std__pair_constsint_std__pair_unsignedslong_unsignedslong_s_ {
  public:
  __std__pair_constsint_std__pair_unsignedslong_unsignedslong_s_();
  int first;
  ::std::pair<unsigned long,unsigned long> second;
};
#ifdef __std__pair_constsint_std__pair_unsignedsint_unsignedsint_s_
#undef __std__pair_constsint_std__pair_unsignedsint_unsignedsint_s_
#endif
struct __std__pair_constsint_std__pair_unsignedsint_unsignedsint_s_ {
  public:
  __std__pair_constsint_std__pair_unsignedsint_unsignedsint_s_();
  int first;
  ::std::pair<unsigned int,unsigned int> second;
};
#ifdef __std__pair_constsint_std__pair_double_double_s_
#undef __std__pair_constsint_std__pair_double_double_s_
#endif
struct __std__pair_constsint_std__pair_double_double_s_ {
  public:
  __std__pair_constsint_std__pair_double_double_s_();
  int first;
  ::std::pair<double,double> second;
};
#ifdef __std__pair_constsint_int_
#undef __std__pair_constsint_int_
#endif
struct __std__pair_constsint_int_ {
  public:
  __std__pair_constsint_int_();
  int first;
  int second;
};
#ifdef __std__input_iterator_tag
#undef __std__input_iterator_tag
#endif
struct __std__input_iterator_tag {
  public:
  __std__input_iterator_tag();
};
#ifdef __std__vector_constsvoidp_
#undef __std__vector_constsvoidp_
#endif
class __std__vector_constsvoidp_ : protected ::std::_Vector_base<const void*,std::allocator<const void*> > {
  public:
  __std__vector_constsvoidp_();
};
#ifdef __std__vector_unsignedsshort_
#undef __std__vector_unsignedsshort_
#endif
class __std__vector_unsignedsshort_ : protected ::std::_Vector_base<unsigned short,std::allocator<unsigned short> > {
  public:
  __std__vector_unsignedsshort_();
};
#ifdef __std__vector_unsignedslong_
#undef __std__vector_unsignedslong_
#endif
class __std__vector_unsignedslong_ : protected ::std::_Vector_base<unsigned long,std::allocator<unsigned long> > {
  public:
  __std__vector_unsignedslong_();
};
#ifdef __std__vector_unsignedslongslong_
#undef __std__vector_unsignedslongslong_
#endif
class __std__vector_unsignedslongslong_ : protected ::std::_Vector_base<unsigned long long,std::allocator<unsigned long long> > {
  public:
  __std__vector_unsignedslongslong_();
};
#ifdef __std__vector_unsignedsint_
#undef __std__vector_unsignedsint_
#endif
class __std__vector_unsignedsint_ : protected ::std::_Vector_base<unsigned int,std::allocator<unsigned int> > {
  public:
  __std__vector_unsignedsint_();
};
#ifdef __std__vector_unsignedschar_
#undef __std__vector_unsignedschar_
#endif
class __std__vector_unsignedschar_ : protected ::std::_Vector_base<unsigned char,std::allocator<unsigned char> > {
  public:
  __std__vector_unsignedschar_();
};
#ifdef __std__vector_unsignedscharp_
#undef __std__vector_unsignedscharp_
#endif
class __std__vector_unsignedscharp_ : protected ::std::_Vector_base<unsigned char*,std::allocator<unsigned char*> > {
  public:
  __std__vector_unsignedscharp_();
};
#ifdef __std__vector_std__vector_unsignedsshort_s_
#undef __std__vector_std__vector_unsignedsshort_s_
#endif
class __std__vector_std__vector_unsignedsshort_s_ : protected ::std::_Vector_base<std::vector<unsigned short>,std::allocator<std::vector<unsigned short> > > {
  public:
  __std__vector_std__vector_unsignedsshort_s_();
};
#ifdef __std__vector_std__vector_unsignedsint_s_
#undef __std__vector_std__vector_unsignedsint_s_
#endif
class __std__vector_std__vector_unsignedsint_s_ : protected ::std::_Vector_base<std::vector<unsigned int>,std::allocator<std::vector<unsigned int> > > {
  public:
  __std__vector_std__vector_unsignedsint_s_();
};
#ifdef __std__vector_int_
#undef __std__vector_int_
#endif
class __std__vector_int_ : protected ::std::_Vector_base<int,std::allocator<int> > {
  public:
  __std__vector_int_();
};
#ifdef __std__vector_std__vector_int_s_
#undef __std__vector_std__vector_int_s_
#endif
class __std__vector_std__vector_int_s_ : protected ::std::_Vector_base<std::vector<int>,std::allocator<std::vector<int> > > {
  public:
  __std__vector_std__vector_int_s_();
};
#ifdef __std__vector_std__vector_std__vector_int_s_s_
#undef __std__vector_std__vector_std__vector_int_s_s_
#endif
class __std__vector_std__vector_std__vector_int_s_s_ : protected ::std::_Vector_base<std::vector<std::vector<int> >,std::allocator<std::vector<std::vector<int> > > > {
  public:
  __std__vector_std__vector_std__vector_int_s_s_();
};
#ifdef __std__vector_std__pair_int_double_s_
#undef __std__vector_std__pair_int_double_s_
#endif
class __std__vector_std__pair_int_double_s_ : protected ::std::_Vector_base<std::pair<int,double>,std::allocator<std::pair<int,double> > > {
  public:
  __std__vector_std__pair_int_double_s_();
};
#ifdef __std__vector_std__vector_std__pair_int_double_s_s_
#undef __std__vector_std__vector_std__pair_int_double_s_s_
#endif
class __std__vector_std__vector_std__pair_int_double_s_s_ : protected ::std::_Vector_base<std::vector<std::pair<int,double> >,std::allocator<std::vector<std::pair<int,double> > > > {
  public:
  __std__vector_std__vector_std__pair_int_double_s_s_();
};
#ifdef __std__vector_short_
#undef __std__vector_short_
#endif
class __std__vector_short_ : protected ::std::_Vector_base<short,std::allocator<short> > {
  public:
  __std__vector_short_();
};
#ifdef __std__vector_std__vector_short_s_
#undef __std__vector_std__vector_short_s_
#endif
class __std__vector_std__vector_short_s_ : protected ::std::_Vector_base<std::vector<short>,std::allocator<std::vector<short> > > {
  public:
  __std__vector_std__vector_short_s_();
};
#ifdef __std__vector_float_
#undef __std__vector_float_
#endif
class __std__vector_float_ : protected ::std::_Vector_base<float,std::allocator<float> > {
  public:
  __std__vector_float_();
};
#ifdef __std__vector_std__vector_float_s_
#undef __std__vector_std__vector_float_s_
#endif
class __std__vector_std__vector_float_s_ : protected ::std::_Vector_base<std::vector<float>,std::allocator<std::vector<float> > > {
  public:
  __std__vector_std__vector_float_s_();
};
#ifdef __std__vector_double_
#undef __std__vector_double_
#endif
class __std__vector_double_ : protected ::std::_Vector_base<double,std::allocator<double> > {
  public:
  __std__vector_double_();
};
#ifdef __std__vector_std__vector_double_s_
#undef __std__vector_std__vector_double_s_
#endif
class __std__vector_std__vector_double_s_ : protected ::std::_Vector_base<std::vector<double>,std::allocator<std::vector<double> > > {
  public:
  __std__vector_std__vector_double_s_();
};
#ifdef __std__basic_string_char_
#undef __std__basic_string_char_
#endif
struct __std__basic_string_char_ {
  public:
  __std__basic_string_char_();
#ifdef __std__basic_string_char____Rep_base
#undef __std__basic_string_char____Rep_base
#endif
  struct __std__basic_string_char____Rep_base {
    public:
    __std__basic_string_char____Rep_base();
    ::std::size_t _M_length;
    ::std::size_t _M_capacity;
    ::_Atomic_word _M_refcount;
  };
#ifdef __std__basic_string_char____Rep
#undef __std__basic_string_char____Rep
#endif
  struct __std__basic_string_char____Rep :   public __std__basic_string_char____Rep_base   {
    public:
    __std__basic_string_char____Rep();
  };
#ifdef __std__basic_string_char____Alloc_hider
#undef __std__basic_string_char____Alloc_hider
#endif
  struct __std__basic_string_char____Alloc_hider :   public ::std::allocator<char>   {
    public:
    __std__basic_string_char____Alloc_hider();
    void* _M_p;
  };
  __std__basic_string_char____Alloc_hider _M_dataplus;
};
#ifdef __std__vector_std__basic_string_char_s_
#undef __std__vector_std__basic_string_char_s_
#endif
class __std__vector_std__basic_string_char_s_ : protected ::std::_Vector_base<std::basic_string<char>,std::allocator<std::basic_string<char> > > {
  public:
  __std__vector_std__basic_string_char_s_();
};
#ifdef __std__vector_std__pair_unsignedslongslong_std__basic_string_char_s_s_
#undef __std__vector_std__pair_unsignedslongslong_std__basic_string_char_s_s_
#endif
class __std__vector_std__pair_unsignedslongslong_std__basic_string_char_s_s_ : protected ::std::_Vector_base<std::pair<unsigned long long,std::basic_string<char> >,std::allocator<std::pair<unsigned long long,std::basic_string<char> > > > {
  public:
  __std__vector_std__pair_unsignedslongslong_std__basic_string_char_s_s_();
};
#ifdef __std__vector_std__pair_unsignedsint_unsignedsint_s_
#undef __std__vector_std__pair_unsignedsint_unsignedsint_s_
#endif
class __std__vector_std__pair_unsignedsint_unsignedsint_s_ : protected ::std::_Vector_base<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > {
  public:
  __std__vector_std__pair_unsignedsint_unsignedsint_s_();
};
#ifdef __std__vector_std__pair_unsignedsint_int_s_
#undef __std__vector_std__pair_unsignedsint_int_s_
#endif
class __std__vector_std__pair_unsignedsint_int_s_ : protected ::std::_Vector_base<std::pair<unsigned int,int>,std::allocator<std::pair<unsigned int,int> > > {
  public:
  __std__vector_std__pair_unsignedsint_int_s_();
};
#ifdef __std__vector_std__pair_unsignedsint_float_s_
#undef __std__vector_std__pair_unsignedsint_float_s_
#endif
class __std__vector_std__pair_unsignedsint_float_s_ : protected ::std::_Vector_base<std::pair<unsigned int,float>,std::allocator<std::pair<unsigned int,float> > > {
  public:
  __std__vector_std__pair_unsignedsint_float_s_();
};
#ifdef __std__vector_std__pair_unsignedsint_double_s_
#undef __std__vector_std__pair_unsignedsint_double_s_
#endif
class __std__vector_std__pair_unsignedsint_double_s_ : protected ::std::_Vector_base<std::pair<unsigned int,double>,std::allocator<std::pair<unsigned int,double> > > {
  public:
  __std__vector_std__pair_unsignedsint_double_s_();
};
#ifdef __std__vector_std__pair_unsignedsint_bool_s_
#undef __std__vector_std__pair_unsignedsint_bool_s_
#endif
class __std__vector_std__pair_unsignedsint_bool_s_ : protected ::std::_Vector_base<std::pair<unsigned int,bool>,std::allocator<std::pair<unsigned int,bool> > > {
  public:
  __std__vector_std__pair_unsignedsint_bool_s_();
};
#ifdef __std__vector_std__pair_std__vector_std__pair_double_std__vector_double_s_s__bool_s_
#undef __std__vector_std__pair_std__vector_std__pair_double_std__vector_double_s_s__bool_s_
#endif
class __std__vector_std__pair_std__vector_std__pair_double_std__vector_double_s_s__bool_s_ : protected ::std::_Vector_base<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>,std::allocator<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> > > {
  public:
  __std__vector_std__pair_std__vector_std__pair_double_std__vector_double_s_s__bool_s_();
};
#ifdef __std__vector_std__pair_double_std__vector_double_s_s_
#undef __std__vector_std__pair_double_std__vector_double_s_s_
#endif
class __std__vector_std__pair_double_std__vector_double_s_s_ : protected ::std::_Vector_base<std::pair<double,std::vector<double> >,std::allocator<std::pair<double,std::vector<double> > > > {
  public:
  __std__vector_std__pair_double_std__vector_double_s_s_();
};
#ifdef __std__vector_std__pair_std__basic_string_char__int_s_
#undef __std__vector_std__pair_std__basic_string_char__int_s_
#endif
class __std__vector_std__pair_std__basic_string_char__int_s_ : protected ::std::_Vector_base<std::pair<std::basic_string<char>,int>,std::allocator<std::pair<std::basic_string<char>,int> > > {
  public:
  __std__vector_std__pair_std__basic_string_char__int_s_();
};
#ifdef __std__vector_std__pair_std__basic_string_char__float_s_
#undef __std__vector_std__pair_std__basic_string_char__float_s_
#endif
class __std__vector_std__pair_std__basic_string_char__float_s_ : protected ::std::_Vector_base<std::pair<std::basic_string<char>,float>,std::allocator<std::pair<std::basic_string<char>,float> > > {
  public:
  __std__vector_std__pair_std__basic_string_char__float_s_();
};
#ifdef __std__vector_std__pair_std__basic_string_char__double_s_
#undef __std__vector_std__pair_std__basic_string_char__double_s_
#endif
class __std__vector_std__pair_std__basic_string_char__double_s_ : protected ::std::_Vector_base<std::pair<std::basic_string<char>,double>,std::allocator<std::pair<std::basic_string<char>,double> > > {
  public:
  __std__vector_std__pair_std__basic_string_char__double_s_();
};
#ifdef __std__vector_std__pair_std__basic_string_char__bool_s_
#undef __std__vector_std__pair_std__basic_string_char__bool_s_
#endif
class __std__vector_std__pair_std__basic_string_char__bool_s_ : protected ::std::_Vector_base<std::pair<std::basic_string<char>,bool>,std::allocator<std::pair<std::basic_string<char>,bool> > > {
  public:
  __std__vector_std__pair_std__basic_string_char__bool_s_();
};
#ifdef __std__vector_std__pair_int_int_s_
#undef __std__vector_std__pair_int_int_s_
#endif
class __std__vector_std__pair_int_int_s_ : protected ::std::_Vector_base<std::pair<int,int>,std::allocator<std::pair<int,int> > > {
  public:
  __std__vector_std__pair_int_int_s_();
};
#ifdef __std__vector_std__pair_float_float_s_
#undef __std__vector_std__pair_float_float_s_
#endif
class __std__vector_std__pair_float_float_s_ : protected ::std::_Vector_base<std::pair<float,float>,std::allocator<std::pair<float,float> > > {
  public:
  __std__vector_std__pair_float_float_s_();
};
#ifdef __std__vector_std__pair_double_double_s_
#undef __std__vector_std__pair_double_double_s_
#endif
class __std__vector_std__pair_double_double_s_ : protected ::std::_Vector_base<std::pair<double,double>,std::allocator<std::pair<double,double> > > {
  public:
  __std__vector_std__pair_double_double_s_();
};
#ifdef __std__map_short_short_
#undef __std__map_short_short_
#endif
class __std__map_short_short_ {
  public:
  __std__map_short_short_();
  ::std::_Rb_tree<short,std::pair<const short,short>,std::_Select1st<std::pair<const short,short> >,std::less<short>,std::allocator<std::pair<const short,short> > > _M_t;
};
#ifdef __std__vector_std__map_short_short_s_
#undef __std__vector_std__map_short_short_s_
#endif
class __std__vector_std__map_short_short_s_ : protected ::std::_Vector_base<std::map<short,short>,std::allocator<std::map<short,short> > > {
  public:
  __std__vector_std__map_short_short_s_();
};
#ifdef __std__vector_long_
#undef __std__vector_long_
#endif
class __std__vector_long_ : protected ::std::_Vector_base<long,std::allocator<long> > {
  public:
  __std__vector_long_();
};
#ifdef __std__vector_longslong_
#undef __std__vector_longslong_
#endif
class __std__vector_longslong_ : protected ::std::_Vector_base<long long,std::allocator<long long> > {
  public:
  __std__vector_longslong_();
};
#ifdef __std__vector_longsdouble_
#undef __std__vector_longsdouble_
#endif
class __std__vector_longsdouble_ : protected ::std::_Vector_base<long double,std::allocator<long double> > {
  public:
  __std__vector_longsdouble_();
};
#ifdef __std__vector_char_
#undef __std__vector_char_
#endif
class __std__vector_char_ : protected ::std::_Vector_base<char,std::allocator<char> > {
  public:
  __std__vector_char_();
};
#ifdef __std__vector_charp_
#undef __std__vector_charp_
#endif
class __std__vector_charp_ : protected ::std::_Vector_base<char*,std::allocator<char*> > {
  public:
  __std__vector_charp_();
};
#ifdef __std__vector_bool_
#undef __std__vector_bool_
#endif
class __std__vector_bool_ : protected ::std::_Bvector_base<std::allocator<bool> > {
  public:
  __std__vector_bool_();
};
#ifdef __std__forward_iterator_tag
#undef __std__forward_iterator_tag
#endif
struct __std__forward_iterator_tag : public ::std::input_iterator_tag {
  public:
  __std__forward_iterator_tag();
};
#ifdef __std__random_access_iterator_tag
#undef __std__random_access_iterator_tag
#endif
struct __std__random_access_iterator_tag : public ::std::bidirectional_iterator_tag {
  public:
  __std__random_access_iterator_tag();
};
#ifdef __std__allocator_int_
#undef __std__allocator_int_
#endif
class __std__allocator_int_ : public ::__gnu_cxx::new_allocator<int> {
  public:
  __std__allocator_int_();
};
#ifdef __std__allocator_short_
#undef __std__allocator_short_
#endif
class __std__allocator_short_ : public ::__gnu_cxx::new_allocator<short> {
  public:
  __std__allocator_short_();
};
#ifdef __std__allocator_double_
#undef __std__allocator_double_
#endif
class __std__allocator_double_ : public ::__gnu_cxx::new_allocator<double> {
  public:
  __std__allocator_double_();
};
#ifdef __std__allocator_char_
#undef __std__allocator_char_
#endif
struct __std__allocator_char_ : public ::__gnu_cxx::new_allocator<char> {
  public:
  __std__allocator_char_();
};
#ifdef __std__set_std__basic_string_char_s_
#undef __std__set_std__basic_string_char_s_
#endif
class __std__set_std__basic_string_char_s_ {
  public:
  __std__set_std__basic_string_char_s_();
  ::std::_Rb_tree<std::basic_string<char>,std::basic_string<char>,std::_Identity<std::basic_string<char> >,std::less<std::basic_string<char> >,std::allocator<std::basic_string<char> > > _M_t;
};
#ifdef __std__set_int_
#undef __std__set_int_
#endif
class __std__set_int_ {
  public:
  __std__set_int_();
  ::std::_Rb_tree<int,int,std::_Identity<int>,std::less<int>,std::allocator<int> > _M_t;
};
#ifdef __std__output_iterator_tag
#undef __std__output_iterator_tag
#endif
struct __std__output_iterator_tag {
  public:
  __std__output_iterator_tag();
};
#ifdef __std__list_int_
#undef __std__list_int_
#endif
class __std__list_int_ : protected ::std::_List_base<int,std::allocator<int> > {
  public:
  __std__list_int_();
};
#ifdef __std__map_std__basic_string_char__std__basic_string_char_s_
#undef __std__map_std__basic_string_char__std__basic_string_char_s_
#endif
class __std__map_std__basic_string_char__std__basic_string_char_s_ {
  public:
  __std__map_std__basic_string_char__std__basic_string_char_s_();
  ::std::_Rb_tree<std::basic_string<char>,std::pair<const std::basic_string<char>,std::basic_string<char> >,std::_Select1st<std::pair<const std::basic_string<char>,std::basic_string<char> > >,std::less<std::basic_string<char> >,std::allocator<std::pair<const std::basic_string<char>,std::basic_string<char> > > > _M_t;
};
#ifdef __std__map_unsignedsshort_unsignedsshort_
#undef __std__map_unsignedsshort_unsignedsshort_
#endif
class __std__map_unsignedsshort_unsignedsshort_ {
  public:
  __std__map_unsignedsshort_unsignedsshort_();
  ::std::_Rb_tree<unsigned short,std::pair<const unsigned short,unsigned short>,std::_Select1st<std::pair<const unsigned short,unsigned short> >,std::less<unsigned short>,std::allocator<std::pair<const unsigned short,unsigned short> > > _M_t;
};
#ifdef __std__map_unsignedsshort_std__vector_unsignedsshort_s_
#undef __std__map_unsignedsshort_std__vector_unsignedsshort_s_
#endif
class __std__map_unsignedsshort_std__vector_unsignedsshort_s_ {
  public:
  __std__map_unsignedsshort_std__vector_unsignedsshort_s_();
  ::std::_Rb_tree<unsigned short,std::pair<const unsigned short,std::vector<unsigned short> >,std::_Select1st<std::pair<const unsigned short,std::vector<unsigned short> > >,std::less<unsigned short>,std::allocator<std::pair<const unsigned short,std::vector<unsigned short> > > > _M_t;
};
#ifdef __std__map_unsignedsshort_float_
#undef __std__map_unsignedsshort_float_
#endif
class __std__map_unsignedsshort_float_ {
  public:
  __std__map_unsignedsshort_float_();
  ::std::_Rb_tree<unsigned short,std::pair<const unsigned short,float>,std::_Select1st<std::pair<const unsigned short,float> >,std::less<unsigned short>,std::allocator<std::pair<const unsigned short,float> > > _M_t;
};
#ifdef __std__map_unsignedslong_unsignedslong_
#undef __std__map_unsignedslong_unsignedslong_
#endif
class __std__map_unsignedslong_unsignedslong_ {
  public:
  __std__map_unsignedslong_unsignedslong_();
  ::std::_Rb_tree<unsigned long,std::pair<const unsigned long,unsigned long>,std::_Select1st<std::pair<const unsigned long,unsigned long> >,std::less<unsigned long>,std::allocator<std::pair<const unsigned long,unsigned long> > > _M_t;
};
#ifdef __std__map_unsignedslong_std__vector_unsignedslong_s_
#undef __std__map_unsignedslong_std__vector_unsignedslong_s_
#endif
class __std__map_unsignedslong_std__vector_unsignedslong_s_ {
  public:
  __std__map_unsignedslong_std__vector_unsignedslong_s_();
  ::std::_Rb_tree<unsigned long,std::pair<const unsigned long,std::vector<unsigned long> >,std::_Select1st<std::pair<const unsigned long,std::vector<unsigned long> > >,std::less<unsigned long>,std::allocator<std::pair<const unsigned long,std::vector<unsigned long> > > > _M_t;
};
#ifdef __std__map_unsignedslongslong_std__basic_string_char_s_
#undef __std__map_unsignedslongslong_std__basic_string_char_s_
#endif
class __std__map_unsignedslongslong_std__basic_string_char_s_ {
  public:
  __std__map_unsignedslongslong_std__basic_string_char_s_();
  ::std::_Rb_tree<unsigned long long,std::pair<const unsigned long long,std::basic_string<char> >,std::_Select1st<std::pair<const unsigned long long,std::basic_string<char> > >,std::less<unsigned long long>,std::allocator<std::pair<const unsigned long long,std::basic_string<char> > > > _M_t;
};
#ifdef __std__map_unsignedsint_unsignedsint_
#undef __std__map_unsignedsint_unsignedsint_
#endif
class __std__map_unsignedsint_unsignedsint_ {
  public:
  __std__map_unsignedsint_unsignedsint_();
  ::std::_Rb_tree<unsigned int,std::pair<const unsigned int,unsigned int>,std::_Select1st<std::pair<const unsigned int,unsigned int> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,unsigned int> > > _M_t;
};
#ifdef __std__map_unsignedsint_std__vector_unsignedsint_s_
#undef __std__map_unsignedsint_std__vector_unsignedsint_s_
#endif
class __std__map_unsignedsint_std__vector_unsignedsint_s_ {
  public:
  __std__map_unsignedsint_std__vector_unsignedsint_s_();
  ::std::_Rb_tree<unsigned int,std::pair<const unsigned int,std::vector<unsigned int> >,std::_Select1st<std::pair<const unsigned int,std::vector<unsigned int> > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,std::vector<unsigned int> > > > _M_t;
};
#ifdef __std__map_unsignedsint_std__vector_std__pair_unsignedsint_float_s_s_
#undef __std__map_unsignedsint_std__vector_std__pair_unsignedsint_float_s_s_
#endif
class __std__map_unsignedsint_std__vector_std__pair_unsignedsint_float_s_s_ {
  public:
  __std__map_unsignedsint_std__vector_std__pair_unsignedsint_float_s_s_();
  ::std::_Rb_tree<unsigned int,std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > >,std::_Select1st<std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > > > > _M_t;
};
#ifdef __std__map_unsignedsint_std__vector_std__pair_unsignedsint_double_s_s_
#undef __std__map_unsignedsint_std__vector_std__pair_unsignedsint_double_s_s_
#endif
class __std__map_unsignedsint_std__vector_std__pair_unsignedsint_double_s_s_ {
  public:
  __std__map_unsignedsint_std__vector_std__pair_unsignedsint_double_s_s_();
  ::std::_Rb_tree<unsigned int,std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > >,std::_Select1st<std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > > > _M_t;
};
#ifdef __std__map_unsignedsint_std__vector_std__pair_unsignedsint_bool_s_s_
#undef __std__map_unsignedsint_std__vector_std__pair_unsignedsint_bool_s_s_
#endif
class __std__map_unsignedsint_std__vector_std__pair_unsignedsint_bool_s_s_ {
  public:
  __std__map_unsignedsint_std__vector_std__pair_unsignedsint_bool_s_s_();
  ::std::_Rb_tree<unsigned int,std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > >,std::_Select1st<std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > > > _M_t;
};
#ifdef __std__map_unsignedsint_std__pair_unsignedsint_unsignedsint_s_
#undef __std__map_unsignedsint_std__pair_unsignedsint_unsignedsint_s_
#endif
class __std__map_unsignedsint_std__pair_unsignedsint_unsignedsint_s_ {
  public:
  __std__map_unsignedsint_std__pair_unsignedsint_unsignedsint_s_();
  ::std::_Rb_tree<unsigned int,std::pair<const unsigned int,std::pair<unsigned int,unsigned int> >,std::_Select1st<std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > > > _M_t;
};
#ifdef __std__map_unsignedsint_std__basic_string_char_s_
#undef __std__map_unsignedsint_std__basic_string_char_s_
#endif
class __std__map_unsignedsint_std__basic_string_char_s_ {
  public:
  __std__map_unsignedsint_std__basic_string_char_s_();
  ::std::_Rb_tree<unsigned int,std::pair<const unsigned int,std::basic_string<char> >,std::_Select1st<std::pair<const unsigned int,std::basic_string<char> > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,std::basic_string<char> > > > _M_t;
};
#ifdef __std__map_unsignedsint_short_
#undef __std__map_unsignedsint_short_
#endif
class __std__map_unsignedsint_short_ {
  public:
  __std__map_unsignedsint_short_();
  ::std::_Rb_tree<unsigned int,std::pair<const unsigned int,short>,std::_Select1st<std::pair<const unsigned int,short> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,short> > > _M_t;
};
#ifdef __std__map_unsignedsint_int_
#undef __std__map_unsignedsint_int_
#endif
class __std__map_unsignedsint_int_ {
  public:
  __std__map_unsignedsint_int_();
  ::std::_Rb_tree<unsigned int,std::pair<const unsigned int,int>,std::_Select1st<std::pair<const unsigned int,int> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,int> > > _M_t;
};
#ifdef __std__map_unsignedsint_float_
#undef __std__map_unsignedsint_float_
#endif
class __std__map_unsignedsint_float_ {
  public:
  __std__map_unsignedsint_float_();
  ::std::_Rb_tree<unsigned int,std::pair<const unsigned int,float>,std::_Select1st<std::pair<const unsigned int,float> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,float> > > _M_t;
};
#ifdef __std__map_unsignedsint_double_
#undef __std__map_unsignedsint_double_
#endif
class __std__map_unsignedsint_double_ {
  public:
  __std__map_unsignedsint_double_();
  ::std::_Rb_tree<unsigned int,std::pair<const unsigned int,double>,std::_Select1st<std::pair<const unsigned int,double> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,double> > > _M_t;
};
#ifdef __std__map_unsignedsint_bool_
#undef __std__map_unsignedsint_bool_
#endif
class __std__map_unsignedsint_bool_ {
  public:
  __std__map_unsignedsint_bool_();
  ::std::_Rb_tree<unsigned int,std::pair<const unsigned int,bool>,std::_Select1st<std::pair<const unsigned int,bool> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int,bool> > > _M_t;
};
#ifdef __std__map_std__pair_short_short__std__pair_short_std__vector_short_s_s_
#undef __std__map_std__pair_short_short__std__pair_short_std__vector_short_s_s_
#endif
class __std__map_std__pair_short_short__std__pair_short_std__vector_short_s_s_ {
  public:
  __std__map_std__pair_short_short__std__pair_short_std__vector_short_s_s_();
  ::std::_Rb_tree<std::pair<short,short>,std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > >,std::_Select1st<std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > >,std::less<std::pair<short,short> >,std::allocator<std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > > > _M_t;
};
#ifdef __std__map_std__pair_int_int__int_
#undef __std__map_std__pair_int_int__int_
#endif
class __std__map_std__pair_int_int__int_ {
  public:
  __std__map_std__pair_int_int__int_();
  ::std::_Rb_tree<std::pair<int,int>,std::pair<const std::pair<int,int>,int>,std::_Select1st<std::pair<const std::pair<int,int>,int> >,std::less<std::pair<int,int> >,std::allocator<std::pair<const std::pair<int,int>,int> > > _M_t;
};
#ifdef __std__map_std__pair_int_int__double_
#undef __std__map_std__pair_int_int__double_
#endif
class __std__map_std__pair_int_int__double_ {
  public:
  __std__map_std__pair_int_int__double_();
  ::std::_Rb_tree<std::pair<int,int>,std::pair<const std::pair<int,int>,double>,std::_Select1st<std::pair<const std::pair<int,int>,double> >,std::less<std::pair<int,int> >,std::allocator<std::pair<const std::pair<int,int>,double> > > _M_t;
};
#ifdef __std__map_std__basic_string_char__unsignedslong_
#undef __std__map_std__basic_string_char__unsignedslong_
#endif
class __std__map_std__basic_string_char__unsignedslong_ {
  public:
  __std__map_std__basic_string_char__unsignedslong_();
  ::std::_Rb_tree<std::basic_string<char>,std::pair<const std::basic_string<char>,unsigned long>,std::_Select1st<std::pair<const std::basic_string<char>,unsigned long> >,std::less<std::basic_string<char> >,std::allocator<std::pair<const std::basic_string<char>,unsigned long> > > _M_t;
};
#ifdef __std__map_std__basic_string_char__unsignedsint_
#undef __std__map_std__basic_string_char__unsignedsint_
#endif
class __std__map_std__basic_string_char__unsignedsint_ {
  public:
  __std__map_std__basic_string_char__unsignedsint_();
  ::std::_Rb_tree<std::basic_string<char>,std::pair<const std::basic_string<char>,unsigned int>,std::_Select1st<std::pair<const std::basic_string<char>,unsigned int> >,std::less<std::basic_string<char> >,std::allocator<std::pair<const std::basic_string<char>,unsigned int> > > _M_t;
};
#ifdef __std__map_std__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s_
#undef __std__map_std__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s_
#endif
class __std__map_std__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s_ {
  public:
  __std__map_std__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s_();
  ::std::_Rb_tree<std::basic_string<char>,std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >,std::_Select1st<std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >,std::less<std::basic_string<char> >,std::allocator<std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > > > _M_t;
};
#ifdef __std__map_std__basic_string_char__std__vector_std__basic_string_char_s_s_
#undef __std__map_std__basic_string_char__std__vector_std__basic_string_char_s_s_
#endif
class __std__map_std__basic_string_char__std__vector_std__basic_string_char_s_s_ {
  public:
  __std__map_std__basic_string_char__std__vector_std__basic_string_char_s_s_();
  ::std::_Rb_tree<std::basic_string<char>,std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > >,std::_Select1st<std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > >,std::less<std::basic_string<char> >,std::allocator<std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > > > _M_t;
};
#ifdef __std__map_std__basic_string_char__std__pair_unsignedsint_unsignedsint_s_
#undef __std__map_std__basic_string_char__std__pair_unsignedsint_unsignedsint_s_
#endif
class __std__map_std__basic_string_char__std__pair_unsignedsint_unsignedsint_s_ {
  public:
  __std__map_std__basic_string_char__std__pair_unsignedsint_unsignedsint_s_();
  ::std::_Rb_tree<std::basic_string<char>,std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> >,std::_Select1st<std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > >,std::less<std::basic_string<char> >,std::allocator<std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > > > _M_t;
};
#ifdef __std__map_std__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s_
#undef __std__map_std__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s_
#endif
class __std__map_std__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s_ {
  public:
  __std__map_std__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s_();
  ::std::_Rb_tree<std::basic_string<char>,std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >,std::_Select1st<std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >,std::less<std::basic_string<char> >,std::allocator<std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > > > _M_t;
};
#ifdef __std__map_std__basic_string_char__int_
#undef __std__map_std__basic_string_char__int_
#endif
class __std__map_std__basic_string_char__int_ {
  public:
  __std__map_std__basic_string_char__int_();
  ::std::_Rb_tree<std::basic_string<char>,std::pair<const std::basic_string<char>,int>,std::_Select1st<std::pair<const std::basic_string<char>,int> >,std::less<std::basic_string<char> >,std::allocator<std::pair<const std::basic_string<char>,int> > > _M_t;
};
#ifdef __std__map_std__basic_string_char__bool_
#undef __std__map_std__basic_string_char__bool_
#endif
class __std__map_std__basic_string_char__bool_ {
  public:
  __std__map_std__basic_string_char__bool_();
  ::std::_Rb_tree<std::basic_string<char>,std::pair<const std::basic_string<char>,bool>,std::_Select1st<std::pair<const std::basic_string<char>,bool> >,std::less<std::basic_string<char> >,std::allocator<std::pair<const std::basic_string<char>,bool> > > _M_t;
};
#ifdef __std__map_short_unsignedsint_
#undef __std__map_short_unsignedsint_
#endif
class __std__map_short_unsignedsint_ {
  public:
  __std__map_short_unsignedsint_();
  ::std::_Rb_tree<short,std::pair<const short,unsigned int>,std::_Select1st<std::pair<const short,unsigned int> >,std::less<short>,std::allocator<std::pair<const short,unsigned int> > > _M_t;
};
#ifdef __std__map_int_unsignedsint_
#undef __std__map_int_unsignedsint_
#endif
class __std__map_int_unsignedsint_ {
  public:
  __std__map_int_unsignedsint_();
  ::std::_Rb_tree<int,std::pair<const int,unsigned int>,std::_Select1st<std::pair<const int,unsigned int> >,std::less<int>,std::allocator<std::pair<const int,unsigned int> > > _M_t;
};
#ifdef __std__map_int_std__pair_unsignedslong_unsignedslong_s_
#undef __std__map_int_std__pair_unsignedslong_unsignedslong_s_
#endif
class __std__map_int_std__pair_unsignedslong_unsignedslong_s_ {
  public:
  __std__map_int_std__pair_unsignedslong_unsignedslong_s_();
  ::std::_Rb_tree<int,std::pair<const int,std::pair<unsigned long,unsigned long> >,std::_Select1st<std::pair<const int,std::pair<unsigned long,unsigned long> > >,std::less<int>,std::allocator<std::pair<const int,std::pair<unsigned long,unsigned long> > > > _M_t;
};
#ifdef __std__map_int_std__pair_unsignedsint_unsignedsint_s_
#undef __std__map_int_std__pair_unsignedsint_unsignedsint_s_
#endif
class __std__map_int_std__pair_unsignedsint_unsignedsint_s_ {
  public:
  __std__map_int_std__pair_unsignedsint_unsignedsint_s_();
  ::std::_Rb_tree<int,std::pair<const int,std::pair<unsigned int,unsigned int> >,std::_Select1st<std::pair<const int,std::pair<unsigned int,unsigned int> > >,std::less<int>,std::allocator<std::pair<const int,std::pair<unsigned int,unsigned int> > > > _M_t;
};
#ifdef __std__map_int_std__pair_double_double_s_
#undef __std__map_int_std__pair_double_double_s_
#endif
class __std__map_int_std__pair_double_double_s_ {
  public:
  __std__map_int_std__pair_double_double_s_();
  ::std::_Rb_tree<int,std::pair<const int,std::pair<double,double> >,std::_Select1st<std::pair<const int,std::pair<double,double> > >,std::less<int>,std::allocator<std::pair<const int,std::pair<double,double> > > > _M_t;
};
#ifdef __std__map_int_int_
#undef __std__map_int_int_
#endif
class __std__map_int_int_ {
  public:
  __std__map_int_int_();
  ::std::_Rb_tree<int,std::pair<const int,int>,std::_Select1st<std::pair<const int,int> >,std::less<int>,std::allocator<std::pair<const int,int> > > _M_t;
};
#ifdef __std__deque_int_
#undef __std__deque_int_
#endif
class __std__deque_int_ : protected ::std::_Deque_base<int,std::allocator<int> > {
  public:
  __std__deque_int_();
};
#ifdef __std__bitset_7_
#undef __std__bitset_7_
#endif
class __std__bitset_7_ : private ::std::_Base_bitset<1> {
  public:
  __std__bitset_7_();
};
#ifdef __std__bidirectional_iterator_tag
#undef __std__bidirectional_iterator_tag
#endif
struct __std__bidirectional_iterator_tag : public ::std::forward_iterator_tag {
  public:
  __std__bidirectional_iterator_tag();
};
#ifdef __std__less_int_
#undef __std__less_int_
#endif
struct __std__less_int_ : public ::std::binary_function<int,int,bool> {
  public:
  __std__less_int_();
};
#ifdef __std__multimap_double_double_
#undef __std__multimap_double_double_
#endif
class __std__multimap_double_double_ {
  public:
  __std__multimap_double_double_();
  ::std::_Rb_tree<double,std::pair<const double,double>,std::_Select1st<std::pair<const double,double> >,std::less<double>,std::allocator<std::pair<const double,double> > > _M_t;
};
#ifdef ____gnu_cxx____normal_iterator_std__basic_string_char_p_std__vector_std__basic_string_char_s_s_
#undef ____gnu_cxx____normal_iterator_std__basic_string_char_p_std__vector_std__basic_string_char_s_s_
#endif
class ____gnu_cxx____normal_iterator_std__basic_string_char_p_std__vector_std__basic_string_char_s_s_ {
  public:
  ____gnu_cxx____normal_iterator_std__basic_string_char_p_std__vector_std__basic_string_char_s_s_();
  void* _M_current;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class pair<int,double> -------------------------------
static void destructor_2789(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<int,double>*)o)->::std::pair<int,double>::~pair)();
}
static  void operator_2790( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<int,double>*)o)->operator=)(*(const ::std::pair<int,double>*)arg[0]);
  else   (((::std::pair<int,double>*)o)->operator=)(*(const ::std::pair<int,double>*)arg[0]);
}

static void constructor_2791( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<int,double>(*(const ::std::pair<int,double>*)arg[0]);
  else ::new(mem) ::std::pair<int,double>(*(const ::std::pair<int,double>*)arg[0]);
}

static void constructor_2792( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<int,double>();
  else ::new(mem) ::std::pair<int,double>();
}

static void constructor_2793( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<int,double>(*(const int*)arg[0],
      *(const double*)arg[1]);
  else ::new(mem) ::std::pair<int,double>(*(const int*)arg[0],
      *(const double*)arg[1]);
}

static void method_newdel_812( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<int,double> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<int,double> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<int,double> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<int,double> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<int,double> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<int,double> -------------------------------
void __std__pair_int_double__db_datamem(Reflex::Class*);
void __std__pair_int_double__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_int_double__datamem_bld(&__std__pair_int_double__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_int_double__funcmem_bld(&__std__pair_int_double__db_funcmem);
void __std__pair_int_double__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<int,double>"), typeid(::std::pair<int,double>), sizeof(::std::pair<int,double>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_22, Reflex::Literal("std::pair<int,double>::first_type"))
  .AddTypedef(type_2052, Reflex::Literal("std::pair<int,double>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_2789, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4532, type_4534), Reflex::Literal("operator="), operator_2790, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4534), Reflex::Literal("pair"), constructor_2791, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_2792, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4404, type_4918), Reflex::Literal("pair"), constructor_2793, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_812, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_int_double__datamem_bld);
}

//------Delayed data member builder for class pair<int,double> -------------------
void __std__pair_int_double__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_22, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_int_double_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_2052, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_int_double_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<int,double> -------------------
void __std__pair_int_double__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<long long unsigned int,std::basic_string<char, std::char_traits<char>, std::allocator<char> > > -------------------------------
static void destructor_2798(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<unsigned long long,std::basic_string<char> >*)o)->::std::pair<unsigned long long,std::basic_string<char> >::~pair)();
}
static  void operator_2799( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<unsigned long long,std::basic_string<char> >*)o)->operator=)(*(const ::std::pair<unsigned long long,std::basic_string<char> >*)arg[0]);
  else   (((::std::pair<unsigned long long,std::basic_string<char> >*)o)->operator=)(*(const ::std::pair<unsigned long long,std::basic_string<char> >*)arg[0]);
}

static void constructor_2800( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned long long,std::basic_string<char> >(*(const ::std::pair<unsigned long long,std::basic_string<char> >*)arg[0]);
  else ::new(mem) ::std::pair<unsigned long long,std::basic_string<char> >(*(const ::std::pair<unsigned long long,std::basic_string<char> >*)arg[0]);
}

static void constructor_2801( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned long long,std::basic_string<char> >();
  else ::new(mem) ::std::pair<unsigned long long,std::basic_string<char> >();
}

static void constructor_2802( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned long long,std::basic_string<char> >(*(const unsigned long long*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
  else ::new(mem) ::std::pair<unsigned long long,std::basic_string<char> >(*(const unsigned long long*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
}

static void method_newdel_813( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned long long,std::basic_string<char> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned long long,std::basic_string<char> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned long long,std::basic_string<char> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned long long,std::basic_string<char> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned long long,std::basic_string<char> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<long long unsigned int,std::basic_string<char, std::char_traits<char>, std::allocator<char> > > -------------------------------
void __std__pair_unsignedslongslong_std__basic_string_char_s__db_datamem(Reflex::Class*);
void __std__pair_unsignedslongslong_std__basic_string_char_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_unsignedslongslong_std__basic_string_char_s__datamem_bld(&__std__pair_unsignedslongslong_std__basic_string_char_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_unsignedslongslong_std__basic_string_char_s__funcmem_bld(&__std__pair_unsignedslongslong_std__basic_string_char_s__db_funcmem);
void __std__pair_unsignedslongslong_std__basic_string_char_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<unsigned long long,std::basic_string<char> >"), typeid(::std::pair<unsigned long long,std::basic_string<char> >), sizeof(::std::pair<unsigned long long,std::basic_string<char> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_2144, Reflex::Literal("std::pair<unsigned long long,std::basic_string<char> >::first_type"))
  .AddTypedef(type_1104, Reflex::Literal("std::pair<unsigned long long,std::basic_string<char> >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_2798, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5044, type_5046), Reflex::Literal("operator="), operator_2799, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5046), Reflex::Literal("pair"), constructor_2800, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_2801, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3888, type_4981), Reflex::Literal("pair"), constructor_2802, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_813, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_unsignedslongslong_std__basic_string_char_s__datamem_bld);
}

//------Delayed data member builder for class pair<long long unsigned int,std::basic_string<char, std::char_traits<char>, std::allocator<char> > > -------------------
void __std__pair_unsignedslongslong_std__basic_string_char_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2144, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_unsignedslongslong_std__basic_string_char_s_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_1104, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_unsignedslongslong_std__basic_string_char_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<long long unsigned int,std::basic_string<char, std::char_traits<char>, std::allocator<char> > > -------------------
void __std__pair_unsignedslongslong_std__basic_string_char_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<unsigned int,unsigned int> -------------------------------
static void destructor_2807(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<unsigned int,unsigned int>*)o)->::std::pair<unsigned int,unsigned int>::~pair)();
}
static  void operator_2808( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<unsigned int,unsigned int>*)o)->operator=)(*(const ::std::pair<unsigned int,unsigned int>*)arg[0]);
  else   (((::std::pair<unsigned int,unsigned int>*)o)->operator=)(*(const ::std::pair<unsigned int,unsigned int>*)arg[0]);
}

static void constructor_2809( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,unsigned int>(*(const ::std::pair<unsigned int,unsigned int>*)arg[0]);
  else ::new(mem) ::std::pair<unsigned int,unsigned int>(*(const ::std::pair<unsigned int,unsigned int>*)arg[0]);
}

static void constructor_2810( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,unsigned int>();
  else ::new(mem) ::std::pair<unsigned int,unsigned int>();
}

static void constructor_2811( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,unsigned int>(*(const unsigned int*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::std::pair<unsigned int,unsigned int>(*(const unsigned int*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_814( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,unsigned int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,unsigned int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,unsigned int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,unsigned int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,unsigned int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<unsigned int,unsigned int> -------------------------------
void __std__pair_unsignedsint_unsignedsint__db_datamem(Reflex::Class*);
void __std__pair_unsignedsint_unsignedsint__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_unsignedsint_unsignedsint__datamem_bld(&__std__pair_unsignedsint_unsignedsint__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_unsignedsint_unsignedsint__funcmem_bld(&__std__pair_unsignedsint_unsignedsint__db_funcmem);
void __std__pair_unsignedsint_unsignedsint__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<unsigned int,unsigned int>"), typeid(::std::pair<unsigned int,unsigned int>), sizeof(::std::pair<unsigned int,unsigned int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_78, Reflex::Literal("std::pair<unsigned int,unsigned int>::first_type"))
  .AddTypedef(type_78, Reflex::Literal("std::pair<unsigned int,unsigned int>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_2807, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5109, type_5111), Reflex::Literal("operator="), operator_2808, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5111), Reflex::Literal("pair"), constructor_2809, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_2810, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3951, type_3951), Reflex::Literal("pair"), constructor_2811, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_814, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_unsignedsint_unsignedsint__datamem_bld);
}

//------Delayed data member builder for class pair<unsigned int,unsigned int> -------------------
void __std__pair_unsignedsint_unsignedsint__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_78, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_unsignedsint_unsignedsint_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_78, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_unsignedsint_unsignedsint_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<unsigned int,unsigned int> -------------------
void __std__pair_unsignedsint_unsignedsint__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<unsigned int,int> -------------------------------
static void destructor_2816(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<unsigned int,int>*)o)->::std::pair<unsigned int,int>::~pair)();
}
static  void operator_2817( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<unsigned int,int>*)o)->operator=)(*(const ::std::pair<unsigned int,int>*)arg[0]);
  else   (((::std::pair<unsigned int,int>*)o)->operator=)(*(const ::std::pair<unsigned int,int>*)arg[0]);
}

static void constructor_2818( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,int>(*(const ::std::pair<unsigned int,int>*)arg[0]);
  else ::new(mem) ::std::pair<unsigned int,int>(*(const ::std::pair<unsigned int,int>*)arg[0]);
}

static void constructor_2819( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,int>();
  else ::new(mem) ::std::pair<unsigned int,int>();
}

static void constructor_2820( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,int>(*(const unsigned int*)arg[0],
      *(const int*)arg[1]);
  else ::new(mem) ::std::pair<unsigned int,int>(*(const unsigned int*)arg[0],
      *(const int*)arg[1]);
}

static void method_newdel_815( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<unsigned int,int> -------------------------------
void __std__pair_unsignedsint_int__db_datamem(Reflex::Class*);
void __std__pair_unsignedsint_int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_unsignedsint_int__datamem_bld(&__std__pair_unsignedsint_int__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_unsignedsint_int__funcmem_bld(&__std__pair_unsignedsint_int__db_funcmem);
void __std__pair_unsignedsint_int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<unsigned int,int>"), typeid(::std::pair<unsigned int,int>), sizeof(::std::pair<unsigned int,int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_78, Reflex::Literal("std::pair<unsigned int,int>::first_type"))
  .AddTypedef(type_22, Reflex::Literal("std::pair<unsigned int,int>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_2816, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5174, type_5176), Reflex::Literal("operator="), operator_2817, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5176), Reflex::Literal("pair"), constructor_2818, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_2819, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3951, type_4404), Reflex::Literal("pair"), constructor_2820, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_815, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_unsignedsint_int__datamem_bld);
}

//------Delayed data member builder for class pair<unsigned int,int> -------------------
void __std__pair_unsignedsint_int__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_78, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_unsignedsint_int_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_22, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_unsignedsint_int_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<unsigned int,int> -------------------
void __std__pair_unsignedsint_int__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<unsigned int,float> -------------------------------
static void destructor_2825(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<unsigned int,float>*)o)->::std::pair<unsigned int,float>::~pair)();
}
static  void operator_2826( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<unsigned int,float>*)o)->operator=)(*(const ::std::pair<unsigned int,float>*)arg[0]);
  else   (((::std::pair<unsigned int,float>*)o)->operator=)(*(const ::std::pair<unsigned int,float>*)arg[0]);
}

static void constructor_2827( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,float>(*(const ::std::pair<unsigned int,float>*)arg[0]);
  else ::new(mem) ::std::pair<unsigned int,float>(*(const ::std::pair<unsigned int,float>*)arg[0]);
}

static void constructor_2828( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,float>();
  else ::new(mem) ::std::pair<unsigned int,float>();
}

static void constructor_2829( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,float>(*(const unsigned int*)arg[0],
      *(const float*)arg[1]);
  else ::new(mem) ::std::pair<unsigned int,float>(*(const unsigned int*)arg[0],
      *(const float*)arg[1]);
}

static void method_newdel_816( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,float> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,float> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,float> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,float> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,float> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<unsigned int,float> -------------------------------
void __std__pair_unsignedsint_float__db_datamem(Reflex::Class*);
void __std__pair_unsignedsint_float__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_unsignedsint_float__datamem_bld(&__std__pair_unsignedsint_float__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_unsignedsint_float__funcmem_bld(&__std__pair_unsignedsint_float__db_funcmem);
void __std__pair_unsignedsint_float__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<unsigned int,float>"), typeid(::std::pair<unsigned int,float>), sizeof(::std::pair<unsigned int,float>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_78, Reflex::Literal("std::pair<unsigned int,float>::first_type"))
  .AddTypedef(type_2058, Reflex::Literal("std::pair<unsigned int,float>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_2825, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5239, type_5241), Reflex::Literal("operator="), operator_2826, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5241), Reflex::Literal("pair"), constructor_2827, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_2828, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3951, type_4790), Reflex::Literal("pair"), constructor_2829, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_816, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_unsignedsint_float__datamem_bld);
}

//------Delayed data member builder for class pair<unsigned int,float> -------------------
void __std__pair_unsignedsint_float__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_78, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_unsignedsint_float_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_2058, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_unsignedsint_float_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<unsigned int,float> -------------------
void __std__pair_unsignedsint_float__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<unsigned int,double> -------------------------------
static void destructor_2834(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<unsigned int,double>*)o)->::std::pair<unsigned int,double>::~pair)();
}
static  void operator_2835( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<unsigned int,double>*)o)->operator=)(*(const ::std::pair<unsigned int,double>*)arg[0]);
  else   (((::std::pair<unsigned int,double>*)o)->operator=)(*(const ::std::pair<unsigned int,double>*)arg[0]);
}

static void constructor_2836( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,double>(*(const ::std::pair<unsigned int,double>*)arg[0]);
  else ::new(mem) ::std::pair<unsigned int,double>(*(const ::std::pair<unsigned int,double>*)arg[0]);
}

static void constructor_2837( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,double>();
  else ::new(mem) ::std::pair<unsigned int,double>();
}

static void constructor_2838( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,double>(*(const unsigned int*)arg[0],
      *(const double*)arg[1]);
  else ::new(mem) ::std::pair<unsigned int,double>(*(const unsigned int*)arg[0],
      *(const double*)arg[1]);
}

static void method_newdel_817( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,double> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,double> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,double> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,double> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,double> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<unsigned int,double> -------------------------------
void __std__pair_unsignedsint_double__db_datamem(Reflex::Class*);
void __std__pair_unsignedsint_double__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_unsignedsint_double__datamem_bld(&__std__pair_unsignedsint_double__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_unsignedsint_double__funcmem_bld(&__std__pair_unsignedsint_double__db_funcmem);
void __std__pair_unsignedsint_double__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<unsigned int,double>"), typeid(::std::pair<unsigned int,double>), sizeof(::std::pair<unsigned int,double>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_78, Reflex::Literal("std::pair<unsigned int,double>::first_type"))
  .AddTypedef(type_2052, Reflex::Literal("std::pair<unsigned int,double>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_2834, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5304, type_5306), Reflex::Literal("operator="), operator_2835, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5306), Reflex::Literal("pair"), constructor_2836, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_2837, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3951, type_4918), Reflex::Literal("pair"), constructor_2838, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_817, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_unsignedsint_double__datamem_bld);
}

//------Delayed data member builder for class pair<unsigned int,double> -------------------
void __std__pair_unsignedsint_double__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_78, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_unsignedsint_double_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_2052, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_unsignedsint_double_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<unsigned int,double> -------------------
void __std__pair_unsignedsint_double__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<unsigned int,bool> -------------------------------
static void destructor_2843(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<unsigned int,bool>*)o)->::std::pair<unsigned int,bool>::~pair)();
}
static  void operator_2844( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<unsigned int,bool>*)o)->operator=)(*(const ::std::pair<unsigned int,bool>*)arg[0]);
  else   (((::std::pair<unsigned int,bool>*)o)->operator=)(*(const ::std::pair<unsigned int,bool>*)arg[0]);
}

static void constructor_2845( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,bool>(*(const ::std::pair<unsigned int,bool>*)arg[0]);
  else ::new(mem) ::std::pair<unsigned int,bool>(*(const ::std::pair<unsigned int,bool>*)arg[0]);
}

static void constructor_2846( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,bool>();
  else ::new(mem) ::std::pair<unsigned int,bool>();
}

static void constructor_2847( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,bool>(*(const unsigned int*)arg[0],
      *(const bool*)arg[1]);
  else ::new(mem) ::std::pair<unsigned int,bool>(*(const unsigned int*)arg[0],
      *(const bool*)arg[1]);
}

static void method_newdel_818( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,bool> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,bool> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,bool> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,bool> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,bool> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<unsigned int,bool> -------------------------------
void __std__pair_unsignedsint_bool__db_datamem(Reflex::Class*);
void __std__pair_unsignedsint_bool__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_unsignedsint_bool__datamem_bld(&__std__pair_unsignedsint_bool__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_unsignedsint_bool__funcmem_bld(&__std__pair_unsignedsint_bool__db_funcmem);
void __std__pair_unsignedsint_bool__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<unsigned int,bool>"), typeid(::std::pair<unsigned int,bool>), sizeof(::std::pair<unsigned int,bool>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_78, Reflex::Literal("std::pair<unsigned int,bool>::first_type"))
  .AddTypedef(type_2083, Reflex::Literal("std::pair<unsigned int,bool>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_2843, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5369, type_5371), Reflex::Literal("operator="), operator_2844, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5371), Reflex::Literal("pair"), constructor_2845, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_2846, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3951, type_11878), Reflex::Literal("pair"), constructor_2847, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_818, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_unsignedsint_bool__datamem_bld);
}

//------Delayed data member builder for class pair<unsigned int,bool> -------------------
void __std__pair_unsignedsint_bool__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_78, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_unsignedsint_bool_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_2083, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_unsignedsint_bool_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<unsigned int,bool> -------------------
void __std__pair_unsignedsint_bool__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<double,std::vector<double, std::allocator<double> > > -------------------------------
static void destructor_2861(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<double,std::vector<double> >*)o)->::std::pair<double,std::vector<double> >::~pair)();
}
static  void operator_2862( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<double,std::vector<double> >*)o)->operator=)(*(const ::std::pair<double,std::vector<double> >*)arg[0]);
  else   (((::std::pair<double,std::vector<double> >*)o)->operator=)(*(const ::std::pair<double,std::vector<double> >*)arg[0]);
}

static void constructor_2863( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<double,std::vector<double> >(*(const ::std::pair<double,std::vector<double> >*)arg[0]);
  else ::new(mem) ::std::pair<double,std::vector<double> >(*(const ::std::pair<double,std::vector<double> >*)arg[0]);
}

static void constructor_2864( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<double,std::vector<double> >();
  else ::new(mem) ::std::pair<double,std::vector<double> >();
}

static void constructor_2865( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<double,std::vector<double> >(*(const double*)arg[0],
      *(const ::std::vector<double>*)arg[1]);
  else ::new(mem) ::std::pair<double,std::vector<double> >(*(const double*)arg[0],
      *(const ::std::vector<double>*)arg[1]);
}

static void method_newdel_820( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<double,std::vector<double> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<double,std::vector<double> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<double,std::vector<double> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<double,std::vector<double> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<double,std::vector<double> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<double,std::vector<double, std::allocator<double> > > -------------------------------
void __std__pair_double_std__vector_double_s__db_datamem(Reflex::Class*);
void __std__pair_double_std__vector_double_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_double_std__vector_double_s__datamem_bld(&__std__pair_double_std__vector_double_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_double_std__vector_double_s__funcmem_bld(&__std__pair_double_std__vector_double_s__db_funcmem);
void __std__pair_double_std__vector_double_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<double,std::vector<double> >"), typeid(::std::pair<double,std::vector<double> >), sizeof(::std::pair<double,std::vector<double> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_2052, Reflex::Literal("std::pair<double,std::vector<double> >::first_type"))
  .AddTypedef(type_1069, Reflex::Literal("std::pair<double,std::vector<double> >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_2861, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5499, type_5501), Reflex::Literal("operator="), operator_2862, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5501), Reflex::Literal("pair"), constructor_2863, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_2864, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4918, type_4855), Reflex::Literal("pair"), constructor_2865, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_820, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_double_std__vector_double_s__datamem_bld);
}

//------Delayed data member builder for class pair<double,std::vector<double, std::allocator<double> > > -------------------
void __std__pair_double_std__vector_double_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2052, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_double_std__vector_double_s_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_1069, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_double_std__vector_double_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<double,std::vector<double, std::allocator<double> > > -------------------
void __std__pair_double_std__vector_double_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<std::vector<std::pair<double, std::vector<double, std::allocator<double> > >, std::allocator<std::pair<double, std::vector<double, std::allocator<double> > > > >,bool> -------------------------------
static void destructor_2852(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>*)o)->::std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>::~pair)();
}
static  void operator_2853( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>*)o)->operator=)(*(const ::std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>*)arg[0]);
  else   (((::std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>*)o)->operator=)(*(const ::std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>*)arg[0]);
}

static void constructor_2854( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>(*(const ::std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>*)arg[0]);
  else ::new(mem) ::std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>(*(const ::std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>*)arg[0]);
}

static void constructor_2855( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>();
  else ::new(mem) ::std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>();
}

static void constructor_2856( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>(*(const ::std::vector<std::pair<double,std::vector<double> > >*)arg[0],
      *(const bool*)arg[1]);
  else ::new(mem) ::std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>(*(const ::std::vector<std::pair<double,std::vector<double> > >*)arg[0],
      *(const bool*)arg[1]);
}

static void method_newdel_819( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<std::vector<std::pair<double, std::vector<double, std::allocator<double> > >, std::allocator<std::pair<double, std::vector<double, std::allocator<double> > > > >,bool> -------------------------------
void __std__pair_std__vector_std__pair_double_std__vector_double_s_s__bool__db_datamem(Reflex::Class*);
void __std__pair_std__vector_std__pair_double_std__vector_double_s_s__bool__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_std__vector_std__pair_double_std__vector_double_s_s__bool__datamem_bld(&__std__pair_std__vector_std__pair_double_std__vector_double_s_s__bool__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_std__vector_std__pair_double_std__vector_double_s_s__bool__funcmem_bld(&__std__pair_std__vector_std__pair_double_std__vector_double_s_s__bool__db_funcmem);
void __std__pair_std__vector_std__pair_double_std__vector_double_s_s__bool__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>"), typeid(::std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>), sizeof(::std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_1078, Reflex::Literal("std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>::first_type"))
  .AddTypedef(type_2083, Reflex::Literal("std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_2852, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5434, type_5436), Reflex::Literal("operator="), operator_2853, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5436), Reflex::Literal("pair"), constructor_2854, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_2855, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20175, type_11878), Reflex::Literal("pair"), constructor_2856, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_819, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_std__vector_std__pair_double_std__vector_double_s_s__bool__datamem_bld);
}

//------Delayed data member builder for class pair<std::vector<std::pair<double, std::vector<double, std::allocator<double> > >, std::allocator<std::pair<double, std::vector<double, std::allocator<double> > > > >,bool> -------------------
void __std__pair_std__vector_std__pair_double_std__vector_double_s_s__bool__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1078, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_std__vector_std__pair_double_std__vector_double_s_s__bool_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_2083, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_std__vector_std__pair_double_std__vector_double_s_s__bool_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<std::vector<std::pair<double, std::vector<double, std::allocator<double> > >, std::allocator<std::pair<double, std::vector<double, std::allocator<double> > > > >,bool> -------------------
void __std__pair_std__vector_std__pair_double_std__vector_double_s_s__bool__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,int> -------------------------------
static void destructor_2870(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<std::basic_string<char>,int>*)o)->::std::pair<std::basic_string<char>,int>::~pair)();
}
static  void operator_2871( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<std::basic_string<char>,int>*)o)->operator=)(*(const ::std::pair<std::basic_string<char>,int>*)arg[0]);
  else   (((::std::pair<std::basic_string<char>,int>*)o)->operator=)(*(const ::std::pair<std::basic_string<char>,int>*)arg[0]);
}

static void constructor_2872( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,int>(*(const ::std::pair<std::basic_string<char>,int>*)arg[0]);
  else ::new(mem) ::std::pair<std::basic_string<char>,int>(*(const ::std::pair<std::basic_string<char>,int>*)arg[0]);
}

static void constructor_2873( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,int>();
  else ::new(mem) ::std::pair<std::basic_string<char>,int>();
}

static void constructor_2874( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,int>(*(const ::std::basic_string<char>*)arg[0],
      *(const int*)arg[1]);
  else ::new(mem) ::std::pair<std::basic_string<char>,int>(*(const ::std::basic_string<char>*)arg[0],
      *(const int*)arg[1]);
}

static void method_newdel_821( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,int> -------------------------------
void __std__pair_std__basic_string_char__int__db_datamem(Reflex::Class*);
void __std__pair_std__basic_string_char__int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_std__basic_string_char__int__datamem_bld(&__std__pair_std__basic_string_char__int__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_std__basic_string_char__int__funcmem_bld(&__std__pair_std__basic_string_char__int__db_funcmem);
void __std__pair_std__basic_string_char__int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<std::basic_string<char>,int>"), typeid(::std::pair<std::basic_string<char>,int>), sizeof(::std::pair<std::basic_string<char>,int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_1104, Reflex::Literal("std::pair<std::basic_string<char>,int>::first_type"))
  .AddTypedef(type_22, Reflex::Literal("std::pair<std::basic_string<char>,int>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_2870, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5564, type_5566), Reflex::Literal("operator="), operator_2871, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5566), Reflex::Literal("pair"), constructor_2872, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_2873, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4981, type_4404), Reflex::Literal("pair"), constructor_2874, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_821, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_std__basic_string_char__int__datamem_bld);
}

//------Delayed data member builder for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,int> -------------------
void __std__pair_std__basic_string_char__int__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1104, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_std__basic_string_char__int_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_22, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_std__basic_string_char__int_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,int> -------------------
void __std__pair_std__basic_string_char__int__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,float> -------------------------------
static void destructor_2879(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<std::basic_string<char>,float>*)o)->::std::pair<std::basic_string<char>,float>::~pair)();
}
static  void operator_2880( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<std::basic_string<char>,float>*)o)->operator=)(*(const ::std::pair<std::basic_string<char>,float>*)arg[0]);
  else   (((::std::pair<std::basic_string<char>,float>*)o)->operator=)(*(const ::std::pair<std::basic_string<char>,float>*)arg[0]);
}

static void constructor_2881( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,float>(*(const ::std::pair<std::basic_string<char>,float>*)arg[0]);
  else ::new(mem) ::std::pair<std::basic_string<char>,float>(*(const ::std::pair<std::basic_string<char>,float>*)arg[0]);
}

static void constructor_2882( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,float>();
  else ::new(mem) ::std::pair<std::basic_string<char>,float>();
}

static void constructor_2883( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,float>(*(const ::std::basic_string<char>*)arg[0],
      *(const float*)arg[1]);
  else ::new(mem) ::std::pair<std::basic_string<char>,float>(*(const ::std::basic_string<char>*)arg[0],
      *(const float*)arg[1]);
}

static void method_newdel_822( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,float> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,float> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,float> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,float> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,float> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,float> -------------------------------
void __std__pair_std__basic_string_char__float__db_datamem(Reflex::Class*);
void __std__pair_std__basic_string_char__float__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_std__basic_string_char__float__datamem_bld(&__std__pair_std__basic_string_char__float__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_std__basic_string_char__float__funcmem_bld(&__std__pair_std__basic_string_char__float__db_funcmem);
void __std__pair_std__basic_string_char__float__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<std::basic_string<char>,float>"), typeid(::std::pair<std::basic_string<char>,float>), sizeof(::std::pair<std::basic_string<char>,float>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_1104, Reflex::Literal("std::pair<std::basic_string<char>,float>::first_type"))
  .AddTypedef(type_2058, Reflex::Literal("std::pair<std::basic_string<char>,float>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_2879, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5629, type_5631), Reflex::Literal("operator="), operator_2880, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5631), Reflex::Literal("pair"), constructor_2881, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_2882, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4981, type_4790), Reflex::Literal("pair"), constructor_2883, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_822, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_std__basic_string_char__float__datamem_bld);
}

//------Delayed data member builder for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,float> -------------------
void __std__pair_std__basic_string_char__float__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1104, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_std__basic_string_char__float_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_2058, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_std__basic_string_char__float_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,float> -------------------
void __std__pair_std__basic_string_char__float__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,double> -------------------------------
static void destructor_2888(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<std::basic_string<char>,double>*)o)->::std::pair<std::basic_string<char>,double>::~pair)();
}
static  void operator_2889( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<std::basic_string<char>,double>*)o)->operator=)(*(const ::std::pair<std::basic_string<char>,double>*)arg[0]);
  else   (((::std::pair<std::basic_string<char>,double>*)o)->operator=)(*(const ::std::pair<std::basic_string<char>,double>*)arg[0]);
}

static void constructor_2890( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,double>(*(const ::std::pair<std::basic_string<char>,double>*)arg[0]);
  else ::new(mem) ::std::pair<std::basic_string<char>,double>(*(const ::std::pair<std::basic_string<char>,double>*)arg[0]);
}

static void constructor_2891( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,double>();
  else ::new(mem) ::std::pair<std::basic_string<char>,double>();
}

static void constructor_2892( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,double>(*(const ::std::basic_string<char>*)arg[0],
      *(const double*)arg[1]);
  else ::new(mem) ::std::pair<std::basic_string<char>,double>(*(const ::std::basic_string<char>*)arg[0],
      *(const double*)arg[1]);
}

static void method_newdel_823( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,double> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,double> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,double> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,double> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,double> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,double> -------------------------------
void __std__pair_std__basic_string_char__double__db_datamem(Reflex::Class*);
void __std__pair_std__basic_string_char__double__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_std__basic_string_char__double__datamem_bld(&__std__pair_std__basic_string_char__double__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_std__basic_string_char__double__funcmem_bld(&__std__pair_std__basic_string_char__double__db_funcmem);
void __std__pair_std__basic_string_char__double__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<std::basic_string<char>,double>"), typeid(::std::pair<std::basic_string<char>,double>), sizeof(::std::pair<std::basic_string<char>,double>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_1104, Reflex::Literal("std::pair<std::basic_string<char>,double>::first_type"))
  .AddTypedef(type_2052, Reflex::Literal("std::pair<std::basic_string<char>,double>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_2888, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5694, type_5696), Reflex::Literal("operator="), operator_2889, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5696), Reflex::Literal("pair"), constructor_2890, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_2891, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4981, type_4918), Reflex::Literal("pair"), constructor_2892, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_823, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_std__basic_string_char__double__datamem_bld);
}

//------Delayed data member builder for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,double> -------------------
void __std__pair_std__basic_string_char__double__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1104, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_std__basic_string_char__double_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_2052, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_std__basic_string_char__double_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,double> -------------------
void __std__pair_std__basic_string_char__double__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,bool> -------------------------------
static void destructor_2897(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<std::basic_string<char>,bool>*)o)->::std::pair<std::basic_string<char>,bool>::~pair)();
}
static  void operator_2898( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<std::basic_string<char>,bool>*)o)->operator=)(*(const ::std::pair<std::basic_string<char>,bool>*)arg[0]);
  else   (((::std::pair<std::basic_string<char>,bool>*)o)->operator=)(*(const ::std::pair<std::basic_string<char>,bool>*)arg[0]);
}

static void constructor_2899( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,bool>(*(const ::std::pair<std::basic_string<char>,bool>*)arg[0]);
  else ::new(mem) ::std::pair<std::basic_string<char>,bool>(*(const ::std::pair<std::basic_string<char>,bool>*)arg[0]);
}

static void constructor_2900( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,bool>();
  else ::new(mem) ::std::pair<std::basic_string<char>,bool>();
}

static void constructor_2901( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,bool>(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
  else ::new(mem) ::std::pair<std::basic_string<char>,bool>(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
}

static void method_newdel_824( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,bool> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,bool> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,bool> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,bool> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,bool> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,bool> -------------------------------
void __std__pair_std__basic_string_char__bool__db_datamem(Reflex::Class*);
void __std__pair_std__basic_string_char__bool__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_std__basic_string_char__bool__datamem_bld(&__std__pair_std__basic_string_char__bool__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_std__basic_string_char__bool__funcmem_bld(&__std__pair_std__basic_string_char__bool__db_funcmem);
void __std__pair_std__basic_string_char__bool__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<std::basic_string<char>,bool>"), typeid(::std::pair<std::basic_string<char>,bool>), sizeof(::std::pair<std::basic_string<char>,bool>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_1104, Reflex::Literal("std::pair<std::basic_string<char>,bool>::first_type"))
  .AddTypedef(type_2083, Reflex::Literal("std::pair<std::basic_string<char>,bool>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_2897, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5759, type_5761), Reflex::Literal("operator="), operator_2898, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5761), Reflex::Literal("pair"), constructor_2899, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_2900, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4981, type_11878), Reflex::Literal("pair"), constructor_2901, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_824, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_std__basic_string_char__bool__datamem_bld);
}

//------Delayed data member builder for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,bool> -------------------
void __std__pair_std__basic_string_char__bool__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1104, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_std__basic_string_char__bool_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_2083, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_std__basic_string_char__bool_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,bool> -------------------
void __std__pair_std__basic_string_char__bool__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<int,int> -------------------------------
static void destructor_2906(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<int,int>*)o)->::std::pair<int,int>::~pair)();
}
static  void operator_2907( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<int,int>*)o)->operator=)(*(const ::std::pair<int,int>*)arg[0]);
  else   (((::std::pair<int,int>*)o)->operator=)(*(const ::std::pair<int,int>*)arg[0]);
}

static void constructor_2908( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<int,int>(*(const ::std::pair<int,int>*)arg[0]);
  else ::new(mem) ::std::pair<int,int>(*(const ::std::pair<int,int>*)arg[0]);
}

static void constructor_2909( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<int,int>();
  else ::new(mem) ::std::pair<int,int>();
}

static void constructor_2910( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<int,int>(*(const int*)arg[0],
      *(const int*)arg[1]);
  else ::new(mem) ::std::pair<int,int>(*(const int*)arg[0],
      *(const int*)arg[1]);
}

static void method_newdel_825( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<int,int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<int,int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<int,int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<int,int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<int,int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<int,int> -------------------------------
void __std__pair_int_int__db_datamem(Reflex::Class*);
void __std__pair_int_int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_int_int__datamem_bld(&__std__pair_int_int__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_int_int__funcmem_bld(&__std__pair_int_int__db_funcmem);
void __std__pair_int_int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<int,int>"), typeid(::std::pair<int,int>), sizeof(::std::pair<int,int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_22, Reflex::Literal("std::pair<int,int>::first_type"))
  .AddTypedef(type_22, Reflex::Literal("std::pair<int,int>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_2906, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5824, type_5826), Reflex::Literal("operator="), operator_2907, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5826), Reflex::Literal("pair"), constructor_2908, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_2909, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4404, type_4404), Reflex::Literal("pair"), constructor_2910, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_825, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_int_int__datamem_bld);
}

//------Delayed data member builder for class pair<int,int> -------------------
void __std__pair_int_int__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_22, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_int_int_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_22, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_int_int_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<int,int> -------------------
void __std__pair_int_int__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<float,float> -------------------------------
static void destructor_2915(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<float,float>*)o)->::std::pair<float,float>::~pair)();
}
static  void operator_2916( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<float,float>*)o)->operator=)(*(const ::std::pair<float,float>*)arg[0]);
  else   (((::std::pair<float,float>*)o)->operator=)(*(const ::std::pair<float,float>*)arg[0]);
}

static void constructor_2917( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<float,float>(*(const ::std::pair<float,float>*)arg[0]);
  else ::new(mem) ::std::pair<float,float>(*(const ::std::pair<float,float>*)arg[0]);
}

static void constructor_2918( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<float,float>();
  else ::new(mem) ::std::pair<float,float>();
}

static void constructor_2919( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<float,float>(*(const float*)arg[0],
      *(const float*)arg[1]);
  else ::new(mem) ::std::pair<float,float>(*(const float*)arg[0],
      *(const float*)arg[1]);
}

static void method_newdel_826( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<float,float> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<float,float> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<float,float> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<float,float> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<float,float> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<float,float> -------------------------------
void __std__pair_float_float__db_datamem(Reflex::Class*);
void __std__pair_float_float__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_float_float__datamem_bld(&__std__pair_float_float__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_float_float__funcmem_bld(&__std__pair_float_float__db_funcmem);
void __std__pair_float_float__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<float,float>"), typeid(::std::pair<float,float>), sizeof(::std::pair<float,float>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_2058, Reflex::Literal("std::pair<float,float>::first_type"))
  .AddTypedef(type_2058, Reflex::Literal("std::pair<float,float>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_2915, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5889, type_5891), Reflex::Literal("operator="), operator_2916, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5891), Reflex::Literal("pair"), constructor_2917, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_2918, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4790, type_4790), Reflex::Literal("pair"), constructor_2919, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_826, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_float_float__datamem_bld);
}

//------Delayed data member builder for class pair<float,float> -------------------
void __std__pair_float_float__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2058, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_float_float_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_2058, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_float_float_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<float,float> -------------------
void __std__pair_float_float__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<double,double> -------------------------------
static void destructor_2924(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<double,double>*)o)->::std::pair<double,double>::~pair)();
}
static  void operator_2925( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<double,double>*)o)->operator=)(*(const ::std::pair<double,double>*)arg[0]);
  else   (((::std::pair<double,double>*)o)->operator=)(*(const ::std::pair<double,double>*)arg[0]);
}

static void constructor_2926( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<double,double>(*(const ::std::pair<double,double>*)arg[0]);
  else ::new(mem) ::std::pair<double,double>(*(const ::std::pair<double,double>*)arg[0]);
}

static void constructor_2927( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<double,double>();
  else ::new(mem) ::std::pair<double,double>();
}

static void constructor_2928( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<double,double>(*(const double*)arg[0],
      *(const double*)arg[1]);
  else ::new(mem) ::std::pair<double,double>(*(const double*)arg[0],
      *(const double*)arg[1]);
}

static void method_newdel_827( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<double,double> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<double,double> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<double,double> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<double,double> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<double,double> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<double,double> -------------------------------
void __std__pair_double_double__db_datamem(Reflex::Class*);
void __std__pair_double_double__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_double_double__datamem_bld(&__std__pair_double_double__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_double_double__funcmem_bld(&__std__pair_double_double__db_funcmem);
void __std__pair_double_double__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<double,double>"), typeid(::std::pair<double,double>), sizeof(::std::pair<double,double>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_2052, Reflex::Literal("std::pair<double,double>::first_type"))
  .AddTypedef(type_2052, Reflex::Literal("std::pair<double,double>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_2924, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5954, type_5956), Reflex::Literal("operator="), operator_2925, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5956), Reflex::Literal("pair"), constructor_2926, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_2927, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4918, type_4918), Reflex::Literal("pair"), constructor_2928, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_827, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_double_double__datamem_bld);
}

//------Delayed data member builder for class pair<double,double> -------------------
void __std__pair_double_double__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2052, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_double_double_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_2052, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_double_double_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<double,double> -------------------
void __std__pair_double_double__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<const short int,short int> -------------------------------
static void destructor_2933(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<const short,short>*)o)->::std::pair<const short,short>::~pair)();
}
static void constructor_2934( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const short,short>(*(const ::std::pair<const short,short>*)arg[0]);
  else ::new(mem) ::std::pair<const short,short>(*(const ::std::pair<const short,short>*)arg[0]);
}

static void constructor_2935( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const short,short>();
  else ::new(mem) ::std::pair<const short,short>();
}

static void constructor_2936( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const short,short>(*(const short*)arg[0],
      *(const short*)arg[1]);
  else ::new(mem) ::std::pair<const short,short>(*(const short*)arg[0],
      *(const short*)arg[1]);
}

static void method_newdel_828( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<const short,short> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<const short,short> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<const short,short> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<const short,short> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<const short,short> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<const short int,short int> -------------------------------
void __std__pair_constsshort_short__db_datamem(Reflex::Class*);
void __std__pair_constsshort_short__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_constsshort_short__datamem_bld(&__std__pair_constsshort_short__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_constsshort_short__funcmem_bld(&__std__pair_constsshort_short__db_funcmem);
void __std__pair_constsshort_short__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<const short,short>"), typeid(::std::pair<const short,short>), sizeof(::std::pair<const short,short>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_113c, Reflex::Literal("std::pair<const short,short>::first_type"))
  .AddTypedef(type_113, Reflex::Literal("std::pair<const short,short>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_2933, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10200), Reflex::Literal("pair"), constructor_2934, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_2935, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4662, type_4662), Reflex::Literal("pair"), constructor_2936, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_828, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_constsshort_short__datamem_bld);
}

//------Delayed data member builder for class pair<const short int,short int> -------------------
void __std__pair_constsshort_short__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_113c, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_constsshort_short_, first), ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddDataMember(type_113, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_constsshort_short_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<const short int,short int> -------------------
void __std__pair_constsshort_short__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<short unsigned int,short unsigned int> -------------------------------
static void destructor_2941(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<unsigned short,unsigned short>*)o)->::std::pair<unsigned short,unsigned short>::~pair)();
}
static  void operator_2942( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<unsigned short,unsigned short>*)o)->operator=)(*(const ::std::pair<unsigned short,unsigned short>*)arg[0]);
  else   (((::std::pair<unsigned short,unsigned short>*)o)->operator=)(*(const ::std::pair<unsigned short,unsigned short>*)arg[0]);
}

static void constructor_2943( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned short,unsigned short>(*(const ::std::pair<unsigned short,unsigned short>*)arg[0]);
  else ::new(mem) ::std::pair<unsigned short,unsigned short>(*(const ::std::pair<unsigned short,unsigned short>*)arg[0]);
}

static void constructor_2944( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned short,unsigned short>();
  else ::new(mem) ::std::pair<unsigned short,unsigned short>();
}

static void constructor_2945( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned short,unsigned short>(*(const unsigned short*)arg[0],
      *(const unsigned short*)arg[1]);
  else ::new(mem) ::std::pair<unsigned short,unsigned short>(*(const unsigned short*)arg[0],
      *(const unsigned short*)arg[1]);
}

static void method_newdel_837( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned short,unsigned short> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned short,unsigned short> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned short,unsigned short> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned short,unsigned short> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned short,unsigned short> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<short unsigned int,short unsigned int> -------------------------------
void __std__pair_unsignedsshort_unsignedsshort__db_datamem(Reflex::Class*);
void __std__pair_unsignedsshort_unsignedsshort__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_unsignedsshort_unsignedsshort__datamem_bld(&__std__pair_unsignedsshort_unsignedsshort__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_unsignedsshort_unsignedsshort__funcmem_bld(&__std__pair_unsignedsshort_unsignedsshort__db_funcmem);
void __std__pair_unsignedsshort_unsignedsshort__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<unsigned short,unsigned short>"), typeid(::std::pair<unsigned short,unsigned short>), sizeof(::std::pair<unsigned short,unsigned short>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_167, Reflex::Literal("std::pair<unsigned short,unsigned short>::first_type"))
  .AddTypedef(type_167, Reflex::Literal("std::pair<unsigned short,unsigned short>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_2941, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20177, type_20178), Reflex::Literal("operator="), operator_2942, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20178), Reflex::Literal("pair"), constructor_2943, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_2944, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3762, type_3762), Reflex::Literal("pair"), constructor_2945, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_837, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_unsignedsshort_unsignedsshort__datamem_bld);
}

//------Delayed data member builder for class pair<short unsigned int,short unsigned int> -------------------
void __std__pair_unsignedsshort_unsignedsshort__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_167, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_unsignedsshort_unsignedsshort_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_167, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_unsignedsshort_unsignedsshort_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<short unsigned int,short unsigned int> -------------------
void __std__pair_unsignedsshort_unsignedsshort__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<short unsigned int,std::vector<short unsigned int, std::allocator<short unsigned int> > > -------------------------------
static void destructor_2950(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<unsigned short,std::vector<unsigned short> >*)o)->::std::pair<unsigned short,std::vector<unsigned short> >::~pair)();
}
static  void operator_2951( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<unsigned short,std::vector<unsigned short> >*)o)->operator=)(*(const ::std::pair<unsigned short,std::vector<unsigned short> >*)arg[0]);
  else   (((::std::pair<unsigned short,std::vector<unsigned short> >*)o)->operator=)(*(const ::std::pair<unsigned short,std::vector<unsigned short> >*)arg[0]);
}

static void constructor_2952( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned short,std::vector<unsigned short> >(*(const ::std::pair<unsigned short,std::vector<unsigned short> >*)arg[0]);
  else ::new(mem) ::std::pair<unsigned short,std::vector<unsigned short> >(*(const ::std::pair<unsigned short,std::vector<unsigned short> >*)arg[0]);
}

static void constructor_2953( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned short,std::vector<unsigned short> >();
  else ::new(mem) ::std::pair<unsigned short,std::vector<unsigned short> >();
}

static void constructor_2954( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned short,std::vector<unsigned short> >(*(const unsigned short*)arg[0],
      *(const ::std::vector<unsigned short>*)arg[1]);
  else ::new(mem) ::std::pair<unsigned short,std::vector<unsigned short> >(*(const unsigned short*)arg[0],
      *(const ::std::vector<unsigned short>*)arg[1]);
}

static void method_newdel_838( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned short,std::vector<unsigned short> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned short,std::vector<unsigned short> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned short,std::vector<unsigned short> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned short,std::vector<unsigned short> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned short,std::vector<unsigned short> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<short unsigned int,std::vector<short unsigned int, std::allocator<short unsigned int> > > -------------------------------
void __std__pair_unsignedsshort_std__vector_unsignedsshort_s__db_datamem(Reflex::Class*);
void __std__pair_unsignedsshort_std__vector_unsignedsshort_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_unsignedsshort_std__vector_unsignedsshort_s__datamem_bld(&__std__pair_unsignedsshort_std__vector_unsignedsshort_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_unsignedsshort_std__vector_unsignedsshort_s__funcmem_bld(&__std__pair_unsignedsshort_std__vector_unsignedsshort_s__db_funcmem);
void __std__pair_unsignedsshort_std__vector_unsignedsshort_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<unsigned short,std::vector<unsigned short> >"), typeid(::std::pair<unsigned short,std::vector<unsigned short> >), sizeof(::std::pair<unsigned short,std::vector<unsigned short> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_167, Reflex::Literal("std::pair<unsigned short,std::vector<unsigned short> >::first_type"))
  .AddTypedef(type_1051, Reflex::Literal("std::pair<unsigned short,std::vector<unsigned short> >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_2950, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20179, type_20180), Reflex::Literal("operator="), operator_2951, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20180), Reflex::Literal("pair"), constructor_2952, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_2953, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3762, type_4146), Reflex::Literal("pair"), constructor_2954, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_838, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_unsignedsshort_std__vector_unsignedsshort_s__datamem_bld);
}

//------Delayed data member builder for class pair<short unsigned int,std::vector<short unsigned int, std::allocator<short unsigned int> > > -------------------
void __std__pair_unsignedsshort_std__vector_unsignedsshort_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_167, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_unsignedsshort_std__vector_unsignedsshort_s_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_1051, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_unsignedsshort_std__vector_unsignedsshort_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<short unsigned int,std::vector<short unsigned int, std::allocator<short unsigned int> > > -------------------
void __std__pair_unsignedsshort_std__vector_unsignedsshort_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<short unsigned int,float> -------------------------------
static void destructor_2959(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<unsigned short,float>*)o)->::std::pair<unsigned short,float>::~pair)();
}
static  void operator_2960( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<unsigned short,float>*)o)->operator=)(*(const ::std::pair<unsigned short,float>*)arg[0]);
  else   (((::std::pair<unsigned short,float>*)o)->operator=)(*(const ::std::pair<unsigned short,float>*)arg[0]);
}

static void constructor_2961( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned short,float>(*(const ::std::pair<unsigned short,float>*)arg[0]);
  else ::new(mem) ::std::pair<unsigned short,float>(*(const ::std::pair<unsigned short,float>*)arg[0]);
}

static void constructor_2962( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned short,float>();
  else ::new(mem) ::std::pair<unsigned short,float>();
}

static void constructor_2963( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned short,float>(*(const unsigned short*)arg[0],
      *(const float*)arg[1]);
  else ::new(mem) ::std::pair<unsigned short,float>(*(const unsigned short*)arg[0],
      *(const float*)arg[1]);
}

static void method_newdel_839( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned short,float> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned short,float> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned short,float> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned short,float> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned short,float> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<short unsigned int,float> -------------------------------
void __std__pair_unsignedsshort_float__db_datamem(Reflex::Class*);
void __std__pair_unsignedsshort_float__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_unsignedsshort_float__datamem_bld(&__std__pair_unsignedsshort_float__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_unsignedsshort_float__funcmem_bld(&__std__pair_unsignedsshort_float__db_funcmem);
void __std__pair_unsignedsshort_float__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<unsigned short,float>"), typeid(::std::pair<unsigned short,float>), sizeof(::std::pair<unsigned short,float>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_167, Reflex::Literal("std::pair<unsigned short,float>::first_type"))
  .AddTypedef(type_2058, Reflex::Literal("std::pair<unsigned short,float>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_2959, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20181, type_20182), Reflex::Literal("operator="), operator_2960, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20182), Reflex::Literal("pair"), constructor_2961, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_2962, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3762, type_4790), Reflex::Literal("pair"), constructor_2963, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_839, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_unsignedsshort_float__datamem_bld);
}

//------Delayed data member builder for class pair<short unsigned int,float> -------------------
void __std__pair_unsignedsshort_float__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_167, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_unsignedsshort_float_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_2058, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_unsignedsshort_float_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<short unsigned int,float> -------------------
void __std__pair_unsignedsshort_float__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<long unsigned int,long unsigned int> -------------------------------
static void destructor_2968(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<unsigned long,unsigned long>*)o)->::std::pair<unsigned long,unsigned long>::~pair)();
}
static  void operator_2969( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<unsigned long,unsigned long>*)o)->operator=)(*(const ::std::pair<unsigned long,unsigned long>*)arg[0]);
  else   (((::std::pair<unsigned long,unsigned long>*)o)->operator=)(*(const ::std::pair<unsigned long,unsigned long>*)arg[0]);
}

static void constructor_2970( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned long,unsigned long>(*(const ::std::pair<unsigned long,unsigned long>*)arg[0]);
  else ::new(mem) ::std::pair<unsigned long,unsigned long>(*(const ::std::pair<unsigned long,unsigned long>*)arg[0]);
}

static void constructor_2971( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned long,unsigned long>();
  else ::new(mem) ::std::pair<unsigned long,unsigned long>();
}

static void constructor_2972( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned long,unsigned long>(*(const unsigned long*)arg[0],
      *(const unsigned long*)arg[1]);
  else ::new(mem) ::std::pair<unsigned long,unsigned long>(*(const unsigned long*)arg[0],
      *(const unsigned long*)arg[1]);
}

static void method_newdel_840( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned long,unsigned long> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned long,unsigned long> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned long,unsigned long> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned long,unsigned long> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned long,unsigned long> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<long unsigned int,long unsigned int> -------------------------------
void __std__pair_unsignedslong_unsignedslong__db_datamem(Reflex::Class*);
void __std__pair_unsignedslong_unsignedslong__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_unsignedslong_unsignedslong__datamem_bld(&__std__pair_unsignedslong_unsignedslong__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_unsignedslong_unsignedslong__funcmem_bld(&__std__pair_unsignedslong_unsignedslong__db_funcmem);
void __std__pair_unsignedslong_unsignedslong__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<unsigned long,unsigned long>"), typeid(::std::pair<unsigned long,unsigned long>), sizeof(::std::pair<unsigned long,unsigned long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_75, Reflex::Literal("std::pair<unsigned long,unsigned long>::first_type"))
  .AddTypedef(type_75, Reflex::Literal("std::pair<unsigned long,unsigned long>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_2968, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20183, type_20184), Reflex::Literal("operator="), operator_2969, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20184), Reflex::Literal("pair"), constructor_2970, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_2971, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3825, type_3825), Reflex::Literal("pair"), constructor_2972, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_840, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_unsignedslong_unsignedslong__datamem_bld);
}

//------Delayed data member builder for class pair<long unsigned int,long unsigned int> -------------------
void __std__pair_unsignedslong_unsignedslong__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_75, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_unsignedslong_unsignedslong_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_75, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_unsignedslong_unsignedslong_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<long unsigned int,long unsigned int> -------------------
void __std__pair_unsignedslong_unsignedslong__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<long unsigned int,std::vector<long unsigned int, std::allocator<long unsigned int> > > -------------------------------
static void destructor_2977(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<unsigned long,std::vector<unsigned long> >*)o)->::std::pair<unsigned long,std::vector<unsigned long> >::~pair)();
}
static  void operator_2978( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<unsigned long,std::vector<unsigned long> >*)o)->operator=)(*(const ::std::pair<unsigned long,std::vector<unsigned long> >*)arg[0]);
  else   (((::std::pair<unsigned long,std::vector<unsigned long> >*)o)->operator=)(*(const ::std::pair<unsigned long,std::vector<unsigned long> >*)arg[0]);
}

static void constructor_2979( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned long,std::vector<unsigned long> >(*(const ::std::pair<unsigned long,std::vector<unsigned long> >*)arg[0]);
  else ::new(mem) ::std::pair<unsigned long,std::vector<unsigned long> >(*(const ::std::pair<unsigned long,std::vector<unsigned long> >*)arg[0]);
}

static void constructor_2980( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned long,std::vector<unsigned long> >();
  else ::new(mem) ::std::pair<unsigned long,std::vector<unsigned long> >();
}

static void constructor_2981( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned long,std::vector<unsigned long> >(*(const unsigned long*)arg[0],
      *(const ::std::vector<unsigned long>*)arg[1]);
  else ::new(mem) ::std::pair<unsigned long,std::vector<unsigned long> >(*(const unsigned long*)arg[0],
      *(const ::std::vector<unsigned long>*)arg[1]);
}

static void method_newdel_841( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned long,std::vector<unsigned long> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned long,std::vector<unsigned long> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned long,std::vector<unsigned long> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned long,std::vector<unsigned long> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned long,std::vector<unsigned long> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<long unsigned int,std::vector<long unsigned int, std::allocator<long unsigned int> > > -------------------------------
void __std__pair_unsignedslong_std__vector_unsignedslong_s__db_datamem(Reflex::Class*);
void __std__pair_unsignedslong_std__vector_unsignedslong_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_unsignedslong_std__vector_unsignedslong_s__datamem_bld(&__std__pair_unsignedslong_std__vector_unsignedslong_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_unsignedslong_std__vector_unsignedslong_s__funcmem_bld(&__std__pair_unsignedslong_std__vector_unsignedslong_s__db_funcmem);
void __std__pair_unsignedslong_std__vector_unsignedslong_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<unsigned long,std::vector<unsigned long> >"), typeid(::std::pair<unsigned long,std::vector<unsigned long> >), sizeof(::std::pair<unsigned long,std::vector<unsigned long> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_75, Reflex::Literal("std::pair<unsigned long,std::vector<unsigned long> >::first_type"))
  .AddTypedef(type_1052, Reflex::Literal("std::pair<unsigned long,std::vector<unsigned long> >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_2977, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20185, type_20186), Reflex::Literal("operator="), operator_2978, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20186), Reflex::Literal("pair"), constructor_2979, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_2980, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3825, type_20187), Reflex::Literal("pair"), constructor_2981, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_841, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_unsignedslong_std__vector_unsignedslong_s__datamem_bld);
}

//------Delayed data member builder for class pair<long unsigned int,std::vector<long unsigned int, std::allocator<long unsigned int> > > -------------------
void __std__pair_unsignedslong_std__vector_unsignedslong_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_75, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_unsignedslong_std__vector_unsignedslong_s_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_1052, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_unsignedslong_std__vector_unsignedslong_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<long unsigned int,std::vector<long unsigned int, std::allocator<long unsigned int> > > -------------------
void __std__pair_unsignedslong_std__vector_unsignedslong_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<unsigned int,long unsigned int> -------------------------------
static void destructor_2986(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<unsigned int,unsigned long>*)o)->::std::pair<unsigned int,unsigned long>::~pair)();
}
static  void operator_2987( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<unsigned int,unsigned long>*)o)->operator=)(*(const ::std::pair<unsigned int,unsigned long>*)arg[0]);
  else   (((::std::pair<unsigned int,unsigned long>*)o)->operator=)(*(const ::std::pair<unsigned int,unsigned long>*)arg[0]);
}

static void constructor_2988( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,unsigned long>(*(const ::std::pair<unsigned int,unsigned long>*)arg[0]);
  else ::new(mem) ::std::pair<unsigned int,unsigned long>(*(const ::std::pair<unsigned int,unsigned long>*)arg[0]);
}

static void constructor_2989( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,unsigned long>();
  else ::new(mem) ::std::pair<unsigned int,unsigned long>();
}

static void constructor_2990( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,unsigned long>(*(const unsigned int*)arg[0],
      *(const unsigned long*)arg[1]);
  else ::new(mem) ::std::pair<unsigned int,unsigned long>(*(const unsigned int*)arg[0],
      *(const unsigned long*)arg[1]);
}

static void method_newdel_842( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,unsigned long> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,unsigned long> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,unsigned long> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,unsigned long> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,unsigned long> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<unsigned int,long unsigned int> -------------------------------
void __std__pair_unsignedsint_unsignedslong__db_datamem(Reflex::Class*);
void __std__pair_unsignedsint_unsignedslong__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_unsignedsint_unsignedslong__datamem_bld(&__std__pair_unsignedsint_unsignedslong__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_unsignedsint_unsignedslong__funcmem_bld(&__std__pair_unsignedsint_unsignedslong__db_funcmem);
void __std__pair_unsignedsint_unsignedslong__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<unsigned int,unsigned long>"), typeid(::std::pair<unsigned int,unsigned long>), sizeof(::std::pair<unsigned int,unsigned long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_78, Reflex::Literal("std::pair<unsigned int,unsigned long>::first_type"))
  .AddTypedef(type_75, Reflex::Literal("std::pair<unsigned int,unsigned long>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_2986, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20188, type_20189), Reflex::Literal("operator="), operator_2987, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20189), Reflex::Literal("pair"), constructor_2988, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_2989, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3951, type_3825), Reflex::Literal("pair"), constructor_2990, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_842, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_unsignedsint_unsignedslong__datamem_bld);
}

//------Delayed data member builder for class pair<unsigned int,long unsigned int> -------------------
void __std__pair_unsignedsint_unsignedslong__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_78, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_unsignedsint_unsignedslong_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_75, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_unsignedsint_unsignedslong_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<unsigned int,long unsigned int> -------------------
void __std__pair_unsignedsint_unsignedslong__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<unsigned int,std::vector<unsigned int, std::allocator<unsigned int> > > -------------------------------
static void destructor_2995(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<unsigned int,std::vector<unsigned int> >*)o)->::std::pair<unsigned int,std::vector<unsigned int> >::~pair)();
}
static  void operator_2996( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<unsigned int,std::vector<unsigned int> >*)o)->operator=)(*(const ::std::pair<unsigned int,std::vector<unsigned int> >*)arg[0]);
  else   (((::std::pair<unsigned int,std::vector<unsigned int> >*)o)->operator=)(*(const ::std::pair<unsigned int,std::vector<unsigned int> >*)arg[0]);
}

static void constructor_2997( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,std::vector<unsigned int> >(*(const ::std::pair<unsigned int,std::vector<unsigned int> >*)arg[0]);
  else ::new(mem) ::std::pair<unsigned int,std::vector<unsigned int> >(*(const ::std::pair<unsigned int,std::vector<unsigned int> >*)arg[0]);
}

static void constructor_2998( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,std::vector<unsigned int> >();
  else ::new(mem) ::std::pair<unsigned int,std::vector<unsigned int> >();
}

static void constructor_2999( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,std::vector<unsigned int> >(*(const unsigned int*)arg[0],
      *(const ::std::vector<unsigned int>*)arg[1]);
  else ::new(mem) ::std::pair<unsigned int,std::vector<unsigned int> >(*(const unsigned int*)arg[0],
      *(const ::std::vector<unsigned int>*)arg[1]);
}

static void method_newdel_843( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,std::vector<unsigned int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,std::vector<unsigned int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,std::vector<unsigned int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,std::vector<unsigned int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,std::vector<unsigned int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<unsigned int,std::vector<unsigned int, std::allocator<unsigned int> > > -------------------------------
void __std__pair_unsignedsint_std__vector_unsignedsint_s__db_datamem(Reflex::Class*);
void __std__pair_unsignedsint_std__vector_unsignedsint_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_unsignedsint_std__vector_unsignedsint_s__datamem_bld(&__std__pair_unsignedsint_std__vector_unsignedsint_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_unsignedsint_std__vector_unsignedsint_s__funcmem_bld(&__std__pair_unsignedsint_std__vector_unsignedsint_s__db_funcmem);
void __std__pair_unsignedsint_std__vector_unsignedsint_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<unsigned int,std::vector<unsigned int> >"), typeid(::std::pair<unsigned int,std::vector<unsigned int> >), sizeof(::std::pair<unsigned int,std::vector<unsigned int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_78, Reflex::Literal("std::pair<unsigned int,std::vector<unsigned int> >::first_type"))
  .AddTypedef(type_1054, Reflex::Literal("std::pair<unsigned int,std::vector<unsigned int> >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_2995, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20190, type_20191), Reflex::Literal("operator="), operator_2996, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20191), Reflex::Literal("pair"), constructor_2997, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_2998, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3951, type_4211), Reflex::Literal("pair"), constructor_2999, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_843, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_unsignedsint_std__vector_unsignedsint_s__datamem_bld);
}

//------Delayed data member builder for class pair<unsigned int,std::vector<unsigned int, std::allocator<unsigned int> > > -------------------
void __std__pair_unsignedsint_std__vector_unsignedsint_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_78, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_unsignedsint_std__vector_unsignedsint_s_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_1054, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_unsignedsint_std__vector_unsignedsint_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<unsigned int,std::vector<unsigned int, std::allocator<unsigned int> > > -------------------
void __std__pair_unsignedsint_std__vector_unsignedsint_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<unsigned int,std::vector<std::pair<unsigned int, double>, std::allocator<std::pair<unsigned int, double> > > > -------------------------------
static void destructor_3004(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->::std::pair<unsigned int,std::vector<std::pair<unsigned int,double> > >::~pair)();
}
static  void operator_3005( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->operator=)(*(const ::std::pair<unsigned int,std::vector<std::pair<unsigned int,double> > >*)arg[0]);
  else   (((::std::pair<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->operator=)(*(const ::std::pair<unsigned int,std::vector<std::pair<unsigned int,double> > >*)arg[0]);
}

static void constructor_3006( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,std::vector<std::pair<unsigned int,double> > >(*(const ::std::pair<unsigned int,std::vector<std::pair<unsigned int,double> > >*)arg[0]);
  else ::new(mem) ::std::pair<unsigned int,std::vector<std::pair<unsigned int,double> > >(*(const ::std::pair<unsigned int,std::vector<std::pair<unsigned int,double> > >*)arg[0]);
}

static void constructor_3007( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,std::vector<std::pair<unsigned int,double> > >();
  else ::new(mem) ::std::pair<unsigned int,std::vector<std::pair<unsigned int,double> > >();
}

static void constructor_3008( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,std::vector<std::pair<unsigned int,double> > >(*(const unsigned int*)arg[0],
      *(const ::std::vector<std::pair<unsigned int,double> >*)arg[1]);
  else ::new(mem) ::std::pair<unsigned int,std::vector<std::pair<unsigned int,double> > >(*(const unsigned int*)arg[0],
      *(const ::std::vector<std::pair<unsigned int,double> >*)arg[1]);
}

static void method_newdel_844( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,std::vector<std::pair<unsigned int,double> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,std::vector<std::pair<unsigned int,double> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,std::vector<std::pair<unsigned int,double> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,std::vector<std::pair<unsigned int,double> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,std::vector<std::pair<unsigned int,double> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<unsigned int,std::vector<std::pair<unsigned int, double>, std::allocator<std::pair<unsigned int, double> > > > -------------------------------
void __std__pair_unsignedsint_std__vector_std__pair_unsignedsint_double_s_s__db_datamem(Reflex::Class*);
void __std__pair_unsignedsint_std__vector_std__pair_unsignedsint_double_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_unsignedsint_std__vector_std__pair_unsignedsint_double_s_s__datamem_bld(&__std__pair_unsignedsint_std__vector_std__pair_unsignedsint_double_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_unsignedsint_std__vector_std__pair_unsignedsint_double_s_s__funcmem_bld(&__std__pair_unsignedsint_std__vector_std__pair_unsignedsint_double_s_s__db_funcmem);
void __std__pair_unsignedsint_std__vector_std__pair_unsignedsint_double_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<unsigned int,std::vector<std::pair<unsigned int,double> > >"), typeid(::std::pair<unsigned int,std::vector<std::pair<unsigned int,double> > >), sizeof(::std::pair<unsigned int,std::vector<std::pair<unsigned int,double> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_78, Reflex::Literal("std::pair<unsigned int,std::vector<std::pair<unsigned int,double> > >::first_type"))
  .AddTypedef(type_1075, Reflex::Literal("std::pair<unsigned int,std::vector<std::pair<unsigned int,double> > >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3004, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20192, type_20193), Reflex::Literal("operator="), operator_3005, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20193), Reflex::Literal("pair"), constructor_3006, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3007, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3951, type_20194), Reflex::Literal("pair"), constructor_3008, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_844, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_unsignedsint_std__vector_std__pair_unsignedsint_double_s_s__datamem_bld);
}

//------Delayed data member builder for class pair<unsigned int,std::vector<std::pair<unsigned int, double>, std::allocator<std::pair<unsigned int, double> > > > -------------------
void __std__pair_unsignedsint_std__vector_std__pair_unsignedsint_double_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_78, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_unsignedsint_std__vector_std__pair_unsignedsint_double_s_s_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_1075, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_unsignedsint_std__vector_std__pair_unsignedsint_double_s_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<unsigned int,std::vector<std::pair<unsigned int, double>, std::allocator<std::pair<unsigned int, double> > > > -------------------
void __std__pair_unsignedsint_std__vector_std__pair_unsignedsint_double_s_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<unsigned int,std::vector<std::pair<unsigned int, bool>, std::allocator<std::pair<unsigned int, bool> > > > -------------------------------
static void destructor_3013(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->::std::pair<unsigned int,std::vector<std::pair<unsigned int,bool> > >::~pair)();
}
static  void operator_3014( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->operator=)(*(const ::std::pair<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)arg[0]);
  else   (((::std::pair<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->operator=)(*(const ::std::pair<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)arg[0]);
}

static void constructor_3015( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,std::vector<std::pair<unsigned int,bool> > >(*(const ::std::pair<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)arg[0]);
  else ::new(mem) ::std::pair<unsigned int,std::vector<std::pair<unsigned int,bool> > >(*(const ::std::pair<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)arg[0]);
}

static void constructor_3016( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,std::vector<std::pair<unsigned int,bool> > >();
  else ::new(mem) ::std::pair<unsigned int,std::vector<std::pair<unsigned int,bool> > >();
}

static void constructor_3017( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,std::vector<std::pair<unsigned int,bool> > >(*(const unsigned int*)arg[0],
      *(const ::std::vector<std::pair<unsigned int,bool> >*)arg[1]);
  else ::new(mem) ::std::pair<unsigned int,std::vector<std::pair<unsigned int,bool> > >(*(const unsigned int*)arg[0],
      *(const ::std::vector<std::pair<unsigned int,bool> >*)arg[1]);
}

static void method_newdel_845( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,std::vector<std::pair<unsigned int,bool> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,std::vector<std::pair<unsigned int,bool> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,std::vector<std::pair<unsigned int,bool> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,std::vector<std::pair<unsigned int,bool> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,std::vector<std::pair<unsigned int,bool> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<unsigned int,std::vector<std::pair<unsigned int, bool>, std::allocator<std::pair<unsigned int, bool> > > > -------------------------------
void __std__pair_unsignedsint_std__vector_std__pair_unsignedsint_bool_s_s__db_datamem(Reflex::Class*);
void __std__pair_unsignedsint_std__vector_std__pair_unsignedsint_bool_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_unsignedsint_std__vector_std__pair_unsignedsint_bool_s_s__datamem_bld(&__std__pair_unsignedsint_std__vector_std__pair_unsignedsint_bool_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_unsignedsint_std__vector_std__pair_unsignedsint_bool_s_s__funcmem_bld(&__std__pair_unsignedsint_std__vector_std__pair_unsignedsint_bool_s_s__db_funcmem);
void __std__pair_unsignedsint_std__vector_std__pair_unsignedsint_bool_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<unsigned int,std::vector<std::pair<unsigned int,bool> > >"), typeid(::std::pair<unsigned int,std::vector<std::pair<unsigned int,bool> > >), sizeof(::std::pair<unsigned int,std::vector<std::pair<unsigned int,bool> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_78, Reflex::Literal("std::pair<unsigned int,std::vector<std::pair<unsigned int,bool> > >::first_type"))
  .AddTypedef(type_1076, Reflex::Literal("std::pair<unsigned int,std::vector<std::pair<unsigned int,bool> > >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3013, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20195, type_20196), Reflex::Literal("operator="), operator_3014, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20196), Reflex::Literal("pair"), constructor_3015, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3016, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3951, type_20197), Reflex::Literal("pair"), constructor_3017, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_845, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_unsignedsint_std__vector_std__pair_unsignedsint_bool_s_s__datamem_bld);
}

//------Delayed data member builder for class pair<unsigned int,std::vector<std::pair<unsigned int, bool>, std::allocator<std::pair<unsigned int, bool> > > > -------------------
void __std__pair_unsignedsint_std__vector_std__pair_unsignedsint_bool_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_78, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_unsignedsint_std__vector_std__pair_unsignedsint_bool_s_s_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_1076, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_unsignedsint_std__vector_std__pair_unsignedsint_bool_s_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<unsigned int,std::vector<std::pair<unsigned int, bool>, std::allocator<std::pair<unsigned int, bool> > > > -------------------
void __std__pair_unsignedsint_std__vector_std__pair_unsignedsint_bool_s_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<unsigned int,std::pair<unsigned int, unsigned int> > -------------------------------
static void destructor_3022(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->::std::pair<unsigned int,std::pair<unsigned int,unsigned int> >::~pair)();
}
static  void operator_3023( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->operator=)(*(const ::std::pair<unsigned int,std::pair<unsigned int,unsigned int> >*)arg[0]);
  else   (((::std::pair<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->operator=)(*(const ::std::pair<unsigned int,std::pair<unsigned int,unsigned int> >*)arg[0]);
}

static void constructor_3024( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,std::pair<unsigned int,unsigned int> >(*(const ::std::pair<unsigned int,std::pair<unsigned int,unsigned int> >*)arg[0]);
  else ::new(mem) ::std::pair<unsigned int,std::pair<unsigned int,unsigned int> >(*(const ::std::pair<unsigned int,std::pair<unsigned int,unsigned int> >*)arg[0]);
}

static void constructor_3025( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,std::pair<unsigned int,unsigned int> >();
  else ::new(mem) ::std::pair<unsigned int,std::pair<unsigned int,unsigned int> >();
}

static void constructor_3026( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,std::pair<unsigned int,unsigned int> >(*(const unsigned int*)arg[0],
      *(const ::std::pair<unsigned int,unsigned int>*)arg[1]);
  else ::new(mem) ::std::pair<unsigned int,std::pair<unsigned int,unsigned int> >(*(const unsigned int*)arg[0],
      *(const ::std::pair<unsigned int,unsigned int>*)arg[1]);
}

static void method_newdel_846( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,std::pair<unsigned int,unsigned int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,std::pair<unsigned int,unsigned int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,std::pair<unsigned int,unsigned int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,std::pair<unsigned int,unsigned int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,std::pair<unsigned int,unsigned int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<unsigned int,std::pair<unsigned int, unsigned int> > -------------------------------
void __std__pair_unsignedsint_std__pair_unsignedsint_unsignedsint_s__db_datamem(Reflex::Class*);
void __std__pair_unsignedsint_std__pair_unsignedsint_unsignedsint_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_unsignedsint_std__pair_unsignedsint_unsignedsint_s__datamem_bld(&__std__pair_unsignedsint_std__pair_unsignedsint_unsignedsint_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_unsignedsint_std__pair_unsignedsint_unsignedsint_s__funcmem_bld(&__std__pair_unsignedsint_std__pair_unsignedsint_unsignedsint_s__db_funcmem);
void __std__pair_unsignedsint_std__pair_unsignedsint_unsignedsint_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<unsigned int,std::pair<unsigned int,unsigned int> >"), typeid(::std::pair<unsigned int,std::pair<unsigned int,unsigned int> >), sizeof(::std::pair<unsigned int,std::pair<unsigned int,unsigned int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_78, Reflex::Literal("std::pair<unsigned int,std::pair<unsigned int,unsigned int> >::first_type"))
  .AddTypedef(type_814, Reflex::Literal("std::pair<unsigned int,std::pair<unsigned int,unsigned int> >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3022, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20198, type_20199), Reflex::Literal("operator="), operator_3023, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20199), Reflex::Literal("pair"), constructor_3024, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3025, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3951, type_5111), Reflex::Literal("pair"), constructor_3026, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_846, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_unsignedsint_std__pair_unsignedsint_unsignedsint_s__datamem_bld);
}

//------Delayed data member builder for class pair<unsigned int,std::pair<unsigned int, unsigned int> > -------------------
void __std__pair_unsignedsint_std__pair_unsignedsint_unsignedsint_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_78, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_unsignedsint_std__pair_unsignedsint_unsignedsint_s_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_814, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_unsignedsint_std__pair_unsignedsint_unsignedsint_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<unsigned int,std::pair<unsigned int, unsigned int> > -------------------
void __std__pair_unsignedsint_std__pair_unsignedsint_unsignedsint_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<unsigned int,std::basic_string<char, std::char_traits<char>, std::allocator<char> > > -------------------------------
static void destructor_3031(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<unsigned int,std::basic_string<char> >*)o)->::std::pair<unsigned int,std::basic_string<char> >::~pair)();
}
static  void operator_3032( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<unsigned int,std::basic_string<char> >*)o)->operator=)(*(const ::std::pair<unsigned int,std::basic_string<char> >*)arg[0]);
  else   (((::std::pair<unsigned int,std::basic_string<char> >*)o)->operator=)(*(const ::std::pair<unsigned int,std::basic_string<char> >*)arg[0]);
}

static void constructor_3033( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,std::basic_string<char> >(*(const ::std::pair<unsigned int,std::basic_string<char> >*)arg[0]);
  else ::new(mem) ::std::pair<unsigned int,std::basic_string<char> >(*(const ::std::pair<unsigned int,std::basic_string<char> >*)arg[0]);
}

static void constructor_3034( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,std::basic_string<char> >();
  else ::new(mem) ::std::pair<unsigned int,std::basic_string<char> >();
}

static void constructor_3035( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,std::basic_string<char> >(*(const unsigned int*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
  else ::new(mem) ::std::pair<unsigned int,std::basic_string<char> >(*(const unsigned int*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
}

static void method_newdel_847( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,std::basic_string<char> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,std::basic_string<char> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,std::basic_string<char> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,std::basic_string<char> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,std::basic_string<char> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<unsigned int,std::basic_string<char, std::char_traits<char>, std::allocator<char> > > -------------------------------
void __std__pair_unsignedsint_std__basic_string_char_s__db_datamem(Reflex::Class*);
void __std__pair_unsignedsint_std__basic_string_char_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_unsignedsint_std__basic_string_char_s__datamem_bld(&__std__pair_unsignedsint_std__basic_string_char_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_unsignedsint_std__basic_string_char_s__funcmem_bld(&__std__pair_unsignedsint_std__basic_string_char_s__db_funcmem);
void __std__pair_unsignedsint_std__basic_string_char_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<unsigned int,std::basic_string<char> >"), typeid(::std::pair<unsigned int,std::basic_string<char> >), sizeof(::std::pair<unsigned int,std::basic_string<char> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_78, Reflex::Literal("std::pair<unsigned int,std::basic_string<char> >::first_type"))
  .AddTypedef(type_1104, Reflex::Literal("std::pair<unsigned int,std::basic_string<char> >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3031, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20200, type_20201), Reflex::Literal("operator="), operator_3032, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20201), Reflex::Literal("pair"), constructor_3033, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3034, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3951, type_4981), Reflex::Literal("pair"), constructor_3035, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_847, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_unsignedsint_std__basic_string_char_s__datamem_bld);
}

//------Delayed data member builder for class pair<unsigned int,std::basic_string<char, std::char_traits<char>, std::allocator<char> > > -------------------
void __std__pair_unsignedsint_std__basic_string_char_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_78, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_unsignedsint_std__basic_string_char_s_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_1104, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_unsignedsint_std__basic_string_char_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<unsigned int,std::basic_string<char, std::char_traits<char>, std::allocator<char> > > -------------------
void __std__pair_unsignedsint_std__basic_string_char_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<unsigned int,short int> -------------------------------
static void destructor_3040(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<unsigned int,short>*)o)->::std::pair<unsigned int,short>::~pair)();
}
static  void operator_3041( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<unsigned int,short>*)o)->operator=)(*(const ::std::pair<unsigned int,short>*)arg[0]);
  else   (((::std::pair<unsigned int,short>*)o)->operator=)(*(const ::std::pair<unsigned int,short>*)arg[0]);
}

static void constructor_3042( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,short>(*(const ::std::pair<unsigned int,short>*)arg[0]);
  else ::new(mem) ::std::pair<unsigned int,short>(*(const ::std::pair<unsigned int,short>*)arg[0]);
}

static void constructor_3043( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,short>();
  else ::new(mem) ::std::pair<unsigned int,short>();
}

static void constructor_3044( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<unsigned int,short>(*(const unsigned int*)arg[0],
      *(const short*)arg[1]);
  else ::new(mem) ::std::pair<unsigned int,short>(*(const unsigned int*)arg[0],
      *(const short*)arg[1]);
}

static void method_newdel_848( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,short> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,short> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,short> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,short> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<unsigned int,short> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<unsigned int,short int> -------------------------------
void __std__pair_unsignedsint_short__db_datamem(Reflex::Class*);
void __std__pair_unsignedsint_short__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_unsignedsint_short__datamem_bld(&__std__pair_unsignedsint_short__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_unsignedsint_short__funcmem_bld(&__std__pair_unsignedsint_short__db_funcmem);
void __std__pair_unsignedsint_short__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<unsigned int,short>"), typeid(::std::pair<unsigned int,short>), sizeof(::std::pair<unsigned int,short>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_78, Reflex::Literal("std::pair<unsigned int,short>::first_type"))
  .AddTypedef(type_113, Reflex::Literal("std::pair<unsigned int,short>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3040, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20202, type_20203), Reflex::Literal("operator="), operator_3041, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20203), Reflex::Literal("pair"), constructor_3042, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3043, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3951, type_4662), Reflex::Literal("pair"), constructor_3044, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_848, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_unsignedsint_short__datamem_bld);
}

//------Delayed data member builder for class pair<unsigned int,short int> -------------------
void __std__pair_unsignedsint_short__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_78, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_unsignedsint_short_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_113, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_unsignedsint_short_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<unsigned int,short int> -------------------
void __std__pair_unsignedsint_short__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<std::pair<short int, short int>,std::pair<short int, std::vector<short int, std::allocator<short int> > > > -------------------------------
static void destructor_3049(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->::std::pair<std::pair<short,short>,std::pair<short,std::vector<short> > >::~pair)();
}
static  void operator_3050( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->operator=)(*(const ::std::pair<std::pair<short,short>,std::pair<short,std::vector<short> > >*)arg[0]);
  else   (((::std::pair<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->operator=)(*(const ::std::pair<std::pair<short,short>,std::pair<short,std::vector<short> > >*)arg[0]);
}

static void constructor_3051( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::pair<short,short>,std::pair<short,std::vector<short> > >(*(const ::std::pair<std::pair<short,short>,std::pair<short,std::vector<short> > >*)arg[0]);
  else ::new(mem) ::std::pair<std::pair<short,short>,std::pair<short,std::vector<short> > >(*(const ::std::pair<std::pair<short,short>,std::pair<short,std::vector<short> > >*)arg[0]);
}

static void constructor_3052( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::pair<short,short>,std::pair<short,std::vector<short> > >();
  else ::new(mem) ::std::pair<std::pair<short,short>,std::pair<short,std::vector<short> > >();
}

static void constructor_3053( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::pair<short,short>,std::pair<short,std::vector<short> > >(*(const ::std::pair<short,short>*)arg[0],
      *(const ::std::pair<short,std::vector<short> >*)arg[1]);
  else ::new(mem) ::std::pair<std::pair<short,short>,std::pair<short,std::vector<short> > >(*(const ::std::pair<short,short>*)arg[0],
      *(const ::std::pair<short,std::vector<short> >*)arg[1]);
}

static void method_newdel_849( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<std::pair<short,short>,std::pair<short,std::vector<short> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<std::pair<short,short>,std::pair<short,std::vector<short> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<std::pair<short,short>,std::pair<short,std::vector<short> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<std::pair<short,short>,std::pair<short,std::vector<short> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<std::pair<short,short>,std::pair<short,std::vector<short> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<std::pair<short int, short int>,std::pair<short int, std::vector<short int, std::allocator<short int> > > > -------------------------------
void __std__pair_std__pair_short_short__std__pair_short_std__vector_short_s_s__db_datamem(Reflex::Class*);
void __std__pair_std__pair_short_short__std__pair_short_std__vector_short_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_std__pair_short_short__std__pair_short_std__vector_short_s_s__datamem_bld(&__std__pair_std__pair_short_short__std__pair_short_std__vector_short_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_std__pair_short_short__std__pair_short_std__vector_short_s_s__funcmem_bld(&__std__pair_std__pair_short_short__std__pair_short_std__vector_short_s_s__db_funcmem);
void __std__pair_std__pair_short_short__std__pair_short_std__vector_short_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<std::pair<short,short>,std::pair<short,std::vector<short> > >"), typeid(::std::pair<std::pair<short,short>,std::pair<short,std::vector<short> > >), sizeof(::std::pair<std::pair<short,short>,std::pair<short,std::vector<short> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_851, Reflex::Literal("std::pair<std::pair<short,short>,std::pair<short,std::vector<short> > >::first_type"))
  .AddTypedef(type_850, Reflex::Literal("std::pair<std::pair<short,short>,std::pair<short,std::vector<short> > >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3049, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20204, type_20205), Reflex::Literal("operator="), operator_3050, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20205), Reflex::Literal("pair"), constructor_3051, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3052, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20206, type_20207), Reflex::Literal("pair"), constructor_3053, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_849, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_std__pair_short_short__std__pair_short_std__vector_short_s_s__datamem_bld);
}

//------Delayed data member builder for class pair<std::pair<short int, short int>,std::pair<short int, std::vector<short int, std::allocator<short int> > > > -------------------
void __std__pair_std__pair_short_short__std__pair_short_std__vector_short_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_851, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_std__pair_short_short__std__pair_short_std__vector_short_s_s_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_850, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_std__pair_short_short__std__pair_short_std__vector_short_s_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<std::pair<short int, short int>,std::pair<short int, std::vector<short int, std::allocator<short int> > > > -------------------
void __std__pair_std__pair_short_short__std__pair_short_std__vector_short_s_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<short int,std::vector<short int, std::allocator<short int> > > -------------------------------
static void destructor_3058(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<short,std::vector<short> >*)o)->::std::pair<short,std::vector<short> >::~pair)();
}
static  void operator_3059( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<short,std::vector<short> >*)o)->operator=)(*(const ::std::pair<short,std::vector<short> >*)arg[0]);
  else   (((::std::pair<short,std::vector<short> >*)o)->operator=)(*(const ::std::pair<short,std::vector<short> >*)arg[0]);
}

static void constructor_3060( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<short,std::vector<short> >(*(const ::std::pair<short,std::vector<short> >*)arg[0]);
  else ::new(mem) ::std::pair<short,std::vector<short> >(*(const ::std::pair<short,std::vector<short> >*)arg[0]);
}

static void constructor_3061( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<short,std::vector<short> >();
  else ::new(mem) ::std::pair<short,std::vector<short> >();
}

static void constructor_3062( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<short,std::vector<short> >(*(const short*)arg[0],
      *(const ::std::vector<short>*)arg[1]);
  else ::new(mem) ::std::pair<short,std::vector<short> >(*(const short*)arg[0],
      *(const ::std::vector<short>*)arg[1]);
}

static void method_newdel_850( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<short,std::vector<short> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<short,std::vector<short> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<short,std::vector<short> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<short,std::vector<short> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<short,std::vector<short> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<short int,std::vector<short int, std::allocator<short int> > > -------------------------------
void __std__pair_short_std__vector_short_s__db_datamem(Reflex::Class*);
void __std__pair_short_std__vector_short_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_short_std__vector_short_s__datamem_bld(&__std__pair_short_std__vector_short_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_short_std__vector_short_s__funcmem_bld(&__std__pair_short_std__vector_short_s__db_funcmem);
void __std__pair_short_std__vector_short_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<short,std::vector<short> >"), typeid(::std::pair<short,std::vector<short> >), sizeof(::std::pair<short,std::vector<short> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_113, Reflex::Literal("std::pair<short,std::vector<short> >::first_type"))
  .AddTypedef(type_1065, Reflex::Literal("std::pair<short,std::vector<short> >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3058, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20208, type_20207), Reflex::Literal("operator="), operator_3059, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20207), Reflex::Literal("pair"), constructor_3060, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3061, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4662, type_4599), Reflex::Literal("pair"), constructor_3062, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_850, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_short_std__vector_short_s__datamem_bld);
}

//------Delayed data member builder for class pair<short int,std::vector<short int, std::allocator<short int> > > -------------------
void __std__pair_short_std__vector_short_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_113, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_short_std__vector_short_s_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_1065, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_short_std__vector_short_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<short int,std::vector<short int, std::allocator<short int> > > -------------------
void __std__pair_short_std__vector_short_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<short int,short int> -------------------------------
static void destructor_3067(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<short,short>*)o)->::std::pair<short,short>::~pair)();
}
static  void operator_3068( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<short,short>*)o)->operator=)(*(const ::std::pair<short,short>*)arg[0]);
  else   (((::std::pair<short,short>*)o)->operator=)(*(const ::std::pair<short,short>*)arg[0]);
}

static void constructor_3069( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<short,short>(*(const ::std::pair<short,short>*)arg[0]);
  else ::new(mem) ::std::pair<short,short>(*(const ::std::pair<short,short>*)arg[0]);
}

static void constructor_3070( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<short,short>();
  else ::new(mem) ::std::pair<short,short>();
}

static void constructor_3071( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<short,short>(*(const short*)arg[0],
      *(const short*)arg[1]);
  else ::new(mem) ::std::pair<short,short>(*(const short*)arg[0],
      *(const short*)arg[1]);
}

static void method_newdel_851( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<short,short> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<short,short> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<short,short> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<short,short> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<short,short> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<short int,short int> -------------------------------
void __std__pair_short_short__db_datamem(Reflex::Class*);
void __std__pair_short_short__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_short_short__datamem_bld(&__std__pair_short_short__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_short_short__funcmem_bld(&__std__pair_short_short__db_funcmem);
void __std__pair_short_short__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<short,short>"), typeid(::std::pair<short,short>), sizeof(::std::pair<short,short>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_113, Reflex::Literal("std::pair<short,short>::first_type"))
  .AddTypedef(type_113, Reflex::Literal("std::pair<short,short>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3067, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20209, type_20206), Reflex::Literal("operator="), operator_3068, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20206), Reflex::Literal("pair"), constructor_3069, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3070, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4662, type_4662), Reflex::Literal("pair"), constructor_3071, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_851, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_short_short__datamem_bld);
}

//------Delayed data member builder for class pair<short int,short int> -------------------
void __std__pair_short_short__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_113, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_short_short_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_113, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_short_short_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<short int,short int> -------------------
void __std__pair_short_short__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<std::pair<int, int>,int> -------------------------------
static void destructor_3076(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<std::pair<int,int>,int>*)o)->::std::pair<std::pair<int,int>,int>::~pair)();
}
static  void operator_3077( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<std::pair<int,int>,int>*)o)->operator=)(*(const ::std::pair<std::pair<int,int>,int>*)arg[0]);
  else   (((::std::pair<std::pair<int,int>,int>*)o)->operator=)(*(const ::std::pair<std::pair<int,int>,int>*)arg[0]);
}

static void constructor_3078( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::pair<int,int>,int>(*(const ::std::pair<std::pair<int,int>,int>*)arg[0]);
  else ::new(mem) ::std::pair<std::pair<int,int>,int>(*(const ::std::pair<std::pair<int,int>,int>*)arg[0]);
}

static void constructor_3079( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::pair<int,int>,int>();
  else ::new(mem) ::std::pair<std::pair<int,int>,int>();
}

static void constructor_3080( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::pair<int,int>,int>(*(const ::std::pair<int,int>*)arg[0],
      *(const int*)arg[1]);
  else ::new(mem) ::std::pair<std::pair<int,int>,int>(*(const ::std::pair<int,int>*)arg[0],
      *(const int*)arg[1]);
}

static void method_newdel_852( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<std::pair<int,int>,int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<std::pair<int,int>,int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<std::pair<int,int>,int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<std::pair<int,int>,int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<std::pair<int,int>,int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<std::pair<int, int>,int> -------------------------------
void __std__pair_std__pair_int_int__int__db_datamem(Reflex::Class*);
void __std__pair_std__pair_int_int__int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_std__pair_int_int__int__datamem_bld(&__std__pair_std__pair_int_int__int__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_std__pair_int_int__int__funcmem_bld(&__std__pair_std__pair_int_int__int__db_funcmem);
void __std__pair_std__pair_int_int__int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<std::pair<int,int>,int>"), typeid(::std::pair<std::pair<int,int>,int>), sizeof(::std::pair<std::pair<int,int>,int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_825, Reflex::Literal("std::pair<std::pair<int,int>,int>::first_type"))
  .AddTypedef(type_22, Reflex::Literal("std::pair<std::pair<int,int>,int>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3076, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20210, type_20211), Reflex::Literal("operator="), operator_3077, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20211), Reflex::Literal("pair"), constructor_3078, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3079, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5826, type_4404), Reflex::Literal("pair"), constructor_3080, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_852, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_std__pair_int_int__int__datamem_bld);
}

//------Delayed data member builder for class pair<std::pair<int, int>,int> -------------------
void __std__pair_std__pair_int_int__int__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_825, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_std__pair_int_int__int_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_22, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_std__pair_int_int__int_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<std::pair<int, int>,int> -------------------
void __std__pair_std__pair_int_int__int__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,unsigned int> -------------------------------
static void destructor_3085(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<std::basic_string<char>,unsigned int>*)o)->::std::pair<std::basic_string<char>,unsigned int>::~pair)();
}
static  void operator_3086( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<std::basic_string<char>,unsigned int>*)o)->operator=)(*(const ::std::pair<std::basic_string<char>,unsigned int>*)arg[0]);
  else   (((::std::pair<std::basic_string<char>,unsigned int>*)o)->operator=)(*(const ::std::pair<std::basic_string<char>,unsigned int>*)arg[0]);
}

static void constructor_3087( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,unsigned int>(*(const ::std::pair<std::basic_string<char>,unsigned int>*)arg[0]);
  else ::new(mem) ::std::pair<std::basic_string<char>,unsigned int>(*(const ::std::pair<std::basic_string<char>,unsigned int>*)arg[0]);
}

static void constructor_3088( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,unsigned int>();
  else ::new(mem) ::std::pair<std::basic_string<char>,unsigned int>();
}

static void constructor_3089( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,unsigned int>(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::std::pair<std::basic_string<char>,unsigned int>(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_853( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,unsigned int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,unsigned int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,unsigned int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,unsigned int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,unsigned int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,unsigned int> -------------------------------
void __std__pair_std__basic_string_char__unsignedsint__db_datamem(Reflex::Class*);
void __std__pair_std__basic_string_char__unsignedsint__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_std__basic_string_char__unsignedsint__datamem_bld(&__std__pair_std__basic_string_char__unsignedsint__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_std__basic_string_char__unsignedsint__funcmem_bld(&__std__pair_std__basic_string_char__unsignedsint__db_funcmem);
void __std__pair_std__basic_string_char__unsignedsint__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<std::basic_string<char>,unsigned int>"), typeid(::std::pair<std::basic_string<char>,unsigned int>), sizeof(::std::pair<std::basic_string<char>,unsigned int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_1104, Reflex::Literal("std::pair<std::basic_string<char>,unsigned int>::first_type"))
  .AddTypedef(type_78, Reflex::Literal("std::pair<std::basic_string<char>,unsigned int>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3085, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20212, type_20213), Reflex::Literal("operator="), operator_3086, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20213), Reflex::Literal("pair"), constructor_3087, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3088, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4981, type_3951), Reflex::Literal("pair"), constructor_3089, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_853, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_std__basic_string_char__unsignedsint__datamem_bld);
}

//------Delayed data member builder for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,unsigned int> -------------------
void __std__pair_std__basic_string_char__unsignedsint__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1104, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_std__basic_string_char__unsignedsint_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_78, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_std__basic_string_char__unsignedsint_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,unsigned int> -------------------
void __std__pair_std__basic_string_char__unsignedsint__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, double>, std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, double> > > > -------------------------------
static void destructor_3094(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->::std::pair<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >::~pair)();
}
static  void operator_3095( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->operator=)(*(const ::std::pair<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)arg[0]);
  else   (((::std::pair<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->operator=)(*(const ::std::pair<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)arg[0]);
}

static void constructor_3096( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >(*(const ::std::pair<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)arg[0]);
  else ::new(mem) ::std::pair<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >(*(const ::std::pair<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)arg[0]);
}

static void constructor_3097( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >();
  else ::new(mem) ::std::pair<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >();
}

static void constructor_3098( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >(*(const ::std::basic_string<char>*)arg[0],
      *(const ::std::vector<std::pair<std::basic_string<char>,double> >*)arg[1]);
  else ::new(mem) ::std::pair<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >(*(const ::std::basic_string<char>*)arg[0],
      *(const ::std::vector<std::pair<std::basic_string<char>,double> >*)arg[1]);
}

static void method_newdel_854( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, double>, std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, double> > > > -------------------------------
void __std__pair_std__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s__db_datamem(Reflex::Class*);
void __std__pair_std__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_std__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s__datamem_bld(&__std__pair_std__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_std__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s__funcmem_bld(&__std__pair_std__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s__db_funcmem);
void __std__pair_std__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >"), typeid(::std::pair<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >), sizeof(::std::pair<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_1104, Reflex::Literal("std::pair<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >::first_type"))
  .AddTypedef(type_1081, Reflex::Literal("std::pair<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3094, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20214, type_20215), Reflex::Literal("operator="), operator_3095, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20215), Reflex::Literal("pair"), constructor_3096, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3097, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4981, type_20216), Reflex::Literal("pair"), constructor_3098, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_854, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_std__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s__datamem_bld);
}

//------Delayed data member builder for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, double>, std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, double> > > > -------------------
void __std__pair_std__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1104, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_std__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_1081, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_std__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, double>, std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, double> > > > -------------------
void __std__pair_std__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------------------
static void destructor_3103(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->::std::pair<std::basic_string<char>,std::vector<std::basic_string<char> > >::~pair)();
}
static  void operator_3104( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->operator=)(*(const ::std::pair<std::basic_string<char>,std::vector<std::basic_string<char> > >*)arg[0]);
  else   (((::std::pair<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->operator=)(*(const ::std::pair<std::basic_string<char>,std::vector<std::basic_string<char> > >*)arg[0]);
}

static void constructor_3105( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,std::vector<std::basic_string<char> > >(*(const ::std::pair<std::basic_string<char>,std::vector<std::basic_string<char> > >*)arg[0]);
  else ::new(mem) ::std::pair<std::basic_string<char>,std::vector<std::basic_string<char> > >(*(const ::std::pair<std::basic_string<char>,std::vector<std::basic_string<char> > >*)arg[0]);
}

static void constructor_3106( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,std::vector<std::basic_string<char> > >();
  else ::new(mem) ::std::pair<std::basic_string<char>,std::vector<std::basic_string<char> > >();
}

static void constructor_3107( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,std::vector<std::basic_string<char> > >(*(const ::std::basic_string<char>*)arg[0],
      *(const ::std::vector<std::basic_string<char> >*)arg[1]);
  else ::new(mem) ::std::pair<std::basic_string<char>,std::vector<std::basic_string<char> > >(*(const ::std::basic_string<char>*)arg[0],
      *(const ::std::vector<std::basic_string<char> >*)arg[1]);
}

static void method_newdel_855( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,std::vector<std::basic_string<char> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,std::vector<std::basic_string<char> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,std::vector<std::basic_string<char> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,std::vector<std::basic_string<char> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,std::vector<std::basic_string<char> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------------------
void __std__pair_std__basic_string_char__std__vector_std__basic_string_char_s_s__db_datamem(Reflex::Class*);
void __std__pair_std__basic_string_char__std__vector_std__basic_string_char_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_std__basic_string_char__std__vector_std__basic_string_char_s_s__datamem_bld(&__std__pair_std__basic_string_char__std__vector_std__basic_string_char_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_std__basic_string_char__std__vector_std__basic_string_char_s_s__funcmem_bld(&__std__pair_std__basic_string_char__std__vector_std__basic_string_char_s_s__db_funcmem);
void __std__pair_std__basic_string_char__std__vector_std__basic_string_char_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<std::basic_string<char>,std::vector<std::basic_string<char> > >"), typeid(::std::pair<std::basic_string<char>,std::vector<std::basic_string<char> > >), sizeof(::std::pair<std::basic_string<char>,std::vector<std::basic_string<char> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_1104, Reflex::Literal("std::pair<std::basic_string<char>,std::vector<std::basic_string<char> > >::first_type"))
  .AddTypedef(type_1070, Reflex::Literal("std::pair<std::basic_string<char>,std::vector<std::basic_string<char> > >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3103, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20217, type_20218), Reflex::Literal("operator="), operator_3104, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20218), Reflex::Literal("pair"), constructor_3105, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3106, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4981, type_20219), Reflex::Literal("pair"), constructor_3107, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_855, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_std__basic_string_char__std__vector_std__basic_string_char_s_s__datamem_bld);
}

//------Delayed data member builder for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------
void __std__pair_std__basic_string_char__std__vector_std__basic_string_char_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1104, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_std__basic_string_char__std__vector_std__basic_string_char_s_s_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_1070, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_std__basic_string_char__std__vector_std__basic_string_char_s_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------
void __std__pair_std__basic_string_char__std__vector_std__basic_string_char_s_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::pair<unsigned int, unsigned int> > -------------------------------
static void destructor_3112(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->::std::pair<std::basic_string<char>,std::pair<unsigned int,unsigned int> >::~pair)();
}
static  void operator_3113( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->operator=)(*(const ::std::pair<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)arg[0]);
  else   (((::std::pair<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->operator=)(*(const ::std::pair<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)arg[0]);
}

static void constructor_3114( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,std::pair<unsigned int,unsigned int> >(*(const ::std::pair<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)arg[0]);
  else ::new(mem) ::std::pair<std::basic_string<char>,std::pair<unsigned int,unsigned int> >(*(const ::std::pair<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)arg[0]);
}

static void constructor_3115( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,std::pair<unsigned int,unsigned int> >();
  else ::new(mem) ::std::pair<std::basic_string<char>,std::pair<unsigned int,unsigned int> >();
}

static void constructor_3116( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,std::pair<unsigned int,unsigned int> >(*(const ::std::basic_string<char>*)arg[0],
      *(const ::std::pair<unsigned int,unsigned int>*)arg[1]);
  else ::new(mem) ::std::pair<std::basic_string<char>,std::pair<unsigned int,unsigned int> >(*(const ::std::basic_string<char>*)arg[0],
      *(const ::std::pair<unsigned int,unsigned int>*)arg[1]);
}

static void method_newdel_856( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,std::pair<unsigned int,unsigned int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,std::pair<unsigned int,unsigned int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,std::pair<unsigned int,unsigned int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,std::pair<unsigned int,unsigned int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,std::pair<unsigned int,unsigned int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::pair<unsigned int, unsigned int> > -------------------------------
void __std__pair_std__basic_string_char__std__pair_unsignedsint_unsignedsint_s__db_datamem(Reflex::Class*);
void __std__pair_std__basic_string_char__std__pair_unsignedsint_unsignedsint_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_std__basic_string_char__std__pair_unsignedsint_unsignedsint_s__datamem_bld(&__std__pair_std__basic_string_char__std__pair_unsignedsint_unsignedsint_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_std__basic_string_char__std__pair_unsignedsint_unsignedsint_s__funcmem_bld(&__std__pair_std__basic_string_char__std__pair_unsignedsint_unsignedsint_s__db_funcmem);
void __std__pair_std__basic_string_char__std__pair_unsignedsint_unsignedsint_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<std::basic_string<char>,std::pair<unsigned int,unsigned int> >"), typeid(::std::pair<std::basic_string<char>,std::pair<unsigned int,unsigned int> >), sizeof(::std::pair<std::basic_string<char>,std::pair<unsigned int,unsigned int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_1104, Reflex::Literal("std::pair<std::basic_string<char>,std::pair<unsigned int,unsigned int> >::first_type"))
  .AddTypedef(type_814, Reflex::Literal("std::pair<std::basic_string<char>,std::pair<unsigned int,unsigned int> >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3112, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20220, type_20221), Reflex::Literal("operator="), operator_3113, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20221), Reflex::Literal("pair"), constructor_3114, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3115, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4981, type_5111), Reflex::Literal("pair"), constructor_3116, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_856, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_std__basic_string_char__std__pair_unsignedsint_unsignedsint_s__datamem_bld);
}

//------Delayed data member builder for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::pair<unsigned int, unsigned int> > -------------------
void __std__pair_std__basic_string_char__std__pair_unsignedsint_unsignedsint_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1104, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_std__basic_string_char__std__pair_unsignedsint_unsignedsint_s_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_814, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_std__basic_string_char__std__pair_unsignedsint_unsignedsint_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::pair<unsigned int, unsigned int> > -------------------
void __std__pair_std__basic_string_char__std__pair_unsignedsint_unsignedsint_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > > -------------------------------
static void destructor_3121(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->::std::pair<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >::~pair)();
}
static  void operator_3122( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->operator=)(*(const ::std::pair<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)arg[0]);
  else   (((::std::pair<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->operator=)(*(const ::std::pair<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)arg[0]);
}

static void constructor_3123( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >(*(const ::std::pair<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)arg[0]);
  else ::new(mem) ::std::pair<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >(*(const ::std::pair<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)arg[0]);
}

static void constructor_3124( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >();
  else ::new(mem) ::std::pair<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >();
}

static void constructor_3125( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >(*(const ::std::basic_string<char>*)arg[0],
      *(const ::std::map<std::basic_string<char>,std::basic_string<char> >*)arg[1]);
  else ::new(mem) ::std::pair<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >(*(const ::std::basic_string<char>*)arg[0],
      *(const ::std::map<std::basic_string<char>,std::basic_string<char> >*)arg[1]);
}

static void method_newdel_857( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > > -------------------------------
void __std__pair_std__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s__db_datamem(Reflex::Class*);
void __std__pair_std__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_std__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s__datamem_bld(&__std__pair_std__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_std__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s__funcmem_bld(&__std__pair_std__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s__db_funcmem);
void __std__pair_std__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >"), typeid(::std::pair<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >), sizeof(::std::pair<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_1104, Reflex::Literal("std::pair<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >::first_type"))
  .AddTypedef(type_1615, Reflex::Literal("std::pair<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3121, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20222, type_20223), Reflex::Literal("operator="), operator_3122, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20223), Reflex::Literal("pair"), constructor_3123, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3124, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4981, type_20224), Reflex::Literal("pair"), constructor_3125, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_857, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_std__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s__datamem_bld);
}

//------Delayed data member builder for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > > -------------------
void __std__pair_std__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1104, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_std__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_1615, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_std__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > > -------------------
void __std__pair_std__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::basic_string<char, std::char_traits<char>, std::allocator<char> > > -------------------------------
static void destructor_3130(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<const std::basic_string<char>,std::basic_string<char> >*)o)->::std::pair<const std::basic_string<char>,std::basic_string<char> >::~pair)();
}
static void constructor_3131( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const std::basic_string<char>,std::basic_string<char> >(*(const ::std::pair<const std::basic_string<char>,std::basic_string<char> >*)arg[0]);
  else ::new(mem) ::std::pair<const std::basic_string<char>,std::basic_string<char> >(*(const ::std::pair<const std::basic_string<char>,std::basic_string<char> >*)arg[0]);
}

static void constructor_3132( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const std::basic_string<char>,std::basic_string<char> >();
  else ::new(mem) ::std::pair<const std::basic_string<char>,std::basic_string<char> >();
}

static void constructor_3133( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const std::basic_string<char>,std::basic_string<char> >(*(const ::std::basic_string<char>*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
  else ::new(mem) ::std::pair<const std::basic_string<char>,std::basic_string<char> >(*(const ::std::basic_string<char>*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
}

static void method_newdel_858( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<const std::basic_string<char>,std::basic_string<char> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<const std::basic_string<char>,std::basic_string<char> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<const std::basic_string<char>,std::basic_string<char> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<const std::basic_string<char>,std::basic_string<char> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<const std::basic_string<char>,std::basic_string<char> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::basic_string<char, std::char_traits<char>, std::allocator<char> > > -------------------------------
void __std__pair_constsstd__basic_string_char__std__basic_string_char_s__db_datamem(Reflex::Class*);
void __std__pair_constsstd__basic_string_char__std__basic_string_char_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_constsstd__basic_string_char__std__basic_string_char_s__datamem_bld(&__std__pair_constsstd__basic_string_char__std__basic_string_char_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_constsstd__basic_string_char__std__basic_string_char_s__funcmem_bld(&__std__pair_constsstd__basic_string_char__std__basic_string_char_s__db_funcmem);
void __std__pair_constsstd__basic_string_char__std__basic_string_char_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<const std::basic_string<char>,std::basic_string<char> >"), typeid(::std::pair<const std::basic_string<char>,std::basic_string<char> >), sizeof(::std::pair<const std::basic_string<char>,std::basic_string<char> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_1104c, Reflex::Literal("std::pair<const std::basic_string<char>,std::basic_string<char> >::first_type"))
  .AddTypedef(type_1104, Reflex::Literal("std::pair<const std::basic_string<char>,std::basic_string<char> >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3130, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8835), Reflex::Literal("pair"), constructor_3131, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3132, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4981, type_4981), Reflex::Literal("pair"), constructor_3133, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_858, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_constsstd__basic_string_char__std__basic_string_char_s__datamem_bld);
}

//------Delayed data member builder for class pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::basic_string<char, std::char_traits<char>, std::allocator<char> > > -------------------
void __std__pair_constsstd__basic_string_char__std__basic_string_char_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1104c, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_constsstd__basic_string_char__std__basic_string_char_s_, first), ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddDataMember(type_1104, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_constsstd__basic_string_char__std__basic_string_char_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::basic_string<char, std::char_traits<char>, std::allocator<char> > > -------------------
void __std__pair_constsstd__basic_string_char__std__basic_string_char_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::basic_string<char, std::char_traits<char>, std::allocator<char> > > -------------------------------
static void destructor_3138(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<std::basic_string<char>,std::basic_string<char> >*)o)->::std::pair<std::basic_string<char>,std::basic_string<char> >::~pair)();
}
static  void operator_3139( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<std::basic_string<char>,std::basic_string<char> >*)o)->operator=)(*(const ::std::pair<std::basic_string<char>,std::basic_string<char> >*)arg[0]);
  else   (((::std::pair<std::basic_string<char>,std::basic_string<char> >*)o)->operator=)(*(const ::std::pair<std::basic_string<char>,std::basic_string<char> >*)arg[0]);
}

static void constructor_3140( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,std::basic_string<char> >(*(const ::std::pair<std::basic_string<char>,std::basic_string<char> >*)arg[0]);
  else ::new(mem) ::std::pair<std::basic_string<char>,std::basic_string<char> >(*(const ::std::pair<std::basic_string<char>,std::basic_string<char> >*)arg[0]);
}

static void constructor_3141( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,std::basic_string<char> >();
  else ::new(mem) ::std::pair<std::basic_string<char>,std::basic_string<char> >();
}

static void constructor_3142( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<std::basic_string<char>,std::basic_string<char> >(*(const ::std::basic_string<char>*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
  else ::new(mem) ::std::pair<std::basic_string<char>,std::basic_string<char> >(*(const ::std::basic_string<char>*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
}

static void method_newdel_859( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,std::basic_string<char> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,std::basic_string<char> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,std::basic_string<char> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,std::basic_string<char> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<std::basic_string<char>,std::basic_string<char> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::basic_string<char, std::char_traits<char>, std::allocator<char> > > -------------------------------
void __std__pair_std__basic_string_char__std__basic_string_char_s__db_datamem(Reflex::Class*);
void __std__pair_std__basic_string_char__std__basic_string_char_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_std__basic_string_char__std__basic_string_char_s__datamem_bld(&__std__pair_std__basic_string_char__std__basic_string_char_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_std__basic_string_char__std__basic_string_char_s__funcmem_bld(&__std__pair_std__basic_string_char__std__basic_string_char_s__db_funcmem);
void __std__pair_std__basic_string_char__std__basic_string_char_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<std::basic_string<char>,std::basic_string<char> >"), typeid(::std::pair<std::basic_string<char>,std::basic_string<char> >), sizeof(::std::pair<std::basic_string<char>,std::basic_string<char> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_1104, Reflex::Literal("std::pair<std::basic_string<char>,std::basic_string<char> >::first_type"))
  .AddTypedef(type_1104, Reflex::Literal("std::pair<std::basic_string<char>,std::basic_string<char> >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3138, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20226, type_20227), Reflex::Literal("operator="), operator_3139, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20227), Reflex::Literal("pair"), constructor_3140, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3141, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4981, type_4981), Reflex::Literal("pair"), constructor_3142, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_859, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_std__basic_string_char__std__basic_string_char_s__datamem_bld);
}

//------Delayed data member builder for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::basic_string<char, std::char_traits<char>, std::allocator<char> > > -------------------
void __std__pair_std__basic_string_char__std__basic_string_char_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1104, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_std__basic_string_char__std__basic_string_char_s_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_1104, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_std__basic_string_char__std__basic_string_char_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::basic_string<char, std::char_traits<char>, std::allocator<char> > > -------------------
void __std__pair_std__basic_string_char__std__basic_string_char_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<short int,unsigned int> -------------------------------
static void destructor_3147(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<short,unsigned int>*)o)->::std::pair<short,unsigned int>::~pair)();
}
static  void operator_3148( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<short,unsigned int>*)o)->operator=)(*(const ::std::pair<short,unsigned int>*)arg[0]);
  else   (((::std::pair<short,unsigned int>*)o)->operator=)(*(const ::std::pair<short,unsigned int>*)arg[0]);
}

static void constructor_3149( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<short,unsigned int>(*(const ::std::pair<short,unsigned int>*)arg[0]);
  else ::new(mem) ::std::pair<short,unsigned int>(*(const ::std::pair<short,unsigned int>*)arg[0]);
}

static void constructor_3150( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<short,unsigned int>();
  else ::new(mem) ::std::pair<short,unsigned int>();
}

static void constructor_3151( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<short,unsigned int>(*(const short*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::std::pair<short,unsigned int>(*(const short*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_860( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<short,unsigned int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<short,unsigned int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<short,unsigned int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<short,unsigned int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<short,unsigned int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<short int,unsigned int> -------------------------------
void __std__pair_short_unsignedsint__db_datamem(Reflex::Class*);
void __std__pair_short_unsignedsint__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_short_unsignedsint__datamem_bld(&__std__pair_short_unsignedsint__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_short_unsignedsint__funcmem_bld(&__std__pair_short_unsignedsint__db_funcmem);
void __std__pair_short_unsignedsint__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<short,unsigned int>"), typeid(::std::pair<short,unsigned int>), sizeof(::std::pair<short,unsigned int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_113, Reflex::Literal("std::pair<short,unsigned int>::first_type"))
  .AddTypedef(type_78, Reflex::Literal("std::pair<short,unsigned int>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3147, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20228, type_20229), Reflex::Literal("operator="), operator_3148, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20229), Reflex::Literal("pair"), constructor_3149, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3150, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4662, type_3951), Reflex::Literal("pair"), constructor_3151, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_860, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_short_unsignedsint__datamem_bld);
}

//------Delayed data member builder for class pair<short int,unsigned int> -------------------
void __std__pair_short_unsignedsint__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_113, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_short_unsignedsint_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_78, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_short_unsignedsint_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<short int,unsigned int> -------------------
void __std__pair_short_unsignedsint__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<int,unsigned int> -------------------------------
static void destructor_3156(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<int,unsigned int>*)o)->::std::pair<int,unsigned int>::~pair)();
}
static  void operator_3157( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<int,unsigned int>*)o)->operator=)(*(const ::std::pair<int,unsigned int>*)arg[0]);
  else   (((::std::pair<int,unsigned int>*)o)->operator=)(*(const ::std::pair<int,unsigned int>*)arg[0]);
}

static void constructor_3158( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<int,unsigned int>(*(const ::std::pair<int,unsigned int>*)arg[0]);
  else ::new(mem) ::std::pair<int,unsigned int>(*(const ::std::pair<int,unsigned int>*)arg[0]);
}

static void constructor_3159( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<int,unsigned int>();
  else ::new(mem) ::std::pair<int,unsigned int>();
}

static void constructor_3160( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<int,unsigned int>(*(const int*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::std::pair<int,unsigned int>(*(const int*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_861( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<int,unsigned int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<int,unsigned int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<int,unsigned int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<int,unsigned int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<int,unsigned int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<int,unsigned int> -------------------------------
void __std__pair_int_unsignedsint__db_datamem(Reflex::Class*);
void __std__pair_int_unsignedsint__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_int_unsignedsint__datamem_bld(&__std__pair_int_unsignedsint__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_int_unsignedsint__funcmem_bld(&__std__pair_int_unsignedsint__db_funcmem);
void __std__pair_int_unsignedsint__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<int,unsigned int>"), typeid(::std::pair<int,unsigned int>), sizeof(::std::pair<int,unsigned int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_22, Reflex::Literal("std::pair<int,unsigned int>::first_type"))
  .AddTypedef(type_78, Reflex::Literal("std::pair<int,unsigned int>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3156, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20230, type_20231), Reflex::Literal("operator="), operator_3157, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20231), Reflex::Literal("pair"), constructor_3158, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3159, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4404, type_3951), Reflex::Literal("pair"), constructor_3160, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_861, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_int_unsignedsint__datamem_bld);
}

//------Delayed data member builder for class pair<int,unsigned int> -------------------
void __std__pair_int_unsignedsint__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_22, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_int_unsignedsint_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_78, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_int_unsignedsint_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<int,unsigned int> -------------------
void __std__pair_int_unsignedsint__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<int,std::pair<long unsigned int, long unsigned int> > -------------------------------
static void destructor_3165(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<int,std::pair<unsigned long,unsigned long> >*)o)->::std::pair<int,std::pair<unsigned long,unsigned long> >::~pair)();
}
static  void operator_3166( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<int,std::pair<unsigned long,unsigned long> >*)o)->operator=)(*(const ::std::pair<int,std::pair<unsigned long,unsigned long> >*)arg[0]);
  else   (((::std::pair<int,std::pair<unsigned long,unsigned long> >*)o)->operator=)(*(const ::std::pair<int,std::pair<unsigned long,unsigned long> >*)arg[0]);
}

static void constructor_3167( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<int,std::pair<unsigned long,unsigned long> >(*(const ::std::pair<int,std::pair<unsigned long,unsigned long> >*)arg[0]);
  else ::new(mem) ::std::pair<int,std::pair<unsigned long,unsigned long> >(*(const ::std::pair<int,std::pair<unsigned long,unsigned long> >*)arg[0]);
}

static void constructor_3168( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<int,std::pair<unsigned long,unsigned long> >();
  else ::new(mem) ::std::pair<int,std::pair<unsigned long,unsigned long> >();
}

static void constructor_3169( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<int,std::pair<unsigned long,unsigned long> >(*(const int*)arg[0],
      *(const ::std::pair<unsigned long,unsigned long>*)arg[1]);
  else ::new(mem) ::std::pair<int,std::pair<unsigned long,unsigned long> >(*(const int*)arg[0],
      *(const ::std::pair<unsigned long,unsigned long>*)arg[1]);
}

static void method_newdel_862( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<int,std::pair<unsigned long,unsigned long> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<int,std::pair<unsigned long,unsigned long> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<int,std::pair<unsigned long,unsigned long> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<int,std::pair<unsigned long,unsigned long> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<int,std::pair<unsigned long,unsigned long> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<int,std::pair<long unsigned int, long unsigned int> > -------------------------------
void __std__pair_int_std__pair_unsignedslong_unsignedslong_s__db_datamem(Reflex::Class*);
void __std__pair_int_std__pair_unsignedslong_unsignedslong_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_int_std__pair_unsignedslong_unsignedslong_s__datamem_bld(&__std__pair_int_std__pair_unsignedslong_unsignedslong_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_int_std__pair_unsignedslong_unsignedslong_s__funcmem_bld(&__std__pair_int_std__pair_unsignedslong_unsignedslong_s__db_funcmem);
void __std__pair_int_std__pair_unsignedslong_unsignedslong_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<int,std::pair<unsigned long,unsigned long> >"), typeid(::std::pair<int,std::pair<unsigned long,unsigned long> >), sizeof(::std::pair<int,std::pair<unsigned long,unsigned long> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_22, Reflex::Literal("std::pair<int,std::pair<unsigned long,unsigned long> >::first_type"))
  .AddTypedef(type_840, Reflex::Literal("std::pair<int,std::pair<unsigned long,unsigned long> >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3165, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20232, type_20233), Reflex::Literal("operator="), operator_3166, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20233), Reflex::Literal("pair"), constructor_3167, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3168, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4404, type_20184), Reflex::Literal("pair"), constructor_3169, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_862, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_int_std__pair_unsignedslong_unsignedslong_s__datamem_bld);
}

//------Delayed data member builder for class pair<int,std::pair<long unsigned int, long unsigned int> > -------------------
void __std__pair_int_std__pair_unsignedslong_unsignedslong_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_22, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_int_std__pair_unsignedslong_unsignedslong_s_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_840, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_int_std__pair_unsignedslong_unsignedslong_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<int,std::pair<long unsigned int, long unsigned int> > -------------------
void __std__pair_int_std__pair_unsignedslong_unsignedslong_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<int,std::pair<unsigned int, unsigned int> > -------------------------------
static void destructor_3174(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<int,std::pair<unsigned int,unsigned int> >*)o)->::std::pair<int,std::pair<unsigned int,unsigned int> >::~pair)();
}
static  void operator_3175( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<int,std::pair<unsigned int,unsigned int> >*)o)->operator=)(*(const ::std::pair<int,std::pair<unsigned int,unsigned int> >*)arg[0]);
  else   (((::std::pair<int,std::pair<unsigned int,unsigned int> >*)o)->operator=)(*(const ::std::pair<int,std::pair<unsigned int,unsigned int> >*)arg[0]);
}

static void constructor_3176( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<int,std::pair<unsigned int,unsigned int> >(*(const ::std::pair<int,std::pair<unsigned int,unsigned int> >*)arg[0]);
  else ::new(mem) ::std::pair<int,std::pair<unsigned int,unsigned int> >(*(const ::std::pair<int,std::pair<unsigned int,unsigned int> >*)arg[0]);
}

static void constructor_3177( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<int,std::pair<unsigned int,unsigned int> >();
  else ::new(mem) ::std::pair<int,std::pair<unsigned int,unsigned int> >();
}

static void constructor_3178( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<int,std::pair<unsigned int,unsigned int> >(*(const int*)arg[0],
      *(const ::std::pair<unsigned int,unsigned int>*)arg[1]);
  else ::new(mem) ::std::pair<int,std::pair<unsigned int,unsigned int> >(*(const int*)arg[0],
      *(const ::std::pair<unsigned int,unsigned int>*)arg[1]);
}

static void method_newdel_863( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<int,std::pair<unsigned int,unsigned int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<int,std::pair<unsigned int,unsigned int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<int,std::pair<unsigned int,unsigned int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<int,std::pair<unsigned int,unsigned int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<int,std::pair<unsigned int,unsigned int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<int,std::pair<unsigned int, unsigned int> > -------------------------------
void __std__pair_int_std__pair_unsignedsint_unsignedsint_s__db_datamem(Reflex::Class*);
void __std__pair_int_std__pair_unsignedsint_unsignedsint_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_int_std__pair_unsignedsint_unsignedsint_s__datamem_bld(&__std__pair_int_std__pair_unsignedsint_unsignedsint_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_int_std__pair_unsignedsint_unsignedsint_s__funcmem_bld(&__std__pair_int_std__pair_unsignedsint_unsignedsint_s__db_funcmem);
void __std__pair_int_std__pair_unsignedsint_unsignedsint_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<int,std::pair<unsigned int,unsigned int> >"), typeid(::std::pair<int,std::pair<unsigned int,unsigned int> >), sizeof(::std::pair<int,std::pair<unsigned int,unsigned int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_22, Reflex::Literal("std::pair<int,std::pair<unsigned int,unsigned int> >::first_type"))
  .AddTypedef(type_814, Reflex::Literal("std::pair<int,std::pair<unsigned int,unsigned int> >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3174, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20234, type_20235), Reflex::Literal("operator="), operator_3175, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20235), Reflex::Literal("pair"), constructor_3176, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3177, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4404, type_5111), Reflex::Literal("pair"), constructor_3178, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_863, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_int_std__pair_unsignedsint_unsignedsint_s__datamem_bld);
}

//------Delayed data member builder for class pair<int,std::pair<unsigned int, unsigned int> > -------------------
void __std__pair_int_std__pair_unsignedsint_unsignedsint_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_22, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_int_std__pair_unsignedsint_unsignedsint_s_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_814, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_int_std__pair_unsignedsint_unsignedsint_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<int,std::pair<unsigned int, unsigned int> > -------------------
void __std__pair_int_std__pair_unsignedsint_unsignedsint_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<int,std::pair<double, double> > -------------------------------
static void destructor_3183(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<int,std::pair<double,double> >*)o)->::std::pair<int,std::pair<double,double> >::~pair)();
}
static  void operator_3184( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::pair<int,std::pair<double,double> >*)o)->operator=)(*(const ::std::pair<int,std::pair<double,double> >*)arg[0]);
  else   (((::std::pair<int,std::pair<double,double> >*)o)->operator=)(*(const ::std::pair<int,std::pair<double,double> >*)arg[0]);
}

static void constructor_3185( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<int,std::pair<double,double> >(*(const ::std::pair<int,std::pair<double,double> >*)arg[0]);
  else ::new(mem) ::std::pair<int,std::pair<double,double> >(*(const ::std::pair<int,std::pair<double,double> >*)arg[0]);
}

static void constructor_3186( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<int,std::pair<double,double> >();
  else ::new(mem) ::std::pair<int,std::pair<double,double> >();
}

static void constructor_3187( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<int,std::pair<double,double> >(*(const int*)arg[0],
      *(const ::std::pair<double,double>*)arg[1]);
  else ::new(mem) ::std::pair<int,std::pair<double,double> >(*(const int*)arg[0],
      *(const ::std::pair<double,double>*)arg[1]);
}

static void method_newdel_864( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<int,std::pair<double,double> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<int,std::pair<double,double> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<int,std::pair<double,double> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<int,std::pair<double,double> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<int,std::pair<double,double> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<int,std::pair<double, double> > -------------------------------
void __std__pair_int_std__pair_double_double_s__db_datamem(Reflex::Class*);
void __std__pair_int_std__pair_double_double_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_int_std__pair_double_double_s__datamem_bld(&__std__pair_int_std__pair_double_double_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_int_std__pair_double_double_s__funcmem_bld(&__std__pair_int_std__pair_double_double_s__db_funcmem);
void __std__pair_int_std__pair_double_double_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<int,std::pair<double,double> >"), typeid(::std::pair<int,std::pair<double,double> >), sizeof(::std::pair<int,std::pair<double,double> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_22, Reflex::Literal("std::pair<int,std::pair<double,double> >::first_type"))
  .AddTypedef(type_827, Reflex::Literal("std::pair<int,std::pair<double,double> >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3183, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20236, type_20237), Reflex::Literal("operator="), operator_3184, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20237), Reflex::Literal("pair"), constructor_3185, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3186, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4404, type_5956), Reflex::Literal("pair"), constructor_3187, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_864, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_int_std__pair_double_double_s__datamem_bld);
}

//------Delayed data member builder for class pair<int,std::pair<double, double> > -------------------
void __std__pair_int_std__pair_double_double_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_22, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_int_std__pair_double_double_s_, first), ::Reflex::PUBLIC)
  .AddDataMember(type_827, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_int_std__pair_double_double_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<int,std::pair<double, double> > -------------------
void __std__pair_int_std__pair_double_double_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<const short unsigned int,short unsigned int> -------------------------------
static void destructor_3192(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<const unsigned short,unsigned short>*)o)->::std::pair<const unsigned short,unsigned short>::~pair)();
}
static void constructor_3193( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned short,unsigned short>(*(const ::std::pair<const unsigned short,unsigned short>*)arg[0]);
  else ::new(mem) ::std::pair<const unsigned short,unsigned short>(*(const ::std::pair<const unsigned short,unsigned short>*)arg[0]);
}

static void constructor_3194( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned short,unsigned short>();
  else ::new(mem) ::std::pair<const unsigned short,unsigned short>();
}

static void constructor_3195( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned short,unsigned short>(*(const unsigned short*)arg[0],
      *(const unsigned short*)arg[1]);
  else ::new(mem) ::std::pair<const unsigned short,unsigned short>(*(const unsigned short*)arg[0],
      *(const unsigned short*)arg[1]);
}

static void method_newdel_865( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned short,unsigned short> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned short,unsigned short> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned short,unsigned short> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned short,unsigned short> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned short,unsigned short> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<const short unsigned int,short unsigned int> -------------------------------
void __std__pair_constsunsignedsshort_unsignedsshort__db_datamem(Reflex::Class*);
void __std__pair_constsunsignedsshort_unsignedsshort__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_constsunsignedsshort_unsignedsshort__datamem_bld(&__std__pair_constsunsignedsshort_unsignedsshort__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_constsunsignedsshort_unsignedsshort__funcmem_bld(&__std__pair_constsunsignedsshort_unsignedsshort__db_funcmem);
void __std__pair_constsunsignedsshort_unsignedsshort__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<const unsigned short,unsigned short>"), typeid(::std::pair<const unsigned short,unsigned short>), sizeof(::std::pair<const unsigned short,unsigned short>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_167c, Reflex::Literal("std::pair<const unsigned short,unsigned short>::first_type"))
  .AddTypedef(type_167, Reflex::Literal("std::pair<const unsigned short,unsigned short>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3192, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6945), Reflex::Literal("pair"), constructor_3193, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3194, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3762, type_3762), Reflex::Literal("pair"), constructor_3195, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_865, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_constsunsignedsshort_unsignedsshort__datamem_bld);
}

//------Delayed data member builder for class pair<const short unsigned int,short unsigned int> -------------------
void __std__pair_constsunsignedsshort_unsignedsshort__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_167c, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_constsunsignedsshort_unsignedsshort_, first), ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddDataMember(type_167, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_constsunsignedsshort_unsignedsshort_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<const short unsigned int,short unsigned int> -------------------
void __std__pair_constsunsignedsshort_unsignedsshort__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<const short unsigned int,std::vector<short unsigned int, std::allocator<short unsigned int> > > -------------------------------
static void destructor_3200(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<const unsigned short,std::vector<unsigned short> >*)o)->::std::pair<const unsigned short,std::vector<unsigned short> >::~pair)();
}
static void constructor_3201( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned short,std::vector<unsigned short> >(*(const ::std::pair<const unsigned short,std::vector<unsigned short> >*)arg[0]);
  else ::new(mem) ::std::pair<const unsigned short,std::vector<unsigned short> >(*(const ::std::pair<const unsigned short,std::vector<unsigned short> >*)arg[0]);
}

static void constructor_3202( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned short,std::vector<unsigned short> >();
  else ::new(mem) ::std::pair<const unsigned short,std::vector<unsigned short> >();
}

static void constructor_3203( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned short,std::vector<unsigned short> >(*(const unsigned short*)arg[0],
      *(const ::std::vector<unsigned short>*)arg[1]);
  else ::new(mem) ::std::pair<const unsigned short,std::vector<unsigned short> >(*(const unsigned short*)arg[0],
      *(const ::std::vector<unsigned short>*)arg[1]);
}

static void method_newdel_866( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned short,std::vector<unsigned short> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned short,std::vector<unsigned short> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned short,std::vector<unsigned short> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned short,std::vector<unsigned short> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned short,std::vector<unsigned short> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<const short unsigned int,std::vector<short unsigned int, std::allocator<short unsigned int> > > -------------------------------
void __std__pair_constsunsignedsshort_std__vector_unsignedsshort_s__db_datamem(Reflex::Class*);
void __std__pair_constsunsignedsshort_std__vector_unsignedsshort_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_constsunsignedsshort_std__vector_unsignedsshort_s__datamem_bld(&__std__pair_constsunsignedsshort_std__vector_unsignedsshort_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_constsunsignedsshort_std__vector_unsignedsshort_s__funcmem_bld(&__std__pair_constsunsignedsshort_std__vector_unsignedsshort_s__db_funcmem);
void __std__pair_constsunsignedsshort_std__vector_unsignedsshort_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<const unsigned short,std::vector<unsigned short> >"), typeid(::std::pair<const unsigned short,std::vector<unsigned short> >), sizeof(::std::pair<const unsigned short,std::vector<unsigned short> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_167c, Reflex::Literal("std::pair<const unsigned short,std::vector<unsigned short> >::first_type"))
  .AddTypedef(type_1051, Reflex::Literal("std::pair<const unsigned short,std::vector<unsigned short> >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3200, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7050), Reflex::Literal("pair"), constructor_3201, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3202, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3762, type_4146), Reflex::Literal("pair"), constructor_3203, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_866, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_constsunsignedsshort_std__vector_unsignedsshort_s__datamem_bld);
}

//------Delayed data member builder for class pair<const short unsigned int,std::vector<short unsigned int, std::allocator<short unsigned int> > > -------------------
void __std__pair_constsunsignedsshort_std__vector_unsignedsshort_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_167c, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_constsunsignedsshort_std__vector_unsignedsshort_s_, first), ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddDataMember(type_1051, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_constsunsignedsshort_std__vector_unsignedsshort_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<const short unsigned int,std::vector<short unsigned int, std::allocator<short unsigned int> > > -------------------
void __std__pair_constsunsignedsshort_std__vector_unsignedsshort_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<const short unsigned int,float> -------------------------------
static void destructor_3208(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<const unsigned short,float>*)o)->::std::pair<const unsigned short,float>::~pair)();
}
static void constructor_3209( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned short,float>(*(const ::std::pair<const unsigned short,float>*)arg[0]);
  else ::new(mem) ::std::pair<const unsigned short,float>(*(const ::std::pair<const unsigned short,float>*)arg[0]);
}

static void constructor_3210( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned short,float>();
  else ::new(mem) ::std::pair<const unsigned short,float>();
}

static void constructor_3211( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned short,float>(*(const unsigned short*)arg[0],
      *(const float*)arg[1]);
  else ::new(mem) ::std::pair<const unsigned short,float>(*(const unsigned short*)arg[0],
      *(const float*)arg[1]);
}

static void method_newdel_867( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned short,float> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned short,float> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned short,float> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned short,float> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned short,float> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<const short unsigned int,float> -------------------------------
void __std__pair_constsunsignedsshort_float__db_datamem(Reflex::Class*);
void __std__pair_constsunsignedsshort_float__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_constsunsignedsshort_float__datamem_bld(&__std__pair_constsunsignedsshort_float__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_constsunsignedsshort_float__funcmem_bld(&__std__pair_constsunsignedsshort_float__db_funcmem);
void __std__pair_constsunsignedsshort_float__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<const unsigned short,float>"), typeid(::std::pair<const unsigned short,float>), sizeof(::std::pair<const unsigned short,float>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_167c, Reflex::Literal("std::pair<const unsigned short,float>::first_type"))
  .AddTypedef(type_2058, Reflex::Literal("std::pair<const unsigned short,float>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3208, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7155), Reflex::Literal("pair"), constructor_3209, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3210, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3762, type_4790), Reflex::Literal("pair"), constructor_3211, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_867, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_constsunsignedsshort_float__datamem_bld);
}

//------Delayed data member builder for class pair<const short unsigned int,float> -------------------
void __std__pair_constsunsignedsshort_float__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_167c, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_constsunsignedsshort_float_, first), ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddDataMember(type_2058, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_constsunsignedsshort_float_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<const short unsigned int,float> -------------------
void __std__pair_constsunsignedsshort_float__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<const long unsigned int,long unsigned int> -------------------------------
static void destructor_3216(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<const unsigned long,unsigned long>*)o)->::std::pair<const unsigned long,unsigned long>::~pair)();
}
static void constructor_3217( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned long,unsigned long>(*(const ::std::pair<const unsigned long,unsigned long>*)arg[0]);
  else ::new(mem) ::std::pair<const unsigned long,unsigned long>(*(const ::std::pair<const unsigned long,unsigned long>*)arg[0]);
}

static void constructor_3218( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned long,unsigned long>();
  else ::new(mem) ::std::pair<const unsigned long,unsigned long>();
}

static void constructor_3219( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned long,unsigned long>(*(const unsigned long*)arg[0],
      *(const unsigned long*)arg[1]);
  else ::new(mem) ::std::pair<const unsigned long,unsigned long>(*(const unsigned long*)arg[0],
      *(const unsigned long*)arg[1]);
}

static void method_newdel_868( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned long,unsigned long> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned long,unsigned long> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned long,unsigned long> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned long,unsigned long> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned long,unsigned long> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<const long unsigned int,long unsigned int> -------------------------------
void __std__pair_constsunsignedslong_unsignedslong__db_datamem(Reflex::Class*);
void __std__pair_constsunsignedslong_unsignedslong__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_constsunsignedslong_unsignedslong__datamem_bld(&__std__pair_constsunsignedslong_unsignedslong__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_constsunsignedslong_unsignedslong__funcmem_bld(&__std__pair_constsunsignedslong_unsignedslong__db_funcmem);
void __std__pair_constsunsignedslong_unsignedslong__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<const unsigned long,unsigned long>"), typeid(::std::pair<const unsigned long,unsigned long>), sizeof(::std::pair<const unsigned long,unsigned long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_75c, Reflex::Literal("std::pair<const unsigned long,unsigned long>::first_type"))
  .AddTypedef(type_75, Reflex::Literal("std::pair<const unsigned long,unsigned long>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3216, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7260), Reflex::Literal("pair"), constructor_3217, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3218, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3825, type_3825), Reflex::Literal("pair"), constructor_3219, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_868, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_constsunsignedslong_unsignedslong__datamem_bld);
}

//------Delayed data member builder for class pair<const long unsigned int,long unsigned int> -------------------
void __std__pair_constsunsignedslong_unsignedslong__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_75c, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_constsunsignedslong_unsignedslong_, first), ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddDataMember(type_75, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_constsunsignedslong_unsignedslong_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<const long unsigned int,long unsigned int> -------------------
void __std__pair_constsunsignedslong_unsignedslong__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<const long unsigned int,std::vector<long unsigned int, std::allocator<long unsigned int> > > -------------------------------
static void destructor_3224(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<const unsigned long,std::vector<unsigned long> >*)o)->::std::pair<const unsigned long,std::vector<unsigned long> >::~pair)();
}
static void constructor_3225( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned long,std::vector<unsigned long> >(*(const ::std::pair<const unsigned long,std::vector<unsigned long> >*)arg[0]);
  else ::new(mem) ::std::pair<const unsigned long,std::vector<unsigned long> >(*(const ::std::pair<const unsigned long,std::vector<unsigned long> >*)arg[0]);
}

static void constructor_3226( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned long,std::vector<unsigned long> >();
  else ::new(mem) ::std::pair<const unsigned long,std::vector<unsigned long> >();
}

static void constructor_3227( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned long,std::vector<unsigned long> >(*(const unsigned long*)arg[0],
      *(const ::std::vector<unsigned long>*)arg[1]);
  else ::new(mem) ::std::pair<const unsigned long,std::vector<unsigned long> >(*(const unsigned long*)arg[0],
      *(const ::std::vector<unsigned long>*)arg[1]);
}

static void method_newdel_869( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned long,std::vector<unsigned long> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned long,std::vector<unsigned long> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned long,std::vector<unsigned long> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned long,std::vector<unsigned long> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned long,std::vector<unsigned long> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<const long unsigned int,std::vector<long unsigned int, std::allocator<long unsigned int> > > -------------------------------
void __std__pair_constsunsignedslong_std__vector_unsignedslong_s__db_datamem(Reflex::Class*);
void __std__pair_constsunsignedslong_std__vector_unsignedslong_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_constsunsignedslong_std__vector_unsignedslong_s__datamem_bld(&__std__pair_constsunsignedslong_std__vector_unsignedslong_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_constsunsignedslong_std__vector_unsignedslong_s__funcmem_bld(&__std__pair_constsunsignedslong_std__vector_unsignedslong_s__db_funcmem);
void __std__pair_constsunsignedslong_std__vector_unsignedslong_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<const unsigned long,std::vector<unsigned long> >"), typeid(::std::pair<const unsigned long,std::vector<unsigned long> >), sizeof(::std::pair<const unsigned long,std::vector<unsigned long> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_75c, Reflex::Literal("std::pair<const unsigned long,std::vector<unsigned long> >::first_type"))
  .AddTypedef(type_1052, Reflex::Literal("std::pair<const unsigned long,std::vector<unsigned long> >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3224, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7365), Reflex::Literal("pair"), constructor_3225, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3226, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3825, type_20187), Reflex::Literal("pair"), constructor_3227, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_869, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_constsunsignedslong_std__vector_unsignedslong_s__datamem_bld);
}

//------Delayed data member builder for class pair<const long unsigned int,std::vector<long unsigned int, std::allocator<long unsigned int> > > -------------------
void __std__pair_constsunsignedslong_std__vector_unsignedslong_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_75c, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_constsunsignedslong_std__vector_unsignedslong_s_, first), ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddDataMember(type_1052, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_constsunsignedslong_std__vector_unsignedslong_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<const long unsigned int,std::vector<long unsigned int, std::allocator<long unsigned int> > > -------------------
void __std__pair_constsunsignedslong_std__vector_unsignedslong_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<const long long unsigned int,std::basic_string<char, std::char_traits<char>, std::allocator<char> > > -------------------------------
static void destructor_3232(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<const unsigned long long,std::basic_string<char> >*)o)->::std::pair<const unsigned long long,std::basic_string<char> >::~pair)();
}
static void constructor_3233( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned long long,std::basic_string<char> >(*(const ::std::pair<const unsigned long long,std::basic_string<char> >*)arg[0]);
  else ::new(mem) ::std::pair<const unsigned long long,std::basic_string<char> >(*(const ::std::pair<const unsigned long long,std::basic_string<char> >*)arg[0]);
}

static void constructor_3234( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned long long,std::basic_string<char> >();
  else ::new(mem) ::std::pair<const unsigned long long,std::basic_string<char> >();
}

static void constructor_3235( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned long long,std::basic_string<char> >(*(const unsigned long long*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
  else ::new(mem) ::std::pair<const unsigned long long,std::basic_string<char> >(*(const unsigned long long*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
}

static void method_newdel_870( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned long long,std::basic_string<char> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned long long,std::basic_string<char> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned long long,std::basic_string<char> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned long long,std::basic_string<char> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned long long,std::basic_string<char> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<const long long unsigned int,std::basic_string<char, std::char_traits<char>, std::allocator<char> > > -------------------------------
void __std__pair_constsunsignedslongslong_std__basic_string_char_s__db_datamem(Reflex::Class*);
void __std__pair_constsunsignedslongslong_std__basic_string_char_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_constsunsignedslongslong_std__basic_string_char_s__datamem_bld(&__std__pair_constsunsignedslongslong_std__basic_string_char_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_constsunsignedslongslong_std__basic_string_char_s__funcmem_bld(&__std__pair_constsunsignedslongslong_std__basic_string_char_s__db_funcmem);
void __std__pair_constsunsignedslongslong_std__basic_string_char_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<const unsigned long long,std::basic_string<char> >"), typeid(::std::pair<const unsigned long long,std::basic_string<char> >), sizeof(::std::pair<const unsigned long long,std::basic_string<char> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_2144c, Reflex::Literal("std::pair<const unsigned long long,std::basic_string<char> >::first_type"))
  .AddTypedef(type_1104, Reflex::Literal("std::pair<const unsigned long long,std::basic_string<char> >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3232, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7470), Reflex::Literal("pair"), constructor_3233, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3234, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3888, type_4981), Reflex::Literal("pair"), constructor_3235, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_870, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_constsunsignedslongslong_std__basic_string_char_s__datamem_bld);
}

//------Delayed data member builder for class pair<const long long unsigned int,std::basic_string<char, std::char_traits<char>, std::allocator<char> > > -------------------
void __std__pair_constsunsignedslongslong_std__basic_string_char_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2144c, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_constsunsignedslongslong_std__basic_string_char_s_, first), ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddDataMember(type_1104, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_constsunsignedslongslong_std__basic_string_char_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<const long long unsigned int,std::basic_string<char, std::char_traits<char>, std::allocator<char> > > -------------------
void __std__pair_constsunsignedslongslong_std__basic_string_char_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<const unsigned int,unsigned int> -------------------------------
static void destructor_3240(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<const unsigned int,unsigned int>*)o)->::std::pair<const unsigned int,unsigned int>::~pair)();
}
static void constructor_3241( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned int,unsigned int>(*(const ::std::pair<const unsigned int,unsigned int>*)arg[0]);
  else ::new(mem) ::std::pair<const unsigned int,unsigned int>(*(const ::std::pair<const unsigned int,unsigned int>*)arg[0]);
}

static void constructor_3242( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned int,unsigned int>();
  else ::new(mem) ::std::pair<const unsigned int,unsigned int>();
}

static void constructor_3243( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned int,unsigned int>(*(const unsigned int*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::std::pair<const unsigned int,unsigned int>(*(const unsigned int*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_871( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,unsigned int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,unsigned int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,unsigned int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,unsigned int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,unsigned int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<const unsigned int,unsigned int> -------------------------------
void __std__pair_constsunsignedsint_unsignedsint__db_datamem(Reflex::Class*);
void __std__pair_constsunsignedsint_unsignedsint__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_constsunsignedsint_unsignedsint__datamem_bld(&__std__pair_constsunsignedsint_unsignedsint__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_constsunsignedsint_unsignedsint__funcmem_bld(&__std__pair_constsunsignedsint_unsignedsint__db_funcmem);
void __std__pair_constsunsignedsint_unsignedsint__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<const unsigned int,unsigned int>"), typeid(::std::pair<const unsigned int,unsigned int>), sizeof(::std::pair<const unsigned int,unsigned int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_78c, Reflex::Literal("std::pair<const unsigned int,unsigned int>::first_type"))
  .AddTypedef(type_78, Reflex::Literal("std::pair<const unsigned int,unsigned int>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3240, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7575), Reflex::Literal("pair"), constructor_3241, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3242, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3951, type_3951), Reflex::Literal("pair"), constructor_3243, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_871, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_constsunsignedsint_unsignedsint__datamem_bld);
}

//------Delayed data member builder for class pair<const unsigned int,unsigned int> -------------------
void __std__pair_constsunsignedsint_unsignedsint__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_78c, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_constsunsignedsint_unsignedsint_, first), ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddDataMember(type_78, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_constsunsignedsint_unsignedsint_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<const unsigned int,unsigned int> -------------------
void __std__pair_constsunsignedsint_unsignedsint__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<const unsigned int,std::vector<unsigned int, std::allocator<unsigned int> > > -------------------------------
static void destructor_3248(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<const unsigned int,std::vector<unsigned int> >*)o)->::std::pair<const unsigned int,std::vector<unsigned int> >::~pair)();
}
static void constructor_3249( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned int,std::vector<unsigned int> >(*(const ::std::pair<const unsigned int,std::vector<unsigned int> >*)arg[0]);
  else ::new(mem) ::std::pair<const unsigned int,std::vector<unsigned int> >(*(const ::std::pair<const unsigned int,std::vector<unsigned int> >*)arg[0]);
}

static void constructor_3250( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned int,std::vector<unsigned int> >();
  else ::new(mem) ::std::pair<const unsigned int,std::vector<unsigned int> >();
}

static void constructor_3251( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned int,std::vector<unsigned int> >(*(const unsigned int*)arg[0],
      *(const ::std::vector<unsigned int>*)arg[1]);
  else ::new(mem) ::std::pair<const unsigned int,std::vector<unsigned int> >(*(const unsigned int*)arg[0],
      *(const ::std::vector<unsigned int>*)arg[1]);
}

static void method_newdel_872( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,std::vector<unsigned int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,std::vector<unsigned int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,std::vector<unsigned int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,std::vector<unsigned int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,std::vector<unsigned int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<const unsigned int,std::vector<unsigned int, std::allocator<unsigned int> > > -------------------------------
void __std__pair_constsunsignedsint_std__vector_unsignedsint_s__db_datamem(Reflex::Class*);
void __std__pair_constsunsignedsint_std__vector_unsignedsint_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_constsunsignedsint_std__vector_unsignedsint_s__datamem_bld(&__std__pair_constsunsignedsint_std__vector_unsignedsint_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_constsunsignedsint_std__vector_unsignedsint_s__funcmem_bld(&__std__pair_constsunsignedsint_std__vector_unsignedsint_s__db_funcmem);
void __std__pair_constsunsignedsint_std__vector_unsignedsint_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<const unsigned int,std::vector<unsigned int> >"), typeid(::std::pair<const unsigned int,std::vector<unsigned int> >), sizeof(::std::pair<const unsigned int,std::vector<unsigned int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_78c, Reflex::Literal("std::pair<const unsigned int,std::vector<unsigned int> >::first_type"))
  .AddTypedef(type_1054, Reflex::Literal("std::pair<const unsigned int,std::vector<unsigned int> >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3248, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7680), Reflex::Literal("pair"), constructor_3249, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3250, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3951, type_4211), Reflex::Literal("pair"), constructor_3251, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_872, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_constsunsignedsint_std__vector_unsignedsint_s__datamem_bld);
}

//------Delayed data member builder for class pair<const unsigned int,std::vector<unsigned int, std::allocator<unsigned int> > > -------------------
void __std__pair_constsunsignedsint_std__vector_unsignedsint_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_78c, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_constsunsignedsint_std__vector_unsignedsint_s_, first), ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddDataMember(type_1054, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_constsunsignedsint_std__vector_unsignedsint_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<const unsigned int,std::vector<unsigned int, std::allocator<unsigned int> > > -------------------
void __std__pair_constsunsignedsint_std__vector_unsignedsint_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<const unsigned int,std::vector<std::pair<unsigned int, double>, std::allocator<std::pair<unsigned int, double> > > > -------------------------------
static void destructor_3256(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->::std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > >::~pair)();
}
static void constructor_3257( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > >(*(const ::std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > >*)arg[0]);
  else ::new(mem) ::std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > >(*(const ::std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > >*)arg[0]);
}

static void constructor_3258( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > >();
  else ::new(mem) ::std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > >();
}

static void constructor_3259( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > >(*(const unsigned int*)arg[0],
      *(const ::std::vector<std::pair<unsigned int,double> >*)arg[1]);
  else ::new(mem) ::std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > >(*(const unsigned int*)arg[0],
      *(const ::std::vector<std::pair<unsigned int,double> >*)arg[1]);
}

static void method_newdel_873( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<const unsigned int,std::vector<std::pair<unsigned int, double>, std::allocator<std::pair<unsigned int, double> > > > -------------------------------
void __std__pair_constsunsignedsint_std__vector_std__pair_unsignedsint_double_s_s__db_datamem(Reflex::Class*);
void __std__pair_constsunsignedsint_std__vector_std__pair_unsignedsint_double_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_constsunsignedsint_std__vector_std__pair_unsignedsint_double_s_s__datamem_bld(&__std__pair_constsunsignedsint_std__vector_std__pair_unsignedsint_double_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_constsunsignedsint_std__vector_std__pair_unsignedsint_double_s_s__funcmem_bld(&__std__pair_constsunsignedsint_std__vector_std__pair_unsignedsint_double_s_s__db_funcmem);
void __std__pair_constsunsignedsint_std__vector_std__pair_unsignedsint_double_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > >"), typeid(::std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > >), sizeof(::std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_78c, Reflex::Literal("std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > >::first_type"))
  .AddTypedef(type_1075, Reflex::Literal("std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3256, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7890), Reflex::Literal("pair"), constructor_3257, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3258, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3951, type_20194), Reflex::Literal("pair"), constructor_3259, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_873, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_constsunsignedsint_std__vector_std__pair_unsignedsint_double_s_s__datamem_bld);
}

//------Delayed data member builder for class pair<const unsigned int,std::vector<std::pair<unsigned int, double>, std::allocator<std::pair<unsigned int, double> > > > -------------------
void __std__pair_constsunsignedsint_std__vector_std__pair_unsignedsint_double_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_78c, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_constsunsignedsint_std__vector_std__pair_unsignedsint_double_s_s_, first), ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddDataMember(type_1075, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_constsunsignedsint_std__vector_std__pair_unsignedsint_double_s_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<const unsigned int,std::vector<std::pair<unsigned int, double>, std::allocator<std::pair<unsigned int, double> > > > -------------------
void __std__pair_constsunsignedsint_std__vector_std__pair_unsignedsint_double_s_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<const unsigned int,std::vector<std::pair<unsigned int, bool>, std::allocator<std::pair<unsigned int, bool> > > > -------------------------------
static void destructor_3264(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->::std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > >::~pair)();
}
static void constructor_3265( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > >(*(const ::std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > >*)arg[0]);
  else ::new(mem) ::std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > >(*(const ::std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > >*)arg[0]);
}

static void constructor_3266( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > >();
  else ::new(mem) ::std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > >();
}

static void constructor_3267( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > >(*(const unsigned int*)arg[0],
      *(const ::std::vector<std::pair<unsigned int,bool> >*)arg[1]);
  else ::new(mem) ::std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > >(*(const unsigned int*)arg[0],
      *(const ::std::vector<std::pair<unsigned int,bool> >*)arg[1]);
}

static void method_newdel_874( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<const unsigned int,std::vector<std::pair<unsigned int, bool>, std::allocator<std::pair<unsigned int, bool> > > > -------------------------------
void __std__pair_constsunsignedsint_std__vector_std__pair_unsignedsint_bool_s_s__db_datamem(Reflex::Class*);
void __std__pair_constsunsignedsint_std__vector_std__pair_unsignedsint_bool_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_constsunsignedsint_std__vector_std__pair_unsignedsint_bool_s_s__datamem_bld(&__std__pair_constsunsignedsint_std__vector_std__pair_unsignedsint_bool_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_constsunsignedsint_std__vector_std__pair_unsignedsint_bool_s_s__funcmem_bld(&__std__pair_constsunsignedsint_std__vector_std__pair_unsignedsint_bool_s_s__db_funcmem);
void __std__pair_constsunsignedsint_std__vector_std__pair_unsignedsint_bool_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > >"), typeid(::std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > >), sizeof(::std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_78c, Reflex::Literal("std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > >::first_type"))
  .AddTypedef(type_1076, Reflex::Literal("std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3264, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7995), Reflex::Literal("pair"), constructor_3265, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3266, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3951, type_20197), Reflex::Literal("pair"), constructor_3267, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_874, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_constsunsignedsint_std__vector_std__pair_unsignedsint_bool_s_s__datamem_bld);
}

//------Delayed data member builder for class pair<const unsigned int,std::vector<std::pair<unsigned int, bool>, std::allocator<std::pair<unsigned int, bool> > > > -------------------
void __std__pair_constsunsignedsint_std__vector_std__pair_unsignedsint_bool_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_78c, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_constsunsignedsint_std__vector_std__pair_unsignedsint_bool_s_s_, first), ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddDataMember(type_1076, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_constsunsignedsint_std__vector_std__pair_unsignedsint_bool_s_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<const unsigned int,std::vector<std::pair<unsigned int, bool>, std::allocator<std::pair<unsigned int, bool> > > > -------------------
void __std__pair_constsunsignedsint_std__vector_std__pair_unsignedsint_bool_s_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<const unsigned int,std::pair<unsigned int, unsigned int> > -------------------------------
static void destructor_3272(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<const unsigned int,std::pair<unsigned int,unsigned int> >*)o)->::std::pair<const unsigned int,std::pair<unsigned int,unsigned int> >::~pair)();
}
static void constructor_3273( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned int,std::pair<unsigned int,unsigned int> >(*(const ::std::pair<const unsigned int,std::pair<unsigned int,unsigned int> >*)arg[0]);
  else ::new(mem) ::std::pair<const unsigned int,std::pair<unsigned int,unsigned int> >(*(const ::std::pair<const unsigned int,std::pair<unsigned int,unsigned int> >*)arg[0]);
}

static void constructor_3274( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned int,std::pair<unsigned int,unsigned int> >();
  else ::new(mem) ::std::pair<const unsigned int,std::pair<unsigned int,unsigned int> >();
}

static void constructor_3275( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned int,std::pair<unsigned int,unsigned int> >(*(const unsigned int*)arg[0],
      *(const ::std::pair<unsigned int,unsigned int>*)arg[1]);
  else ::new(mem) ::std::pair<const unsigned int,std::pair<unsigned int,unsigned int> >(*(const unsigned int*)arg[0],
      *(const ::std::pair<unsigned int,unsigned int>*)arg[1]);
}

static void method_newdel_875( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<const unsigned int,std::pair<unsigned int, unsigned int> > -------------------------------
void __std__pair_constsunsignedsint_std__pair_unsignedsint_unsignedsint_s__db_datamem(Reflex::Class*);
void __std__pair_constsunsignedsint_std__pair_unsignedsint_unsignedsint_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_constsunsignedsint_std__pair_unsignedsint_unsignedsint_s__datamem_bld(&__std__pair_constsunsignedsint_std__pair_unsignedsint_unsignedsint_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_constsunsignedsint_std__pair_unsignedsint_unsignedsint_s__funcmem_bld(&__std__pair_constsunsignedsint_std__pair_unsignedsint_unsignedsint_s__db_funcmem);
void __std__pair_constsunsignedsint_std__pair_unsignedsint_unsignedsint_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<const unsigned int,std::pair<unsigned int,unsigned int> >"), typeid(::std::pair<const unsigned int,std::pair<unsigned int,unsigned int> >), sizeof(::std::pair<const unsigned int,std::pair<unsigned int,unsigned int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_78c, Reflex::Literal("std::pair<const unsigned int,std::pair<unsigned int,unsigned int> >::first_type"))
  .AddTypedef(type_814, Reflex::Literal("std::pair<const unsigned int,std::pair<unsigned int,unsigned int> >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3272, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8100), Reflex::Literal("pair"), constructor_3273, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3274, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3951, type_5111), Reflex::Literal("pair"), constructor_3275, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_875, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_constsunsignedsint_std__pair_unsignedsint_unsignedsint_s__datamem_bld);
}

//------Delayed data member builder for class pair<const unsigned int,std::pair<unsigned int, unsigned int> > -------------------
void __std__pair_constsunsignedsint_std__pair_unsignedsint_unsignedsint_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_78c, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_constsunsignedsint_std__pair_unsignedsint_unsignedsint_s_, first), ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddDataMember(type_814, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_constsunsignedsint_std__pair_unsignedsint_unsignedsint_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<const unsigned int,std::pair<unsigned int, unsigned int> > -------------------
void __std__pair_constsunsignedsint_std__pair_unsignedsint_unsignedsint_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<const unsigned int,std::basic_string<char, std::char_traits<char>, std::allocator<char> > > -------------------------------
static void destructor_3280(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<const unsigned int,std::basic_string<char> >*)o)->::std::pair<const unsigned int,std::basic_string<char> >::~pair)();
}
static void constructor_3281( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned int,std::basic_string<char> >(*(const ::std::pair<const unsigned int,std::basic_string<char> >*)arg[0]);
  else ::new(mem) ::std::pair<const unsigned int,std::basic_string<char> >(*(const ::std::pair<const unsigned int,std::basic_string<char> >*)arg[0]);
}

static void constructor_3282( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned int,std::basic_string<char> >();
  else ::new(mem) ::std::pair<const unsigned int,std::basic_string<char> >();
}

static void constructor_3283( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned int,std::basic_string<char> >(*(const unsigned int*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
  else ::new(mem) ::std::pair<const unsigned int,std::basic_string<char> >(*(const unsigned int*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
}

static void method_newdel_876( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,std::basic_string<char> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,std::basic_string<char> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,std::basic_string<char> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,std::basic_string<char> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,std::basic_string<char> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<const unsigned int,std::basic_string<char, std::char_traits<char>, std::allocator<char> > > -------------------------------
void __std__pair_constsunsignedsint_std__basic_string_char_s__db_datamem(Reflex::Class*);
void __std__pair_constsunsignedsint_std__basic_string_char_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_constsunsignedsint_std__basic_string_char_s__datamem_bld(&__std__pair_constsunsignedsint_std__basic_string_char_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_constsunsignedsint_std__basic_string_char_s__funcmem_bld(&__std__pair_constsunsignedsint_std__basic_string_char_s__db_funcmem);
void __std__pair_constsunsignedsint_std__basic_string_char_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<const unsigned int,std::basic_string<char> >"), typeid(::std::pair<const unsigned int,std::basic_string<char> >), sizeof(::std::pair<const unsigned int,std::basic_string<char> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_78c, Reflex::Literal("std::pair<const unsigned int,std::basic_string<char> >::first_type"))
  .AddTypedef(type_1104, Reflex::Literal("std::pair<const unsigned int,std::basic_string<char> >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3280, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8205), Reflex::Literal("pair"), constructor_3281, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3282, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3951, type_4981), Reflex::Literal("pair"), constructor_3283, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_876, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_constsunsignedsint_std__basic_string_char_s__datamem_bld);
}

//------Delayed data member builder for class pair<const unsigned int,std::basic_string<char, std::char_traits<char>, std::allocator<char> > > -------------------
void __std__pair_constsunsignedsint_std__basic_string_char_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_78c, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_constsunsignedsint_std__basic_string_char_s_, first), ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddDataMember(type_1104, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_constsunsignedsint_std__basic_string_char_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<const unsigned int,std::basic_string<char, std::char_traits<char>, std::allocator<char> > > -------------------
void __std__pair_constsunsignedsint_std__basic_string_char_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<const unsigned int,short int> -------------------------------
static void destructor_3288(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<const unsigned int,short>*)o)->::std::pair<const unsigned int,short>::~pair)();
}
static void constructor_3289( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned int,short>(*(const ::std::pair<const unsigned int,short>*)arg[0]);
  else ::new(mem) ::std::pair<const unsigned int,short>(*(const ::std::pair<const unsigned int,short>*)arg[0]);
}

static void constructor_3290( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned int,short>();
  else ::new(mem) ::std::pair<const unsigned int,short>();
}

static void constructor_3291( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned int,short>(*(const unsigned int*)arg[0],
      *(const short*)arg[1]);
  else ::new(mem) ::std::pair<const unsigned int,short>(*(const unsigned int*)arg[0],
      *(const short*)arg[1]);
}

static void method_newdel_877( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,short> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,short> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,short> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,short> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,short> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<const unsigned int,short int> -------------------------------
void __std__pair_constsunsignedsint_short__db_datamem(Reflex::Class*);
void __std__pair_constsunsignedsint_short__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_constsunsignedsint_short__datamem_bld(&__std__pair_constsunsignedsint_short__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_constsunsignedsint_short__funcmem_bld(&__std__pair_constsunsignedsint_short__db_funcmem);
void __std__pair_constsunsignedsint_short__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<const unsigned int,short>"), typeid(::std::pair<const unsigned int,short>), sizeof(::std::pair<const unsigned int,short>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_78c, Reflex::Literal("std::pair<const unsigned int,short>::first_type"))
  .AddTypedef(type_113, Reflex::Literal("std::pair<const unsigned int,short>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3288, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8310), Reflex::Literal("pair"), constructor_3289, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3290, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3951, type_4662), Reflex::Literal("pair"), constructor_3291, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_877, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_constsunsignedsint_short__datamem_bld);
}

//------Delayed data member builder for class pair<const unsigned int,short int> -------------------
void __std__pair_constsunsignedsint_short__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_78c, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_constsunsignedsint_short_, first), ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddDataMember(type_113, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_constsunsignedsint_short_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<const unsigned int,short int> -------------------
void __std__pair_constsunsignedsint_short__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<const unsigned int,int> -------------------------------
static void destructor_3296(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<const unsigned int,int>*)o)->::std::pair<const unsigned int,int>::~pair)();
}
static void constructor_3297( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned int,int>(*(const ::std::pair<const unsigned int,int>*)arg[0]);
  else ::new(mem) ::std::pair<const unsigned int,int>(*(const ::std::pair<const unsigned int,int>*)arg[0]);
}

static void constructor_3298( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned int,int>();
  else ::new(mem) ::std::pair<const unsigned int,int>();
}

static void constructor_3299( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned int,int>(*(const unsigned int*)arg[0],
      *(const int*)arg[1]);
  else ::new(mem) ::std::pair<const unsigned int,int>(*(const unsigned int*)arg[0],
      *(const int*)arg[1]);
}

static void method_newdel_878( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<const unsigned int,int> -------------------------------
void __std__pair_constsunsignedsint_int__db_datamem(Reflex::Class*);
void __std__pair_constsunsignedsint_int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_constsunsignedsint_int__datamem_bld(&__std__pair_constsunsignedsint_int__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_constsunsignedsint_int__funcmem_bld(&__std__pair_constsunsignedsint_int__db_funcmem);
void __std__pair_constsunsignedsint_int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<const unsigned int,int>"), typeid(::std::pair<const unsigned int,int>), sizeof(::std::pair<const unsigned int,int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_78c, Reflex::Literal("std::pair<const unsigned int,int>::first_type"))
  .AddTypedef(type_22, Reflex::Literal("std::pair<const unsigned int,int>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3296, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8415), Reflex::Literal("pair"), constructor_3297, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3298, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3951, type_4404), Reflex::Literal("pair"), constructor_3299, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_878, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_constsunsignedsint_int__datamem_bld);
}

//------Delayed data member builder for class pair<const unsigned int,int> -------------------
void __std__pair_constsunsignedsint_int__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_78c, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_constsunsignedsint_int_, first), ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddDataMember(type_22, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_constsunsignedsint_int_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<const unsigned int,int> -------------------
void __std__pair_constsunsignedsint_int__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<const unsigned int,float> -------------------------------
static void destructor_3304(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<const unsigned int,float>*)o)->::std::pair<const unsigned int,float>::~pair)();
}
static void constructor_3305( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned int,float>(*(const ::std::pair<const unsigned int,float>*)arg[0]);
  else ::new(mem) ::std::pair<const unsigned int,float>(*(const ::std::pair<const unsigned int,float>*)arg[0]);
}

static void constructor_3306( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned int,float>();
  else ::new(mem) ::std::pair<const unsigned int,float>();
}

static void constructor_3307( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned int,float>(*(const unsigned int*)arg[0],
      *(const float*)arg[1]);
  else ::new(mem) ::std::pair<const unsigned int,float>(*(const unsigned int*)arg[0],
      *(const float*)arg[1]);
}

static void method_newdel_879( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,float> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,float> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,float> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,float> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,float> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<const unsigned int,float> -------------------------------
void __std__pair_constsunsignedsint_float__db_datamem(Reflex::Class*);
void __std__pair_constsunsignedsint_float__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_constsunsignedsint_float__datamem_bld(&__std__pair_constsunsignedsint_float__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_constsunsignedsint_float__funcmem_bld(&__std__pair_constsunsignedsint_float__db_funcmem);
void __std__pair_constsunsignedsint_float__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<const unsigned int,float>"), typeid(::std::pair<const unsigned int,float>), sizeof(::std::pair<const unsigned int,float>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_78c, Reflex::Literal("std::pair<const unsigned int,float>::first_type"))
  .AddTypedef(type_2058, Reflex::Literal("std::pair<const unsigned int,float>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3304, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8520), Reflex::Literal("pair"), constructor_3305, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3306, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3951, type_4790), Reflex::Literal("pair"), constructor_3307, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_879, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_constsunsignedsint_float__datamem_bld);
}

//------Delayed data member builder for class pair<const unsigned int,float> -------------------
void __std__pair_constsunsignedsint_float__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_78c, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_constsunsignedsint_float_, first), ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddDataMember(type_2058, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_constsunsignedsint_float_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<const unsigned int,float> -------------------
void __std__pair_constsunsignedsint_float__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<const unsigned int,double> -------------------------------
static void destructor_3312(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<const unsigned int,double>*)o)->::std::pair<const unsigned int,double>::~pair)();
}
static void constructor_3313( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned int,double>(*(const ::std::pair<const unsigned int,double>*)arg[0]);
  else ::new(mem) ::std::pair<const unsigned int,double>(*(const ::std::pair<const unsigned int,double>*)arg[0]);
}

static void constructor_3314( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned int,double>();
  else ::new(mem) ::std::pair<const unsigned int,double>();
}

static void constructor_3315( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned int,double>(*(const unsigned int*)arg[0],
      *(const double*)arg[1]);
  else ::new(mem) ::std::pair<const unsigned int,double>(*(const unsigned int*)arg[0],
      *(const double*)arg[1]);
}

static void method_newdel_880( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,double> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,double> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,double> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,double> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,double> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<const unsigned int,double> -------------------------------
void __std__pair_constsunsignedsint_double__db_datamem(Reflex::Class*);
void __std__pair_constsunsignedsint_double__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_constsunsignedsint_double__datamem_bld(&__std__pair_constsunsignedsint_double__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_constsunsignedsint_double__funcmem_bld(&__std__pair_constsunsignedsint_double__db_funcmem);
void __std__pair_constsunsignedsint_double__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<const unsigned int,double>"), typeid(::std::pair<const unsigned int,double>), sizeof(::std::pair<const unsigned int,double>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_78c, Reflex::Literal("std::pair<const unsigned int,double>::first_type"))
  .AddTypedef(type_2052, Reflex::Literal("std::pair<const unsigned int,double>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3312, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8625), Reflex::Literal("pair"), constructor_3313, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3314, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3951, type_4918), Reflex::Literal("pair"), constructor_3315, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_880, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_constsunsignedsint_double__datamem_bld);
}

//------Delayed data member builder for class pair<const unsigned int,double> -------------------
void __std__pair_constsunsignedsint_double__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_78c, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_constsunsignedsint_double_, first), ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddDataMember(type_2052, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_constsunsignedsint_double_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<const unsigned int,double> -------------------
void __std__pair_constsunsignedsint_double__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<const unsigned int,bool> -------------------------------
static void destructor_3320(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<const unsigned int,bool>*)o)->::std::pair<const unsigned int,bool>::~pair)();
}
static void constructor_3321( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned int,bool>(*(const ::std::pair<const unsigned int,bool>*)arg[0]);
  else ::new(mem) ::std::pair<const unsigned int,bool>(*(const ::std::pair<const unsigned int,bool>*)arg[0]);
}

static void constructor_3322( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned int,bool>();
  else ::new(mem) ::std::pair<const unsigned int,bool>();
}

static void constructor_3323( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const unsigned int,bool>(*(const unsigned int*)arg[0],
      *(const bool*)arg[1]);
  else ::new(mem) ::std::pair<const unsigned int,bool>(*(const unsigned int*)arg[0],
      *(const bool*)arg[1]);
}

static void method_newdel_881( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,bool> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,bool> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,bool> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,bool> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<const unsigned int,bool> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<const unsigned int,bool> -------------------------------
void __std__pair_constsunsignedsint_bool__db_datamem(Reflex::Class*);
void __std__pair_constsunsignedsint_bool__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_constsunsignedsint_bool__datamem_bld(&__std__pair_constsunsignedsint_bool__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_constsunsignedsint_bool__funcmem_bld(&__std__pair_constsunsignedsint_bool__db_funcmem);
void __std__pair_constsunsignedsint_bool__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<const unsigned int,bool>"), typeid(::std::pair<const unsigned int,bool>), sizeof(::std::pair<const unsigned int,bool>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_78c, Reflex::Literal("std::pair<const unsigned int,bool>::first_type"))
  .AddTypedef(type_2083, Reflex::Literal("std::pair<const unsigned int,bool>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3320, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8730), Reflex::Literal("pair"), constructor_3321, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3322, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3951, type_11878), Reflex::Literal("pair"), constructor_3323, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_881, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_constsunsignedsint_bool__datamem_bld);
}

//------Delayed data member builder for class pair<const unsigned int,bool> -------------------
void __std__pair_constsunsignedsint_bool__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_78c, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_constsunsignedsint_bool_, first), ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddDataMember(type_2083, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_constsunsignedsint_bool_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<const unsigned int,bool> -------------------
void __std__pair_constsunsignedsint_bool__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<const std::pair<short int, short int>,std::pair<short int, std::vector<short int, std::allocator<short int> > > > -------------------------------
static void destructor_3328(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->::std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > >::~pair)();
}
static void constructor_3329( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > >(*(const ::std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > >*)arg[0]);
  else ::new(mem) ::std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > >(*(const ::std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > >*)arg[0]);
}

static void constructor_3330( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > >();
  else ::new(mem) ::std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > >();
}

static void constructor_3331( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > >(*(const ::std::pair<short,short>*)arg[0],
      *(const ::std::pair<short,std::vector<short> >*)arg[1]);
  else ::new(mem) ::std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > >(*(const ::std::pair<short,short>*)arg[0],
      *(const ::std::pair<short,std::vector<short> >*)arg[1]);
}

static void method_newdel_882( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<const std::pair<short int, short int>,std::pair<short int, std::vector<short int, std::allocator<short int> > > > -------------------------------
void __std__pair_constsstd__pair_short_short__std__pair_short_std__vector_short_s_s__db_datamem(Reflex::Class*);
void __std__pair_constsstd__pair_short_short__std__pair_short_std__vector_short_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_constsstd__pair_short_short__std__pair_short_std__vector_short_s_s__datamem_bld(&__std__pair_constsstd__pair_short_short__std__pair_short_std__vector_short_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_constsstd__pair_short_short__std__pair_short_std__vector_short_s_s__funcmem_bld(&__std__pair_constsstd__pair_short_short__std__pair_short_std__vector_short_s_s__db_funcmem);
void __std__pair_constsstd__pair_short_short__std__pair_short_std__vector_short_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > >"), typeid(::std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > >), sizeof(::std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_851c, Reflex::Literal("std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > >::first_type"))
  .AddTypedef(type_850, Reflex::Literal("std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3328, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8940), Reflex::Literal("pair"), constructor_3329, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3330, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20206, type_20207), Reflex::Literal("pair"), constructor_3331, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_882, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_constsstd__pair_short_short__std__pair_short_std__vector_short_s_s__datamem_bld);
}

//------Delayed data member builder for class pair<const std::pair<short int, short int>,std::pair<short int, std::vector<short int, std::allocator<short int> > > > -------------------
void __std__pair_constsstd__pair_short_short__std__pair_short_std__vector_short_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_851c, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_constsstd__pair_short_short__std__pair_short_std__vector_short_s_s_, first), ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddDataMember(type_850, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_constsstd__pair_short_short__std__pair_short_std__vector_short_s_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<const std::pair<short int, short int>,std::pair<short int, std::vector<short int, std::allocator<short int> > > > -------------------
void __std__pair_constsstd__pair_short_short__std__pair_short_std__vector_short_s_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<const std::pair<int, int>,int> -------------------------------
static void destructor_3336(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<const std::pair<int,int>,int>*)o)->::std::pair<const std::pair<int,int>,int>::~pair)();
}
static void constructor_3337( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const std::pair<int,int>,int>(*(const ::std::pair<const std::pair<int,int>,int>*)arg[0]);
  else ::new(mem) ::std::pair<const std::pair<int,int>,int>(*(const ::std::pair<const std::pair<int,int>,int>*)arg[0]);
}

static void constructor_3338( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const std::pair<int,int>,int>();
  else ::new(mem) ::std::pair<const std::pair<int,int>,int>();
}

static void constructor_3339( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const std::pair<int,int>,int>(*(const ::std::pair<int,int>*)arg[0],
      *(const int*)arg[1]);
  else ::new(mem) ::std::pair<const std::pair<int,int>,int>(*(const ::std::pair<int,int>*)arg[0],
      *(const int*)arg[1]);
}

static void method_newdel_883( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<const std::pair<int,int>,int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<const std::pair<int,int>,int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<const std::pair<int,int>,int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<const std::pair<int,int>,int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<const std::pair<int,int>,int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<const std::pair<int, int>,int> -------------------------------
void __std__pair_constsstd__pair_int_int__int__db_datamem(Reflex::Class*);
void __std__pair_constsstd__pair_int_int__int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_constsstd__pair_int_int__int__datamem_bld(&__std__pair_constsstd__pair_int_int__int__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_constsstd__pair_int_int__int__funcmem_bld(&__std__pair_constsstd__pair_int_int__int__db_funcmem);
void __std__pair_constsstd__pair_int_int__int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<const std::pair<int,int>,int>"), typeid(::std::pair<const std::pair<int,int>,int>), sizeof(::std::pair<const std::pair<int,int>,int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_825c, Reflex::Literal("std::pair<const std::pair<int,int>,int>::first_type"))
  .AddTypedef(type_22, Reflex::Literal("std::pair<const std::pair<int,int>,int>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3336, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9045), Reflex::Literal("pair"), constructor_3337, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3338, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5826, type_4404), Reflex::Literal("pair"), constructor_3339, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_883, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_constsstd__pair_int_int__int__datamem_bld);
}

//------Delayed data member builder for class pair<const std::pair<int, int>,int> -------------------
void __std__pair_constsstd__pair_int_int__int__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_825c, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_constsstd__pair_int_int__int_, first), ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddDataMember(type_22, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_constsstd__pair_int_int__int_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<const std::pair<int, int>,int> -------------------
void __std__pair_constsstd__pair_int_int__int__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >,unsigned int> -------------------------------
static void destructor_3344(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<const std::basic_string<char>,unsigned int>*)o)->::std::pair<const std::basic_string<char>,unsigned int>::~pair)();
}
static void constructor_3345( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const std::basic_string<char>,unsigned int>(*(const ::std::pair<const std::basic_string<char>,unsigned int>*)arg[0]);
  else ::new(mem) ::std::pair<const std::basic_string<char>,unsigned int>(*(const ::std::pair<const std::basic_string<char>,unsigned int>*)arg[0]);
}

static void constructor_3346( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const std::basic_string<char>,unsigned int>();
  else ::new(mem) ::std::pair<const std::basic_string<char>,unsigned int>();
}

static void constructor_3347( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const std::basic_string<char>,unsigned int>(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::std::pair<const std::basic_string<char>,unsigned int>(*(const ::std::basic_string<char>*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_884( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<const std::basic_string<char>,unsigned int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<const std::basic_string<char>,unsigned int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<const std::basic_string<char>,unsigned int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<const std::basic_string<char>,unsigned int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<const std::basic_string<char>,unsigned int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >,unsigned int> -------------------------------
void __std__pair_constsstd__basic_string_char__unsignedsint__db_datamem(Reflex::Class*);
void __std__pair_constsstd__basic_string_char__unsignedsint__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_constsstd__basic_string_char__unsignedsint__datamem_bld(&__std__pair_constsstd__basic_string_char__unsignedsint__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_constsstd__basic_string_char__unsignedsint__funcmem_bld(&__std__pair_constsstd__basic_string_char__unsignedsint__db_funcmem);
void __std__pair_constsstd__basic_string_char__unsignedsint__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<const std::basic_string<char>,unsigned int>"), typeid(::std::pair<const std::basic_string<char>,unsigned int>), sizeof(::std::pair<const std::basic_string<char>,unsigned int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_1104c, Reflex::Literal("std::pair<const std::basic_string<char>,unsigned int>::first_type"))
  .AddTypedef(type_78, Reflex::Literal("std::pair<const std::basic_string<char>,unsigned int>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3344, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9360), Reflex::Literal("pair"), constructor_3345, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3346, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4981, type_3951), Reflex::Literal("pair"), constructor_3347, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_884, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_constsstd__basic_string_char__unsignedsint__datamem_bld);
}

//------Delayed data member builder for class pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >,unsigned int> -------------------
void __std__pair_constsstd__basic_string_char__unsignedsint__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1104c, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_constsstd__basic_string_char__unsignedsint_, first), ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddDataMember(type_78, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_constsstd__basic_string_char__unsignedsint_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >,unsigned int> -------------------
void __std__pair_constsstd__basic_string_char__unsignedsint__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, double>, std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, double> > > > -------------------------------
static void destructor_3352(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->::std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >::~pair)();
}
static void constructor_3353( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >(*(const ::std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)arg[0]);
  else ::new(mem) ::std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >(*(const ::std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)arg[0]);
}

static void constructor_3354( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >();
  else ::new(mem) ::std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >();
}

static void constructor_3355( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >(*(const ::std::basic_string<char>*)arg[0],
      *(const ::std::vector<std::pair<std::basic_string<char>,double> >*)arg[1]);
  else ::new(mem) ::std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >(*(const ::std::basic_string<char>*)arg[0],
      *(const ::std::vector<std::pair<std::basic_string<char>,double> >*)arg[1]);
}

static void method_newdel_885( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, double>, std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, double> > > > -------------------------------
void __std__pair_constsstd__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s__db_datamem(Reflex::Class*);
void __std__pair_constsstd__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_constsstd__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s__datamem_bld(&__std__pair_constsstd__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_constsstd__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s__funcmem_bld(&__std__pair_constsstd__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s__db_funcmem);
void __std__pair_constsstd__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >"), typeid(::std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >), sizeof(::std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_1104c, Reflex::Literal("std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >::first_type"))
  .AddTypedef(type_1081, Reflex::Literal("std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3352, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9465), Reflex::Literal("pair"), constructor_3353, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3354, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4981, type_20216), Reflex::Literal("pair"), constructor_3355, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_885, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_constsstd__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s__datamem_bld);
}

//------Delayed data member builder for class pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, double>, std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, double> > > > -------------------
void __std__pair_constsstd__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1104c, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_constsstd__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s_, first), ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddDataMember(type_1081, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_constsstd__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, double>, std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, double> > > > -------------------
void __std__pair_constsstd__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------------------
static void destructor_3360(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->::std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > >::~pair)();
}
static void constructor_3361( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > >(*(const ::std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > >*)arg[0]);
  else ::new(mem) ::std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > >(*(const ::std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > >*)arg[0]);
}

static void constructor_3362( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > >();
  else ::new(mem) ::std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > >();
}

static void constructor_3363( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > >(*(const ::std::basic_string<char>*)arg[0],
      *(const ::std::vector<std::basic_string<char> >*)arg[1]);
  else ::new(mem) ::std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > >(*(const ::std::basic_string<char>*)arg[0],
      *(const ::std::vector<std::basic_string<char> >*)arg[1]);
}

static void method_newdel_886( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------------------
void __std__pair_constsstd__basic_string_char__std__vector_std__basic_string_char_s_s__db_datamem(Reflex::Class*);
void __std__pair_constsstd__basic_string_char__std__vector_std__basic_string_char_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_constsstd__basic_string_char__std__vector_std__basic_string_char_s_s__datamem_bld(&__std__pair_constsstd__basic_string_char__std__vector_std__basic_string_char_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_constsstd__basic_string_char__std__vector_std__basic_string_char_s_s__funcmem_bld(&__std__pair_constsstd__basic_string_char__std__vector_std__basic_string_char_s_s__db_funcmem);
void __std__pair_constsstd__basic_string_char__std__vector_std__basic_string_char_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > >"), typeid(::std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > >), sizeof(::std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_1104c, Reflex::Literal("std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > >::first_type"))
  .AddTypedef(type_1070, Reflex::Literal("std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3360, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9570), Reflex::Literal("pair"), constructor_3361, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3362, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4981, type_20219), Reflex::Literal("pair"), constructor_3363, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_886, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_constsstd__basic_string_char__std__vector_std__basic_string_char_s_s__datamem_bld);
}

//------Delayed data member builder for class pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------
void __std__pair_constsstd__basic_string_char__std__vector_std__basic_string_char_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1104c, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_constsstd__basic_string_char__std__vector_std__basic_string_char_s_s_, first), ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddDataMember(type_1070, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_constsstd__basic_string_char__std__vector_std__basic_string_char_s_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------
void __std__pair_constsstd__basic_string_char__std__vector_std__basic_string_char_s_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::pair<unsigned int, unsigned int> > -------------------------------
static void destructor_3368(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->::std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> >::~pair)();
}
static void constructor_3369( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> >(*(const ::std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)arg[0]);
  else ::new(mem) ::std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> >(*(const ::std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)arg[0]);
}

static void constructor_3370( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> >();
  else ::new(mem) ::std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> >();
}

static void constructor_3371( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> >(*(const ::std::basic_string<char>*)arg[0],
      *(const ::std::pair<unsigned int,unsigned int>*)arg[1]);
  else ::new(mem) ::std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> >(*(const ::std::basic_string<char>*)arg[0],
      *(const ::std::pair<unsigned int,unsigned int>*)arg[1]);
}

static void method_newdel_887( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::pair<unsigned int, unsigned int> > -------------------------------
void __std__pair_constsstd__basic_string_char__std__pair_unsignedsint_unsignedsint_s__db_datamem(Reflex::Class*);
void __std__pair_constsstd__basic_string_char__std__pair_unsignedsint_unsignedsint_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_constsstd__basic_string_char__std__pair_unsignedsint_unsignedsint_s__datamem_bld(&__std__pair_constsstd__basic_string_char__std__pair_unsignedsint_unsignedsint_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_constsstd__basic_string_char__std__pair_unsignedsint_unsignedsint_s__funcmem_bld(&__std__pair_constsstd__basic_string_char__std__pair_unsignedsint_unsignedsint_s__db_funcmem);
void __std__pair_constsstd__basic_string_char__std__pair_unsignedsint_unsignedsint_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> >"), typeid(::std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> >), sizeof(::std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_1104c, Reflex::Literal("std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> >::first_type"))
  .AddTypedef(type_814, Reflex::Literal("std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3368, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9675), Reflex::Literal("pair"), constructor_3369, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3370, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4981, type_5111), Reflex::Literal("pair"), constructor_3371, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_887, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_constsstd__basic_string_char__std__pair_unsignedsint_unsignedsint_s__datamem_bld);
}

//------Delayed data member builder for class pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::pair<unsigned int, unsigned int> > -------------------
void __std__pair_constsstd__basic_string_char__std__pair_unsignedsint_unsignedsint_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1104c, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_constsstd__basic_string_char__std__pair_unsignedsint_unsignedsint_s_, first), ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddDataMember(type_814, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_constsstd__basic_string_char__std__pair_unsignedsint_unsignedsint_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::pair<unsigned int, unsigned int> > -------------------
void __std__pair_constsstd__basic_string_char__std__pair_unsignedsint_unsignedsint_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > > -------------------------------
static void destructor_3376(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->::std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >::~pair)();
}
static void constructor_3377( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >(*(const ::std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)arg[0]);
  else ::new(mem) ::std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >(*(const ::std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)arg[0]);
}

static void constructor_3378( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >();
  else ::new(mem) ::std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >();
}

static void constructor_3379( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >(*(const ::std::basic_string<char>*)arg[0],
      *(const ::std::map<std::basic_string<char>,std::basic_string<char> >*)arg[1]);
  else ::new(mem) ::std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >(*(const ::std::basic_string<char>*)arg[0],
      *(const ::std::map<std::basic_string<char>,std::basic_string<char> >*)arg[1]);
}

static void method_newdel_888( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > > -------------------------------
void __std__pair_constsstd__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s__db_datamem(Reflex::Class*);
void __std__pair_constsstd__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_constsstd__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s__datamem_bld(&__std__pair_constsstd__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_constsstd__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s__funcmem_bld(&__std__pair_constsstd__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s__db_funcmem);
void __std__pair_constsstd__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >"), typeid(::std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >), sizeof(::std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_1104c, Reflex::Literal("std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >::first_type"))
  .AddTypedef(type_1615, Reflex::Literal("std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3376, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9780), Reflex::Literal("pair"), constructor_3377, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3378, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4981, type_20224), Reflex::Literal("pair"), constructor_3379, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_888, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_constsstd__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s__datamem_bld);
}

//------Delayed data member builder for class pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > > -------------------
void __std__pair_constsstd__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1104c, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_constsstd__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s_, first), ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddDataMember(type_1615, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_constsstd__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > > -------------------
void __std__pair_constsstd__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >,int> -------------------------------
static void destructor_3384(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<const std::basic_string<char>,int>*)o)->::std::pair<const std::basic_string<char>,int>::~pair)();
}
static void constructor_3385( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const std::basic_string<char>,int>(*(const ::std::pair<const std::basic_string<char>,int>*)arg[0]);
  else ::new(mem) ::std::pair<const std::basic_string<char>,int>(*(const ::std::pair<const std::basic_string<char>,int>*)arg[0]);
}

static void constructor_3386( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const std::basic_string<char>,int>();
  else ::new(mem) ::std::pair<const std::basic_string<char>,int>();
}

static void constructor_3387( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const std::basic_string<char>,int>(*(const ::std::basic_string<char>*)arg[0],
      *(const int*)arg[1]);
  else ::new(mem) ::std::pair<const std::basic_string<char>,int>(*(const ::std::basic_string<char>*)arg[0],
      *(const int*)arg[1]);
}

static void method_newdel_889( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<const std::basic_string<char>,int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<const std::basic_string<char>,int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<const std::basic_string<char>,int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<const std::basic_string<char>,int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<const std::basic_string<char>,int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >,int> -------------------------------
void __std__pair_constsstd__basic_string_char__int__db_datamem(Reflex::Class*);
void __std__pair_constsstd__basic_string_char__int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_constsstd__basic_string_char__int__datamem_bld(&__std__pair_constsstd__basic_string_char__int__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_constsstd__basic_string_char__int__funcmem_bld(&__std__pair_constsstd__basic_string_char__int__db_funcmem);
void __std__pair_constsstd__basic_string_char__int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<const std::basic_string<char>,int>"), typeid(::std::pair<const std::basic_string<char>,int>), sizeof(::std::pair<const std::basic_string<char>,int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_1104c, Reflex::Literal("std::pair<const std::basic_string<char>,int>::first_type"))
  .AddTypedef(type_22, Reflex::Literal("std::pair<const std::basic_string<char>,int>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3384, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9885), Reflex::Literal("pair"), constructor_3385, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3386, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4981, type_4404), Reflex::Literal("pair"), constructor_3387, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_889, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_constsstd__basic_string_char__int__datamem_bld);
}

//------Delayed data member builder for class pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >,int> -------------------
void __std__pair_constsstd__basic_string_char__int__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1104c, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_constsstd__basic_string_char__int_, first), ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddDataMember(type_22, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_constsstd__basic_string_char__int_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >,int> -------------------
void __std__pair_constsstd__basic_string_char__int__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >,bool> -------------------------------
static void destructor_3392(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<const std::basic_string<char>,bool>*)o)->::std::pair<const std::basic_string<char>,bool>::~pair)();
}
static void constructor_3393( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const std::basic_string<char>,bool>(*(const ::std::pair<const std::basic_string<char>,bool>*)arg[0]);
  else ::new(mem) ::std::pair<const std::basic_string<char>,bool>(*(const ::std::pair<const std::basic_string<char>,bool>*)arg[0]);
}

static void constructor_3394( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const std::basic_string<char>,bool>();
  else ::new(mem) ::std::pair<const std::basic_string<char>,bool>();
}

static void constructor_3395( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const std::basic_string<char>,bool>(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
  else ::new(mem) ::std::pair<const std::basic_string<char>,bool>(*(const ::std::basic_string<char>*)arg[0],
      *(const bool*)arg[1]);
}

static void method_newdel_890( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<const std::basic_string<char>,bool> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<const std::basic_string<char>,bool> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<const std::basic_string<char>,bool> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<const std::basic_string<char>,bool> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<const std::basic_string<char>,bool> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >,bool> -------------------------------
void __std__pair_constsstd__basic_string_char__bool__db_datamem(Reflex::Class*);
void __std__pair_constsstd__basic_string_char__bool__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_constsstd__basic_string_char__bool__datamem_bld(&__std__pair_constsstd__basic_string_char__bool__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_constsstd__basic_string_char__bool__funcmem_bld(&__std__pair_constsstd__basic_string_char__bool__db_funcmem);
void __std__pair_constsstd__basic_string_char__bool__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<const std::basic_string<char>,bool>"), typeid(::std::pair<const std::basic_string<char>,bool>), sizeof(::std::pair<const std::basic_string<char>,bool>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_1104c, Reflex::Literal("std::pair<const std::basic_string<char>,bool>::first_type"))
  .AddTypedef(type_2083, Reflex::Literal("std::pair<const std::basic_string<char>,bool>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3392, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9990), Reflex::Literal("pair"), constructor_3393, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3394, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4981, type_11878), Reflex::Literal("pair"), constructor_3395, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_890, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_constsstd__basic_string_char__bool__datamem_bld);
}

//------Delayed data member builder for class pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >,bool> -------------------
void __std__pair_constsstd__basic_string_char__bool__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1104c, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_constsstd__basic_string_char__bool_, first), ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddDataMember(type_2083, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_constsstd__basic_string_char__bool_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >,bool> -------------------
void __std__pair_constsstd__basic_string_char__bool__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<const short int,unsigned int> -------------------------------
static void destructor_3400(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<const short,unsigned int>*)o)->::std::pair<const short,unsigned int>::~pair)();
}
static void constructor_3401( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const short,unsigned int>(*(const ::std::pair<const short,unsigned int>*)arg[0]);
  else ::new(mem) ::std::pair<const short,unsigned int>(*(const ::std::pair<const short,unsigned int>*)arg[0]);
}

static void constructor_3402( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const short,unsigned int>();
  else ::new(mem) ::std::pair<const short,unsigned int>();
}

static void constructor_3403( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const short,unsigned int>(*(const short*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::std::pair<const short,unsigned int>(*(const short*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_891( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<const short,unsigned int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<const short,unsigned int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<const short,unsigned int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<const short,unsigned int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<const short,unsigned int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<const short int,unsigned int> -------------------------------
void __std__pair_constsshort_unsignedsint__db_datamem(Reflex::Class*);
void __std__pair_constsshort_unsignedsint__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_constsshort_unsignedsint__datamem_bld(&__std__pair_constsshort_unsignedsint__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_constsshort_unsignedsint__funcmem_bld(&__std__pair_constsshort_unsignedsint__db_funcmem);
void __std__pair_constsshort_unsignedsint__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<const short,unsigned int>"), typeid(::std::pair<const short,unsigned int>), sizeof(::std::pair<const short,unsigned int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_113c, Reflex::Literal("std::pair<const short,unsigned int>::first_type"))
  .AddTypedef(type_78, Reflex::Literal("std::pair<const short,unsigned int>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3400, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10095), Reflex::Literal("pair"), constructor_3401, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3402, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4662, type_3951), Reflex::Literal("pair"), constructor_3403, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_891, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_constsshort_unsignedsint__datamem_bld);
}

//------Delayed data member builder for class pair<const short int,unsigned int> -------------------
void __std__pair_constsshort_unsignedsint__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_113c, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_constsshort_unsignedsint_, first), ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddDataMember(type_78, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_constsshort_unsignedsint_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<const short int,unsigned int> -------------------
void __std__pair_constsshort_unsignedsint__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<const int,unsigned int> -------------------------------
static void destructor_3408(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<const int,unsigned int>*)o)->::std::pair<const int,unsigned int>::~pair)();
}
static void constructor_3409( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const int,unsigned int>(*(const ::std::pair<const int,unsigned int>*)arg[0]);
  else ::new(mem) ::std::pair<const int,unsigned int>(*(const ::std::pair<const int,unsigned int>*)arg[0]);
}

static void constructor_3410( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const int,unsigned int>();
  else ::new(mem) ::std::pair<const int,unsigned int>();
}

static void constructor_3411( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const int,unsigned int>(*(const int*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::std::pair<const int,unsigned int>(*(const int*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_892( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<const int,unsigned int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<const int,unsigned int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<const int,unsigned int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<const int,unsigned int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<const int,unsigned int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<const int,unsigned int> -------------------------------
void __std__pair_constsint_unsignedsint__db_datamem(Reflex::Class*);
void __std__pair_constsint_unsignedsint__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_constsint_unsignedsint__datamem_bld(&__std__pair_constsint_unsignedsint__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_constsint_unsignedsint__funcmem_bld(&__std__pair_constsint_unsignedsint__db_funcmem);
void __std__pair_constsint_unsignedsint__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<const int,unsigned int>"), typeid(::std::pair<const int,unsigned int>), sizeof(::std::pair<const int,unsigned int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_22c, Reflex::Literal("std::pair<const int,unsigned int>::first_type"))
  .AddTypedef(type_78, Reflex::Literal("std::pair<const int,unsigned int>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3408, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10305), Reflex::Literal("pair"), constructor_3409, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3410, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4404, type_3951), Reflex::Literal("pair"), constructor_3411, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_892, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_constsint_unsignedsint__datamem_bld);
}

//------Delayed data member builder for class pair<const int,unsigned int> -------------------
void __std__pair_constsint_unsignedsint__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_22c, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_constsint_unsignedsint_, first), ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddDataMember(type_78, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_constsint_unsignedsint_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<const int,unsigned int> -------------------
void __std__pair_constsint_unsignedsint__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<const int,std::pair<long unsigned int, long unsigned int> > -------------------------------
static void destructor_3416(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<const int,std::pair<unsigned long,unsigned long> >*)o)->::std::pair<const int,std::pair<unsigned long,unsigned long> >::~pair)();
}
static void constructor_3417( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const int,std::pair<unsigned long,unsigned long> >(*(const ::std::pair<const int,std::pair<unsigned long,unsigned long> >*)arg[0]);
  else ::new(mem) ::std::pair<const int,std::pair<unsigned long,unsigned long> >(*(const ::std::pair<const int,std::pair<unsigned long,unsigned long> >*)arg[0]);
}

static void constructor_3418( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const int,std::pair<unsigned long,unsigned long> >();
  else ::new(mem) ::std::pair<const int,std::pair<unsigned long,unsigned long> >();
}

static void constructor_3419( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const int,std::pair<unsigned long,unsigned long> >(*(const int*)arg[0],
      *(const ::std::pair<unsigned long,unsigned long>*)arg[1]);
  else ::new(mem) ::std::pair<const int,std::pair<unsigned long,unsigned long> >(*(const int*)arg[0],
      *(const ::std::pair<unsigned long,unsigned long>*)arg[1]);
}

static void method_newdel_893( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<const int,std::pair<unsigned long,unsigned long> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<const int,std::pair<unsigned long,unsigned long> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<const int,std::pair<unsigned long,unsigned long> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<const int,std::pair<unsigned long,unsigned long> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<const int,std::pair<unsigned long,unsigned long> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<const int,std::pair<long unsigned int, long unsigned int> > -------------------------------
void __std__pair_constsint_std__pair_unsignedslong_unsignedslong_s__db_datamem(Reflex::Class*);
void __std__pair_constsint_std__pair_unsignedslong_unsignedslong_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_constsint_std__pair_unsignedslong_unsignedslong_s__datamem_bld(&__std__pair_constsint_std__pair_unsignedslong_unsignedslong_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_constsint_std__pair_unsignedslong_unsignedslong_s__funcmem_bld(&__std__pair_constsint_std__pair_unsignedslong_unsignedslong_s__db_funcmem);
void __std__pair_constsint_std__pair_unsignedslong_unsignedslong_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<const int,std::pair<unsigned long,unsigned long> >"), typeid(::std::pair<const int,std::pair<unsigned long,unsigned long> >), sizeof(::std::pair<const int,std::pair<unsigned long,unsigned long> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_22c, Reflex::Literal("std::pair<const int,std::pair<unsigned long,unsigned long> >::first_type"))
  .AddTypedef(type_840, Reflex::Literal("std::pair<const int,std::pair<unsigned long,unsigned long> >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3416, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10410), Reflex::Literal("pair"), constructor_3417, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3418, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4404, type_20184), Reflex::Literal("pair"), constructor_3419, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_893, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_constsint_std__pair_unsignedslong_unsignedslong_s__datamem_bld);
}

//------Delayed data member builder for class pair<const int,std::pair<long unsigned int, long unsigned int> > -------------------
void __std__pair_constsint_std__pair_unsignedslong_unsignedslong_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_22c, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_constsint_std__pair_unsignedslong_unsignedslong_s_, first), ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddDataMember(type_840, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_constsint_std__pair_unsignedslong_unsignedslong_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<const int,std::pair<long unsigned int, long unsigned int> > -------------------
void __std__pair_constsint_std__pair_unsignedslong_unsignedslong_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<const int,std::pair<unsigned int, unsigned int> > -------------------------------
static void destructor_3424(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<const int,std::pair<unsigned int,unsigned int> >*)o)->::std::pair<const int,std::pair<unsigned int,unsigned int> >::~pair)();
}
static void constructor_3425( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const int,std::pair<unsigned int,unsigned int> >(*(const ::std::pair<const int,std::pair<unsigned int,unsigned int> >*)arg[0]);
  else ::new(mem) ::std::pair<const int,std::pair<unsigned int,unsigned int> >(*(const ::std::pair<const int,std::pair<unsigned int,unsigned int> >*)arg[0]);
}

static void constructor_3426( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const int,std::pair<unsigned int,unsigned int> >();
  else ::new(mem) ::std::pair<const int,std::pair<unsigned int,unsigned int> >();
}

static void constructor_3427( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const int,std::pair<unsigned int,unsigned int> >(*(const int*)arg[0],
      *(const ::std::pair<unsigned int,unsigned int>*)arg[1]);
  else ::new(mem) ::std::pair<const int,std::pair<unsigned int,unsigned int> >(*(const int*)arg[0],
      *(const ::std::pair<unsigned int,unsigned int>*)arg[1]);
}

static void method_newdel_894( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<const int,std::pair<unsigned int,unsigned int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<const int,std::pair<unsigned int,unsigned int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<const int,std::pair<unsigned int,unsigned int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<const int,std::pair<unsigned int,unsigned int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<const int,std::pair<unsigned int,unsigned int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<const int,std::pair<unsigned int, unsigned int> > -------------------------------
void __std__pair_constsint_std__pair_unsignedsint_unsignedsint_s__db_datamem(Reflex::Class*);
void __std__pair_constsint_std__pair_unsignedsint_unsignedsint_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_constsint_std__pair_unsignedsint_unsignedsint_s__datamem_bld(&__std__pair_constsint_std__pair_unsignedsint_unsignedsint_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_constsint_std__pair_unsignedsint_unsignedsint_s__funcmem_bld(&__std__pair_constsint_std__pair_unsignedsint_unsignedsint_s__db_funcmem);
void __std__pair_constsint_std__pair_unsignedsint_unsignedsint_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<const int,std::pair<unsigned int,unsigned int> >"), typeid(::std::pair<const int,std::pair<unsigned int,unsigned int> >), sizeof(::std::pair<const int,std::pair<unsigned int,unsigned int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_22c, Reflex::Literal("std::pair<const int,std::pair<unsigned int,unsigned int> >::first_type"))
  .AddTypedef(type_814, Reflex::Literal("std::pair<const int,std::pair<unsigned int,unsigned int> >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3424, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10515), Reflex::Literal("pair"), constructor_3425, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3426, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4404, type_5111), Reflex::Literal("pair"), constructor_3427, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_894, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_constsint_std__pair_unsignedsint_unsignedsint_s__datamem_bld);
}

//------Delayed data member builder for class pair<const int,std::pair<unsigned int, unsigned int> > -------------------
void __std__pair_constsint_std__pair_unsignedsint_unsignedsint_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_22c, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_constsint_std__pair_unsignedsint_unsignedsint_s_, first), ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddDataMember(type_814, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_constsint_std__pair_unsignedsint_unsignedsint_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<const int,std::pair<unsigned int, unsigned int> > -------------------
void __std__pair_constsint_std__pair_unsignedsint_unsignedsint_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<const int,std::pair<double, double> > -------------------------------
static void destructor_3432(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<const int,std::pair<double,double> >*)o)->::std::pair<const int,std::pair<double,double> >::~pair)();
}
static void constructor_3433( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const int,std::pair<double,double> >(*(const ::std::pair<const int,std::pair<double,double> >*)arg[0]);
  else ::new(mem) ::std::pair<const int,std::pair<double,double> >(*(const ::std::pair<const int,std::pair<double,double> >*)arg[0]);
}

static void constructor_3434( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const int,std::pair<double,double> >();
  else ::new(mem) ::std::pair<const int,std::pair<double,double> >();
}

static void constructor_3435( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const int,std::pair<double,double> >(*(const int*)arg[0],
      *(const ::std::pair<double,double>*)arg[1]);
  else ::new(mem) ::std::pair<const int,std::pair<double,double> >(*(const int*)arg[0],
      *(const ::std::pair<double,double>*)arg[1]);
}

static void method_newdel_895( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<const int,std::pair<double,double> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<const int,std::pair<double,double> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<const int,std::pair<double,double> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<const int,std::pair<double,double> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<const int,std::pair<double,double> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<const int,std::pair<double, double> > -------------------------------
void __std__pair_constsint_std__pair_double_double_s__db_datamem(Reflex::Class*);
void __std__pair_constsint_std__pair_double_double_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_constsint_std__pair_double_double_s__datamem_bld(&__std__pair_constsint_std__pair_double_double_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_constsint_std__pair_double_double_s__funcmem_bld(&__std__pair_constsint_std__pair_double_double_s__db_funcmem);
void __std__pair_constsint_std__pair_double_double_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<const int,std::pair<double,double> >"), typeid(::std::pair<const int,std::pair<double,double> >), sizeof(::std::pair<const int,std::pair<double,double> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_22c, Reflex::Literal("std::pair<const int,std::pair<double,double> >::first_type"))
  .AddTypedef(type_827, Reflex::Literal("std::pair<const int,std::pair<double,double> >::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3432, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10620), Reflex::Literal("pair"), constructor_3433, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3434, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4404, type_5956), Reflex::Literal("pair"), constructor_3435, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_895, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_constsint_std__pair_double_double_s__datamem_bld);
}

//------Delayed data member builder for class pair<const int,std::pair<double, double> > -------------------
void __std__pair_constsint_std__pair_double_double_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_22c, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_constsint_std__pair_double_double_s_, first), ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddDataMember(type_827, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_constsint_std__pair_double_double_s_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<const int,std::pair<double, double> > -------------------
void __std__pair_constsint_std__pair_double_double_s__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class pair<const int,int> -------------------------------
static void destructor_3440(void*, void * o, const std::vector<void*>&, void *) {
(((::std::pair<const int,int>*)o)->::std::pair<const int,int>::~pair)();
}
static void constructor_3441( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const int,int>(*(const ::std::pair<const int,int>*)arg[0]);
  else ::new(mem) ::std::pair<const int,int>(*(const ::std::pair<const int,int>*)arg[0]);
}

static void constructor_3442( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const int,int>();
  else ::new(mem) ::std::pair<const int,int>();
}

static void constructor_3443( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::pair<const int,int>(*(const int*)arg[0],
      *(const int*)arg[1]);
  else ::new(mem) ::std::pair<const int,int>(*(const int*)arg[0],
      *(const int*)arg[1]);
}

static void method_newdel_896( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::pair<const int,int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::pair<const int,int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::pair<const int,int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::pair<const int,int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::pair<const int,int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class pair<const int,int> -------------------------------
void __std__pair_constsint_int__db_datamem(Reflex::Class*);
void __std__pair_constsint_int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__pair_constsint_int__datamem_bld(&__std__pair_constsint_int__db_datamem);
Reflex::GenreflexMemberBuilder __std__pair_constsint_int__funcmem_bld(&__std__pair_constsint_int__db_funcmem);
void __std__pair_constsint_int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::pair<const int,int>"), typeid(::std::pair<const int,int>), sizeof(::std::pair<const int,int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddTypedef(type_22c, Reflex::Literal("std::pair<const int,int>::first_type"))
  .AddTypedef(type_22, Reflex::Literal("std::pair<const int,int>::second_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~pair"), destructor_3440, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10725), Reflex::Literal("pair"), constructor_3441, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("pair"), constructor_3442, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4404, type_4404), Reflex::Literal("pair"), constructor_3443, 0, "__a;__b", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_896, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__pair_constsint_int__datamem_bld);
}

//------Delayed data member builder for class pair<const int,int> -------------------
void __std__pair_constsint_int__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_22c, Reflex::Literal("first"), OffsetOf(__shadow__::__std__pair_constsint_int_, first), ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddDataMember(type_22, Reflex::Literal("second"), OffsetOf(__shadow__::__std__pair_constsint_int_, second), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class pair<const int,int> -------------------
void __std__pair_constsint_int__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class input_iterator_tag -------------------------------
static void destructor_3444(void*, void * o, const std::vector<void*>&, void *) {
(((::std::input_iterator_tag*)o)->::std::input_iterator_tag::~input_iterator_tag)();
}
static  void operator_3445( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::input_iterator_tag*)o)->operator=)(*(const ::std::input_iterator_tag*)arg[0]);
  else   (((::std::input_iterator_tag*)o)->operator=)(*(const ::std::input_iterator_tag*)arg[0]);
}

static void constructor_3446( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::input_iterator_tag(*(const ::std::input_iterator_tag*)arg[0]);
  else ::new(mem) ::std::input_iterator_tag(*(const ::std::input_iterator_tag*)arg[0]);
}

static void constructor_3447( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::input_iterator_tag();
  else ::new(mem) ::std::input_iterator_tag();
}

static void method_newdel_1018( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::input_iterator_tag >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::input_iterator_tag >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::input_iterator_tag >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::input_iterator_tag >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::input_iterator_tag >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class input_iterator_tag -------------------------------
void __std__input_iterator_tag_db_datamem(Reflex::Class*);
void __std__input_iterator_tag_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__input_iterator_tag_datamem_bld(&__std__input_iterator_tag_db_datamem);
Reflex::GenreflexMemberBuilder __std__input_iterator_tag_funcmem_bld(&__std__input_iterator_tag_db_funcmem);
void __std__input_iterator_tag_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::input_iterator_tag"), typeid(::std::input_iterator_tag), sizeof(::std::input_iterator_tag), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~input_iterator_tag"), destructor_3444, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20244, type_20245), Reflex::Literal("operator="), operator_3445, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20245), Reflex::Literal("input_iterator_tag"), constructor_3446, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("input_iterator_tag"), constructor_3447, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1018, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class input_iterator_tag -------------------
void __std__input_iterator_tag_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class input_iterator_tag -------------------
void __std__input_iterator_tag_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<const void*,std::allocator<const void*> > -------------------------------
static void constructor_3645( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<const void*>();
  else ::new(mem) ::std::vector<const void*>();
}

static void constructor_3646( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<const void*>(*(const ::std::allocator<const void*>*)arg[0]);
  else ::new(mem) ::std::vector<const void*>(*(const ::std::allocator<const void*>*)arg[0]);
}

static void constructor_3647( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<const void*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<const void*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<const void*>(*(::std::size_t*)arg[0],
      *(const void* const*)arg[1]);
  else ::new(mem) ::std::vector<const void*>(*(::std::size_t*)arg[0],
      *(const void* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<const void*>(*(::std::size_t*)arg[0],
      *(const void* const*)arg[1],
      *(const ::std::allocator<const void*>*)arg[2]);
  else ::new(mem) ::std::vector<const void*>(*(::std::size_t*)arg[0],
      *(const void* const*)arg[1],
      *(const ::std::allocator<const void*>*)arg[2]);
  }
}

static void constructor_3648( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<const void*>(*(const ::std::vector<const void*>*)arg[0]);
  else ::new(mem) ::std::vector<const void*>(*(const ::std::vector<const void*>*)arg[0]);
}

static void destructor_3649(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<const void*>*)o)->::std::vector<const void*>::~vector)();
}
static  void operator_3650( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<const void*>*)o)->operator=)(*(const ::std::vector<const void*>*)arg[0]);
  else   (((::std::vector<const void*>*)o)->operator=)(*(const ::std::vector<const void*>*)arg[0]);
}

static  void method_3651( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<const void*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const void* const*)arg[1]);
}

static  void method_3652( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const void**,std::vector<const void*> >)((((::std::vector<const void*>*)o)->begin)());
  else   (((::std::vector<const void*>*)o)->begin)();
}

static  void method_3653( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const void* const*,std::vector<const void*> >)((((const ::std::vector<const void*>*)o)->begin)());
  else   (((const ::std::vector<const void*>*)o)->begin)();
}

static  void method_3654( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const void**,std::vector<const void*> >)((((::std::vector<const void*>*)o)->end)());
  else   (((::std::vector<const void*>*)o)->end)();
}

static  void method_3655( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const void* const*,std::vector<const void*> >)((((const ::std::vector<const void*>*)o)->end)());
  else   (((const ::std::vector<const void*>*)o)->end)();
}

static  void method_3660( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<const void*>*)o)->size)());
  else   (((const ::std::vector<const void*>*)o)->size)();
}

static  void method_3661( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<const void*>*)o)->max_size)());
  else   (((const ::std::vector<const void*>*)o)->max_size)();
}

static  void method_3662( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<const void*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<const void*>*)o)->resize)(*(::std::size_t*)arg[0],
      (const void*)arg[1]);
  }
}

static  void method_3663( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<const void*>*)o)->capacity)());
  else   (((const ::std::vector<const void*>*)o)->capacity)();
}

static  void method_3664( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<const void*>*)o)->empty)());
  else   (((const ::std::vector<const void*>*)o)->empty)();
}

static  void method_3665( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<const void*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_3666( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<const void*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<const void*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_3667( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<const void*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<const void*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_3669( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<const void*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<const void*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3670( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<const void*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<const void*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3671( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<const void*>*)o)->front)();
  else   (((::std::vector<const void*>*)o)->front)();
}

static  void method_3672( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<const void*>*)o)->front)();
  else   (((const ::std::vector<const void*>*)o)->front)();
}

static  void method_3673( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<const void*>*)o)->back)();
  else   (((::std::vector<const void*>*)o)->back)();
}

static  void method_3674( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<const void*>*)o)->back)();
  else   (((const ::std::vector<const void*>*)o)->back)();
}

static  void method_3675( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<const void*>*)o)->data)());
  else   (((::std::vector<const void*>*)o)->data)();
}

static  void method_3676( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<const void*>*)o)->data)());
  else   (((const ::std::vector<const void*>*)o)->data)();
}

static  void method_3677( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<const void*>*)o)->push_back)(*(const void* const*)arg[0]);
}

static  void method_3678( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<const void*>*)o)->pop_back)();
}

static  void method_3679( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const void**,std::vector<const void*> >)((((::std::vector<const void*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<const void**,std::vector<const void*> >*)arg[0],
    *(const void* const*)arg[1]));
  else   (((::std::vector<const void*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<const void**,std::vector<const void*> >*)arg[0],
    *(const void* const*)arg[1]);
}

static  void method_3680( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<const void*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<const void**,std::vector<const void*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const void* const*)arg[2]);
}

static  void method_3681( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const void**,std::vector<const void*> >)((((::std::vector<const void*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<const void**,std::vector<const void*> >*)arg[0]));
  else   (((::std::vector<const void*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<const void**,std::vector<const void*> >*)arg[0]);
}

static  void method_3682( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const void**,std::vector<const void*> >)((((::std::vector<const void*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<const void**,std::vector<const void*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<const void**,std::vector<const void*> >*)arg[1]));
  else   (((::std::vector<const void*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<const void**,std::vector<const void*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<const void**,std::vector<const void*> >*)arg[1]);
}

static  void method_3683( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<const void*>*)o)->swap)(*(::std::vector<const void*>*)arg[0]);
}

static  void method_3684( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<const void*>*)o)->clear)();
}

static void method_newdel_1049( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<const void*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<const void*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<const void*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<const void*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<const void*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x79( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<const void*,std::allocator<const void*> >")), ::Reflex::BaseOffset< ::std::vector<const void*>,::std::_Vector_base<const void*,std::allocator<const void*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x80( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<const void*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<const void*> >::Generate();
}

//------Dictionary for class vector<const void*,std::allocator<const void*> > -------------------------------
void __std__vector_constsvoidp__db_datamem(Reflex::Class*);
void __std__vector_constsvoidp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_constsvoidp__datamem_bld(&__std__vector_constsvoidp__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_constsvoidp__funcmem_bld(&__std__vector_constsvoidp__db_funcmem);
void __std__vector_constsvoidp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<const void*>"), typeid(::std::vector<const void*>), sizeof(::std::vector<const void*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1946, ::Reflex::BaseOffset< ::std::vector<const void*>, ::std::_Vector_base<const void*,std::allocator<const void*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2418, Reflex::Literal("std::vector<const void*>::_Alloc_value_type"))
  .AddTypedef(type_1946, Reflex::Literal("std::vector<const void*>::_Base"))
  .AddTypedef(type_1327, Reflex::Literal("std::vector<const void*>::_Tp_alloc_type"))
  .AddTypedef(type_2418, Reflex::Literal("std::vector<const void*>::value_type"))
  .AddTypedef(type_3630, Reflex::Literal("std::vector<const void*>::pointer"))
  .AddTypedef(type_3632, Reflex::Literal("std::vector<const void*>::const_pointer"))
  .AddTypedef(type_3634, Reflex::Literal("std::vector<const void*>::reference"))
  .AddTypedef(type_3636, Reflex::Literal("std::vector<const void*>::const_reference"))
  .AddTypedef(type_2308, Reflex::Literal("std::vector<const void*>::iterator"))
  .AddTypedef(type_2309, Reflex::Literal("std::vector<const void*>::const_iterator"))
  .AddTypedef(type_1706, Reflex::Literal("std::vector<const void*>::const_reverse_iterator"))
  .AddTypedef(type_1707, Reflex::Literal("std::vector<const void*>::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<const void*>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<const void*>::difference_type"))
  .AddTypedef(type_1327, Reflex::Literal("std::vector<const void*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_3645, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20283), Reflex::Literal("vector"), constructor_3646, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_3636, type_20283), Reflex::Literal("vector"), constructor_3647, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20284), Reflex::Literal("vector"), constructor_3648, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_3649, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1049, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x79, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x80, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_constsvoidp__funcmem_bld);
}

//------Delayed data member builder for class vector<const void*,std::allocator<const void*> > -------------------
void __std__vector_constsvoidp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<const void*,std::allocator<const void*> > -------------------
void __std__vector_constsvoidp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20285, type_20284), Reflex::Literal("operator="), operator_3650, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_3636), Reflex::Literal("assign"), method_3651, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2308), Reflex::Literal("begin"), method_3652, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2309), Reflex::Literal("begin"), method_3653, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2308), Reflex::Literal("end"), method_3654, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2309), Reflex::Literal("end"), method_3655, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_3660, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_3661, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_2418), Reflex::Literal("resize"), method_3662, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_3663, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_3664, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_3665, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3634, type_1654), Reflex::Literal("operator[]"), operator_3666, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3636, type_1654), Reflex::Literal("operator[]"), operator_3667, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3634, type_1654), Reflex::Literal("at"), method_3669, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3636, type_1654), Reflex::Literal("at"), method_3670, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3634), Reflex::Literal("front"), method_3671, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3636), Reflex::Literal("front"), method_3672, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3634), Reflex::Literal("back"), method_3673, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3636), Reflex::Literal("back"), method_3674, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3630), Reflex::Literal("data"), method_3675, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3632), Reflex::Literal("data"), method_3676, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_3636), Reflex::Literal("push_back"), method_3677, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_3678, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2308, type_2308, type_3636), Reflex::Literal("insert"), method_3679, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2308, type_1654, type_3636), Reflex::Literal("insert"), method_3680, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2308, type_2308), Reflex::Literal("erase"), method_3681, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2308, type_2308, type_2308), Reflex::Literal("erase"), method_3682, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_20285), Reflex::Literal("swap"), method_3683, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_3684, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<short unsigned int,std::allocator<short unsigned int> > -------------------------------
static void constructor_3771( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned short>();
  else ::new(mem) ::std::vector<unsigned short>();
}

static void constructor_3772( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned short>(*(const ::std::allocator<unsigned short>*)arg[0]);
  else ::new(mem) ::std::vector<unsigned short>(*(const ::std::allocator<unsigned short>*)arg[0]);
}

static void constructor_3773( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned short>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<unsigned short>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned short>(*(::std::size_t*)arg[0],
      *(const unsigned short*)arg[1]);
  else ::new(mem) ::std::vector<unsigned short>(*(::std::size_t*)arg[0],
      *(const unsigned short*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned short>(*(::std::size_t*)arg[0],
      *(const unsigned short*)arg[1],
      *(const ::std::allocator<unsigned short>*)arg[2]);
  else ::new(mem) ::std::vector<unsigned short>(*(::std::size_t*)arg[0],
      *(const unsigned short*)arg[1],
      *(const ::std::allocator<unsigned short>*)arg[2]);
  }
}

static void constructor_3774( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned short>(*(const ::std::vector<unsigned short>*)arg[0]);
  else ::new(mem) ::std::vector<unsigned short>(*(const ::std::vector<unsigned short>*)arg[0]);
}

static void destructor_3775(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<unsigned short>*)o)->::std::vector<unsigned short>::~vector)();
}
static  void operator_3776( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned short>*)o)->operator=)(*(const ::std::vector<unsigned short>*)arg[0]);
  else   (((::std::vector<unsigned short>*)o)->operator=)(*(const ::std::vector<unsigned short>*)arg[0]);
}

static  void method_3777( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned short>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const unsigned short*)arg[1]);
}

static  void method_3778( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >)((((::std::vector<unsigned short>*)o)->begin)());
  else   (((::std::vector<unsigned short>*)o)->begin)();
}

static  void method_3779( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const unsigned short*,std::vector<unsigned short> >)((((const ::std::vector<unsigned short>*)o)->begin)());
  else   (((const ::std::vector<unsigned short>*)o)->begin)();
}

static  void method_3780( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >)((((::std::vector<unsigned short>*)o)->end)());
  else   (((::std::vector<unsigned short>*)o)->end)();
}

static  void method_3781( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const unsigned short*,std::vector<unsigned short> >)((((const ::std::vector<unsigned short>*)o)->end)());
  else   (((const ::std::vector<unsigned short>*)o)->end)();
}

static  void method_3786( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned short>*)o)->size)());
  else   (((const ::std::vector<unsigned short>*)o)->size)();
}

static  void method_3787( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned short>*)o)->max_size)());
  else   (((const ::std::vector<unsigned short>*)o)->max_size)();
}

static  void method_3788( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<unsigned short>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<unsigned short>*)o)->resize)(*(::std::size_t*)arg[0],
      *(unsigned short*)arg[1]);
  }
}

static  void method_3789( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned short>*)o)->capacity)());
  else   (((const ::std::vector<unsigned short>*)o)->capacity)();
}

static  void method_3790( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<unsigned short>*)o)->empty)());
  else   (((const ::std::vector<unsigned short>*)o)->empty)();
}

static  void method_3791( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned short>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_3792( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned short>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<unsigned short>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_3793( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned short>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<unsigned short>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_3795( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned short>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<unsigned short>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3796( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned short>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<unsigned short>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3797( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned short>*)o)->front)();
  else   (((::std::vector<unsigned short>*)o)->front)();
}

static  void method_3798( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned short>*)o)->front)();
  else   (((const ::std::vector<unsigned short>*)o)->front)();
}

static  void method_3799( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned short>*)o)->back)();
  else   (((::std::vector<unsigned short>*)o)->back)();
}

static  void method_3800( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned short>*)o)->back)();
  else   (((const ::std::vector<unsigned short>*)o)->back)();
}

static  void method_3801( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<unsigned short>*)o)->data)());
  else   (((::std::vector<unsigned short>*)o)->data)();
}

static  void method_3802( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<unsigned short>*)o)->data)());
  else   (((const ::std::vector<unsigned short>*)o)->data)();
}

static  void method_3803( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned short>*)o)->push_back)(*(const unsigned short*)arg[0]);
}

static  void method_3804( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<unsigned short>*)o)->pop_back)();
}

static  void method_3805( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >)((((::std::vector<unsigned short>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >*)arg[0],
    *(const unsigned short*)arg[1]));
  else   (((::std::vector<unsigned short>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >*)arg[0],
    *(const unsigned short*)arg[1]);
}

static  void method_3806( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned short>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const unsigned short*)arg[2]);
}

static  void method_3807( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >)((((::std::vector<unsigned short>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >*)arg[0]));
  else   (((::std::vector<unsigned short>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >*)arg[0]);
}

static  void method_3808( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >)((((::std::vector<unsigned short>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >*)arg[1]));
  else   (((::std::vector<unsigned short>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<unsigned short*,std::vector<unsigned short> >*)arg[1]);
}

static  void method_3809( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned short>*)o)->swap)(*(::std::vector<unsigned short>*)arg[0]);
}

static  void method_3810( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<unsigned short>*)o)->clear)();
}

static void method_newdel_1051( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned short> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned short> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned short> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned short> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned short> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x82( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<unsigned short,std::allocator<unsigned short> >")), ::Reflex::BaseOffset< ::std::vector<unsigned short>,::std::_Vector_base<unsigned short,std::allocator<unsigned short> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x83( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<unsigned short> >::Generate();
  else ::Reflex::Proxy< ::std::vector<unsigned short> >::Generate();
}

//------Dictionary for class vector<short unsigned int,std::allocator<short unsigned int> > -------------------------------
void __std__vector_unsignedsshort__db_datamem(Reflex::Class*);
void __std__vector_unsignedsshort__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_unsignedsshort__datamem_bld(&__std__vector_unsignedsshort__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_unsignedsshort__funcmem_bld(&__std__vector_unsignedsshort__db_funcmem);
void __std__vector_unsignedsshort__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<unsigned short>"), typeid(::std::vector<unsigned short>), sizeof(::std::vector<unsigned short>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1981, ::Reflex::BaseOffset< ::std::vector<unsigned short>, ::std::_Vector_base<unsigned short,std::allocator<unsigned short> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_167, Reflex::Literal("std::vector<unsigned short>::_Alloc_value_type"))
  .AddTypedef(type_1981, Reflex::Literal("std::vector<unsigned short>::_Base"))
  .AddTypedef(type_1329, Reflex::Literal("std::vector<unsigned short>::_Tp_alloc_type"))
  .AddTypedef(type_167, Reflex::Literal("std::vector<unsigned short>::value_type"))
  .AddTypedef(type_2472, Reflex::Literal("std::vector<unsigned short>::pointer"))
  .AddTypedef(type_3759, Reflex::Literal("std::vector<unsigned short>::const_pointer"))
  .AddTypedef(type_3472, Reflex::Literal("std::vector<unsigned short>::reference"))
  .AddTypedef(type_3762, Reflex::Literal("std::vector<unsigned short>::const_reference"))
  .AddTypedef(type_2312, Reflex::Literal("std::vector<unsigned short>::iterator"))
  .AddTypedef(type_2383, Reflex::Literal("std::vector<unsigned short>::const_iterator"))
  .AddTypedef(type_1782, Reflex::Literal("std::vector<unsigned short>::const_reverse_iterator"))
  .AddTypedef(type_1783, Reflex::Literal("std::vector<unsigned short>::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<unsigned short>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<unsigned short>::difference_type"))
  .AddTypedef(type_1329, Reflex::Literal("std::vector<unsigned short>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_3771, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20290), Reflex::Literal("vector"), constructor_3772, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_3762, type_20290), Reflex::Literal("vector"), constructor_3773, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4146), Reflex::Literal("vector"), constructor_3774, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_3775, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1051, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x82, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x83, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_unsignedsshort__funcmem_bld);
}

//------Delayed data member builder for class vector<short unsigned int,std::allocator<short unsigned int> > -------------------
void __std__vector_unsignedsshort__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<short unsigned int,std::allocator<short unsigned int> > -------------------
void __std__vector_unsignedsshort__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4144, type_4146), Reflex::Literal("operator="), operator_3776, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_3762), Reflex::Literal("assign"), method_3777, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2312), Reflex::Literal("begin"), method_3778, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2383), Reflex::Literal("begin"), method_3779, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2312), Reflex::Literal("end"), method_3780, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2383), Reflex::Literal("end"), method_3781, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_3786, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_3787, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_167), Reflex::Literal("resize"), method_3788, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_3789, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_3790, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_3791, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3472, type_1654), Reflex::Literal("operator[]"), operator_3792, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3762, type_1654), Reflex::Literal("operator[]"), operator_3793, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3472, type_1654), Reflex::Literal("at"), method_3795, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3762, type_1654), Reflex::Literal("at"), method_3796, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3472), Reflex::Literal("front"), method_3797, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3762), Reflex::Literal("front"), method_3798, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3472), Reflex::Literal("back"), method_3799, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3762), Reflex::Literal("back"), method_3800, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2472), Reflex::Literal("data"), method_3801, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3759), Reflex::Literal("data"), method_3802, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_3762), Reflex::Literal("push_back"), method_3803, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_3804, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2312, type_2312, type_3762), Reflex::Literal("insert"), method_3805, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2312, type_1654, type_3762), Reflex::Literal("insert"), method_3806, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2312, type_2312), Reflex::Literal("erase"), method_3807, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2312, type_2312, type_2312), Reflex::Literal("erase"), method_3808, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_4144), Reflex::Literal("swap"), method_3809, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_3810, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<long unsigned int,std::allocator<long unsigned int> > -------------------------------
static void constructor_3834( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned long>();
  else ::new(mem) ::std::vector<unsigned long>();
}

static void constructor_3835( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned long>(*(const ::std::allocator<unsigned long>*)arg[0]);
  else ::new(mem) ::std::vector<unsigned long>(*(const ::std::allocator<unsigned long>*)arg[0]);
}

static void constructor_3836( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned long>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<unsigned long>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned long>(*(::std::size_t*)arg[0],
      *(const unsigned long*)arg[1]);
  else ::new(mem) ::std::vector<unsigned long>(*(::std::size_t*)arg[0],
      *(const unsigned long*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned long>(*(::std::size_t*)arg[0],
      *(const unsigned long*)arg[1],
      *(const ::std::allocator<unsigned long>*)arg[2]);
  else ::new(mem) ::std::vector<unsigned long>(*(::std::size_t*)arg[0],
      *(const unsigned long*)arg[1],
      *(const ::std::allocator<unsigned long>*)arg[2]);
  }
}

static void constructor_3837( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned long>(*(const ::std::vector<unsigned long>*)arg[0]);
  else ::new(mem) ::std::vector<unsigned long>(*(const ::std::vector<unsigned long>*)arg[0]);
}

static void destructor_3838(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<unsigned long>*)o)->::std::vector<unsigned long>::~vector)();
}
static  void operator_3839( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned long>*)o)->operator=)(*(const ::std::vector<unsigned long>*)arg[0]);
  else   (((::std::vector<unsigned long>*)o)->operator=)(*(const ::std::vector<unsigned long>*)arg[0]);
}

static  void method_3840( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned long>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const unsigned long*)arg[1]);
}

static  void method_3841( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >)((((::std::vector<unsigned long>*)o)->begin)());
  else   (((::std::vector<unsigned long>*)o)->begin)();
}

static  void method_3842( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const unsigned long*,std::vector<unsigned long> >)((((const ::std::vector<unsigned long>*)o)->begin)());
  else   (((const ::std::vector<unsigned long>*)o)->begin)();
}

static  void method_3843( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >)((((::std::vector<unsigned long>*)o)->end)());
  else   (((::std::vector<unsigned long>*)o)->end)();
}

static  void method_3844( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const unsigned long*,std::vector<unsigned long> >)((((const ::std::vector<unsigned long>*)o)->end)());
  else   (((const ::std::vector<unsigned long>*)o)->end)();
}

static  void method_3849( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned long>*)o)->size)());
  else   (((const ::std::vector<unsigned long>*)o)->size)();
}

static  void method_3850( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned long>*)o)->max_size)());
  else   (((const ::std::vector<unsigned long>*)o)->max_size)();
}

static  void method_3851( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<unsigned long>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<unsigned long>*)o)->resize)(*(::std::size_t*)arg[0],
      *(unsigned long*)arg[1]);
  }
}

static  void method_3852( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned long>*)o)->capacity)());
  else   (((const ::std::vector<unsigned long>*)o)->capacity)();
}

static  void method_3853( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<unsigned long>*)o)->empty)());
  else   (((const ::std::vector<unsigned long>*)o)->empty)();
}

static  void method_3854( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned long>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_3855( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned long>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<unsigned long>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_3856( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned long>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<unsigned long>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_3858( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned long>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<unsigned long>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3859( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned long>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<unsigned long>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3860( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned long>*)o)->front)();
  else   (((::std::vector<unsigned long>*)o)->front)();
}

static  void method_3861( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned long>*)o)->front)();
  else   (((const ::std::vector<unsigned long>*)o)->front)();
}

static  void method_3862( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned long>*)o)->back)();
  else   (((::std::vector<unsigned long>*)o)->back)();
}

static  void method_3863( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned long>*)o)->back)();
  else   (((const ::std::vector<unsigned long>*)o)->back)();
}

static  void method_3864( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<unsigned long>*)o)->data)());
  else   (((::std::vector<unsigned long>*)o)->data)();
}

static  void method_3865( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<unsigned long>*)o)->data)());
  else   (((const ::std::vector<unsigned long>*)o)->data)();
}

static  void method_3866( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned long>*)o)->push_back)(*(const unsigned long*)arg[0]);
}

static  void method_3867( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<unsigned long>*)o)->pop_back)();
}

static  void method_3868( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >)((((::std::vector<unsigned long>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >*)arg[0],
    *(const unsigned long*)arg[1]));
  else   (((::std::vector<unsigned long>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >*)arg[0],
    *(const unsigned long*)arg[1]);
}

static  void method_3869( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned long>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const unsigned long*)arg[2]);
}

static  void method_3870( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >)((((::std::vector<unsigned long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >*)arg[0]));
  else   (((::std::vector<unsigned long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >*)arg[0]);
}

static  void method_3871( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >)((((::std::vector<unsigned long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >*)arg[1]));
  else   (((::std::vector<unsigned long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<unsigned long*,std::vector<unsigned long> >*)arg[1]);
}

static  void method_3872( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned long>*)o)->swap)(*(::std::vector<unsigned long>*)arg[0]);
}

static  void method_3873( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<unsigned long>*)o)->clear)();
}

static void method_newdel_1052( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned long> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned long> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned long> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned long> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned long> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x85( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<unsigned long,std::allocator<unsigned long> >")), ::Reflex::BaseOffset< ::std::vector<unsigned long>,::std::_Vector_base<unsigned long,std::allocator<unsigned long> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x86( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<unsigned long> >::Generate();
  else ::Reflex::Proxy< ::std::vector<unsigned long> >::Generate();
}

//------Dictionary for class vector<long unsigned int,std::allocator<long unsigned int> > -------------------------------
void __std__vector_unsignedslong__db_datamem(Reflex::Class*);
void __std__vector_unsignedslong__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_unsignedslong__datamem_bld(&__std__vector_unsignedslong__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_unsignedslong__funcmem_bld(&__std__vector_unsignedslong__db_funcmem);
void __std__vector_unsignedslong__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<unsigned long>"), typeid(::std::vector<unsigned long>), sizeof(::std::vector<unsigned long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1982, ::Reflex::BaseOffset< ::std::vector<unsigned long>, ::std::_Vector_base<unsigned long,std::allocator<unsigned long> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_75, Reflex::Literal("std::vector<unsigned long>::_Alloc_value_type"))
  .AddTypedef(type_1982, Reflex::Literal("std::vector<unsigned long>::_Base"))
  .AddTypedef(type_1330, Reflex::Literal("std::vector<unsigned long>::_Tp_alloc_type"))
  .AddTypedef(type_75, Reflex::Literal("std::vector<unsigned long>::value_type"))
  .AddTypedef(type_3481, Reflex::Literal("std::vector<unsigned long>::pointer"))
  .AddTypedef(type_3822, Reflex::Literal("std::vector<unsigned long>::const_pointer"))
  .AddTypedef(type_3483, Reflex::Literal("std::vector<unsigned long>::reference"))
  .AddTypedef(type_3825, Reflex::Literal("std::vector<unsigned long>::const_reference"))
  .AddTypedef(type_2313, Reflex::Literal("std::vector<unsigned long>::iterator"))
  .AddTypedef(type_2384, Reflex::Literal("std::vector<unsigned long>::const_iterator"))
  .AddTypedef(type_1784, Reflex::Literal("std::vector<unsigned long>::const_reverse_iterator"))
  .AddTypedef(type_1785, Reflex::Literal("std::vector<unsigned long>::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<unsigned long>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<unsigned long>::difference_type"))
  .AddTypedef(type_1330, Reflex::Literal("std::vector<unsigned long>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_3834, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20291), Reflex::Literal("vector"), constructor_3835, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_3825, type_20291), Reflex::Literal("vector"), constructor_3836, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20187), Reflex::Literal("vector"), constructor_3837, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_3838, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1052, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x85, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x86, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_unsignedslong__funcmem_bld);
}

//------Delayed data member builder for class vector<long unsigned int,std::allocator<long unsigned int> > -------------------
void __std__vector_unsignedslong__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<long unsigned int,std::allocator<long unsigned int> > -------------------
void __std__vector_unsignedslong__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20292, type_20187), Reflex::Literal("operator="), operator_3839, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_3825), Reflex::Literal("assign"), method_3840, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2313), Reflex::Literal("begin"), method_3841, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2384), Reflex::Literal("begin"), method_3842, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2313), Reflex::Literal("end"), method_3843, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2384), Reflex::Literal("end"), method_3844, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_3849, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_3850, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_75), Reflex::Literal("resize"), method_3851, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_3852, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_3853, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_3854, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3483, type_1654), Reflex::Literal("operator[]"), operator_3855, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3825, type_1654), Reflex::Literal("operator[]"), operator_3856, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3483, type_1654), Reflex::Literal("at"), method_3858, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3825, type_1654), Reflex::Literal("at"), method_3859, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3483), Reflex::Literal("front"), method_3860, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3825), Reflex::Literal("front"), method_3861, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3483), Reflex::Literal("back"), method_3862, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3825), Reflex::Literal("back"), method_3863, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3481), Reflex::Literal("data"), method_3864, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3822), Reflex::Literal("data"), method_3865, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_3825), Reflex::Literal("push_back"), method_3866, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_3867, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2313, type_2313, type_3825), Reflex::Literal("insert"), method_3868, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2313, type_1654, type_3825), Reflex::Literal("insert"), method_3869, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2313, type_2313), Reflex::Literal("erase"), method_3870, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2313, type_2313, type_2313), Reflex::Literal("erase"), method_3871, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_20292), Reflex::Literal("swap"), method_3872, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_3873, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<long long unsigned int,std::allocator<long long unsigned int> > -------------------------------
static void constructor_3897( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned long long>();
  else ::new(mem) ::std::vector<unsigned long long>();
}

static void constructor_3898( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned long long>(*(const ::std::allocator<unsigned long long>*)arg[0]);
  else ::new(mem) ::std::vector<unsigned long long>(*(const ::std::allocator<unsigned long long>*)arg[0]);
}

static void constructor_3899( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned long long>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<unsigned long long>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned long long>(*(::std::size_t*)arg[0],
      *(const unsigned long long*)arg[1]);
  else ::new(mem) ::std::vector<unsigned long long>(*(::std::size_t*)arg[0],
      *(const unsigned long long*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned long long>(*(::std::size_t*)arg[0],
      *(const unsigned long long*)arg[1],
      *(const ::std::allocator<unsigned long long>*)arg[2]);
  else ::new(mem) ::std::vector<unsigned long long>(*(::std::size_t*)arg[0],
      *(const unsigned long long*)arg[1],
      *(const ::std::allocator<unsigned long long>*)arg[2]);
  }
}

static void constructor_3900( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned long long>(*(const ::std::vector<unsigned long long>*)arg[0]);
  else ::new(mem) ::std::vector<unsigned long long>(*(const ::std::vector<unsigned long long>*)arg[0]);
}

static void destructor_3901(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<unsigned long long>*)o)->::std::vector<unsigned long long>::~vector)();
}
static  void operator_3902( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned long long>*)o)->operator=)(*(const ::std::vector<unsigned long long>*)arg[0]);
  else   (((::std::vector<unsigned long long>*)o)->operator=)(*(const ::std::vector<unsigned long long>*)arg[0]);
}

static  void method_3903( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned long long>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const unsigned long long*)arg[1]);
}

static  void method_3904( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >)((((::std::vector<unsigned long long>*)o)->begin)());
  else   (((::std::vector<unsigned long long>*)o)->begin)();
}

static  void method_3905( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const unsigned long long*,std::vector<unsigned long long> >)((((const ::std::vector<unsigned long long>*)o)->begin)());
  else   (((const ::std::vector<unsigned long long>*)o)->begin)();
}

static  void method_3906( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >)((((::std::vector<unsigned long long>*)o)->end)());
  else   (((::std::vector<unsigned long long>*)o)->end)();
}

static  void method_3907( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const unsigned long long*,std::vector<unsigned long long> >)((((const ::std::vector<unsigned long long>*)o)->end)());
  else   (((const ::std::vector<unsigned long long>*)o)->end)();
}

static  void method_3912( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned long long>*)o)->size)());
  else   (((const ::std::vector<unsigned long long>*)o)->size)();
}

static  void method_3913( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned long long>*)o)->max_size)());
  else   (((const ::std::vector<unsigned long long>*)o)->max_size)();
}

static  void method_3914( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<unsigned long long>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<unsigned long long>*)o)->resize)(*(::std::size_t*)arg[0],
      *(unsigned long long*)arg[1]);
  }
}

static  void method_3915( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned long long>*)o)->capacity)());
  else   (((const ::std::vector<unsigned long long>*)o)->capacity)();
}

static  void method_3916( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<unsigned long long>*)o)->empty)());
  else   (((const ::std::vector<unsigned long long>*)o)->empty)();
}

static  void method_3917( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned long long>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_3918( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned long long>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<unsigned long long>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_3919( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned long long>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<unsigned long long>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_3921( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned long long>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<unsigned long long>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3922( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned long long>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<unsigned long long>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3923( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned long long>*)o)->front)();
  else   (((::std::vector<unsigned long long>*)o)->front)();
}

static  void method_3924( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned long long>*)o)->front)();
  else   (((const ::std::vector<unsigned long long>*)o)->front)();
}

static  void method_3925( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned long long>*)o)->back)();
  else   (((::std::vector<unsigned long long>*)o)->back)();
}

static  void method_3926( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned long long>*)o)->back)();
  else   (((const ::std::vector<unsigned long long>*)o)->back)();
}

static  void method_3927( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<unsigned long long>*)o)->data)());
  else   (((::std::vector<unsigned long long>*)o)->data)();
}

static  void method_3928( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<unsigned long long>*)o)->data)());
  else   (((const ::std::vector<unsigned long long>*)o)->data)();
}

static  void method_3929( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned long long>*)o)->push_back)(*(const unsigned long long*)arg[0]);
}

static  void method_3930( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<unsigned long long>*)o)->pop_back)();
}

static  void method_3931( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >)((((::std::vector<unsigned long long>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >*)arg[0],
    *(const unsigned long long*)arg[1]));
  else   (((::std::vector<unsigned long long>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >*)arg[0],
    *(const unsigned long long*)arg[1]);
}

static  void method_3932( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned long long>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const unsigned long long*)arg[2]);
}

static  void method_3933( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >)((((::std::vector<unsigned long long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >*)arg[0]));
  else   (((::std::vector<unsigned long long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >*)arg[0]);
}

static  void method_3934( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >)((((::std::vector<unsigned long long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >*)arg[1]));
  else   (((::std::vector<unsigned long long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<unsigned long long*,std::vector<unsigned long long> >*)arg[1]);
}

static  void method_3935( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned long long>*)o)->swap)(*(::std::vector<unsigned long long>*)arg[0]);
}

static  void method_3936( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<unsigned long long>*)o)->clear)();
}

static void method_newdel_1053( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned long long> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned long long> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned long long> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned long long> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned long long> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x88( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<unsigned long long,std::allocator<unsigned long long> >")), ::Reflex::BaseOffset< ::std::vector<unsigned long long>,::std::_Vector_base<unsigned long long,std::allocator<unsigned long long> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x89( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<unsigned long long> >::Generate();
  else ::Reflex::Proxy< ::std::vector<unsigned long long> >::Generate();
}

//------Dictionary for class vector<long long unsigned int,std::allocator<long long unsigned int> > -------------------------------
void __std__vector_unsignedslongslong__db_datamem(Reflex::Class*);
void __std__vector_unsignedslongslong__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_unsignedslongslong__datamem_bld(&__std__vector_unsignedslongslong__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_unsignedslongslong__funcmem_bld(&__std__vector_unsignedslongslong__db_funcmem);
void __std__vector_unsignedslongslong__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<unsigned long long>"), typeid(::std::vector<unsigned long long>), sizeof(::std::vector<unsigned long long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1948, ::Reflex::BaseOffset< ::std::vector<unsigned long long>, ::std::_Vector_base<unsigned long long,std::allocator<unsigned long long> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2144, Reflex::Literal("std::vector<unsigned long long>::_Alloc_value_type"))
  .AddTypedef(type_1948, Reflex::Literal("std::vector<unsigned long long>::_Base"))
  .AddTypedef(type_1331, Reflex::Literal("std::vector<unsigned long long>::_Tp_alloc_type"))
  .AddTypedef(type_2144, Reflex::Literal("std::vector<unsigned long long>::value_type"))
  .AddTypedef(type_3492, Reflex::Literal("std::vector<unsigned long long>::pointer"))
  .AddTypedef(type_3885, Reflex::Literal("std::vector<unsigned long long>::const_pointer"))
  .AddTypedef(type_3494, Reflex::Literal("std::vector<unsigned long long>::reference"))
  .AddTypedef(type_3888, Reflex::Literal("std::vector<unsigned long long>::const_reference"))
  .AddTypedef(type_2314, Reflex::Literal("std::vector<unsigned long long>::iterator"))
  .AddTypedef(type_2315, Reflex::Literal("std::vector<unsigned long long>::const_iterator"))
  .AddTypedef(type_1710, Reflex::Literal("std::vector<unsigned long long>::const_reverse_iterator"))
  .AddTypedef(type_1711, Reflex::Literal("std::vector<unsigned long long>::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<unsigned long long>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<unsigned long long>::difference_type"))
  .AddTypedef(type_1331, Reflex::Literal("std::vector<unsigned long long>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_3897, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20293), Reflex::Literal("vector"), constructor_3898, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_3888, type_20293), Reflex::Literal("vector"), constructor_3899, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20294), Reflex::Literal("vector"), constructor_3900, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_3901, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1053, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x88, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x89, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_unsignedslongslong__funcmem_bld);
}

//------Delayed data member builder for class vector<long long unsigned int,std::allocator<long long unsigned int> > -------------------
void __std__vector_unsignedslongslong__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<long long unsigned int,std::allocator<long long unsigned int> > -------------------
void __std__vector_unsignedslongslong__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20295, type_20294), Reflex::Literal("operator="), operator_3902, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_3888), Reflex::Literal("assign"), method_3903, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2314), Reflex::Literal("begin"), method_3904, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2315), Reflex::Literal("begin"), method_3905, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2314), Reflex::Literal("end"), method_3906, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2315), Reflex::Literal("end"), method_3907, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_3912, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_3913, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_2144), Reflex::Literal("resize"), method_3914, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_3915, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_3916, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_3917, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3494, type_1654), Reflex::Literal("operator[]"), operator_3918, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3888, type_1654), Reflex::Literal("operator[]"), operator_3919, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3494, type_1654), Reflex::Literal("at"), method_3921, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3888, type_1654), Reflex::Literal("at"), method_3922, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3494), Reflex::Literal("front"), method_3923, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3888), Reflex::Literal("front"), method_3924, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3494), Reflex::Literal("back"), method_3925, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3888), Reflex::Literal("back"), method_3926, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3492), Reflex::Literal("data"), method_3927, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3885), Reflex::Literal("data"), method_3928, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_3888), Reflex::Literal("push_back"), method_3929, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_3930, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2314, type_2314, type_3888), Reflex::Literal("insert"), method_3931, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2314, type_1654, type_3888), Reflex::Literal("insert"), method_3932, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2314, type_2314), Reflex::Literal("erase"), method_3933, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2314, type_2314, type_2314), Reflex::Literal("erase"), method_3934, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_20295), Reflex::Literal("swap"), method_3935, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_3936, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<unsigned int,std::allocator<unsigned int> > -------------------------------
static void constructor_3960( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned int>();
  else ::new(mem) ::std::vector<unsigned int>();
}

static void constructor_3961( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned int>(*(const ::std::allocator<unsigned int>*)arg[0]);
  else ::new(mem) ::std::vector<unsigned int>(*(const ::std::allocator<unsigned int>*)arg[0]);
}

static void constructor_3962( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned int>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<unsigned int>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned int>(*(::std::size_t*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::std::vector<unsigned int>(*(::std::size_t*)arg[0],
      *(const unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned int>(*(::std::size_t*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::std::allocator<unsigned int>*)arg[2]);
  else ::new(mem) ::std::vector<unsigned int>(*(::std::size_t*)arg[0],
      *(const unsigned int*)arg[1],
      *(const ::std::allocator<unsigned int>*)arg[2]);
  }
}

static void constructor_3963( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned int>(*(const ::std::vector<unsigned int>*)arg[0]);
  else ::new(mem) ::std::vector<unsigned int>(*(const ::std::vector<unsigned int>*)arg[0]);
}

static void destructor_3964(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<unsigned int>*)o)->::std::vector<unsigned int>::~vector)();
}
static  void operator_3965( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned int>*)o)->operator=)(*(const ::std::vector<unsigned int>*)arg[0]);
  else   (((::std::vector<unsigned int>*)o)->operator=)(*(const ::std::vector<unsigned int>*)arg[0]);
}

static  void method_3966( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned int>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const unsigned int*)arg[1]);
}

static  void method_3967( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >)((((::std::vector<unsigned int>*)o)->begin)());
  else   (((::std::vector<unsigned int>*)o)->begin)();
}

static  void method_3968( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> >)((((const ::std::vector<unsigned int>*)o)->begin)());
  else   (((const ::std::vector<unsigned int>*)o)->begin)();
}

static  void method_3969( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >)((((::std::vector<unsigned int>*)o)->end)());
  else   (((::std::vector<unsigned int>*)o)->end)();
}

static  void method_3970( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const unsigned int*,std::vector<unsigned int> >)((((const ::std::vector<unsigned int>*)o)->end)());
  else   (((const ::std::vector<unsigned int>*)o)->end)();
}

static  void method_3975( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned int>*)o)->size)());
  else   (((const ::std::vector<unsigned int>*)o)->size)();
}

static  void method_3976( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned int>*)o)->max_size)());
  else   (((const ::std::vector<unsigned int>*)o)->max_size)();
}

static  void method_3977( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<unsigned int>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<unsigned int>*)o)->resize)(*(::std::size_t*)arg[0],
      *(unsigned int*)arg[1]);
  }
}

static  void method_3978( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned int>*)o)->capacity)());
  else   (((const ::std::vector<unsigned int>*)o)->capacity)();
}

static  void method_3979( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<unsigned int>*)o)->empty)());
  else   (((const ::std::vector<unsigned int>*)o)->empty)();
}

static  void method_3980( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned int>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_3981( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned int>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<unsigned int>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_3982( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned int>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<unsigned int>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_3984( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned int>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<unsigned int>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3985( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned int>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<unsigned int>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3986( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned int>*)o)->front)();
  else   (((::std::vector<unsigned int>*)o)->front)();
}

static  void method_3987( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned int>*)o)->front)();
  else   (((const ::std::vector<unsigned int>*)o)->front)();
}

static  void method_3988( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned int>*)o)->back)();
  else   (((::std::vector<unsigned int>*)o)->back)();
}

static  void method_3989( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned int>*)o)->back)();
  else   (((const ::std::vector<unsigned int>*)o)->back)();
}

static  void method_3990( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<unsigned int>*)o)->data)());
  else   (((::std::vector<unsigned int>*)o)->data)();
}

static  void method_3991( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<unsigned int>*)o)->data)());
  else   (((const ::std::vector<unsigned int>*)o)->data)();
}

static  void method_3992( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned int>*)o)->push_back)(*(const unsigned int*)arg[0]);
}

static  void method_3993( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<unsigned int>*)o)->pop_back)();
}

static  void method_3994( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >)((((::std::vector<unsigned int>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[0],
    *(const unsigned int*)arg[1]));
  else   (((::std::vector<unsigned int>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[0],
    *(const unsigned int*)arg[1]);
}

static  void method_3995( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned int>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const unsigned int*)arg[2]);
}

static  void method_3996( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >)((((::std::vector<unsigned int>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[0]));
  else   (((::std::vector<unsigned int>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[0]);
}

static  void method_3997( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >)((((::std::vector<unsigned int>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[1]));
  else   (((::std::vector<unsigned int>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<unsigned int*,std::vector<unsigned int> >*)arg[1]);
}

static  void method_3998( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned int>*)o)->swap)(*(::std::vector<unsigned int>*)arg[0]);
}

static  void method_3999( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<unsigned int>*)o)->clear)();
}

static void method_newdel_1054( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x91( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<unsigned int,std::allocator<unsigned int> >")), ::Reflex::BaseOffset< ::std::vector<unsigned int>,::std::_Vector_base<unsigned int,std::allocator<unsigned int> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x92( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<unsigned int> >::Generate();
  else ::Reflex::Proxy< ::std::vector<unsigned int> >::Generate();
}

//------Dictionary for class vector<unsigned int,std::allocator<unsigned int> > -------------------------------
void __std__vector_unsignedsint__db_datamem(Reflex::Class*);
void __std__vector_unsignedsint__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_unsignedsint__datamem_bld(&__std__vector_unsignedsint__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_unsignedsint__funcmem_bld(&__std__vector_unsignedsint__db_funcmem);
void __std__vector_unsignedsint__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<unsigned int>"), typeid(::std::vector<unsigned int>), sizeof(::std::vector<unsigned int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1983, ::Reflex::BaseOffset< ::std::vector<unsigned int>, ::std::_Vector_base<unsigned int,std::allocator<unsigned int> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_78, Reflex::Literal("std::vector<unsigned int>::_Alloc_value_type"))
  .AddTypedef(type_1983, Reflex::Literal("std::vector<unsigned int>::_Base"))
  .AddTypedef(type_1332, Reflex::Literal("std::vector<unsigned int>::_Tp_alloc_type"))
  .AddTypedef(type_78, Reflex::Literal("std::vector<unsigned int>::value_type"))
  .AddTypedef(type_3503, Reflex::Literal("std::vector<unsigned int>::pointer"))
  .AddTypedef(type_3948, Reflex::Literal("std::vector<unsigned int>::const_pointer"))
  .AddTypedef(type_3505, Reflex::Literal("std::vector<unsigned int>::reference"))
  .AddTypedef(type_3951, Reflex::Literal("std::vector<unsigned int>::const_reference"))
  .AddTypedef(type_2316, Reflex::Literal("std::vector<unsigned int>::iterator"))
  .AddTypedef(type_2385, Reflex::Literal("std::vector<unsigned int>::const_iterator"))
  .AddTypedef(type_1786, Reflex::Literal("std::vector<unsigned int>::const_reverse_iterator"))
  .AddTypedef(type_1787, Reflex::Literal("std::vector<unsigned int>::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<unsigned int>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<unsigned int>::difference_type"))
  .AddTypedef(type_1332, Reflex::Literal("std::vector<unsigned int>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_3960, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20296), Reflex::Literal("vector"), constructor_3961, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_3951, type_20296), Reflex::Literal("vector"), constructor_3962, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4211), Reflex::Literal("vector"), constructor_3963, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_3964, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1054, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x91, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x92, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_unsignedsint__funcmem_bld);
}

//------Delayed data member builder for class vector<unsigned int,std::allocator<unsigned int> > -------------------
void __std__vector_unsignedsint__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<unsigned int,std::allocator<unsigned int> > -------------------
void __std__vector_unsignedsint__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4209, type_4211), Reflex::Literal("operator="), operator_3965, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_3951), Reflex::Literal("assign"), method_3966, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2316), Reflex::Literal("begin"), method_3967, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2385), Reflex::Literal("begin"), method_3968, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2316), Reflex::Literal("end"), method_3969, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2385), Reflex::Literal("end"), method_3970, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_3975, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_3976, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_78), Reflex::Literal("resize"), method_3977, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_3978, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_3979, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_3980, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3505, type_1654), Reflex::Literal("operator[]"), operator_3981, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3951, type_1654), Reflex::Literal("operator[]"), operator_3982, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3505, type_1654), Reflex::Literal("at"), method_3984, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3951, type_1654), Reflex::Literal("at"), method_3985, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3505), Reflex::Literal("front"), method_3986, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3951), Reflex::Literal("front"), method_3987, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3505), Reflex::Literal("back"), method_3988, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3951), Reflex::Literal("back"), method_3989, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3503), Reflex::Literal("data"), method_3990, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3948), Reflex::Literal("data"), method_3991, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_3951), Reflex::Literal("push_back"), method_3992, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_3993, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2316, type_2316, type_3951), Reflex::Literal("insert"), method_3994, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2316, type_1654, type_3951), Reflex::Literal("insert"), method_3995, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2316, type_2316), Reflex::Literal("erase"), method_3996, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2316, type_2316, type_2316), Reflex::Literal("erase"), method_3997, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_4209), Reflex::Literal("swap"), method_3998, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_3999, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<unsigned char,std::allocator<unsigned char> > -------------------------------
static void constructor_4025( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned char>();
  else ::new(mem) ::std::vector<unsigned char>();
}

static void constructor_4026( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned char>(*(const ::std::allocator<unsigned char>*)arg[0]);
  else ::new(mem) ::std::vector<unsigned char>(*(const ::std::allocator<unsigned char>*)arg[0]);
}

static void constructor_4027( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned char>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<unsigned char>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned char>(*(::std::size_t*)arg[0],
      *(const unsigned char*)arg[1]);
  else ::new(mem) ::std::vector<unsigned char>(*(::std::size_t*)arg[0],
      *(const unsigned char*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned char>(*(::std::size_t*)arg[0],
      *(const unsigned char*)arg[1],
      *(const ::std::allocator<unsigned char>*)arg[2]);
  else ::new(mem) ::std::vector<unsigned char>(*(::std::size_t*)arg[0],
      *(const unsigned char*)arg[1],
      *(const ::std::allocator<unsigned char>*)arg[2]);
  }
}

static void constructor_4028( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned char>(*(const ::std::vector<unsigned char>*)arg[0]);
  else ::new(mem) ::std::vector<unsigned char>(*(const ::std::vector<unsigned char>*)arg[0]);
}

static void destructor_4029(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<unsigned char>*)o)->::std::vector<unsigned char>::~vector)();
}
static  void operator_4030( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned char>*)o)->operator=)(*(const ::std::vector<unsigned char>*)arg[0]);
  else   (((::std::vector<unsigned char>*)o)->operator=)(*(const ::std::vector<unsigned char>*)arg[0]);
}

static  void method_4031( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned char>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const unsigned char*)arg[1]);
}

static  void method_4032( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >)((((::std::vector<unsigned char>*)o)->begin)());
  else   (((::std::vector<unsigned char>*)o)->begin)();
}

static  void method_4033( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const unsigned char*,std::vector<unsigned char> >)((((const ::std::vector<unsigned char>*)o)->begin)());
  else   (((const ::std::vector<unsigned char>*)o)->begin)();
}

static  void method_4034( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >)((((::std::vector<unsigned char>*)o)->end)());
  else   (((::std::vector<unsigned char>*)o)->end)();
}

static  void method_4035( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const unsigned char*,std::vector<unsigned char> >)((((const ::std::vector<unsigned char>*)o)->end)());
  else   (((const ::std::vector<unsigned char>*)o)->end)();
}

static  void method_4040( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned char>*)o)->size)());
  else   (((const ::std::vector<unsigned char>*)o)->size)();
}

static  void method_4041( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned char>*)o)->max_size)());
  else   (((const ::std::vector<unsigned char>*)o)->max_size)();
}

static  void method_4042( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<unsigned char>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<unsigned char>*)o)->resize)(*(::std::size_t*)arg[0],
      *(unsigned char*)arg[1]);
  }
}

static  void method_4043( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned char>*)o)->capacity)());
  else   (((const ::std::vector<unsigned char>*)o)->capacity)();
}

static  void method_4044( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<unsigned char>*)o)->empty)());
  else   (((const ::std::vector<unsigned char>*)o)->empty)();
}

static  void method_4045( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned char>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_4046( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned char>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<unsigned char>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_4047( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned char>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<unsigned char>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_4049( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned char>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<unsigned char>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4050( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned char>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<unsigned char>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4051( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned char>*)o)->front)();
  else   (((::std::vector<unsigned char>*)o)->front)();
}

static  void method_4052( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned char>*)o)->front)();
  else   (((const ::std::vector<unsigned char>*)o)->front)();
}

static  void method_4053( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned char>*)o)->back)();
  else   (((::std::vector<unsigned char>*)o)->back)();
}

static  void method_4054( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned char>*)o)->back)();
  else   (((const ::std::vector<unsigned char>*)o)->back)();
}

static  void method_4055( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<unsigned char>*)o)->data)());
  else   (((::std::vector<unsigned char>*)o)->data)();
}

static  void method_4056( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<unsigned char>*)o)->data)());
  else   (((const ::std::vector<unsigned char>*)o)->data)();
}

static  void method_4057( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned char>*)o)->push_back)(*(const unsigned char*)arg[0]);
}

static  void method_4058( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<unsigned char>*)o)->pop_back)();
}

static  void method_4059( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >)((((::std::vector<unsigned char>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >*)arg[0],
    *(const unsigned char*)arg[1]));
  else   (((::std::vector<unsigned char>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >*)arg[0],
    *(const unsigned char*)arg[1]);
}

static  void method_4060( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned char>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const unsigned char*)arg[2]);
}

static  void method_4061( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >)((((::std::vector<unsigned char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >*)arg[0]));
  else   (((::std::vector<unsigned char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >*)arg[0]);
}

static  void method_4062( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >)((((::std::vector<unsigned char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >*)arg[1]));
  else   (((::std::vector<unsigned char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<unsigned char*,std::vector<unsigned char> >*)arg[1]);
}

static  void method_4063( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned char>*)o)->swap)(*(::std::vector<unsigned char>*)arg[0]);
}

static  void method_4064( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<unsigned char>*)o)->clear)();
}

static void method_newdel_1055( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned char> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned char> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned char> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned char> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned char> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x94( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<unsigned char,std::allocator<unsigned char> >")), ::Reflex::BaseOffset< ::std::vector<unsigned char>,::std::_Vector_base<unsigned char,std::allocator<unsigned char> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x95( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<unsigned char> >::Generate();
  else ::Reflex::Proxy< ::std::vector<unsigned char> >::Generate();
}

//------Dictionary for class vector<unsigned char,std::allocator<unsigned char> > -------------------------------
void __std__vector_unsignedschar__db_datamem(Reflex::Class*);
void __std__vector_unsignedschar__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_unsignedschar__datamem_bld(&__std__vector_unsignedschar__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_unsignedschar__funcmem_bld(&__std__vector_unsignedschar__db_funcmem);
void __std__vector_unsignedschar__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<unsigned char>"), typeid(::std::vector<unsigned char>), sizeof(::std::vector<unsigned char>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1949, ::Reflex::BaseOffset< ::std::vector<unsigned char>, ::std::_Vector_base<unsigned char,std::allocator<unsigned char> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_528, Reflex::Literal("std::vector<unsigned char>::_Alloc_value_type"))
  .AddTypedef(type_1949, Reflex::Literal("std::vector<unsigned char>::_Base"))
  .AddTypedef(type_1333, Reflex::Literal("std::vector<unsigned char>::_Tp_alloc_type"))
  .AddTypedef(type_528, Reflex::Literal("std::vector<unsigned char>::value_type"))
  .AddTypedef(type_4010, Reflex::Literal("std::vector<unsigned char>::pointer"))
  .AddTypedef(type_4012, Reflex::Literal("std::vector<unsigned char>::const_pointer"))
  .AddTypedef(type_4014, Reflex::Literal("std::vector<unsigned char>::reference"))
  .AddTypedef(type_4016, Reflex::Literal("std::vector<unsigned char>::const_reference"))
  .AddTypedef(type_2317, Reflex::Literal("std::vector<unsigned char>::iterator"))
  .AddTypedef(type_2318, Reflex::Literal("std::vector<unsigned char>::const_iterator"))
  .AddTypedef(type_1712, Reflex::Literal("std::vector<unsigned char>::const_reverse_iterator"))
  .AddTypedef(type_1713, Reflex::Literal("std::vector<unsigned char>::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<unsigned char>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<unsigned char>::difference_type"))
  .AddTypedef(type_1333, Reflex::Literal("std::vector<unsigned char>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_4025, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20298), Reflex::Literal("vector"), constructor_4026, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_4016, type_20298), Reflex::Literal("vector"), constructor_4027, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20299), Reflex::Literal("vector"), constructor_4028, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_4029, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1055, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x94, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x95, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_unsignedschar__funcmem_bld);
}

//------Delayed data member builder for class vector<unsigned char,std::allocator<unsigned char> > -------------------
void __std__vector_unsignedschar__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<unsigned char,std::allocator<unsigned char> > -------------------
void __std__vector_unsignedschar__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20300, type_20299), Reflex::Literal("operator="), operator_4030, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_4016), Reflex::Literal("assign"), method_4031, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317), Reflex::Literal("begin"), method_4032, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2318), Reflex::Literal("begin"), method_4033, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317), Reflex::Literal("end"), method_4034, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2318), Reflex::Literal("end"), method_4035, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_4040, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_4041, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_528), Reflex::Literal("resize"), method_4042, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_4043, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_4044, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_4045, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4014, type_1654), Reflex::Literal("operator[]"), operator_4046, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4016, type_1654), Reflex::Literal("operator[]"), operator_4047, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4014, type_1654), Reflex::Literal("at"), method_4049, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4016, type_1654), Reflex::Literal("at"), method_4050, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4014), Reflex::Literal("front"), method_4051, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4016), Reflex::Literal("front"), method_4052, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4014), Reflex::Literal("back"), method_4053, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4016), Reflex::Literal("back"), method_4054, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4010), Reflex::Literal("data"), method_4055, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4012), Reflex::Literal("data"), method_4056, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_4016), Reflex::Literal("push_back"), method_4057, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_4058, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_2317, type_4016), Reflex::Literal("insert"), method_4059, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2317, type_1654, type_4016), Reflex::Literal("insert"), method_4060, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_2317), Reflex::Literal("erase"), method_4061, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2317, type_2317, type_2317), Reflex::Literal("erase"), method_4062, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_20300), Reflex::Literal("swap"), method_4063, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_4064, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<unsigned char*,std::allocator<unsigned char*> > -------------------------------
static void constructor_4090( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned char*>();
  else ::new(mem) ::std::vector<unsigned char*>();
}

static void constructor_4091( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned char*>(*(const ::std::allocator<unsigned char*>*)arg[0]);
  else ::new(mem) ::std::vector<unsigned char*>(*(const ::std::allocator<unsigned char*>*)arg[0]);
}

static void constructor_4092( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned char*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<unsigned char*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned char*>(*(::std::size_t*)arg[0],
      *(unsigned char* const*)arg[1]);
  else ::new(mem) ::std::vector<unsigned char*>(*(::std::size_t*)arg[0],
      *(unsigned char* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned char*>(*(::std::size_t*)arg[0],
      *(unsigned char* const*)arg[1],
      *(const ::std::allocator<unsigned char*>*)arg[2]);
  else ::new(mem) ::std::vector<unsigned char*>(*(::std::size_t*)arg[0],
      *(unsigned char* const*)arg[1],
      *(const ::std::allocator<unsigned char*>*)arg[2]);
  }
}

static void constructor_4093( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<unsigned char*>(*(const ::std::vector<unsigned char*>*)arg[0]);
  else ::new(mem) ::std::vector<unsigned char*>(*(const ::std::vector<unsigned char*>*)arg[0]);
}

static void destructor_4094(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<unsigned char*>*)o)->::std::vector<unsigned char*>::~vector)();
}
static  void operator_4095( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned char*>*)o)->operator=)(*(const ::std::vector<unsigned char*>*)arg[0]);
  else   (((::std::vector<unsigned char*>*)o)->operator=)(*(const ::std::vector<unsigned char*>*)arg[0]);
}

static  void method_4096( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned char*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(unsigned char* const*)arg[1]);
}

static  void method_4097( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned char**,std::vector<unsigned char*> >)((((::std::vector<unsigned char*>*)o)->begin)());
  else   (((::std::vector<unsigned char*>*)o)->begin)();
}

static  void method_4098( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned char* const*,std::vector<unsigned char*> >)((((const ::std::vector<unsigned char*>*)o)->begin)());
  else   (((const ::std::vector<unsigned char*>*)o)->begin)();
}

static  void method_4099( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned char**,std::vector<unsigned char*> >)((((::std::vector<unsigned char*>*)o)->end)());
  else   (((::std::vector<unsigned char*>*)o)->end)();
}

static  void method_4100( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned char* const*,std::vector<unsigned char*> >)((((const ::std::vector<unsigned char*>*)o)->end)());
  else   (((const ::std::vector<unsigned char*>*)o)->end)();
}

static  void method_4105( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned char*>*)o)->size)());
  else   (((const ::std::vector<unsigned char*>*)o)->size)();
}

static  void method_4106( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned char*>*)o)->max_size)());
  else   (((const ::std::vector<unsigned char*>*)o)->max_size)();
}

static  void method_4107( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<unsigned char*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<unsigned char*>*)o)->resize)(*(::std::size_t*)arg[0],
      (unsigned char*)arg[1]);
  }
}

static  void method_4108( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<unsigned char*>*)o)->capacity)());
  else   (((const ::std::vector<unsigned char*>*)o)->capacity)();
}

static  void method_4109( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<unsigned char*>*)o)->empty)());
  else   (((const ::std::vector<unsigned char*>*)o)->empty)();
}

static  void method_4110( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned char*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_4111( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned char*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<unsigned char*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_4112( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned char*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<unsigned char*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_4114( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned char*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<unsigned char*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4115( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned char*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<unsigned char*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4116( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned char*>*)o)->front)();
  else   (((::std::vector<unsigned char*>*)o)->front)();
}

static  void method_4117( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned char*>*)o)->front)();
  else   (((const ::std::vector<unsigned char*>*)o)->front)();
}

static  void method_4118( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<unsigned char*>*)o)->back)();
  else   (((::std::vector<unsigned char*>*)o)->back)();
}

static  void method_4119( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<unsigned char*>*)o)->back)();
  else   (((const ::std::vector<unsigned char*>*)o)->back)();
}

static  void method_4120( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<unsigned char*>*)o)->data)());
  else   (((::std::vector<unsigned char*>*)o)->data)();
}

static  void method_4121( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<unsigned char*>*)o)->data)());
  else   (((const ::std::vector<unsigned char*>*)o)->data)();
}

static  void method_4122( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned char*>*)o)->push_back)(*(unsigned char* const*)arg[0]);
}

static  void method_4123( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<unsigned char*>*)o)->pop_back)();
}

static  void method_4124( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned char**,std::vector<unsigned char*> >)((((::std::vector<unsigned char*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned char**,std::vector<unsigned char*> >*)arg[0],
    *(unsigned char* const*)arg[1]));
  else   (((::std::vector<unsigned char*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned char**,std::vector<unsigned char*> >*)arg[0],
    *(unsigned char* const*)arg[1]);
}

static  void method_4125( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned char*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<unsigned char**,std::vector<unsigned char*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(unsigned char* const*)arg[2]);
}

static  void method_4126( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned char**,std::vector<unsigned char*> >)((((::std::vector<unsigned char*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned char**,std::vector<unsigned char*> >*)arg[0]));
  else   (((::std::vector<unsigned char*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned char**,std::vector<unsigned char*> >*)arg[0]);
}

static  void method_4127( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<unsigned char**,std::vector<unsigned char*> >)((((::std::vector<unsigned char*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned char**,std::vector<unsigned char*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<unsigned char**,std::vector<unsigned char*> >*)arg[1]));
  else   (((::std::vector<unsigned char*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<unsigned char**,std::vector<unsigned char*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<unsigned char**,std::vector<unsigned char*> >*)arg[1]);
}

static  void method_4128( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<unsigned char*>*)o)->swap)(*(::std::vector<unsigned char*>*)arg[0]);
}

static  void method_4129( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<unsigned char*>*)o)->clear)();
}

static void method_newdel_1056( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned char*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned char*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned char*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned char*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<unsigned char*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x97( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<unsigned char*,std::allocator<unsigned char*> >")), ::Reflex::BaseOffset< ::std::vector<unsigned char*>,::std::_Vector_base<unsigned char*,std::allocator<unsigned char*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x98( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<unsigned char*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<unsigned char*> >::Generate();
}

//------Dictionary for class vector<unsigned char*,std::allocator<unsigned char*> > -------------------------------
void __std__vector_unsignedscharp__db_datamem(Reflex::Class*);
void __std__vector_unsignedscharp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_unsignedscharp__datamem_bld(&__std__vector_unsignedscharp__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_unsignedscharp__funcmem_bld(&__std__vector_unsignedscharp__db_funcmem);
void __std__vector_unsignedscharp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<unsigned char*>"), typeid(::std::vector<unsigned char*>), sizeof(::std::vector<unsigned char*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1950, ::Reflex::BaseOffset< ::std::vector<unsigned char*>, ::std::_Vector_base<unsigned char*,std::allocator<unsigned char*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_4010, Reflex::Literal("std::vector<unsigned char*>::_Alloc_value_type"))
  .AddTypedef(type_1950, Reflex::Literal("std::vector<unsigned char*>::_Base"))
  .AddTypedef(type_1334, Reflex::Literal("std::vector<unsigned char*>::_Tp_alloc_type"))
  .AddTypedef(type_4010, Reflex::Literal("std::vector<unsigned char*>::value_type"))
  .AddTypedef(type_4075, Reflex::Literal("std::vector<unsigned char*>::pointer"))
  .AddTypedef(type_4077, Reflex::Literal("std::vector<unsigned char*>::const_pointer"))
  .AddTypedef(type_4079, Reflex::Literal("std::vector<unsigned char*>::reference"))
  .AddTypedef(type_4081, Reflex::Literal("std::vector<unsigned char*>::const_reference"))
  .AddTypedef(type_2319, Reflex::Literal("std::vector<unsigned char*>::iterator"))
  .AddTypedef(type_2320, Reflex::Literal("std::vector<unsigned char*>::const_iterator"))
  .AddTypedef(type_1714, Reflex::Literal("std::vector<unsigned char*>::const_reverse_iterator"))
  .AddTypedef(type_1715, Reflex::Literal("std::vector<unsigned char*>::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<unsigned char*>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<unsigned char*>::difference_type"))
  .AddTypedef(type_1334, Reflex::Literal("std::vector<unsigned char*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_4090, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20302), Reflex::Literal("vector"), constructor_4091, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_4081, type_20302), Reflex::Literal("vector"), constructor_4092, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20303), Reflex::Literal("vector"), constructor_4093, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_4094, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1056, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x97, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x98, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_unsignedscharp__funcmem_bld);
}

//------Delayed data member builder for class vector<unsigned char*,std::allocator<unsigned char*> > -------------------
void __std__vector_unsignedscharp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<unsigned char*,std::allocator<unsigned char*> > -------------------
void __std__vector_unsignedscharp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20304, type_20303), Reflex::Literal("operator="), operator_4095, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_4081), Reflex::Literal("assign"), method_4096, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2319), Reflex::Literal("begin"), method_4097, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2320), Reflex::Literal("begin"), method_4098, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2319), Reflex::Literal("end"), method_4099, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2320), Reflex::Literal("end"), method_4100, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_4105, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_4106, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_4010), Reflex::Literal("resize"), method_4107, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_4108, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_4109, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_4110, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4079, type_1654), Reflex::Literal("operator[]"), operator_4111, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4081, type_1654), Reflex::Literal("operator[]"), operator_4112, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4079, type_1654), Reflex::Literal("at"), method_4114, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4081, type_1654), Reflex::Literal("at"), method_4115, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4079), Reflex::Literal("front"), method_4116, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4081), Reflex::Literal("front"), method_4117, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4079), Reflex::Literal("back"), method_4118, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4081), Reflex::Literal("back"), method_4119, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4075), Reflex::Literal("data"), method_4120, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4077), Reflex::Literal("data"), method_4121, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_4081), Reflex::Literal("push_back"), method_4122, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_4123, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2319, type_2319, type_4081), Reflex::Literal("insert"), method_4124, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2319, type_1654, type_4081), Reflex::Literal("insert"), method_4125, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2319, type_2319), Reflex::Literal("erase"), method_4126, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2319, type_2319, type_2319), Reflex::Literal("erase"), method_4127, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_20304), Reflex::Literal("swap"), method_4128, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_4129, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::vector<short unsigned int, std::allocator<short unsigned int> >,std::allocator<std::vector<short unsigned int, std::allocator<short unsigned int> > > > -------------------------------
static void constructor_4155( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<unsigned short> >();
  else ::new(mem) ::std::vector<std::vector<unsigned short> >();
}

static void constructor_4156( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<unsigned short> >(*(const ::std::allocator<std::vector<unsigned short> >*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<unsigned short> >(*(const ::std::allocator<std::vector<unsigned short> >*)arg[0]);
}

static void constructor_4157( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<unsigned short> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<unsigned short> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<unsigned short> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<unsigned short>*)arg[1]);
  else ::new(mem) ::std::vector<std::vector<unsigned short> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<unsigned short>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<unsigned short> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<unsigned short>*)arg[1],
      *(const ::std::allocator<std::vector<unsigned short> >*)arg[2]);
  else ::new(mem) ::std::vector<std::vector<unsigned short> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<unsigned short>*)arg[1],
      *(const ::std::allocator<std::vector<unsigned short> >*)arg[2]);
  }
}

static void constructor_4158( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<unsigned short> >(*(const ::std::vector<std::vector<unsigned short> >*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<unsigned short> >(*(const ::std::vector<std::vector<unsigned short> >*)arg[0]);
}

static void destructor_4159(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::vector<unsigned short> >*)o)->::std::vector<std::vector<unsigned short> >::~vector)();
}
static  void operator_4160( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<unsigned short> >*)o)->operator=)(*(const ::std::vector<std::vector<unsigned short> >*)arg[0]);
  else   (((::std::vector<std::vector<unsigned short> >*)o)->operator=)(*(const ::std::vector<std::vector<unsigned short> >*)arg[0]);
}

static  void method_4161( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<unsigned short> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::vector<unsigned short>*)arg[1]);
}

static  void method_4162( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<unsigned short>*,std::vector<std::vector<unsigned short> > >)((((::std::vector<std::vector<unsigned short> >*)o)->begin)());
  else   (((::std::vector<std::vector<unsigned short> >*)o)->begin)();
}

static  void method_4163( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::vector<unsigned short>*,std::vector<std::vector<unsigned short> > >)((((const ::std::vector<std::vector<unsigned short> >*)o)->begin)());
  else   (((const ::std::vector<std::vector<unsigned short> >*)o)->begin)();
}

static  void method_4164( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<unsigned short>*,std::vector<std::vector<unsigned short> > >)((((::std::vector<std::vector<unsigned short> >*)o)->end)());
  else   (((::std::vector<std::vector<unsigned short> >*)o)->end)();
}

static  void method_4165( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::vector<unsigned short>*,std::vector<std::vector<unsigned short> > >)((((const ::std::vector<std::vector<unsigned short> >*)o)->end)());
  else   (((const ::std::vector<std::vector<unsigned short> >*)o)->end)();
}

static  void method_4170( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<unsigned short> >*)o)->size)());
  else   (((const ::std::vector<std::vector<unsigned short> >*)o)->size)();
}

static  void method_4171( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<unsigned short> >*)o)->max_size)());
  else   (((const ::std::vector<std::vector<unsigned short> >*)o)->max_size)();
}

static  void method_4172( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::vector<unsigned short> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::vector<unsigned short> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::vector<unsigned short>*)arg[1]);
  }
}

static  void method_4173( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<unsigned short> >*)o)->capacity)());
  else   (((const ::std::vector<std::vector<unsigned short> >*)o)->capacity)();
}

static  void method_4174( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::vector<unsigned short> >*)o)->empty)());
  else   (((const ::std::vector<std::vector<unsigned short> >*)o)->empty)();
}

static  void method_4175( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<unsigned short> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_4176( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<unsigned short> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::vector<unsigned short> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_4177( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<unsigned short> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::vector<unsigned short> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_4179( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<unsigned short> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::vector<unsigned short> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4180( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<unsigned short> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::vector<unsigned short> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4181( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<unsigned short> >*)o)->front)();
  else   (((::std::vector<std::vector<unsigned short> >*)o)->front)();
}

static  void method_4182( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<unsigned short> >*)o)->front)();
  else   (((const ::std::vector<std::vector<unsigned short> >*)o)->front)();
}

static  void method_4183( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<unsigned short> >*)o)->back)();
  else   (((::std::vector<std::vector<unsigned short> >*)o)->back)();
}

static  void method_4184( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<unsigned short> >*)o)->back)();
  else   (((const ::std::vector<std::vector<unsigned short> >*)o)->back)();
}

static  void method_4185( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::vector<unsigned short> >*)o)->data)());
  else   (((::std::vector<std::vector<unsigned short> >*)o)->data)();
}

static  void method_4186( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::vector<unsigned short> >*)o)->data)());
  else   (((const ::std::vector<std::vector<unsigned short> >*)o)->data)();
}

static  void method_4187( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<unsigned short> >*)o)->push_back)(*(const ::std::vector<unsigned short>*)arg[0]);
}

static  void method_4188( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::vector<unsigned short> >*)o)->pop_back)();
}

static  void method_4189( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<unsigned short>*,std::vector<std::vector<unsigned short> > >)((((::std::vector<std::vector<unsigned short> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<unsigned short>*,std::vector<std::vector<unsigned short> > >*)arg[0],
    *(const ::std::vector<unsigned short>*)arg[1]));
  else   (((::std::vector<std::vector<unsigned short> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<unsigned short>*,std::vector<std::vector<unsigned short> > >*)arg[0],
    *(const ::std::vector<unsigned short>*)arg[1]);
}

static  void method_4190( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<unsigned short> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<unsigned short>*,std::vector<std::vector<unsigned short> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::vector<unsigned short>*)arg[2]);
}

static  void method_4191( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<unsigned short>*,std::vector<std::vector<unsigned short> > >)((((::std::vector<std::vector<unsigned short> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<unsigned short>*,std::vector<std::vector<unsigned short> > >*)arg[0]));
  else   (((::std::vector<std::vector<unsigned short> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<unsigned short>*,std::vector<std::vector<unsigned short> > >*)arg[0]);
}

static  void method_4192( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<unsigned short>*,std::vector<std::vector<unsigned short> > >)((((::std::vector<std::vector<unsigned short> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<unsigned short>*,std::vector<std::vector<unsigned short> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::vector<unsigned short>*,std::vector<std::vector<unsigned short> > >*)arg[1]));
  else   (((::std::vector<std::vector<unsigned short> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<unsigned short>*,std::vector<std::vector<unsigned short> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::vector<unsigned short>*,std::vector<std::vector<unsigned short> > >*)arg[1]);
}

static  void method_4193( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<unsigned short> >*)o)->swap)(*(::std::vector<std::vector<unsigned short> >*)arg[0]);
}

static  void method_4194( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::vector<unsigned short> >*)o)->clear)();
}

static void method_newdel_1057( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<unsigned short> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<unsigned short> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<unsigned short> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<unsigned short> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<unsigned short> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x100( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::vector<unsigned short>,std::allocator<std::vector<unsigned short> > >")), ::Reflex::BaseOffset< ::std::vector<std::vector<unsigned short> >,::std::_Vector_base<std::vector<unsigned short>,std::allocator<std::vector<unsigned short> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x101( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::vector<unsigned short> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::vector<unsigned short> > >::Generate();
}

//------Dictionary for class vector<std::vector<short unsigned int, std::allocator<short unsigned int> >,std::allocator<std::vector<short unsigned int, std::allocator<short unsigned int> > > > -------------------------------
void __std__vector_std__vector_unsignedsshort_s__db_datamem(Reflex::Class*);
void __std__vector_std__vector_unsignedsshort_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__vector_unsignedsshort_s__datamem_bld(&__std__vector_std__vector_unsignedsshort_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__vector_unsignedsshort_s__funcmem_bld(&__std__vector_std__vector_unsignedsshort_s__db_funcmem);
void __std__vector_std__vector_unsignedsshort_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::vector<unsigned short> >"), typeid(::std::vector<std::vector<unsigned short> >), sizeof(::std::vector<std::vector<unsigned short> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1951, ::Reflex::BaseOffset< ::std::vector<std::vector<unsigned short> >, ::std::_Vector_base<std::vector<unsigned short>,std::allocator<std::vector<unsigned short> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1051, Reflex::Literal("std::vector<std::vector<unsigned short> >::_Alloc_value_type"))
  .AddTypedef(type_1951, Reflex::Literal("std::vector<std::vector<unsigned short> >::_Base"))
  .AddTypedef(type_1335, Reflex::Literal("std::vector<std::vector<unsigned short> >::_Tp_alloc_type"))
  .AddTypedef(type_1051, Reflex::Literal("std::vector<std::vector<unsigned short> >::value_type"))
  .AddTypedef(type_4140, Reflex::Literal("std::vector<std::vector<unsigned short> >::pointer"))
  .AddTypedef(type_4142, Reflex::Literal("std::vector<std::vector<unsigned short> >::const_pointer"))
  .AddTypedef(type_4144, Reflex::Literal("std::vector<std::vector<unsigned short> >::reference"))
  .AddTypedef(type_4146, Reflex::Literal("std::vector<std::vector<unsigned short> >::const_reference"))
  .AddTypedef(type_2321, Reflex::Literal("std::vector<std::vector<unsigned short> >::iterator"))
  .AddTypedef(type_2322, Reflex::Literal("std::vector<std::vector<unsigned short> >::const_iterator"))
  .AddTypedef(type_1716, Reflex::Literal("std::vector<std::vector<unsigned short> >::const_reverse_iterator"))
  .AddTypedef(type_1717, Reflex::Literal("std::vector<std::vector<unsigned short> >::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<std::vector<unsigned short> >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<std::vector<unsigned short> >::difference_type"))
  .AddTypedef(type_1335, Reflex::Literal("std::vector<std::vector<unsigned short> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_4155, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20306), Reflex::Literal("vector"), constructor_4156, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_4146, type_20306), Reflex::Literal("vector"), constructor_4157, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20307), Reflex::Literal("vector"), constructor_4158, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_4159, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1057, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x100, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x101, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__vector_unsignedsshort_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::vector<short unsigned int, std::allocator<short unsigned int> >,std::allocator<std::vector<short unsigned int, std::allocator<short unsigned int> > > > -------------------
void __std__vector_std__vector_unsignedsshort_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::vector<short unsigned int, std::allocator<short unsigned int> >,std::allocator<std::vector<short unsigned int, std::allocator<short unsigned int> > > > -------------------
void __std__vector_std__vector_unsignedsshort_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20308, type_20307), Reflex::Literal("operator="), operator_4160, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_4146), Reflex::Literal("assign"), method_4161, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2321), Reflex::Literal("begin"), method_4162, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2322), Reflex::Literal("begin"), method_4163, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2321), Reflex::Literal("end"), method_4164, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2322), Reflex::Literal("end"), method_4165, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_4170, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_4171, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_1051), Reflex::Literal("resize"), method_4172, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_4173, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_4174, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_4175, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4144, type_1654), Reflex::Literal("operator[]"), operator_4176, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4146, type_1654), Reflex::Literal("operator[]"), operator_4177, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4144, type_1654), Reflex::Literal("at"), method_4179, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4146, type_1654), Reflex::Literal("at"), method_4180, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4144), Reflex::Literal("front"), method_4181, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4146), Reflex::Literal("front"), method_4182, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4144), Reflex::Literal("back"), method_4183, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4146), Reflex::Literal("back"), method_4184, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4140), Reflex::Literal("data"), method_4185, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4142), Reflex::Literal("data"), method_4186, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_4146), Reflex::Literal("push_back"), method_4187, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_4188, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2321, type_2321, type_4146), Reflex::Literal("insert"), method_4189, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2321, type_1654, type_4146), Reflex::Literal("insert"), method_4190, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2321, type_2321), Reflex::Literal("erase"), method_4191, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2321, type_2321, type_2321), Reflex::Literal("erase"), method_4192, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_20308), Reflex::Literal("swap"), method_4193, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_4194, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::vector<unsigned int, std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int, std::allocator<unsigned int> > > > -------------------------------
static void constructor_4220( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<unsigned int> >();
  else ::new(mem) ::std::vector<std::vector<unsigned int> >();
}

static void constructor_4221( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<unsigned int> >(*(const ::std::allocator<std::vector<unsigned int> >*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<unsigned int> >(*(const ::std::allocator<std::vector<unsigned int> >*)arg[0]);
}

static void constructor_4222( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<unsigned int> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<unsigned int> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<unsigned int> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<unsigned int>*)arg[1]);
  else ::new(mem) ::std::vector<std::vector<unsigned int> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<unsigned int>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<unsigned int> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<unsigned int>*)arg[1],
      *(const ::std::allocator<std::vector<unsigned int> >*)arg[2]);
  else ::new(mem) ::std::vector<std::vector<unsigned int> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<unsigned int>*)arg[1],
      *(const ::std::allocator<std::vector<unsigned int> >*)arg[2]);
  }
}

static void constructor_4223( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<unsigned int> >(*(const ::std::vector<std::vector<unsigned int> >*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<unsigned int> >(*(const ::std::vector<std::vector<unsigned int> >*)arg[0]);
}

static void destructor_4224(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::vector<unsigned int> >*)o)->::std::vector<std::vector<unsigned int> >::~vector)();
}
static  void operator_4225( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<unsigned int> >*)o)->operator=)(*(const ::std::vector<std::vector<unsigned int> >*)arg[0]);
  else   (((::std::vector<std::vector<unsigned int> >*)o)->operator=)(*(const ::std::vector<std::vector<unsigned int> >*)arg[0]);
}

static  void method_4226( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<unsigned int> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::vector<unsigned int>*)arg[1]);
}

static  void method_4227( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<unsigned int>*,std::vector<std::vector<unsigned int> > >)((((::std::vector<std::vector<unsigned int> >*)o)->begin)());
  else   (((::std::vector<std::vector<unsigned int> >*)o)->begin)();
}

static  void method_4228( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::vector<unsigned int>*,std::vector<std::vector<unsigned int> > >)((((const ::std::vector<std::vector<unsigned int> >*)o)->begin)());
  else   (((const ::std::vector<std::vector<unsigned int> >*)o)->begin)();
}

static  void method_4229( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<unsigned int>*,std::vector<std::vector<unsigned int> > >)((((::std::vector<std::vector<unsigned int> >*)o)->end)());
  else   (((::std::vector<std::vector<unsigned int> >*)o)->end)();
}

static  void method_4230( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::vector<unsigned int>*,std::vector<std::vector<unsigned int> > >)((((const ::std::vector<std::vector<unsigned int> >*)o)->end)());
  else   (((const ::std::vector<std::vector<unsigned int> >*)o)->end)();
}

static  void method_4235( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<unsigned int> >*)o)->size)());
  else   (((const ::std::vector<std::vector<unsigned int> >*)o)->size)();
}

static  void method_4236( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<unsigned int> >*)o)->max_size)());
  else   (((const ::std::vector<std::vector<unsigned int> >*)o)->max_size)();
}

static  void method_4237( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::vector<unsigned int> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::vector<unsigned int> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::vector<unsigned int>*)arg[1]);
  }
}

static  void method_4238( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<unsigned int> >*)o)->capacity)());
  else   (((const ::std::vector<std::vector<unsigned int> >*)o)->capacity)();
}

static  void method_4239( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::vector<unsigned int> >*)o)->empty)());
  else   (((const ::std::vector<std::vector<unsigned int> >*)o)->empty)();
}

static  void method_4240( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<unsigned int> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_4241( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<unsigned int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::vector<unsigned int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_4242( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<unsigned int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::vector<unsigned int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_4244( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<unsigned int> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::vector<unsigned int> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4245( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<unsigned int> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::vector<unsigned int> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4246( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<unsigned int> >*)o)->front)();
  else   (((::std::vector<std::vector<unsigned int> >*)o)->front)();
}

static  void method_4247( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<unsigned int> >*)o)->front)();
  else   (((const ::std::vector<std::vector<unsigned int> >*)o)->front)();
}

static  void method_4248( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<unsigned int> >*)o)->back)();
  else   (((::std::vector<std::vector<unsigned int> >*)o)->back)();
}

static  void method_4249( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<unsigned int> >*)o)->back)();
  else   (((const ::std::vector<std::vector<unsigned int> >*)o)->back)();
}

static  void method_4250( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::vector<unsigned int> >*)o)->data)());
  else   (((::std::vector<std::vector<unsigned int> >*)o)->data)();
}

static  void method_4251( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::vector<unsigned int> >*)o)->data)());
  else   (((const ::std::vector<std::vector<unsigned int> >*)o)->data)();
}

static  void method_4252( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<unsigned int> >*)o)->push_back)(*(const ::std::vector<unsigned int>*)arg[0]);
}

static  void method_4253( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::vector<unsigned int> >*)o)->pop_back)();
}

static  void method_4254( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<unsigned int>*,std::vector<std::vector<unsigned int> > >)((((::std::vector<std::vector<unsigned int> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<unsigned int>*,std::vector<std::vector<unsigned int> > >*)arg[0],
    *(const ::std::vector<unsigned int>*)arg[1]));
  else   (((::std::vector<std::vector<unsigned int> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<unsigned int>*,std::vector<std::vector<unsigned int> > >*)arg[0],
    *(const ::std::vector<unsigned int>*)arg[1]);
}

static  void method_4255( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<unsigned int> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<unsigned int>*,std::vector<std::vector<unsigned int> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::vector<unsigned int>*)arg[2]);
}

static  void method_4256( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<unsigned int>*,std::vector<std::vector<unsigned int> > >)((((::std::vector<std::vector<unsigned int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<unsigned int>*,std::vector<std::vector<unsigned int> > >*)arg[0]));
  else   (((::std::vector<std::vector<unsigned int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<unsigned int>*,std::vector<std::vector<unsigned int> > >*)arg[0]);
}

static  void method_4257( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<unsigned int>*,std::vector<std::vector<unsigned int> > >)((((::std::vector<std::vector<unsigned int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<unsigned int>*,std::vector<std::vector<unsigned int> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::vector<unsigned int>*,std::vector<std::vector<unsigned int> > >*)arg[1]));
  else   (((::std::vector<std::vector<unsigned int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<unsigned int>*,std::vector<std::vector<unsigned int> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::vector<unsigned int>*,std::vector<std::vector<unsigned int> > >*)arg[1]);
}

static  void method_4258( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<unsigned int> >*)o)->swap)(*(::std::vector<std::vector<unsigned int> >*)arg[0]);
}

static  void method_4259( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::vector<unsigned int> >*)o)->clear)();
}

static void method_newdel_1058( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<unsigned int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<unsigned int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<unsigned int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<unsigned int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<unsigned int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x103( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::vector<unsigned int>,std::allocator<std::vector<unsigned int> > >")), ::Reflex::BaseOffset< ::std::vector<std::vector<unsigned int> >,::std::_Vector_base<std::vector<unsigned int>,std::allocator<std::vector<unsigned int> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x104( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::vector<unsigned int> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::vector<unsigned int> > >::Generate();
}

//------Dictionary for class vector<std::vector<unsigned int, std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int, std::allocator<unsigned int> > > > -------------------------------
void __std__vector_std__vector_unsignedsint_s__db_datamem(Reflex::Class*);
void __std__vector_std__vector_unsignedsint_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__vector_unsignedsint_s__datamem_bld(&__std__vector_std__vector_unsignedsint_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__vector_unsignedsint_s__funcmem_bld(&__std__vector_std__vector_unsignedsint_s__db_funcmem);
void __std__vector_std__vector_unsignedsint_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::vector<unsigned int> >"), typeid(::std::vector<std::vector<unsigned int> >), sizeof(::std::vector<std::vector<unsigned int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1952, ::Reflex::BaseOffset< ::std::vector<std::vector<unsigned int> >, ::std::_Vector_base<std::vector<unsigned int>,std::allocator<std::vector<unsigned int> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1054, Reflex::Literal("std::vector<std::vector<unsigned int> >::_Alloc_value_type"))
  .AddTypedef(type_1952, Reflex::Literal("std::vector<std::vector<unsigned int> >::_Base"))
  .AddTypedef(type_1336, Reflex::Literal("std::vector<std::vector<unsigned int> >::_Tp_alloc_type"))
  .AddTypedef(type_1054, Reflex::Literal("std::vector<std::vector<unsigned int> >::value_type"))
  .AddTypedef(type_4205, Reflex::Literal("std::vector<std::vector<unsigned int> >::pointer"))
  .AddTypedef(type_4207, Reflex::Literal("std::vector<std::vector<unsigned int> >::const_pointer"))
  .AddTypedef(type_4209, Reflex::Literal("std::vector<std::vector<unsigned int> >::reference"))
  .AddTypedef(type_4211, Reflex::Literal("std::vector<std::vector<unsigned int> >::const_reference"))
  .AddTypedef(type_2323, Reflex::Literal("std::vector<std::vector<unsigned int> >::iterator"))
  .AddTypedef(type_2324, Reflex::Literal("std::vector<std::vector<unsigned int> >::const_iterator"))
  .AddTypedef(type_1718, Reflex::Literal("std::vector<std::vector<unsigned int> >::const_reverse_iterator"))
  .AddTypedef(type_1719, Reflex::Literal("std::vector<std::vector<unsigned int> >::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<std::vector<unsigned int> >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<std::vector<unsigned int> >::difference_type"))
  .AddTypedef(type_1336, Reflex::Literal("std::vector<std::vector<unsigned int> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_4220, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20310), Reflex::Literal("vector"), constructor_4221, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_4211, type_20310), Reflex::Literal("vector"), constructor_4222, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20311), Reflex::Literal("vector"), constructor_4223, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_4224, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1058, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x103, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x104, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__vector_unsignedsint_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::vector<unsigned int, std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int, std::allocator<unsigned int> > > > -------------------
void __std__vector_std__vector_unsignedsint_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::vector<unsigned int, std::allocator<unsigned int> >,std::allocator<std::vector<unsigned int, std::allocator<unsigned int> > > > -------------------
void __std__vector_std__vector_unsignedsint_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20312, type_20311), Reflex::Literal("operator="), operator_4225, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_4211), Reflex::Literal("assign"), method_4226, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2323), Reflex::Literal("begin"), method_4227, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2324), Reflex::Literal("begin"), method_4228, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2323), Reflex::Literal("end"), method_4229, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2324), Reflex::Literal("end"), method_4230, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_4235, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_4236, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_1054), Reflex::Literal("resize"), method_4237, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_4238, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_4239, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_4240, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4209, type_1654), Reflex::Literal("operator[]"), operator_4241, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4211, type_1654), Reflex::Literal("operator[]"), operator_4242, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4209, type_1654), Reflex::Literal("at"), method_4244, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4211, type_1654), Reflex::Literal("at"), method_4245, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4209), Reflex::Literal("front"), method_4246, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4211), Reflex::Literal("front"), method_4247, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4209), Reflex::Literal("back"), method_4248, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4211), Reflex::Literal("back"), method_4249, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4205), Reflex::Literal("data"), method_4250, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4207), Reflex::Literal("data"), method_4251, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_4211), Reflex::Literal("push_back"), method_4252, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_4253, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2323, type_2323, type_4211), Reflex::Literal("insert"), method_4254, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2323, type_1654, type_4211), Reflex::Literal("insert"), method_4255, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2323, type_2323), Reflex::Literal("erase"), method_4256, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2323, type_2323, type_2323), Reflex::Literal("erase"), method_4257, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_20312), Reflex::Literal("swap"), method_4258, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_4259, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<int,std::allocator<int> > -------------------------------
static void constructor_4413( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<int>();
  else ::new(mem) ::std::vector<int>();
}

static void constructor_4414( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<int>(*(const ::std::allocator<int>*)arg[0]);
  else ::new(mem) ::std::vector<int>(*(const ::std::allocator<int>*)arg[0]);
}

static void constructor_4415( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<int>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<int>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<int>(*(::std::size_t*)arg[0],
      *(const int*)arg[1]);
  else ::new(mem) ::std::vector<int>(*(::std::size_t*)arg[0],
      *(const int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<int>(*(::std::size_t*)arg[0],
      *(const int*)arg[1],
      *(const ::std::allocator<int>*)arg[2]);
  else ::new(mem) ::std::vector<int>(*(::std::size_t*)arg[0],
      *(const int*)arg[1],
      *(const ::std::allocator<int>*)arg[2]);
  }
}

static void constructor_4416( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<int>(*(const ::std::vector<int>*)arg[0]);
  else ::new(mem) ::std::vector<int>(*(const ::std::vector<int>*)arg[0]);
}

static void destructor_4417(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<int>*)o)->::std::vector<int>::~vector)();
}
static  void operator_4418( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<int>*)o)->operator=)(*(const ::std::vector<int>*)arg[0]);
  else   (((::std::vector<int>*)o)->operator=)(*(const ::std::vector<int>*)arg[0]);
}

static  void method_4419( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<int>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const int*)arg[1]);
}

static  void method_4420( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<int*,std::vector<int> >)((((::std::vector<int>*)o)->begin)());
  else   (((::std::vector<int>*)o)->begin)();
}

static  void method_4421( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const int*,std::vector<int> >)((((const ::std::vector<int>*)o)->begin)());
  else   (((const ::std::vector<int>*)o)->begin)();
}

static  void method_4422( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<int*,std::vector<int> >)((((::std::vector<int>*)o)->end)());
  else   (((::std::vector<int>*)o)->end)();
}

static  void method_4423( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const int*,std::vector<int> >)((((const ::std::vector<int>*)o)->end)());
  else   (((const ::std::vector<int>*)o)->end)();
}

static  void method_4428( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<int>*)o)->size)());
  else   (((const ::std::vector<int>*)o)->size)();
}

static  void method_4429( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<int>*)o)->max_size)());
  else   (((const ::std::vector<int>*)o)->max_size)();
}

static  void method_4430( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<int>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<int>*)o)->resize)(*(::std::size_t*)arg[0],
      *(int*)arg[1]);
  }
}

static  void method_4431( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<int>*)o)->capacity)());
  else   (((const ::std::vector<int>*)o)->capacity)();
}

static  void method_4432( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<int>*)o)->empty)());
  else   (((const ::std::vector<int>*)o)->empty)();
}

static  void method_4433( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<int>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_4434( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<int>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<int>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_4435( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<int>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<int>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_4437( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<int>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<int>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4438( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<int>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<int>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4439( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<int>*)o)->front)();
  else   (((::std::vector<int>*)o)->front)();
}

static  void method_4440( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<int>*)o)->front)();
  else   (((const ::std::vector<int>*)o)->front)();
}

static  void method_4441( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<int>*)o)->back)();
  else   (((::std::vector<int>*)o)->back)();
}

static  void method_4442( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<int>*)o)->back)();
  else   (((const ::std::vector<int>*)o)->back)();
}

static  void method_4443( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<int>*)o)->data)());
  else   (((::std::vector<int>*)o)->data)();
}

static  void method_4444( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<int>*)o)->data)());
  else   (((const ::std::vector<int>*)o)->data)();
}

static  void method_4445( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<int>*)o)->push_back)(*(const int*)arg[0]);
}

static  void method_4446( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<int>*)o)->pop_back)();
}

static  void method_4447( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<int*,std::vector<int> >)((((::std::vector<int>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<int*,std::vector<int> >*)arg[0],
    *(const int*)arg[1]));
  else   (((::std::vector<int>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<int*,std::vector<int> >*)arg[0],
    *(const int*)arg[1]);
}

static  void method_4448( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<int>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<int*,std::vector<int> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const int*)arg[2]);
}

static  void method_4449( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<int*,std::vector<int> >)((((::std::vector<int>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<int*,std::vector<int> >*)arg[0]));
  else   (((::std::vector<int>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<int*,std::vector<int> >*)arg[0]);
}

static  void method_4450( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<int*,std::vector<int> >)((((::std::vector<int>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<int*,std::vector<int> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<int*,std::vector<int> >*)arg[1]));
  else   (((::std::vector<int>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<int*,std::vector<int> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<int*,std::vector<int> >*)arg[1]);
}

static  void method_4451( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<int>*)o)->swap)(*(::std::vector<int>*)arg[0]);
}

static  void method_4452( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<int>*)o)->clear)();
}

static void method_newdel_1061( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x106( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<int,std::allocator<int> >")), ::Reflex::BaseOffset< ::std::vector<int>,::std::_Vector_base<int,std::allocator<int> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x107( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<int> >::Generate();
  else ::Reflex::Proxy< ::std::vector<int> >::Generate();
}

//------Dictionary for class vector<int,std::allocator<int> > -------------------------------
void __std__vector_int__db_datamem(Reflex::Class*);
void __std__vector_int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_int__datamem_bld(&__std__vector_int__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_int__funcmem_bld(&__std__vector_int__db_funcmem);
void __std__vector_int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<int>"), typeid(::std::vector<int>), sizeof(::std::vector<int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1975, ::Reflex::BaseOffset< ::std::vector<int>, ::std::_Vector_base<int,std::allocator<int> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_22, Reflex::Literal("std::vector<int>::_Alloc_value_type"))
  .AddTypedef(type_1975, Reflex::Literal("std::vector<int>::_Base"))
  .AddTypedef(type_1339, Reflex::Literal("std::vector<int>::_Tp_alloc_type"))
  .AddTypedef(type_22, Reflex::Literal("std::vector<int>::value_type"))
  .AddTypedef(type_2054, Reflex::Literal("std::vector<int>::pointer"))
  .AddTypedef(type_4401, Reflex::Literal("std::vector<int>::const_pointer"))
  .AddTypedef(type_3569, Reflex::Literal("std::vector<int>::reference"))
  .AddTypedef(type_4404, Reflex::Literal("std::vector<int>::const_reference"))
  .AddTypedef(type_2371, Reflex::Literal("std::vector<int>::iterator"))
  .AddTypedef(type_2372, Reflex::Literal("std::vector<int>::const_iterator"))
  .AddTypedef(type_1764, Reflex::Literal("std::vector<int>::const_reverse_iterator"))
  .AddTypedef(type_1765, Reflex::Literal("std::vector<int>::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<int>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<int>::difference_type"))
  .AddTypedef(type_1339, Reflex::Literal("std::vector<int>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_4413, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20319), Reflex::Literal("vector"), constructor_4414, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_4404, type_20319), Reflex::Literal("vector"), constructor_4415, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4341), Reflex::Literal("vector"), constructor_4416, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_4417, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1061, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x106, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x107, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_int__funcmem_bld);
}

//------Delayed data member builder for class vector<int,std::allocator<int> > -------------------
void __std__vector_int__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<int,std::allocator<int> > -------------------
void __std__vector_int__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4339, type_4341), Reflex::Literal("operator="), operator_4418, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_4404), Reflex::Literal("assign"), method_4419, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2371), Reflex::Literal("begin"), method_4420, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2372), Reflex::Literal("begin"), method_4421, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2371), Reflex::Literal("end"), method_4422, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2372), Reflex::Literal("end"), method_4423, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_4428, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_4429, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_22), Reflex::Literal("resize"), method_4430, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_4431, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_4432, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_4433, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3569, type_1654), Reflex::Literal("operator[]"), operator_4434, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4404, type_1654), Reflex::Literal("operator[]"), operator_4435, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3569, type_1654), Reflex::Literal("at"), method_4437, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4404, type_1654), Reflex::Literal("at"), method_4438, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3569), Reflex::Literal("front"), method_4439, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4404), Reflex::Literal("front"), method_4440, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3569), Reflex::Literal("back"), method_4441, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4404), Reflex::Literal("back"), method_4442, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2054), Reflex::Literal("data"), method_4443, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4401), Reflex::Literal("data"), method_4444, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_4404), Reflex::Literal("push_back"), method_4445, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_4446, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2371, type_2371, type_4404), Reflex::Literal("insert"), method_4447, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2371, type_1654, type_4404), Reflex::Literal("insert"), method_4448, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2371, type_2371), Reflex::Literal("erase"), method_4449, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2371, type_2371, type_2371), Reflex::Literal("erase"), method_4450, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_4339), Reflex::Literal("swap"), method_4451, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_4452, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::vector<int, std::allocator<int> >,std::allocator<std::vector<int, std::allocator<int> > > > -------------------------------
static void constructor_4350( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<int> >();
  else ::new(mem) ::std::vector<std::vector<int> >();
}

static void constructor_4351( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<int> >(*(const ::std::allocator<std::vector<int> >*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<int> >(*(const ::std::allocator<std::vector<int> >*)arg[0]);
}

static void constructor_4352( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<int> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<int> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<int> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<int>*)arg[1]);
  else ::new(mem) ::std::vector<std::vector<int> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<int>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<int> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<int>*)arg[1],
      *(const ::std::allocator<std::vector<int> >*)arg[2]);
  else ::new(mem) ::std::vector<std::vector<int> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<int>*)arg[1],
      *(const ::std::allocator<std::vector<int> >*)arg[2]);
  }
}

static void constructor_4353( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<int> >(*(const ::std::vector<std::vector<int> >*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<int> >(*(const ::std::vector<std::vector<int> >*)arg[0]);
}

static void destructor_4354(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::vector<int> >*)o)->::std::vector<std::vector<int> >::~vector)();
}
static  void operator_4355( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<int> >*)o)->operator=)(*(const ::std::vector<std::vector<int> >*)arg[0]);
  else   (((::std::vector<std::vector<int> >*)o)->operator=)(*(const ::std::vector<std::vector<int> >*)arg[0]);
}

static  void method_4356( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<int> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::vector<int>*)arg[1]);
}

static  void method_4357( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >)((((::std::vector<std::vector<int> >*)o)->begin)());
  else   (((::std::vector<std::vector<int> >*)o)->begin)();
}

static  void method_4358( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::vector<int>*,std::vector<std::vector<int> > >)((((const ::std::vector<std::vector<int> >*)o)->begin)());
  else   (((const ::std::vector<std::vector<int> >*)o)->begin)();
}

static  void method_4359( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >)((((::std::vector<std::vector<int> >*)o)->end)());
  else   (((::std::vector<std::vector<int> >*)o)->end)();
}

static  void method_4360( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::vector<int>*,std::vector<std::vector<int> > >)((((const ::std::vector<std::vector<int> >*)o)->end)());
  else   (((const ::std::vector<std::vector<int> >*)o)->end)();
}

static  void method_4365( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<int> >*)o)->size)());
  else   (((const ::std::vector<std::vector<int> >*)o)->size)();
}

static  void method_4366( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<int> >*)o)->max_size)());
  else   (((const ::std::vector<std::vector<int> >*)o)->max_size)();
}

static  void method_4367( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::vector<int> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::vector<int> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::vector<int>*)arg[1]);
  }
}

static  void method_4368( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<int> >*)o)->capacity)());
  else   (((const ::std::vector<std::vector<int> >*)o)->capacity)();
}

static  void method_4369( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::vector<int> >*)o)->empty)());
  else   (((const ::std::vector<std::vector<int> >*)o)->empty)();
}

static  void method_4370( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<int> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_4371( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::vector<int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_4372( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::vector<int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_4374( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<int> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::vector<int> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4375( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<int> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::vector<int> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4376( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<int> >*)o)->front)();
  else   (((::std::vector<std::vector<int> >*)o)->front)();
}

static  void method_4377( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<int> >*)o)->front)();
  else   (((const ::std::vector<std::vector<int> >*)o)->front)();
}

static  void method_4378( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<int> >*)o)->back)();
  else   (((::std::vector<std::vector<int> >*)o)->back)();
}

static  void method_4379( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<int> >*)o)->back)();
  else   (((const ::std::vector<std::vector<int> >*)o)->back)();
}

static  void method_4380( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::vector<int> >*)o)->data)());
  else   (((::std::vector<std::vector<int> >*)o)->data)();
}

static  void method_4381( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::vector<int> >*)o)->data)());
  else   (((const ::std::vector<std::vector<int> >*)o)->data)();
}

static  void method_4382( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<int> >*)o)->push_back)(*(const ::std::vector<int>*)arg[0]);
}

static  void method_4383( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::vector<int> >*)o)->pop_back)();
}

static  void method_4384( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >)((((::std::vector<std::vector<int> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >*)arg[0],
    *(const ::std::vector<int>*)arg[1]));
  else   (((::std::vector<std::vector<int> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >*)arg[0],
    *(const ::std::vector<int>*)arg[1]);
}

static  void method_4385( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<int> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::vector<int>*)arg[2]);
}

static  void method_4386( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >)((((::std::vector<std::vector<int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >*)arg[0]));
  else   (((::std::vector<std::vector<int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >*)arg[0]);
}

static  void method_4387( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >)((((::std::vector<std::vector<int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >*)arg[1]));
  else   (((::std::vector<std::vector<int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::vector<int>*,std::vector<std::vector<int> > >*)arg[1]);
}

static  void method_4388( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<int> >*)o)->swap)(*(::std::vector<std::vector<int> >*)arg[0]);
}

static  void method_4389( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::vector<int> >*)o)->clear)();
}

static void method_newdel_1060( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x109( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::vector<int>,std::allocator<std::vector<int> > >")), ::Reflex::BaseOffset< ::std::vector<std::vector<int> >,::std::_Vector_base<std::vector<int>,std::allocator<std::vector<int> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x110( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::vector<int> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::vector<int> > >::Generate();
}

//------Dictionary for class vector<std::vector<int, std::allocator<int> >,std::allocator<std::vector<int, std::allocator<int> > > > -------------------------------
void __std__vector_std__vector_int_s__db_datamem(Reflex::Class*);
void __std__vector_std__vector_int_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__vector_int_s__datamem_bld(&__std__vector_std__vector_int_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__vector_int_s__funcmem_bld(&__std__vector_std__vector_int_s__db_funcmem);
void __std__vector_std__vector_int_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::vector<int> >"), typeid(::std::vector<std::vector<int> >), sizeof(::std::vector<std::vector<int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1956, ::Reflex::BaseOffset< ::std::vector<std::vector<int> >, ::std::_Vector_base<std::vector<int>,std::allocator<std::vector<int> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1061, Reflex::Literal("std::vector<std::vector<int> >::_Alloc_value_type"))
  .AddTypedef(type_1956, Reflex::Literal("std::vector<std::vector<int> >::_Base"))
  .AddTypedef(type_1338, Reflex::Literal("std::vector<std::vector<int> >::_Tp_alloc_type"))
  .AddTypedef(type_1061, Reflex::Literal("std::vector<std::vector<int> >::value_type"))
  .AddTypedef(type_4335, Reflex::Literal("std::vector<std::vector<int> >::pointer"))
  .AddTypedef(type_4337, Reflex::Literal("std::vector<std::vector<int> >::const_pointer"))
  .AddTypedef(type_4339, Reflex::Literal("std::vector<std::vector<int> >::reference"))
  .AddTypedef(type_4341, Reflex::Literal("std::vector<std::vector<int> >::const_reference"))
  .AddTypedef(type_2331, Reflex::Literal("std::vector<std::vector<int> >::iterator"))
  .AddTypedef(type_2332, Reflex::Literal("std::vector<std::vector<int> >::const_iterator"))
  .AddTypedef(type_1726, Reflex::Literal("std::vector<std::vector<int> >::const_reverse_iterator"))
  .AddTypedef(type_1727, Reflex::Literal("std::vector<std::vector<int> >::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<std::vector<int> >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<std::vector<int> >::difference_type"))
  .AddTypedef(type_1338, Reflex::Literal("std::vector<std::vector<int> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_4350, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20318), Reflex::Literal("vector"), constructor_4351, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_4341, type_20318), Reflex::Literal("vector"), constructor_4352, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4276), Reflex::Literal("vector"), constructor_4353, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_4354, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1060, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x109, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x110, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__vector_int_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::vector<int, std::allocator<int> >,std::allocator<std::vector<int, std::allocator<int> > > > -------------------
void __std__vector_std__vector_int_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::vector<int, std::allocator<int> >,std::allocator<std::vector<int, std::allocator<int> > > > -------------------
void __std__vector_std__vector_int_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4274, type_4276), Reflex::Literal("operator="), operator_4355, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_4341), Reflex::Literal("assign"), method_4356, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2331), Reflex::Literal("begin"), method_4357, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2332), Reflex::Literal("begin"), method_4358, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2331), Reflex::Literal("end"), method_4359, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2332), Reflex::Literal("end"), method_4360, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_4365, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_4366, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_1061), Reflex::Literal("resize"), method_4367, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_4368, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_4369, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_4370, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4339, type_1654), Reflex::Literal("operator[]"), operator_4371, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4341, type_1654), Reflex::Literal("operator[]"), operator_4372, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4339, type_1654), Reflex::Literal("at"), method_4374, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4341, type_1654), Reflex::Literal("at"), method_4375, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4339), Reflex::Literal("front"), method_4376, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4341), Reflex::Literal("front"), method_4377, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4339), Reflex::Literal("back"), method_4378, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4341), Reflex::Literal("back"), method_4379, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4335), Reflex::Literal("data"), method_4380, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4337), Reflex::Literal("data"), method_4381, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_4341), Reflex::Literal("push_back"), method_4382, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_4383, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2331, type_2331, type_4341), Reflex::Literal("insert"), method_4384, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2331, type_1654, type_4341), Reflex::Literal("insert"), method_4385, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2331, type_2331), Reflex::Literal("erase"), method_4386, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2331, type_2331, type_2331), Reflex::Literal("erase"), method_4387, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_4274), Reflex::Literal("swap"), method_4388, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_4389, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > >,std::allocator<std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > > > > -------------------------------
static void constructor_4285( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<std::vector<int> > >();
  else ::new(mem) ::std::vector<std::vector<std::vector<int> > >();
}

static void constructor_4286( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<std::vector<int> > >(*(const ::std::allocator<std::vector<std::vector<int> > >*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<std::vector<int> > >(*(const ::std::allocator<std::vector<std::vector<int> > >*)arg[0]);
}

static void constructor_4287( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<std::vector<int> > >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<std::vector<int> > >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<std::vector<int> > >(*(::std::size_t*)arg[0],
      *(const ::std::vector<std::vector<int> >*)arg[1]);
  else ::new(mem) ::std::vector<std::vector<std::vector<int> > >(*(::std::size_t*)arg[0],
      *(const ::std::vector<std::vector<int> >*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<std::vector<int> > >(*(::std::size_t*)arg[0],
      *(const ::std::vector<std::vector<int> >*)arg[1],
      *(const ::std::allocator<std::vector<std::vector<int> > >*)arg[2]);
  else ::new(mem) ::std::vector<std::vector<std::vector<int> > >(*(::std::size_t*)arg[0],
      *(const ::std::vector<std::vector<int> >*)arg[1],
      *(const ::std::allocator<std::vector<std::vector<int> > >*)arg[2]);
  }
}

static void constructor_4288( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<std::vector<int> > >(*(const ::std::vector<std::vector<std::vector<int> > >*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<std::vector<int> > >(*(const ::std::vector<std::vector<std::vector<int> > >*)arg[0]);
}

static void destructor_4289(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::vector<std::vector<int> > >*)o)->::std::vector<std::vector<std::vector<int> > >::~vector)();
}
static  void operator_4290( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<std::vector<int> > >*)o)->operator=)(*(const ::std::vector<std::vector<std::vector<int> > >*)arg[0]);
  else   (((::std::vector<std::vector<std::vector<int> > >*)o)->operator=)(*(const ::std::vector<std::vector<std::vector<int> > >*)arg[0]);
}

static  void method_4291( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<std::vector<int> > >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::vector<std::vector<int> >*)arg[1]);
}

static  void method_4292( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<std::vector<int> >*,std::vector<std::vector<std::vector<int> > > >)((((::std::vector<std::vector<std::vector<int> > >*)o)->begin)());
  else   (((::std::vector<std::vector<std::vector<int> > >*)o)->begin)();
}

static  void method_4293( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::vector<std::vector<int> >*,std::vector<std::vector<std::vector<int> > > >)((((const ::std::vector<std::vector<std::vector<int> > >*)o)->begin)());
  else   (((const ::std::vector<std::vector<std::vector<int> > >*)o)->begin)();
}

static  void method_4294( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<std::vector<int> >*,std::vector<std::vector<std::vector<int> > > >)((((::std::vector<std::vector<std::vector<int> > >*)o)->end)());
  else   (((::std::vector<std::vector<std::vector<int> > >*)o)->end)();
}

static  void method_4295( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::vector<std::vector<int> >*,std::vector<std::vector<std::vector<int> > > >)((((const ::std::vector<std::vector<std::vector<int> > >*)o)->end)());
  else   (((const ::std::vector<std::vector<std::vector<int> > >*)o)->end)();
}

static  void method_4300( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<std::vector<int> > >*)o)->size)());
  else   (((const ::std::vector<std::vector<std::vector<int> > >*)o)->size)();
}

static  void method_4301( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<std::vector<int> > >*)o)->max_size)());
  else   (((const ::std::vector<std::vector<std::vector<int> > >*)o)->max_size)();
}

static  void method_4302( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::vector<std::vector<int> > >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::vector<std::vector<int> > >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::vector<std::vector<int> >*)arg[1]);
  }
}

static  void method_4303( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<std::vector<int> > >*)o)->capacity)());
  else   (((const ::std::vector<std::vector<std::vector<int> > >*)o)->capacity)();
}

static  void method_4304( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::vector<std::vector<int> > >*)o)->empty)());
  else   (((const ::std::vector<std::vector<std::vector<int> > >*)o)->empty)();
}

static  void method_4305( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<std::vector<int> > >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_4306( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<std::vector<int> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::vector<std::vector<int> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_4307( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<std::vector<int> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::vector<std::vector<int> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_4309( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<std::vector<int> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::vector<std::vector<int> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4310( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<std::vector<int> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::vector<std::vector<int> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4311( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<std::vector<int> > >*)o)->front)();
  else   (((::std::vector<std::vector<std::vector<int> > >*)o)->front)();
}

static  void method_4312( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<std::vector<int> > >*)o)->front)();
  else   (((const ::std::vector<std::vector<std::vector<int> > >*)o)->front)();
}

static  void method_4313( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<std::vector<int> > >*)o)->back)();
  else   (((::std::vector<std::vector<std::vector<int> > >*)o)->back)();
}

static  void method_4314( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<std::vector<int> > >*)o)->back)();
  else   (((const ::std::vector<std::vector<std::vector<int> > >*)o)->back)();
}

static  void method_4315( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::vector<std::vector<int> > >*)o)->data)());
  else   (((::std::vector<std::vector<std::vector<int> > >*)o)->data)();
}

static  void method_4316( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::vector<std::vector<int> > >*)o)->data)());
  else   (((const ::std::vector<std::vector<std::vector<int> > >*)o)->data)();
}

static  void method_4317( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<std::vector<int> > >*)o)->push_back)(*(const ::std::vector<std::vector<int> >*)arg[0]);
}

static  void method_4318( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::vector<std::vector<int> > >*)o)->pop_back)();
}

static  void method_4319( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<std::vector<int> >*,std::vector<std::vector<std::vector<int> > > >)((((::std::vector<std::vector<std::vector<int> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<std::vector<int> >*,std::vector<std::vector<std::vector<int> > > >*)arg[0],
    *(const ::std::vector<std::vector<int> >*)arg[1]));
  else   (((::std::vector<std::vector<std::vector<int> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<std::vector<int> >*,std::vector<std::vector<std::vector<int> > > >*)arg[0],
    *(const ::std::vector<std::vector<int> >*)arg[1]);
}

static  void method_4320( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<std::vector<int> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<std::vector<int> >*,std::vector<std::vector<std::vector<int> > > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::vector<std::vector<int> >*)arg[2]);
}

static  void method_4321( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<std::vector<int> >*,std::vector<std::vector<std::vector<int> > > >)((((::std::vector<std::vector<std::vector<int> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<std::vector<int> >*,std::vector<std::vector<std::vector<int> > > >*)arg[0]));
  else   (((::std::vector<std::vector<std::vector<int> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<std::vector<int> >*,std::vector<std::vector<std::vector<int> > > >*)arg[0]);
}

static  void method_4322( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<std::vector<int> >*,std::vector<std::vector<std::vector<int> > > >)((((::std::vector<std::vector<std::vector<int> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<std::vector<int> >*,std::vector<std::vector<std::vector<int> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::vector<std::vector<int> >*,std::vector<std::vector<std::vector<int> > > >*)arg[1]));
  else   (((::std::vector<std::vector<std::vector<int> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<std::vector<int> >*,std::vector<std::vector<std::vector<int> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::vector<std::vector<int> >*,std::vector<std::vector<std::vector<int> > > >*)arg[1]);
}

static  void method_4323( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<std::vector<int> > >*)o)->swap)(*(::std::vector<std::vector<std::vector<int> > >*)arg[0]);
}

static  void method_4324( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::vector<std::vector<int> > >*)o)->clear)();
}

static void method_newdel_1059( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<std::vector<int> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<std::vector<int> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<std::vector<int> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<std::vector<int> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<std::vector<int> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x112( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::vector<std::vector<int> >,std::allocator<std::vector<std::vector<int> > > >")), ::Reflex::BaseOffset< ::std::vector<std::vector<std::vector<int> > >,::std::_Vector_base<std::vector<std::vector<int> >,std::allocator<std::vector<std::vector<int> > > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x113( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::vector<std::vector<int> > > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::vector<std::vector<int> > > >::Generate();
}

//------Dictionary for class vector<std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > >,std::allocator<std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > > > > -------------------------------
void __std__vector_std__vector_std__vector_int_s_s__db_datamem(Reflex::Class*);
void __std__vector_std__vector_std__vector_int_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__vector_std__vector_int_s_s__datamem_bld(&__std__vector_std__vector_std__vector_int_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__vector_std__vector_int_s_s__funcmem_bld(&__std__vector_std__vector_std__vector_int_s_s__db_funcmem);
void __std__vector_std__vector_std__vector_int_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::vector<std::vector<int> > >"), typeid(::std::vector<std::vector<std::vector<int> > >), sizeof(::std::vector<std::vector<std::vector<int> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1953, ::Reflex::BaseOffset< ::std::vector<std::vector<std::vector<int> > >, ::std::_Vector_base<std::vector<std::vector<int> >,std::allocator<std::vector<std::vector<int> > > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1060, Reflex::Literal("std::vector<std::vector<std::vector<int> > >::_Alloc_value_type"))
  .AddTypedef(type_1953, Reflex::Literal("std::vector<std::vector<std::vector<int> > >::_Base"))
  .AddTypedef(type_1337, Reflex::Literal("std::vector<std::vector<std::vector<int> > >::_Tp_alloc_type"))
  .AddTypedef(type_1060, Reflex::Literal("std::vector<std::vector<std::vector<int> > >::value_type"))
  .AddTypedef(type_4270, Reflex::Literal("std::vector<std::vector<std::vector<int> > >::pointer"))
  .AddTypedef(type_4272, Reflex::Literal("std::vector<std::vector<std::vector<int> > >::const_pointer"))
  .AddTypedef(type_4274, Reflex::Literal("std::vector<std::vector<std::vector<int> > >::reference"))
  .AddTypedef(type_4276, Reflex::Literal("std::vector<std::vector<std::vector<int> > >::const_reference"))
  .AddTypedef(type_2325, Reflex::Literal("std::vector<std::vector<std::vector<int> > >::iterator"))
  .AddTypedef(type_2326, Reflex::Literal("std::vector<std::vector<std::vector<int> > >::const_iterator"))
  .AddTypedef(type_1720, Reflex::Literal("std::vector<std::vector<std::vector<int> > >::const_reverse_iterator"))
  .AddTypedef(type_1721, Reflex::Literal("std::vector<std::vector<std::vector<int> > >::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<std::vector<std::vector<int> > >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<std::vector<std::vector<int> > >::difference_type"))
  .AddTypedef(type_1337, Reflex::Literal("std::vector<std::vector<std::vector<int> > >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_4285, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20314), Reflex::Literal("vector"), constructor_4286, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_4276, type_20314), Reflex::Literal("vector"), constructor_4287, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20315), Reflex::Literal("vector"), constructor_4288, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_4289, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1059, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x112, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x113, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__vector_std__vector_int_s_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > >,std::allocator<std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > > > > -------------------
void __std__vector_std__vector_std__vector_int_s_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > >,std::allocator<std::vector<std::vector<int, std::allocator<int> >, std::allocator<std::vector<int, std::allocator<int> > > > > > -------------------
void __std__vector_std__vector_std__vector_int_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20316, type_20315), Reflex::Literal("operator="), operator_4290, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_4276), Reflex::Literal("assign"), method_4291, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2325), Reflex::Literal("begin"), method_4292, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2326), Reflex::Literal("begin"), method_4293, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2325), Reflex::Literal("end"), method_4294, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2326), Reflex::Literal("end"), method_4295, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_4300, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_4301, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_1060), Reflex::Literal("resize"), method_4302, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_4303, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_4304, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_4305, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4274, type_1654), Reflex::Literal("operator[]"), operator_4306, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4276, type_1654), Reflex::Literal("operator[]"), operator_4307, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4274, type_1654), Reflex::Literal("at"), method_4309, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4276, type_1654), Reflex::Literal("at"), method_4310, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4274), Reflex::Literal("front"), method_4311, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4276), Reflex::Literal("front"), method_4312, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4274), Reflex::Literal("back"), method_4313, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4276), Reflex::Literal("back"), method_4314, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4270), Reflex::Literal("data"), method_4315, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4272), Reflex::Literal("data"), method_4316, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_4276), Reflex::Literal("push_back"), method_4317, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_4318, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2325, type_2325, type_4276), Reflex::Literal("insert"), method_4319, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2325, type_1654, type_4276), Reflex::Literal("insert"), method_4320, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2325, type_2325), Reflex::Literal("erase"), method_4321, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2325, type_2325, type_2325), Reflex::Literal("erase"), method_4322, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_20316), Reflex::Literal("swap"), method_4323, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_4324, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::pair<int, double>,std::allocator<std::pair<int, double> > > -------------------------------
static void constructor_4543( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<int,double> >();
  else ::new(mem) ::std::vector<std::pair<int,double> >();
}

static void constructor_4544( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<int,double> >(*(const ::std::allocator<std::pair<int,double> >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<int,double> >(*(const ::std::allocator<std::pair<int,double> >*)arg[0]);
}

static void constructor_4545( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<int,double> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<int,double> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<int,double> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<int,double>*)arg[1]);
  else ::new(mem) ::std::vector<std::pair<int,double> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<int,double>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<int,double> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<int,double>*)arg[1],
      *(const ::std::allocator<std::pair<int,double> >*)arg[2]);
  else ::new(mem) ::std::vector<std::pair<int,double> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<int,double>*)arg[1],
      *(const ::std::allocator<std::pair<int,double> >*)arg[2]);
  }
}

static void constructor_4546( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<int,double> >(*(const ::std::vector<std::pair<int,double> >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<int,double> >(*(const ::std::vector<std::pair<int,double> >*)arg[0]);
}

static void destructor_4547(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::pair<int,double> >*)o)->::std::vector<std::pair<int,double> >::~vector)();
}
static  void operator_4548( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<int,double> >*)o)->operator=)(*(const ::std::vector<std::pair<int,double> >*)arg[0]);
  else   (((::std::vector<std::pair<int,double> >*)o)->operator=)(*(const ::std::vector<std::pair<int,double> >*)arg[0]);
}

static  void method_4549( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<int,double> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::pair<int,double>*)arg[1]);
}

static  void method_4550( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<int,double>*,std::vector<std::pair<int,double> > >)((((::std::vector<std::pair<int,double> >*)o)->begin)());
  else   (((::std::vector<std::pair<int,double> >*)o)->begin)();
}

static  void method_4551( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<int,double>*,std::vector<std::pair<int,double> > >)((((const ::std::vector<std::pair<int,double> >*)o)->begin)());
  else   (((const ::std::vector<std::pair<int,double> >*)o)->begin)();
}

static  void method_4552( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<int,double>*,std::vector<std::pair<int,double> > >)((((::std::vector<std::pair<int,double> >*)o)->end)());
  else   (((::std::vector<std::pair<int,double> >*)o)->end)();
}

static  void method_4553( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<int,double>*,std::vector<std::pair<int,double> > >)((((const ::std::vector<std::pair<int,double> >*)o)->end)());
  else   (((const ::std::vector<std::pair<int,double> >*)o)->end)();
}

static  void method_4558( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<int,double> >*)o)->size)());
  else   (((const ::std::vector<std::pair<int,double> >*)o)->size)();
}

static  void method_4559( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<int,double> >*)o)->max_size)());
  else   (((const ::std::vector<std::pair<int,double> >*)o)->max_size)();
}

static  void method_4560( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::pair<int,double> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::pair<int,double> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::pair<int,double>*)arg[1]);
  }
}

static  void method_4561( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<int,double> >*)o)->capacity)());
  else   (((const ::std::vector<std::pair<int,double> >*)o)->capacity)();
}

static  void method_4562( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::pair<int,double> >*)o)->empty)());
  else   (((const ::std::vector<std::pair<int,double> >*)o)->empty)();
}

static  void method_4563( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<int,double> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_4564( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<int,double> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<int,double> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_4565( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<int,double> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<int,double> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_4567( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<int,double> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<int,double> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4568( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<int,double> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<int,double> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4569( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<int,double> >*)o)->front)();
  else   (((::std::vector<std::pair<int,double> >*)o)->front)();
}

static  void method_4570( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<int,double> >*)o)->front)();
  else   (((const ::std::vector<std::pair<int,double> >*)o)->front)();
}

static  void method_4571( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<int,double> >*)o)->back)();
  else   (((::std::vector<std::pair<int,double> >*)o)->back)();
}

static  void method_4572( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<int,double> >*)o)->back)();
  else   (((const ::std::vector<std::pair<int,double> >*)o)->back)();
}

static  void method_4573( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::pair<int,double> >*)o)->data)());
  else   (((::std::vector<std::pair<int,double> >*)o)->data)();
}

static  void method_4574( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::pair<int,double> >*)o)->data)());
  else   (((const ::std::vector<std::pair<int,double> >*)o)->data)();
}

static  void method_4575( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<int,double> >*)o)->push_back)(*(const ::std::pair<int,double>*)arg[0]);
}

static  void method_4576( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<int,double> >*)o)->pop_back)();
}

static  void method_4577( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<int,double>*,std::vector<std::pair<int,double> > >)((((::std::vector<std::pair<int,double> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<int,double>*,std::vector<std::pair<int,double> > >*)arg[0],
    *(const ::std::pair<int,double>*)arg[1]));
  else   (((::std::vector<std::pair<int,double> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<int,double>*,std::vector<std::pair<int,double> > >*)arg[0],
    *(const ::std::pair<int,double>*)arg[1]);
}

static  void method_4578( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<int,double> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<int,double>*,std::vector<std::pair<int,double> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::pair<int,double>*)arg[2]);
}

static  void method_4579( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<int,double>*,std::vector<std::pair<int,double> > >)((((::std::vector<std::pair<int,double> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<int,double>*,std::vector<std::pair<int,double> > >*)arg[0]));
  else   (((::std::vector<std::pair<int,double> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<int,double>*,std::vector<std::pair<int,double> > >*)arg[0]);
}

static  void method_4580( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<int,double>*,std::vector<std::pair<int,double> > >)((((::std::vector<std::pair<int,double> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<int,double>*,std::vector<std::pair<int,double> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<int,double>*,std::vector<std::pair<int,double> > >*)arg[1]));
  else   (((::std::vector<std::pair<int,double> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<int,double>*,std::vector<std::pair<int,double> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<int,double>*,std::vector<std::pair<int,double> > >*)arg[1]);
}

static  void method_4581( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<int,double> >*)o)->swap)(*(::std::vector<std::pair<int,double> >*)arg[0]);
}

static  void method_4582( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<int,double> >*)o)->clear)();
}

static void method_newdel_1063( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<int,double> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<int,double> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<int,double> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<int,double> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<int,double> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x115( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<int,double>,std::allocator<std::pair<int,double> > >")), ::Reflex::BaseOffset< ::std::vector<std::pair<int,double> >,::std::_Vector_base<std::pair<int,double>,std::allocator<std::pair<int,double> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x116( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::pair<int,double> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::pair<int,double> > >::Generate();
}

//------Dictionary for class vector<std::pair<int, double>,std::allocator<std::pair<int, double> > > -------------------------------
void __std__vector_std__pair_int_double_s__db_datamem(Reflex::Class*);
void __std__vector_std__pair_int_double_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_int_double_s__datamem_bld(&__std__vector_std__pair_int_double_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_int_double_s__funcmem_bld(&__std__vector_std__pair_int_double_s__db_funcmem);
void __std__vector_std__pair_int_double_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::pair<int,double> >"), typeid(::std::vector<std::pair<int,double> >), sizeof(::std::vector<std::pair<int,double> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1968, ::Reflex::BaseOffset< ::std::vector<std::pair<int,double> >, ::std::_Vector_base<std::pair<int,double>,std::allocator<std::pair<int,double> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_812, Reflex::Literal("std::vector<std::pair<int,double> >::_Alloc_value_type"))
  .AddTypedef(type_1968, Reflex::Literal("std::vector<std::pair<int,double> >::_Base"))
  .AddTypedef(type_1341, Reflex::Literal("std::vector<std::pair<int,double> >::_Tp_alloc_type"))
  .AddTypedef(type_812, Reflex::Literal("std::vector<std::pair<int,double> >::value_type"))
  .AddTypedef(type_4528, Reflex::Literal("std::vector<std::pair<int,double> >::pointer"))
  .AddTypedef(type_4530, Reflex::Literal("std::vector<std::pair<int,double> >::const_pointer"))
  .AddTypedef(type_4532, Reflex::Literal("std::vector<std::pair<int,double> >::reference"))
  .AddTypedef(type_4534, Reflex::Literal("std::vector<std::pair<int,double> >::const_reference"))
  .AddTypedef(type_2356, Reflex::Literal("std::vector<std::pair<int,double> >::iterator"))
  .AddTypedef(type_2357, Reflex::Literal("std::vector<std::pair<int,double> >::const_iterator"))
  .AddTypedef(type_1750, Reflex::Literal("std::vector<std::pair<int,double> >::const_reverse_iterator"))
  .AddTypedef(type_1751, Reflex::Literal("std::vector<std::pair<int,double> >::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<std::pair<int,double> >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<std::pair<int,double> >::difference_type"))
  .AddTypedef(type_1341, Reflex::Literal("std::vector<std::pair<int,double> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_4543, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20325), Reflex::Literal("vector"), constructor_4544, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_4534, type_20325), Reflex::Literal("vector"), constructor_4545, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4469), Reflex::Literal("vector"), constructor_4546, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_4547, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1063, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x115, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x116, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__pair_int_double_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::pair<int, double>,std::allocator<std::pair<int, double> > > -------------------
void __std__vector_std__pair_int_double_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::pair<int, double>,std::allocator<std::pair<int, double> > > -------------------
void __std__vector_std__pair_int_double_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4467, type_4469), Reflex::Literal("operator="), operator_4548, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_4534), Reflex::Literal("assign"), method_4549, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2356), Reflex::Literal("begin"), method_4550, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2357), Reflex::Literal("begin"), method_4551, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2356), Reflex::Literal("end"), method_4552, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2357), Reflex::Literal("end"), method_4553, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_4558, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_4559, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_812), Reflex::Literal("resize"), method_4560, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_4561, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_4562, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_4563, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4532, type_1654), Reflex::Literal("operator[]"), operator_4564, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4534, type_1654), Reflex::Literal("operator[]"), operator_4565, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4532, type_1654), Reflex::Literal("at"), method_4567, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4534, type_1654), Reflex::Literal("at"), method_4568, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4532), Reflex::Literal("front"), method_4569, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4534), Reflex::Literal("front"), method_4570, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4532), Reflex::Literal("back"), method_4571, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4534), Reflex::Literal("back"), method_4572, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4528), Reflex::Literal("data"), method_4573, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4530), Reflex::Literal("data"), method_4574, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_4534), Reflex::Literal("push_back"), method_4575, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_4576, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2356, type_2356, type_4534), Reflex::Literal("insert"), method_4577, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2356, type_1654, type_4534), Reflex::Literal("insert"), method_4578, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2356, type_2356), Reflex::Literal("erase"), method_4579, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2356, type_2356, type_2356), Reflex::Literal("erase"), method_4580, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_4467), Reflex::Literal("swap"), method_4581, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_4582, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::vector<std::pair<int, double>, std::allocator<std::pair<int, double> > >,std::allocator<std::vector<std::pair<int, double>, std::allocator<std::pair<int, double> > > > > -------------------------------
static void constructor_4478( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<std::pair<int,double> > >();
  else ::new(mem) ::std::vector<std::vector<std::pair<int,double> > >();
}

static void constructor_4479( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<std::pair<int,double> > >(*(const ::std::allocator<std::vector<std::pair<int,double> > >*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<std::pair<int,double> > >(*(const ::std::allocator<std::vector<std::pair<int,double> > >*)arg[0]);
}

static void constructor_4480( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<std::pair<int,double> > >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<std::pair<int,double> > >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<std::pair<int,double> > >(*(::std::size_t*)arg[0],
      *(const ::std::vector<std::pair<int,double> >*)arg[1]);
  else ::new(mem) ::std::vector<std::vector<std::pair<int,double> > >(*(::std::size_t*)arg[0],
      *(const ::std::vector<std::pair<int,double> >*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<std::pair<int,double> > >(*(::std::size_t*)arg[0],
      *(const ::std::vector<std::pair<int,double> >*)arg[1],
      *(const ::std::allocator<std::vector<std::pair<int,double> > >*)arg[2]);
  else ::new(mem) ::std::vector<std::vector<std::pair<int,double> > >(*(::std::size_t*)arg[0],
      *(const ::std::vector<std::pair<int,double> >*)arg[1],
      *(const ::std::allocator<std::vector<std::pair<int,double> > >*)arg[2]);
  }
}

static void constructor_4481( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<std::pair<int,double> > >(*(const ::std::vector<std::vector<std::pair<int,double> > >*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<std::pair<int,double> > >(*(const ::std::vector<std::vector<std::pair<int,double> > >*)arg[0]);
}

static void destructor_4482(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::vector<std::pair<int,double> > >*)o)->::std::vector<std::vector<std::pair<int,double> > >::~vector)();
}
static  void operator_4483( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<std::pair<int,double> > >*)o)->operator=)(*(const ::std::vector<std::vector<std::pair<int,double> > >*)arg[0]);
  else   (((::std::vector<std::vector<std::pair<int,double> > >*)o)->operator=)(*(const ::std::vector<std::vector<std::pair<int,double> > >*)arg[0]);
}

static  void method_4484( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<std::pair<int,double> > >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::vector<std::pair<int,double> >*)arg[1]);
}

static  void method_4485( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<std::pair<int,double> >*,std::vector<std::vector<std::pair<int,double> > > >)((((::std::vector<std::vector<std::pair<int,double> > >*)o)->begin)());
  else   (((::std::vector<std::vector<std::pair<int,double> > >*)o)->begin)();
}

static  void method_4486( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::vector<std::pair<int,double> >*,std::vector<std::vector<std::pair<int,double> > > >)((((const ::std::vector<std::vector<std::pair<int,double> > >*)o)->begin)());
  else   (((const ::std::vector<std::vector<std::pair<int,double> > >*)o)->begin)();
}

static  void method_4487( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<std::pair<int,double> >*,std::vector<std::vector<std::pair<int,double> > > >)((((::std::vector<std::vector<std::pair<int,double> > >*)o)->end)());
  else   (((::std::vector<std::vector<std::pair<int,double> > >*)o)->end)();
}

static  void method_4488( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::vector<std::pair<int,double> >*,std::vector<std::vector<std::pair<int,double> > > >)((((const ::std::vector<std::vector<std::pair<int,double> > >*)o)->end)());
  else   (((const ::std::vector<std::vector<std::pair<int,double> > >*)o)->end)();
}

static  void method_4493( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<std::pair<int,double> > >*)o)->size)());
  else   (((const ::std::vector<std::vector<std::pair<int,double> > >*)o)->size)();
}

static  void method_4494( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<std::pair<int,double> > >*)o)->max_size)());
  else   (((const ::std::vector<std::vector<std::pair<int,double> > >*)o)->max_size)();
}

static  void method_4495( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::vector<std::pair<int,double> > >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::vector<std::pair<int,double> > >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::vector<std::pair<int,double> >*)arg[1]);
  }
}

static  void method_4496( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<std::pair<int,double> > >*)o)->capacity)());
  else   (((const ::std::vector<std::vector<std::pair<int,double> > >*)o)->capacity)();
}

static  void method_4497( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::vector<std::pair<int,double> > >*)o)->empty)());
  else   (((const ::std::vector<std::vector<std::pair<int,double> > >*)o)->empty)();
}

static  void method_4498( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<std::pair<int,double> > >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_4499( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<std::pair<int,double> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::vector<std::pair<int,double> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_4500( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<std::pair<int,double> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::vector<std::pair<int,double> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_4502( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<std::pair<int,double> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::vector<std::pair<int,double> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4503( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<std::pair<int,double> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::vector<std::pair<int,double> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4504( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<std::pair<int,double> > >*)o)->front)();
  else   (((::std::vector<std::vector<std::pair<int,double> > >*)o)->front)();
}

static  void method_4505( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<std::pair<int,double> > >*)o)->front)();
  else   (((const ::std::vector<std::vector<std::pair<int,double> > >*)o)->front)();
}

static  void method_4506( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<std::pair<int,double> > >*)o)->back)();
  else   (((::std::vector<std::vector<std::pair<int,double> > >*)o)->back)();
}

static  void method_4507( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<std::pair<int,double> > >*)o)->back)();
  else   (((const ::std::vector<std::vector<std::pair<int,double> > >*)o)->back)();
}

static  void method_4508( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::vector<std::pair<int,double> > >*)o)->data)());
  else   (((::std::vector<std::vector<std::pair<int,double> > >*)o)->data)();
}

static  void method_4509( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::vector<std::pair<int,double> > >*)o)->data)());
  else   (((const ::std::vector<std::vector<std::pair<int,double> > >*)o)->data)();
}

static  void method_4510( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<std::pair<int,double> > >*)o)->push_back)(*(const ::std::vector<std::pair<int,double> >*)arg[0]);
}

static  void method_4511( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::vector<std::pair<int,double> > >*)o)->pop_back)();
}

static  void method_4512( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<std::pair<int,double> >*,std::vector<std::vector<std::pair<int,double> > > >)((((::std::vector<std::vector<std::pair<int,double> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<std::pair<int,double> >*,std::vector<std::vector<std::pair<int,double> > > >*)arg[0],
    *(const ::std::vector<std::pair<int,double> >*)arg[1]));
  else   (((::std::vector<std::vector<std::pair<int,double> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<std::pair<int,double> >*,std::vector<std::vector<std::pair<int,double> > > >*)arg[0],
    *(const ::std::vector<std::pair<int,double> >*)arg[1]);
}

static  void method_4513( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<std::pair<int,double> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<std::pair<int,double> >*,std::vector<std::vector<std::pair<int,double> > > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::vector<std::pair<int,double> >*)arg[2]);
}

static  void method_4514( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<std::pair<int,double> >*,std::vector<std::vector<std::pair<int,double> > > >)((((::std::vector<std::vector<std::pair<int,double> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<std::pair<int,double> >*,std::vector<std::vector<std::pair<int,double> > > >*)arg[0]));
  else   (((::std::vector<std::vector<std::pair<int,double> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<std::pair<int,double> >*,std::vector<std::vector<std::pair<int,double> > > >*)arg[0]);
}

static  void method_4515( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<std::pair<int,double> >*,std::vector<std::vector<std::pair<int,double> > > >)((((::std::vector<std::vector<std::pair<int,double> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<std::pair<int,double> >*,std::vector<std::vector<std::pair<int,double> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::vector<std::pair<int,double> >*,std::vector<std::vector<std::pair<int,double> > > >*)arg[1]));
  else   (((::std::vector<std::vector<std::pair<int,double> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<std::pair<int,double> >*,std::vector<std::vector<std::pair<int,double> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::vector<std::pair<int,double> >*,std::vector<std::vector<std::pair<int,double> > > >*)arg[1]);
}

static  void method_4516( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<std::pair<int,double> > >*)o)->swap)(*(::std::vector<std::vector<std::pair<int,double> > >*)arg[0]);
}

static  void method_4517( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::vector<std::pair<int,double> > >*)o)->clear)();
}

static void method_newdel_1062( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<std::pair<int,double> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<std::pair<int,double> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<std::pair<int,double> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<std::pair<int,double> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<std::pair<int,double> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x118( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::vector<std::pair<int,double> >,std::allocator<std::vector<std::pair<int,double> > > >")), ::Reflex::BaseOffset< ::std::vector<std::vector<std::pair<int,double> > >,::std::_Vector_base<std::vector<std::pair<int,double> >,std::allocator<std::vector<std::pair<int,double> > > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x119( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::vector<std::pair<int,double> > > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::vector<std::pair<int,double> > > >::Generate();
}

//------Dictionary for class vector<std::vector<std::pair<int, double>, std::allocator<std::pair<int, double> > >,std::allocator<std::vector<std::pair<int, double>, std::allocator<std::pair<int, double> > > > > -------------------------------
void __std__vector_std__vector_std__pair_int_double_s_s__db_datamem(Reflex::Class*);
void __std__vector_std__vector_std__pair_int_double_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__vector_std__pair_int_double_s_s__datamem_bld(&__std__vector_std__vector_std__pair_int_double_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__vector_std__pair_int_double_s_s__funcmem_bld(&__std__vector_std__vector_std__pair_int_double_s_s__db_funcmem);
void __std__vector_std__vector_std__pair_int_double_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::vector<std::pair<int,double> > >"), typeid(::std::vector<std::vector<std::pair<int,double> > >), sizeof(::std::vector<std::vector<std::pair<int,double> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1954, ::Reflex::BaseOffset< ::std::vector<std::vector<std::pair<int,double> > >, ::std::_Vector_base<std::vector<std::pair<int,double> >,std::allocator<std::vector<std::pair<int,double> > > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1063, Reflex::Literal("std::vector<std::vector<std::pair<int,double> > >::_Alloc_value_type"))
  .AddTypedef(type_1954, Reflex::Literal("std::vector<std::vector<std::pair<int,double> > >::_Base"))
  .AddTypedef(type_1340, Reflex::Literal("std::vector<std::vector<std::pair<int,double> > >::_Tp_alloc_type"))
  .AddTypedef(type_1063, Reflex::Literal("std::vector<std::vector<std::pair<int,double> > >::value_type"))
  .AddTypedef(type_4463, Reflex::Literal("std::vector<std::vector<std::pair<int,double> > >::pointer"))
  .AddTypedef(type_4465, Reflex::Literal("std::vector<std::vector<std::pair<int,double> > >::const_pointer"))
  .AddTypedef(type_4467, Reflex::Literal("std::vector<std::vector<std::pair<int,double> > >::reference"))
  .AddTypedef(type_4469, Reflex::Literal("std::vector<std::vector<std::pair<int,double> > >::const_reference"))
  .AddTypedef(type_2327, Reflex::Literal("std::vector<std::vector<std::pair<int,double> > >::iterator"))
  .AddTypedef(type_2328, Reflex::Literal("std::vector<std::vector<std::pair<int,double> > >::const_iterator"))
  .AddTypedef(type_1722, Reflex::Literal("std::vector<std::vector<std::pair<int,double> > >::const_reverse_iterator"))
  .AddTypedef(type_1723, Reflex::Literal("std::vector<std::vector<std::pair<int,double> > >::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<std::vector<std::pair<int,double> > >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<std::vector<std::pair<int,double> > >::difference_type"))
  .AddTypedef(type_1340, Reflex::Literal("std::vector<std::vector<std::pair<int,double> > >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_4478, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20321), Reflex::Literal("vector"), constructor_4479, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_4469, type_20321), Reflex::Literal("vector"), constructor_4480, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20322), Reflex::Literal("vector"), constructor_4481, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_4482, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1062, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x118, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x119, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__vector_std__pair_int_double_s_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::vector<std::pair<int, double>, std::allocator<std::pair<int, double> > >,std::allocator<std::vector<std::pair<int, double>, std::allocator<std::pair<int, double> > > > > -------------------
void __std__vector_std__vector_std__pair_int_double_s_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::vector<std::pair<int, double>, std::allocator<std::pair<int, double> > >,std::allocator<std::vector<std::pair<int, double>, std::allocator<std::pair<int, double> > > > > -------------------
void __std__vector_std__vector_std__pair_int_double_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20323, type_20322), Reflex::Literal("operator="), operator_4483, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_4469), Reflex::Literal("assign"), method_4484, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2327), Reflex::Literal("begin"), method_4485, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2328), Reflex::Literal("begin"), method_4486, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2327), Reflex::Literal("end"), method_4487, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2328), Reflex::Literal("end"), method_4488, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_4493, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_4494, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_1063), Reflex::Literal("resize"), method_4495, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_4496, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_4497, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_4498, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4467, type_1654), Reflex::Literal("operator[]"), operator_4499, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4469, type_1654), Reflex::Literal("operator[]"), operator_4500, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4467, type_1654), Reflex::Literal("at"), method_4502, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4469, type_1654), Reflex::Literal("at"), method_4503, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4467), Reflex::Literal("front"), method_4504, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4469), Reflex::Literal("front"), method_4505, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4467), Reflex::Literal("back"), method_4506, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4469), Reflex::Literal("back"), method_4507, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4463), Reflex::Literal("data"), method_4508, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4465), Reflex::Literal("data"), method_4509, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_4469), Reflex::Literal("push_back"), method_4510, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_4511, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2327, type_2327, type_4469), Reflex::Literal("insert"), method_4512, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2327, type_1654, type_4469), Reflex::Literal("insert"), method_4513, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2327, type_2327), Reflex::Literal("erase"), method_4514, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2327, type_2327, type_2327), Reflex::Literal("erase"), method_4515, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_20323), Reflex::Literal("swap"), method_4516, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_4517, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<short int,std::allocator<short int> > -------------------------------
static void constructor_4671( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<short>();
  else ::new(mem) ::std::vector<short>();
}

static void constructor_4672( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<short>(*(const ::std::allocator<short>*)arg[0]);
  else ::new(mem) ::std::vector<short>(*(const ::std::allocator<short>*)arg[0]);
}

static void constructor_4673( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<short>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<short>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<short>(*(::std::size_t*)arg[0],
      *(const short*)arg[1]);
  else ::new(mem) ::std::vector<short>(*(::std::size_t*)arg[0],
      *(const short*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<short>(*(::std::size_t*)arg[0],
      *(const short*)arg[1],
      *(const ::std::allocator<short>*)arg[2]);
  else ::new(mem) ::std::vector<short>(*(::std::size_t*)arg[0],
      *(const short*)arg[1],
      *(const ::std::allocator<short>*)arg[2]);
  }
}

static void constructor_4674( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<short>(*(const ::std::vector<short>*)arg[0]);
  else ::new(mem) ::std::vector<short>(*(const ::std::vector<short>*)arg[0]);
}

static void destructor_4675(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<short>*)o)->::std::vector<short>::~vector)();
}
static  void operator_4676( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<short>*)o)->operator=)(*(const ::std::vector<short>*)arg[0]);
  else   (((::std::vector<short>*)o)->operator=)(*(const ::std::vector<short>*)arg[0]);
}

static  void method_4677( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<short>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const short*)arg[1]);
}

static  void method_4678( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<short*,std::vector<short> >)((((::std::vector<short>*)o)->begin)());
  else   (((::std::vector<short>*)o)->begin)();
}

static  void method_4679( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const short*,std::vector<short> >)((((const ::std::vector<short>*)o)->begin)());
  else   (((const ::std::vector<short>*)o)->begin)();
}

static  void method_4680( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<short*,std::vector<short> >)((((::std::vector<short>*)o)->end)());
  else   (((::std::vector<short>*)o)->end)();
}

static  void method_4681( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const short*,std::vector<short> >)((((const ::std::vector<short>*)o)->end)());
  else   (((const ::std::vector<short>*)o)->end)();
}

static  void method_4686( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<short>*)o)->size)());
  else   (((const ::std::vector<short>*)o)->size)();
}

static  void method_4687( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<short>*)o)->max_size)());
  else   (((const ::std::vector<short>*)o)->max_size)();
}

static  void method_4688( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<short>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<short>*)o)->resize)(*(::std::size_t*)arg[0],
      *(short*)arg[1]);
  }
}

static  void method_4689( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<short>*)o)->capacity)());
  else   (((const ::std::vector<short>*)o)->capacity)();
}

static  void method_4690( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<short>*)o)->empty)());
  else   (((const ::std::vector<short>*)o)->empty)();
}

static  void method_4691( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<short>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_4692( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<short>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<short>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_4693( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<short>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<short>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_4695( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<short>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<short>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4696( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<short>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<short>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4697( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<short>*)o)->front)();
  else   (((::std::vector<short>*)o)->front)();
}

static  void method_4698( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<short>*)o)->front)();
  else   (((const ::std::vector<short>*)o)->front)();
}

static  void method_4699( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<short>*)o)->back)();
  else   (((::std::vector<short>*)o)->back)();
}

static  void method_4700( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<short>*)o)->back)();
  else   (((const ::std::vector<short>*)o)->back)();
}

static  void method_4701( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<short>*)o)->data)());
  else   (((::std::vector<short>*)o)->data)();
}

static  void method_4702( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<short>*)o)->data)());
  else   (((const ::std::vector<short>*)o)->data)();
}

static  void method_4703( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<short>*)o)->push_back)(*(const short*)arg[0]);
}

static  void method_4704( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<short>*)o)->pop_back)();
}

static  void method_4705( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<short*,std::vector<short> >)((((::std::vector<short>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<short*,std::vector<short> >*)arg[0],
    *(const short*)arg[1]));
  else   (((::std::vector<short>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<short*,std::vector<short> >*)arg[0],
    *(const short*)arg[1]);
}

static  void method_4706( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<short>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<short*,std::vector<short> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const short*)arg[2]);
}

static  void method_4707( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<short*,std::vector<short> >)((((::std::vector<short>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<short*,std::vector<short> >*)arg[0]));
  else   (((::std::vector<short>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<short*,std::vector<short> >*)arg[0]);
}

static  void method_4708( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<short*,std::vector<short> >)((((::std::vector<short>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<short*,std::vector<short> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<short*,std::vector<short> >*)arg[1]));
  else   (((::std::vector<short>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<short*,std::vector<short> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<short*,std::vector<short> >*)arg[1]);
}

static  void method_4709( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<short>*)o)->swap)(*(::std::vector<short>*)arg[0]);
}

static  void method_4710( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<short>*)o)->clear)();
}

static void method_newdel_1065( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<short> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<short> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<short> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<short> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<short> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x121( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<short,std::allocator<short> >")), ::Reflex::BaseOffset< ::std::vector<short>,::std::_Vector_base<short,std::allocator<short> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x122( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<short> >::Generate();
  else ::Reflex::Proxy< ::std::vector<short> >::Generate();
}

//------Dictionary for class vector<short int,std::allocator<short int> > -------------------------------
void __std__vector_short__db_datamem(Reflex::Class*);
void __std__vector_short__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_short__datamem_bld(&__std__vector_short__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_short__funcmem_bld(&__std__vector_short__db_funcmem);
void __std__vector_short__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<short>"), typeid(::std::vector<short>), sizeof(::std::vector<short>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1986, ::Reflex::BaseOffset< ::std::vector<short>, ::std::_Vector_base<short,std::allocator<short> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_113, Reflex::Literal("std::vector<short>::_Alloc_value_type"))
  .AddTypedef(type_1986, Reflex::Literal("std::vector<short>::_Base"))
  .AddTypedef(type_1343, Reflex::Literal("std::vector<short>::_Tp_alloc_type"))
  .AddTypedef(type_113, Reflex::Literal("std::vector<short>::value_type"))
  .AddTypedef(type_3525, Reflex::Literal("std::vector<short>::pointer"))
  .AddTypedef(type_4659, Reflex::Literal("std::vector<short>::const_pointer"))
  .AddTypedef(type_3527, Reflex::Literal("std::vector<short>::reference"))
  .AddTypedef(type_4662, Reflex::Literal("std::vector<short>::const_reference"))
  .AddTypedef(type_2364, Reflex::Literal("std::vector<short>::iterator"))
  .AddTypedef(type_2390, Reflex::Literal("std::vector<short>::const_iterator"))
  .AddTypedef(type_1792, Reflex::Literal("std::vector<short>::const_reverse_iterator"))
  .AddTypedef(type_1793, Reflex::Literal("std::vector<short>::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<short>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<short>::difference_type"))
  .AddTypedef(type_1343, Reflex::Literal("std::vector<short>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_4671, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20330), Reflex::Literal("vector"), constructor_4672, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_4662, type_20330), Reflex::Literal("vector"), constructor_4673, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4599), Reflex::Literal("vector"), constructor_4674, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_4675, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1065, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x121, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x122, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_short__funcmem_bld);
}

//------Delayed data member builder for class vector<short int,std::allocator<short int> > -------------------
void __std__vector_short__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<short int,std::allocator<short int> > -------------------
void __std__vector_short__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4597, type_4599), Reflex::Literal("operator="), operator_4676, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_4662), Reflex::Literal("assign"), method_4677, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2364), Reflex::Literal("begin"), method_4678, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2390), Reflex::Literal("begin"), method_4679, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2364), Reflex::Literal("end"), method_4680, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2390), Reflex::Literal("end"), method_4681, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_4686, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_4687, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_113), Reflex::Literal("resize"), method_4688, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_4689, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_4690, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_4691, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3527, type_1654), Reflex::Literal("operator[]"), operator_4692, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4662, type_1654), Reflex::Literal("operator[]"), operator_4693, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3527, type_1654), Reflex::Literal("at"), method_4695, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4662, type_1654), Reflex::Literal("at"), method_4696, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3527), Reflex::Literal("front"), method_4697, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4662), Reflex::Literal("front"), method_4698, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3527), Reflex::Literal("back"), method_4699, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4662), Reflex::Literal("back"), method_4700, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3525), Reflex::Literal("data"), method_4701, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4659), Reflex::Literal("data"), method_4702, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_4662), Reflex::Literal("push_back"), method_4703, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_4704, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2364, type_2364, type_4662), Reflex::Literal("insert"), method_4705, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2364, type_1654, type_4662), Reflex::Literal("insert"), method_4706, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2364, type_2364), Reflex::Literal("erase"), method_4707, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2364, type_2364, type_2364), Reflex::Literal("erase"), method_4708, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_4597), Reflex::Literal("swap"), method_4709, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_4710, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::vector<short int, std::allocator<short int> >,std::allocator<std::vector<short int, std::allocator<short int> > > > -------------------------------
static void constructor_4608( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<short> >();
  else ::new(mem) ::std::vector<std::vector<short> >();
}

static void constructor_4609( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<short> >(*(const ::std::allocator<std::vector<short> >*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<short> >(*(const ::std::allocator<std::vector<short> >*)arg[0]);
}

static void constructor_4610( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<short> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<short> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<short> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<short>*)arg[1]);
  else ::new(mem) ::std::vector<std::vector<short> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<short>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<short> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<short>*)arg[1],
      *(const ::std::allocator<std::vector<short> >*)arg[2]);
  else ::new(mem) ::std::vector<std::vector<short> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<short>*)arg[1],
      *(const ::std::allocator<std::vector<short> >*)arg[2]);
  }
}

static void constructor_4611( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<short> >(*(const ::std::vector<std::vector<short> >*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<short> >(*(const ::std::vector<std::vector<short> >*)arg[0]);
}

static void destructor_4612(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::vector<short> >*)o)->::std::vector<std::vector<short> >::~vector)();
}
static  void operator_4613( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<short> >*)o)->operator=)(*(const ::std::vector<std::vector<short> >*)arg[0]);
  else   (((::std::vector<std::vector<short> >*)o)->operator=)(*(const ::std::vector<std::vector<short> >*)arg[0]);
}

static  void method_4614( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<short> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::vector<short>*)arg[1]);
}

static  void method_4615( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<short>*,std::vector<std::vector<short> > >)((((::std::vector<std::vector<short> >*)o)->begin)());
  else   (((::std::vector<std::vector<short> >*)o)->begin)();
}

static  void method_4616( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::vector<short>*,std::vector<std::vector<short> > >)((((const ::std::vector<std::vector<short> >*)o)->begin)());
  else   (((const ::std::vector<std::vector<short> >*)o)->begin)();
}

static  void method_4617( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<short>*,std::vector<std::vector<short> > >)((((::std::vector<std::vector<short> >*)o)->end)());
  else   (((::std::vector<std::vector<short> >*)o)->end)();
}

static  void method_4618( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::vector<short>*,std::vector<std::vector<short> > >)((((const ::std::vector<std::vector<short> >*)o)->end)());
  else   (((const ::std::vector<std::vector<short> >*)o)->end)();
}

static  void method_4623( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<short> >*)o)->size)());
  else   (((const ::std::vector<std::vector<short> >*)o)->size)();
}

static  void method_4624( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<short> >*)o)->max_size)());
  else   (((const ::std::vector<std::vector<short> >*)o)->max_size)();
}

static  void method_4625( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::vector<short> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::vector<short> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::vector<short>*)arg[1]);
  }
}

static  void method_4626( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<short> >*)o)->capacity)());
  else   (((const ::std::vector<std::vector<short> >*)o)->capacity)();
}

static  void method_4627( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::vector<short> >*)o)->empty)());
  else   (((const ::std::vector<std::vector<short> >*)o)->empty)();
}

static  void method_4628( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<short> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_4629( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<short> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::vector<short> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_4630( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<short> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::vector<short> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_4632( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<short> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::vector<short> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4633( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<short> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::vector<short> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4634( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<short> >*)o)->front)();
  else   (((::std::vector<std::vector<short> >*)o)->front)();
}

static  void method_4635( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<short> >*)o)->front)();
  else   (((const ::std::vector<std::vector<short> >*)o)->front)();
}

static  void method_4636( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<short> >*)o)->back)();
  else   (((::std::vector<std::vector<short> >*)o)->back)();
}

static  void method_4637( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<short> >*)o)->back)();
  else   (((const ::std::vector<std::vector<short> >*)o)->back)();
}

static  void method_4638( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::vector<short> >*)o)->data)());
  else   (((::std::vector<std::vector<short> >*)o)->data)();
}

static  void method_4639( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::vector<short> >*)o)->data)());
  else   (((const ::std::vector<std::vector<short> >*)o)->data)();
}

static  void method_4640( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<short> >*)o)->push_back)(*(const ::std::vector<short>*)arg[0]);
}

static  void method_4641( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::vector<short> >*)o)->pop_back)();
}

static  void method_4642( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<short>*,std::vector<std::vector<short> > >)((((::std::vector<std::vector<short> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<short>*,std::vector<std::vector<short> > >*)arg[0],
    *(const ::std::vector<short>*)arg[1]));
  else   (((::std::vector<std::vector<short> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<short>*,std::vector<std::vector<short> > >*)arg[0],
    *(const ::std::vector<short>*)arg[1]);
}

static  void method_4643( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<short> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<short>*,std::vector<std::vector<short> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::vector<short>*)arg[2]);
}

static  void method_4644( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<short>*,std::vector<std::vector<short> > >)((((::std::vector<std::vector<short> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<short>*,std::vector<std::vector<short> > >*)arg[0]));
  else   (((::std::vector<std::vector<short> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<short>*,std::vector<std::vector<short> > >*)arg[0]);
}

static  void method_4645( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<short>*,std::vector<std::vector<short> > >)((((::std::vector<std::vector<short> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<short>*,std::vector<std::vector<short> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::vector<short>*,std::vector<std::vector<short> > >*)arg[1]));
  else   (((::std::vector<std::vector<short> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<short>*,std::vector<std::vector<short> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::vector<short>*,std::vector<std::vector<short> > >*)arg[1]);
}

static  void method_4646( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<short> >*)o)->swap)(*(::std::vector<std::vector<short> >*)arg[0]);
}

static  void method_4647( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::vector<short> >*)o)->clear)();
}

static void method_newdel_1064( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<short> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<short> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<short> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<short> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<short> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x124( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::vector<short>,std::allocator<std::vector<short> > >")), ::Reflex::BaseOffset< ::std::vector<std::vector<short> >,::std::_Vector_base<std::vector<short>,std::allocator<std::vector<short> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x125( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::vector<short> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::vector<short> > >::Generate();
}

//------Dictionary for class vector<std::vector<short int, std::allocator<short int> >,std::allocator<std::vector<short int, std::allocator<short int> > > > -------------------------------
void __std__vector_std__vector_short_s__db_datamem(Reflex::Class*);
void __std__vector_std__vector_short_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__vector_short_s__datamem_bld(&__std__vector_std__vector_short_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__vector_short_s__funcmem_bld(&__std__vector_std__vector_short_s__db_funcmem);
void __std__vector_std__vector_short_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::vector<short> >"), typeid(::std::vector<std::vector<short> >), sizeof(::std::vector<std::vector<short> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1955, ::Reflex::BaseOffset< ::std::vector<std::vector<short> >, ::std::_Vector_base<std::vector<short>,std::allocator<std::vector<short> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1065, Reflex::Literal("std::vector<std::vector<short> >::_Alloc_value_type"))
  .AddTypedef(type_1955, Reflex::Literal("std::vector<std::vector<short> >::_Base"))
  .AddTypedef(type_1342, Reflex::Literal("std::vector<std::vector<short> >::_Tp_alloc_type"))
  .AddTypedef(type_1065, Reflex::Literal("std::vector<std::vector<short> >::value_type"))
  .AddTypedef(type_4593, Reflex::Literal("std::vector<std::vector<short> >::pointer"))
  .AddTypedef(type_4595, Reflex::Literal("std::vector<std::vector<short> >::const_pointer"))
  .AddTypedef(type_4597, Reflex::Literal("std::vector<std::vector<short> >::reference"))
  .AddTypedef(type_4599, Reflex::Literal("std::vector<std::vector<short> >::const_reference"))
  .AddTypedef(type_2329, Reflex::Literal("std::vector<std::vector<short> >::iterator"))
  .AddTypedef(type_2330, Reflex::Literal("std::vector<std::vector<short> >::const_iterator"))
  .AddTypedef(type_1724, Reflex::Literal("std::vector<std::vector<short> >::const_reverse_iterator"))
  .AddTypedef(type_1725, Reflex::Literal("std::vector<std::vector<short> >::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<std::vector<short> >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<std::vector<short> >::difference_type"))
  .AddTypedef(type_1342, Reflex::Literal("std::vector<std::vector<short> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_4608, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20327), Reflex::Literal("vector"), constructor_4609, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_4599, type_20327), Reflex::Literal("vector"), constructor_4610, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20328), Reflex::Literal("vector"), constructor_4611, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_4612, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1064, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x124, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x125, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__vector_short_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::vector<short int, std::allocator<short int> >,std::allocator<std::vector<short int, std::allocator<short int> > > > -------------------
void __std__vector_std__vector_short_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::vector<short int, std::allocator<short int> >,std::allocator<std::vector<short int, std::allocator<short int> > > > -------------------
void __std__vector_std__vector_short_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20329, type_20328), Reflex::Literal("operator="), operator_4613, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_4599), Reflex::Literal("assign"), method_4614, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2329), Reflex::Literal("begin"), method_4615, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2330), Reflex::Literal("begin"), method_4616, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2329), Reflex::Literal("end"), method_4617, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2330), Reflex::Literal("end"), method_4618, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_4623, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_4624, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_1065), Reflex::Literal("resize"), method_4625, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_4626, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_4627, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_4628, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4597, type_1654), Reflex::Literal("operator[]"), operator_4629, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4599, type_1654), Reflex::Literal("operator[]"), operator_4630, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4597, type_1654), Reflex::Literal("at"), method_4632, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4599, type_1654), Reflex::Literal("at"), method_4633, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4597), Reflex::Literal("front"), method_4634, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4599), Reflex::Literal("front"), method_4635, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4597), Reflex::Literal("back"), method_4636, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4599), Reflex::Literal("back"), method_4637, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4593), Reflex::Literal("data"), method_4638, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4595), Reflex::Literal("data"), method_4639, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_4599), Reflex::Literal("push_back"), method_4640, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_4641, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2329, type_2329, type_4599), Reflex::Literal("insert"), method_4642, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2329, type_1654, type_4599), Reflex::Literal("insert"), method_4643, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2329, type_2329), Reflex::Literal("erase"), method_4644, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2329, type_2329, type_2329), Reflex::Literal("erase"), method_4645, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_20329), Reflex::Literal("swap"), method_4646, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_4647, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<float,std::allocator<float> > -------------------------------
static void constructor_4799( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<float>();
  else ::new(mem) ::std::vector<float>();
}

static void constructor_4800( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<float>(*(const ::std::allocator<float>*)arg[0]);
  else ::new(mem) ::std::vector<float>(*(const ::std::allocator<float>*)arg[0]);
}

static void constructor_4801( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<float>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<float>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<float>(*(::std::size_t*)arg[0],
      *(const float*)arg[1]);
  else ::new(mem) ::std::vector<float>(*(::std::size_t*)arg[0],
      *(const float*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<float>(*(::std::size_t*)arg[0],
      *(const float*)arg[1],
      *(const ::std::allocator<float>*)arg[2]);
  else ::new(mem) ::std::vector<float>(*(::std::size_t*)arg[0],
      *(const float*)arg[1],
      *(const ::std::allocator<float>*)arg[2]);
  }
}

static void constructor_4802( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<float>(*(const ::std::vector<float>*)arg[0]);
  else ::new(mem) ::std::vector<float>(*(const ::std::vector<float>*)arg[0]);
}

static void destructor_4803(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<float>*)o)->::std::vector<float>::~vector)();
}
static  void operator_4804( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<float>*)o)->operator=)(*(const ::std::vector<float>*)arg[0]);
  else   (((::std::vector<float>*)o)->operator=)(*(const ::std::vector<float>*)arg[0]);
}

static  void method_4805( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<float>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const float*)arg[1]);
}

static  void method_4806( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<float*,std::vector<float> >)((((::std::vector<float>*)o)->begin)());
  else   (((::std::vector<float>*)o)->begin)();
}

static  void method_4807( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const float*,std::vector<float> >)((((const ::std::vector<float>*)o)->begin)());
  else   (((const ::std::vector<float>*)o)->begin)();
}

static  void method_4808( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<float*,std::vector<float> >)((((::std::vector<float>*)o)->end)());
  else   (((::std::vector<float>*)o)->end)();
}

static  void method_4809( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const float*,std::vector<float> >)((((const ::std::vector<float>*)o)->end)());
  else   (((const ::std::vector<float>*)o)->end)();
}

static  void method_4814( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<float>*)o)->size)());
  else   (((const ::std::vector<float>*)o)->size)();
}

static  void method_4815( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<float>*)o)->max_size)());
  else   (((const ::std::vector<float>*)o)->max_size)();
}

static  void method_4816( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<float>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<float>*)o)->resize)(*(::std::size_t*)arg[0],
      *(float*)arg[1]);
  }
}

static  void method_4817( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<float>*)o)->capacity)());
  else   (((const ::std::vector<float>*)o)->capacity)();
}

static  void method_4818( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<float>*)o)->empty)());
  else   (((const ::std::vector<float>*)o)->empty)();
}

static  void method_4819( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<float>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_4820( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<float>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<float>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_4821( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<float>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<float>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_4823( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<float>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<float>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4824( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<float>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<float>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4825( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<float>*)o)->front)();
  else   (((::std::vector<float>*)o)->front)();
}

static  void method_4826( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<float>*)o)->front)();
  else   (((const ::std::vector<float>*)o)->front)();
}

static  void method_4827( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<float>*)o)->back)();
  else   (((::std::vector<float>*)o)->back)();
}

static  void method_4828( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<float>*)o)->back)();
  else   (((const ::std::vector<float>*)o)->back)();
}

static  void method_4829( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<float>*)o)->data)());
  else   (((::std::vector<float>*)o)->data)();
}

static  void method_4830( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<float>*)o)->data)());
  else   (((const ::std::vector<float>*)o)->data)();
}

static  void method_4831( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<float>*)o)->push_back)(*(const float*)arg[0]);
}

static  void method_4832( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<float>*)o)->pop_back)();
}

static  void method_4833( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<float*,std::vector<float> >)((((::std::vector<float>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<float*,std::vector<float> >*)arg[0],
    *(const float*)arg[1]));
  else   (((::std::vector<float>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<float*,std::vector<float> >*)arg[0],
    *(const float*)arg[1]);
}

static  void method_4834( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<float>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<float*,std::vector<float> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const float*)arg[2]);
}

static  void method_4835( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<float*,std::vector<float> >)((((::std::vector<float>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<float*,std::vector<float> >*)arg[0]));
  else   (((::std::vector<float>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<float*,std::vector<float> >*)arg[0]);
}

static  void method_4836( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<float*,std::vector<float> >)((((::std::vector<float>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<float*,std::vector<float> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<float*,std::vector<float> >*)arg[1]));
  else   (((::std::vector<float>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<float*,std::vector<float> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<float*,std::vector<float> >*)arg[1]);
}

static  void method_4837( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<float>*)o)->swap)(*(::std::vector<float>*)arg[0]);
}

static  void method_4838( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<float>*)o)->clear)();
}

static void method_newdel_1067( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<float> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<float> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<float> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<float> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<float> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x127( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<float,std::allocator<float> >")), ::Reflex::BaseOffset< ::std::vector<float>,::std::_Vector_base<float,std::allocator<float> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x128( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<float> >::Generate();
  else ::Reflex::Proxy< ::std::vector<float> >::Generate();
}

//------Dictionary for class vector<float,std::allocator<float> > -------------------------------
void __std__vector_float__db_datamem(Reflex::Class*);
void __std__vector_float__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_float__datamem_bld(&__std__vector_float__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_float__funcmem_bld(&__std__vector_float__db_funcmem);
void __std__vector_float__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<float>"), typeid(::std::vector<float>), sizeof(::std::vector<float>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1976, ::Reflex::BaseOffset< ::std::vector<float>, ::std::_Vector_base<float,std::allocator<float> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2058, Reflex::Literal("std::vector<float>::_Alloc_value_type"))
  .AddTypedef(type_1976, Reflex::Literal("std::vector<float>::_Base"))
  .AddTypedef(type_1345, Reflex::Literal("std::vector<float>::_Tp_alloc_type"))
  .AddTypedef(type_2058, Reflex::Literal("std::vector<float>::value_type"))
  .AddTypedef(type_2462, Reflex::Literal("std::vector<float>::pointer"))
  .AddTypedef(type_4787, Reflex::Literal("std::vector<float>::const_pointer"))
  .AddTypedef(type_3579, Reflex::Literal("std::vector<float>::reference"))
  .AddTypedef(type_4790, Reflex::Literal("std::vector<float>::const_reference"))
  .AddTypedef(type_2373, Reflex::Literal("std::vector<float>::iterator"))
  .AddTypedef(type_2374, Reflex::Literal("std::vector<float>::const_iterator"))
  .AddTypedef(type_1766, Reflex::Literal("std::vector<float>::const_reverse_iterator"))
  .AddTypedef(type_1767, Reflex::Literal("std::vector<float>::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<float>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<float>::difference_type"))
  .AddTypedef(type_1345, Reflex::Literal("std::vector<float>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_4799, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20336), Reflex::Literal("vector"), constructor_4800, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_4790, type_20336), Reflex::Literal("vector"), constructor_4801, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4727), Reflex::Literal("vector"), constructor_4802, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_4803, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1067, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x127, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x128, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_float__funcmem_bld);
}

//------Delayed data member builder for class vector<float,std::allocator<float> > -------------------
void __std__vector_float__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<float,std::allocator<float> > -------------------
void __std__vector_float__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4725, type_4727), Reflex::Literal("operator="), operator_4804, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_4790), Reflex::Literal("assign"), method_4805, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2373), Reflex::Literal("begin"), method_4806, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2374), Reflex::Literal("begin"), method_4807, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2373), Reflex::Literal("end"), method_4808, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2374), Reflex::Literal("end"), method_4809, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_4814, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_4815, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_2058), Reflex::Literal("resize"), method_4816, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_4817, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_4818, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_4819, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3579, type_1654), Reflex::Literal("operator[]"), operator_4820, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4790, type_1654), Reflex::Literal("operator[]"), operator_4821, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3579, type_1654), Reflex::Literal("at"), method_4823, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4790, type_1654), Reflex::Literal("at"), method_4824, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3579), Reflex::Literal("front"), method_4825, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4790), Reflex::Literal("front"), method_4826, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3579), Reflex::Literal("back"), method_4827, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4790), Reflex::Literal("back"), method_4828, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2462), Reflex::Literal("data"), method_4829, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4787), Reflex::Literal("data"), method_4830, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_4790), Reflex::Literal("push_back"), method_4831, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_4832, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2373, type_2373, type_4790), Reflex::Literal("insert"), method_4833, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2373, type_1654, type_4790), Reflex::Literal("insert"), method_4834, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2373, type_2373), Reflex::Literal("erase"), method_4835, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2373, type_2373, type_2373), Reflex::Literal("erase"), method_4836, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_4725), Reflex::Literal("swap"), method_4837, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_4838, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::vector<float, std::allocator<float> >,std::allocator<std::vector<float, std::allocator<float> > > > -------------------------------
static void constructor_4736( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<float> >();
  else ::new(mem) ::std::vector<std::vector<float> >();
}

static void constructor_4737( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<float> >(*(const ::std::allocator<std::vector<float> >*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<float> >(*(const ::std::allocator<std::vector<float> >*)arg[0]);
}

static void constructor_4738( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<float> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<float> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<float> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<float>*)arg[1]);
  else ::new(mem) ::std::vector<std::vector<float> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<float>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<float> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<float>*)arg[1],
      *(const ::std::allocator<std::vector<float> >*)arg[2]);
  else ::new(mem) ::std::vector<std::vector<float> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<float>*)arg[1],
      *(const ::std::allocator<std::vector<float> >*)arg[2]);
  }
}

static void constructor_4739( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<float> >(*(const ::std::vector<std::vector<float> >*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<float> >(*(const ::std::vector<std::vector<float> >*)arg[0]);
}

static void destructor_4740(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::vector<float> >*)o)->::std::vector<std::vector<float> >::~vector)();
}
static  void operator_4741( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<float> >*)o)->operator=)(*(const ::std::vector<std::vector<float> >*)arg[0]);
  else   (((::std::vector<std::vector<float> >*)o)->operator=)(*(const ::std::vector<std::vector<float> >*)arg[0]);
}

static  void method_4742( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<float> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::vector<float>*)arg[1]);
}

static  void method_4743( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<float>*,std::vector<std::vector<float> > >)((((::std::vector<std::vector<float> >*)o)->begin)());
  else   (((::std::vector<std::vector<float> >*)o)->begin)();
}

static  void method_4744( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::vector<float>*,std::vector<std::vector<float> > >)((((const ::std::vector<std::vector<float> >*)o)->begin)());
  else   (((const ::std::vector<std::vector<float> >*)o)->begin)();
}

static  void method_4745( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<float>*,std::vector<std::vector<float> > >)((((::std::vector<std::vector<float> >*)o)->end)());
  else   (((::std::vector<std::vector<float> >*)o)->end)();
}

static  void method_4746( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::vector<float>*,std::vector<std::vector<float> > >)((((const ::std::vector<std::vector<float> >*)o)->end)());
  else   (((const ::std::vector<std::vector<float> >*)o)->end)();
}

static  void method_4751( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<float> >*)o)->size)());
  else   (((const ::std::vector<std::vector<float> >*)o)->size)();
}

static  void method_4752( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<float> >*)o)->max_size)());
  else   (((const ::std::vector<std::vector<float> >*)o)->max_size)();
}

static  void method_4753( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::vector<float> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::vector<float> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::vector<float>*)arg[1]);
  }
}

static  void method_4754( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<float> >*)o)->capacity)());
  else   (((const ::std::vector<std::vector<float> >*)o)->capacity)();
}

static  void method_4755( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::vector<float> >*)o)->empty)());
  else   (((const ::std::vector<std::vector<float> >*)o)->empty)();
}

static  void method_4756( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<float> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_4757( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<float> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::vector<float> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_4758( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<float> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::vector<float> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_4760( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<float> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::vector<float> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4761( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<float> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::vector<float> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4762( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<float> >*)o)->front)();
  else   (((::std::vector<std::vector<float> >*)o)->front)();
}

static  void method_4763( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<float> >*)o)->front)();
  else   (((const ::std::vector<std::vector<float> >*)o)->front)();
}

static  void method_4764( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<float> >*)o)->back)();
  else   (((::std::vector<std::vector<float> >*)o)->back)();
}

static  void method_4765( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<float> >*)o)->back)();
  else   (((const ::std::vector<std::vector<float> >*)o)->back)();
}

static  void method_4766( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::vector<float> >*)o)->data)());
  else   (((::std::vector<std::vector<float> >*)o)->data)();
}

static  void method_4767( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::vector<float> >*)o)->data)());
  else   (((const ::std::vector<std::vector<float> >*)o)->data)();
}

static  void method_4768( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<float> >*)o)->push_back)(*(const ::std::vector<float>*)arg[0]);
}

static  void method_4769( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::vector<float> >*)o)->pop_back)();
}

static  void method_4770( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<float>*,std::vector<std::vector<float> > >)((((::std::vector<std::vector<float> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<float>*,std::vector<std::vector<float> > >*)arg[0],
    *(const ::std::vector<float>*)arg[1]));
  else   (((::std::vector<std::vector<float> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<float>*,std::vector<std::vector<float> > >*)arg[0],
    *(const ::std::vector<float>*)arg[1]);
}

static  void method_4771( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<float> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<float>*,std::vector<std::vector<float> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::vector<float>*)arg[2]);
}

static  void method_4772( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<float>*,std::vector<std::vector<float> > >)((((::std::vector<std::vector<float> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<float>*,std::vector<std::vector<float> > >*)arg[0]));
  else   (((::std::vector<std::vector<float> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<float>*,std::vector<std::vector<float> > >*)arg[0]);
}

static  void method_4773( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<float>*,std::vector<std::vector<float> > >)((((::std::vector<std::vector<float> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<float>*,std::vector<std::vector<float> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::vector<float>*,std::vector<std::vector<float> > >*)arg[1]));
  else   (((::std::vector<std::vector<float> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<float>*,std::vector<std::vector<float> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::vector<float>*,std::vector<std::vector<float> > >*)arg[1]);
}

static  void method_4774( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<float> >*)o)->swap)(*(::std::vector<std::vector<float> >*)arg[0]);
}

static  void method_4775( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::vector<float> >*)o)->clear)();
}

static void method_newdel_1066( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<float> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<float> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<float> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<float> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<float> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x130( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::vector<float>,std::allocator<std::vector<float> > >")), ::Reflex::BaseOffset< ::std::vector<std::vector<float> >,::std::_Vector_base<std::vector<float>,std::allocator<std::vector<float> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x131( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::vector<float> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::vector<float> > >::Generate();
}

//------Dictionary for class vector<std::vector<float, std::allocator<float> >,std::allocator<std::vector<float, std::allocator<float> > > > -------------------------------
void __std__vector_std__vector_float_s__db_datamem(Reflex::Class*);
void __std__vector_std__vector_float_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__vector_float_s__datamem_bld(&__std__vector_std__vector_float_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__vector_float_s__funcmem_bld(&__std__vector_std__vector_float_s__db_funcmem);
void __std__vector_std__vector_float_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::vector<float> >"), typeid(::std::vector<std::vector<float> >), sizeof(::std::vector<std::vector<float> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1957, ::Reflex::BaseOffset< ::std::vector<std::vector<float> >, ::std::_Vector_base<std::vector<float>,std::allocator<std::vector<float> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1067, Reflex::Literal("std::vector<std::vector<float> >::_Alloc_value_type"))
  .AddTypedef(type_1957, Reflex::Literal("std::vector<std::vector<float> >::_Base"))
  .AddTypedef(type_1344, Reflex::Literal("std::vector<std::vector<float> >::_Tp_alloc_type"))
  .AddTypedef(type_1067, Reflex::Literal("std::vector<std::vector<float> >::value_type"))
  .AddTypedef(type_4721, Reflex::Literal("std::vector<std::vector<float> >::pointer"))
  .AddTypedef(type_4723, Reflex::Literal("std::vector<std::vector<float> >::const_pointer"))
  .AddTypedef(type_4725, Reflex::Literal("std::vector<std::vector<float> >::reference"))
  .AddTypedef(type_4727, Reflex::Literal("std::vector<std::vector<float> >::const_reference"))
  .AddTypedef(type_2333, Reflex::Literal("std::vector<std::vector<float> >::iterator"))
  .AddTypedef(type_2334, Reflex::Literal("std::vector<std::vector<float> >::const_iterator"))
  .AddTypedef(type_1728, Reflex::Literal("std::vector<std::vector<float> >::const_reverse_iterator"))
  .AddTypedef(type_1729, Reflex::Literal("std::vector<std::vector<float> >::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<std::vector<float> >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<std::vector<float> >::difference_type"))
  .AddTypedef(type_1344, Reflex::Literal("std::vector<std::vector<float> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_4736, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20332), Reflex::Literal("vector"), constructor_4737, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_4727, type_20332), Reflex::Literal("vector"), constructor_4738, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20333), Reflex::Literal("vector"), constructor_4739, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_4740, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1066, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x130, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x131, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__vector_float_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::vector<float, std::allocator<float> >,std::allocator<std::vector<float, std::allocator<float> > > > -------------------
void __std__vector_std__vector_float_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::vector<float, std::allocator<float> >,std::allocator<std::vector<float, std::allocator<float> > > > -------------------
void __std__vector_std__vector_float_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20334, type_20333), Reflex::Literal("operator="), operator_4741, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_4727), Reflex::Literal("assign"), method_4742, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2333), Reflex::Literal("begin"), method_4743, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2334), Reflex::Literal("begin"), method_4744, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2333), Reflex::Literal("end"), method_4745, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2334), Reflex::Literal("end"), method_4746, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_4751, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_4752, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_1067), Reflex::Literal("resize"), method_4753, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_4754, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_4755, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_4756, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4725, type_1654), Reflex::Literal("operator[]"), operator_4757, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4727, type_1654), Reflex::Literal("operator[]"), operator_4758, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4725, type_1654), Reflex::Literal("at"), method_4760, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4727, type_1654), Reflex::Literal("at"), method_4761, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4725), Reflex::Literal("front"), method_4762, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4727), Reflex::Literal("front"), method_4763, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4725), Reflex::Literal("back"), method_4764, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4727), Reflex::Literal("back"), method_4765, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4721), Reflex::Literal("data"), method_4766, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4723), Reflex::Literal("data"), method_4767, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_4727), Reflex::Literal("push_back"), method_4768, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_4769, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2333, type_2333, type_4727), Reflex::Literal("insert"), method_4770, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2333, type_1654, type_4727), Reflex::Literal("insert"), method_4771, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2333, type_2333), Reflex::Literal("erase"), method_4772, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2333, type_2333, type_2333), Reflex::Literal("erase"), method_4773, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_20334), Reflex::Literal("swap"), method_4774, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_4775, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<double,std::allocator<double> > -------------------------------
static void constructor_4927( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<double>();
  else ::new(mem) ::std::vector<double>();
}

static void constructor_4928( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<double>(*(const ::std::allocator<double>*)arg[0]);
  else ::new(mem) ::std::vector<double>(*(const ::std::allocator<double>*)arg[0]);
}

static void constructor_4929( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<double>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<double>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<double>(*(::std::size_t*)arg[0],
      *(const double*)arg[1]);
  else ::new(mem) ::std::vector<double>(*(::std::size_t*)arg[0],
      *(const double*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<double>(*(::std::size_t*)arg[0],
      *(const double*)arg[1],
      *(const ::std::allocator<double>*)arg[2]);
  else ::new(mem) ::std::vector<double>(*(::std::size_t*)arg[0],
      *(const double*)arg[1],
      *(const ::std::allocator<double>*)arg[2]);
  }
}

static void constructor_4930( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<double>(*(const ::std::vector<double>*)arg[0]);
  else ::new(mem) ::std::vector<double>(*(const ::std::vector<double>*)arg[0]);
}

static void destructor_4931(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<double>*)o)->::std::vector<double>::~vector)();
}
static  void operator_4932( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<double>*)o)->operator=)(*(const ::std::vector<double>*)arg[0]);
  else   (((::std::vector<double>*)o)->operator=)(*(const ::std::vector<double>*)arg[0]);
}

static  void method_4933( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<double>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const double*)arg[1]);
}

static  void method_4934( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<double*,std::vector<double> >)((((::std::vector<double>*)o)->begin)());
  else   (((::std::vector<double>*)o)->begin)();
}

static  void method_4935( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const double*,std::vector<double> >)((((const ::std::vector<double>*)o)->begin)());
  else   (((const ::std::vector<double>*)o)->begin)();
}

static  void method_4936( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<double*,std::vector<double> >)((((::std::vector<double>*)o)->end)());
  else   (((::std::vector<double>*)o)->end)();
}

static  void method_4937( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const double*,std::vector<double> >)((((const ::std::vector<double>*)o)->end)());
  else   (((const ::std::vector<double>*)o)->end)();
}

static  void method_4942( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<double>*)o)->size)());
  else   (((const ::std::vector<double>*)o)->size)();
}

static  void method_4943( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<double>*)o)->max_size)());
  else   (((const ::std::vector<double>*)o)->max_size)();
}

static  void method_4944( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<double>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<double>*)o)->resize)(*(::std::size_t*)arg[0],
      *(double*)arg[1]);
  }
}

static  void method_4945( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<double>*)o)->capacity)());
  else   (((const ::std::vector<double>*)o)->capacity)();
}

static  void method_4946( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<double>*)o)->empty)());
  else   (((const ::std::vector<double>*)o)->empty)();
}

static  void method_4947( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<double>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_4948( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<double>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<double>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_4949( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<double>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<double>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_4951( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<double>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<double>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4952( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<double>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<double>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4953( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<double>*)o)->front)();
  else   (((::std::vector<double>*)o)->front)();
}

static  void method_4954( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<double>*)o)->front)();
  else   (((const ::std::vector<double>*)o)->front)();
}

static  void method_4955( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<double>*)o)->back)();
  else   (((::std::vector<double>*)o)->back)();
}

static  void method_4956( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<double>*)o)->back)();
  else   (((const ::std::vector<double>*)o)->back)();
}

static  void method_4957( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<double>*)o)->data)());
  else   (((::std::vector<double>*)o)->data)();
}

static  void method_4958( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<double>*)o)->data)());
  else   (((const ::std::vector<double>*)o)->data)();
}

static  void method_4959( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<double>*)o)->push_back)(*(const double*)arg[0]);
}

static  void method_4960( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<double>*)o)->pop_back)();
}

static  void method_4961( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<double*,std::vector<double> >)((((::std::vector<double>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<double*,std::vector<double> >*)arg[0],
    *(const double*)arg[1]));
  else   (((::std::vector<double>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<double*,std::vector<double> >*)arg[0],
    *(const double*)arg[1]);
}

static  void method_4962( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<double>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<double*,std::vector<double> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const double*)arg[2]);
}

static  void method_4963( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<double*,std::vector<double> >)((((::std::vector<double>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<double*,std::vector<double> >*)arg[0]));
  else   (((::std::vector<double>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<double*,std::vector<double> >*)arg[0]);
}

static  void method_4964( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<double*,std::vector<double> >)((((::std::vector<double>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<double*,std::vector<double> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<double*,std::vector<double> >*)arg[1]));
  else   (((::std::vector<double>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<double*,std::vector<double> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<double*,std::vector<double> >*)arg[1]);
}

static  void method_4965( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<double>*)o)->swap)(*(::std::vector<double>*)arg[0]);
}

static  void method_4966( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<double>*)o)->clear)();
}

static void method_newdel_1069( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<double> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<double> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<double> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<double> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<double> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x133( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<double,std::allocator<double> >")), ::Reflex::BaseOffset< ::std::vector<double>,::std::_Vector_base<double,std::allocator<double> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x134( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<double> >::Generate();
  else ::Reflex::Proxy< ::std::vector<double> >::Generate();
}

//------Dictionary for class vector<double,std::allocator<double> > -------------------------------
void __std__vector_double__db_datamem(Reflex::Class*);
void __std__vector_double__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_double__datamem_bld(&__std__vector_double__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_double__funcmem_bld(&__std__vector_double__db_funcmem);
void __std__vector_double__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<double>"), typeid(::std::vector<double>), sizeof(::std::vector<double>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1980, ::Reflex::BaseOffset< ::std::vector<double>, ::std::_Vector_base<double,std::allocator<double> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2052, Reflex::Literal("std::vector<double>::_Alloc_value_type"))
  .AddTypedef(type_1980, Reflex::Literal("std::vector<double>::_Base"))
  .AddTypedef(type_1347, Reflex::Literal("std::vector<double>::_Tp_alloc_type"))
  .AddTypedef(type_2052, Reflex::Literal("std::vector<double>::value_type"))
  .AddTypedef(type_3588, Reflex::Literal("std::vector<double>::pointer"))
  .AddTypedef(type_4915, Reflex::Literal("std::vector<double>::const_pointer"))
  .AddTypedef(type_3590, Reflex::Literal("std::vector<double>::reference"))
  .AddTypedef(type_4918, Reflex::Literal("std::vector<double>::const_reference"))
  .AddTypedef(type_2375, Reflex::Literal("std::vector<double>::iterator"))
  .AddTypedef(type_2382, Reflex::Literal("std::vector<double>::const_iterator"))
  .AddTypedef(type_1780, Reflex::Literal("std::vector<double>::const_reverse_iterator"))
  .AddTypedef(type_1781, Reflex::Literal("std::vector<double>::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<double>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<double>::difference_type"))
  .AddTypedef(type_1347, Reflex::Literal("std::vector<double>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_4927, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20342), Reflex::Literal("vector"), constructor_4928, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_4918, type_20342), Reflex::Literal("vector"), constructor_4929, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4855), Reflex::Literal("vector"), constructor_4930, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_4931, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1069, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x133, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x134, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_double__funcmem_bld);
}

//------Delayed data member builder for class vector<double,std::allocator<double> > -------------------
void __std__vector_double__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<double,std::allocator<double> > -------------------
void __std__vector_double__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4853, type_4855), Reflex::Literal("operator="), operator_4932, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_4918), Reflex::Literal("assign"), method_4933, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2375), Reflex::Literal("begin"), method_4934, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2382), Reflex::Literal("begin"), method_4935, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2375), Reflex::Literal("end"), method_4936, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2382), Reflex::Literal("end"), method_4937, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_4942, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_4943, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_2052), Reflex::Literal("resize"), method_4944, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_4945, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_4946, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_4947, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3590, type_1654), Reflex::Literal("operator[]"), operator_4948, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4918, type_1654), Reflex::Literal("operator[]"), operator_4949, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3590, type_1654), Reflex::Literal("at"), method_4951, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4918, type_1654), Reflex::Literal("at"), method_4952, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3590), Reflex::Literal("front"), method_4953, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4918), Reflex::Literal("front"), method_4954, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3590), Reflex::Literal("back"), method_4955, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4918), Reflex::Literal("back"), method_4956, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3588), Reflex::Literal("data"), method_4957, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4915), Reflex::Literal("data"), method_4958, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_4918), Reflex::Literal("push_back"), method_4959, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_4960, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2375, type_2375, type_4918), Reflex::Literal("insert"), method_4961, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2375, type_1654, type_4918), Reflex::Literal("insert"), method_4962, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2375, type_2375), Reflex::Literal("erase"), method_4963, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2375, type_2375, type_2375), Reflex::Literal("erase"), method_4964, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_4853), Reflex::Literal("swap"), method_4965, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_4966, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::vector<double, std::allocator<double> >,std::allocator<std::vector<double, std::allocator<double> > > > -------------------------------
static void constructor_4864( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<double> >();
  else ::new(mem) ::std::vector<std::vector<double> >();
}

static void constructor_4865( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<double> >(*(const ::std::allocator<std::vector<double> >*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<double> >(*(const ::std::allocator<std::vector<double> >*)arg[0]);
}

static void constructor_4866( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<double> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<double> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<double> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<double>*)arg[1]);
  else ::new(mem) ::std::vector<std::vector<double> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<double>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<double> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<double>*)arg[1],
      *(const ::std::allocator<std::vector<double> >*)arg[2]);
  else ::new(mem) ::std::vector<std::vector<double> >(*(::std::size_t*)arg[0],
      *(const ::std::vector<double>*)arg[1],
      *(const ::std::allocator<std::vector<double> >*)arg[2]);
  }
}

static void constructor_4867( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::vector<double> >(*(const ::std::vector<std::vector<double> >*)arg[0]);
  else ::new(mem) ::std::vector<std::vector<double> >(*(const ::std::vector<std::vector<double> >*)arg[0]);
}

static void destructor_4868(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::vector<double> >*)o)->::std::vector<std::vector<double> >::~vector)();
}
static  void operator_4869( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<double> >*)o)->operator=)(*(const ::std::vector<std::vector<double> >*)arg[0]);
  else   (((::std::vector<std::vector<double> >*)o)->operator=)(*(const ::std::vector<std::vector<double> >*)arg[0]);
}

static  void method_4870( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<double> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::vector<double>*)arg[1]);
}

static  void method_4871( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >)((((::std::vector<std::vector<double> >*)o)->begin)());
  else   (((::std::vector<std::vector<double> >*)o)->begin)();
}

static  void method_4872( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::vector<double>*,std::vector<std::vector<double> > >)((((const ::std::vector<std::vector<double> >*)o)->begin)());
  else   (((const ::std::vector<std::vector<double> >*)o)->begin)();
}

static  void method_4873( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >)((((::std::vector<std::vector<double> >*)o)->end)());
  else   (((::std::vector<std::vector<double> >*)o)->end)();
}

static  void method_4874( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::vector<double>*,std::vector<std::vector<double> > >)((((const ::std::vector<std::vector<double> >*)o)->end)());
  else   (((const ::std::vector<std::vector<double> >*)o)->end)();
}

static  void method_4879( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<double> >*)o)->size)());
  else   (((const ::std::vector<std::vector<double> >*)o)->size)();
}

static  void method_4880( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<double> >*)o)->max_size)());
  else   (((const ::std::vector<std::vector<double> >*)o)->max_size)();
}

static  void method_4881( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::vector<double> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::vector<double> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::vector<double>*)arg[1]);
  }
}

static  void method_4882( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::vector<double> >*)o)->capacity)());
  else   (((const ::std::vector<std::vector<double> >*)o)->capacity)();
}

static  void method_4883( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::vector<double> >*)o)->empty)());
  else   (((const ::std::vector<std::vector<double> >*)o)->empty)();
}

static  void method_4884( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<double> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_4885( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<double> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::vector<double> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_4886( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<double> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::vector<double> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_4888( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<double> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::vector<double> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4889( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<double> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::vector<double> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_4890( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<double> >*)o)->front)();
  else   (((::std::vector<std::vector<double> >*)o)->front)();
}

static  void method_4891( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<double> >*)o)->front)();
  else   (((const ::std::vector<std::vector<double> >*)o)->front)();
}

static  void method_4892( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::vector<double> >*)o)->back)();
  else   (((::std::vector<std::vector<double> >*)o)->back)();
}

static  void method_4893( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::vector<double> >*)o)->back)();
  else   (((const ::std::vector<std::vector<double> >*)o)->back)();
}

static  void method_4894( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::vector<double> >*)o)->data)());
  else   (((::std::vector<std::vector<double> >*)o)->data)();
}

static  void method_4895( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::vector<double> >*)o)->data)());
  else   (((const ::std::vector<std::vector<double> >*)o)->data)();
}

static  void method_4896( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<double> >*)o)->push_back)(*(const ::std::vector<double>*)arg[0]);
}

static  void method_4897( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::vector<double> >*)o)->pop_back)();
}

static  void method_4898( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >)((((::std::vector<std::vector<double> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >*)arg[0],
    *(const ::std::vector<double>*)arg[1]));
  else   (((::std::vector<std::vector<double> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >*)arg[0],
    *(const ::std::vector<double>*)arg[1]);
}

static  void method_4899( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<double> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::vector<double>*)arg[2]);
}

static  void method_4900( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >)((((::std::vector<std::vector<double> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >*)arg[0]));
  else   (((::std::vector<std::vector<double> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >*)arg[0]);
}

static  void method_4901( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >)((((::std::vector<std::vector<double> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >*)arg[1]));
  else   (((::std::vector<std::vector<double> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::vector<double>*,std::vector<std::vector<double> > >*)arg[1]);
}

static  void method_4902( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::vector<double> >*)o)->swap)(*(::std::vector<std::vector<double> >*)arg[0]);
}

static  void method_4903( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::vector<double> >*)o)->clear)();
}

static void method_newdel_1068( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<double> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<double> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<double> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<double> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::vector<double> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x136( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::vector<double>,std::allocator<std::vector<double> > >")), ::Reflex::BaseOffset< ::std::vector<std::vector<double> >,::std::_Vector_base<std::vector<double>,std::allocator<std::vector<double> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x137( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::vector<double> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::vector<double> > >::Generate();
}

//------Dictionary for class vector<std::vector<double, std::allocator<double> >,std::allocator<std::vector<double, std::allocator<double> > > > -------------------------------
void __std__vector_std__vector_double_s__db_datamem(Reflex::Class*);
void __std__vector_std__vector_double_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__vector_double_s__datamem_bld(&__std__vector_std__vector_double_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__vector_double_s__funcmem_bld(&__std__vector_std__vector_double_s__db_funcmem);
void __std__vector_std__vector_double_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::vector<double> >"), typeid(::std::vector<std::vector<double> >), sizeof(::std::vector<std::vector<double> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1958, ::Reflex::BaseOffset< ::std::vector<std::vector<double> >, ::std::_Vector_base<std::vector<double>,std::allocator<std::vector<double> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1069, Reflex::Literal("std::vector<std::vector<double> >::_Alloc_value_type"))
  .AddTypedef(type_1958, Reflex::Literal("std::vector<std::vector<double> >::_Base"))
  .AddTypedef(type_1346, Reflex::Literal("std::vector<std::vector<double> >::_Tp_alloc_type"))
  .AddTypedef(type_1069, Reflex::Literal("std::vector<std::vector<double> >::value_type"))
  .AddTypedef(type_4849, Reflex::Literal("std::vector<std::vector<double> >::pointer"))
  .AddTypedef(type_4851, Reflex::Literal("std::vector<std::vector<double> >::const_pointer"))
  .AddTypedef(type_4853, Reflex::Literal("std::vector<std::vector<double> >::reference"))
  .AddTypedef(type_4855, Reflex::Literal("std::vector<std::vector<double> >::const_reference"))
  .AddTypedef(type_2335, Reflex::Literal("std::vector<std::vector<double> >::iterator"))
  .AddTypedef(type_2336, Reflex::Literal("std::vector<std::vector<double> >::const_iterator"))
  .AddTypedef(type_1730, Reflex::Literal("std::vector<std::vector<double> >::const_reverse_iterator"))
  .AddTypedef(type_1731, Reflex::Literal("std::vector<std::vector<double> >::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<std::vector<double> >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<std::vector<double> >::difference_type"))
  .AddTypedef(type_1346, Reflex::Literal("std::vector<std::vector<double> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_4864, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20338), Reflex::Literal("vector"), constructor_4865, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_4855, type_20338), Reflex::Literal("vector"), constructor_4866, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20339), Reflex::Literal("vector"), constructor_4867, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_4868, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1068, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x136, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x137, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__vector_double_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::vector<double, std::allocator<double> >,std::allocator<std::vector<double, std::allocator<double> > > > -------------------
void __std__vector_std__vector_double_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::vector<double, std::allocator<double> >,std::allocator<std::vector<double, std::allocator<double> > > > -------------------
void __std__vector_std__vector_double_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20340, type_20339), Reflex::Literal("operator="), operator_4869, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_4855), Reflex::Literal("assign"), method_4870, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2335), Reflex::Literal("begin"), method_4871, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2336), Reflex::Literal("begin"), method_4872, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2335), Reflex::Literal("end"), method_4873, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2336), Reflex::Literal("end"), method_4874, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_4879, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_4880, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_1069), Reflex::Literal("resize"), method_4881, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_4882, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_4883, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_4884, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4853, type_1654), Reflex::Literal("operator[]"), operator_4885, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4855, type_1654), Reflex::Literal("operator[]"), operator_4886, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4853, type_1654), Reflex::Literal("at"), method_4888, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4855, type_1654), Reflex::Literal("at"), method_4889, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4853), Reflex::Literal("front"), method_4890, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4855), Reflex::Literal("front"), method_4891, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4853), Reflex::Literal("back"), method_4892, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4855), Reflex::Literal("back"), method_4893, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4849), Reflex::Literal("data"), method_4894, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4851), Reflex::Literal("data"), method_4895, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_4855), Reflex::Literal("push_back"), method_4896, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_4897, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2335, type_2335, type_4855), Reflex::Literal("insert"), method_4898, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2335, type_1654, type_4855), Reflex::Literal("insert"), method_4899, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2335, type_2335), Reflex::Literal("erase"), method_4900, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2335, type_2335, type_2335), Reflex::Literal("erase"), method_4901, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_20340), Reflex::Literal("swap"), method_4902, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_4903, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class basic_string<char,std::char_traits<char>,std::allocator<char> > -------------------------------
static void constructor_6503( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>();
  else ::new(mem) ::std::basic_string<char>();
}

static void constructor_6504( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(const ::std::allocator<char>*)arg[0]);
  else ::new(mem) ::std::basic_string<char>(*(const ::std::allocator<char>*)arg[0]);
}

static void constructor_6505( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0]);
  else ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0]);
}

static void constructor_6506( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]);
  else ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1],
      *(::std::size_t*)arg[2]);
  else ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1],
      *(::std::size_t*)arg[2]);
  }
}

static void constructor_6507( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1],
      *(::std::size_t*)arg[2],
      *(const ::std::allocator<char>*)arg[3]);
  else ::new(mem) ::std::basic_string<char>(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1],
      *(::std::size_t*)arg[2],
      *(const ::std::allocator<char>*)arg[3]);
}

static void constructor_6508( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>((const char*)arg[0],
      *(::std::size_t*)arg[1]);
  else ::new(mem) ::std::basic_string<char>((const char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>((const char*)arg[0],
      *(::std::size_t*)arg[1],
      *(const ::std::allocator<char>*)arg[2]);
  else ::new(mem) ::std::basic_string<char>((const char*)arg[0],
      *(::std::size_t*)arg[1],
      *(const ::std::allocator<char>*)arg[2]);
  }
}

static void constructor_6509( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>((const char*)arg[0]);
  else ::new(mem) ::std::basic_string<char>((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>((const char*)arg[0],
      *(const ::std::allocator<char>*)arg[1]);
  else ::new(mem) ::std::basic_string<char>((const char*)arg[0],
      *(const ::std::allocator<char>*)arg[1]);
  }
}

static void constructor_6510( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(::std::size_t*)arg[0],
      *(char*)arg[1]);
  else ::new(mem) ::std::basic_string<char>(*(::std::size_t*)arg[0],
      *(char*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::basic_string<char>(*(::std::size_t*)arg[0],
      *(char*)arg[1],
      *(const ::std::allocator<char>*)arg[2]);
  else ::new(mem) ::std::basic_string<char>(*(::std::size_t*)arg[0],
      *(char*)arg[1],
      *(const ::std::allocator<char>*)arg[2]);
  }
}

static void destructor_6511(void*, void * o, const std::vector<void*>&, void *) {
(((::std::basic_string<char>*)o)->::std::basic_string<char>::~basic_string)();
}
static  void operator_6512( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator=)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator=)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void operator_6513( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator=)((const char*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator=)((const char*)arg[0]);
}

static  void operator_6514( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator=)(*(char*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator=)(*(char*)arg[0]);
}

static  void method_6515( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >)((((::std::basic_string<char>*)o)->begin)());
  else   (((::std::basic_string<char>*)o)->begin)();
}

static  void method_6516( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >)((((const ::std::basic_string<char>*)o)->begin)());
  else   (((const ::std::basic_string<char>*)o)->begin)();
}

static  void method_6517( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >)((((::std::basic_string<char>*)o)->end)());
  else   (((::std::basic_string<char>*)o)->end)();
}

static  void method_6518( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >)((((const ::std::basic_string<char>*)o)->end)());
  else   (((const ::std::basic_string<char>*)o)->end)();
}

static  void method_6523( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->size)());
  else   (((const ::std::basic_string<char>*)o)->size)();
}

static  void method_6524( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->length)());
  else   (((const ::std::basic_string<char>*)o)->length)();
}

static  void method_6525( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->max_size)());
  else   (((const ::std::basic_string<char>*)o)->max_size)();
}

static  void method_6526( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::basic_string<char>*)o)->resize)(*(::std::size_t*)arg[0],
    *(char*)arg[1]);
}

static  void method_6527( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::basic_string<char>*)o)->resize)(*(::std::size_t*)arg[0]);
}

static  void method_6528( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->capacity)());
  else   (((const ::std::basic_string<char>*)o)->capacity)();
}

static  void method_6529( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    (((::std::basic_string<char>*)o)->reserve)();
  }
  else if ( arg.size() == 1 ) { 
    (((::std::basic_string<char>*)o)->reserve)(*(::std::size_t*)arg[0]);
  }
}

static  void method_6530( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::basic_string<char>*)o)->clear)();
}

static  void method_6531( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::basic_string<char>*)o)->empty)());
  else   (((const ::std::basic_string<char>*)o)->empty)();
}

static  void operator_6532( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::basic_string<char>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::basic_string<char>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_6533( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_6534( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::basic_string<char>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::basic_string<char>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6535( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::basic_string<char>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void operator_6536( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator+=)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator+=)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void operator_6537( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator+=)((const char*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator+=)((const char*)arg[0]);
}

static  void operator_6538( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->operator+=)(*(char*)arg[0]);
  else   (((::std::basic_string<char>*)o)->operator+=)(*(char*)arg[0]);
}

static  void method_6539( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->append)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::basic_string<char>*)o)->append)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_6540( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->append)(*(const ::std::basic_string<char>*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]);
  else   (((::std::basic_string<char>*)o)->append)(*(const ::std::basic_string<char>*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_6541( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->append)((const char*)arg[0],
    *(::std::size_t*)arg[1]);
  else   (((::std::basic_string<char>*)o)->append)((const char*)arg[0],
    *(::std::size_t*)arg[1]);
}

static  void method_6542( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->append)((const char*)arg[0]);
  else   (((::std::basic_string<char>*)o)->append)((const char*)arg[0]);
}

static  void method_6543( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->append)(*(::std::size_t*)arg[0],
    *(char*)arg[1]);
  else   (((::std::basic_string<char>*)o)->append)(*(::std::size_t*)arg[0],
    *(char*)arg[1]);
}

static  void method_6544( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::basic_string<char>*)o)->push_back)(*(char*)arg[0]);
}

static  void method_6545( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->assign)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::basic_string<char>*)o)->assign)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_6546( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->assign)(*(const ::std::basic_string<char>*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]);
  else   (((::std::basic_string<char>*)o)->assign)(*(const ::std::basic_string<char>*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_6547( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->assign)((const char*)arg[0],
    *(::std::size_t*)arg[1]);
  else   (((::std::basic_string<char>*)o)->assign)((const char*)arg[0],
    *(::std::size_t*)arg[1]);
}

static  void method_6548( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->assign)((const char*)arg[0]);
  else   (((::std::basic_string<char>*)o)->assign)((const char*)arg[0]);
}

static  void method_6549( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->assign)(*(::std::size_t*)arg[0],
    *(char*)arg[1]);
  else   (((::std::basic_string<char>*)o)->assign)(*(::std::size_t*)arg[0],
    *(char*)arg[1]);
}

static  void method_6550( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::basic_string<char>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(char*)arg[2]);
}

static  void method_6551( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->insert)(*(::std::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
  else   (((::std::basic_string<char>*)o)->insert)(*(::std::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_6552( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->insert)(*(::std::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1],
    *(::std::size_t*)arg[2],
    *(::std::size_t*)arg[3]);
  else   (((::std::basic_string<char>*)o)->insert)(*(::std::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1],
    *(::std::size_t*)arg[2],
    *(::std::size_t*)arg[3]);
}

static  void method_6553( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->insert)(*(::std::size_t*)arg[0],
    (const char*)arg[1],
    *(::std::size_t*)arg[2]);
  else   (((::std::basic_string<char>*)o)->insert)(*(::std::size_t*)arg[0],
    (const char*)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_6554( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->insert)(*(::std::size_t*)arg[0],
    (const char*)arg[1]);
  else   (((::std::basic_string<char>*)o)->insert)(*(::std::size_t*)arg[0],
    (const char*)arg[1]);
}

static  void method_6555( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->insert)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(char*)arg[2]);
  else   (((::std::basic_string<char>*)o)->insert)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(char*)arg[2]);
}

static  void method_6556( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >)((((::std::basic_string<char>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(char*)arg[1]));
  else   (((::std::basic_string<char>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(char*)arg[1]);
}

static  void method_6557( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->erase)();
    else     (((::std::basic_string<char>*)o)->erase)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->erase)(*(::std::size_t*)arg[0]);
    else     (((::std::basic_string<char>*)o)->erase)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->erase)(*(::std::size_t*)arg[0],
      *(::std::size_t*)arg[1]);
    else     (((::std::basic_string<char>*)o)->erase)(*(::std::size_t*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_6558( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >)((((::std::basic_string<char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0]));
  else   (((::std::basic_string<char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0]);
}

static  void method_6559( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >)((((::std::basic_string<char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1]));
  else   (((::std::basic_string<char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1]);
}

static  void method_6560( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]);
}

static  void method_6561( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2],
    *(::std::size_t*)arg[3],
    *(::std::size_t*)arg[4]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2],
    *(::std::size_t*)arg[3],
    *(::std::size_t*)arg[4]);
}

static  void method_6562( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    (const char*)arg[2],
    *(::std::size_t*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    (const char*)arg[2],
    *(::std::size_t*)arg[3]);
}

static  void method_6563( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    (const char*)arg[2]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    (const char*)arg[2]);
}

static  void method_6564( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2],
    *(char*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2],
    *(char*)arg[3]);
}

static  void method_6565( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]);
}

static  void method_6566( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (const char*)arg[2],
    *(::std::size_t*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (const char*)arg[2],
    *(::std::size_t*)arg[3]);
}

static  void method_6567( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (const char*)arg[2]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (const char*)arg[2]);
}

static  void method_6568( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(::std::size_t*)arg[2],
    *(char*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(::std::size_t*)arg[2],
    *(char*)arg[3]);
}

static  void method_6569( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (char*)arg[2],
    (char*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (char*)arg[2],
    (char*)arg[3]);
}

static  void method_6570( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (const char*)arg[2],
    (const char*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    (const char*)arg[2],
    (const char*)arg[3]);
}

static  void method_6571( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[2],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[2],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[3]);
}

static  void method_6572( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(::__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >*)arg[2],
    *(::__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >*)arg[3]);
  else   (((::std::basic_string<char>*)o)->replace)(*(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::basic_string<char> >*)arg[1],
    *(::__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >*)arg[2],
    *(::__gnu_cxx::__normal_iterator<const char*,std::basic_string<char> >*)arg[3]);
}

static  void method_6577( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 2 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->copy)((char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->copy)((char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->copy)((char*)arg[0],
      *(::std::size_t*)arg[1],
      *(::std::size_t*)arg[2]));
    else     (((const ::std::basic_string<char>*)o)->copy)((char*)arg[0],
      *(::std::size_t*)arg[1],
      *(::std::size_t*)arg[2]);
  }
}

static  void method_6578( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::basic_string<char>*)o)->swap)(*(::std::basic_string<char>*)arg[0]);
}

static  void method_6579( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::basic_string<char>*)o)->c_str)());
  else   (((const ::std::basic_string<char>*)o)->c_str)();
}

static  void method_6580( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::basic_string<char>*)o)->data)());
  else   (((const ::std::basic_string<char>*)o)->data)();
}

static  void method_6581( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<char>)((((const ::std::basic_string<char>*)o)->get_allocator)());
  else   (((const ::std::basic_string<char>*)o)->get_allocator)();
}

static  void method_6582( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->find)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_6583( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_6584( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find)((const char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find)((const char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find)((const char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_6585( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find)(*(char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find)(*(char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find)(*(char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_6586( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->rfind)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->rfind)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->rfind)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->rfind)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_6587( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->rfind)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->rfind)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_6588( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->rfind)((const char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->rfind)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->rfind)((const char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->rfind)((const char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_6589( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->rfind)(*(char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->rfind)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->rfind)(*(char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->rfind)(*(char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_6590( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_of)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_first_of)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_first_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_6591( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_of)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->find_first_of)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_6592( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_of)((const char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_first_of)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_of)((const char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_first_of)((const char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_6593( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_of)(*(char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_first_of)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_of)(*(char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_first_of)(*(char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_6594( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_of)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_last_of)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_last_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_6595( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_of)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->find_last_of)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_6596( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_of)((const char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_last_of)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_of)((const char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_last_of)((const char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_6597( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_of)(*(char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_last_of)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_of)(*(char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_last_of)(*(char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_6598( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_first_not_of)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_first_not_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_6599( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->find_first_not_of)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_6600( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)((const char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_first_not_of)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)((const char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_first_not_of)((const char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_6601( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)(*(char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_first_not_of)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_first_not_of)(*(char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_first_not_of)(*(char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_6602( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)(*(const ::std::basic_string<char>*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_last_not_of)(*(const ::std::basic_string<char>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_last_not_of)(*(const ::std::basic_string<char>*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_6603( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->find_last_not_of)((const char*)arg[0],
    *(::std::size_t*)arg[1],
    *(::std::size_t*)arg[2]);
}

static  void method_6604( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)((const char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_last_not_of)((const char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)((const char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_last_not_of)((const char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_6605( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)(*(char*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->find_last_not_of)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::size_t)((((const ::std::basic_string<char>*)o)->find_last_not_of)(*(char*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->find_last_not_of)(*(char*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_6606( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::std::basic_string<char>*)o)->substr)());
    else     (((const ::std::basic_string<char>*)o)->substr)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::std::basic_string<char>*)o)->substr)(*(::std::size_t*)arg[0]));
    else     (((const ::std::basic_string<char>*)o)->substr)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::std::basic_string<char>*)o)->substr)(*(::std::size_t*)arg[0],
      *(::std::size_t*)arg[1]));
    else     (((const ::std::basic_string<char>*)o)->substr)(*(::std::size_t*)arg[0],
      *(::std::size_t*)arg[1]);
  }
}

static  void method_6607( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::std::basic_string<char>*)o)->compare)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::basic_string<char>*)o)->compare)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_6608( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::std::basic_string<char>*)o)->compare)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->compare)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]);
}

static  void method_6609( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::std::basic_string<char>*)o)->compare)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2],
    *(::std::size_t*)arg[3],
    *(::std::size_t*)arg[4]));
  else   (((const ::std::basic_string<char>*)o)->compare)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2],
    *(::std::size_t*)arg[3],
    *(::std::size_t*)arg[4]);
}

static  void method_6610( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::std::basic_string<char>*)o)->compare)((const char*)arg[0]));
  else   (((const ::std::basic_string<char>*)o)->compare)((const char*)arg[0]);
}

static  void method_6611( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::std::basic_string<char>*)o)->compare)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    (const char*)arg[2]));
  else   (((const ::std::basic_string<char>*)o)->compare)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    (const char*)arg[2]);
}

static  void method_6612( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::std::basic_string<char>*)o)->compare)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    (const char*)arg[2],
    *(::std::size_t*)arg[3]));
  else   (((const ::std::basic_string<char>*)o)->compare)(*(::std::size_t*)arg[0],
    *(::std::size_t*)arg[1],
    (const char*)arg[2],
    *(::std::size_t*)arg[3]);
}

static void method_newdel_1104( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::basic_string<char> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::basic_string<char> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::basic_string<char> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::basic_string<char> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::basic_string<char> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class basic_string<char,std::char_traits<char>,std::allocator<char> > -------------------------------
void __std__basic_string_char__db_datamem(Reflex::Class*);
void __std__basic_string_char__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__basic_string_char__datamem_bld(&__std__basic_string_char__db_datamem);
Reflex::GenreflexMemberBuilder __std__basic_string_char__funcmem_bld(&__std__basic_string_char__db_funcmem);
void __std__basic_string_char__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::basic_string<char>"), typeid(::std::basic_string<char>), sizeof(::std::basic_string<char>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddDataMember(type_1654c, Reflex::Literal("npos"), (size_t)&std::basic_string<char>::npos, ::Reflex::PUBLIC | Reflex::STATIC | Reflex::CONST)
  .AddTypedef(type_1350, Reflex::Literal("std::basic_string<char>::_CharT_alloc_type"))
  .AddTypedef(type_1605, Reflex::Literal("std::basic_string<char>::traits_type"))
  .AddTypedef(type_2616, Reflex::Literal("std::basic_string<char>::value_type"))
  .AddTypedef(type_1350, Reflex::Literal("std::basic_string<char>::allocator_type"))
  .AddTypedef(type_1654, Reflex::Literal("std::basic_string<char>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::basic_string<char>::difference_type"))
  .AddTypedef(type_3600, Reflex::Literal("std::basic_string<char>::reference"))
  .AddTypedef(type_6272, Reflex::Literal("std::basic_string<char>::const_reference"))
  .AddTypedef(type_791, Reflex::Literal("std::basic_string<char>::pointer"))
  .AddTypedef(type_2053, Reflex::Literal("std::basic_string<char>::const_pointer"))
  .AddTypedef(type_2396, Reflex::Literal("std::basic_string<char>::iterator"))
  .AddTypedef(type_2397, Reflex::Literal("std::basic_string<char>::const_iterator"))
  .AddTypedef(type_1880, Reflex::Literal("std::basic_string<char>::const_reverse_iterator"))
  .AddTypedef(type_1881, Reflex::Literal("std::basic_string<char>::reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("basic_string"), constructor_6503, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20416), Reflex::Literal("basic_string"), constructor_6504, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4981), Reflex::Literal("basic_string"), constructor_6505, 0, "__str", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4981, type_1654, type_1654), Reflex::Literal("basic_string"), constructor_6506, 0, "__str;__pos;__n=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_4981, type_1654, type_1654, type_20416), Reflex::Literal("basic_string"), constructor_6507, 0, "__str;__pos;__n;__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2053, type_1654, type_20416), Reflex::Literal("basic_string"), constructor_6508, 0, "__s;__n;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2053, type_20416), Reflex::Literal("basic_string"), constructor_6509, 0, "__s;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_2616, type_20416), Reflex::Literal("basic_string"), constructor_6510, 0, "__n;__c;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~basic_string"), destructor_6511, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1104, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__basic_string_char__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__basic_string_char__funcmem_bld);
}

//------Delayed data member builder for class basic_string<char,std::char_traits<char>,std::allocator<char> > -------------------
void __std__basic_string_char__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_6481, Reflex::Literal("_M_dataplus"), OffsetOf(__shadow__::__std__basic_string_char_, _M_dataplus), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class basic_string<char,std::char_traits<char>,std::allocator<char> > -------------------
void __std__basic_string_char__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_4981), Reflex::Literal("operator="), operator_6512, 0, "__str", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_2053), Reflex::Literal("operator="), operator_6513, 0, "__s", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_2616), Reflex::Literal("operator="), operator_6514, 0, "__c", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2396), Reflex::Literal("begin"), method_6515, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2397), Reflex::Literal("begin"), method_6516, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2396), Reflex::Literal("end"), method_6517, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2397), Reflex::Literal("end"), method_6518, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_6523, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("length"), method_6524, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_6525, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_2616), Reflex::Literal("resize"), method_6526, 0, "__n;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("resize"), method_6527, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_6528, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_6529, 0, "__res=0", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_6530, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_6531, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6272, type_1654), Reflex::Literal("operator[]"), operator_6532, 0, "__pos", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3600, type_1654), Reflex::Literal("operator[]"), operator_6533, 0, "__pos", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6272, type_1654), Reflex::Literal("at"), method_6534, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3600, type_1654), Reflex::Literal("at"), method_6535, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_4981), Reflex::Literal("operator+="), operator_6536, 0, "__str", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_2053), Reflex::Literal("operator+="), operator_6537, 0, "__s", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_2616), Reflex::Literal("operator+="), operator_6538, 0, "__c", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_4981), Reflex::Literal("append"), method_6539, 0, "__str", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_4981, type_1654, type_1654), Reflex::Literal("append"), method_6540, 0, "__str;__pos;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_2053, type_1654), Reflex::Literal("append"), method_6541, 0, "__s;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_2053), Reflex::Literal("append"), method_6542, 0, "__s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_1654, type_2616), Reflex::Literal("append"), method_6543, 0, "__n;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2616), Reflex::Literal("push_back"), method_6544, 0, "__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_4981), Reflex::Literal("assign"), method_6545, 0, "__str", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_4981, type_1654, type_1654), Reflex::Literal("assign"), method_6546, 0, "__str;__pos;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_2053, type_1654), Reflex::Literal("assign"), method_6547, 0, "__s;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_2053), Reflex::Literal("assign"), method_6548, 0, "__s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_1654, type_2616), Reflex::Literal("assign"), method_6549, 0, "__n;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2396, type_1654, type_2616), Reflex::Literal("insert"), method_6550, 0, "__p;__n;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_1654, type_4981), Reflex::Literal("insert"), method_6551, 0, "__pos1;__str", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_1654, type_4981, type_1654, type_1654), Reflex::Literal("insert"), method_6552, 0, "__pos1;__str;__pos2;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_1654, type_2053, type_1654), Reflex::Literal("insert"), method_6553, 0, "__pos;__s;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_1654, type_2053), Reflex::Literal("insert"), method_6554, 0, "__pos;__s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_1654, type_1654, type_2616), Reflex::Literal("insert"), method_6555, 0, "__pos;__n;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2396, type_2396, type_2616), Reflex::Literal("insert"), method_6556, 0, "__p;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_1654, type_1654), Reflex::Literal("erase"), method_6557, 0, "__pos=0;__n=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2396, type_2396), Reflex::Literal("erase"), method_6558, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2396, type_2396, type_2396), Reflex::Literal("erase"), method_6559, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_1654, type_1654, type_4981), Reflex::Literal("replace"), method_6560, 0, "__pos;__n;__str", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_1654, type_1654, type_4981, type_1654, type_1654), Reflex::Literal("replace"), method_6561, 0, "__pos1;__n1;__str;__pos2;__n2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_1654, type_1654, type_2053, type_1654), Reflex::Literal("replace"), method_6562, 0, "__pos;__n1;__s;__n2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_1654, type_1654, type_2053), Reflex::Literal("replace"), method_6563, 0, "__pos;__n1;__s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_1654, type_1654, type_1654, type_2616), Reflex::Literal("replace"), method_6564, 0, "__pos;__n1;__n2;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_2396, type_2396, type_4981), Reflex::Literal("replace"), method_6565, 0, "__i1;__i2;__str", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_2396, type_2396, type_2053, type_1654), Reflex::Literal("replace"), method_6566, 0, "__i1;__i2;__s;__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_2396, type_2396, type_2053), Reflex::Literal("replace"), method_6567, 0, "__i1;__i2;__s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_2396, type_2396, type_1654, type_2616), Reflex::Literal("replace"), method_6568, 0, "__i1;__i2;__n;__c", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_2396, type_2396, type_791, type_791), Reflex::Literal("replace"), method_6569, 0, "__i1;__i2;__k1;__k2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_2396, type_2396, type_2053, type_2053), Reflex::Literal("replace"), method_6570, 0, "__i1;__i2;__k1;__k2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_2396, type_2396, type_2396, type_2396), Reflex::Literal("replace"), method_6571, 0, "__i1;__i2;__k1;__k2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_2396, type_2396, type_2397, type_2397), Reflex::Literal("replace"), method_6572, 0, "__i1;__i2;__k1;__k2", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_791, type_1654, type_1654), Reflex::Literal("copy"), method_6577, 0, "__s;__n;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_3516), Reflex::Literal("swap"), method_6578, 0, "__s", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2053), Reflex::Literal("c_str"), method_6579, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2053), Reflex::Literal("data"), method_6580, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1350), Reflex::Literal("get_allocator"), method_6581, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_2053, type_1654, type_1654), Reflex::Literal("find"), method_6582, 0, "__s;__pos;__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4981, type_1654), Reflex::Literal("find"), method_6583, 0, "__str;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_2053, type_1654), Reflex::Literal("find"), method_6584, 0, "__s;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_2616, type_1654), Reflex::Literal("find"), method_6585, 0, "__c;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4981, type_1654), Reflex::Literal("rfind"), method_6586, 0, "__str;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_2053, type_1654, type_1654), Reflex::Literal("rfind"), method_6587, 0, "__s;__pos;__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_2053, type_1654), Reflex::Literal("rfind"), method_6588, 0, "__s;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_2616, type_1654), Reflex::Literal("rfind"), method_6589, 0, "__c;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4981, type_1654), Reflex::Literal("find_first_of"), method_6590, 0, "__str;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_2053, type_1654, type_1654), Reflex::Literal("find_first_of"), method_6591, 0, "__s;__pos;__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_2053, type_1654), Reflex::Literal("find_first_of"), method_6592, 0, "__s;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_2616, type_1654), Reflex::Literal("find_first_of"), method_6593, 0, "__c;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4981, type_1654), Reflex::Literal("find_last_of"), method_6594, 0, "__str;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_2053, type_1654, type_1654), Reflex::Literal("find_last_of"), method_6595, 0, "__s;__pos;__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_2053, type_1654), Reflex::Literal("find_last_of"), method_6596, 0, "__s;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_2616, type_1654), Reflex::Literal("find_last_of"), method_6597, 0, "__c;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4981, type_1654), Reflex::Literal("find_first_not_of"), method_6598, 0, "__str;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_2053, type_1654, type_1654), Reflex::Literal("find_first_not_of"), method_6599, 0, "__s;__pos;__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_2053, type_1654), Reflex::Literal("find_first_not_of"), method_6600, 0, "__s;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_2616, type_1654), Reflex::Literal("find_first_not_of"), method_6601, 0, "__c;__pos=0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4981, type_1654), Reflex::Literal("find_last_not_of"), method_6602, 0, "__str;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_2053, type_1654, type_1654), Reflex::Literal("find_last_not_of"), method_6603, 0, "__s;__pos;__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_2053, type_1654), Reflex::Literal("find_last_not_of"), method_6604, 0, "__s;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_2616, type_1654), Reflex::Literal("find_last_not_of"), method_6605, 0, "__c;__pos=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1104, type_1654, type_1654), Reflex::Literal("substr"), method_6606, 0, "__pos=0;__n=std::basic_string<_CharT, _Traits, _Alloc>::npos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22, type_4981), Reflex::Literal("compare"), method_6607, 0, "__str", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22, type_1654, type_1654, type_4981), Reflex::Literal("compare"), method_6608, 0, "__pos;__n;__str", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22, type_1654, type_1654, type_4981, type_1654, type_1654), Reflex::Literal("compare"), method_6609, 0, "__pos1;__n1;__str;__pos2;__n2", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22, type_2053), Reflex::Literal("compare"), method_6610, 0, "__s", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22, type_1654, type_1654, type_2053), Reflex::Literal("compare"), method_6611, 0, "__pos;__n1;__s", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22, type_1654, type_1654, type_2053, type_1654), Reflex::Literal("compare"), method_6612, 0, "__pos;__n1;__s;__n2", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > -------------------------------
static void constructor_4990( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::basic_string<char> >();
  else ::new(mem) ::std::vector<std::basic_string<char> >();
}

static void constructor_4991( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::basic_string<char> >(*(const ::std::allocator<std::basic_string<char> >*)arg[0]);
  else ::new(mem) ::std::vector<std::basic_string<char> >(*(const ::std::allocator<std::basic_string<char> >*)arg[0]);
}

static void constructor_4992( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::basic_string<char> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::basic_string<char> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::basic_string<char> >(*(::std::size_t*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
  else ::new(mem) ::std::vector<std::basic_string<char> >(*(::std::size_t*)arg[0],
      *(const ::std::basic_string<char>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::basic_string<char> >(*(::std::size_t*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(const ::std::allocator<std::basic_string<char> >*)arg[2]);
  else ::new(mem) ::std::vector<std::basic_string<char> >(*(::std::size_t*)arg[0],
      *(const ::std::basic_string<char>*)arg[1],
      *(const ::std::allocator<std::basic_string<char> >*)arg[2]);
  }
}

static void constructor_4993( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::basic_string<char> >(*(const ::std::vector<std::basic_string<char> >*)arg[0]);
  else ::new(mem) ::std::vector<std::basic_string<char> >(*(const ::std::vector<std::basic_string<char> >*)arg[0]);
}

static void destructor_4994(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::basic_string<char> >*)o)->::std::vector<std::basic_string<char> >::~vector)();
}
static  void operator_4995( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::basic_string<char> >*)o)->operator=)(*(const ::std::vector<std::basic_string<char> >*)arg[0]);
  else   (((::std::vector<std::basic_string<char> >*)o)->operator=)(*(const ::std::vector<std::basic_string<char> >*)arg[0]);
}

static  void method_4996( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::basic_string<char> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_4997( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((::std::vector<std::basic_string<char> >*)o)->begin)());
  else   (((::std::vector<std::basic_string<char> >*)o)->begin)();
}

static  void method_4998( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((const ::std::vector<std::basic_string<char> >*)o)->begin)());
  else   (((const ::std::vector<std::basic_string<char> >*)o)->begin)();
}

static  void method_4999( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((::std::vector<std::basic_string<char> >*)o)->end)());
  else   (((::std::vector<std::basic_string<char> >*)o)->end)();
}

static  void method_5000( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((const ::std::vector<std::basic_string<char> >*)o)->end)());
  else   (((const ::std::vector<std::basic_string<char> >*)o)->end)();
}

static  void method_5005( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::basic_string<char> >*)o)->size)());
  else   (((const ::std::vector<std::basic_string<char> >*)o)->size)();
}

static  void method_5006( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::basic_string<char> >*)o)->max_size)());
  else   (((const ::std::vector<std::basic_string<char> >*)o)->max_size)();
}

static  void method_5007( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::basic_string<char> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::basic_string<char> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::basic_string<char>*)arg[1]);
  }
}

static  void method_5008( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::basic_string<char> >*)o)->capacity)());
  else   (((const ::std::vector<std::basic_string<char> >*)o)->capacity)();
}

static  void method_5009( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::basic_string<char> >*)o)->empty)());
  else   (((const ::std::vector<std::basic_string<char> >*)o)->empty)();
}

static  void method_5010( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::basic_string<char> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_5011( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::basic_string<char> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::basic_string<char> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_5012( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::basic_string<char> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::basic_string<char> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_5014( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::basic_string<char> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::basic_string<char> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5015( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::basic_string<char> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::basic_string<char> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5016( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::basic_string<char> >*)o)->front)();
  else   (((::std::vector<std::basic_string<char> >*)o)->front)();
}

static  void method_5017( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::basic_string<char> >*)o)->front)();
  else   (((const ::std::vector<std::basic_string<char> >*)o)->front)();
}

static  void method_5018( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::basic_string<char> >*)o)->back)();
  else   (((::std::vector<std::basic_string<char> >*)o)->back)();
}

static  void method_5019( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::basic_string<char> >*)o)->back)();
  else   (((const ::std::vector<std::basic_string<char> >*)o)->back)();
}

static  void method_5020( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::basic_string<char> >*)o)->data)());
  else   (((::std::vector<std::basic_string<char> >*)o)->data)();
}

static  void method_5021( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::basic_string<char> >*)o)->data)());
  else   (((const ::std::vector<std::basic_string<char> >*)o)->data)();
}

static  void method_5022( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::basic_string<char> >*)o)->push_back)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_5023( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::basic_string<char> >*)o)->pop_back)();
}

static  void method_5024( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((::std::vector<std::basic_string<char> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((::std::vector<std::basic_string<char> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_5025( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::basic_string<char> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::basic_string<char>*)arg[2]);
}

static  void method_5026( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((::std::vector<std::basic_string<char> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[0]));
  else   (((::std::vector<std::basic_string<char> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[0]);
}

static  void method_5027( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((::std::vector<std::basic_string<char> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[1]));
  else   (((::std::vector<std::basic_string<char> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[1]);
}

static  void method_5028( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::basic_string<char> >*)o)->swap)(*(::std::vector<std::basic_string<char> >*)arg[0]);
}

static  void method_5029( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::basic_string<char> >*)o)->clear)();
}

static void method_newdel_1070( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::basic_string<char> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::basic_string<char> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::basic_string<char> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::basic_string<char> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::basic_string<char> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x140( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::basic_string<char>,std::allocator<std::basic_string<char> > >")), ::Reflex::BaseOffset< ::std::vector<std::basic_string<char> >,::std::_Vector_base<std::basic_string<char>,std::allocator<std::basic_string<char> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x141( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::basic_string<char> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::basic_string<char> > >::Generate();
}

//------Dictionary for class vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > -------------------------------
void __std__vector_std__basic_string_char_s__db_datamem(Reflex::Class*);
void __std__vector_std__basic_string_char_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__basic_string_char_s__datamem_bld(&__std__vector_std__basic_string_char_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__basic_string_char_s__funcmem_bld(&__std__vector_std__basic_string_char_s__db_funcmem);
void __std__vector_std__basic_string_char_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::basic_string<char> >"), typeid(::std::vector<std::basic_string<char> >), sizeof(::std::vector<std::basic_string<char> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1988, ::Reflex::BaseOffset< ::std::vector<std::basic_string<char> >, ::std::_Vector_base<std::basic_string<char>,std::allocator<std::basic_string<char> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1104, Reflex::Literal("std::vector<std::basic_string<char> >::_Alloc_value_type"))
  .AddTypedef(type_1988, Reflex::Literal("std::vector<std::basic_string<char> >::_Base"))
  .AddTypedef(type_1348, Reflex::Literal("std::vector<std::basic_string<char> >::_Tp_alloc_type"))
  .AddTypedef(type_1104, Reflex::Literal("std::vector<std::basic_string<char> >::value_type"))
  .AddTypedef(type_3514, Reflex::Literal("std::vector<std::basic_string<char> >::pointer"))
  .AddTypedef(type_4978, Reflex::Literal("std::vector<std::basic_string<char> >::const_pointer"))
  .AddTypedef(type_3516, Reflex::Literal("std::vector<std::basic_string<char> >::reference"))
  .AddTypedef(type_4981, Reflex::Literal("std::vector<std::basic_string<char> >::const_reference"))
  .AddTypedef(type_2337, Reflex::Literal("std::vector<std::basic_string<char> >::iterator"))
  .AddTypedef(type_2393, Reflex::Literal("std::vector<std::basic_string<char> >::const_iterator"))
  .AddTypedef(type_1796, Reflex::Literal("std::vector<std::basic_string<char> >::const_reverse_iterator"))
  .AddTypedef(type_1797, Reflex::Literal("std::vector<std::basic_string<char> >::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<std::basic_string<char> >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<std::basic_string<char> >::difference_type"))
  .AddTypedef(type_1348, Reflex::Literal("std::vector<std::basic_string<char> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_4990, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20343), Reflex::Literal("vector"), constructor_4991, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_4981, type_20343), Reflex::Literal("vector"), constructor_4992, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20219), Reflex::Literal("vector"), constructor_4993, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_4994, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1070, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x140, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x141, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__basic_string_char_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > -------------------
void __std__vector_std__basic_string_char_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > -------------------
void __std__vector_std__basic_string_char_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20344, type_20219), Reflex::Literal("operator="), operator_4995, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_4981), Reflex::Literal("assign"), method_4996, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2337), Reflex::Literal("begin"), method_4997, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("begin"), method_4998, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2337), Reflex::Literal("end"), method_4999, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2393), Reflex::Literal("end"), method_5000, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_5005, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_5006, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_1104), Reflex::Literal("resize"), method_5007, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_5008, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_5009, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_5010, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_1654), Reflex::Literal("operator[]"), operator_5011, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4981, type_1654), Reflex::Literal("operator[]"), operator_5012, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_1654), Reflex::Literal("at"), method_5014, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4981, type_1654), Reflex::Literal("at"), method_5015, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516), Reflex::Literal("front"), method_5016, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4981), Reflex::Literal("front"), method_5017, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516), Reflex::Literal("back"), method_5018, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4981), Reflex::Literal("back"), method_5019, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3514), Reflex::Literal("data"), method_5020, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4978), Reflex::Literal("data"), method_5021, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_4981), Reflex::Literal("push_back"), method_5022, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_5023, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2337, type_2337, type_4981), Reflex::Literal("insert"), method_5024, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2337, type_1654, type_4981), Reflex::Literal("insert"), method_5025, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2337, type_2337), Reflex::Literal("erase"), method_5026, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2337, type_2337, type_2337), Reflex::Literal("erase"), method_5027, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_20344), Reflex::Literal("swap"), method_5028, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_5029, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::pair<long long unsigned int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<long long unsigned int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------------------
static void constructor_5055( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<unsigned long long,std::basic_string<char> > >();
  else ::new(mem) ::std::vector<std::pair<unsigned long long,std::basic_string<char> > >();
}

static void constructor_5056( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<unsigned long long,std::basic_string<char> > >(*(const ::std::allocator<std::pair<unsigned long long,std::basic_string<char> > >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<unsigned long long,std::basic_string<char> > >(*(const ::std::allocator<std::pair<unsigned long long,std::basic_string<char> > >*)arg[0]);
}

static void constructor_5057( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<unsigned long long,std::basic_string<char> > >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<unsigned long long,std::basic_string<char> > >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<unsigned long long,std::basic_string<char> > >(*(::std::size_t*)arg[0],
      *(const ::std::pair<unsigned long long,std::basic_string<char> >*)arg[1]);
  else ::new(mem) ::std::vector<std::pair<unsigned long long,std::basic_string<char> > >(*(::std::size_t*)arg[0],
      *(const ::std::pair<unsigned long long,std::basic_string<char> >*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<unsigned long long,std::basic_string<char> > >(*(::std::size_t*)arg[0],
      *(const ::std::pair<unsigned long long,std::basic_string<char> >*)arg[1],
      *(const ::std::allocator<std::pair<unsigned long long,std::basic_string<char> > >*)arg[2]);
  else ::new(mem) ::std::vector<std::pair<unsigned long long,std::basic_string<char> > >(*(::std::size_t*)arg[0],
      *(const ::std::pair<unsigned long long,std::basic_string<char> >*)arg[1],
      *(const ::std::allocator<std::pair<unsigned long long,std::basic_string<char> > >*)arg[2]);
  }
}

static void constructor_5058( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<unsigned long long,std::basic_string<char> > >(*(const ::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<unsigned long long,std::basic_string<char> > >(*(const ::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)arg[0]);
}

static void destructor_5059(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->::std::vector<std::pair<unsigned long long,std::basic_string<char> > >::~vector)();
}
static  void operator_5060( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->operator=)(*(const ::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)arg[0]);
  else   (((::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->operator=)(*(const ::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)arg[0]);
}

static  void method_5061( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::pair<unsigned long long,std::basic_string<char> >*)arg[1]);
}

static  void method_5062( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<unsigned long long,std::basic_string<char> >*,std::vector<std::pair<unsigned long long,std::basic_string<char> > > >)((((::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->begin)());
  else   (((::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->begin)();
}

static  void method_5063( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<unsigned long long,std::basic_string<char> >*,std::vector<std::pair<unsigned long long,std::basic_string<char> > > >)((((const ::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->begin)());
  else   (((const ::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->begin)();
}

static  void method_5064( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<unsigned long long,std::basic_string<char> >*,std::vector<std::pair<unsigned long long,std::basic_string<char> > > >)((((::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->end)());
  else   (((::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->end)();
}

static  void method_5065( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<unsigned long long,std::basic_string<char> >*,std::vector<std::pair<unsigned long long,std::basic_string<char> > > >)((((const ::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->end)());
  else   (((const ::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->end)();
}

static  void method_5070( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->size)());
  else   (((const ::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->size)();
}

static  void method_5071( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->max_size)());
  else   (((const ::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->max_size)();
}

static  void method_5072( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::pair<unsigned long long,std::basic_string<char> >*)arg[1]);
  }
}

static  void method_5073( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->capacity)());
  else   (((const ::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->capacity)();
}

static  void method_5074( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->empty)());
  else   (((const ::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->empty)();
}

static  void method_5075( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_5076( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_5077( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_5079( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5080( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5081( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->front)();
  else   (((::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->front)();
}

static  void method_5082( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->front)();
  else   (((const ::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->front)();
}

static  void method_5083( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->back)();
  else   (((::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->back)();
}

static  void method_5084( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->back)();
  else   (((const ::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->back)();
}

static  void method_5085( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->data)());
  else   (((::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->data)();
}

static  void method_5086( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->data)());
  else   (((const ::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->data)();
}

static  void method_5087( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->push_back)(*(const ::std::pair<unsigned long long,std::basic_string<char> >*)arg[0]);
}

static  void method_5088( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->pop_back)();
}

static  void method_5089( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<unsigned long long,std::basic_string<char> >*,std::vector<std::pair<unsigned long long,std::basic_string<char> > > >)((((::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<unsigned long long,std::basic_string<char> >*,std::vector<std::pair<unsigned long long,std::basic_string<char> > > >*)arg[0],
    *(const ::std::pair<unsigned long long,std::basic_string<char> >*)arg[1]));
  else   (((::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<unsigned long long,std::basic_string<char> >*,std::vector<std::pair<unsigned long long,std::basic_string<char> > > >*)arg[0],
    *(const ::std::pair<unsigned long long,std::basic_string<char> >*)arg[1]);
}

static  void method_5090( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<unsigned long long,std::basic_string<char> >*,std::vector<std::pair<unsigned long long,std::basic_string<char> > > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::pair<unsigned long long,std::basic_string<char> >*)arg[2]);
}

static  void method_5091( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<unsigned long long,std::basic_string<char> >*,std::vector<std::pair<unsigned long long,std::basic_string<char> > > >)((((::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<unsigned long long,std::basic_string<char> >*,std::vector<std::pair<unsigned long long,std::basic_string<char> > > >*)arg[0]));
  else   (((::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<unsigned long long,std::basic_string<char> >*,std::vector<std::pair<unsigned long long,std::basic_string<char> > > >*)arg[0]);
}

static  void method_5092( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<unsigned long long,std::basic_string<char> >*,std::vector<std::pair<unsigned long long,std::basic_string<char> > > >)((((::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<unsigned long long,std::basic_string<char> >*,std::vector<std::pair<unsigned long long,std::basic_string<char> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<unsigned long long,std::basic_string<char> >*,std::vector<std::pair<unsigned long long,std::basic_string<char> > > >*)arg[1]));
  else   (((::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<unsigned long long,std::basic_string<char> >*,std::vector<std::pair<unsigned long long,std::basic_string<char> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<unsigned long long,std::basic_string<char> >*,std::vector<std::pair<unsigned long long,std::basic_string<char> > > >*)arg[1]);
}

static  void method_5093( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->swap)(*(::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)arg[0]);
}

static  void method_5094( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<unsigned long long,std::basic_string<char> > >*)o)->clear)();
}

static void method_newdel_1071( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<unsigned long long,std::basic_string<char> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<unsigned long long,std::basic_string<char> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<unsigned long long,std::basic_string<char> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<unsigned long long,std::basic_string<char> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<unsigned long long,std::basic_string<char> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x143( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<unsigned long long,std::basic_string<char> >,std::allocator<std::pair<unsigned long long,std::basic_string<char> > > >")), ::Reflex::BaseOffset< ::std::vector<std::pair<unsigned long long,std::basic_string<char> > >,::std::_Vector_base<std::pair<unsigned long long,std::basic_string<char> >,std::allocator<std::pair<unsigned long long,std::basic_string<char> > > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x144( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::pair<unsigned long long,std::basic_string<char> > > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::pair<unsigned long long,std::basic_string<char> > > >::Generate();
}

//------Dictionary for class vector<std::pair<long long unsigned int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<long long unsigned int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------------------
void __std__vector_std__pair_unsignedslongslong_std__basic_string_char_s_s__db_datamem(Reflex::Class*);
void __std__vector_std__pair_unsignedslongslong_std__basic_string_char_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_unsignedslongslong_std__basic_string_char_s_s__datamem_bld(&__std__vector_std__pair_unsignedslongslong_std__basic_string_char_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_unsignedslongslong_std__basic_string_char_s_s__funcmem_bld(&__std__vector_std__pair_unsignedslongslong_std__basic_string_char_s_s__db_funcmem);
void __std__vector_std__pair_unsignedslongslong_std__basic_string_char_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::pair<unsigned long long,std::basic_string<char> > >"), typeid(::std::vector<std::pair<unsigned long long,std::basic_string<char> > >), sizeof(::std::vector<std::pair<unsigned long long,std::basic_string<char> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1959, ::Reflex::BaseOffset< ::std::vector<std::pair<unsigned long long,std::basic_string<char> > >, ::std::_Vector_base<std::pair<unsigned long long,std::basic_string<char> >,std::allocator<std::pair<unsigned long long,std::basic_string<char> > > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_813, Reflex::Literal("std::vector<std::pair<unsigned long long,std::basic_string<char> > >::_Alloc_value_type"))
  .AddTypedef(type_1959, Reflex::Literal("std::vector<std::pair<unsigned long long,std::basic_string<char> > >::_Base"))
  .AddTypedef(type_1349, Reflex::Literal("std::vector<std::pair<unsigned long long,std::basic_string<char> > >::_Tp_alloc_type"))
  .AddTypedef(type_813, Reflex::Literal("std::vector<std::pair<unsigned long long,std::basic_string<char> > >::value_type"))
  .AddTypedef(type_5040, Reflex::Literal("std::vector<std::pair<unsigned long long,std::basic_string<char> > >::pointer"))
  .AddTypedef(type_5042, Reflex::Literal("std::vector<std::pair<unsigned long long,std::basic_string<char> > >::const_pointer"))
  .AddTypedef(type_5044, Reflex::Literal("std::vector<std::pair<unsigned long long,std::basic_string<char> > >::reference"))
  .AddTypedef(type_5046, Reflex::Literal("std::vector<std::pair<unsigned long long,std::basic_string<char> > >::const_reference"))
  .AddTypedef(type_2338, Reflex::Literal("std::vector<std::pair<unsigned long long,std::basic_string<char> > >::iterator"))
  .AddTypedef(type_2339, Reflex::Literal("std::vector<std::pair<unsigned long long,std::basic_string<char> > >::const_iterator"))
  .AddTypedef(type_1732, Reflex::Literal("std::vector<std::pair<unsigned long long,std::basic_string<char> > >::const_reverse_iterator"))
  .AddTypedef(type_1733, Reflex::Literal("std::vector<std::pair<unsigned long long,std::basic_string<char> > >::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<std::pair<unsigned long long,std::basic_string<char> > >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<std::pair<unsigned long long,std::basic_string<char> > >::difference_type"))
  .AddTypedef(type_1349, Reflex::Literal("std::vector<std::pair<unsigned long long,std::basic_string<char> > >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_5055, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20346), Reflex::Literal("vector"), constructor_5056, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_5046, type_20346), Reflex::Literal("vector"), constructor_5057, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20347), Reflex::Literal("vector"), constructor_5058, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_5059, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1071, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x143, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x144, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__pair_unsignedslongslong_std__basic_string_char_s_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::pair<long long unsigned int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<long long unsigned int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------
void __std__vector_std__pair_unsignedslongslong_std__basic_string_char_s_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::pair<long long unsigned int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<long long unsigned int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------
void __std__vector_std__pair_unsignedslongslong_std__basic_string_char_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20348, type_20347), Reflex::Literal("operator="), operator_5060, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_5046), Reflex::Literal("assign"), method_5061, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2338), Reflex::Literal("begin"), method_5062, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2339), Reflex::Literal("begin"), method_5063, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2338), Reflex::Literal("end"), method_5064, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2339), Reflex::Literal("end"), method_5065, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_5070, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_5071, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_813), Reflex::Literal("resize"), method_5072, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_5073, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_5074, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_5075, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5044, type_1654), Reflex::Literal("operator[]"), operator_5076, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5046, type_1654), Reflex::Literal("operator[]"), operator_5077, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5044, type_1654), Reflex::Literal("at"), method_5079, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5046, type_1654), Reflex::Literal("at"), method_5080, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5044), Reflex::Literal("front"), method_5081, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5046), Reflex::Literal("front"), method_5082, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5044), Reflex::Literal("back"), method_5083, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5046), Reflex::Literal("back"), method_5084, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5040), Reflex::Literal("data"), method_5085, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5042), Reflex::Literal("data"), method_5086, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_5046), Reflex::Literal("push_back"), method_5087, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_5088, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2338, type_2338, type_5046), Reflex::Literal("insert"), method_5089, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2338, type_1654, type_5046), Reflex::Literal("insert"), method_5090, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2338, type_2338), Reflex::Literal("erase"), method_5091, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2338, type_2338, type_2338), Reflex::Literal("erase"), method_5092, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_20348), Reflex::Literal("swap"), method_5093, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_5094, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::pair<unsigned int, unsigned int>,std::allocator<std::pair<unsigned int, unsigned int> > > -------------------------------
static void constructor_5120( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<unsigned int,unsigned int> >();
  else ::new(mem) ::std::vector<std::pair<unsigned int,unsigned int> >();
}

static void constructor_5121( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<unsigned int,unsigned int> >(*(const ::std::allocator<std::pair<unsigned int,unsigned int> >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<unsigned int,unsigned int> >(*(const ::std::allocator<std::pair<unsigned int,unsigned int> >*)arg[0]);
}

static void constructor_5122( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<unsigned int,unsigned int> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<unsigned int,unsigned int> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<unsigned int,unsigned int> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<unsigned int,unsigned int>*)arg[1]);
  else ::new(mem) ::std::vector<std::pair<unsigned int,unsigned int> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<unsigned int,unsigned int>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<unsigned int,unsigned int> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<unsigned int,unsigned int>*)arg[1],
      *(const ::std::allocator<std::pair<unsigned int,unsigned int> >*)arg[2]);
  else ::new(mem) ::std::vector<std::pair<unsigned int,unsigned int> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<unsigned int,unsigned int>*)arg[1],
      *(const ::std::allocator<std::pair<unsigned int,unsigned int> >*)arg[2]);
  }
}

static void constructor_5123( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<unsigned int,unsigned int> >(*(const ::std::vector<std::pair<unsigned int,unsigned int> >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<unsigned int,unsigned int> >(*(const ::std::vector<std::pair<unsigned int,unsigned int> >*)arg[0]);
}

static void destructor_5124(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::pair<unsigned int,unsigned int> >*)o)->::std::vector<std::pair<unsigned int,unsigned int> >::~vector)();
}
static  void operator_5125( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<unsigned int,unsigned int> >*)o)->operator=)(*(const ::std::vector<std::pair<unsigned int,unsigned int> >*)arg[0]);
  else   (((::std::vector<std::pair<unsigned int,unsigned int> >*)o)->operator=)(*(const ::std::vector<std::pair<unsigned int,unsigned int> >*)arg[0]);
}

static  void method_5126( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<unsigned int,unsigned int> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::pair<unsigned int,unsigned int>*)arg[1]);
}

static  void method_5127( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<unsigned int,unsigned int>*,std::vector<std::pair<unsigned int,unsigned int> > >)((((::std::vector<std::pair<unsigned int,unsigned int> >*)o)->begin)());
  else   (((::std::vector<std::pair<unsigned int,unsigned int> >*)o)->begin)();
}

static  void method_5128( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<unsigned int,unsigned int>*,std::vector<std::pair<unsigned int,unsigned int> > >)((((const ::std::vector<std::pair<unsigned int,unsigned int> >*)o)->begin)());
  else   (((const ::std::vector<std::pair<unsigned int,unsigned int> >*)o)->begin)();
}

static  void method_5129( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<unsigned int,unsigned int>*,std::vector<std::pair<unsigned int,unsigned int> > >)((((::std::vector<std::pair<unsigned int,unsigned int> >*)o)->end)());
  else   (((::std::vector<std::pair<unsigned int,unsigned int> >*)o)->end)();
}

static  void method_5130( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<unsigned int,unsigned int>*,std::vector<std::pair<unsigned int,unsigned int> > >)((((const ::std::vector<std::pair<unsigned int,unsigned int> >*)o)->end)());
  else   (((const ::std::vector<std::pair<unsigned int,unsigned int> >*)o)->end)();
}

static  void method_5135( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<unsigned int,unsigned int> >*)o)->size)());
  else   (((const ::std::vector<std::pair<unsigned int,unsigned int> >*)o)->size)();
}

static  void method_5136( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<unsigned int,unsigned int> >*)o)->max_size)());
  else   (((const ::std::vector<std::pair<unsigned int,unsigned int> >*)o)->max_size)();
}

static  void method_5137( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::pair<unsigned int,unsigned int> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::pair<unsigned int,unsigned int> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::pair<unsigned int,unsigned int>*)arg[1]);
  }
}

static  void method_5138( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<unsigned int,unsigned int> >*)o)->capacity)());
  else   (((const ::std::vector<std::pair<unsigned int,unsigned int> >*)o)->capacity)();
}

static  void method_5139( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::pair<unsigned int,unsigned int> >*)o)->empty)());
  else   (((const ::std::vector<std::pair<unsigned int,unsigned int> >*)o)->empty)();
}

static  void method_5140( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<unsigned int,unsigned int> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_5141( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<unsigned int,unsigned int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<unsigned int,unsigned int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_5142( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<unsigned int,unsigned int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<unsigned int,unsigned int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_5144( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<unsigned int,unsigned int> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<unsigned int,unsigned int> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5145( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<unsigned int,unsigned int> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<unsigned int,unsigned int> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5146( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<unsigned int,unsigned int> >*)o)->front)();
  else   (((::std::vector<std::pair<unsigned int,unsigned int> >*)o)->front)();
}

static  void method_5147( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<unsigned int,unsigned int> >*)o)->front)();
  else   (((const ::std::vector<std::pair<unsigned int,unsigned int> >*)o)->front)();
}

static  void method_5148( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<unsigned int,unsigned int> >*)o)->back)();
  else   (((::std::vector<std::pair<unsigned int,unsigned int> >*)o)->back)();
}

static  void method_5149( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<unsigned int,unsigned int> >*)o)->back)();
  else   (((const ::std::vector<std::pair<unsigned int,unsigned int> >*)o)->back)();
}

static  void method_5150( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::pair<unsigned int,unsigned int> >*)o)->data)());
  else   (((::std::vector<std::pair<unsigned int,unsigned int> >*)o)->data)();
}

static  void method_5151( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::pair<unsigned int,unsigned int> >*)o)->data)());
  else   (((const ::std::vector<std::pair<unsigned int,unsigned int> >*)o)->data)();
}

static  void method_5152( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<unsigned int,unsigned int> >*)o)->push_back)(*(const ::std::pair<unsigned int,unsigned int>*)arg[0]);
}

static  void method_5153( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<unsigned int,unsigned int> >*)o)->pop_back)();
}

static  void method_5154( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<unsigned int,unsigned int>*,std::vector<std::pair<unsigned int,unsigned int> > >)((((::std::vector<std::pair<unsigned int,unsigned int> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,unsigned int>*,std::vector<std::pair<unsigned int,unsigned int> > >*)arg[0],
    *(const ::std::pair<unsigned int,unsigned int>*)arg[1]));
  else   (((::std::vector<std::pair<unsigned int,unsigned int> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,unsigned int>*,std::vector<std::pair<unsigned int,unsigned int> > >*)arg[0],
    *(const ::std::pair<unsigned int,unsigned int>*)arg[1]);
}

static  void method_5155( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<unsigned int,unsigned int> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,unsigned int>*,std::vector<std::pair<unsigned int,unsigned int> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::pair<unsigned int,unsigned int>*)arg[2]);
}

static  void method_5156( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<unsigned int,unsigned int>*,std::vector<std::pair<unsigned int,unsigned int> > >)((((::std::vector<std::pair<unsigned int,unsigned int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,unsigned int>*,std::vector<std::pair<unsigned int,unsigned int> > >*)arg[0]));
  else   (((::std::vector<std::pair<unsigned int,unsigned int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,unsigned int>*,std::vector<std::pair<unsigned int,unsigned int> > >*)arg[0]);
}

static  void method_5157( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<unsigned int,unsigned int>*,std::vector<std::pair<unsigned int,unsigned int> > >)((((::std::vector<std::pair<unsigned int,unsigned int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,unsigned int>*,std::vector<std::pair<unsigned int,unsigned int> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,unsigned int>*,std::vector<std::pair<unsigned int,unsigned int> > >*)arg[1]));
  else   (((::std::vector<std::pair<unsigned int,unsigned int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,unsigned int>*,std::vector<std::pair<unsigned int,unsigned int> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,unsigned int>*,std::vector<std::pair<unsigned int,unsigned int> > >*)arg[1]);
}

static  void method_5158( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<unsigned int,unsigned int> >*)o)->swap)(*(::std::vector<std::pair<unsigned int,unsigned int> >*)arg[0]);
}

static  void method_5159( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<unsigned int,unsigned int> >*)o)->clear)();
}

static void method_newdel_1072( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<unsigned int,unsigned int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<unsigned int,unsigned int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<unsigned int,unsigned int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<unsigned int,unsigned int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<unsigned int,unsigned int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x146( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > >")), ::Reflex::BaseOffset< ::std::vector<std::pair<unsigned int,unsigned int> >,::std::_Vector_base<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x147( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::pair<unsigned int,unsigned int> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::pair<unsigned int,unsigned int> > >::Generate();
}

//------Dictionary for class vector<std::pair<unsigned int, unsigned int>,std::allocator<std::pair<unsigned int, unsigned int> > > -------------------------------
void __std__vector_std__pair_unsignedsint_unsignedsint_s__db_datamem(Reflex::Class*);
void __std__vector_std__pair_unsignedsint_unsignedsint_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_unsignedsint_unsignedsint_s__datamem_bld(&__std__vector_std__pair_unsignedsint_unsignedsint_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_unsignedsint_unsignedsint_s__funcmem_bld(&__std__vector_std__pair_unsignedsint_unsignedsint_s__db_funcmem);
void __std__vector_std__pair_unsignedsint_unsignedsint_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::pair<unsigned int,unsigned int> >"), typeid(::std::vector<std::pair<unsigned int,unsigned int> >), sizeof(::std::vector<std::pair<unsigned int,unsigned int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1960, ::Reflex::BaseOffset< ::std::vector<std::pair<unsigned int,unsigned int> >, ::std::_Vector_base<std::pair<unsigned int,unsigned int>,std::allocator<std::pair<unsigned int,unsigned int> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_814, Reflex::Literal("std::vector<std::pair<unsigned int,unsigned int> >::_Alloc_value_type"))
  .AddTypedef(type_1960, Reflex::Literal("std::vector<std::pair<unsigned int,unsigned int> >::_Base"))
  .AddTypedef(type_1351, Reflex::Literal("std::vector<std::pair<unsigned int,unsigned int> >::_Tp_alloc_type"))
  .AddTypedef(type_814, Reflex::Literal("std::vector<std::pair<unsigned int,unsigned int> >::value_type"))
  .AddTypedef(type_5105, Reflex::Literal("std::vector<std::pair<unsigned int,unsigned int> >::pointer"))
  .AddTypedef(type_5107, Reflex::Literal("std::vector<std::pair<unsigned int,unsigned int> >::const_pointer"))
  .AddTypedef(type_5109, Reflex::Literal("std::vector<std::pair<unsigned int,unsigned int> >::reference"))
  .AddTypedef(type_5111, Reflex::Literal("std::vector<std::pair<unsigned int,unsigned int> >::const_reference"))
  .AddTypedef(type_2340, Reflex::Literal("std::vector<std::pair<unsigned int,unsigned int> >::iterator"))
  .AddTypedef(type_2341, Reflex::Literal("std::vector<std::pair<unsigned int,unsigned int> >::const_iterator"))
  .AddTypedef(type_1734, Reflex::Literal("std::vector<std::pair<unsigned int,unsigned int> >::const_reverse_iterator"))
  .AddTypedef(type_1735, Reflex::Literal("std::vector<std::pair<unsigned int,unsigned int> >::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<std::pair<unsigned int,unsigned int> >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<std::pair<unsigned int,unsigned int> >::difference_type"))
  .AddTypedef(type_1351, Reflex::Literal("std::vector<std::pair<unsigned int,unsigned int> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_5120, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20350), Reflex::Literal("vector"), constructor_5121, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_5111, type_20350), Reflex::Literal("vector"), constructor_5122, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20351), Reflex::Literal("vector"), constructor_5123, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_5124, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1072, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x146, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x147, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__pair_unsignedsint_unsignedsint_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::pair<unsigned int, unsigned int>,std::allocator<std::pair<unsigned int, unsigned int> > > -------------------
void __std__vector_std__pair_unsignedsint_unsignedsint_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::pair<unsigned int, unsigned int>,std::allocator<std::pair<unsigned int, unsigned int> > > -------------------
void __std__vector_std__pair_unsignedsint_unsignedsint_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20352, type_20351), Reflex::Literal("operator="), operator_5125, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_5111), Reflex::Literal("assign"), method_5126, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2340), Reflex::Literal("begin"), method_5127, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2341), Reflex::Literal("begin"), method_5128, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2340), Reflex::Literal("end"), method_5129, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2341), Reflex::Literal("end"), method_5130, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_5135, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_5136, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_814), Reflex::Literal("resize"), method_5137, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_5138, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_5139, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_5140, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5109, type_1654), Reflex::Literal("operator[]"), operator_5141, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5111, type_1654), Reflex::Literal("operator[]"), operator_5142, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5109, type_1654), Reflex::Literal("at"), method_5144, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5111, type_1654), Reflex::Literal("at"), method_5145, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5109), Reflex::Literal("front"), method_5146, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5111), Reflex::Literal("front"), method_5147, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5109), Reflex::Literal("back"), method_5148, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5111), Reflex::Literal("back"), method_5149, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5105), Reflex::Literal("data"), method_5150, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5107), Reflex::Literal("data"), method_5151, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_5111), Reflex::Literal("push_back"), method_5152, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_5153, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2340, type_2340, type_5111), Reflex::Literal("insert"), method_5154, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2340, type_1654, type_5111), Reflex::Literal("insert"), method_5155, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2340, type_2340), Reflex::Literal("erase"), method_5156, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2340, type_2340, type_2340), Reflex::Literal("erase"), method_5157, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_20352), Reflex::Literal("swap"), method_5158, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_5159, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::pair<unsigned int, int>,std::allocator<std::pair<unsigned int, int> > > -------------------------------
static void constructor_5185( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<unsigned int,int> >();
  else ::new(mem) ::std::vector<std::pair<unsigned int,int> >();
}

static void constructor_5186( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<unsigned int,int> >(*(const ::std::allocator<std::pair<unsigned int,int> >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<unsigned int,int> >(*(const ::std::allocator<std::pair<unsigned int,int> >*)arg[0]);
}

static void constructor_5187( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<unsigned int,int> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<unsigned int,int> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<unsigned int,int> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<unsigned int,int>*)arg[1]);
  else ::new(mem) ::std::vector<std::pair<unsigned int,int> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<unsigned int,int>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<unsigned int,int> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<unsigned int,int>*)arg[1],
      *(const ::std::allocator<std::pair<unsigned int,int> >*)arg[2]);
  else ::new(mem) ::std::vector<std::pair<unsigned int,int> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<unsigned int,int>*)arg[1],
      *(const ::std::allocator<std::pair<unsigned int,int> >*)arg[2]);
  }
}

static void constructor_5188( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<unsigned int,int> >(*(const ::std::vector<std::pair<unsigned int,int> >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<unsigned int,int> >(*(const ::std::vector<std::pair<unsigned int,int> >*)arg[0]);
}

static void destructor_5189(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::pair<unsigned int,int> >*)o)->::std::vector<std::pair<unsigned int,int> >::~vector)();
}
static  void operator_5190( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<unsigned int,int> >*)o)->operator=)(*(const ::std::vector<std::pair<unsigned int,int> >*)arg[0]);
  else   (((::std::vector<std::pair<unsigned int,int> >*)o)->operator=)(*(const ::std::vector<std::pair<unsigned int,int> >*)arg[0]);
}

static  void method_5191( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<unsigned int,int> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::pair<unsigned int,int>*)arg[1]);
}

static  void method_5192( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<unsigned int,int>*,std::vector<std::pair<unsigned int,int> > >)((((::std::vector<std::pair<unsigned int,int> >*)o)->begin)());
  else   (((::std::vector<std::pair<unsigned int,int> >*)o)->begin)();
}

static  void method_5193( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<unsigned int,int>*,std::vector<std::pair<unsigned int,int> > >)((((const ::std::vector<std::pair<unsigned int,int> >*)o)->begin)());
  else   (((const ::std::vector<std::pair<unsigned int,int> >*)o)->begin)();
}

static  void method_5194( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<unsigned int,int>*,std::vector<std::pair<unsigned int,int> > >)((((::std::vector<std::pair<unsigned int,int> >*)o)->end)());
  else   (((::std::vector<std::pair<unsigned int,int> >*)o)->end)();
}

static  void method_5195( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<unsigned int,int>*,std::vector<std::pair<unsigned int,int> > >)((((const ::std::vector<std::pair<unsigned int,int> >*)o)->end)());
  else   (((const ::std::vector<std::pair<unsigned int,int> >*)o)->end)();
}

static  void method_5200( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<unsigned int,int> >*)o)->size)());
  else   (((const ::std::vector<std::pair<unsigned int,int> >*)o)->size)();
}

static  void method_5201( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<unsigned int,int> >*)o)->max_size)());
  else   (((const ::std::vector<std::pair<unsigned int,int> >*)o)->max_size)();
}

static  void method_5202( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::pair<unsigned int,int> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::pair<unsigned int,int> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::pair<unsigned int,int>*)arg[1]);
  }
}

static  void method_5203( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<unsigned int,int> >*)o)->capacity)());
  else   (((const ::std::vector<std::pair<unsigned int,int> >*)o)->capacity)();
}

static  void method_5204( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::pair<unsigned int,int> >*)o)->empty)());
  else   (((const ::std::vector<std::pair<unsigned int,int> >*)o)->empty)();
}

static  void method_5205( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<unsigned int,int> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_5206( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<unsigned int,int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<unsigned int,int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_5207( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<unsigned int,int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<unsigned int,int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_5209( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<unsigned int,int> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<unsigned int,int> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5210( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<unsigned int,int> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<unsigned int,int> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5211( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<unsigned int,int> >*)o)->front)();
  else   (((::std::vector<std::pair<unsigned int,int> >*)o)->front)();
}

static  void method_5212( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<unsigned int,int> >*)o)->front)();
  else   (((const ::std::vector<std::pair<unsigned int,int> >*)o)->front)();
}

static  void method_5213( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<unsigned int,int> >*)o)->back)();
  else   (((::std::vector<std::pair<unsigned int,int> >*)o)->back)();
}

static  void method_5214( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<unsigned int,int> >*)o)->back)();
  else   (((const ::std::vector<std::pair<unsigned int,int> >*)o)->back)();
}

static  void method_5215( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::pair<unsigned int,int> >*)o)->data)());
  else   (((::std::vector<std::pair<unsigned int,int> >*)o)->data)();
}

static  void method_5216( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::pair<unsigned int,int> >*)o)->data)());
  else   (((const ::std::vector<std::pair<unsigned int,int> >*)o)->data)();
}

static  void method_5217( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<unsigned int,int> >*)o)->push_back)(*(const ::std::pair<unsigned int,int>*)arg[0]);
}

static  void method_5218( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<unsigned int,int> >*)o)->pop_back)();
}

static  void method_5219( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<unsigned int,int>*,std::vector<std::pair<unsigned int,int> > >)((((::std::vector<std::pair<unsigned int,int> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,int>*,std::vector<std::pair<unsigned int,int> > >*)arg[0],
    *(const ::std::pair<unsigned int,int>*)arg[1]));
  else   (((::std::vector<std::pair<unsigned int,int> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,int>*,std::vector<std::pair<unsigned int,int> > >*)arg[0],
    *(const ::std::pair<unsigned int,int>*)arg[1]);
}

static  void method_5220( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<unsigned int,int> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,int>*,std::vector<std::pair<unsigned int,int> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::pair<unsigned int,int>*)arg[2]);
}

static  void method_5221( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<unsigned int,int>*,std::vector<std::pair<unsigned int,int> > >)((((::std::vector<std::pair<unsigned int,int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,int>*,std::vector<std::pair<unsigned int,int> > >*)arg[0]));
  else   (((::std::vector<std::pair<unsigned int,int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,int>*,std::vector<std::pair<unsigned int,int> > >*)arg[0]);
}

static  void method_5222( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<unsigned int,int>*,std::vector<std::pair<unsigned int,int> > >)((((::std::vector<std::pair<unsigned int,int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,int>*,std::vector<std::pair<unsigned int,int> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,int>*,std::vector<std::pair<unsigned int,int> > >*)arg[1]));
  else   (((::std::vector<std::pair<unsigned int,int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,int>*,std::vector<std::pair<unsigned int,int> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,int>*,std::vector<std::pair<unsigned int,int> > >*)arg[1]);
}

static  void method_5223( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<unsigned int,int> >*)o)->swap)(*(::std::vector<std::pair<unsigned int,int> >*)arg[0]);
}

static  void method_5224( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<unsigned int,int> >*)o)->clear)();
}

static void method_newdel_1073( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<unsigned int,int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<unsigned int,int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<unsigned int,int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<unsigned int,int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<unsigned int,int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x149( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<unsigned int,int>,std::allocator<std::pair<unsigned int,int> > >")), ::Reflex::BaseOffset< ::std::vector<std::pair<unsigned int,int> >,::std::_Vector_base<std::pair<unsigned int,int>,std::allocator<std::pair<unsigned int,int> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x150( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::pair<unsigned int,int> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::pair<unsigned int,int> > >::Generate();
}

//------Dictionary for class vector<std::pair<unsigned int, int>,std::allocator<std::pair<unsigned int, int> > > -------------------------------
void __std__vector_std__pair_unsignedsint_int_s__db_datamem(Reflex::Class*);
void __std__vector_std__pair_unsignedsint_int_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_unsignedsint_int_s__datamem_bld(&__std__vector_std__pair_unsignedsint_int_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_unsignedsint_int_s__funcmem_bld(&__std__vector_std__pair_unsignedsint_int_s__db_funcmem);
void __std__vector_std__pair_unsignedsint_int_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::pair<unsigned int,int> >"), typeid(::std::vector<std::pair<unsigned int,int> >), sizeof(::std::vector<std::pair<unsigned int,int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1961, ::Reflex::BaseOffset< ::std::vector<std::pair<unsigned int,int> >, ::std::_Vector_base<std::pair<unsigned int,int>,std::allocator<std::pair<unsigned int,int> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_815, Reflex::Literal("std::vector<std::pair<unsigned int,int> >::_Alloc_value_type"))
  .AddTypedef(type_1961, Reflex::Literal("std::vector<std::pair<unsigned int,int> >::_Base"))
  .AddTypedef(type_1352, Reflex::Literal("std::vector<std::pair<unsigned int,int> >::_Tp_alloc_type"))
  .AddTypedef(type_815, Reflex::Literal("std::vector<std::pair<unsigned int,int> >::value_type"))
  .AddTypedef(type_5170, Reflex::Literal("std::vector<std::pair<unsigned int,int> >::pointer"))
  .AddTypedef(type_5172, Reflex::Literal("std::vector<std::pair<unsigned int,int> >::const_pointer"))
  .AddTypedef(type_5174, Reflex::Literal("std::vector<std::pair<unsigned int,int> >::reference"))
  .AddTypedef(type_5176, Reflex::Literal("std::vector<std::pair<unsigned int,int> >::const_reference"))
  .AddTypedef(type_2342, Reflex::Literal("std::vector<std::pair<unsigned int,int> >::iterator"))
  .AddTypedef(type_2343, Reflex::Literal("std::vector<std::pair<unsigned int,int> >::const_iterator"))
  .AddTypedef(type_1736, Reflex::Literal("std::vector<std::pair<unsigned int,int> >::const_reverse_iterator"))
  .AddTypedef(type_1737, Reflex::Literal("std::vector<std::pair<unsigned int,int> >::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<std::pair<unsigned int,int> >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<std::pair<unsigned int,int> >::difference_type"))
  .AddTypedef(type_1352, Reflex::Literal("std::vector<std::pair<unsigned int,int> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_5185, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20354), Reflex::Literal("vector"), constructor_5186, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_5176, type_20354), Reflex::Literal("vector"), constructor_5187, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20355), Reflex::Literal("vector"), constructor_5188, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_5189, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1073, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x149, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x150, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__pair_unsignedsint_int_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::pair<unsigned int, int>,std::allocator<std::pair<unsigned int, int> > > -------------------
void __std__vector_std__pair_unsignedsint_int_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::pair<unsigned int, int>,std::allocator<std::pair<unsigned int, int> > > -------------------
void __std__vector_std__pair_unsignedsint_int_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20356, type_20355), Reflex::Literal("operator="), operator_5190, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_5176), Reflex::Literal("assign"), method_5191, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2342), Reflex::Literal("begin"), method_5192, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2343), Reflex::Literal("begin"), method_5193, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2342), Reflex::Literal("end"), method_5194, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2343), Reflex::Literal("end"), method_5195, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_5200, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_5201, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_815), Reflex::Literal("resize"), method_5202, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_5203, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_5204, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_5205, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5174, type_1654), Reflex::Literal("operator[]"), operator_5206, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5176, type_1654), Reflex::Literal("operator[]"), operator_5207, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5174, type_1654), Reflex::Literal("at"), method_5209, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5176, type_1654), Reflex::Literal("at"), method_5210, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5174), Reflex::Literal("front"), method_5211, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5176), Reflex::Literal("front"), method_5212, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5174), Reflex::Literal("back"), method_5213, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5176), Reflex::Literal("back"), method_5214, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5170), Reflex::Literal("data"), method_5215, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5172), Reflex::Literal("data"), method_5216, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_5176), Reflex::Literal("push_back"), method_5217, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_5218, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2342, type_2342, type_5176), Reflex::Literal("insert"), method_5219, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2342, type_1654, type_5176), Reflex::Literal("insert"), method_5220, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2342, type_2342), Reflex::Literal("erase"), method_5221, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2342, type_2342, type_2342), Reflex::Literal("erase"), method_5222, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_20356), Reflex::Literal("swap"), method_5223, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_5224, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::pair<unsigned int, float>,std::allocator<std::pair<unsigned int, float> > > -------------------------------
static void constructor_5250( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<unsigned int,float> >();
  else ::new(mem) ::std::vector<std::pair<unsigned int,float> >();
}

static void constructor_5251( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<unsigned int,float> >(*(const ::std::allocator<std::pair<unsigned int,float> >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<unsigned int,float> >(*(const ::std::allocator<std::pair<unsigned int,float> >*)arg[0]);
}

static void constructor_5252( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<unsigned int,float> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<unsigned int,float> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<unsigned int,float> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<unsigned int,float>*)arg[1]);
  else ::new(mem) ::std::vector<std::pair<unsigned int,float> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<unsigned int,float>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<unsigned int,float> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<unsigned int,float>*)arg[1],
      *(const ::std::allocator<std::pair<unsigned int,float> >*)arg[2]);
  else ::new(mem) ::std::vector<std::pair<unsigned int,float> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<unsigned int,float>*)arg[1],
      *(const ::std::allocator<std::pair<unsigned int,float> >*)arg[2]);
  }
}

static void constructor_5253( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<unsigned int,float> >(*(const ::std::vector<std::pair<unsigned int,float> >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<unsigned int,float> >(*(const ::std::vector<std::pair<unsigned int,float> >*)arg[0]);
}

static void destructor_5254(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::pair<unsigned int,float> >*)o)->::std::vector<std::pair<unsigned int,float> >::~vector)();
}
static  void operator_5255( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<unsigned int,float> >*)o)->operator=)(*(const ::std::vector<std::pair<unsigned int,float> >*)arg[0]);
  else   (((::std::vector<std::pair<unsigned int,float> >*)o)->operator=)(*(const ::std::vector<std::pair<unsigned int,float> >*)arg[0]);
}

static  void method_5256( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<unsigned int,float> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::pair<unsigned int,float>*)arg[1]);
}

static  void method_5257( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<unsigned int,float>*,std::vector<std::pair<unsigned int,float> > >)((((::std::vector<std::pair<unsigned int,float> >*)o)->begin)());
  else   (((::std::vector<std::pair<unsigned int,float> >*)o)->begin)();
}

static  void method_5258( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<unsigned int,float>*,std::vector<std::pair<unsigned int,float> > >)((((const ::std::vector<std::pair<unsigned int,float> >*)o)->begin)());
  else   (((const ::std::vector<std::pair<unsigned int,float> >*)o)->begin)();
}

static  void method_5259( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<unsigned int,float>*,std::vector<std::pair<unsigned int,float> > >)((((::std::vector<std::pair<unsigned int,float> >*)o)->end)());
  else   (((::std::vector<std::pair<unsigned int,float> >*)o)->end)();
}

static  void method_5260( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<unsigned int,float>*,std::vector<std::pair<unsigned int,float> > >)((((const ::std::vector<std::pair<unsigned int,float> >*)o)->end)());
  else   (((const ::std::vector<std::pair<unsigned int,float> >*)o)->end)();
}

static  void method_5265( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<unsigned int,float> >*)o)->size)());
  else   (((const ::std::vector<std::pair<unsigned int,float> >*)o)->size)();
}

static  void method_5266( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<unsigned int,float> >*)o)->max_size)());
  else   (((const ::std::vector<std::pair<unsigned int,float> >*)o)->max_size)();
}

static  void method_5267( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::pair<unsigned int,float> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::pair<unsigned int,float> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::pair<unsigned int,float>*)arg[1]);
  }
}

static  void method_5268( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<unsigned int,float> >*)o)->capacity)());
  else   (((const ::std::vector<std::pair<unsigned int,float> >*)o)->capacity)();
}

static  void method_5269( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::pair<unsigned int,float> >*)o)->empty)());
  else   (((const ::std::vector<std::pair<unsigned int,float> >*)o)->empty)();
}

static  void method_5270( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<unsigned int,float> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_5271( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<unsigned int,float> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<unsigned int,float> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_5272( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<unsigned int,float> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<unsigned int,float> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_5274( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<unsigned int,float> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<unsigned int,float> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5275( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<unsigned int,float> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<unsigned int,float> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5276( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<unsigned int,float> >*)o)->front)();
  else   (((::std::vector<std::pair<unsigned int,float> >*)o)->front)();
}

static  void method_5277( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<unsigned int,float> >*)o)->front)();
  else   (((const ::std::vector<std::pair<unsigned int,float> >*)o)->front)();
}

static  void method_5278( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<unsigned int,float> >*)o)->back)();
  else   (((::std::vector<std::pair<unsigned int,float> >*)o)->back)();
}

static  void method_5279( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<unsigned int,float> >*)o)->back)();
  else   (((const ::std::vector<std::pair<unsigned int,float> >*)o)->back)();
}

static  void method_5280( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::pair<unsigned int,float> >*)o)->data)());
  else   (((::std::vector<std::pair<unsigned int,float> >*)o)->data)();
}

static  void method_5281( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::pair<unsigned int,float> >*)o)->data)());
  else   (((const ::std::vector<std::pair<unsigned int,float> >*)o)->data)();
}

static  void method_5282( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<unsigned int,float> >*)o)->push_back)(*(const ::std::pair<unsigned int,float>*)arg[0]);
}

static  void method_5283( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<unsigned int,float> >*)o)->pop_back)();
}

static  void method_5284( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<unsigned int,float>*,std::vector<std::pair<unsigned int,float> > >)((((::std::vector<std::pair<unsigned int,float> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,float>*,std::vector<std::pair<unsigned int,float> > >*)arg[0],
    *(const ::std::pair<unsigned int,float>*)arg[1]));
  else   (((::std::vector<std::pair<unsigned int,float> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,float>*,std::vector<std::pair<unsigned int,float> > >*)arg[0],
    *(const ::std::pair<unsigned int,float>*)arg[1]);
}

static  void method_5285( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<unsigned int,float> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,float>*,std::vector<std::pair<unsigned int,float> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::pair<unsigned int,float>*)arg[2]);
}

static  void method_5286( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<unsigned int,float>*,std::vector<std::pair<unsigned int,float> > >)((((::std::vector<std::pair<unsigned int,float> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,float>*,std::vector<std::pair<unsigned int,float> > >*)arg[0]));
  else   (((::std::vector<std::pair<unsigned int,float> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,float>*,std::vector<std::pair<unsigned int,float> > >*)arg[0]);
}

static  void method_5287( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<unsigned int,float>*,std::vector<std::pair<unsigned int,float> > >)((((::std::vector<std::pair<unsigned int,float> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,float>*,std::vector<std::pair<unsigned int,float> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,float>*,std::vector<std::pair<unsigned int,float> > >*)arg[1]));
  else   (((::std::vector<std::pair<unsigned int,float> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,float>*,std::vector<std::pair<unsigned int,float> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,float>*,std::vector<std::pair<unsigned int,float> > >*)arg[1]);
}

static  void method_5288( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<unsigned int,float> >*)o)->swap)(*(::std::vector<std::pair<unsigned int,float> >*)arg[0]);
}

static  void method_5289( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<unsigned int,float> >*)o)->clear)();
}

static void method_newdel_1074( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<unsigned int,float> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<unsigned int,float> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<unsigned int,float> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<unsigned int,float> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<unsigned int,float> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x152( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<unsigned int,float>,std::allocator<std::pair<unsigned int,float> > >")), ::Reflex::BaseOffset< ::std::vector<std::pair<unsigned int,float> >,::std::_Vector_base<std::pair<unsigned int,float>,std::allocator<std::pair<unsigned int,float> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x153( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::pair<unsigned int,float> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::pair<unsigned int,float> > >::Generate();
}

//------Dictionary for class vector<std::pair<unsigned int, float>,std::allocator<std::pair<unsigned int, float> > > -------------------------------
void __std__vector_std__pair_unsignedsint_float_s__db_datamem(Reflex::Class*);
void __std__vector_std__pair_unsignedsint_float_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_unsignedsint_float_s__datamem_bld(&__std__vector_std__pair_unsignedsint_float_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_unsignedsint_float_s__funcmem_bld(&__std__vector_std__pair_unsignedsint_float_s__db_funcmem);
void __std__vector_std__pair_unsignedsint_float_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::pair<unsigned int,float> >"), typeid(::std::vector<std::pair<unsigned int,float> >), sizeof(::std::vector<std::pair<unsigned int,float> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1962, ::Reflex::BaseOffset< ::std::vector<std::pair<unsigned int,float> >, ::std::_Vector_base<std::pair<unsigned int,float>,std::allocator<std::pair<unsigned int,float> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_816, Reflex::Literal("std::vector<std::pair<unsigned int,float> >::_Alloc_value_type"))
  .AddTypedef(type_1962, Reflex::Literal("std::vector<std::pair<unsigned int,float> >::_Base"))
  .AddTypedef(type_1353, Reflex::Literal("std::vector<std::pair<unsigned int,float> >::_Tp_alloc_type"))
  .AddTypedef(type_816, Reflex::Literal("std::vector<std::pair<unsigned int,float> >::value_type"))
  .AddTypedef(type_5235, Reflex::Literal("std::vector<std::pair<unsigned int,float> >::pointer"))
  .AddTypedef(type_5237, Reflex::Literal("std::vector<std::pair<unsigned int,float> >::const_pointer"))
  .AddTypedef(type_5239, Reflex::Literal("std::vector<std::pair<unsigned int,float> >::reference"))
  .AddTypedef(type_5241, Reflex::Literal("std::vector<std::pair<unsigned int,float> >::const_reference"))
  .AddTypedef(type_2344, Reflex::Literal("std::vector<std::pair<unsigned int,float> >::iterator"))
  .AddTypedef(type_2345, Reflex::Literal("std::vector<std::pair<unsigned int,float> >::const_iterator"))
  .AddTypedef(type_1738, Reflex::Literal("std::vector<std::pair<unsigned int,float> >::const_reverse_iterator"))
  .AddTypedef(type_1739, Reflex::Literal("std::vector<std::pair<unsigned int,float> >::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<std::pair<unsigned int,float> >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<std::pair<unsigned int,float> >::difference_type"))
  .AddTypedef(type_1353, Reflex::Literal("std::vector<std::pair<unsigned int,float> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_5250, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20358), Reflex::Literal("vector"), constructor_5251, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_5241, type_20358), Reflex::Literal("vector"), constructor_5252, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20359), Reflex::Literal("vector"), constructor_5253, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_5254, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1074, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x152, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x153, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__pair_unsignedsint_float_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::pair<unsigned int, float>,std::allocator<std::pair<unsigned int, float> > > -------------------
void __std__vector_std__pair_unsignedsint_float_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::pair<unsigned int, float>,std::allocator<std::pair<unsigned int, float> > > -------------------
void __std__vector_std__pair_unsignedsint_float_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20360, type_20359), Reflex::Literal("operator="), operator_5255, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_5241), Reflex::Literal("assign"), method_5256, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2344), Reflex::Literal("begin"), method_5257, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2345), Reflex::Literal("begin"), method_5258, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2344), Reflex::Literal("end"), method_5259, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2345), Reflex::Literal("end"), method_5260, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_5265, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_5266, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_816), Reflex::Literal("resize"), method_5267, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_5268, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_5269, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_5270, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5239, type_1654), Reflex::Literal("operator[]"), operator_5271, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5241, type_1654), Reflex::Literal("operator[]"), operator_5272, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5239, type_1654), Reflex::Literal("at"), method_5274, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5241, type_1654), Reflex::Literal("at"), method_5275, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5239), Reflex::Literal("front"), method_5276, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5241), Reflex::Literal("front"), method_5277, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5239), Reflex::Literal("back"), method_5278, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5241), Reflex::Literal("back"), method_5279, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5235), Reflex::Literal("data"), method_5280, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5237), Reflex::Literal("data"), method_5281, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_5241), Reflex::Literal("push_back"), method_5282, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_5283, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2344, type_2344, type_5241), Reflex::Literal("insert"), method_5284, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2344, type_1654, type_5241), Reflex::Literal("insert"), method_5285, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2344, type_2344), Reflex::Literal("erase"), method_5286, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2344, type_2344, type_2344), Reflex::Literal("erase"), method_5287, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_20360), Reflex::Literal("swap"), method_5288, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_5289, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::pair<unsigned int, double>,std::allocator<std::pair<unsigned int, double> > > -------------------------------
static void constructor_5315( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<unsigned int,double> >();
  else ::new(mem) ::std::vector<std::pair<unsigned int,double> >();
}

static void constructor_5316( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<unsigned int,double> >(*(const ::std::allocator<std::pair<unsigned int,double> >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<unsigned int,double> >(*(const ::std::allocator<std::pair<unsigned int,double> >*)arg[0]);
}

static void constructor_5317( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<unsigned int,double> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<unsigned int,double> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<unsigned int,double> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<unsigned int,double>*)arg[1]);
  else ::new(mem) ::std::vector<std::pair<unsigned int,double> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<unsigned int,double>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<unsigned int,double> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<unsigned int,double>*)arg[1],
      *(const ::std::allocator<std::pair<unsigned int,double> >*)arg[2]);
  else ::new(mem) ::std::vector<std::pair<unsigned int,double> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<unsigned int,double>*)arg[1],
      *(const ::std::allocator<std::pair<unsigned int,double> >*)arg[2]);
  }
}

static void constructor_5318( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<unsigned int,double> >(*(const ::std::vector<std::pair<unsigned int,double> >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<unsigned int,double> >(*(const ::std::vector<std::pair<unsigned int,double> >*)arg[0]);
}

static void destructor_5319(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::pair<unsigned int,double> >*)o)->::std::vector<std::pair<unsigned int,double> >::~vector)();
}
static  void operator_5320( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<unsigned int,double> >*)o)->operator=)(*(const ::std::vector<std::pair<unsigned int,double> >*)arg[0]);
  else   (((::std::vector<std::pair<unsigned int,double> >*)o)->operator=)(*(const ::std::vector<std::pair<unsigned int,double> >*)arg[0]);
}

static  void method_5321( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<unsigned int,double> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::pair<unsigned int,double>*)arg[1]);
}

static  void method_5322( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<unsigned int,double>*,std::vector<std::pair<unsigned int,double> > >)((((::std::vector<std::pair<unsigned int,double> >*)o)->begin)());
  else   (((::std::vector<std::pair<unsigned int,double> >*)o)->begin)();
}

static  void method_5323( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<unsigned int,double>*,std::vector<std::pair<unsigned int,double> > >)((((const ::std::vector<std::pair<unsigned int,double> >*)o)->begin)());
  else   (((const ::std::vector<std::pair<unsigned int,double> >*)o)->begin)();
}

static  void method_5324( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<unsigned int,double>*,std::vector<std::pair<unsigned int,double> > >)((((::std::vector<std::pair<unsigned int,double> >*)o)->end)());
  else   (((::std::vector<std::pair<unsigned int,double> >*)o)->end)();
}

static  void method_5325( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<unsigned int,double>*,std::vector<std::pair<unsigned int,double> > >)((((const ::std::vector<std::pair<unsigned int,double> >*)o)->end)());
  else   (((const ::std::vector<std::pair<unsigned int,double> >*)o)->end)();
}

static  void method_5330( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<unsigned int,double> >*)o)->size)());
  else   (((const ::std::vector<std::pair<unsigned int,double> >*)o)->size)();
}

static  void method_5331( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<unsigned int,double> >*)o)->max_size)());
  else   (((const ::std::vector<std::pair<unsigned int,double> >*)o)->max_size)();
}

static  void method_5332( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::pair<unsigned int,double> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::pair<unsigned int,double> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::pair<unsigned int,double>*)arg[1]);
  }
}

static  void method_5333( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<unsigned int,double> >*)o)->capacity)());
  else   (((const ::std::vector<std::pair<unsigned int,double> >*)o)->capacity)();
}

static  void method_5334( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::pair<unsigned int,double> >*)o)->empty)());
  else   (((const ::std::vector<std::pair<unsigned int,double> >*)o)->empty)();
}

static  void method_5335( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<unsigned int,double> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_5336( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<unsigned int,double> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<unsigned int,double> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_5337( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<unsigned int,double> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<unsigned int,double> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_5339( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<unsigned int,double> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<unsigned int,double> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5340( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<unsigned int,double> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<unsigned int,double> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5341( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<unsigned int,double> >*)o)->front)();
  else   (((::std::vector<std::pair<unsigned int,double> >*)o)->front)();
}

static  void method_5342( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<unsigned int,double> >*)o)->front)();
  else   (((const ::std::vector<std::pair<unsigned int,double> >*)o)->front)();
}

static  void method_5343( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<unsigned int,double> >*)o)->back)();
  else   (((::std::vector<std::pair<unsigned int,double> >*)o)->back)();
}

static  void method_5344( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<unsigned int,double> >*)o)->back)();
  else   (((const ::std::vector<std::pair<unsigned int,double> >*)o)->back)();
}

static  void method_5345( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::pair<unsigned int,double> >*)o)->data)());
  else   (((::std::vector<std::pair<unsigned int,double> >*)o)->data)();
}

static  void method_5346( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::pair<unsigned int,double> >*)o)->data)());
  else   (((const ::std::vector<std::pair<unsigned int,double> >*)o)->data)();
}

static  void method_5347( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<unsigned int,double> >*)o)->push_back)(*(const ::std::pair<unsigned int,double>*)arg[0]);
}

static  void method_5348( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<unsigned int,double> >*)o)->pop_back)();
}

static  void method_5349( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<unsigned int,double>*,std::vector<std::pair<unsigned int,double> > >)((((::std::vector<std::pair<unsigned int,double> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,double>*,std::vector<std::pair<unsigned int,double> > >*)arg[0],
    *(const ::std::pair<unsigned int,double>*)arg[1]));
  else   (((::std::vector<std::pair<unsigned int,double> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,double>*,std::vector<std::pair<unsigned int,double> > >*)arg[0],
    *(const ::std::pair<unsigned int,double>*)arg[1]);
}

static  void method_5350( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<unsigned int,double> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,double>*,std::vector<std::pair<unsigned int,double> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::pair<unsigned int,double>*)arg[2]);
}

static  void method_5351( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<unsigned int,double>*,std::vector<std::pair<unsigned int,double> > >)((((::std::vector<std::pair<unsigned int,double> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,double>*,std::vector<std::pair<unsigned int,double> > >*)arg[0]));
  else   (((::std::vector<std::pair<unsigned int,double> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,double>*,std::vector<std::pair<unsigned int,double> > >*)arg[0]);
}

static  void method_5352( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<unsigned int,double>*,std::vector<std::pair<unsigned int,double> > >)((((::std::vector<std::pair<unsigned int,double> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,double>*,std::vector<std::pair<unsigned int,double> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,double>*,std::vector<std::pair<unsigned int,double> > >*)arg[1]));
  else   (((::std::vector<std::pair<unsigned int,double> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,double>*,std::vector<std::pair<unsigned int,double> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,double>*,std::vector<std::pair<unsigned int,double> > >*)arg[1]);
}

static  void method_5353( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<unsigned int,double> >*)o)->swap)(*(::std::vector<std::pair<unsigned int,double> >*)arg[0]);
}

static  void method_5354( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<unsigned int,double> >*)o)->clear)();
}

static void method_newdel_1075( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<unsigned int,double> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<unsigned int,double> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<unsigned int,double> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<unsigned int,double> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<unsigned int,double> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x155( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<unsigned int,double>,std::allocator<std::pair<unsigned int,double> > >")), ::Reflex::BaseOffset< ::std::vector<std::pair<unsigned int,double> >,::std::_Vector_base<std::pair<unsigned int,double>,std::allocator<std::pair<unsigned int,double> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x156( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::pair<unsigned int,double> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::pair<unsigned int,double> > >::Generate();
}

//------Dictionary for class vector<std::pair<unsigned int, double>,std::allocator<std::pair<unsigned int, double> > > -------------------------------
void __std__vector_std__pair_unsignedsint_double_s__db_datamem(Reflex::Class*);
void __std__vector_std__pair_unsignedsint_double_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_unsignedsint_double_s__datamem_bld(&__std__vector_std__pair_unsignedsint_double_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_unsignedsint_double_s__funcmem_bld(&__std__vector_std__pair_unsignedsint_double_s__db_funcmem);
void __std__vector_std__pair_unsignedsint_double_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::pair<unsigned int,double> >"), typeid(::std::vector<std::pair<unsigned int,double> >), sizeof(::std::vector<std::pair<unsigned int,double> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1984, ::Reflex::BaseOffset< ::std::vector<std::pair<unsigned int,double> >, ::std::_Vector_base<std::pair<unsigned int,double>,std::allocator<std::pair<unsigned int,double> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_817, Reflex::Literal("std::vector<std::pair<unsigned int,double> >::_Alloc_value_type"))
  .AddTypedef(type_1984, Reflex::Literal("std::vector<std::pair<unsigned int,double> >::_Base"))
  .AddTypedef(type_1354, Reflex::Literal("std::vector<std::pair<unsigned int,double> >::_Tp_alloc_type"))
  .AddTypedef(type_817, Reflex::Literal("std::vector<std::pair<unsigned int,double> >::value_type"))
  .AddTypedef(type_5300, Reflex::Literal("std::vector<std::pair<unsigned int,double> >::pointer"))
  .AddTypedef(type_5302, Reflex::Literal("std::vector<std::pair<unsigned int,double> >::const_pointer"))
  .AddTypedef(type_5304, Reflex::Literal("std::vector<std::pair<unsigned int,double> >::reference"))
  .AddTypedef(type_5306, Reflex::Literal("std::vector<std::pair<unsigned int,double> >::const_reference"))
  .AddTypedef(type_2386, Reflex::Literal("std::vector<std::pair<unsigned int,double> >::iterator"))
  .AddTypedef(type_2387, Reflex::Literal("std::vector<std::pair<unsigned int,double> >::const_iterator"))
  .AddTypedef(type_1788, Reflex::Literal("std::vector<std::pair<unsigned int,double> >::const_reverse_iterator"))
  .AddTypedef(type_1789, Reflex::Literal("std::vector<std::pair<unsigned int,double> >::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<std::pair<unsigned int,double> >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<std::pair<unsigned int,double> >::difference_type"))
  .AddTypedef(type_1354, Reflex::Literal("std::vector<std::pair<unsigned int,double> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_5315, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20362), Reflex::Literal("vector"), constructor_5316, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_5306, type_20362), Reflex::Literal("vector"), constructor_5317, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20194), Reflex::Literal("vector"), constructor_5318, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_5319, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1075, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x155, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x156, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__pair_unsignedsint_double_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::pair<unsigned int, double>,std::allocator<std::pair<unsigned int, double> > > -------------------
void __std__vector_std__pair_unsignedsint_double_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::pair<unsigned int, double>,std::allocator<std::pair<unsigned int, double> > > -------------------
void __std__vector_std__pair_unsignedsint_double_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20363, type_20194), Reflex::Literal("operator="), operator_5320, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_5306), Reflex::Literal("assign"), method_5321, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2386), Reflex::Literal("begin"), method_5322, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2387), Reflex::Literal("begin"), method_5323, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2386), Reflex::Literal("end"), method_5324, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2387), Reflex::Literal("end"), method_5325, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_5330, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_5331, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_817), Reflex::Literal("resize"), method_5332, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_5333, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_5334, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_5335, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5304, type_1654), Reflex::Literal("operator[]"), operator_5336, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5306, type_1654), Reflex::Literal("operator[]"), operator_5337, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5304, type_1654), Reflex::Literal("at"), method_5339, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5306, type_1654), Reflex::Literal("at"), method_5340, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5304), Reflex::Literal("front"), method_5341, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5306), Reflex::Literal("front"), method_5342, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5304), Reflex::Literal("back"), method_5343, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5306), Reflex::Literal("back"), method_5344, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5300), Reflex::Literal("data"), method_5345, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5302), Reflex::Literal("data"), method_5346, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_5306), Reflex::Literal("push_back"), method_5347, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_5348, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2386, type_2386, type_5306), Reflex::Literal("insert"), method_5349, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2386, type_1654, type_5306), Reflex::Literal("insert"), method_5350, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2386, type_2386), Reflex::Literal("erase"), method_5351, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2386, type_2386, type_2386), Reflex::Literal("erase"), method_5352, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_20363), Reflex::Literal("swap"), method_5353, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_5354, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::pair<unsigned int, bool>,std::allocator<std::pair<unsigned int, bool> > > -------------------------------
static void constructor_5380( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<unsigned int,bool> >();
  else ::new(mem) ::std::vector<std::pair<unsigned int,bool> >();
}

static void constructor_5381( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<unsigned int,bool> >(*(const ::std::allocator<std::pair<unsigned int,bool> >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<unsigned int,bool> >(*(const ::std::allocator<std::pair<unsigned int,bool> >*)arg[0]);
}

static void constructor_5382( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<unsigned int,bool> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<unsigned int,bool> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<unsigned int,bool> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<unsigned int,bool>*)arg[1]);
  else ::new(mem) ::std::vector<std::pair<unsigned int,bool> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<unsigned int,bool>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<unsigned int,bool> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<unsigned int,bool>*)arg[1],
      *(const ::std::allocator<std::pair<unsigned int,bool> >*)arg[2]);
  else ::new(mem) ::std::vector<std::pair<unsigned int,bool> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<unsigned int,bool>*)arg[1],
      *(const ::std::allocator<std::pair<unsigned int,bool> >*)arg[2]);
  }
}

static void constructor_5383( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<unsigned int,bool> >(*(const ::std::vector<std::pair<unsigned int,bool> >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<unsigned int,bool> >(*(const ::std::vector<std::pair<unsigned int,bool> >*)arg[0]);
}

static void destructor_5384(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::pair<unsigned int,bool> >*)o)->::std::vector<std::pair<unsigned int,bool> >::~vector)();
}
static  void operator_5385( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<unsigned int,bool> >*)o)->operator=)(*(const ::std::vector<std::pair<unsigned int,bool> >*)arg[0]);
  else   (((::std::vector<std::pair<unsigned int,bool> >*)o)->operator=)(*(const ::std::vector<std::pair<unsigned int,bool> >*)arg[0]);
}

static  void method_5386( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<unsigned int,bool> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::pair<unsigned int,bool>*)arg[1]);
}

static  void method_5387( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<unsigned int,bool>*,std::vector<std::pair<unsigned int,bool> > >)((((::std::vector<std::pair<unsigned int,bool> >*)o)->begin)());
  else   (((::std::vector<std::pair<unsigned int,bool> >*)o)->begin)();
}

static  void method_5388( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<unsigned int,bool>*,std::vector<std::pair<unsigned int,bool> > >)((((const ::std::vector<std::pair<unsigned int,bool> >*)o)->begin)());
  else   (((const ::std::vector<std::pair<unsigned int,bool> >*)o)->begin)();
}

static  void method_5389( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<unsigned int,bool>*,std::vector<std::pair<unsigned int,bool> > >)((((::std::vector<std::pair<unsigned int,bool> >*)o)->end)());
  else   (((::std::vector<std::pair<unsigned int,bool> >*)o)->end)();
}

static  void method_5390( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<unsigned int,bool>*,std::vector<std::pair<unsigned int,bool> > >)((((const ::std::vector<std::pair<unsigned int,bool> >*)o)->end)());
  else   (((const ::std::vector<std::pair<unsigned int,bool> >*)o)->end)();
}

static  void method_5395( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<unsigned int,bool> >*)o)->size)());
  else   (((const ::std::vector<std::pair<unsigned int,bool> >*)o)->size)();
}

static  void method_5396( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<unsigned int,bool> >*)o)->max_size)());
  else   (((const ::std::vector<std::pair<unsigned int,bool> >*)o)->max_size)();
}

static  void method_5397( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::pair<unsigned int,bool> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::pair<unsigned int,bool> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::pair<unsigned int,bool>*)arg[1]);
  }
}

static  void method_5398( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<unsigned int,bool> >*)o)->capacity)());
  else   (((const ::std::vector<std::pair<unsigned int,bool> >*)o)->capacity)();
}

static  void method_5399( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::pair<unsigned int,bool> >*)o)->empty)());
  else   (((const ::std::vector<std::pair<unsigned int,bool> >*)o)->empty)();
}

static  void method_5400( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<unsigned int,bool> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_5401( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<unsigned int,bool> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<unsigned int,bool> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_5402( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<unsigned int,bool> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<unsigned int,bool> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_5404( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<unsigned int,bool> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<unsigned int,bool> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5405( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<unsigned int,bool> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<unsigned int,bool> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5406( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<unsigned int,bool> >*)o)->front)();
  else   (((::std::vector<std::pair<unsigned int,bool> >*)o)->front)();
}

static  void method_5407( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<unsigned int,bool> >*)o)->front)();
  else   (((const ::std::vector<std::pair<unsigned int,bool> >*)o)->front)();
}

static  void method_5408( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<unsigned int,bool> >*)o)->back)();
  else   (((::std::vector<std::pair<unsigned int,bool> >*)o)->back)();
}

static  void method_5409( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<unsigned int,bool> >*)o)->back)();
  else   (((const ::std::vector<std::pair<unsigned int,bool> >*)o)->back)();
}

static  void method_5410( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::pair<unsigned int,bool> >*)o)->data)());
  else   (((::std::vector<std::pair<unsigned int,bool> >*)o)->data)();
}

static  void method_5411( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::pair<unsigned int,bool> >*)o)->data)());
  else   (((const ::std::vector<std::pair<unsigned int,bool> >*)o)->data)();
}

static  void method_5412( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<unsigned int,bool> >*)o)->push_back)(*(const ::std::pair<unsigned int,bool>*)arg[0]);
}

static  void method_5413( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<unsigned int,bool> >*)o)->pop_back)();
}

static  void method_5414( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<unsigned int,bool>*,std::vector<std::pair<unsigned int,bool> > >)((((::std::vector<std::pair<unsigned int,bool> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,bool>*,std::vector<std::pair<unsigned int,bool> > >*)arg[0],
    *(const ::std::pair<unsigned int,bool>*)arg[1]));
  else   (((::std::vector<std::pair<unsigned int,bool> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,bool>*,std::vector<std::pair<unsigned int,bool> > >*)arg[0],
    *(const ::std::pair<unsigned int,bool>*)arg[1]);
}

static  void method_5415( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<unsigned int,bool> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,bool>*,std::vector<std::pair<unsigned int,bool> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::pair<unsigned int,bool>*)arg[2]);
}

static  void method_5416( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<unsigned int,bool>*,std::vector<std::pair<unsigned int,bool> > >)((((::std::vector<std::pair<unsigned int,bool> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,bool>*,std::vector<std::pair<unsigned int,bool> > >*)arg[0]));
  else   (((::std::vector<std::pair<unsigned int,bool> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,bool>*,std::vector<std::pair<unsigned int,bool> > >*)arg[0]);
}

static  void method_5417( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<unsigned int,bool>*,std::vector<std::pair<unsigned int,bool> > >)((((::std::vector<std::pair<unsigned int,bool> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,bool>*,std::vector<std::pair<unsigned int,bool> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,bool>*,std::vector<std::pair<unsigned int,bool> > >*)arg[1]));
  else   (((::std::vector<std::pair<unsigned int,bool> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,bool>*,std::vector<std::pair<unsigned int,bool> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<unsigned int,bool>*,std::vector<std::pair<unsigned int,bool> > >*)arg[1]);
}

static  void method_5418( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<unsigned int,bool> >*)o)->swap)(*(::std::vector<std::pair<unsigned int,bool> >*)arg[0]);
}

static  void method_5419( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<unsigned int,bool> >*)o)->clear)();
}

static void method_newdel_1076( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<unsigned int,bool> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<unsigned int,bool> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<unsigned int,bool> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<unsigned int,bool> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<unsigned int,bool> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x158( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<unsigned int,bool>,std::allocator<std::pair<unsigned int,bool> > >")), ::Reflex::BaseOffset< ::std::vector<std::pair<unsigned int,bool> >,::std::_Vector_base<std::pair<unsigned int,bool>,std::allocator<std::pair<unsigned int,bool> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x159( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::pair<unsigned int,bool> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::pair<unsigned int,bool> > >::Generate();
}

//------Dictionary for class vector<std::pair<unsigned int, bool>,std::allocator<std::pair<unsigned int, bool> > > -------------------------------
void __std__vector_std__pair_unsignedsint_bool_s__db_datamem(Reflex::Class*);
void __std__vector_std__pair_unsignedsint_bool_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_unsignedsint_bool_s__datamem_bld(&__std__vector_std__pair_unsignedsint_bool_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_unsignedsint_bool_s__funcmem_bld(&__std__vector_std__pair_unsignedsint_bool_s__db_funcmem);
void __std__vector_std__pair_unsignedsint_bool_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::pair<unsigned int,bool> >"), typeid(::std::vector<std::pair<unsigned int,bool> >), sizeof(::std::vector<std::pair<unsigned int,bool> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1985, ::Reflex::BaseOffset< ::std::vector<std::pair<unsigned int,bool> >, ::std::_Vector_base<std::pair<unsigned int,bool>,std::allocator<std::pair<unsigned int,bool> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_818, Reflex::Literal("std::vector<std::pair<unsigned int,bool> >::_Alloc_value_type"))
  .AddTypedef(type_1985, Reflex::Literal("std::vector<std::pair<unsigned int,bool> >::_Base"))
  .AddTypedef(type_1355, Reflex::Literal("std::vector<std::pair<unsigned int,bool> >::_Tp_alloc_type"))
  .AddTypedef(type_818, Reflex::Literal("std::vector<std::pair<unsigned int,bool> >::value_type"))
  .AddTypedef(type_5365, Reflex::Literal("std::vector<std::pair<unsigned int,bool> >::pointer"))
  .AddTypedef(type_5367, Reflex::Literal("std::vector<std::pair<unsigned int,bool> >::const_pointer"))
  .AddTypedef(type_5369, Reflex::Literal("std::vector<std::pair<unsigned int,bool> >::reference"))
  .AddTypedef(type_5371, Reflex::Literal("std::vector<std::pair<unsigned int,bool> >::const_reference"))
  .AddTypedef(type_2388, Reflex::Literal("std::vector<std::pair<unsigned int,bool> >::iterator"))
  .AddTypedef(type_2389, Reflex::Literal("std::vector<std::pair<unsigned int,bool> >::const_iterator"))
  .AddTypedef(type_1790, Reflex::Literal("std::vector<std::pair<unsigned int,bool> >::const_reverse_iterator"))
  .AddTypedef(type_1791, Reflex::Literal("std::vector<std::pair<unsigned int,bool> >::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<std::pair<unsigned int,bool> >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<std::pair<unsigned int,bool> >::difference_type"))
  .AddTypedef(type_1355, Reflex::Literal("std::vector<std::pair<unsigned int,bool> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_5380, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20365), Reflex::Literal("vector"), constructor_5381, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_5371, type_20365), Reflex::Literal("vector"), constructor_5382, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20197), Reflex::Literal("vector"), constructor_5383, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_5384, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1076, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x158, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x159, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__pair_unsignedsint_bool_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::pair<unsigned int, bool>,std::allocator<std::pair<unsigned int, bool> > > -------------------
void __std__vector_std__pair_unsignedsint_bool_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::pair<unsigned int, bool>,std::allocator<std::pair<unsigned int, bool> > > -------------------
void __std__vector_std__pair_unsignedsint_bool_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20366, type_20197), Reflex::Literal("operator="), operator_5385, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_5371), Reflex::Literal("assign"), method_5386, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2388), Reflex::Literal("begin"), method_5387, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2389), Reflex::Literal("begin"), method_5388, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2388), Reflex::Literal("end"), method_5389, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2389), Reflex::Literal("end"), method_5390, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_5395, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_5396, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_818), Reflex::Literal("resize"), method_5397, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_5398, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_5399, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_5400, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5369, type_1654), Reflex::Literal("operator[]"), operator_5401, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5371, type_1654), Reflex::Literal("operator[]"), operator_5402, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5369, type_1654), Reflex::Literal("at"), method_5404, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5371, type_1654), Reflex::Literal("at"), method_5405, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5369), Reflex::Literal("front"), method_5406, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5371), Reflex::Literal("front"), method_5407, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5369), Reflex::Literal("back"), method_5408, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5371), Reflex::Literal("back"), method_5409, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5365), Reflex::Literal("data"), method_5410, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5367), Reflex::Literal("data"), method_5411, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_5371), Reflex::Literal("push_back"), method_5412, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_5413, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2388, type_2388, type_5371), Reflex::Literal("insert"), method_5414, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2388, type_1654, type_5371), Reflex::Literal("insert"), method_5415, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2388, type_2388), Reflex::Literal("erase"), method_5416, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2388, type_2388, type_2388), Reflex::Literal("erase"), method_5417, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_20366), Reflex::Literal("swap"), method_5418, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_5419, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::pair<std::vector<std::pair<double, std::vector<double, std::allocator<double> > >, std::allocator<std::pair<double, std::vector<double, std::allocator<double> > > > >, bool>,std::allocator<std::pair<std::vector<std::pair<double, std::vector<double, std::allocator<double> > >, std::allocator<std::pair<double, std::vector<double, std::allocator<double> > > > >, bool> > > -------------------------------
static void constructor_5445( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >();
  else ::new(mem) ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >();
}

static void constructor_5446( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >(*(const ::std::allocator<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >(*(const ::std::allocator<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)arg[0]);
}

static void constructor_5447( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>*)arg[1]);
  else ::new(mem) ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>*)arg[1],
      *(const ::std::allocator<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)arg[2]);
  else ::new(mem) ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>*)arg[1],
      *(const ::std::allocator<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)arg[2]);
  }
}

static void constructor_5448( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >(*(const ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >(*(const ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)arg[0]);
}

static void destructor_5449(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >::~vector)();
}
static  void operator_5450( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->operator=)(*(const ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)arg[0]);
  else   (((::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->operator=)(*(const ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)arg[0]);
}

static  void method_5451( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>*)arg[1]);
}

static  void method_5452( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>*,std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> > >)((((::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->begin)());
  else   (((::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->begin)();
}

static  void method_5453( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>*,std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> > >)((((const ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->begin)());
  else   (((const ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->begin)();
}

static  void method_5454( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>*,std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> > >)((((::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->end)());
  else   (((::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->end)();
}

static  void method_5455( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>*,std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> > >)((((const ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->end)());
  else   (((const ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->end)();
}

static  void method_5460( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->size)());
  else   (((const ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->size)();
}

static  void method_5461( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->max_size)());
  else   (((const ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->max_size)();
}

static  void method_5462( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>*)arg[1]);
  }
}

static  void method_5463( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->capacity)());
  else   (((const ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->capacity)();
}

static  void method_5464( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->empty)());
  else   (((const ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->empty)();
}

static  void method_5465( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_5466( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_5467( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_5469( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5470( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5471( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->front)();
  else   (((::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->front)();
}

static  void method_5472( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->front)();
  else   (((const ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->front)();
}

static  void method_5473( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->back)();
  else   (((::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->back)();
}

static  void method_5474( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->back)();
  else   (((const ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->back)();
}

static  void method_5475( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->data)());
  else   (((::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->data)();
}

static  void method_5476( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->data)());
  else   (((const ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->data)();
}

static  void method_5477( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->push_back)(*(const ::std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>*)arg[0]);
}

static  void method_5478( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->pop_back)();
}

static  void method_5479( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>*,std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> > >)((((::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>*,std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> > >*)arg[0],
    *(const ::std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>*)arg[1]));
  else   (((::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>*,std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> > >*)arg[0],
    *(const ::std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>*)arg[1]);
}

static  void method_5480( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>*,std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>*)arg[2]);
}

static  void method_5481( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>*,std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> > >)((((::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>*,std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> > >*)arg[0]));
  else   (((::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>*,std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> > >*)arg[0]);
}

static  void method_5482( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>*,std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> > >)((((::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>*,std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>*,std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> > >*)arg[1]));
  else   (((::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>*,std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>*,std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> > >*)arg[1]);
}

static  void method_5483( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->swap)(*(::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)arg[0]);
}

static  void method_5484( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >*)o)->clear)();
}

static void method_newdel_1077( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x161( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>,std::allocator<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> > >")), ::Reflex::BaseOffset< ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >,::std::_Vector_base<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>,std::allocator<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x162( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> > >::Generate();
}

//------Dictionary for class vector<std::pair<std::vector<std::pair<double, std::vector<double, std::allocator<double> > >, std::allocator<std::pair<double, std::vector<double, std::allocator<double> > > > >, bool>,std::allocator<std::pair<std::vector<std::pair<double, std::vector<double, std::allocator<double> > >, std::allocator<std::pair<double, std::vector<double, std::allocator<double> > > > >, bool> > > -------------------------------
void __std__vector_std__pair_std__vector_std__pair_double_std__vector_double_s_s__bool_s__db_datamem(Reflex::Class*);
void __std__vector_std__pair_std__vector_std__pair_double_std__vector_double_s_s__bool_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_std__vector_std__pair_double_std__vector_double_s_s__bool_s__datamem_bld(&__std__vector_std__pair_std__vector_std__pair_double_std__vector_double_s_s__bool_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_std__vector_std__pair_double_std__vector_double_s_s__bool_s__funcmem_bld(&__std__vector_std__pair_std__vector_std__pair_double_std__vector_double_s_s__bool_s__db_funcmem);
void __std__vector_std__pair_std__vector_std__pair_double_std__vector_double_s_s__bool_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >"), typeid(::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >), sizeof(::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1963, ::Reflex::BaseOffset< ::std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >, ::std::_Vector_base<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool>,std::allocator<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_819, Reflex::Literal("std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >::_Alloc_value_type"))
  .AddTypedef(type_1963, Reflex::Literal("std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >::_Base"))
  .AddTypedef(type_1356, Reflex::Literal("std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >::_Tp_alloc_type"))
  .AddTypedef(type_819, Reflex::Literal("std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >::value_type"))
  .AddTypedef(type_5430, Reflex::Literal("std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >::pointer"))
  .AddTypedef(type_5432, Reflex::Literal("std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >::const_pointer"))
  .AddTypedef(type_5434, Reflex::Literal("std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >::reference"))
  .AddTypedef(type_5436, Reflex::Literal("std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >::const_reference"))
  .AddTypedef(type_2346, Reflex::Literal("std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >::iterator"))
  .AddTypedef(type_2347, Reflex::Literal("std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >::const_iterator"))
  .AddTypedef(type_1740, Reflex::Literal("std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >::const_reverse_iterator"))
  .AddTypedef(type_1741, Reflex::Literal("std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >::difference_type"))
  .AddTypedef(type_1356, Reflex::Literal("std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_5445, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20368), Reflex::Literal("vector"), constructor_5446, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_5436, type_20368), Reflex::Literal("vector"), constructor_5447, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20369), Reflex::Literal("vector"), constructor_5448, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_5449, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1077, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x161, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x162, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__pair_std__vector_std__pair_double_std__vector_double_s_s__bool_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::pair<std::vector<std::pair<double, std::vector<double, std::allocator<double> > >, std::allocator<std::pair<double, std::vector<double, std::allocator<double> > > > >, bool>,std::allocator<std::pair<std::vector<std::pair<double, std::vector<double, std::allocator<double> > >, std::allocator<std::pair<double, std::vector<double, std::allocator<double> > > > >, bool> > > -------------------
void __std__vector_std__pair_std__vector_std__pair_double_std__vector_double_s_s__bool_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::pair<std::vector<std::pair<double, std::vector<double, std::allocator<double> > >, std::allocator<std::pair<double, std::vector<double, std::allocator<double> > > > >, bool>,std::allocator<std::pair<std::vector<std::pair<double, std::vector<double, std::allocator<double> > >, std::allocator<std::pair<double, std::vector<double, std::allocator<double> > > > >, bool> > > -------------------
void __std__vector_std__pair_std__vector_std__pair_double_std__vector_double_s_s__bool_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20370, type_20369), Reflex::Literal("operator="), operator_5450, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_5436), Reflex::Literal("assign"), method_5451, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2346), Reflex::Literal("begin"), method_5452, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2347), Reflex::Literal("begin"), method_5453, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2346), Reflex::Literal("end"), method_5454, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2347), Reflex::Literal("end"), method_5455, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_5460, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_5461, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_819), Reflex::Literal("resize"), method_5462, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_5463, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_5464, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_5465, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5434, type_1654), Reflex::Literal("operator[]"), operator_5466, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5436, type_1654), Reflex::Literal("operator[]"), operator_5467, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5434, type_1654), Reflex::Literal("at"), method_5469, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5436, type_1654), Reflex::Literal("at"), method_5470, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5434), Reflex::Literal("front"), method_5471, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5436), Reflex::Literal("front"), method_5472, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5434), Reflex::Literal("back"), method_5473, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5436), Reflex::Literal("back"), method_5474, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5430), Reflex::Literal("data"), method_5475, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5432), Reflex::Literal("data"), method_5476, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_5436), Reflex::Literal("push_back"), method_5477, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_5478, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2346, type_2346, type_5436), Reflex::Literal("insert"), method_5479, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2346, type_1654, type_5436), Reflex::Literal("insert"), method_5480, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2346, type_2346), Reflex::Literal("erase"), method_5481, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2346, type_2346, type_2346), Reflex::Literal("erase"), method_5482, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_20370), Reflex::Literal("swap"), method_5483, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_5484, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::pair<double, std::vector<double, std::allocator<double> > >,std::allocator<std::pair<double, std::vector<double, std::allocator<double> > > > > -------------------------------
static void constructor_5510( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<double,std::vector<double> > >();
  else ::new(mem) ::std::vector<std::pair<double,std::vector<double> > >();
}

static void constructor_5511( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<double,std::vector<double> > >(*(const ::std::allocator<std::pair<double,std::vector<double> > >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<double,std::vector<double> > >(*(const ::std::allocator<std::pair<double,std::vector<double> > >*)arg[0]);
}

static void constructor_5512( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<double,std::vector<double> > >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<double,std::vector<double> > >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<double,std::vector<double> > >(*(::std::size_t*)arg[0],
      *(const ::std::pair<double,std::vector<double> >*)arg[1]);
  else ::new(mem) ::std::vector<std::pair<double,std::vector<double> > >(*(::std::size_t*)arg[0],
      *(const ::std::pair<double,std::vector<double> >*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<double,std::vector<double> > >(*(::std::size_t*)arg[0],
      *(const ::std::pair<double,std::vector<double> >*)arg[1],
      *(const ::std::allocator<std::pair<double,std::vector<double> > >*)arg[2]);
  else ::new(mem) ::std::vector<std::pair<double,std::vector<double> > >(*(::std::size_t*)arg[0],
      *(const ::std::pair<double,std::vector<double> >*)arg[1],
      *(const ::std::allocator<std::pair<double,std::vector<double> > >*)arg[2]);
  }
}

static void constructor_5513( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<double,std::vector<double> > >(*(const ::std::vector<std::pair<double,std::vector<double> > >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<double,std::vector<double> > >(*(const ::std::vector<std::pair<double,std::vector<double> > >*)arg[0]);
}

static void destructor_5514(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::pair<double,std::vector<double> > >*)o)->::std::vector<std::pair<double,std::vector<double> > >::~vector)();
}
static  void operator_5515( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<double,std::vector<double> > >*)o)->operator=)(*(const ::std::vector<std::pair<double,std::vector<double> > >*)arg[0]);
  else   (((::std::vector<std::pair<double,std::vector<double> > >*)o)->operator=)(*(const ::std::vector<std::pair<double,std::vector<double> > >*)arg[0]);
}

static  void method_5516( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<double,std::vector<double> > >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::pair<double,std::vector<double> >*)arg[1]);
}

static  void method_5517( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<double,std::vector<double> >*,std::vector<std::pair<double,std::vector<double> > > >)((((::std::vector<std::pair<double,std::vector<double> > >*)o)->begin)());
  else   (((::std::vector<std::pair<double,std::vector<double> > >*)o)->begin)();
}

static  void method_5518( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<double,std::vector<double> >*,std::vector<std::pair<double,std::vector<double> > > >)((((const ::std::vector<std::pair<double,std::vector<double> > >*)o)->begin)());
  else   (((const ::std::vector<std::pair<double,std::vector<double> > >*)o)->begin)();
}

static  void method_5519( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<double,std::vector<double> >*,std::vector<std::pair<double,std::vector<double> > > >)((((::std::vector<std::pair<double,std::vector<double> > >*)o)->end)());
  else   (((::std::vector<std::pair<double,std::vector<double> > >*)o)->end)();
}

static  void method_5520( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<double,std::vector<double> >*,std::vector<std::pair<double,std::vector<double> > > >)((((const ::std::vector<std::pair<double,std::vector<double> > >*)o)->end)());
  else   (((const ::std::vector<std::pair<double,std::vector<double> > >*)o)->end)();
}

static  void method_5525( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<double,std::vector<double> > >*)o)->size)());
  else   (((const ::std::vector<std::pair<double,std::vector<double> > >*)o)->size)();
}

static  void method_5526( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<double,std::vector<double> > >*)o)->max_size)());
  else   (((const ::std::vector<std::pair<double,std::vector<double> > >*)o)->max_size)();
}

static  void method_5527( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::pair<double,std::vector<double> > >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::pair<double,std::vector<double> > >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::pair<double,std::vector<double> >*)arg[1]);
  }
}

static  void method_5528( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<double,std::vector<double> > >*)o)->capacity)());
  else   (((const ::std::vector<std::pair<double,std::vector<double> > >*)o)->capacity)();
}

static  void method_5529( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::pair<double,std::vector<double> > >*)o)->empty)());
  else   (((const ::std::vector<std::pair<double,std::vector<double> > >*)o)->empty)();
}

static  void method_5530( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<double,std::vector<double> > >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_5531( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<double,std::vector<double> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<double,std::vector<double> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_5532( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<double,std::vector<double> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<double,std::vector<double> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_5534( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<double,std::vector<double> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<double,std::vector<double> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5535( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<double,std::vector<double> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<double,std::vector<double> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5536( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<double,std::vector<double> > >*)o)->front)();
  else   (((::std::vector<std::pair<double,std::vector<double> > >*)o)->front)();
}

static  void method_5537( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<double,std::vector<double> > >*)o)->front)();
  else   (((const ::std::vector<std::pair<double,std::vector<double> > >*)o)->front)();
}

static  void method_5538( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<double,std::vector<double> > >*)o)->back)();
  else   (((::std::vector<std::pair<double,std::vector<double> > >*)o)->back)();
}

static  void method_5539( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<double,std::vector<double> > >*)o)->back)();
  else   (((const ::std::vector<std::pair<double,std::vector<double> > >*)o)->back)();
}

static  void method_5540( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::pair<double,std::vector<double> > >*)o)->data)());
  else   (((::std::vector<std::pair<double,std::vector<double> > >*)o)->data)();
}

static  void method_5541( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::pair<double,std::vector<double> > >*)o)->data)());
  else   (((const ::std::vector<std::pair<double,std::vector<double> > >*)o)->data)();
}

static  void method_5542( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<double,std::vector<double> > >*)o)->push_back)(*(const ::std::pair<double,std::vector<double> >*)arg[0]);
}

static  void method_5543( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<double,std::vector<double> > >*)o)->pop_back)();
}

static  void method_5544( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<double,std::vector<double> >*,std::vector<std::pair<double,std::vector<double> > > >)((((::std::vector<std::pair<double,std::vector<double> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<double,std::vector<double> >*,std::vector<std::pair<double,std::vector<double> > > >*)arg[0],
    *(const ::std::pair<double,std::vector<double> >*)arg[1]));
  else   (((::std::vector<std::pair<double,std::vector<double> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<double,std::vector<double> >*,std::vector<std::pair<double,std::vector<double> > > >*)arg[0],
    *(const ::std::pair<double,std::vector<double> >*)arg[1]);
}

static  void method_5545( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<double,std::vector<double> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<double,std::vector<double> >*,std::vector<std::pair<double,std::vector<double> > > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::pair<double,std::vector<double> >*)arg[2]);
}

static  void method_5546( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<double,std::vector<double> >*,std::vector<std::pair<double,std::vector<double> > > >)((((::std::vector<std::pair<double,std::vector<double> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<double,std::vector<double> >*,std::vector<std::pair<double,std::vector<double> > > >*)arg[0]));
  else   (((::std::vector<std::pair<double,std::vector<double> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<double,std::vector<double> >*,std::vector<std::pair<double,std::vector<double> > > >*)arg[0]);
}

static  void method_5547( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<double,std::vector<double> >*,std::vector<std::pair<double,std::vector<double> > > >)((((::std::vector<std::pair<double,std::vector<double> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<double,std::vector<double> >*,std::vector<std::pair<double,std::vector<double> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<double,std::vector<double> >*,std::vector<std::pair<double,std::vector<double> > > >*)arg[1]));
  else   (((::std::vector<std::pair<double,std::vector<double> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<double,std::vector<double> >*,std::vector<std::pair<double,std::vector<double> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<double,std::vector<double> >*,std::vector<std::pair<double,std::vector<double> > > >*)arg[1]);
}

static  void method_5548( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<double,std::vector<double> > >*)o)->swap)(*(::std::vector<std::pair<double,std::vector<double> > >*)arg[0]);
}

static  void method_5549( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<double,std::vector<double> > >*)o)->clear)();
}

static void method_newdel_1078( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<double,std::vector<double> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<double,std::vector<double> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<double,std::vector<double> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<double,std::vector<double> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<double,std::vector<double> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x164( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<double,std::vector<double> >,std::allocator<std::pair<double,std::vector<double> > > >")), ::Reflex::BaseOffset< ::std::vector<std::pair<double,std::vector<double> > >,::std::_Vector_base<std::pair<double,std::vector<double> >,std::allocator<std::pair<double,std::vector<double> > > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x165( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::pair<double,std::vector<double> > > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::pair<double,std::vector<double> > > >::Generate();
}

//------Dictionary for class vector<std::pair<double, std::vector<double, std::allocator<double> > >,std::allocator<std::pair<double, std::vector<double, std::allocator<double> > > > > -------------------------------
void __std__vector_std__pair_double_std__vector_double_s_s__db_datamem(Reflex::Class*);
void __std__vector_std__pair_double_std__vector_double_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_double_std__vector_double_s_s__datamem_bld(&__std__vector_std__pair_double_std__vector_double_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_double_std__vector_double_s_s__funcmem_bld(&__std__vector_std__pair_double_std__vector_double_s_s__db_funcmem);
void __std__vector_std__pair_double_std__vector_double_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::pair<double,std::vector<double> > >"), typeid(::std::vector<std::pair<double,std::vector<double> > >), sizeof(::std::vector<std::pair<double,std::vector<double> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1979, ::Reflex::BaseOffset< ::std::vector<std::pair<double,std::vector<double> > >, ::std::_Vector_base<std::pair<double,std::vector<double> >,std::allocator<std::pair<double,std::vector<double> > > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_820, Reflex::Literal("std::vector<std::pair<double,std::vector<double> > >::_Alloc_value_type"))
  .AddTypedef(type_1979, Reflex::Literal("std::vector<std::pair<double,std::vector<double> > >::_Base"))
  .AddTypedef(type_1357, Reflex::Literal("std::vector<std::pair<double,std::vector<double> > >::_Tp_alloc_type"))
  .AddTypedef(type_820, Reflex::Literal("std::vector<std::pair<double,std::vector<double> > >::value_type"))
  .AddTypedef(type_5495, Reflex::Literal("std::vector<std::pair<double,std::vector<double> > >::pointer"))
  .AddTypedef(type_5497, Reflex::Literal("std::vector<std::pair<double,std::vector<double> > >::const_pointer"))
  .AddTypedef(type_5499, Reflex::Literal("std::vector<std::pair<double,std::vector<double> > >::reference"))
  .AddTypedef(type_5501, Reflex::Literal("std::vector<std::pair<double,std::vector<double> > >::const_reference"))
  .AddTypedef(type_2380, Reflex::Literal("std::vector<std::pair<double,std::vector<double> > >::iterator"))
  .AddTypedef(type_2381, Reflex::Literal("std::vector<std::pair<double,std::vector<double> > >::const_iterator"))
  .AddTypedef(type_1778, Reflex::Literal("std::vector<std::pair<double,std::vector<double> > >::const_reverse_iterator"))
  .AddTypedef(type_1779, Reflex::Literal("std::vector<std::pair<double,std::vector<double> > >::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<std::pair<double,std::vector<double> > >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<std::pair<double,std::vector<double> > >::difference_type"))
  .AddTypedef(type_1357, Reflex::Literal("std::vector<std::pair<double,std::vector<double> > >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_5510, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20372), Reflex::Literal("vector"), constructor_5511, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_5501, type_20372), Reflex::Literal("vector"), constructor_5512, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20175), Reflex::Literal("vector"), constructor_5513, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_5514, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1078, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x164, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x165, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__pair_double_std__vector_double_s_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::pair<double, std::vector<double, std::allocator<double> > >,std::allocator<std::pair<double, std::vector<double, std::allocator<double> > > > > -------------------
void __std__vector_std__pair_double_std__vector_double_s_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::pair<double, std::vector<double, std::allocator<double> > >,std::allocator<std::pair<double, std::vector<double, std::allocator<double> > > > > -------------------
void __std__vector_std__pair_double_std__vector_double_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20373, type_20175), Reflex::Literal("operator="), operator_5515, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_5501), Reflex::Literal("assign"), method_5516, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2380), Reflex::Literal("begin"), method_5517, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2381), Reflex::Literal("begin"), method_5518, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2380), Reflex::Literal("end"), method_5519, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2381), Reflex::Literal("end"), method_5520, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_5525, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_5526, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_820), Reflex::Literal("resize"), method_5527, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_5528, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_5529, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_5530, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5499, type_1654), Reflex::Literal("operator[]"), operator_5531, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5501, type_1654), Reflex::Literal("operator[]"), operator_5532, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5499, type_1654), Reflex::Literal("at"), method_5534, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5501, type_1654), Reflex::Literal("at"), method_5535, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5499), Reflex::Literal("front"), method_5536, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5501), Reflex::Literal("front"), method_5537, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5499), Reflex::Literal("back"), method_5538, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5501), Reflex::Literal("back"), method_5539, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5495), Reflex::Literal("data"), method_5540, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5497), Reflex::Literal("data"), method_5541, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_5501), Reflex::Literal("push_back"), method_5542, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_5543, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2380, type_2380, type_5501), Reflex::Literal("insert"), method_5544, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2380, type_1654, type_5501), Reflex::Literal("insert"), method_5545, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2380, type_2380), Reflex::Literal("erase"), method_5546, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2380, type_2380, type_2380), Reflex::Literal("erase"), method_5547, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_20373), Reflex::Literal("swap"), method_5548, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_5549, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > > -------------------------------
static void constructor_5575( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,int> >();
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,int> >();
}

static void constructor_5576( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,int> >(*(const ::std::allocator<std::pair<std::basic_string<char>,int> >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,int> >(*(const ::std::allocator<std::pair<std::basic_string<char>,int> >*)arg[0]);
}

static void constructor_5577( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,int> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,int> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,int> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,int>*)arg[1]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,int> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,int>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,int> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,int>*)arg[1],
      *(const ::std::allocator<std::pair<std::basic_string<char>,int> >*)arg[2]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,int> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,int>*)arg[1],
      *(const ::std::allocator<std::pair<std::basic_string<char>,int> >*)arg[2]);
  }
}

static void constructor_5578( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,int> >(*(const ::std::vector<std::pair<std::basic_string<char>,int> >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,int> >(*(const ::std::vector<std::pair<std::basic_string<char>,int> >*)arg[0]);
}

static void destructor_5579(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->::std::vector<std::pair<std::basic_string<char>,int> >::~vector)();
}
static  void operator_5580( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->operator=)(*(const ::std::vector<std::pair<std::basic_string<char>,int> >*)arg[0]);
  else   (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->operator=)(*(const ::std::vector<std::pair<std::basic_string<char>,int> >*)arg[0]);
}

static  void method_5581( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::pair<std::basic_string<char>,int>*)arg[1]);
}

static  void method_5582( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >)((((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->begin)());
  else   (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->begin)();
}

static  void method_5583( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >)((((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->begin)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->begin)();
}

static  void method_5584( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >)((((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->end)());
  else   (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->end)();
}

static  void method_5585( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >)((((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->end)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->end)();
}

static  void method_5590( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->size)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->size)();
}

static  void method_5591( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->max_size)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->max_size)();
}

static  void method_5592( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::pair<std::basic_string<char>,int>*)arg[1]);
  }
}

static  void method_5593( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->capacity)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->capacity)();
}

static  void method_5594( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->empty)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->empty)();
}

static  void method_5595( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_5596( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_5597( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_5599( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5600( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5601( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->front)();
  else   (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->front)();
}

static  void method_5602( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->front)();
  else   (((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->front)();
}

static  void method_5603( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->back)();
  else   (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->back)();
}

static  void method_5604( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->back)();
  else   (((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->back)();
}

static  void method_5605( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->data)());
  else   (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->data)();
}

static  void method_5606( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->data)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,int> >*)o)->data)();
}

static  void method_5607( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->push_back)(*(const ::std::pair<std::basic_string<char>,int>*)arg[0]);
}

static  void method_5608( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->pop_back)();
}

static  void method_5609( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >)((((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >*)arg[0],
    *(const ::std::pair<std::basic_string<char>,int>*)arg[1]));
  else   (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >*)arg[0],
    *(const ::std::pair<std::basic_string<char>,int>*)arg[1]);
}

static  void method_5610( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::pair<std::basic_string<char>,int>*)arg[2]);
}

static  void method_5611( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >)((((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >*)arg[0]));
  else   (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >*)arg[0]);
}

static  void method_5612( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >)((((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >*)arg[1]));
  else   (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,int>*,std::vector<std::pair<std::basic_string<char>,int> > >*)arg[1]);
}

static  void method_5613( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->swap)(*(::std::vector<std::pair<std::basic_string<char>,int> >*)arg[0]);
}

static  void method_5614( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,int> >*)o)->clear)();
}

static void method_newdel_1079( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x167( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<std::basic_string<char>,int>,std::allocator<std::pair<std::basic_string<char>,int> > >")), ::Reflex::BaseOffset< ::std::vector<std::pair<std::basic_string<char>,int> >,::std::_Vector_base<std::pair<std::basic_string<char>,int>,std::allocator<std::pair<std::basic_string<char>,int> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x168( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::pair<std::basic_string<char>,int> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::pair<std::basic_string<char>,int> > >::Generate();
}

//------Dictionary for class vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > > -------------------------------
void __std__vector_std__pair_std__basic_string_char__int_s__db_datamem(Reflex::Class*);
void __std__vector_std__pair_std__basic_string_char__int_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_std__basic_string_char__int_s__datamem_bld(&__std__vector_std__pair_std__basic_string_char__int_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_std__basic_string_char__int_s__funcmem_bld(&__std__vector_std__pair_std__basic_string_char__int_s__db_funcmem);
void __std__vector_std__pair_std__basic_string_char__int_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >"), typeid(::std::vector<std::pair<std::basic_string<char>,int> >), sizeof(::std::vector<std::pair<std::basic_string<char>,int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1964, ::Reflex::BaseOffset< ::std::vector<std::pair<std::basic_string<char>,int> >, ::std::_Vector_base<std::pair<std::basic_string<char>,int>,std::allocator<std::pair<std::basic_string<char>,int> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_821, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::_Alloc_value_type"))
  .AddTypedef(type_1964, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::_Base"))
  .AddTypedef(type_1358, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::_Tp_alloc_type"))
  .AddTypedef(type_821, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::value_type"))
  .AddTypedef(type_5560, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::pointer"))
  .AddTypedef(type_5562, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::const_pointer"))
  .AddTypedef(type_5564, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::reference"))
  .AddTypedef(type_5566, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::const_reference"))
  .AddTypedef(type_2348, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::iterator"))
  .AddTypedef(type_2349, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::const_iterator"))
  .AddTypedef(type_1742, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::const_reverse_iterator"))
  .AddTypedef(type_1743, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::difference_type"))
  .AddTypedef(type_1358, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,int> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_5575, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20375), Reflex::Literal("vector"), constructor_5576, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_5566, type_20375), Reflex::Literal("vector"), constructor_5577, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20376), Reflex::Literal("vector"), constructor_5578, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_5579, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1079, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x167, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x168, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__pair_std__basic_string_char__int_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > > -------------------
void __std__vector_std__pair_std__basic_string_char__int_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > > -------------------
void __std__vector_std__pair_std__basic_string_char__int_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20377, type_20376), Reflex::Literal("operator="), operator_5580, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_5566), Reflex::Literal("assign"), method_5581, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2348), Reflex::Literal("begin"), method_5582, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2349), Reflex::Literal("begin"), method_5583, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2348), Reflex::Literal("end"), method_5584, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2349), Reflex::Literal("end"), method_5585, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_5590, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_5591, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_821), Reflex::Literal("resize"), method_5592, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_5593, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_5594, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_5595, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5564, type_1654), Reflex::Literal("operator[]"), operator_5596, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5566, type_1654), Reflex::Literal("operator[]"), operator_5597, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5564, type_1654), Reflex::Literal("at"), method_5599, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5566, type_1654), Reflex::Literal("at"), method_5600, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5564), Reflex::Literal("front"), method_5601, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5566), Reflex::Literal("front"), method_5602, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5564), Reflex::Literal("back"), method_5603, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5566), Reflex::Literal("back"), method_5604, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5560), Reflex::Literal("data"), method_5605, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5562), Reflex::Literal("data"), method_5606, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_5566), Reflex::Literal("push_back"), method_5607, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_5608, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2348, type_2348, type_5566), Reflex::Literal("insert"), method_5609, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2348, type_1654, type_5566), Reflex::Literal("insert"), method_5610, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2348, type_2348), Reflex::Literal("erase"), method_5611, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2348, type_2348, type_2348), Reflex::Literal("erase"), method_5612, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_20377), Reflex::Literal("swap"), method_5613, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_5614, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, float>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, float> > > -------------------------------
static void constructor_5640( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,float> >();
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,float> >();
}

static void constructor_5641( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,float> >(*(const ::std::allocator<std::pair<std::basic_string<char>,float> >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,float> >(*(const ::std::allocator<std::pair<std::basic_string<char>,float> >*)arg[0]);
}

static void constructor_5642( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,float> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,float> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,float> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,float>*)arg[1]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,float> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,float>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,float> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,float>*)arg[1],
      *(const ::std::allocator<std::pair<std::basic_string<char>,float> >*)arg[2]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,float> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,float>*)arg[1],
      *(const ::std::allocator<std::pair<std::basic_string<char>,float> >*)arg[2]);
  }
}

static void constructor_5643( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,float> >(*(const ::std::vector<std::pair<std::basic_string<char>,float> >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,float> >(*(const ::std::vector<std::pair<std::basic_string<char>,float> >*)arg[0]);
}

static void destructor_5644(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::pair<std::basic_string<char>,float> >*)o)->::std::vector<std::pair<std::basic_string<char>,float> >::~vector)();
}
static  void operator_5645( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,float> >*)o)->operator=)(*(const ::std::vector<std::pair<std::basic_string<char>,float> >*)arg[0]);
  else   (((::std::vector<std::pair<std::basic_string<char>,float> >*)o)->operator=)(*(const ::std::vector<std::pair<std::basic_string<char>,float> >*)arg[0]);
}

static  void method_5646( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,float> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::pair<std::basic_string<char>,float>*)arg[1]);
}

static  void method_5647( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,float>*,std::vector<std::pair<std::basic_string<char>,float> > >)((((::std::vector<std::pair<std::basic_string<char>,float> >*)o)->begin)());
  else   (((::std::vector<std::pair<std::basic_string<char>,float> >*)o)->begin)();
}

static  void method_5648( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,float>*,std::vector<std::pair<std::basic_string<char>,float> > >)((((const ::std::vector<std::pair<std::basic_string<char>,float> >*)o)->begin)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,float> >*)o)->begin)();
}

static  void method_5649( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,float>*,std::vector<std::pair<std::basic_string<char>,float> > >)((((::std::vector<std::pair<std::basic_string<char>,float> >*)o)->end)());
  else   (((::std::vector<std::pair<std::basic_string<char>,float> >*)o)->end)();
}

static  void method_5650( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,float>*,std::vector<std::pair<std::basic_string<char>,float> > >)((((const ::std::vector<std::pair<std::basic_string<char>,float> >*)o)->end)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,float> >*)o)->end)();
}

static  void method_5655( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<std::basic_string<char>,float> >*)o)->size)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,float> >*)o)->size)();
}

static  void method_5656( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<std::basic_string<char>,float> >*)o)->max_size)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,float> >*)o)->max_size)();
}

static  void method_5657( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::pair<std::basic_string<char>,float> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::pair<std::basic_string<char>,float> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::pair<std::basic_string<char>,float>*)arg[1]);
  }
}

static  void method_5658( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<std::basic_string<char>,float> >*)o)->capacity)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,float> >*)o)->capacity)();
}

static  void method_5659( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::pair<std::basic_string<char>,float> >*)o)->empty)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,float> >*)o)->empty)();
}

static  void method_5660( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,float> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_5661( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,float> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<std::basic_string<char>,float> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_5662( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::basic_string<char>,float> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<std::basic_string<char>,float> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_5664( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,float> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<std::basic_string<char>,float> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5665( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::basic_string<char>,float> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<std::basic_string<char>,float> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5666( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,float> >*)o)->front)();
  else   (((::std::vector<std::pair<std::basic_string<char>,float> >*)o)->front)();
}

static  void method_5667( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::basic_string<char>,float> >*)o)->front)();
  else   (((const ::std::vector<std::pair<std::basic_string<char>,float> >*)o)->front)();
}

static  void method_5668( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,float> >*)o)->back)();
  else   (((::std::vector<std::pair<std::basic_string<char>,float> >*)o)->back)();
}

static  void method_5669( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::basic_string<char>,float> >*)o)->back)();
  else   (((const ::std::vector<std::pair<std::basic_string<char>,float> >*)o)->back)();
}

static  void method_5670( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::pair<std::basic_string<char>,float> >*)o)->data)());
  else   (((::std::vector<std::pair<std::basic_string<char>,float> >*)o)->data)();
}

static  void method_5671( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::pair<std::basic_string<char>,float> >*)o)->data)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,float> >*)o)->data)();
}

static  void method_5672( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,float> >*)o)->push_back)(*(const ::std::pair<std::basic_string<char>,float>*)arg[0]);
}

static  void method_5673( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,float> >*)o)->pop_back)();
}

static  void method_5674( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,float>*,std::vector<std::pair<std::basic_string<char>,float> > >)((((::std::vector<std::pair<std::basic_string<char>,float> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,float>*,std::vector<std::pair<std::basic_string<char>,float> > >*)arg[0],
    *(const ::std::pair<std::basic_string<char>,float>*)arg[1]));
  else   (((::std::vector<std::pair<std::basic_string<char>,float> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,float>*,std::vector<std::pair<std::basic_string<char>,float> > >*)arg[0],
    *(const ::std::pair<std::basic_string<char>,float>*)arg[1]);
}

static  void method_5675( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,float> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,float>*,std::vector<std::pair<std::basic_string<char>,float> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::pair<std::basic_string<char>,float>*)arg[2]);
}

static  void method_5676( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,float>*,std::vector<std::pair<std::basic_string<char>,float> > >)((((::std::vector<std::pair<std::basic_string<char>,float> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,float>*,std::vector<std::pair<std::basic_string<char>,float> > >*)arg[0]));
  else   (((::std::vector<std::pair<std::basic_string<char>,float> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,float>*,std::vector<std::pair<std::basic_string<char>,float> > >*)arg[0]);
}

static  void method_5677( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,float>*,std::vector<std::pair<std::basic_string<char>,float> > >)((((::std::vector<std::pair<std::basic_string<char>,float> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,float>*,std::vector<std::pair<std::basic_string<char>,float> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,float>*,std::vector<std::pair<std::basic_string<char>,float> > >*)arg[1]));
  else   (((::std::vector<std::pair<std::basic_string<char>,float> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,float>*,std::vector<std::pair<std::basic_string<char>,float> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,float>*,std::vector<std::pair<std::basic_string<char>,float> > >*)arg[1]);
}

static  void method_5678( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,float> >*)o)->swap)(*(::std::vector<std::pair<std::basic_string<char>,float> >*)arg[0]);
}

static  void method_5679( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,float> >*)o)->clear)();
}

static void method_newdel_1080( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,float> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,float> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,float> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,float> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,float> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x170( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<std::basic_string<char>,float>,std::allocator<std::pair<std::basic_string<char>,float> > >")), ::Reflex::BaseOffset< ::std::vector<std::pair<std::basic_string<char>,float> >,::std::_Vector_base<std::pair<std::basic_string<char>,float>,std::allocator<std::pair<std::basic_string<char>,float> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x171( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::pair<std::basic_string<char>,float> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::pair<std::basic_string<char>,float> > >::Generate();
}

//------Dictionary for class vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, float>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, float> > > -------------------------------
void __std__vector_std__pair_std__basic_string_char__float_s__db_datamem(Reflex::Class*);
void __std__vector_std__pair_std__basic_string_char__float_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_std__basic_string_char__float_s__datamem_bld(&__std__vector_std__pair_std__basic_string_char__float_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_std__basic_string_char__float_s__funcmem_bld(&__std__vector_std__pair_std__basic_string_char__float_s__db_funcmem);
void __std__vector_std__pair_std__basic_string_char__float_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,float> >"), typeid(::std::vector<std::pair<std::basic_string<char>,float> >), sizeof(::std::vector<std::pair<std::basic_string<char>,float> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1965, ::Reflex::BaseOffset< ::std::vector<std::pair<std::basic_string<char>,float> >, ::std::_Vector_base<std::pair<std::basic_string<char>,float>,std::allocator<std::pair<std::basic_string<char>,float> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_822, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,float> >::_Alloc_value_type"))
  .AddTypedef(type_1965, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,float> >::_Base"))
  .AddTypedef(type_1359, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,float> >::_Tp_alloc_type"))
  .AddTypedef(type_822, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,float> >::value_type"))
  .AddTypedef(type_5625, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,float> >::pointer"))
  .AddTypedef(type_5627, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,float> >::const_pointer"))
  .AddTypedef(type_5629, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,float> >::reference"))
  .AddTypedef(type_5631, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,float> >::const_reference"))
  .AddTypedef(type_2350, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,float> >::iterator"))
  .AddTypedef(type_2351, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,float> >::const_iterator"))
  .AddTypedef(type_1744, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,float> >::const_reverse_iterator"))
  .AddTypedef(type_1745, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,float> >::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,float> >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,float> >::difference_type"))
  .AddTypedef(type_1359, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,float> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_5640, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20379), Reflex::Literal("vector"), constructor_5641, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_5631, type_20379), Reflex::Literal("vector"), constructor_5642, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20380), Reflex::Literal("vector"), constructor_5643, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_5644, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1080, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x170, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x171, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__pair_std__basic_string_char__float_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, float>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, float> > > -------------------
void __std__vector_std__pair_std__basic_string_char__float_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, float>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, float> > > -------------------
void __std__vector_std__pair_std__basic_string_char__float_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20381, type_20380), Reflex::Literal("operator="), operator_5645, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_5631), Reflex::Literal("assign"), method_5646, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2350), Reflex::Literal("begin"), method_5647, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2351), Reflex::Literal("begin"), method_5648, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2350), Reflex::Literal("end"), method_5649, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2351), Reflex::Literal("end"), method_5650, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_5655, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_5656, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_822), Reflex::Literal("resize"), method_5657, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_5658, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_5659, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_5660, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5629, type_1654), Reflex::Literal("operator[]"), operator_5661, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5631, type_1654), Reflex::Literal("operator[]"), operator_5662, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5629, type_1654), Reflex::Literal("at"), method_5664, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5631, type_1654), Reflex::Literal("at"), method_5665, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5629), Reflex::Literal("front"), method_5666, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5631), Reflex::Literal("front"), method_5667, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5629), Reflex::Literal("back"), method_5668, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5631), Reflex::Literal("back"), method_5669, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5625), Reflex::Literal("data"), method_5670, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5627), Reflex::Literal("data"), method_5671, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_5631), Reflex::Literal("push_back"), method_5672, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_5673, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2350, type_2350, type_5631), Reflex::Literal("insert"), method_5674, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2350, type_1654, type_5631), Reflex::Literal("insert"), method_5675, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2350, type_2350), Reflex::Literal("erase"), method_5676, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2350, type_2350, type_2350), Reflex::Literal("erase"), method_5677, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_20381), Reflex::Literal("swap"), method_5678, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_5679, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, double>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, double> > > -------------------------------
static void constructor_5705( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,double> >();
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,double> >();
}

static void constructor_5706( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,double> >(*(const ::std::allocator<std::pair<std::basic_string<char>,double> >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,double> >(*(const ::std::allocator<std::pair<std::basic_string<char>,double> >*)arg[0]);
}

static void constructor_5707( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,double> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,double> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,double> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,double>*)arg[1]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,double> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,double>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,double> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,double>*)arg[1],
      *(const ::std::allocator<std::pair<std::basic_string<char>,double> >*)arg[2]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,double> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,double>*)arg[1],
      *(const ::std::allocator<std::pair<std::basic_string<char>,double> >*)arg[2]);
  }
}

static void constructor_5708( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,double> >(*(const ::std::vector<std::pair<std::basic_string<char>,double> >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,double> >(*(const ::std::vector<std::pair<std::basic_string<char>,double> >*)arg[0]);
}

static void destructor_5709(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::pair<std::basic_string<char>,double> >*)o)->::std::vector<std::pair<std::basic_string<char>,double> >::~vector)();
}
static  void operator_5710( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,double> >*)o)->operator=)(*(const ::std::vector<std::pair<std::basic_string<char>,double> >*)arg[0]);
  else   (((::std::vector<std::pair<std::basic_string<char>,double> >*)o)->operator=)(*(const ::std::vector<std::pair<std::basic_string<char>,double> >*)arg[0]);
}

static  void method_5711( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,double> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::pair<std::basic_string<char>,double>*)arg[1]);
}

static  void method_5712( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,double>*,std::vector<std::pair<std::basic_string<char>,double> > >)((((::std::vector<std::pair<std::basic_string<char>,double> >*)o)->begin)());
  else   (((::std::vector<std::pair<std::basic_string<char>,double> >*)o)->begin)();
}

static  void method_5713( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,double>*,std::vector<std::pair<std::basic_string<char>,double> > >)((((const ::std::vector<std::pair<std::basic_string<char>,double> >*)o)->begin)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,double> >*)o)->begin)();
}

static  void method_5714( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,double>*,std::vector<std::pair<std::basic_string<char>,double> > >)((((::std::vector<std::pair<std::basic_string<char>,double> >*)o)->end)());
  else   (((::std::vector<std::pair<std::basic_string<char>,double> >*)o)->end)();
}

static  void method_5715( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,double>*,std::vector<std::pair<std::basic_string<char>,double> > >)((((const ::std::vector<std::pair<std::basic_string<char>,double> >*)o)->end)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,double> >*)o)->end)();
}

static  void method_5720( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<std::basic_string<char>,double> >*)o)->size)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,double> >*)o)->size)();
}

static  void method_5721( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<std::basic_string<char>,double> >*)o)->max_size)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,double> >*)o)->max_size)();
}

static  void method_5722( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::pair<std::basic_string<char>,double> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::pair<std::basic_string<char>,double> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::pair<std::basic_string<char>,double>*)arg[1]);
  }
}

static  void method_5723( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<std::basic_string<char>,double> >*)o)->capacity)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,double> >*)o)->capacity)();
}

static  void method_5724( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::pair<std::basic_string<char>,double> >*)o)->empty)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,double> >*)o)->empty)();
}

static  void method_5725( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,double> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_5726( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,double> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<std::basic_string<char>,double> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_5727( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::basic_string<char>,double> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<std::basic_string<char>,double> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_5729( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,double> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<std::basic_string<char>,double> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5730( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::basic_string<char>,double> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<std::basic_string<char>,double> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5731( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,double> >*)o)->front)();
  else   (((::std::vector<std::pair<std::basic_string<char>,double> >*)o)->front)();
}

static  void method_5732( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::basic_string<char>,double> >*)o)->front)();
  else   (((const ::std::vector<std::pair<std::basic_string<char>,double> >*)o)->front)();
}

static  void method_5733( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,double> >*)o)->back)();
  else   (((::std::vector<std::pair<std::basic_string<char>,double> >*)o)->back)();
}

static  void method_5734( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::basic_string<char>,double> >*)o)->back)();
  else   (((const ::std::vector<std::pair<std::basic_string<char>,double> >*)o)->back)();
}

static  void method_5735( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::pair<std::basic_string<char>,double> >*)o)->data)());
  else   (((::std::vector<std::pair<std::basic_string<char>,double> >*)o)->data)();
}

static  void method_5736( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::pair<std::basic_string<char>,double> >*)o)->data)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,double> >*)o)->data)();
}

static  void method_5737( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,double> >*)o)->push_back)(*(const ::std::pair<std::basic_string<char>,double>*)arg[0]);
}

static  void method_5738( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,double> >*)o)->pop_back)();
}

static  void method_5739( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,double>*,std::vector<std::pair<std::basic_string<char>,double> > >)((((::std::vector<std::pair<std::basic_string<char>,double> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,double>*,std::vector<std::pair<std::basic_string<char>,double> > >*)arg[0],
    *(const ::std::pair<std::basic_string<char>,double>*)arg[1]));
  else   (((::std::vector<std::pair<std::basic_string<char>,double> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,double>*,std::vector<std::pair<std::basic_string<char>,double> > >*)arg[0],
    *(const ::std::pair<std::basic_string<char>,double>*)arg[1]);
}

static  void method_5740( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,double> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,double>*,std::vector<std::pair<std::basic_string<char>,double> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::pair<std::basic_string<char>,double>*)arg[2]);
}

static  void method_5741( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,double>*,std::vector<std::pair<std::basic_string<char>,double> > >)((((::std::vector<std::pair<std::basic_string<char>,double> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,double>*,std::vector<std::pair<std::basic_string<char>,double> > >*)arg[0]));
  else   (((::std::vector<std::pair<std::basic_string<char>,double> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,double>*,std::vector<std::pair<std::basic_string<char>,double> > >*)arg[0]);
}

static  void method_5742( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,double>*,std::vector<std::pair<std::basic_string<char>,double> > >)((((::std::vector<std::pair<std::basic_string<char>,double> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,double>*,std::vector<std::pair<std::basic_string<char>,double> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,double>*,std::vector<std::pair<std::basic_string<char>,double> > >*)arg[1]));
  else   (((::std::vector<std::pair<std::basic_string<char>,double> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,double>*,std::vector<std::pair<std::basic_string<char>,double> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,double>*,std::vector<std::pair<std::basic_string<char>,double> > >*)arg[1]);
}

static  void method_5743( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,double> >*)o)->swap)(*(::std::vector<std::pair<std::basic_string<char>,double> >*)arg[0]);
}

static  void method_5744( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,double> >*)o)->clear)();
}

static void method_newdel_1081( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,double> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,double> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,double> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,double> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,double> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x173( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<std::basic_string<char>,double>,std::allocator<std::pair<std::basic_string<char>,double> > >")), ::Reflex::BaseOffset< ::std::vector<std::pair<std::basic_string<char>,double> >,::std::_Vector_base<std::pair<std::basic_string<char>,double>,std::allocator<std::pair<std::basic_string<char>,double> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x174( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::pair<std::basic_string<char>,double> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::pair<std::basic_string<char>,double> > >::Generate();
}

//------Dictionary for class vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, double>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, double> > > -------------------------------
void __std__vector_std__pair_std__basic_string_char__double_s__db_datamem(Reflex::Class*);
void __std__vector_std__pair_std__basic_string_char__double_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_std__basic_string_char__double_s__datamem_bld(&__std__vector_std__pair_std__basic_string_char__double_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_std__basic_string_char__double_s__funcmem_bld(&__std__vector_std__pair_std__basic_string_char__double_s__db_funcmem);
void __std__vector_std__pair_std__basic_string_char__double_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,double> >"), typeid(::std::vector<std::pair<std::basic_string<char>,double> >), sizeof(::std::vector<std::pair<std::basic_string<char>,double> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1987, ::Reflex::BaseOffset< ::std::vector<std::pair<std::basic_string<char>,double> >, ::std::_Vector_base<std::pair<std::basic_string<char>,double>,std::allocator<std::pair<std::basic_string<char>,double> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_823, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,double> >::_Alloc_value_type"))
  .AddTypedef(type_1987, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,double> >::_Base"))
  .AddTypedef(type_1360, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,double> >::_Tp_alloc_type"))
  .AddTypedef(type_823, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,double> >::value_type"))
  .AddTypedef(type_5690, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,double> >::pointer"))
  .AddTypedef(type_5692, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,double> >::const_pointer"))
  .AddTypedef(type_5694, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,double> >::reference"))
  .AddTypedef(type_5696, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,double> >::const_reference"))
  .AddTypedef(type_2391, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,double> >::iterator"))
  .AddTypedef(type_2392, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,double> >::const_iterator"))
  .AddTypedef(type_1794, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,double> >::const_reverse_iterator"))
  .AddTypedef(type_1795, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,double> >::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,double> >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,double> >::difference_type"))
  .AddTypedef(type_1360, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,double> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_5705, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20383), Reflex::Literal("vector"), constructor_5706, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_5696, type_20383), Reflex::Literal("vector"), constructor_5707, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20216), Reflex::Literal("vector"), constructor_5708, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_5709, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1081, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x173, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x174, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__pair_std__basic_string_char__double_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, double>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, double> > > -------------------
void __std__vector_std__pair_std__basic_string_char__double_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, double>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, double> > > -------------------
void __std__vector_std__pair_std__basic_string_char__double_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20384, type_20216), Reflex::Literal("operator="), operator_5710, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_5696), Reflex::Literal("assign"), method_5711, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2391), Reflex::Literal("begin"), method_5712, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2392), Reflex::Literal("begin"), method_5713, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2391), Reflex::Literal("end"), method_5714, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2392), Reflex::Literal("end"), method_5715, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_5720, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_5721, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_823), Reflex::Literal("resize"), method_5722, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_5723, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_5724, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_5725, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5694, type_1654), Reflex::Literal("operator[]"), operator_5726, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5696, type_1654), Reflex::Literal("operator[]"), operator_5727, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5694, type_1654), Reflex::Literal("at"), method_5729, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5696, type_1654), Reflex::Literal("at"), method_5730, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5694), Reflex::Literal("front"), method_5731, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5696), Reflex::Literal("front"), method_5732, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5694), Reflex::Literal("back"), method_5733, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5696), Reflex::Literal("back"), method_5734, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5690), Reflex::Literal("data"), method_5735, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5692), Reflex::Literal("data"), method_5736, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_5696), Reflex::Literal("push_back"), method_5737, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_5738, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2391, type_2391, type_5696), Reflex::Literal("insert"), method_5739, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2391, type_1654, type_5696), Reflex::Literal("insert"), method_5740, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2391, type_2391), Reflex::Literal("erase"), method_5741, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2391, type_2391, type_2391), Reflex::Literal("erase"), method_5742, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_20384), Reflex::Literal("swap"), method_5743, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_5744, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool> > > -------------------------------
static void constructor_5770( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,bool> >();
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,bool> >();
}

static void constructor_5771( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,bool> >(*(const ::std::allocator<std::pair<std::basic_string<char>,bool> >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,bool> >(*(const ::std::allocator<std::pair<std::basic_string<char>,bool> >*)arg[0]);
}

static void constructor_5772( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,bool> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,bool> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,bool> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,bool>*)arg[1]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,bool> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,bool>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,bool> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,bool>*)arg[1],
      *(const ::std::allocator<std::pair<std::basic_string<char>,bool> >*)arg[2]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,bool> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<std::basic_string<char>,bool>*)arg[1],
      *(const ::std::allocator<std::pair<std::basic_string<char>,bool> >*)arg[2]);
  }
}

static void constructor_5773( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<std::basic_string<char>,bool> >(*(const ::std::vector<std::pair<std::basic_string<char>,bool> >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<std::basic_string<char>,bool> >(*(const ::std::vector<std::pair<std::basic_string<char>,bool> >*)arg[0]);
}

static void destructor_5774(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->::std::vector<std::pair<std::basic_string<char>,bool> >::~vector)();
}
static  void operator_5775( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->operator=)(*(const ::std::vector<std::pair<std::basic_string<char>,bool> >*)arg[0]);
  else   (((::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->operator=)(*(const ::std::vector<std::pair<std::basic_string<char>,bool> >*)arg[0]);
}

static  void method_5776( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::pair<std::basic_string<char>,bool>*)arg[1]);
}

static  void method_5777( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,bool>*,std::vector<std::pair<std::basic_string<char>,bool> > >)((((::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->begin)());
  else   (((::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->begin)();
}

static  void method_5778( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,bool>*,std::vector<std::pair<std::basic_string<char>,bool> > >)((((const ::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->begin)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->begin)();
}

static  void method_5779( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,bool>*,std::vector<std::pair<std::basic_string<char>,bool> > >)((((::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->end)());
  else   (((::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->end)();
}

static  void method_5780( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<std::basic_string<char>,bool>*,std::vector<std::pair<std::basic_string<char>,bool> > >)((((const ::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->end)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->end)();
}

static  void method_5785( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->size)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->size)();
}

static  void method_5786( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->max_size)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->max_size)();
}

static  void method_5787( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::pair<std::basic_string<char>,bool>*)arg[1]);
  }
}

static  void method_5788( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->capacity)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->capacity)();
}

static  void method_5789( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->empty)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->empty)();
}

static  void method_5790( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_5791( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_5792( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_5794( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5795( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5796( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->front)();
  else   (((::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->front)();
}

static  void method_5797( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->front)();
  else   (((const ::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->front)();
}

static  void method_5798( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->back)();
  else   (((::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->back)();
}

static  void method_5799( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->back)();
  else   (((const ::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->back)();
}

static  void method_5800( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->data)());
  else   (((::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->data)();
}

static  void method_5801( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->data)());
  else   (((const ::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->data)();
}

static  void method_5802( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->push_back)(*(const ::std::pair<std::basic_string<char>,bool>*)arg[0]);
}

static  void method_5803( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->pop_back)();
}

static  void method_5804( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,bool>*,std::vector<std::pair<std::basic_string<char>,bool> > >)((((::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,bool>*,std::vector<std::pair<std::basic_string<char>,bool> > >*)arg[0],
    *(const ::std::pair<std::basic_string<char>,bool>*)arg[1]));
  else   (((::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,bool>*,std::vector<std::pair<std::basic_string<char>,bool> > >*)arg[0],
    *(const ::std::pair<std::basic_string<char>,bool>*)arg[1]);
}

static  void method_5805( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,bool>*,std::vector<std::pair<std::basic_string<char>,bool> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::pair<std::basic_string<char>,bool>*)arg[2]);
}

static  void method_5806( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,bool>*,std::vector<std::pair<std::basic_string<char>,bool> > >)((((::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,bool>*,std::vector<std::pair<std::basic_string<char>,bool> > >*)arg[0]));
  else   (((::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,bool>*,std::vector<std::pair<std::basic_string<char>,bool> > >*)arg[0]);
}

static  void method_5807( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,bool>*,std::vector<std::pair<std::basic_string<char>,bool> > >)((((::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,bool>*,std::vector<std::pair<std::basic_string<char>,bool> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,bool>*,std::vector<std::pair<std::basic_string<char>,bool> > >*)arg[1]));
  else   (((::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,bool>*,std::vector<std::pair<std::basic_string<char>,bool> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<std::basic_string<char>,bool>*,std::vector<std::pair<std::basic_string<char>,bool> > >*)arg[1]);
}

static  void method_5808( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->swap)(*(::std::vector<std::pair<std::basic_string<char>,bool> >*)arg[0]);
}

static  void method_5809( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<std::basic_string<char>,bool> >*)o)->clear)();
}

static void method_newdel_1082( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,bool> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,bool> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,bool> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,bool> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<std::basic_string<char>,bool> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x176( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<std::basic_string<char>,bool>,std::allocator<std::pair<std::basic_string<char>,bool> > >")), ::Reflex::BaseOffset< ::std::vector<std::pair<std::basic_string<char>,bool> >,::std::_Vector_base<std::pair<std::basic_string<char>,bool>,std::allocator<std::pair<std::basic_string<char>,bool> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x177( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::pair<std::basic_string<char>,bool> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::pair<std::basic_string<char>,bool> > >::Generate();
}

//------Dictionary for class vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool> > > -------------------------------
void __std__vector_std__pair_std__basic_string_char__bool_s__db_datamem(Reflex::Class*);
void __std__vector_std__pair_std__basic_string_char__bool_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_std__basic_string_char__bool_s__datamem_bld(&__std__vector_std__pair_std__basic_string_char__bool_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_std__basic_string_char__bool_s__funcmem_bld(&__std__vector_std__pair_std__basic_string_char__bool_s__db_funcmem);
void __std__vector_std__pair_std__basic_string_char__bool_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::pair<std::basic_string<char>,bool> >"), typeid(::std::vector<std::pair<std::basic_string<char>,bool> >), sizeof(::std::vector<std::pair<std::basic_string<char>,bool> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1966, ::Reflex::BaseOffset< ::std::vector<std::pair<std::basic_string<char>,bool> >, ::std::_Vector_base<std::pair<std::basic_string<char>,bool>,std::allocator<std::pair<std::basic_string<char>,bool> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_824, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,bool> >::_Alloc_value_type"))
  .AddTypedef(type_1966, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,bool> >::_Base"))
  .AddTypedef(type_1361, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,bool> >::_Tp_alloc_type"))
  .AddTypedef(type_824, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,bool> >::value_type"))
  .AddTypedef(type_5755, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,bool> >::pointer"))
  .AddTypedef(type_5757, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,bool> >::const_pointer"))
  .AddTypedef(type_5759, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,bool> >::reference"))
  .AddTypedef(type_5761, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,bool> >::const_reference"))
  .AddTypedef(type_2352, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,bool> >::iterator"))
  .AddTypedef(type_2353, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,bool> >::const_iterator"))
  .AddTypedef(type_1746, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,bool> >::const_reverse_iterator"))
  .AddTypedef(type_1747, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,bool> >::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,bool> >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,bool> >::difference_type"))
  .AddTypedef(type_1361, Reflex::Literal("std::vector<std::pair<std::basic_string<char>,bool> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_5770, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20386), Reflex::Literal("vector"), constructor_5771, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_5761, type_20386), Reflex::Literal("vector"), constructor_5772, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20387), Reflex::Literal("vector"), constructor_5773, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_5774, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1082, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x176, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x177, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__pair_std__basic_string_char__bool_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool> > > -------------------
void __std__vector_std__pair_std__basic_string_char__bool_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool>,std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool> > > -------------------
void __std__vector_std__pair_std__basic_string_char__bool_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20388, type_20387), Reflex::Literal("operator="), operator_5775, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_5761), Reflex::Literal("assign"), method_5776, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2352), Reflex::Literal("begin"), method_5777, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2353), Reflex::Literal("begin"), method_5778, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2352), Reflex::Literal("end"), method_5779, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2353), Reflex::Literal("end"), method_5780, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_5785, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_5786, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_824), Reflex::Literal("resize"), method_5787, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_5788, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_5789, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_5790, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5759, type_1654), Reflex::Literal("operator[]"), operator_5791, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5761, type_1654), Reflex::Literal("operator[]"), operator_5792, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5759, type_1654), Reflex::Literal("at"), method_5794, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5761, type_1654), Reflex::Literal("at"), method_5795, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5759), Reflex::Literal("front"), method_5796, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5761), Reflex::Literal("front"), method_5797, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5759), Reflex::Literal("back"), method_5798, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5761), Reflex::Literal("back"), method_5799, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5755), Reflex::Literal("data"), method_5800, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5757), Reflex::Literal("data"), method_5801, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_5761), Reflex::Literal("push_back"), method_5802, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_5803, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2352, type_2352, type_5761), Reflex::Literal("insert"), method_5804, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2352, type_1654, type_5761), Reflex::Literal("insert"), method_5805, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2352, type_2352), Reflex::Literal("erase"), method_5806, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2352, type_2352, type_2352), Reflex::Literal("erase"), method_5807, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_20388), Reflex::Literal("swap"), method_5808, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_5809, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::pair<int, int>,std::allocator<std::pair<int, int> > > -------------------------------
static void constructor_5835( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<int,int> >();
  else ::new(mem) ::std::vector<std::pair<int,int> >();
}

static void constructor_5836( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<int,int> >(*(const ::std::allocator<std::pair<int,int> >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<int,int> >(*(const ::std::allocator<std::pair<int,int> >*)arg[0]);
}

static void constructor_5837( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<int,int> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<int,int> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<int,int> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<int,int>*)arg[1]);
  else ::new(mem) ::std::vector<std::pair<int,int> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<int,int>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<int,int> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<int,int>*)arg[1],
      *(const ::std::allocator<std::pair<int,int> >*)arg[2]);
  else ::new(mem) ::std::vector<std::pair<int,int> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<int,int>*)arg[1],
      *(const ::std::allocator<std::pair<int,int> >*)arg[2]);
  }
}

static void constructor_5838( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<int,int> >(*(const ::std::vector<std::pair<int,int> >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<int,int> >(*(const ::std::vector<std::pair<int,int> >*)arg[0]);
}

static void destructor_5839(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::pair<int,int> >*)o)->::std::vector<std::pair<int,int> >::~vector)();
}
static  void operator_5840( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<int,int> >*)o)->operator=)(*(const ::std::vector<std::pair<int,int> >*)arg[0]);
  else   (((::std::vector<std::pair<int,int> >*)o)->operator=)(*(const ::std::vector<std::pair<int,int> >*)arg[0]);
}

static  void method_5841( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<int,int> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::pair<int,int>*)arg[1]);
}

static  void method_5842( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<int,int>*,std::vector<std::pair<int,int> > >)((((::std::vector<std::pair<int,int> >*)o)->begin)());
  else   (((::std::vector<std::pair<int,int> >*)o)->begin)();
}

static  void method_5843( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<int,int>*,std::vector<std::pair<int,int> > >)((((const ::std::vector<std::pair<int,int> >*)o)->begin)());
  else   (((const ::std::vector<std::pair<int,int> >*)o)->begin)();
}

static  void method_5844( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<int,int>*,std::vector<std::pair<int,int> > >)((((::std::vector<std::pair<int,int> >*)o)->end)());
  else   (((::std::vector<std::pair<int,int> >*)o)->end)();
}

static  void method_5845( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<int,int>*,std::vector<std::pair<int,int> > >)((((const ::std::vector<std::pair<int,int> >*)o)->end)());
  else   (((const ::std::vector<std::pair<int,int> >*)o)->end)();
}

static  void method_5850( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<int,int> >*)o)->size)());
  else   (((const ::std::vector<std::pair<int,int> >*)o)->size)();
}

static  void method_5851( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<int,int> >*)o)->max_size)());
  else   (((const ::std::vector<std::pair<int,int> >*)o)->max_size)();
}

static  void method_5852( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::pair<int,int> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::pair<int,int> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::pair<int,int>*)arg[1]);
  }
}

static  void method_5853( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<int,int> >*)o)->capacity)());
  else   (((const ::std::vector<std::pair<int,int> >*)o)->capacity)();
}

static  void method_5854( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::pair<int,int> >*)o)->empty)());
  else   (((const ::std::vector<std::pair<int,int> >*)o)->empty)();
}

static  void method_5855( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<int,int> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_5856( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<int,int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<int,int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_5857( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<int,int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<int,int> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_5859( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<int,int> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<int,int> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5860( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<int,int> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<int,int> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5861( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<int,int> >*)o)->front)();
  else   (((::std::vector<std::pair<int,int> >*)o)->front)();
}

static  void method_5862( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<int,int> >*)o)->front)();
  else   (((const ::std::vector<std::pair<int,int> >*)o)->front)();
}

static  void method_5863( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<int,int> >*)o)->back)();
  else   (((::std::vector<std::pair<int,int> >*)o)->back)();
}

static  void method_5864( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<int,int> >*)o)->back)();
  else   (((const ::std::vector<std::pair<int,int> >*)o)->back)();
}

static  void method_5865( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::pair<int,int> >*)o)->data)());
  else   (((::std::vector<std::pair<int,int> >*)o)->data)();
}

static  void method_5866( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::pair<int,int> >*)o)->data)());
  else   (((const ::std::vector<std::pair<int,int> >*)o)->data)();
}

static  void method_5867( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<int,int> >*)o)->push_back)(*(const ::std::pair<int,int>*)arg[0]);
}

static  void method_5868( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<int,int> >*)o)->pop_back)();
}

static  void method_5869( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<int,int>*,std::vector<std::pair<int,int> > >)((((::std::vector<std::pair<int,int> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<int,int>*,std::vector<std::pair<int,int> > >*)arg[0],
    *(const ::std::pair<int,int>*)arg[1]));
  else   (((::std::vector<std::pair<int,int> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<int,int>*,std::vector<std::pair<int,int> > >*)arg[0],
    *(const ::std::pair<int,int>*)arg[1]);
}

static  void method_5870( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<int,int> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<int,int>*,std::vector<std::pair<int,int> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::pair<int,int>*)arg[2]);
}

static  void method_5871( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<int,int>*,std::vector<std::pair<int,int> > >)((((::std::vector<std::pair<int,int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<int,int>*,std::vector<std::pair<int,int> > >*)arg[0]));
  else   (((::std::vector<std::pair<int,int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<int,int>*,std::vector<std::pair<int,int> > >*)arg[0]);
}

static  void method_5872( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<int,int>*,std::vector<std::pair<int,int> > >)((((::std::vector<std::pair<int,int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<int,int>*,std::vector<std::pair<int,int> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<int,int>*,std::vector<std::pair<int,int> > >*)arg[1]));
  else   (((::std::vector<std::pair<int,int> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<int,int>*,std::vector<std::pair<int,int> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<int,int>*,std::vector<std::pair<int,int> > >*)arg[1]);
}

static  void method_5873( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<int,int> >*)o)->swap)(*(::std::vector<std::pair<int,int> >*)arg[0]);
}

static  void method_5874( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<int,int> >*)o)->clear)();
}

static void method_newdel_1083( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<int,int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<int,int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<int,int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<int,int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<int,int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x179( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<int,int>,std::allocator<std::pair<int,int> > >")), ::Reflex::BaseOffset< ::std::vector<std::pair<int,int> >,::std::_Vector_base<std::pair<int,int>,std::allocator<std::pair<int,int> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x180( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::pair<int,int> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::pair<int,int> > >::Generate();
}

//------Dictionary for class vector<std::pair<int, int>,std::allocator<std::pair<int, int> > > -------------------------------
void __std__vector_std__pair_int_int_s__db_datamem(Reflex::Class*);
void __std__vector_std__pair_int_int_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_int_int_s__datamem_bld(&__std__vector_std__pair_int_int_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_int_int_s__funcmem_bld(&__std__vector_std__pair_int_int_s__db_funcmem);
void __std__vector_std__pair_int_int_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::pair<int,int> >"), typeid(::std::vector<std::pair<int,int> >), sizeof(::std::vector<std::pair<int,int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1967, ::Reflex::BaseOffset< ::std::vector<std::pair<int,int> >, ::std::_Vector_base<std::pair<int,int>,std::allocator<std::pair<int,int> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_825, Reflex::Literal("std::vector<std::pair<int,int> >::_Alloc_value_type"))
  .AddTypedef(type_1967, Reflex::Literal("std::vector<std::pair<int,int> >::_Base"))
  .AddTypedef(type_1362, Reflex::Literal("std::vector<std::pair<int,int> >::_Tp_alloc_type"))
  .AddTypedef(type_825, Reflex::Literal("std::vector<std::pair<int,int> >::value_type"))
  .AddTypedef(type_5820, Reflex::Literal("std::vector<std::pair<int,int> >::pointer"))
  .AddTypedef(type_5822, Reflex::Literal("std::vector<std::pair<int,int> >::const_pointer"))
  .AddTypedef(type_5824, Reflex::Literal("std::vector<std::pair<int,int> >::reference"))
  .AddTypedef(type_5826, Reflex::Literal("std::vector<std::pair<int,int> >::const_reference"))
  .AddTypedef(type_2354, Reflex::Literal("std::vector<std::pair<int,int> >::iterator"))
  .AddTypedef(type_2355, Reflex::Literal("std::vector<std::pair<int,int> >::const_iterator"))
  .AddTypedef(type_1748, Reflex::Literal("std::vector<std::pair<int,int> >::const_reverse_iterator"))
  .AddTypedef(type_1749, Reflex::Literal("std::vector<std::pair<int,int> >::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<std::pair<int,int> >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<std::pair<int,int> >::difference_type"))
  .AddTypedef(type_1362, Reflex::Literal("std::vector<std::pair<int,int> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_5835, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20389), Reflex::Literal("vector"), constructor_5836, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_5826, type_20389), Reflex::Literal("vector"), constructor_5837, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20390), Reflex::Literal("vector"), constructor_5838, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_5839, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1083, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x179, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x180, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__pair_int_int_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::pair<int, int>,std::allocator<std::pair<int, int> > > -------------------
void __std__vector_std__pair_int_int_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::pair<int, int>,std::allocator<std::pair<int, int> > > -------------------
void __std__vector_std__pair_int_int_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20391, type_20390), Reflex::Literal("operator="), operator_5840, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_5826), Reflex::Literal("assign"), method_5841, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2354), Reflex::Literal("begin"), method_5842, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2355), Reflex::Literal("begin"), method_5843, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2354), Reflex::Literal("end"), method_5844, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2355), Reflex::Literal("end"), method_5845, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_5850, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_5851, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_825), Reflex::Literal("resize"), method_5852, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_5853, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_5854, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_5855, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5824, type_1654), Reflex::Literal("operator[]"), operator_5856, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5826, type_1654), Reflex::Literal("operator[]"), operator_5857, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5824, type_1654), Reflex::Literal("at"), method_5859, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5826, type_1654), Reflex::Literal("at"), method_5860, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5824), Reflex::Literal("front"), method_5861, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5826), Reflex::Literal("front"), method_5862, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5824), Reflex::Literal("back"), method_5863, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5826), Reflex::Literal("back"), method_5864, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5820), Reflex::Literal("data"), method_5865, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5822), Reflex::Literal("data"), method_5866, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_5826), Reflex::Literal("push_back"), method_5867, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_5868, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2354, type_2354, type_5826), Reflex::Literal("insert"), method_5869, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2354, type_1654, type_5826), Reflex::Literal("insert"), method_5870, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2354, type_2354), Reflex::Literal("erase"), method_5871, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2354, type_2354, type_2354), Reflex::Literal("erase"), method_5872, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_20391), Reflex::Literal("swap"), method_5873, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_5874, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::pair<float, float>,std::allocator<std::pair<float, float> > > -------------------------------
static void constructor_5900( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<float,float> >();
  else ::new(mem) ::std::vector<std::pair<float,float> >();
}

static void constructor_5901( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<float,float> >(*(const ::std::allocator<std::pair<float,float> >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<float,float> >(*(const ::std::allocator<std::pair<float,float> >*)arg[0]);
}

static void constructor_5902( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<float,float> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<float,float> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<float,float> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<float,float>*)arg[1]);
  else ::new(mem) ::std::vector<std::pair<float,float> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<float,float>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<float,float> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<float,float>*)arg[1],
      *(const ::std::allocator<std::pair<float,float> >*)arg[2]);
  else ::new(mem) ::std::vector<std::pair<float,float> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<float,float>*)arg[1],
      *(const ::std::allocator<std::pair<float,float> >*)arg[2]);
  }
}

static void constructor_5903( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<float,float> >(*(const ::std::vector<std::pair<float,float> >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<float,float> >(*(const ::std::vector<std::pair<float,float> >*)arg[0]);
}

static void destructor_5904(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::pair<float,float> >*)o)->::std::vector<std::pair<float,float> >::~vector)();
}
static  void operator_5905( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<float,float> >*)o)->operator=)(*(const ::std::vector<std::pair<float,float> >*)arg[0]);
  else   (((::std::vector<std::pair<float,float> >*)o)->operator=)(*(const ::std::vector<std::pair<float,float> >*)arg[0]);
}

static  void method_5906( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<float,float> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::pair<float,float>*)arg[1]);
}

static  void method_5907( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<float,float>*,std::vector<std::pair<float,float> > >)((((::std::vector<std::pair<float,float> >*)o)->begin)());
  else   (((::std::vector<std::pair<float,float> >*)o)->begin)();
}

static  void method_5908( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<float,float>*,std::vector<std::pair<float,float> > >)((((const ::std::vector<std::pair<float,float> >*)o)->begin)());
  else   (((const ::std::vector<std::pair<float,float> >*)o)->begin)();
}

static  void method_5909( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<float,float>*,std::vector<std::pair<float,float> > >)((((::std::vector<std::pair<float,float> >*)o)->end)());
  else   (((::std::vector<std::pair<float,float> >*)o)->end)();
}

static  void method_5910( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<float,float>*,std::vector<std::pair<float,float> > >)((((const ::std::vector<std::pair<float,float> >*)o)->end)());
  else   (((const ::std::vector<std::pair<float,float> >*)o)->end)();
}

static  void method_5915( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<float,float> >*)o)->size)());
  else   (((const ::std::vector<std::pair<float,float> >*)o)->size)();
}

static  void method_5916( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<float,float> >*)o)->max_size)());
  else   (((const ::std::vector<std::pair<float,float> >*)o)->max_size)();
}

static  void method_5917( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::pair<float,float> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::pair<float,float> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::pair<float,float>*)arg[1]);
  }
}

static  void method_5918( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<float,float> >*)o)->capacity)());
  else   (((const ::std::vector<std::pair<float,float> >*)o)->capacity)();
}

static  void method_5919( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::pair<float,float> >*)o)->empty)());
  else   (((const ::std::vector<std::pair<float,float> >*)o)->empty)();
}

static  void method_5920( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<float,float> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_5921( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<float,float> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<float,float> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_5922( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<float,float> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<float,float> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_5924( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<float,float> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<float,float> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5925( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<float,float> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<float,float> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5926( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<float,float> >*)o)->front)();
  else   (((::std::vector<std::pair<float,float> >*)o)->front)();
}

static  void method_5927( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<float,float> >*)o)->front)();
  else   (((const ::std::vector<std::pair<float,float> >*)o)->front)();
}

static  void method_5928( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<float,float> >*)o)->back)();
  else   (((::std::vector<std::pair<float,float> >*)o)->back)();
}

static  void method_5929( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<float,float> >*)o)->back)();
  else   (((const ::std::vector<std::pair<float,float> >*)o)->back)();
}

static  void method_5930( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::pair<float,float> >*)o)->data)());
  else   (((::std::vector<std::pair<float,float> >*)o)->data)();
}

static  void method_5931( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::pair<float,float> >*)o)->data)());
  else   (((const ::std::vector<std::pair<float,float> >*)o)->data)();
}

static  void method_5932( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<float,float> >*)o)->push_back)(*(const ::std::pair<float,float>*)arg[0]);
}

static  void method_5933( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<float,float> >*)o)->pop_back)();
}

static  void method_5934( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<float,float>*,std::vector<std::pair<float,float> > >)((((::std::vector<std::pair<float,float> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<float,float>*,std::vector<std::pair<float,float> > >*)arg[0],
    *(const ::std::pair<float,float>*)arg[1]));
  else   (((::std::vector<std::pair<float,float> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<float,float>*,std::vector<std::pair<float,float> > >*)arg[0],
    *(const ::std::pair<float,float>*)arg[1]);
}

static  void method_5935( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<float,float> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<float,float>*,std::vector<std::pair<float,float> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::pair<float,float>*)arg[2]);
}

static  void method_5936( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<float,float>*,std::vector<std::pair<float,float> > >)((((::std::vector<std::pair<float,float> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<float,float>*,std::vector<std::pair<float,float> > >*)arg[0]));
  else   (((::std::vector<std::pair<float,float> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<float,float>*,std::vector<std::pair<float,float> > >*)arg[0]);
}

static  void method_5937( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<float,float>*,std::vector<std::pair<float,float> > >)((((::std::vector<std::pair<float,float> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<float,float>*,std::vector<std::pair<float,float> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<float,float>*,std::vector<std::pair<float,float> > >*)arg[1]));
  else   (((::std::vector<std::pair<float,float> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<float,float>*,std::vector<std::pair<float,float> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<float,float>*,std::vector<std::pair<float,float> > >*)arg[1]);
}

static  void method_5938( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<float,float> >*)o)->swap)(*(::std::vector<std::pair<float,float> >*)arg[0]);
}

static  void method_5939( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<float,float> >*)o)->clear)();
}

static void method_newdel_1084( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<float,float> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<float,float> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<float,float> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<float,float> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<float,float> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x182( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<float,float>,std::allocator<std::pair<float,float> > >")), ::Reflex::BaseOffset< ::std::vector<std::pair<float,float> >,::std::_Vector_base<std::pair<float,float>,std::allocator<std::pair<float,float> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x183( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::pair<float,float> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::pair<float,float> > >::Generate();
}

//------Dictionary for class vector<std::pair<float, float>,std::allocator<std::pair<float, float> > > -------------------------------
void __std__vector_std__pair_float_float_s__db_datamem(Reflex::Class*);
void __std__vector_std__pair_float_float_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_float_float_s__datamem_bld(&__std__vector_std__pair_float_float_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_float_float_s__funcmem_bld(&__std__vector_std__pair_float_float_s__db_funcmem);
void __std__vector_std__pair_float_float_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::pair<float,float> >"), typeid(::std::vector<std::pair<float,float> >), sizeof(::std::vector<std::pair<float,float> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1969, ::Reflex::BaseOffset< ::std::vector<std::pair<float,float> >, ::std::_Vector_base<std::pair<float,float>,std::allocator<std::pair<float,float> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_826, Reflex::Literal("std::vector<std::pair<float,float> >::_Alloc_value_type"))
  .AddTypedef(type_1969, Reflex::Literal("std::vector<std::pair<float,float> >::_Base"))
  .AddTypedef(type_1363, Reflex::Literal("std::vector<std::pair<float,float> >::_Tp_alloc_type"))
  .AddTypedef(type_826, Reflex::Literal("std::vector<std::pair<float,float> >::value_type"))
  .AddTypedef(type_5885, Reflex::Literal("std::vector<std::pair<float,float> >::pointer"))
  .AddTypedef(type_5887, Reflex::Literal("std::vector<std::pair<float,float> >::const_pointer"))
  .AddTypedef(type_5889, Reflex::Literal("std::vector<std::pair<float,float> >::reference"))
  .AddTypedef(type_5891, Reflex::Literal("std::vector<std::pair<float,float> >::const_reference"))
  .AddTypedef(type_2358, Reflex::Literal("std::vector<std::pair<float,float> >::iterator"))
  .AddTypedef(type_2359, Reflex::Literal("std::vector<std::pair<float,float> >::const_iterator"))
  .AddTypedef(type_1752, Reflex::Literal("std::vector<std::pair<float,float> >::const_reverse_iterator"))
  .AddTypedef(type_1753, Reflex::Literal("std::vector<std::pair<float,float> >::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<std::pair<float,float> >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<std::pair<float,float> >::difference_type"))
  .AddTypedef(type_1363, Reflex::Literal("std::vector<std::pair<float,float> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_5900, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20393), Reflex::Literal("vector"), constructor_5901, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_5891, type_20393), Reflex::Literal("vector"), constructor_5902, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20394), Reflex::Literal("vector"), constructor_5903, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_5904, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1084, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x182, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x183, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__pair_float_float_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::pair<float, float>,std::allocator<std::pair<float, float> > > -------------------
void __std__vector_std__pair_float_float_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::pair<float, float>,std::allocator<std::pair<float, float> > > -------------------
void __std__vector_std__pair_float_float_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20395, type_20394), Reflex::Literal("operator="), operator_5905, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_5891), Reflex::Literal("assign"), method_5906, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2358), Reflex::Literal("begin"), method_5907, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2359), Reflex::Literal("begin"), method_5908, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2358), Reflex::Literal("end"), method_5909, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2359), Reflex::Literal("end"), method_5910, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_5915, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_5916, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_826), Reflex::Literal("resize"), method_5917, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_5918, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_5919, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_5920, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5889, type_1654), Reflex::Literal("operator[]"), operator_5921, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5891, type_1654), Reflex::Literal("operator[]"), operator_5922, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5889, type_1654), Reflex::Literal("at"), method_5924, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5891, type_1654), Reflex::Literal("at"), method_5925, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5889), Reflex::Literal("front"), method_5926, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5891), Reflex::Literal("front"), method_5927, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5889), Reflex::Literal("back"), method_5928, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5891), Reflex::Literal("back"), method_5929, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5885), Reflex::Literal("data"), method_5930, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5887), Reflex::Literal("data"), method_5931, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_5891), Reflex::Literal("push_back"), method_5932, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_5933, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2358, type_2358, type_5891), Reflex::Literal("insert"), method_5934, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2358, type_1654, type_5891), Reflex::Literal("insert"), method_5935, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2358, type_2358), Reflex::Literal("erase"), method_5936, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2358, type_2358, type_2358), Reflex::Literal("erase"), method_5937, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_20395), Reflex::Literal("swap"), method_5938, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_5939, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<std::pair<double, double>,std::allocator<std::pair<double, double> > > -------------------------------
static void constructor_5965( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<double,double> >();
  else ::new(mem) ::std::vector<std::pair<double,double> >();
}

static void constructor_5966( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<double,double> >(*(const ::std::allocator<std::pair<double,double> >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<double,double> >(*(const ::std::allocator<std::pair<double,double> >*)arg[0]);
}

static void constructor_5967( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<double,double> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<double,double> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<double,double> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<double,double>*)arg[1]);
  else ::new(mem) ::std::vector<std::pair<double,double> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<double,double>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<double,double> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<double,double>*)arg[1],
      *(const ::std::allocator<std::pair<double,double> >*)arg[2]);
  else ::new(mem) ::std::vector<std::pair<double,double> >(*(::std::size_t*)arg[0],
      *(const ::std::pair<double,double>*)arg[1],
      *(const ::std::allocator<std::pair<double,double> >*)arg[2]);
  }
}

static void constructor_5968( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::pair<double,double> >(*(const ::std::vector<std::pair<double,double> >*)arg[0]);
  else ::new(mem) ::std::vector<std::pair<double,double> >(*(const ::std::vector<std::pair<double,double> >*)arg[0]);
}

static void destructor_5969(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::pair<double,double> >*)o)->::std::vector<std::pair<double,double> >::~vector)();
}
static  void operator_5970( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<double,double> >*)o)->operator=)(*(const ::std::vector<std::pair<double,double> >*)arg[0]);
  else   (((::std::vector<std::pair<double,double> >*)o)->operator=)(*(const ::std::vector<std::pair<double,double> >*)arg[0]);
}

static  void method_5971( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<double,double> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::pair<double,double>*)arg[1]);
}

static  void method_5972( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<double,double>*,std::vector<std::pair<double,double> > >)((((::std::vector<std::pair<double,double> >*)o)->begin)());
  else   (((::std::vector<std::pair<double,double> >*)o)->begin)();
}

static  void method_5973( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<double,double>*,std::vector<std::pair<double,double> > >)((((const ::std::vector<std::pair<double,double> >*)o)->begin)());
  else   (((const ::std::vector<std::pair<double,double> >*)o)->begin)();
}

static  void method_5974( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<double,double>*,std::vector<std::pair<double,double> > >)((((::std::vector<std::pair<double,double> >*)o)->end)());
  else   (((::std::vector<std::pair<double,double> >*)o)->end)();
}

static  void method_5975( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::pair<double,double>*,std::vector<std::pair<double,double> > >)((((const ::std::vector<std::pair<double,double> >*)o)->end)());
  else   (((const ::std::vector<std::pair<double,double> >*)o)->end)();
}

static  void method_5980( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<double,double> >*)o)->size)());
  else   (((const ::std::vector<std::pair<double,double> >*)o)->size)();
}

static  void method_5981( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<double,double> >*)o)->max_size)());
  else   (((const ::std::vector<std::pair<double,double> >*)o)->max_size)();
}

static  void method_5982( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::pair<double,double> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::pair<double,double> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::pair<double,double>*)arg[1]);
  }
}

static  void method_5983( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::pair<double,double> >*)o)->capacity)());
  else   (((const ::std::vector<std::pair<double,double> >*)o)->capacity)();
}

static  void method_5984( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::pair<double,double> >*)o)->empty)());
  else   (((const ::std::vector<std::pair<double,double> >*)o)->empty)();
}

static  void method_5985( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<double,double> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_5986( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<double,double> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<double,double> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_5987( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<double,double> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<double,double> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_5989( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<double,double> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::pair<double,double> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5990( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<double,double> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::pair<double,double> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_5991( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<double,double> >*)o)->front)();
  else   (((::std::vector<std::pair<double,double> >*)o)->front)();
}

static  void method_5992( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<double,double> >*)o)->front)();
  else   (((const ::std::vector<std::pair<double,double> >*)o)->front)();
}

static  void method_5993( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::pair<double,double> >*)o)->back)();
  else   (((::std::vector<std::pair<double,double> >*)o)->back)();
}

static  void method_5994( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::pair<double,double> >*)o)->back)();
  else   (((const ::std::vector<std::pair<double,double> >*)o)->back)();
}

static  void method_5995( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::pair<double,double> >*)o)->data)());
  else   (((::std::vector<std::pair<double,double> >*)o)->data)();
}

static  void method_5996( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::pair<double,double> >*)o)->data)());
  else   (((const ::std::vector<std::pair<double,double> >*)o)->data)();
}

static  void method_5997( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<double,double> >*)o)->push_back)(*(const ::std::pair<double,double>*)arg[0]);
}

static  void method_5998( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<double,double> >*)o)->pop_back)();
}

static  void method_5999( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<double,double>*,std::vector<std::pair<double,double> > >)((((::std::vector<std::pair<double,double> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<double,double>*,std::vector<std::pair<double,double> > >*)arg[0],
    *(const ::std::pair<double,double>*)arg[1]));
  else   (((::std::vector<std::pair<double,double> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<double,double>*,std::vector<std::pair<double,double> > >*)arg[0],
    *(const ::std::pair<double,double>*)arg[1]);
}

static  void method_6000( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<double,double> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::pair<double,double>*,std::vector<std::pair<double,double> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::pair<double,double>*)arg[2]);
}

static  void method_6001( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<double,double>*,std::vector<std::pair<double,double> > >)((((::std::vector<std::pair<double,double> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<double,double>*,std::vector<std::pair<double,double> > >*)arg[0]));
  else   (((::std::vector<std::pair<double,double> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<double,double>*,std::vector<std::pair<double,double> > >*)arg[0]);
}

static  void method_6002( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::pair<double,double>*,std::vector<std::pair<double,double> > >)((((::std::vector<std::pair<double,double> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<double,double>*,std::vector<std::pair<double,double> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<double,double>*,std::vector<std::pair<double,double> > >*)arg[1]));
  else   (((::std::vector<std::pair<double,double> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::pair<double,double>*,std::vector<std::pair<double,double> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::pair<double,double>*,std::vector<std::pair<double,double> > >*)arg[1]);
}

static  void method_6003( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::pair<double,double> >*)o)->swap)(*(::std::vector<std::pair<double,double> >*)arg[0]);
}

static  void method_6004( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::pair<double,double> >*)o)->clear)();
}

static void method_newdel_1085( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<double,double> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<double,double> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<double,double> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<double,double> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::pair<double,double> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x185( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::pair<double,double>,std::allocator<std::pair<double,double> > >")), ::Reflex::BaseOffset< ::std::vector<std::pair<double,double> >,::std::_Vector_base<std::pair<double,double>,std::allocator<std::pair<double,double> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x186( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::pair<double,double> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::pair<double,double> > >::Generate();
}

//------Dictionary for class vector<std::pair<double, double>,std::allocator<std::pair<double, double> > > -------------------------------
void __std__vector_std__pair_double_double_s__db_datamem(Reflex::Class*);
void __std__vector_std__pair_double_double_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_double_double_s__datamem_bld(&__std__vector_std__pair_double_double_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__pair_double_double_s__funcmem_bld(&__std__vector_std__pair_double_double_s__db_funcmem);
void __std__vector_std__pair_double_double_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::pair<double,double> >"), typeid(::std::vector<std::pair<double,double> >), sizeof(::std::vector<std::pair<double,double> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1970, ::Reflex::BaseOffset< ::std::vector<std::pair<double,double> >, ::std::_Vector_base<std::pair<double,double>,std::allocator<std::pair<double,double> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_827, Reflex::Literal("std::vector<std::pair<double,double> >::_Alloc_value_type"))
  .AddTypedef(type_1970, Reflex::Literal("std::vector<std::pair<double,double> >::_Base"))
  .AddTypedef(type_1364, Reflex::Literal("std::vector<std::pair<double,double> >::_Tp_alloc_type"))
  .AddTypedef(type_827, Reflex::Literal("std::vector<std::pair<double,double> >::value_type"))
  .AddTypedef(type_5950, Reflex::Literal("std::vector<std::pair<double,double> >::pointer"))
  .AddTypedef(type_5952, Reflex::Literal("std::vector<std::pair<double,double> >::const_pointer"))
  .AddTypedef(type_5954, Reflex::Literal("std::vector<std::pair<double,double> >::reference"))
  .AddTypedef(type_5956, Reflex::Literal("std::vector<std::pair<double,double> >::const_reference"))
  .AddTypedef(type_2360, Reflex::Literal("std::vector<std::pair<double,double> >::iterator"))
  .AddTypedef(type_2361, Reflex::Literal("std::vector<std::pair<double,double> >::const_iterator"))
  .AddTypedef(type_1754, Reflex::Literal("std::vector<std::pair<double,double> >::const_reverse_iterator"))
  .AddTypedef(type_1755, Reflex::Literal("std::vector<std::pair<double,double> >::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<std::pair<double,double> >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<std::pair<double,double> >::difference_type"))
  .AddTypedef(type_1364, Reflex::Literal("std::vector<std::pair<double,double> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_5965, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20397), Reflex::Literal("vector"), constructor_5966, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_5956, type_20397), Reflex::Literal("vector"), constructor_5967, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20398), Reflex::Literal("vector"), constructor_5968, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_5969, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1085, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x185, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x186, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__pair_double_double_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::pair<double, double>,std::allocator<std::pair<double, double> > > -------------------
void __std__vector_std__pair_double_double_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::pair<double, double>,std::allocator<std::pair<double, double> > > -------------------
void __std__vector_std__pair_double_double_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20399, type_20398), Reflex::Literal("operator="), operator_5970, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_5956), Reflex::Literal("assign"), method_5971, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2360), Reflex::Literal("begin"), method_5972, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2361), Reflex::Literal("begin"), method_5973, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2360), Reflex::Literal("end"), method_5974, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2361), Reflex::Literal("end"), method_5975, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_5980, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_5981, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_827), Reflex::Literal("resize"), method_5982, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_5983, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_5984, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_5985, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5954, type_1654), Reflex::Literal("operator[]"), operator_5986, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5956, type_1654), Reflex::Literal("operator[]"), operator_5987, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5954, type_1654), Reflex::Literal("at"), method_5989, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5956, type_1654), Reflex::Literal("at"), method_5990, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5954), Reflex::Literal("front"), method_5991, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5956), Reflex::Literal("front"), method_5992, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5954), Reflex::Literal("back"), method_5993, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5956), Reflex::Literal("back"), method_5994, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5950), Reflex::Literal("data"), method_5995, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5952), Reflex::Literal("data"), method_5996, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_5956), Reflex::Literal("push_back"), method_5997, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_5998, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2360, type_2360, type_5956), Reflex::Literal("insert"), method_5999, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2360, type_1654, type_5956), Reflex::Literal("insert"), method_6000, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2360, type_2360), Reflex::Literal("erase"), method_6001, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2360, type_2360, type_2360), Reflex::Literal("erase"), method_6002, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_20399), Reflex::Literal("swap"), method_6003, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_6004, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class map<short int,short int,std::less<short int>,std::allocator<std::pair<const short int, short int> > > -------------------------------
static void destructor_13772(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<short,short>*)o)->::std::map<short,short>::~map)();
}
static void constructor_13773( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<short,short>();
  else ::new(mem) ::std::map<short,short>();
}

static void constructor_13774( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<short,short>(*(const ::std::less<short>*)arg[0]);
  else ::new(mem) ::std::map<short,short>(*(const ::std::less<short>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<short,short>(*(const ::std::less<short>*)arg[0],
      *(const ::std::allocator<std::pair<const short,short> >*)arg[1]);
  else ::new(mem) ::std::map<short,short>(*(const ::std::less<short>*)arg[0],
      *(const ::std::allocator<std::pair<const short,short> >*)arg[1]);
  }
}

static void constructor_13775( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<short,short>(*(const ::std::map<short,short>*)arg[0]);
  else ::new(mem) ::std::map<short,short>(*(const ::std::map<short,short>*)arg[0]);
}

static  void operator_13776( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<short,short>*)o)->operator=)(*(const ::std::map<short,short>*)arg[0]);
  else   (((::std::map<short,short>*)o)->operator=)(*(const ::std::map<short,short>*)arg[0]);
}

static  void method_13777( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const short,short> >)((((const ::std::map<short,short>*)o)->get_allocator)());
  else   (((const ::std::map<short,short>*)o)->get_allocator)();
}

static  void method_13778( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const short,short> >)((((::std::map<short,short>*)o)->begin)());
  else   (((::std::map<short,short>*)o)->begin)();
}

static  void method_13779( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const short,short> >)((((const ::std::map<short,short>*)o)->begin)());
  else   (((const ::std::map<short,short>*)o)->begin)();
}

static  void method_13780( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const short,short> >)((((::std::map<short,short>*)o)->end)());
  else   (((::std::map<short,short>*)o)->end)();
}

static  void method_13781( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const short,short> >)((((const ::std::map<short,short>*)o)->end)());
  else   (((const ::std::map<short,short>*)o)->end)();
}

static  void method_13786( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<short,short>*)o)->empty)());
  else   (((const ::std::map<short,short>*)o)->empty)();
}

static  void method_13787( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<short,short>*)o)->size)());
  else   (((const ::std::map<short,short>*)o)->size)();
}

static  void method_13788( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<short,short>*)o)->max_size)());
  else   (((const ::std::map<short,short>*)o)->max_size)();
}

static  void operator_13789( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<short,short>*)o)->operator[])(*(const short*)arg[0]);
  else   (((::std::map<short,short>*)o)->operator[])(*(const short*)arg[0]);
}

static  void method_13790( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<short,short>*)o)->at)(*(const short*)arg[0]);
  else   (((::std::map<short,short>*)o)->at)(*(const short*)arg[0]);
}

static  void method_13791( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<short,short>*)o)->at)(*(const short*)arg[0]);
  else   (((const ::std::map<short,short>*)o)->at)(*(const short*)arg[0]);
}

static  void method_13792( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const short,short> >,bool>)((((::std::map<short,short>*)o)->insert)(*(const ::std::pair<const short,short>*)arg[0]));
  else   (((::std::map<short,short>*)o)->insert)(*(const ::std::pair<const short,short>*)arg[0]);
}

static  void method_13793( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const short,short> >)((((::std::map<short,short>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const short,short> >*)arg[0],
    *(const ::std::pair<const short,short>*)arg[1]));
  else   (((::std::map<short,short>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const short,short> >*)arg[0],
    *(const ::std::pair<const short,short>*)arg[1]);
}

static  void method_13794( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<short,short>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const short,short> >*)arg[0]);
}

static  void method_13795( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<short,short>*)o)->erase)(*(const short*)arg[0]));
  else   (((::std::map<short,short>*)o)->erase)(*(const short*)arg[0]);
}

static  void method_13796( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<short,short>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const short,short> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const short,short> >*)arg[1]);
}

static  void method_13797( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<short,short>*)o)->swap)(*(::std::map<short,short>*)arg[0]);
}

static  void method_13798( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<short,short>*)o)->clear)();
}

static  void method_13799( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<short>)((((const ::std::map<short,short>*)o)->key_comp)());
  else   (((const ::std::map<short,short>*)o)->key_comp)();
}

static  void method_13801( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const short,short> >)((((::std::map<short,short>*)o)->find)(*(const short*)arg[0]));
  else   (((::std::map<short,short>*)o)->find)(*(const short*)arg[0]);
}

static  void method_13802( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const short,short> >)((((const ::std::map<short,short>*)o)->find)(*(const short*)arg[0]));
  else   (((const ::std::map<short,short>*)o)->find)(*(const short*)arg[0]);
}

static  void method_13803( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<short,short>*)o)->count)(*(const short*)arg[0]));
  else   (((const ::std::map<short,short>*)o)->count)(*(const short*)arg[0]);
}

static  void method_13804( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const short,short> >)((((::std::map<short,short>*)o)->lower_bound)(*(const short*)arg[0]));
  else   (((::std::map<short,short>*)o)->lower_bound)(*(const short*)arg[0]);
}

static  void method_13805( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const short,short> >)((((const ::std::map<short,short>*)o)->lower_bound)(*(const short*)arg[0]));
  else   (((const ::std::map<short,short>*)o)->lower_bound)(*(const short*)arg[0]);
}

static  void method_13806( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const short,short> >)((((::std::map<short,short>*)o)->upper_bound)(*(const short*)arg[0]));
  else   (((::std::map<short,short>*)o)->upper_bound)(*(const short*)arg[0]);
}

static  void method_13807( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const short,short> >)((((const ::std::map<short,short>*)o)->upper_bound)(*(const short*)arg[0]));
  else   (((const ::std::map<short,short>*)o)->upper_bound)(*(const short*)arg[0]);
}

static  void method_13808( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const short,short> >,std::_Rb_tree_iterator<std::pair<const short,short> > >)((((::std::map<short,short>*)o)->equal_range)(*(const short*)arg[0]));
  else   (((::std::map<short,short>*)o)->equal_range)(*(const short*)arg[0]);
}

static  void method_13809( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const short,short> >,std::_Rb_tree_const_iterator<std::pair<const short,short> > >)((((const ::std::map<short,short>*)o)->equal_range)(*(const short*)arg[0]));
  else   (((const ::std::map<short,short>*)o)->equal_range)(*(const short*)arg[0]);
}

static void method_newdel_1614( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<short,short> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<short,short> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<short,short> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<short,short> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<short,short> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x188( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<short,short> >::Generate();
  else ::Reflex::Proxy< ::std::map<short,short> >::Generate();
}

//------Dictionary for class map<short int,short int,std::less<short int>,std::allocator<std::pair<const short int, short int> > > -------------------------------
void __std__map_short_short__db_datamem(Reflex::Class*);
void __std__map_short_short__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_short_short__datamem_bld(&__std__map_short_short__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_short_short__funcmem_bld(&__std__map_short_short__db_funcmem);
void __std__map_short_short__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<short,short>"), typeid(::std::map<short,short>), sizeof(::std::map<short,short>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_113, Reflex::Literal("std::map<short,short>::key_type"))
  .AddTypedef(type_113, Reflex::Literal("std::map<short,short>::mapped_type"))
  .AddTypedef(type_828, Reflex::Literal("std::map<short,short>::value_type"))
  .AddTypedef(type_2022, Reflex::Literal("std::map<short,short>::key_compare"))
  .AddTypedef(type_1366, Reflex::Literal("std::map<short,short>::allocator_type"))
  .AddTypedef(type_828, Reflex::Literal("std::map<short,short>::_Alloc_value_type"))
  .AddTypedef(type_1366, Reflex::Literal("std::map<short,short>::_Pair_alloc_type"))
  .AddTypedef(type_1145, Reflex::Literal("std::map<short,short>::_Rep_type"))
  .AddTypedef(type_10194, Reflex::Literal("std::map<short,short>::pointer"))
  .AddTypedef(type_10196, Reflex::Literal("std::map<short,short>::const_pointer"))
  .AddTypedef(type_10198, Reflex::Literal("std::map<short,short>::reference"))
  .AddTypedef(type_10200, Reflex::Literal("std::map<short,short>::const_reference"))
  .AddTypedef(type_1281, Reflex::Literal("std::map<short,short>::iterator"))
  .AddTypedef(type_1923, Reflex::Literal("std::map<short,short>::const_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::map<short,short>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::map<short,short>::difference_type"))
  .AddTypedef(type_1863, Reflex::Literal("std::map<short,short>::reverse_iterator"))
  .AddTypedef(type_1862, Reflex::Literal("std::map<short,short>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_13772, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_13773, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20709, type_20717), Reflex::Literal("map"), constructor_13774, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6021), Reflex::Literal("map"), constructor_13775, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1614, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x188, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_short_short__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_short_short__funcmem_bld);
}

//------Delayed data member builder for class map<short int,short int,std::less<short int>,std::allocator<std::pair<const short int, short int> > > -------------------
void __std__map_short_short__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1145, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_short_short_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<short int,short int,std::less<short int>,std::allocator<std::pair<const short int, short int> > > -------------------
void __std__map_short_short__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6019, type_6021), Reflex::Literal("operator="), operator_13776, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1366), Reflex::Literal("get_allocator"), method_13777, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1281), Reflex::Literal("begin"), method_13778, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1923), Reflex::Literal("begin"), method_13779, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1281), Reflex::Literal("end"), method_13780, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1923), Reflex::Literal("end"), method_13781, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_13786, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_13787, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_13788, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3527, type_4662), Reflex::Literal("operator[]"), operator_13789, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3527, type_4662), Reflex::Literal("at"), method_13790, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4662, type_4662), Reflex::Literal("at"), method_13791, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_999, type_10200), Reflex::Literal("insert"), method_13792, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1281, type_1281, type_10200), Reflex::Literal("insert"), method_13793, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1281), Reflex::Literal("erase"), method_13794, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4662), Reflex::Literal("erase"), method_13795, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1281, type_1281), Reflex::Literal("erase"), method_13796, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_6019), Reflex::Literal("swap"), method_13797, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_13798, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2022), Reflex::Literal("key_comp"), method_13799, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1281, type_4662), Reflex::Literal("find"), method_13801, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1923, type_4662), Reflex::Literal("find"), method_13802, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4662), Reflex::Literal("count"), method_13803, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1281, type_4662), Reflex::Literal("lower_bound"), method_13804, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1923, type_4662), Reflex::Literal("lower_bound"), method_13805, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1281, type_4662), Reflex::Literal("upper_bound"), method_13806, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1923, type_4662), Reflex::Literal("upper_bound"), method_13807, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_998, type_4662), Reflex::Literal("equal_range"), method_13808, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_997, type_4662), Reflex::Literal("equal_range"), method_13809, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class vector<std::map<short int, short int, std::less<short int>, std::allocator<std::pair<const short int, short int> > >,std::allocator<std::map<short int, short int, std::less<short int>, std::allocator<std::pair<const short int, short int> > > > > -------------------------------
static void constructor_6030( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::map<short,short> >();
  else ::new(mem) ::std::vector<std::map<short,short> >();
}

static void constructor_6031( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::map<short,short> >(*(const ::std::allocator<std::map<short,short> >*)arg[0]);
  else ::new(mem) ::std::vector<std::map<short,short> >(*(const ::std::allocator<std::map<short,short> >*)arg[0]);
}

static void constructor_6032( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::map<short,short> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<std::map<short,short> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::map<short,short> >(*(::std::size_t*)arg[0],
      *(const ::std::map<short,short>*)arg[1]);
  else ::new(mem) ::std::vector<std::map<short,short> >(*(::std::size_t*)arg[0],
      *(const ::std::map<short,short>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::map<short,short> >(*(::std::size_t*)arg[0],
      *(const ::std::map<short,short>*)arg[1],
      *(const ::std::allocator<std::map<short,short> >*)arg[2]);
  else ::new(mem) ::std::vector<std::map<short,short> >(*(::std::size_t*)arg[0],
      *(const ::std::map<short,short>*)arg[1],
      *(const ::std::allocator<std::map<short,short> >*)arg[2]);
  }
}

static void constructor_6033( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<std::map<short,short> >(*(const ::std::vector<std::map<short,short> >*)arg[0]);
  else ::new(mem) ::std::vector<std::map<short,short> >(*(const ::std::vector<std::map<short,short> >*)arg[0]);
}

static void destructor_6034(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<std::map<short,short> >*)o)->::std::vector<std::map<short,short> >::~vector)();
}
static  void operator_6035( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::map<short,short> >*)o)->operator=)(*(const ::std::vector<std::map<short,short> >*)arg[0]);
  else   (((::std::vector<std::map<short,short> >*)o)->operator=)(*(const ::std::vector<std::map<short,short> >*)arg[0]);
}

static  void method_6036( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::map<short,short> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::std::map<short,short>*)arg[1]);
}

static  void method_6037( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::map<short,short>*,std::vector<std::map<short,short> > >)((((::std::vector<std::map<short,short> >*)o)->begin)());
  else   (((::std::vector<std::map<short,short> >*)o)->begin)();
}

static  void method_6038( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::map<short,short>*,std::vector<std::map<short,short> > >)((((const ::std::vector<std::map<short,short> >*)o)->begin)());
  else   (((const ::std::vector<std::map<short,short> >*)o)->begin)();
}

static  void method_6039( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::map<short,short>*,std::vector<std::map<short,short> > >)((((::std::vector<std::map<short,short> >*)o)->end)());
  else   (((::std::vector<std::map<short,short> >*)o)->end)();
}

static  void method_6040( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const std::map<short,short>*,std::vector<std::map<short,short> > >)((((const ::std::vector<std::map<short,short> >*)o)->end)());
  else   (((const ::std::vector<std::map<short,short> >*)o)->end)();
}

static  void method_6045( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::map<short,short> >*)o)->size)());
  else   (((const ::std::vector<std::map<short,short> >*)o)->size)();
}

static  void method_6046( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::map<short,short> >*)o)->max_size)());
  else   (((const ::std::vector<std::map<short,short> >*)o)->max_size)();
}

static  void method_6047( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<std::map<short,short> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<std::map<short,short> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::std::map<short,short>*)arg[1]);
  }
}

static  void method_6048( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<std::map<short,short> >*)o)->capacity)());
  else   (((const ::std::vector<std::map<short,short> >*)o)->capacity)();
}

static  void method_6049( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<std::map<short,short> >*)o)->empty)());
  else   (((const ::std::vector<std::map<short,short> >*)o)->empty)();
}

static  void method_6050( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::map<short,short> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_6051( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::map<short,short> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::map<short,short> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_6052( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::map<short,short> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::map<short,short> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_6054( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::map<short,short> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<std::map<short,short> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6055( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::map<short,short> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<std::map<short,short> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6056( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::map<short,short> >*)o)->front)();
  else   (((::std::vector<std::map<short,short> >*)o)->front)();
}

static  void method_6057( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::map<short,short> >*)o)->front)();
  else   (((const ::std::vector<std::map<short,short> >*)o)->front)();
}

static  void method_6058( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<std::map<short,short> >*)o)->back)();
  else   (((::std::vector<std::map<short,short> >*)o)->back)();
}

static  void method_6059( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<std::map<short,short> >*)o)->back)();
  else   (((const ::std::vector<std::map<short,short> >*)o)->back)();
}

static  void method_6060( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<std::map<short,short> >*)o)->data)());
  else   (((::std::vector<std::map<short,short> >*)o)->data)();
}

static  void method_6061( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<std::map<short,short> >*)o)->data)());
  else   (((const ::std::vector<std::map<short,short> >*)o)->data)();
}

static  void method_6062( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::map<short,short> >*)o)->push_back)(*(const ::std::map<short,short>*)arg[0]);
}

static  void method_6063( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::map<short,short> >*)o)->pop_back)();
}

static  void method_6064( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::map<short,short>*,std::vector<std::map<short,short> > >)((((::std::vector<std::map<short,short> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::map<short,short>*,std::vector<std::map<short,short> > >*)arg[0],
    *(const ::std::map<short,short>*)arg[1]));
  else   (((::std::vector<std::map<short,short> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::map<short,short>*,std::vector<std::map<short,short> > >*)arg[0],
    *(const ::std::map<short,short>*)arg[1]);
}

static  void method_6065( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::map<short,short> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<std::map<short,short>*,std::vector<std::map<short,short> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::std::map<short,short>*)arg[2]);
}

static  void method_6066( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::map<short,short>*,std::vector<std::map<short,short> > >)((((::std::vector<std::map<short,short> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::map<short,short>*,std::vector<std::map<short,short> > >*)arg[0]));
  else   (((::std::vector<std::map<short,short> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::map<short,short>*,std::vector<std::map<short,short> > >*)arg[0]);
}

static  void method_6067( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::map<short,short>*,std::vector<std::map<short,short> > >)((((::std::vector<std::map<short,short> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::map<short,short>*,std::vector<std::map<short,short> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::map<short,short>*,std::vector<std::map<short,short> > >*)arg[1]));
  else   (((::std::vector<std::map<short,short> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<std::map<short,short>*,std::vector<std::map<short,short> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<std::map<short,short>*,std::vector<std::map<short,short> > >*)arg[1]);
}

static  void method_6068( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<std::map<short,short> >*)o)->swap)(*(::std::vector<std::map<short,short> >*)arg[0]);
}

static  void method_6069( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<std::map<short,short> >*)o)->clear)();
}

static void method_newdel_1086( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<std::map<short,short> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<std::map<short,short> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<std::map<short,short> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<std::map<short,short> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<std::map<short,short> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x190( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<std::map<short,short>,std::allocator<std::map<short,short> > >")), ::Reflex::BaseOffset< ::std::vector<std::map<short,short> >,::std::_Vector_base<std::map<short,short>,std::allocator<std::map<short,short> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x191( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<std::map<short,short> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<std::map<short,short> > >::Generate();
}

//------Dictionary for class vector<std::map<short int, short int, std::less<short int>, std::allocator<std::pair<const short int, short int> > >,std::allocator<std::map<short int, short int, std::less<short int>, std::allocator<std::pair<const short int, short int> > > > > -------------------------------
void __std__vector_std__map_short_short_s__db_datamem(Reflex::Class*);
void __std__vector_std__map_short_short_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_std__map_short_short_s__datamem_bld(&__std__vector_std__map_short_short_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_std__map_short_short_s__funcmem_bld(&__std__vector_std__map_short_short_s__db_funcmem);
void __std__vector_std__map_short_short_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<std::map<short,short> >"), typeid(::std::vector<std::map<short,short> >), sizeof(::std::vector<std::map<short,short> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1971, ::Reflex::BaseOffset< ::std::vector<std::map<short,short> >, ::std::_Vector_base<std::map<short,short>,std::allocator<std::map<short,short> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1614, Reflex::Literal("std::vector<std::map<short,short> >::_Alloc_value_type"))
  .AddTypedef(type_1971, Reflex::Literal("std::vector<std::map<short,short> >::_Base"))
  .AddTypedef(type_1365, Reflex::Literal("std::vector<std::map<short,short> >::_Tp_alloc_type"))
  .AddTypedef(type_1614, Reflex::Literal("std::vector<std::map<short,short> >::value_type"))
  .AddTypedef(type_6015, Reflex::Literal("std::vector<std::map<short,short> >::pointer"))
  .AddTypedef(type_6017, Reflex::Literal("std::vector<std::map<short,short> >::const_pointer"))
  .AddTypedef(type_6019, Reflex::Literal("std::vector<std::map<short,short> >::reference"))
  .AddTypedef(type_6021, Reflex::Literal("std::vector<std::map<short,short> >::const_reference"))
  .AddTypedef(type_2362, Reflex::Literal("std::vector<std::map<short,short> >::iterator"))
  .AddTypedef(type_2363, Reflex::Literal("std::vector<std::map<short,short> >::const_iterator"))
  .AddTypedef(type_1756, Reflex::Literal("std::vector<std::map<short,short> >::const_reverse_iterator"))
  .AddTypedef(type_1757, Reflex::Literal("std::vector<std::map<short,short> >::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<std::map<short,short> >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<std::map<short,short> >::difference_type"))
  .AddTypedef(type_1365, Reflex::Literal("std::vector<std::map<short,short> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_6030, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20401), Reflex::Literal("vector"), constructor_6031, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_6021, type_20401), Reflex::Literal("vector"), constructor_6032, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20402), Reflex::Literal("vector"), constructor_6033, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_6034, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1086, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x190, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x191, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_std__map_short_short_s__funcmem_bld);
}

//------Delayed data member builder for class vector<std::map<short int, short int, std::less<short int>, std::allocator<std::pair<const short int, short int> > >,std::allocator<std::map<short int, short int, std::less<short int>, std::allocator<std::pair<const short int, short int> > > > > -------------------
void __std__vector_std__map_short_short_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<std::map<short int, short int, std::less<short int>, std::allocator<std::pair<const short int, short int> > >,std::allocator<std::map<short int, short int, std::less<short int>, std::allocator<std::pair<const short int, short int> > > > > -------------------
void __std__vector_std__map_short_short_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20403, type_20402), Reflex::Literal("operator="), operator_6035, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_6021), Reflex::Literal("assign"), method_6036, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2362), Reflex::Literal("begin"), method_6037, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2363), Reflex::Literal("begin"), method_6038, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2362), Reflex::Literal("end"), method_6039, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2363), Reflex::Literal("end"), method_6040, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_6045, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_6046, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_1614), Reflex::Literal("resize"), method_6047, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_6048, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_6049, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_6050, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6019, type_1654), Reflex::Literal("operator[]"), operator_6051, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6021, type_1654), Reflex::Literal("operator[]"), operator_6052, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6019, type_1654), Reflex::Literal("at"), method_6054, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6021, type_1654), Reflex::Literal("at"), method_6055, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6019), Reflex::Literal("front"), method_6056, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6021), Reflex::Literal("front"), method_6057, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6019), Reflex::Literal("back"), method_6058, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6021), Reflex::Literal("back"), method_6059, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6015), Reflex::Literal("data"), method_6060, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6017), Reflex::Literal("data"), method_6061, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_6021), Reflex::Literal("push_back"), method_6062, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_6063, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2362, type_2362, type_6021), Reflex::Literal("insert"), method_6064, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2362, type_1654, type_6021), Reflex::Literal("insert"), method_6065, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2362, type_2362), Reflex::Literal("erase"), method_6066, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2362, type_2362, type_2362), Reflex::Literal("erase"), method_6067, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_20403), Reflex::Literal("swap"), method_6068, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_6069, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<long int,std::allocator<long int> > -------------------------------
static void constructor_6093( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<long>();
  else ::new(mem) ::std::vector<long>();
}

static void constructor_6094( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<long>(*(const ::std::allocator<long>*)arg[0]);
  else ::new(mem) ::std::vector<long>(*(const ::std::allocator<long>*)arg[0]);
}

static void constructor_6095( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<long>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<long>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<long>(*(::std::size_t*)arg[0],
      *(const long*)arg[1]);
  else ::new(mem) ::std::vector<long>(*(::std::size_t*)arg[0],
      *(const long*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<long>(*(::std::size_t*)arg[0],
      *(const long*)arg[1],
      *(const ::std::allocator<long>*)arg[2]);
  else ::new(mem) ::std::vector<long>(*(::std::size_t*)arg[0],
      *(const long*)arg[1],
      *(const ::std::allocator<long>*)arg[2]);
  }
}

static void constructor_6096( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<long>(*(const ::std::vector<long>*)arg[0]);
  else ::new(mem) ::std::vector<long>(*(const ::std::vector<long>*)arg[0]);
}

static void destructor_6097(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<long>*)o)->::std::vector<long>::~vector)();
}
static  void operator_6098( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<long>*)o)->operator=)(*(const ::std::vector<long>*)arg[0]);
  else   (((::std::vector<long>*)o)->operator=)(*(const ::std::vector<long>*)arg[0]);
}

static  void method_6099( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<long>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const long*)arg[1]);
}

static  void method_6100( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<long*,std::vector<long> >)((((::std::vector<long>*)o)->begin)());
  else   (((::std::vector<long>*)o)->begin)();
}

static  void method_6101( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const long*,std::vector<long> >)((((const ::std::vector<long>*)o)->begin)());
  else   (((const ::std::vector<long>*)o)->begin)();
}

static  void method_6102( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<long*,std::vector<long> >)((((::std::vector<long>*)o)->end)());
  else   (((::std::vector<long>*)o)->end)();
}

static  void method_6103( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const long*,std::vector<long> >)((((const ::std::vector<long>*)o)->end)());
  else   (((const ::std::vector<long>*)o)->end)();
}

static  void method_6108( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<long>*)o)->size)());
  else   (((const ::std::vector<long>*)o)->size)();
}

static  void method_6109( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<long>*)o)->max_size)());
  else   (((const ::std::vector<long>*)o)->max_size)();
}

static  void method_6110( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<long>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<long>*)o)->resize)(*(::std::size_t*)arg[0],
      *(long*)arg[1]);
  }
}

static  void method_6111( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<long>*)o)->capacity)());
  else   (((const ::std::vector<long>*)o)->capacity)();
}

static  void method_6112( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<long>*)o)->empty)());
  else   (((const ::std::vector<long>*)o)->empty)();
}

static  void method_6113( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<long>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_6114( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<long>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<long>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_6115( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<long>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<long>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_6117( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<long>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<long>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6118( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<long>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<long>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6119( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<long>*)o)->front)();
  else   (((::std::vector<long>*)o)->front)();
}

static  void method_6120( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<long>*)o)->front)();
  else   (((const ::std::vector<long>*)o)->front)();
}

static  void method_6121( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<long>*)o)->back)();
  else   (((::std::vector<long>*)o)->back)();
}

static  void method_6122( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<long>*)o)->back)();
  else   (((const ::std::vector<long>*)o)->back)();
}

static  void method_6123( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<long>*)o)->data)());
  else   (((::std::vector<long>*)o)->data)();
}

static  void method_6124( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<long>*)o)->data)());
  else   (((const ::std::vector<long>*)o)->data)();
}

static  void method_6125( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<long>*)o)->push_back)(*(const long*)arg[0]);
}

static  void method_6126( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<long>*)o)->pop_back)();
}

static  void method_6127( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<long*,std::vector<long> >)((((::std::vector<long>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<long*,std::vector<long> >*)arg[0],
    *(const long*)arg[1]));
  else   (((::std::vector<long>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<long*,std::vector<long> >*)arg[0],
    *(const long*)arg[1]);
}

static  void method_6128( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<long>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<long*,std::vector<long> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const long*)arg[2]);
}

static  void method_6129( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<long*,std::vector<long> >)((((::std::vector<long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<long*,std::vector<long> >*)arg[0]));
  else   (((::std::vector<long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<long*,std::vector<long> >*)arg[0]);
}

static  void method_6130( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<long*,std::vector<long> >)((((::std::vector<long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<long*,std::vector<long> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<long*,std::vector<long> >*)arg[1]));
  else   (((::std::vector<long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<long*,std::vector<long> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<long*,std::vector<long> >*)arg[1]);
}

static  void method_6131( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<long>*)o)->swap)(*(::std::vector<long>*)arg[0]);
}

static  void method_6132( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<long>*)o)->clear)();
}

static void method_newdel_1087( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<long> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<long> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<long> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<long> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<long> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x193( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<long,std::allocator<long> >")), ::Reflex::BaseOffset< ::std::vector<long>,::std::_Vector_base<long,std::allocator<long> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x194( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<long> >::Generate();
  else ::Reflex::Proxy< ::std::vector<long> >::Generate();
}

//------Dictionary for class vector<long int,std::allocator<long int> > -------------------------------
void __std__vector_long__db_datamem(Reflex::Class*);
void __std__vector_long__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_long__datamem_bld(&__std__vector_long__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_long__funcmem_bld(&__std__vector_long__db_funcmem);
void __std__vector_long__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<long>"), typeid(::std::vector<long>), sizeof(::std::vector<long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1972, ::Reflex::BaseOffset< ::std::vector<long>, ::std::_Vector_base<long,std::allocator<long> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_48, Reflex::Literal("std::vector<long>::_Alloc_value_type"))
  .AddTypedef(type_1972, Reflex::Literal("std::vector<long>::_Base"))
  .AddTypedef(type_1367, Reflex::Literal("std::vector<long>::_Tp_alloc_type"))
  .AddTypedef(type_48, Reflex::Literal("std::vector<long>::value_type"))
  .AddTypedef(type_3536, Reflex::Literal("std::vector<long>::pointer"))
  .AddTypedef(type_6081, Reflex::Literal("std::vector<long>::const_pointer"))
  .AddTypedef(type_3538, Reflex::Literal("std::vector<long>::reference"))
  .AddTypedef(type_6084, Reflex::Literal("std::vector<long>::const_reference"))
  .AddTypedef(type_2365, Reflex::Literal("std::vector<long>::iterator"))
  .AddTypedef(type_2366, Reflex::Literal("std::vector<long>::const_iterator"))
  .AddTypedef(type_1758, Reflex::Literal("std::vector<long>::const_reverse_iterator"))
  .AddTypedef(type_1759, Reflex::Literal("std::vector<long>::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<long>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<long>::difference_type"))
  .AddTypedef(type_1367, Reflex::Literal("std::vector<long>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_6093, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20405), Reflex::Literal("vector"), constructor_6094, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_6084, type_20405), Reflex::Literal("vector"), constructor_6095, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20406), Reflex::Literal("vector"), constructor_6096, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_6097, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1087, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x193, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x194, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_long__funcmem_bld);
}

//------Delayed data member builder for class vector<long int,std::allocator<long int> > -------------------
void __std__vector_long__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<long int,std::allocator<long int> > -------------------
void __std__vector_long__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20407, type_20406), Reflex::Literal("operator="), operator_6098, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_6084), Reflex::Literal("assign"), method_6099, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2365), Reflex::Literal("begin"), method_6100, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2366), Reflex::Literal("begin"), method_6101, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2365), Reflex::Literal("end"), method_6102, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2366), Reflex::Literal("end"), method_6103, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_6108, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_6109, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_48), Reflex::Literal("resize"), method_6110, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_6111, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_6112, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_6113, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3538, type_1654), Reflex::Literal("operator[]"), operator_6114, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6084, type_1654), Reflex::Literal("operator[]"), operator_6115, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3538, type_1654), Reflex::Literal("at"), method_6117, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6084, type_1654), Reflex::Literal("at"), method_6118, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3538), Reflex::Literal("front"), method_6119, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6084), Reflex::Literal("front"), method_6120, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3538), Reflex::Literal("back"), method_6121, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6084), Reflex::Literal("back"), method_6122, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3536), Reflex::Literal("data"), method_6123, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6081), Reflex::Literal("data"), method_6124, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_6084), Reflex::Literal("push_back"), method_6125, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_6126, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2365, type_2365, type_6084), Reflex::Literal("insert"), method_6127, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2365, type_1654, type_6084), Reflex::Literal("insert"), method_6128, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2365, type_2365), Reflex::Literal("erase"), method_6129, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2365, type_2365, type_2365), Reflex::Literal("erase"), method_6130, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_20407), Reflex::Literal("swap"), method_6131, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_6132, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<long long int,std::allocator<long long int> > -------------------------------
static void constructor_6156( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<long long>();
  else ::new(mem) ::std::vector<long long>();
}

static void constructor_6157( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<long long>(*(const ::std::allocator<long long>*)arg[0]);
  else ::new(mem) ::std::vector<long long>(*(const ::std::allocator<long long>*)arg[0]);
}

static void constructor_6158( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<long long>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<long long>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<long long>(*(::std::size_t*)arg[0],
      *(const long long*)arg[1]);
  else ::new(mem) ::std::vector<long long>(*(::std::size_t*)arg[0],
      *(const long long*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<long long>(*(::std::size_t*)arg[0],
      *(const long long*)arg[1],
      *(const ::std::allocator<long long>*)arg[2]);
  else ::new(mem) ::std::vector<long long>(*(::std::size_t*)arg[0],
      *(const long long*)arg[1],
      *(const ::std::allocator<long long>*)arg[2]);
  }
}

static void constructor_6159( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<long long>(*(const ::std::vector<long long>*)arg[0]);
  else ::new(mem) ::std::vector<long long>(*(const ::std::vector<long long>*)arg[0]);
}

static void destructor_6160(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<long long>*)o)->::std::vector<long long>::~vector)();
}
static  void operator_6161( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<long long>*)o)->operator=)(*(const ::std::vector<long long>*)arg[0]);
  else   (((::std::vector<long long>*)o)->operator=)(*(const ::std::vector<long long>*)arg[0]);
}

static  void method_6162( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<long long>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const long long*)arg[1]);
}

static  void method_6163( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >)((((::std::vector<long long>*)o)->begin)());
  else   (((::std::vector<long long>*)o)->begin)();
}

static  void method_6164( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const long long*,std::vector<long long> >)((((const ::std::vector<long long>*)o)->begin)());
  else   (((const ::std::vector<long long>*)o)->begin)();
}

static  void method_6165( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >)((((::std::vector<long long>*)o)->end)());
  else   (((::std::vector<long long>*)o)->end)();
}

static  void method_6166( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const long long*,std::vector<long long> >)((((const ::std::vector<long long>*)o)->end)());
  else   (((const ::std::vector<long long>*)o)->end)();
}

static  void method_6171( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<long long>*)o)->size)());
  else   (((const ::std::vector<long long>*)o)->size)();
}

static  void method_6172( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<long long>*)o)->max_size)());
  else   (((const ::std::vector<long long>*)o)->max_size)();
}

static  void method_6173( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<long long>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<long long>*)o)->resize)(*(::std::size_t*)arg[0],
      *(long long*)arg[1]);
  }
}

static  void method_6174( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<long long>*)o)->capacity)());
  else   (((const ::std::vector<long long>*)o)->capacity)();
}

static  void method_6175( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<long long>*)o)->empty)());
  else   (((const ::std::vector<long long>*)o)->empty)();
}

static  void method_6176( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<long long>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_6177( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<long long>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<long long>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_6178( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<long long>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<long long>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_6180( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<long long>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<long long>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6181( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<long long>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<long long>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6182( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<long long>*)o)->front)();
  else   (((::std::vector<long long>*)o)->front)();
}

static  void method_6183( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<long long>*)o)->front)();
  else   (((const ::std::vector<long long>*)o)->front)();
}

static  void method_6184( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<long long>*)o)->back)();
  else   (((::std::vector<long long>*)o)->back)();
}

static  void method_6185( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<long long>*)o)->back)();
  else   (((const ::std::vector<long long>*)o)->back)();
}

static  void method_6186( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<long long>*)o)->data)());
  else   (((::std::vector<long long>*)o)->data)();
}

static  void method_6187( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<long long>*)o)->data)());
  else   (((const ::std::vector<long long>*)o)->data)();
}

static  void method_6188( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<long long>*)o)->push_back)(*(const long long*)arg[0]);
}

static  void method_6189( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<long long>*)o)->pop_back)();
}

static  void method_6190( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >)((((::std::vector<long long>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >*)arg[0],
    *(const long long*)arg[1]));
  else   (((::std::vector<long long>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >*)arg[0],
    *(const long long*)arg[1]);
}

static  void method_6191( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<long long>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const long long*)arg[2]);
}

static  void method_6192( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >)((((::std::vector<long long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >*)arg[0]));
  else   (((::std::vector<long long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >*)arg[0]);
}

static  void method_6193( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >)((((::std::vector<long long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >*)arg[1]));
  else   (((::std::vector<long long>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<long long*,std::vector<long long> >*)arg[1]);
}

static  void method_6194( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<long long>*)o)->swap)(*(::std::vector<long long>*)arg[0]);
}

static  void method_6195( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<long long>*)o)->clear)();
}

static void method_newdel_1088( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<long long> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<long long> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<long long> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<long long> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<long long> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x196( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<long long,std::allocator<long long> >")), ::Reflex::BaseOffset< ::std::vector<long long>,::std::_Vector_base<long long,std::allocator<long long> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x197( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<long long> >::Generate();
  else ::Reflex::Proxy< ::std::vector<long long> >::Generate();
}

//------Dictionary for class vector<long long int,std::allocator<long long int> > -------------------------------
void __std__vector_longslong__db_datamem(Reflex::Class*);
void __std__vector_longslong__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_longslong__datamem_bld(&__std__vector_longslong__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_longslong__funcmem_bld(&__std__vector_longslong__db_funcmem);
void __std__vector_longslong__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<long long>"), typeid(::std::vector<long long>), sizeof(::std::vector<long long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1973, ::Reflex::BaseOffset< ::std::vector<long long>, ::std::_Vector_base<long long,std::allocator<long long> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2087, Reflex::Literal("std::vector<long long>::_Alloc_value_type"))
  .AddTypedef(type_1973, Reflex::Literal("std::vector<long long>::_Base"))
  .AddTypedef(type_1368, Reflex::Literal("std::vector<long long>::_Tp_alloc_type"))
  .AddTypedef(type_2087, Reflex::Literal("std::vector<long long>::value_type"))
  .AddTypedef(type_3547, Reflex::Literal("std::vector<long long>::pointer"))
  .AddTypedef(type_6144, Reflex::Literal("std::vector<long long>::const_pointer"))
  .AddTypedef(type_3549, Reflex::Literal("std::vector<long long>::reference"))
  .AddTypedef(type_6147, Reflex::Literal("std::vector<long long>::const_reference"))
  .AddTypedef(type_2367, Reflex::Literal("std::vector<long long>::iterator"))
  .AddTypedef(type_2368, Reflex::Literal("std::vector<long long>::const_iterator"))
  .AddTypedef(type_1760, Reflex::Literal("std::vector<long long>::const_reverse_iterator"))
  .AddTypedef(type_1761, Reflex::Literal("std::vector<long long>::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<long long>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<long long>::difference_type"))
  .AddTypedef(type_1368, Reflex::Literal("std::vector<long long>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_6156, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20409), Reflex::Literal("vector"), constructor_6157, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_6147, type_20409), Reflex::Literal("vector"), constructor_6158, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20410), Reflex::Literal("vector"), constructor_6159, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_6160, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1088, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x196, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x197, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_longslong__funcmem_bld);
}

//------Delayed data member builder for class vector<long long int,std::allocator<long long int> > -------------------
void __std__vector_longslong__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<long long int,std::allocator<long long int> > -------------------
void __std__vector_longslong__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20411, type_20410), Reflex::Literal("operator="), operator_6161, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_6147), Reflex::Literal("assign"), method_6162, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2367), Reflex::Literal("begin"), method_6163, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2368), Reflex::Literal("begin"), method_6164, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2367), Reflex::Literal("end"), method_6165, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2368), Reflex::Literal("end"), method_6166, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_6171, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_6172, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_2087), Reflex::Literal("resize"), method_6173, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_6174, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_6175, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_6176, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3549, type_1654), Reflex::Literal("operator[]"), operator_6177, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6147, type_1654), Reflex::Literal("operator[]"), operator_6178, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3549, type_1654), Reflex::Literal("at"), method_6180, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6147, type_1654), Reflex::Literal("at"), method_6181, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3549), Reflex::Literal("front"), method_6182, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6147), Reflex::Literal("front"), method_6183, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3549), Reflex::Literal("back"), method_6184, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6147), Reflex::Literal("back"), method_6185, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3547), Reflex::Literal("data"), method_6186, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6144), Reflex::Literal("data"), method_6187, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_6147), Reflex::Literal("push_back"), method_6188, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_6189, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2367, type_2367, type_6147), Reflex::Literal("insert"), method_6190, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2367, type_1654, type_6147), Reflex::Literal("insert"), method_6191, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2367, type_2367), Reflex::Literal("erase"), method_6192, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2367, type_2367, type_2367), Reflex::Literal("erase"), method_6193, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_20411), Reflex::Literal("swap"), method_6194, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_6195, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<long double,std::allocator<long double> > -------------------------------
static void constructor_6219( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<long double>();
  else ::new(mem) ::std::vector<long double>();
}

static void constructor_6220( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<long double>(*(const ::std::allocator<long double>*)arg[0]);
  else ::new(mem) ::std::vector<long double>(*(const ::std::allocator<long double>*)arg[0]);
}

static void constructor_6221( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<long double>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<long double>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<long double>(*(::std::size_t*)arg[0],
      *(const long double*)arg[1]);
  else ::new(mem) ::std::vector<long double>(*(::std::size_t*)arg[0],
      *(const long double*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<long double>(*(::std::size_t*)arg[0],
      *(const long double*)arg[1],
      *(const ::std::allocator<long double>*)arg[2]);
  else ::new(mem) ::std::vector<long double>(*(::std::size_t*)arg[0],
      *(const long double*)arg[1],
      *(const ::std::allocator<long double>*)arg[2]);
  }
}

static void constructor_6222( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<long double>(*(const ::std::vector<long double>*)arg[0]);
  else ::new(mem) ::std::vector<long double>(*(const ::std::vector<long double>*)arg[0]);
}

static void destructor_6223(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<long double>*)o)->::std::vector<long double>::~vector)();
}
static  void operator_6224( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<long double>*)o)->operator=)(*(const ::std::vector<long double>*)arg[0]);
  else   (((::std::vector<long double>*)o)->operator=)(*(const ::std::vector<long double>*)arg[0]);
}

static  void method_6225( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<long double>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const long double*)arg[1]);
}

static  void method_6226( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<long double*,std::vector<long double> >)((((::std::vector<long double>*)o)->begin)());
  else   (((::std::vector<long double>*)o)->begin)();
}

static  void method_6227( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const long double*,std::vector<long double> >)((((const ::std::vector<long double>*)o)->begin)());
  else   (((const ::std::vector<long double>*)o)->begin)();
}

static  void method_6228( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<long double*,std::vector<long double> >)((((::std::vector<long double>*)o)->end)());
  else   (((::std::vector<long double>*)o)->end)();
}

static  void method_6229( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const long double*,std::vector<long double> >)((((const ::std::vector<long double>*)o)->end)());
  else   (((const ::std::vector<long double>*)o)->end)();
}

static  void method_6234( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<long double>*)o)->size)());
  else   (((const ::std::vector<long double>*)o)->size)();
}

static  void method_6235( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<long double>*)o)->max_size)());
  else   (((const ::std::vector<long double>*)o)->max_size)();
}

static  void method_6236( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<long double>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<long double>*)o)->resize)(*(::std::size_t*)arg[0],
      *(long double*)arg[1]);
  }
}

static  void method_6237( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<long double>*)o)->capacity)());
  else   (((const ::std::vector<long double>*)o)->capacity)();
}

static  void method_6238( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<long double>*)o)->empty)());
  else   (((const ::std::vector<long double>*)o)->empty)();
}

static  void method_6239( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<long double>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_6240( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<long double>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<long double>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_6241( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<long double>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<long double>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_6243( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<long double>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<long double>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6244( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<long double>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<long double>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6245( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<long double>*)o)->front)();
  else   (((::std::vector<long double>*)o)->front)();
}

static  void method_6246( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<long double>*)o)->front)();
  else   (((const ::std::vector<long double>*)o)->front)();
}

static  void method_6247( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<long double>*)o)->back)();
  else   (((::std::vector<long double>*)o)->back)();
}

static  void method_6248( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<long double>*)o)->back)();
  else   (((const ::std::vector<long double>*)o)->back)();
}

static  void method_6249( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<long double>*)o)->data)());
  else   (((::std::vector<long double>*)o)->data)();
}

static  void method_6250( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<long double>*)o)->data)());
  else   (((const ::std::vector<long double>*)o)->data)();
}

static  void method_6251( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<long double>*)o)->push_back)(*(const long double*)arg[0]);
}

static  void method_6252( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<long double>*)o)->pop_back)();
}

static  void method_6253( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<long double*,std::vector<long double> >)((((::std::vector<long double>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<long double*,std::vector<long double> >*)arg[0],
    *(const long double*)arg[1]));
  else   (((::std::vector<long double>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<long double*,std::vector<long double> >*)arg[0],
    *(const long double*)arg[1]);
}

static  void method_6254( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<long double>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<long double*,std::vector<long double> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const long double*)arg[2]);
}

static  void method_6255( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<long double*,std::vector<long double> >)((((::std::vector<long double>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<long double*,std::vector<long double> >*)arg[0]));
  else   (((::std::vector<long double>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<long double*,std::vector<long double> >*)arg[0]);
}

static  void method_6256( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<long double*,std::vector<long double> >)((((::std::vector<long double>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<long double*,std::vector<long double> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<long double*,std::vector<long double> >*)arg[1]));
  else   (((::std::vector<long double>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<long double*,std::vector<long double> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<long double*,std::vector<long double> >*)arg[1]);
}

static  void method_6257( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<long double>*)o)->swap)(*(::std::vector<long double>*)arg[0]);
}

static  void method_6258( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<long double>*)o)->clear)();
}

static void method_newdel_1089( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<long double> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<long double> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<long double> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<long double> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<long double> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x199( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<long double,std::allocator<long double> >")), ::Reflex::BaseOffset< ::std::vector<long double>,::std::_Vector_base<long double,std::allocator<long double> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x200( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<long double> >::Generate();
  else ::Reflex::Proxy< ::std::vector<long double> >::Generate();
}

//------Dictionary for class vector<long double,std::allocator<long double> > -------------------------------
void __std__vector_longsdouble__db_datamem(Reflex::Class*);
void __std__vector_longsdouble__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_longsdouble__datamem_bld(&__std__vector_longsdouble__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_longsdouble__funcmem_bld(&__std__vector_longsdouble__db_funcmem);
void __std__vector_longsdouble__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<long double>"), typeid(::std::vector<long double>), sizeof(::std::vector<long double>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1974, ::Reflex::BaseOffset< ::std::vector<long double>, ::std::_Vector_base<long double,std::allocator<long double> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2059, Reflex::Literal("std::vector<long double>::_Alloc_value_type"))
  .AddTypedef(type_1974, Reflex::Literal("std::vector<long double>::_Base"))
  .AddTypedef(type_1369, Reflex::Literal("std::vector<long double>::_Tp_alloc_type"))
  .AddTypedef(type_2059, Reflex::Literal("std::vector<long double>::value_type"))
  .AddTypedef(type_2463, Reflex::Literal("std::vector<long double>::pointer"))
  .AddTypedef(type_6207, Reflex::Literal("std::vector<long double>::const_pointer"))
  .AddTypedef(type_3559, Reflex::Literal("std::vector<long double>::reference"))
  .AddTypedef(type_6210, Reflex::Literal("std::vector<long double>::const_reference"))
  .AddTypedef(type_2369, Reflex::Literal("std::vector<long double>::iterator"))
  .AddTypedef(type_2370, Reflex::Literal("std::vector<long double>::const_iterator"))
  .AddTypedef(type_1762, Reflex::Literal("std::vector<long double>::const_reverse_iterator"))
  .AddTypedef(type_1763, Reflex::Literal("std::vector<long double>::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<long double>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<long double>::difference_type"))
  .AddTypedef(type_1369, Reflex::Literal("std::vector<long double>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_6219, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20413), Reflex::Literal("vector"), constructor_6220, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_6210, type_20413), Reflex::Literal("vector"), constructor_6221, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20414), Reflex::Literal("vector"), constructor_6222, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_6223, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1089, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x199, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x200, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_longsdouble__funcmem_bld);
}

//------Delayed data member builder for class vector<long double,std::allocator<long double> > -------------------
void __std__vector_longsdouble__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<long double,std::allocator<long double> > -------------------
void __std__vector_longsdouble__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20415, type_20414), Reflex::Literal("operator="), operator_6224, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_6210), Reflex::Literal("assign"), method_6225, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2369), Reflex::Literal("begin"), method_6226, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2370), Reflex::Literal("begin"), method_6227, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2369), Reflex::Literal("end"), method_6228, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2370), Reflex::Literal("end"), method_6229, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_6234, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_6235, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_2059), Reflex::Literal("resize"), method_6236, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_6237, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_6238, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_6239, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3559, type_1654), Reflex::Literal("operator[]"), operator_6240, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6210, type_1654), Reflex::Literal("operator[]"), operator_6241, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3559, type_1654), Reflex::Literal("at"), method_6243, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6210, type_1654), Reflex::Literal("at"), method_6244, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3559), Reflex::Literal("front"), method_6245, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6210), Reflex::Literal("front"), method_6246, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3559), Reflex::Literal("back"), method_6247, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6210), Reflex::Literal("back"), method_6248, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2463), Reflex::Literal("data"), method_6249, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6207), Reflex::Literal("data"), method_6250, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_6210), Reflex::Literal("push_back"), method_6251, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_6252, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2369, type_2369, type_6210), Reflex::Literal("insert"), method_6253, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2369, type_1654, type_6210), Reflex::Literal("insert"), method_6254, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2369, type_2369), Reflex::Literal("erase"), method_6255, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2369, type_2369, type_2369), Reflex::Literal("erase"), method_6256, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_20415), Reflex::Literal("swap"), method_6257, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_6258, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<char,std::allocator<char> > -------------------------------
static void constructor_6281( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<char>();
  else ::new(mem) ::std::vector<char>();
}

static void constructor_6282( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<char>(*(const ::std::allocator<char>*)arg[0]);
  else ::new(mem) ::std::vector<char>(*(const ::std::allocator<char>*)arg[0]);
}

static void constructor_6283( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<char>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<char>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<char>(*(::std::size_t*)arg[0],
      *(const char*)arg[1]);
  else ::new(mem) ::std::vector<char>(*(::std::size_t*)arg[0],
      *(const char*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<char>(*(::std::size_t*)arg[0],
      *(const char*)arg[1],
      *(const ::std::allocator<char>*)arg[2]);
  else ::new(mem) ::std::vector<char>(*(::std::size_t*)arg[0],
      *(const char*)arg[1],
      *(const ::std::allocator<char>*)arg[2]);
  }
}

static void constructor_6284( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<char>(*(const ::std::vector<char>*)arg[0]);
  else ::new(mem) ::std::vector<char>(*(const ::std::vector<char>*)arg[0]);
}

static void destructor_6285(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<char>*)o)->::std::vector<char>::~vector)();
}
static  void operator_6286( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<char>*)o)->operator=)(*(const ::std::vector<char>*)arg[0]);
  else   (((::std::vector<char>*)o)->operator=)(*(const ::std::vector<char>*)arg[0]);
}

static  void method_6287( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<char>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const char*)arg[1]);
}

static  void method_6288( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::vector<char> >)((((::std::vector<char>*)o)->begin)());
  else   (((::std::vector<char>*)o)->begin)();
}

static  void method_6289( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const char*,std::vector<char> >)((((const ::std::vector<char>*)o)->begin)());
  else   (((const ::std::vector<char>*)o)->begin)();
}

static  void method_6290( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::vector<char> >)((((::std::vector<char>*)o)->end)());
  else   (((::std::vector<char>*)o)->end)();
}

static  void method_6291( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const char*,std::vector<char> >)((((const ::std::vector<char>*)o)->end)());
  else   (((const ::std::vector<char>*)o)->end)();
}

static  void method_6296( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<char>*)o)->size)());
  else   (((const ::std::vector<char>*)o)->size)();
}

static  void method_6297( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<char>*)o)->max_size)());
  else   (((const ::std::vector<char>*)o)->max_size)();
}

static  void method_6298( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<char>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<char>*)o)->resize)(*(::std::size_t*)arg[0],
      *(char*)arg[1]);
  }
}

static  void method_6299( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<char>*)o)->capacity)());
  else   (((const ::std::vector<char>*)o)->capacity)();
}

static  void method_6300( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<char>*)o)->empty)());
  else   (((const ::std::vector<char>*)o)->empty)();
}

static  void method_6301( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<char>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_6302( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<char>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<char>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_6303( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<char>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<char>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_6305( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<char>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<char>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6306( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<char>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<char>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6307( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<char>*)o)->front)();
  else   (((::std::vector<char>*)o)->front)();
}

static  void method_6308( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<char>*)o)->front)();
  else   (((const ::std::vector<char>*)o)->front)();
}

static  void method_6309( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<char>*)o)->back)();
  else   (((::std::vector<char>*)o)->back)();
}

static  void method_6310( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<char>*)o)->back)();
  else   (((const ::std::vector<char>*)o)->back)();
}

static  void method_6311( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<char>*)o)->data)());
  else   (((::std::vector<char>*)o)->data)();
}

static  void method_6312( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<char>*)o)->data)());
  else   (((const ::std::vector<char>*)o)->data)();
}

static  void method_6313( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<char>*)o)->push_back)(*(const char*)arg[0]);
}

static  void method_6314( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<char>*)o)->pop_back)();
}

static  void method_6315( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::vector<char> >)((((::std::vector<char>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<char*,std::vector<char> >*)arg[0],
    *(const char*)arg[1]));
  else   (((::std::vector<char>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<char*,std::vector<char> >*)arg[0],
    *(const char*)arg[1]);
}

static  void method_6316( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<char>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<char*,std::vector<char> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const char*)arg[2]);
}

static  void method_6317( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::vector<char> >)((((::std::vector<char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char*,std::vector<char> >*)arg[0]));
  else   (((::std::vector<char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char*,std::vector<char> >*)arg[0]);
}

static  void method_6318( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char*,std::vector<char> >)((((::std::vector<char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char*,std::vector<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::vector<char> >*)arg[1]));
  else   (((::std::vector<char>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char*,std::vector<char> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char*,std::vector<char> >*)arg[1]);
}

static  void method_6319( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<char>*)o)->swap)(*(::std::vector<char>*)arg[0]);
}

static  void method_6320( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<char>*)o)->clear)();
}

static void method_newdel_1090( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<char> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<char> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<char> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<char> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<char> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x202( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<char,std::allocator<char> >")), ::Reflex::BaseOffset< ::std::vector<char>,::std::_Vector_base<char,std::allocator<char> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x203( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<char> >::Generate();
  else ::Reflex::Proxy< ::std::vector<char> >::Generate();
}

//------Dictionary for class vector<char,std::allocator<char> > -------------------------------
void __std__vector_char__db_datamem(Reflex::Class*);
void __std__vector_char__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_char__datamem_bld(&__std__vector_char__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_char__funcmem_bld(&__std__vector_char__db_funcmem);
void __std__vector_char__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<char>"), typeid(::std::vector<char>), sizeof(::std::vector<char>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1977, ::Reflex::BaseOffset< ::std::vector<char>, ::std::_Vector_base<char,std::allocator<char> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2616, Reflex::Literal("std::vector<char>::_Alloc_value_type"))
  .AddTypedef(type_1977, Reflex::Literal("std::vector<char>::_Base"))
  .AddTypedef(type_1350, Reflex::Literal("std::vector<char>::_Tp_alloc_type"))
  .AddTypedef(type_2616, Reflex::Literal("std::vector<char>::value_type"))
  .AddTypedef(type_791, Reflex::Literal("std::vector<char>::pointer"))
  .AddTypedef(type_2053, Reflex::Literal("std::vector<char>::const_pointer"))
  .AddTypedef(type_3600, Reflex::Literal("std::vector<char>::reference"))
  .AddTypedef(type_6272, Reflex::Literal("std::vector<char>::const_reference"))
  .AddTypedef(type_2376, Reflex::Literal("std::vector<char>::iterator"))
  .AddTypedef(type_2377, Reflex::Literal("std::vector<char>::const_iterator"))
  .AddTypedef(type_1768, Reflex::Literal("std::vector<char>::const_reverse_iterator"))
  .AddTypedef(type_1769, Reflex::Literal("std::vector<char>::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<char>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<char>::difference_type"))
  .AddTypedef(type_1350, Reflex::Literal("std::vector<char>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_6281, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20416), Reflex::Literal("vector"), constructor_6282, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_6272, type_20416), Reflex::Literal("vector"), constructor_6283, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20417), Reflex::Literal("vector"), constructor_6284, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_6285, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1090, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x202, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x203, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_char__funcmem_bld);
}

//------Delayed data member builder for class vector<char,std::allocator<char> > -------------------
void __std__vector_char__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<char,std::allocator<char> > -------------------
void __std__vector_char__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20418, type_20417), Reflex::Literal("operator="), operator_6286, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_6272), Reflex::Literal("assign"), method_6287, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2376), Reflex::Literal("begin"), method_6288, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2377), Reflex::Literal("begin"), method_6289, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2376), Reflex::Literal("end"), method_6290, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2377), Reflex::Literal("end"), method_6291, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_6296, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_6297, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_2616), Reflex::Literal("resize"), method_6298, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_6299, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_6300, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_6301, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3600, type_1654), Reflex::Literal("operator[]"), operator_6302, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6272, type_1654), Reflex::Literal("operator[]"), operator_6303, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3600, type_1654), Reflex::Literal("at"), method_6305, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6272, type_1654), Reflex::Literal("at"), method_6306, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3600), Reflex::Literal("front"), method_6307, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6272), Reflex::Literal("front"), method_6308, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3600), Reflex::Literal("back"), method_6309, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6272), Reflex::Literal("back"), method_6310, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_791), Reflex::Literal("data"), method_6311, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2053), Reflex::Literal("data"), method_6312, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_6272), Reflex::Literal("push_back"), method_6313, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_6314, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2376, type_2376, type_6272), Reflex::Literal("insert"), method_6315, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2376, type_1654, type_6272), Reflex::Literal("insert"), method_6316, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2376, type_2376), Reflex::Literal("erase"), method_6317, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2376, type_2376, type_2376), Reflex::Literal("erase"), method_6318, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_20418), Reflex::Literal("swap"), method_6319, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_6320, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<char*,std::allocator<char*> > -------------------------------
static void constructor_6344( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<char*>();
  else ::new(mem) ::std::vector<char*>();
}

static void constructor_6345( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<char*>(*(const ::std::allocator<char*>*)arg[0]);
  else ::new(mem) ::std::vector<char*>(*(const ::std::allocator<char*>*)arg[0]);
}

static void constructor_6346( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<char*>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<char*>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<char*>(*(::std::size_t*)arg[0],
      *(char* const*)arg[1]);
  else ::new(mem) ::std::vector<char*>(*(::std::size_t*)arg[0],
      *(char* const*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<char*>(*(::std::size_t*)arg[0],
      *(char* const*)arg[1],
      *(const ::std::allocator<char*>*)arg[2]);
  else ::new(mem) ::std::vector<char*>(*(::std::size_t*)arg[0],
      *(char* const*)arg[1],
      *(const ::std::allocator<char*>*)arg[2]);
  }
}

static void constructor_6347( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<char*>(*(const ::std::vector<char*>*)arg[0]);
  else ::new(mem) ::std::vector<char*>(*(const ::std::vector<char*>*)arg[0]);
}

static void destructor_6348(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<char*>*)o)->::std::vector<char*>::~vector)();
}
static  void operator_6349( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<char*>*)o)->operator=)(*(const ::std::vector<char*>*)arg[0]);
  else   (((::std::vector<char*>*)o)->operator=)(*(const ::std::vector<char*>*)arg[0]);
}

static  void method_6350( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<char*>*)o)->assign)(*(::std::size_t*)arg[0],
    *(char* const*)arg[1]);
}

static  void method_6351( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char**,std::vector<char*> >)((((::std::vector<char*>*)o)->begin)());
  else   (((::std::vector<char*>*)o)->begin)();
}

static  void method_6352( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char* const*,std::vector<char*> >)((((const ::std::vector<char*>*)o)->begin)());
  else   (((const ::std::vector<char*>*)o)->begin)();
}

static  void method_6353( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char**,std::vector<char*> >)((((::std::vector<char*>*)o)->end)());
  else   (((::std::vector<char*>*)o)->end)();
}

static  void method_6354( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char* const*,std::vector<char*> >)((((const ::std::vector<char*>*)o)->end)());
  else   (((const ::std::vector<char*>*)o)->end)();
}

static  void method_6359( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<char*>*)o)->size)());
  else   (((const ::std::vector<char*>*)o)->size)();
}

static  void method_6360( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<char*>*)o)->max_size)());
  else   (((const ::std::vector<char*>*)o)->max_size)();
}

static  void method_6361( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<char*>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<char*>*)o)->resize)(*(::std::size_t*)arg[0],
      (char*)arg[1]);
  }
}

static  void method_6362( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<char*>*)o)->capacity)());
  else   (((const ::std::vector<char*>*)o)->capacity)();
}

static  void method_6363( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<char*>*)o)->empty)());
  else   (((const ::std::vector<char*>*)o)->empty)();
}

static  void method_6364( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<char*>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_6365( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<char*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<char*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_6366( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<char*>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<char*>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_6368( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<char*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<char*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6369( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<char*>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<char*>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6370( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<char*>*)o)->front)();
  else   (((::std::vector<char*>*)o)->front)();
}

static  void method_6371( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<char*>*)o)->front)();
  else   (((const ::std::vector<char*>*)o)->front)();
}

static  void method_6372( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<char*>*)o)->back)();
  else   (((::std::vector<char*>*)o)->back)();
}

static  void method_6373( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<char*>*)o)->back)();
  else   (((const ::std::vector<char*>*)o)->back)();
}

static  void method_6374( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<char*>*)o)->data)());
  else   (((::std::vector<char*>*)o)->data)();
}

static  void method_6375( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<char*>*)o)->data)());
  else   (((const ::std::vector<char*>*)o)->data)();
}

static  void method_6376( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<char*>*)o)->push_back)(*(char* const*)arg[0]);
}

static  void method_6377( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<char*>*)o)->pop_back)();
}

static  void method_6378( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char**,std::vector<char*> >)((((::std::vector<char*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<char**,std::vector<char*> >*)arg[0],
    *(char* const*)arg[1]));
  else   (((::std::vector<char*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<char**,std::vector<char*> >*)arg[0],
    *(char* const*)arg[1]);
}

static  void method_6379( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<char*>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<char**,std::vector<char*> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(char* const*)arg[2]);
}

static  void method_6380( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char**,std::vector<char*> >)((((::std::vector<char*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char**,std::vector<char*> >*)arg[0]));
  else   (((::std::vector<char*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char**,std::vector<char*> >*)arg[0]);
}

static  void method_6381( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<char**,std::vector<char*> >)((((::std::vector<char*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char**,std::vector<char*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char**,std::vector<char*> >*)arg[1]));
  else   (((::std::vector<char*>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<char**,std::vector<char*> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<char**,std::vector<char*> >*)arg[1]);
}

static  void method_6382( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<char*>*)o)->swap)(*(::std::vector<char*>*)arg[0]);
}

static  void method_6383( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<char*>*)o)->clear)();
}

static void method_newdel_1091( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<char*> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<char*> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<char*> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<char*> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<char*> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x205( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<char*,std::allocator<char*> >")), ::Reflex::BaseOffset< ::std::vector<char*>,::std::_Vector_base<char*,std::allocator<char*> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x206( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<char*> >::Generate();
  else ::Reflex::Proxy< ::std::vector<char*> >::Generate();
}

//------Dictionary for class vector<char*,std::allocator<char*> > -------------------------------
void __std__vector_charp__db_datamem(Reflex::Class*);
void __std__vector_charp__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_charp__datamem_bld(&__std__vector_charp__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_charp__funcmem_bld(&__std__vector_charp__db_funcmem);
void __std__vector_charp__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<char*>"), typeid(::std::vector<char*>), sizeof(::std::vector<char*>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1978, ::Reflex::BaseOffset< ::std::vector<char*>, ::std::_Vector_base<char*,std::allocator<char*> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_791, Reflex::Literal("std::vector<char*>::_Alloc_value_type"))
  .AddTypedef(type_1978, Reflex::Literal("std::vector<char*>::_Base"))
  .AddTypedef(type_1370, Reflex::Literal("std::vector<char*>::_Tp_alloc_type"))
  .AddTypedef(type_791, Reflex::Literal("std::vector<char*>::value_type"))
  .AddTypedef(type_2549, Reflex::Literal("std::vector<char*>::pointer"))
  .AddTypedef(type_2100, Reflex::Literal("std::vector<char*>::const_pointer"))
  .AddTypedef(type_6333, Reflex::Literal("std::vector<char*>::reference"))
  .AddTypedef(type_6335, Reflex::Literal("std::vector<char*>::const_reference"))
  .AddTypedef(type_2378, Reflex::Literal("std::vector<char*>::iterator"))
  .AddTypedef(type_2379, Reflex::Literal("std::vector<char*>::const_iterator"))
  .AddTypedef(type_1770, Reflex::Literal("std::vector<char*>::const_reverse_iterator"))
  .AddTypedef(type_1771, Reflex::Literal("std::vector<char*>::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<char*>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<char*>::difference_type"))
  .AddTypedef(type_1370, Reflex::Literal("std::vector<char*>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_6344, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20419), Reflex::Literal("vector"), constructor_6345, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_6335, type_20419), Reflex::Literal("vector"), constructor_6346, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20420), Reflex::Literal("vector"), constructor_6347, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_6348, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1091, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x205, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x206, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_charp__funcmem_bld);
}

//------Delayed data member builder for class vector<char*,std::allocator<char*> > -------------------
void __std__vector_charp__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<char*,std::allocator<char*> > -------------------
void __std__vector_charp__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20421, type_20420), Reflex::Literal("operator="), operator_6349, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_6335), Reflex::Literal("assign"), method_6350, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2378), Reflex::Literal("begin"), method_6351, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2379), Reflex::Literal("begin"), method_6352, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2378), Reflex::Literal("end"), method_6353, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2379), Reflex::Literal("end"), method_6354, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_6359, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_6360, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_791), Reflex::Literal("resize"), method_6361, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_6362, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_6363, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_6364, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6333, type_1654), Reflex::Literal("operator[]"), operator_6365, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6335, type_1654), Reflex::Literal("operator[]"), operator_6366, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6333, type_1654), Reflex::Literal("at"), method_6368, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6335, type_1654), Reflex::Literal("at"), method_6369, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6333), Reflex::Literal("front"), method_6370, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6335), Reflex::Literal("front"), method_6371, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6333), Reflex::Literal("back"), method_6372, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6335), Reflex::Literal("back"), method_6373, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2549), Reflex::Literal("data"), method_6374, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2100), Reflex::Literal("data"), method_6375, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_6335), Reflex::Literal("push_back"), method_6376, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_6377, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2378, type_2378, type_6335), Reflex::Literal("insert"), method_6378, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2378, type_1654, type_6335), Reflex::Literal("insert"), method_6379, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2378, type_2378), Reflex::Literal("erase"), method_6380, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2378, type_2378, type_2378), Reflex::Literal("erase"), method_6381, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_20421), Reflex::Literal("swap"), method_6382, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_6383, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<bool,std::allocator<bool> > -------------------------------
static  void method_6403( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<bool>)((((const ::std::vector<bool>*)o)->get_allocator)());
  else   (((const ::std::vector<bool>*)o)->get_allocator)();
}

static void constructor_6404( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<bool>();
  else ::new(mem) ::std::vector<bool>();
}

static void constructor_6405( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<bool>(*(const ::std::allocator<bool>*)arg[0]);
  else ::new(mem) ::std::vector<bool>(*(const ::std::allocator<bool>*)arg[0]);
}

static void constructor_6406( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<bool>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<bool>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<bool>(*(::std::size_t*)arg[0],
      *(const bool*)arg[1]);
  else ::new(mem) ::std::vector<bool>(*(::std::size_t*)arg[0],
      *(const bool*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<bool>(*(::std::size_t*)arg[0],
      *(const bool*)arg[1],
      *(const ::std::allocator<bool>*)arg[2]);
  else ::new(mem) ::std::vector<bool>(*(::std::size_t*)arg[0],
      *(const bool*)arg[1],
      *(const ::std::allocator<bool>*)arg[2]);
  }
}

static void constructor_6407( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<bool>(*(const ::std::vector<bool>*)arg[0]);
  else ::new(mem) ::std::vector<bool>(*(const ::std::vector<bool>*)arg[0]);
}

static void destructor_6408(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<bool>*)o)->::std::vector<bool>::~vector)();
}
static  void operator_6409( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<bool>*)o)->operator=)(*(const ::std::vector<bool>*)arg[0]);
  else   (((::std::vector<bool>*)o)->operator=)(*(const ::std::vector<bool>*)arg[0]);
}

static  void method_6410( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<bool>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const bool*)arg[1]);
}

static  void method_6411( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Bit_iterator)((((::std::vector<bool>*)o)->begin)());
  else   (((::std::vector<bool>*)o)->begin)();
}

static  void method_6412( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Bit_const_iterator)((((const ::std::vector<bool>*)o)->begin)());
  else   (((const ::std::vector<bool>*)o)->begin)();
}

static  void method_6413( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Bit_iterator)((((::std::vector<bool>*)o)->end)());
  else   (((::std::vector<bool>*)o)->end)();
}

static  void method_6414( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Bit_const_iterator)((((const ::std::vector<bool>*)o)->end)());
  else   (((const ::std::vector<bool>*)o)->end)();
}

static  void method_6419( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<bool>*)o)->size)());
  else   (((const ::std::vector<bool>*)o)->size)();
}

static  void method_6420( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<bool>*)o)->max_size)());
  else   (((const ::std::vector<bool>*)o)->max_size)();
}

static  void method_6421( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<bool>*)o)->capacity)());
  else   (((const ::std::vector<bool>*)o)->capacity)();
}

static  void method_6422( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<bool>*)o)->empty)());
  else   (((const ::std::vector<bool>*)o)->empty)();
}

static  void operator_6423( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Bit_reference)((((::std::vector<bool>*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((::std::vector<bool>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_6424( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<bool>*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::std::vector<bool>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_6426( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Bit_reference)((((::std::vector<bool>*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((::std::vector<bool>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6427( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<bool>*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((const ::std::vector<bool>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6428( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<bool>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_6429( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Bit_reference)((((::std::vector<bool>*)o)->front)());
  else   (((::std::vector<bool>*)o)->front)();
}

static  void method_6430( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<bool>*)o)->front)());
  else   (((const ::std::vector<bool>*)o)->front)();
}

static  void method_6431( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Bit_reference)((((::std::vector<bool>*)o)->back)());
  else   (((::std::vector<bool>*)o)->back)();
}

static  void method_6432( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<bool>*)o)->back)());
  else   (((const ::std::vector<bool>*)o)->back)();
}

static  void method_6433( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<bool>*)o)->data)();
}

static  void method_6434( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<bool>*)o)->push_back)(*(bool*)arg[0]);
}

static  void method_6435( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<bool>*)o)->swap)(*(::std::vector<bool>*)arg[0]);
}

static  void method_6436( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<bool>*)o)->swap)(*(::std::_Bit_reference*)arg[0],
    *(::std::_Bit_reference*)arg[1]);
}

static  void method_6437( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::_Bit_iterator)((((::std::vector<bool>*)o)->insert)(*(::std::_Bit_iterator*)arg[0]));
    else     (((::std::vector<bool>*)o)->insert)(*(::std::_Bit_iterator*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::_Bit_iterator)((((::std::vector<bool>*)o)->insert)(*(::std::_Bit_iterator*)arg[0],
      *(const bool*)arg[1]));
    else     (((::std::vector<bool>*)o)->insert)(*(::std::_Bit_iterator*)arg[0],
      *(const bool*)arg[1]);
  }
}

static  void method_6438( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<bool>*)o)->insert)(*(::std::_Bit_iterator*)arg[0],
    *(::std::size_t*)arg[1],
    *(const bool*)arg[2]);
}

static  void method_6439( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<bool>*)o)->pop_back)();
}

static  void method_6440( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Bit_iterator)((((::std::vector<bool>*)o)->erase)(*(::std::_Bit_iterator*)arg[0]));
  else   (((::std::vector<bool>*)o)->erase)(*(::std::_Bit_iterator*)arg[0]);
}

static  void method_6441( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Bit_iterator)((((::std::vector<bool>*)o)->erase)(*(::std::_Bit_iterator*)arg[0],
    *(::std::_Bit_iterator*)arg[1]));
  else   (((::std::vector<bool>*)o)->erase)(*(::std::_Bit_iterator*)arg[0],
    *(::std::_Bit_iterator*)arg[1]);
}

static  void method_6442( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<bool>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<bool>*)o)->resize)(*(::std::size_t*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_6443( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<bool>*)o)->flip)();
}

static  void method_6444( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<bool>*)o)->clear)();
}

static void method_newdel_1092( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<bool> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<bool> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<bool> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<bool> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<bool> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x208( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Bvector_base<std::allocator<bool> >")), ::Reflex::BaseOffset< ::std::vector<bool>,::std::_Bvector_base<std::allocator<bool> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x209( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<bool> >::Generate();
  else ::Reflex::Proxy< ::std::vector<bool> >::Generate();
}

//------Dictionary for class vector<bool,std::allocator<bool> > -------------------------------
void __std__vector_bool__db_datamem(Reflex::Class*);
void __std__vector_bool__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_bool__datamem_bld(&__std__vector_bool__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_bool__funcmem_bld(&__std__vector_bool__db_funcmem);
void __std__vector_bool__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<bool>"), typeid(::std::vector<bool>), sizeof(::std::vector<bool>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1588, ::Reflex::BaseOffset< ::std::vector<bool>, ::std::_Bvector_base<std::allocator<bool> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1588, Reflex::Literal("std::vector<bool>::_Base"))
  .AddTypedef(type_2083, Reflex::Literal("std::vector<bool>::value_type"))
  .AddTypedef(type_1654, Reflex::Literal("std::vector<bool>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::vector<bool>::difference_type"))
  .AddTypedef(type_1110, Reflex::Literal("std::vector<bool>::reference"))
  .AddTypedef(type_2083, Reflex::Literal("std::vector<bool>::const_reference"))
  .AddTypedef(type_3619, Reflex::Literal("std::vector<bool>::pointer"))
  .AddTypedef(type_3609, Reflex::Literal("std::vector<bool>::const_pointer"))
  .AddTypedef(type_1297, Reflex::Literal("std::vector<bool>::iterator"))
  .AddTypedef(type_1886, Reflex::Literal("std::vector<bool>::const_iterator"))
  .AddTypedef(type_1772, Reflex::Literal("std::vector<bool>::const_reverse_iterator"))
  .AddTypedef(type_1773, Reflex::Literal("std::vector<bool>::reverse_iterator"))
  .AddTypedef(type_1371, Reflex::Literal("std::vector<bool>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_6404, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20422), Reflex::Literal("vector"), constructor_6405, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_11878, type_20422), Reflex::Literal("vector"), constructor_6406, 0, "__n;__value=bool();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20423), Reflex::Literal("vector"), constructor_6407, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_6408, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1092, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x208, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x209, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_bool__funcmem_bld);
}

//------Delayed data member builder for class vector<bool,std::allocator<bool> > -------------------
void __std__vector_bool__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<bool,std::allocator<bool> > -------------------
void __std__vector_bool__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1371), Reflex::Literal("get_allocator"), method_6403, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20424, type_20423), Reflex::Literal("operator="), operator_6409, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_11878), Reflex::Literal("assign"), method_6410, 0, "__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1297), Reflex::Literal("begin"), method_6411, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1886), Reflex::Literal("begin"), method_6412, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1297), Reflex::Literal("end"), method_6413, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1886), Reflex::Literal("end"), method_6414, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_6419, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_6420, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("capacity"), method_6421, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_6422, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1110, type_1654), Reflex::Literal("operator[]"), operator_6423, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083, type_1654), Reflex::Literal("operator[]"), operator_6424, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1110, type_1654), Reflex::Literal("at"), method_6426, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083, type_1654), Reflex::Literal("at"), method_6427, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654), Reflex::Literal("reserve"), method_6428, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1110), Reflex::Literal("front"), method_6429, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("front"), method_6430, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1110), Reflex::Literal("back"), method_6431, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("back"), method_6432, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("data"), method_6433, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2083), Reflex::Literal("push_back"), method_6434, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_20424), Reflex::Literal("swap"), method_6435, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1110, type_1110), Reflex::Literal("swap"), method_6436, 0, "__x;__y", ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1297, type_1297, type_11878), Reflex::Literal("insert"), method_6437, 0, "__position;__x=bool()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1297, type_1654, type_11878), Reflex::Literal("insert"), method_6438, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_6439, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1297, type_1297), Reflex::Literal("erase"), method_6440, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1297, type_1297, type_1297), Reflex::Literal("erase"), method_6441, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_2083), Reflex::Literal("resize"), method_6442, 0, "__new_size;__x=bool()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("flip"), method_6443, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_6444, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class forward_iterator_tag -------------------------------
static void destructor_11292(void*, void * o, const std::vector<void*>&, void *) {
(((::std::forward_iterator_tag*)o)->::std::forward_iterator_tag::~forward_iterator_tag)();
}
static  void operator_11293( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::forward_iterator_tag*)o)->operator=)(*(const ::std::forward_iterator_tag*)arg[0]);
  else   (((::std::forward_iterator_tag*)o)->operator=)(*(const ::std::forward_iterator_tag*)arg[0]);
}

static void constructor_11294( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::forward_iterator_tag(*(const ::std::forward_iterator_tag*)arg[0]);
  else ::new(mem) ::std::forward_iterator_tag(*(const ::std::forward_iterator_tag*)arg[0]);
}

static void constructor_11295( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::forward_iterator_tag();
  else ::new(mem) ::std::forward_iterator_tag();
}

static void method_newdel_1292( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::forward_iterator_tag >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::forward_iterator_tag >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::forward_iterator_tag >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::forward_iterator_tag >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::forward_iterator_tag >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x211( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::input_iterator_tag")), ::Reflex::BaseOffset< ::std::forward_iterator_tag,::std::input_iterator_tag >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class forward_iterator_tag -------------------------------
void __std__forward_iterator_tag_db_datamem(Reflex::Class*);
void __std__forward_iterator_tag_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__forward_iterator_tag_datamem_bld(&__std__forward_iterator_tag_db_datamem);
Reflex::GenreflexMemberBuilder __std__forward_iterator_tag_funcmem_bld(&__std__forward_iterator_tag_db_funcmem);
void __std__forward_iterator_tag_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::forward_iterator_tag"), typeid(::std::forward_iterator_tag), sizeof(::std::forward_iterator_tag), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddBase(type_1018, ::Reflex::BaseOffset< ::std::forward_iterator_tag, ::std::input_iterator_tag >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~forward_iterator_tag"), destructor_11292, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20877, type_20878), Reflex::Literal("operator="), operator_11293, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20878), Reflex::Literal("forward_iterator_tag"), constructor_11294, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("forward_iterator_tag"), constructor_11295, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1292, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x211, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class forward_iterator_tag -------------------
void __std__forward_iterator_tag_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class forward_iterator_tag -------------------
void __std__forward_iterator_tag_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class random_access_iterator_tag -------------------------------
static void destructor_11383(void*, void * o, const std::vector<void*>&, void *) {
(((::std::random_access_iterator_tag*)o)->::std::random_access_iterator_tag::~random_access_iterator_tag)();
}
static  void operator_11384( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::random_access_iterator_tag*)o)->operator=)(*(const ::std::random_access_iterator_tag*)arg[0]);
  else   (((::std::random_access_iterator_tag*)o)->operator=)(*(const ::std::random_access_iterator_tag*)arg[0]);
}

static void constructor_11385( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::random_access_iterator_tag(*(const ::std::random_access_iterator_tag*)arg[0]);
  else ::new(mem) ::std::random_access_iterator_tag(*(const ::std::random_access_iterator_tag*)arg[0]);
}

static void constructor_11386( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::random_access_iterator_tag();
  else ::new(mem) ::std::random_access_iterator_tag();
}

static void method_newdel_1326( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::random_access_iterator_tag >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::random_access_iterator_tag >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::random_access_iterator_tag >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::random_access_iterator_tag >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::random_access_iterator_tag >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x213( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::bidirectional_iterator_tag")), ::Reflex::BaseOffset< ::std::random_access_iterator_tag,::std::bidirectional_iterator_tag >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::forward_iterator_tag")), ::Reflex::BaseOffset< ::std::random_access_iterator_tag,::std::forward_iterator_tag >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::input_iterator_tag")), ::Reflex::BaseOffset< ::std::random_access_iterator_tag,::std::input_iterator_tag >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class random_access_iterator_tag -------------------------------
void __std__random_access_iterator_tag_db_datamem(Reflex::Class*);
void __std__random_access_iterator_tag_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__random_access_iterator_tag_datamem_bld(&__std__random_access_iterator_tag_db_datamem);
Reflex::GenreflexMemberBuilder __std__random_access_iterator_tag_funcmem_bld(&__std__random_access_iterator_tag_db_funcmem);
void __std__random_access_iterator_tag_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::random_access_iterator_tag"), typeid(::std::random_access_iterator_tag), sizeof(::std::random_access_iterator_tag), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddBase(type_2006, ::Reflex::BaseOffset< ::std::random_access_iterator_tag, ::std::bidirectional_iterator_tag >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~random_access_iterator_tag"), destructor_11383, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20899, type_20900), Reflex::Literal("operator="), operator_11384, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20900), Reflex::Literal("random_access_iterator_tag"), constructor_11385, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("random_access_iterator_tag"), constructor_11386, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1326, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x213, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class random_access_iterator_tag -------------------
void __std__random_access_iterator_tag_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class random_access_iterator_tag -------------------
void __std__random_access_iterator_tag_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class allocator<int> -------------------------------
static  void operator_11526( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::allocator<int>*)o)->operator=)(*(const ::std::allocator<int>*)arg[0]);
  else   (((::std::allocator<int>*)o)->operator=)(*(const ::std::allocator<int>*)arg[0]);
}

static void constructor_11527( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<int>();
  else ::new(mem) ::std::allocator<int>();
}

static void constructor_11528( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<int>(*(const ::std::allocator<int>*)arg[0]);
  else ::new(mem) ::std::allocator<int>(*(const ::std::allocator<int>*)arg[0]);
}

static void destructor_11529(void*, void * o, const std::vector<void*>&, void *) {
(((::std::allocator<int>*)o)->::std::allocator<int>::~allocator)();
}
static void method_newdel_1339( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::allocator<int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::allocator<int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::allocator<int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::allocator<int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::allocator<int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x215( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<int>")), ::Reflex::BaseOffset< ::std::allocator<int>,::__gnu_cxx::new_allocator<int> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class allocator<int> -------------------------------
void __std__allocator_int__db_datamem(Reflex::Class*);
void __std__allocator_int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__allocator_int__datamem_bld(&__std__allocator_int__db_datamem);
Reflex::GenreflexMemberBuilder __std__allocator_int__funcmem_bld(&__std__allocator_int__db_funcmem);
void __std__allocator_int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::allocator<int>"), typeid(::std::allocator<int>), sizeof(::std::allocator<int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2280, ::Reflex::BaseOffset< ::std::allocator<int>, ::__gnu_cxx::new_allocator<int> >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_1654, Reflex::Literal("std::allocator<int>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::allocator<int>::difference_type"))
  .AddTypedef(type_2054, Reflex::Literal("std::allocator<int>::pointer"))
  .AddTypedef(type_4401, Reflex::Literal("std::allocator<int>::const_pointer"))
  .AddTypedef(type_3569, Reflex::Literal("std::allocator<int>::reference"))
  .AddTypedef(type_4404, Reflex::Literal("std::allocator<int>::const_reference"))
  .AddTypedef(type_22, Reflex::Literal("std::allocator<int>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20896, type_20319), Reflex::Literal("operator="), operator_11526, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("allocator"), constructor_11527, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20319), Reflex::Literal("allocator"), constructor_11528, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~allocator"), destructor_11529, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1339, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x215, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class allocator<int> -------------------
void __std__allocator_int__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class allocator<int> -------------------
void __std__allocator_int__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class allocator<short int> -------------------------------
static  void operator_11570( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::allocator<short>*)o)->operator=)(*(const ::std::allocator<short>*)arg[0]);
  else   (((::std::allocator<short>*)o)->operator=)(*(const ::std::allocator<short>*)arg[0]);
}

static void constructor_11571( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<short>();
  else ::new(mem) ::std::allocator<short>();
}

static void constructor_11572( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<short>(*(const ::std::allocator<short>*)arg[0]);
  else ::new(mem) ::std::allocator<short>(*(const ::std::allocator<short>*)arg[0]);
}

static void destructor_11573(void*, void * o, const std::vector<void*>&, void *) {
(((::std::allocator<short>*)o)->::std::allocator<short>::~allocator)();
}
static void method_newdel_1343( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::allocator<short> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::allocator<short> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::allocator<short> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::allocator<short> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::allocator<short> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x217( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<short>")), ::Reflex::BaseOffset< ::std::allocator<short>,::__gnu_cxx::new_allocator<short> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class allocator<short int> -------------------------------
void __std__allocator_short__db_datamem(Reflex::Class*);
void __std__allocator_short__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__allocator_short__datamem_bld(&__std__allocator_short__db_datamem);
Reflex::GenreflexMemberBuilder __std__allocator_short__funcmem_bld(&__std__allocator_short__db_funcmem);
void __std__allocator_short__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::allocator<short>"), typeid(::std::allocator<short>), sizeof(::std::allocator<short>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2279, ::Reflex::BaseOffset< ::std::allocator<short>, ::__gnu_cxx::new_allocator<short> >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_1654, Reflex::Literal("std::allocator<short>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::allocator<short>::difference_type"))
  .AddTypedef(type_3525, Reflex::Literal("std::allocator<short>::pointer"))
  .AddTypedef(type_4659, Reflex::Literal("std::allocator<short>::const_pointer"))
  .AddTypedef(type_3527, Reflex::Literal("std::allocator<short>::reference"))
  .AddTypedef(type_4662, Reflex::Literal("std::allocator<short>::const_reference"))
  .AddTypedef(type_113, Reflex::Literal("std::allocator<short>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20916, type_20330), Reflex::Literal("operator="), operator_11570, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("allocator"), constructor_11571, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20330), Reflex::Literal("allocator"), constructor_11572, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~allocator"), destructor_11573, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1343, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x217, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class allocator<short int> -------------------
void __std__allocator_short__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class allocator<short int> -------------------
void __std__allocator_short__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class allocator<double> -------------------------------
static  void operator_11614( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::allocator<double>*)o)->operator=)(*(const ::std::allocator<double>*)arg[0]);
  else   (((::std::allocator<double>*)o)->operator=)(*(const ::std::allocator<double>*)arg[0]);
}

static void constructor_11615( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<double>();
  else ::new(mem) ::std::allocator<double>();
}

static void constructor_11616( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<double>(*(const ::std::allocator<double>*)arg[0]);
  else ::new(mem) ::std::allocator<double>(*(const ::std::allocator<double>*)arg[0]);
}

static void destructor_11617(void*, void * o, const std::vector<void*>&, void *) {
(((::std::allocator<double>*)o)->::std::allocator<double>::~allocator)();
}
static void method_newdel_1347( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::allocator<double> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::allocator<double> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::allocator<double> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::allocator<double> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::allocator<double> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x219( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<double>")), ::Reflex::BaseOffset< ::std::allocator<double>,::__gnu_cxx::new_allocator<double> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class allocator<double> -------------------------------
void __std__allocator_double__db_datamem(Reflex::Class*);
void __std__allocator_double__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__allocator_double__datamem_bld(&__std__allocator_double__db_datamem);
Reflex::GenreflexMemberBuilder __std__allocator_double__funcmem_bld(&__std__allocator_double__db_funcmem);
void __std__allocator_double__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::allocator<double>"), typeid(::std::allocator<double>), sizeof(::std::allocator<double>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2281, ::Reflex::BaseOffset< ::std::allocator<double>, ::__gnu_cxx::new_allocator<double> >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_1654, Reflex::Literal("std::allocator<double>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::allocator<double>::difference_type"))
  .AddTypedef(type_3588, Reflex::Literal("std::allocator<double>::pointer"))
  .AddTypedef(type_4915, Reflex::Literal("std::allocator<double>::const_pointer"))
  .AddTypedef(type_3590, Reflex::Literal("std::allocator<double>::reference"))
  .AddTypedef(type_4918, Reflex::Literal("std::allocator<double>::const_reference"))
  .AddTypedef(type_2052, Reflex::Literal("std::allocator<double>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20920, type_20342), Reflex::Literal("operator="), operator_11614, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("allocator"), constructor_11615, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20342), Reflex::Literal("allocator"), constructor_11616, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~allocator"), destructor_11617, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1347, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x219, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class allocator<double> -------------------
void __std__allocator_double__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class allocator<double> -------------------
void __std__allocator_double__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class allocator<char> -------------------------------
static  void operator_11647( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::allocator<char>*)o)->operator=)(*(const ::std::allocator<char>*)arg[0]);
  else   (((::std::allocator<char>*)o)->operator=)(*(const ::std::allocator<char>*)arg[0]);
}

static void constructor_11648( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<char>();
  else ::new(mem) ::std::allocator<char>();
}

static void constructor_11649( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::allocator<char>(*(const ::std::allocator<char>*)arg[0]);
  else ::new(mem) ::std::allocator<char>(*(const ::std::allocator<char>*)arg[0]);
}

static void destructor_11650(void*, void * o, const std::vector<void*>&, void *) {
(((::std::allocator<char>*)o)->::std::allocator<char>::~allocator)();
}
static void method_newdel_1350( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::allocator<char> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::allocator<char> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::allocator<char> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::allocator<char> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::allocator<char> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x221( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::new_allocator<char>")), ::Reflex::BaseOffset< ::std::allocator<char>,::__gnu_cxx::new_allocator<char> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class allocator<char> -------------------------------
void __std__allocator_char__db_datamem(Reflex::Class*);
void __std__allocator_char__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__allocator_char__datamem_bld(&__std__allocator_char__db_datamem);
Reflex::GenreflexMemberBuilder __std__allocator_char__funcmem_bld(&__std__allocator_char__db_funcmem);
void __std__allocator_char__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::allocator<char>"), typeid(::std::allocator<char>), sizeof(::std::allocator<char>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddBase(type_2283, ::Reflex::BaseOffset< ::std::allocator<char>, ::__gnu_cxx::new_allocator<char> >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_1654, Reflex::Literal("std::allocator<char>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::allocator<char>::difference_type"))
  .AddTypedef(type_791, Reflex::Literal("std::allocator<char>::pointer"))
  .AddTypedef(type_2053, Reflex::Literal("std::allocator<char>::const_pointer"))
  .AddTypedef(type_3600, Reflex::Literal("std::allocator<char>::reference"))
  .AddTypedef(type_6272, Reflex::Literal("std::allocator<char>::const_reference"))
  .AddTypedef(type_2616, Reflex::Literal("std::allocator<char>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20923, type_20416), Reflex::Literal("operator="), operator_11647, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("allocator"), constructor_11648, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20416), Reflex::Literal("allocator"), constructor_11649, 0, "__a", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~allocator"), destructor_11650, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1350, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x221, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class allocator<char> -------------------
void __std__allocator_char__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class allocator<char> -------------------
void __std__allocator_char__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class set<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > -------------------------------
static void destructor_13534(void*, void * o, const std::vector<void*>&, void *) {
(((::std::set<std::basic_string<char> >*)o)->::std::set<std::basic_string<char> >::~set)();
}
static void constructor_13535( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::set<std::basic_string<char> >();
  else ::new(mem) ::std::set<std::basic_string<char> >();
}

static void constructor_13536( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::set<std::basic_string<char> >(*(const ::std::less<std::basic_string<char> >*)arg[0]);
  else ::new(mem) ::std::set<std::basic_string<char> >(*(const ::std::less<std::basic_string<char> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::set<std::basic_string<char> >(*(const ::std::less<std::basic_string<char> >*)arg[0],
      *(const ::std::allocator<std::basic_string<char> >*)arg[1]);
  else ::new(mem) ::std::set<std::basic_string<char> >(*(const ::std::less<std::basic_string<char> >*)arg[0],
      *(const ::std::allocator<std::basic_string<char> >*)arg[1]);
  }
}

static void constructor_13537( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::set<std::basic_string<char> >(*(const ::std::set<std::basic_string<char> >*)arg[0]);
  else ::new(mem) ::std::set<std::basic_string<char> >(*(const ::std::set<std::basic_string<char> >*)arg[0]);
}

static  void operator_13538( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::set<std::basic_string<char> >*)o)->operator=)(*(const ::std::set<std::basic_string<char> >*)arg[0]);
  else   (((::std::set<std::basic_string<char> >*)o)->operator=)(*(const ::std::set<std::basic_string<char> >*)arg[0]);
}

static  void method_13539( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<std::basic_string<char> >)((((const ::std::set<std::basic_string<char> >*)o)->key_comp)());
  else   (((const ::std::set<std::basic_string<char> >*)o)->key_comp)();
}

static  void method_13541( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::basic_string<char> >)((((const ::std::set<std::basic_string<char> >*)o)->get_allocator)());
  else   (((const ::std::set<std::basic_string<char> >*)o)->get_allocator)();
}

static  void method_13542( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::basic_string<char> >)((((const ::std::set<std::basic_string<char> >*)o)->begin)());
  else   (((const ::std::set<std::basic_string<char> >*)o)->begin)();
}

static  void method_13543( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::basic_string<char> >)((((const ::std::set<std::basic_string<char> >*)o)->end)());
  else   (((const ::std::set<std::basic_string<char> >*)o)->end)();
}

static  void method_13546( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::set<std::basic_string<char> >*)o)->empty)());
  else   (((const ::std::set<std::basic_string<char> >*)o)->empty)();
}

static  void method_13547( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::set<std::basic_string<char> >*)o)->size)());
  else   (((const ::std::set<std::basic_string<char> >*)o)->size)();
}

static  void method_13548( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::set<std::basic_string<char> >*)o)->max_size)());
  else   (((const ::std::set<std::basic_string<char> >*)o)->max_size)();
}

static  void method_13549( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::set<std::basic_string<char> >*)o)->swap)(*(::std::set<std::basic_string<char> >*)arg[0]);
}

static  void method_13550( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::basic_string<char> >,bool>)((((::std::set<std::basic_string<char> >*)o)->insert)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::set<std::basic_string<char> >*)o)->insert)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13551( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::basic_string<char> >)((((::std::set<std::basic_string<char> >*)o)->insert)(*(::std::_Rb_tree_const_iterator<std::basic_string<char> >*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]));
  else   (((::std::set<std::basic_string<char> >*)o)->insert)(*(::std::_Rb_tree_const_iterator<std::basic_string<char> >*)arg[0],
    *(const ::std::basic_string<char>*)arg[1]);
}

static  void method_13552( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::set<std::basic_string<char> >*)o)->erase)(*(::std::_Rb_tree_const_iterator<std::basic_string<char> >*)arg[0]);
}

static  void method_13553( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::set<std::basic_string<char> >*)o)->erase)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::set<std::basic_string<char> >*)o)->erase)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13554( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::set<std::basic_string<char> >*)o)->erase)(*(::std::_Rb_tree_const_iterator<std::basic_string<char> >*)arg[0],
    *(::std::_Rb_tree_const_iterator<std::basic_string<char> >*)arg[1]);
}

static  void method_13555( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::set<std::basic_string<char> >*)o)->clear)();
}

static  void method_13556( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::set<std::basic_string<char> >*)o)->count)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::set<std::basic_string<char> >*)o)->count)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13557( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::basic_string<char> >)((((::std::set<std::basic_string<char> >*)o)->find)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::set<std::basic_string<char> >*)o)->find)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13558( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::basic_string<char> >)((((const ::std::set<std::basic_string<char> >*)o)->find)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::set<std::basic_string<char> >*)o)->find)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13559( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::basic_string<char> >)((((::std::set<std::basic_string<char> >*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::set<std::basic_string<char> >*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13560( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::basic_string<char> >)((((const ::std::set<std::basic_string<char> >*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::set<std::basic_string<char> >*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13561( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::basic_string<char> >)((((::std::set<std::basic_string<char> >*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::set<std::basic_string<char> >*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13562( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::basic_string<char> >)((((const ::std::set<std::basic_string<char> >*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::set<std::basic_string<char> >*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13563( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::basic_string<char> >,std::_Rb_tree_const_iterator<std::basic_string<char> > >)((((::std::set<std::basic_string<char> >*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::set<std::basic_string<char> >*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13564( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::basic_string<char> >,std::_Rb_tree_const_iterator<std::basic_string<char> > >)((((const ::std::set<std::basic_string<char> >*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::set<std::basic_string<char> >*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]);
}

static void method_newdel_1585( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::set<std::basic_string<char> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::set<std::basic_string<char> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::set<std::basic_string<char> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::set<std::basic_string<char> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::set<std::basic_string<char> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x223( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::set<std::basic_string<char> > >::Generate();
  else ::Reflex::Proxy< ::std::set<std::basic_string<char> > >::Generate();
}

//------Dictionary for class set<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > -------------------------------
void __std__set_std__basic_string_char_s__db_datamem(Reflex::Class*);
void __std__set_std__basic_string_char_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__set_std__basic_string_char_s__datamem_bld(&__std__set_std__basic_string_char_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__set_std__basic_string_char_s__funcmem_bld(&__std__set_std__basic_string_char_s__db_funcmem);
void __std__set_std__basic_string_char_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::set<std::basic_string<char> >"), typeid(::std::set<std::basic_string<char> >), sizeof(::std::set<std::basic_string<char> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1104, Reflex::Literal("std::set<std::basic_string<char> >::_Alloc_value_type"))
  .AddTypedef(type_1104, Reflex::Literal("std::set<std::basic_string<char> >::key_type"))
  .AddTypedef(type_1104, Reflex::Literal("std::set<std::basic_string<char> >::value_type"))
  .AddTypedef(type_2023, Reflex::Literal("std::set<std::basic_string<char> >::key_compare"))
  .AddTypedef(type_2023, Reflex::Literal("std::set<std::basic_string<char> >::value_compare"))
  .AddTypedef(type_1348, Reflex::Literal("std::set<std::basic_string<char> >::allocator_type"))
  .AddTypedef(type_1348, Reflex::Literal("std::set<std::basic_string<char> >::_Key_alloc_type"))
  .AddTypedef(type_1111, Reflex::Literal("std::set<std::basic_string<char> >::_Rep_type"))
  .AddTypedef(type_3514, Reflex::Literal("std::set<std::basic_string<char> >::pointer"))
  .AddTypedef(type_4978, Reflex::Literal("std::set<std::basic_string<char> >::const_pointer"))
  .AddTypedef(type_3516, Reflex::Literal("std::set<std::basic_string<char> >::reference"))
  .AddTypedef(type_4981, Reflex::Literal("std::set<std::basic_string<char> >::const_reference"))
  .AddTypedef(type_1889, Reflex::Literal("std::set<std::basic_string<char> >::iterator"))
  .AddTypedef(type_1889, Reflex::Literal("std::set<std::basic_string<char> >::const_iterator"))
  .AddTypedef(type_1774, Reflex::Literal("std::set<std::basic_string<char> >::reverse_iterator"))
  .AddTypedef(type_1774, Reflex::Literal("std::set<std::basic_string<char> >::const_reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::set<std::basic_string<char> >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::set<std::basic_string<char> >::difference_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~set"), destructor_13534, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("set"), constructor_13535, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20471, type_20343), Reflex::Literal("set"), constructor_13536, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21247), Reflex::Literal("set"), constructor_13537, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1585, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x223, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__set_std__basic_string_char_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__set_std__basic_string_char_s__funcmem_bld);
}

//------Delayed data member builder for class set<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > -------------------
void __std__set_std__basic_string_char_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1111, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__set_std__basic_string_char_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class set<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > -------------------
void __std__set_std__basic_string_char_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21248, type_21247), Reflex::Literal("operator="), operator_13538, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2023), Reflex::Literal("key_comp"), method_13539, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1348), Reflex::Literal("get_allocator"), method_13541, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1889), Reflex::Literal("begin"), method_13542, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1889), Reflex::Literal("end"), method_13543, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_13546, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_13547, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_13548, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_21248), Reflex::Literal("swap"), method_13549, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_830, type_4981), Reflex::Literal("insert"), method_13550, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1889, type_1889, type_4981), Reflex::Literal("insert"), method_13551, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1889), Reflex::Literal("erase"), method_13552, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4981), Reflex::Literal("erase"), method_13553, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1889, type_1889), Reflex::Literal("erase"), method_13554, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_13555, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4981), Reflex::Literal("count"), method_13556, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1889, type_4981), Reflex::Literal("find"), method_13557, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1889, type_4981), Reflex::Literal("find"), method_13558, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1889, type_4981), Reflex::Literal("lower_bound"), method_13559, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1889, type_4981), Reflex::Literal("lower_bound"), method_13560, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1889, type_4981), Reflex::Literal("upper_bound"), method_13561, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1889, type_4981), Reflex::Literal("upper_bound"), method_13562, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_829, type_4981), Reflex::Literal("equal_range"), method_13563, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_829, type_4981), Reflex::Literal("equal_range"), method_13564, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class set<int,std::less<int>,std::allocator<int> > -------------------------------
static void destructor_13584(void*, void * o, const std::vector<void*>&, void *) {
(((::std::set<int>*)o)->::std::set<int>::~set)();
}
static void constructor_13585( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::set<int>();
  else ::new(mem) ::std::set<int>();
}

static void constructor_13586( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::set<int>(*(const ::std::less<int>*)arg[0]);
  else ::new(mem) ::std::set<int>(*(const ::std::less<int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::set<int>(*(const ::std::less<int>*)arg[0],
      *(const ::std::allocator<int>*)arg[1]);
  else ::new(mem) ::std::set<int>(*(const ::std::less<int>*)arg[0],
      *(const ::std::allocator<int>*)arg[1]);
  }
}

static void constructor_13587( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::set<int>(*(const ::std::set<int>*)arg[0]);
  else ::new(mem) ::std::set<int>(*(const ::std::set<int>*)arg[0]);
}

static  void operator_13588( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::set<int>*)o)->operator=)(*(const ::std::set<int>*)arg[0]);
  else   (((::std::set<int>*)o)->operator=)(*(const ::std::set<int>*)arg[0]);
}

static  void method_13589( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<int>)((((const ::std::set<int>*)o)->key_comp)());
  else   (((const ::std::set<int>*)o)->key_comp)();
}

static  void method_13591( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<int>)((((const ::std::set<int>*)o)->get_allocator)());
  else   (((const ::std::set<int>*)o)->get_allocator)();
}

static  void method_13592( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<int>)((((const ::std::set<int>*)o)->begin)());
  else   (((const ::std::set<int>*)o)->begin)();
}

static  void method_13593( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<int>)((((const ::std::set<int>*)o)->end)());
  else   (((const ::std::set<int>*)o)->end)();
}

static  void method_13596( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::set<int>*)o)->empty)());
  else   (((const ::std::set<int>*)o)->empty)();
}

static  void method_13597( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::set<int>*)o)->size)());
  else   (((const ::std::set<int>*)o)->size)();
}

static  void method_13598( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::set<int>*)o)->max_size)());
  else   (((const ::std::set<int>*)o)->max_size)();
}

static  void method_13599( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::set<int>*)o)->swap)(*(::std::set<int>*)arg[0]);
}

static  void method_13600( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<int>,bool>)((((::std::set<int>*)o)->insert)(*(const int*)arg[0]));
  else   (((::std::set<int>*)o)->insert)(*(const int*)arg[0]);
}

static  void method_13601( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<int>)((((::std::set<int>*)o)->insert)(*(::std::_Rb_tree_const_iterator<int>*)arg[0],
    *(const int*)arg[1]));
  else   (((::std::set<int>*)o)->insert)(*(::std::_Rb_tree_const_iterator<int>*)arg[0],
    *(const int*)arg[1]);
}

static  void method_13602( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::set<int>*)o)->erase)(*(::std::_Rb_tree_const_iterator<int>*)arg[0]);
}

static  void method_13603( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::set<int>*)o)->erase)(*(const int*)arg[0]));
  else   (((::std::set<int>*)o)->erase)(*(const int*)arg[0]);
}

static  void method_13604( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::set<int>*)o)->erase)(*(::std::_Rb_tree_const_iterator<int>*)arg[0],
    *(::std::_Rb_tree_const_iterator<int>*)arg[1]);
}

static  void method_13605( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::set<int>*)o)->clear)();
}

static  void method_13606( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::set<int>*)o)->count)(*(const int*)arg[0]));
  else   (((const ::std::set<int>*)o)->count)(*(const int*)arg[0]);
}

static  void method_13607( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<int>)((((::std::set<int>*)o)->find)(*(const int*)arg[0]));
  else   (((::std::set<int>*)o)->find)(*(const int*)arg[0]);
}

static  void method_13608( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<int>)((((const ::std::set<int>*)o)->find)(*(const int*)arg[0]));
  else   (((const ::std::set<int>*)o)->find)(*(const int*)arg[0]);
}

static  void method_13609( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<int>)((((::std::set<int>*)o)->lower_bound)(*(const int*)arg[0]));
  else   (((::std::set<int>*)o)->lower_bound)(*(const int*)arg[0]);
}

static  void method_13610( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<int>)((((const ::std::set<int>*)o)->lower_bound)(*(const int*)arg[0]));
  else   (((const ::std::set<int>*)o)->lower_bound)(*(const int*)arg[0]);
}

static  void method_13611( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<int>)((((::std::set<int>*)o)->upper_bound)(*(const int*)arg[0]));
  else   (((::std::set<int>*)o)->upper_bound)(*(const int*)arg[0]);
}

static  void method_13612( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<int>)((((const ::std::set<int>*)o)->upper_bound)(*(const int*)arg[0]));
  else   (((const ::std::set<int>*)o)->upper_bound)(*(const int*)arg[0]);
}

static  void method_13613( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<int>,std::_Rb_tree_const_iterator<int> >)((((::std::set<int>*)o)->equal_range)(*(const int*)arg[0]));
  else   (((::std::set<int>*)o)->equal_range)(*(const int*)arg[0]);
}

static  void method_13614( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<int>,std::_Rb_tree_const_iterator<int> >)((((const ::std::set<int>*)o)->equal_range)(*(const int*)arg[0]));
  else   (((const ::std::set<int>*)o)->equal_range)(*(const int*)arg[0]);
}

static void method_newdel_1586( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::set<int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::set<int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::set<int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::set<int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::set<int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x225( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::set<int> >::Generate();
  else ::Reflex::Proxy< ::std::set<int> >::Generate();
}

//------Dictionary for class set<int,std::less<int>,std::allocator<int> > -------------------------------
void __std__set_int__db_datamem(Reflex::Class*);
void __std__set_int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__set_int__datamem_bld(&__std__set_int__db_datamem);
Reflex::GenreflexMemberBuilder __std__set_int__funcmem_bld(&__std__set_int__db_funcmem);
void __std__set_int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::set<int>"), typeid(::std::set<int>), sizeof(::std::set<int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_22, Reflex::Literal("std::set<int>::_Alloc_value_type"))
  .AddTypedef(type_22, Reflex::Literal("std::set<int>::key_type"))
  .AddTypedef(type_22, Reflex::Literal("std::set<int>::value_type"))
  .AddTypedef(type_2024, Reflex::Literal("std::set<int>::key_compare"))
  .AddTypedef(type_2024, Reflex::Literal("std::set<int>::value_compare"))
  .AddTypedef(type_1339, Reflex::Literal("std::set<int>::allocator_type"))
  .AddTypedef(type_1339, Reflex::Literal("std::set<int>::_Key_alloc_type"))
  .AddTypedef(type_1112, Reflex::Literal("std::set<int>::_Rep_type"))
  .AddTypedef(type_2054, Reflex::Literal("std::set<int>::pointer"))
  .AddTypedef(type_4401, Reflex::Literal("std::set<int>::const_pointer"))
  .AddTypedef(type_3569, Reflex::Literal("std::set<int>::reference"))
  .AddTypedef(type_4404, Reflex::Literal("std::set<int>::const_reference"))
  .AddTypedef(type_1890, Reflex::Literal("std::set<int>::iterator"))
  .AddTypedef(type_1890, Reflex::Literal("std::set<int>::const_iterator"))
  .AddTypedef(type_1776, Reflex::Literal("std::set<int>::reverse_iterator"))
  .AddTypedef(type_1776, Reflex::Literal("std::set<int>::const_reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::set<int>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::set<int>::difference_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~set"), destructor_13584, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("set"), constructor_13585, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20477, type_20319), Reflex::Literal("set"), constructor_13586, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21249), Reflex::Literal("set"), constructor_13587, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1586, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x225, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__set_int__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__set_int__funcmem_bld);
}

//------Delayed data member builder for class set<int,std::less<int>,std::allocator<int> > -------------------
void __std__set_int__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1112, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__set_int_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class set<int,std::less<int>,std::allocator<int> > -------------------
void __std__set_int__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21250, type_21249), Reflex::Literal("operator="), operator_13588, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2024), Reflex::Literal("key_comp"), method_13589, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1339), Reflex::Literal("get_allocator"), method_13591, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1890), Reflex::Literal("begin"), method_13592, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1890), Reflex::Literal("end"), method_13593, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_13596, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_13597, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_13598, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_21250), Reflex::Literal("swap"), method_13599, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_834, type_4404), Reflex::Literal("insert"), method_13600, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1890, type_1890, type_4404), Reflex::Literal("insert"), method_13601, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1890), Reflex::Literal("erase"), method_13602, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4404), Reflex::Literal("erase"), method_13603, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1890, type_1890), Reflex::Literal("erase"), method_13604, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_13605, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4404), Reflex::Literal("count"), method_13606, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1890, type_4404), Reflex::Literal("find"), method_13607, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1890, type_4404), Reflex::Literal("find"), method_13608, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1890, type_4404), Reflex::Literal("lower_bound"), method_13609, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1890, type_4404), Reflex::Literal("lower_bound"), method_13610, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1890, type_4404), Reflex::Literal("upper_bound"), method_13611, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1890, type_4404), Reflex::Literal("upper_bound"), method_13612, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_833, type_4404), Reflex::Literal("equal_range"), method_13613, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_833, type_4404), Reflex::Literal("equal_range"), method_13614, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class output_iterator_tag -------------------------------
static void destructor_13630(void*, void * o, const std::vector<void*>&, void *) {
(((::std::output_iterator_tag*)o)->::std::output_iterator_tag::~output_iterator_tag)();
}
static  void operator_13631( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::output_iterator_tag*)o)->operator=)(*(const ::std::output_iterator_tag*)arg[0]);
  else   (((::std::output_iterator_tag*)o)->operator=)(*(const ::std::output_iterator_tag*)arg[0]);
}

static void constructor_13632( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::output_iterator_tag(*(const ::std::output_iterator_tag*)arg[0]);
  else ::new(mem) ::std::output_iterator_tag(*(const ::std::output_iterator_tag*)arg[0]);
}

static void constructor_13633( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::output_iterator_tag();
  else ::new(mem) ::std::output_iterator_tag();
}

static void method_newdel_1589( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::output_iterator_tag >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::output_iterator_tag >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::output_iterator_tag >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::output_iterator_tag >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::output_iterator_tag >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class output_iterator_tag -------------------------------
void __std__output_iterator_tag_db_datamem(Reflex::Class*);
void __std__output_iterator_tag_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__output_iterator_tag_datamem_bld(&__std__output_iterator_tag_db_datamem);
Reflex::GenreflexMemberBuilder __std__output_iterator_tag_funcmem_bld(&__std__output_iterator_tag_db_funcmem);
void __std__output_iterator_tag_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::output_iterator_tag"), typeid(::std::output_iterator_tag), sizeof(::std::output_iterator_tag), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~output_iterator_tag"), destructor_13630, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21272, type_21273), Reflex::Literal("operator="), operator_13631, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21273), Reflex::Literal("output_iterator_tag"), constructor_13632, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("output_iterator_tag"), constructor_13633, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1589, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class output_iterator_tag -------------------
void __std__output_iterator_tag_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class output_iterator_tag -------------------
void __std__output_iterator_tag_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class list<int,std::allocator<int> > -------------------------------
static void destructor_13654(void*, void * o, const std::vector<void*>&, void *) {
(((::std::list<int>*)o)->::std::list<int>::~list)();
}
static void constructor_13656( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::list<int>();
  else ::new(mem) ::std::list<int>();
}

static void constructor_13657( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::list<int>(*(const ::std::allocator<int>*)arg[0]);
  else ::new(mem) ::std::list<int>(*(const ::std::allocator<int>*)arg[0]);
}

static void constructor_13658( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::list<int>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::list<int>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::list<int>(*(::std::size_t*)arg[0],
      *(const int*)arg[1]);
  else ::new(mem) ::std::list<int>(*(::std::size_t*)arg[0],
      *(const int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::list<int>(*(::std::size_t*)arg[0],
      *(const int*)arg[1],
      *(const ::std::allocator<int>*)arg[2]);
  else ::new(mem) ::std::list<int>(*(::std::size_t*)arg[0],
      *(const int*)arg[1],
      *(const ::std::allocator<int>*)arg[2]);
  }
}

static void constructor_13659( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::list<int>(*(const ::std::list<int>*)arg[0]);
  else ::new(mem) ::std::list<int>(*(const ::std::list<int>*)arg[0]);
}

static  void operator_13660( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::list<int>*)o)->operator=)(*(const ::std::list<int>*)arg[0]);
  else   (((::std::list<int>*)o)->operator=)(*(const ::std::list<int>*)arg[0]);
}

static  void method_13661( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::list<int>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const int*)arg[1]);
}

static  void method_13662( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<int>)((((const ::std::list<int>*)o)->get_allocator)());
  else   (((const ::std::list<int>*)o)->get_allocator)();
}

static  void method_13663( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_List_iterator<int>)((((::std::list<int>*)o)->begin)());
  else   (((::std::list<int>*)o)->begin)();
}

static  void method_13664( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_List_const_iterator<int>)((((const ::std::list<int>*)o)->begin)());
  else   (((const ::std::list<int>*)o)->begin)();
}

static  void method_13665( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_List_iterator<int>)((((::std::list<int>*)o)->end)());
  else   (((::std::list<int>*)o)->end)();
}

static  void method_13666( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_List_const_iterator<int>)((((const ::std::list<int>*)o)->end)());
  else   (((const ::std::list<int>*)o)->end)();
}

static  void method_13671( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::list<int>*)o)->empty)());
  else   (((const ::std::list<int>*)o)->empty)();
}

static  void method_13672( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::list<int>*)o)->size)());
  else   (((const ::std::list<int>*)o)->size)();
}

static  void method_13673( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::list<int>*)o)->max_size)());
  else   (((const ::std::list<int>*)o)->max_size)();
}

static  void method_13674( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::list<int>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::list<int>*)o)->resize)(*(::std::size_t*)arg[0],
      *(int*)arg[1]);
  }
}

static  void method_13675( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::list<int>*)o)->front)();
  else   (((::std::list<int>*)o)->front)();
}

static  void method_13676( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::list<int>*)o)->front)();
  else   (((const ::std::list<int>*)o)->front)();
}

static  void method_13677( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::list<int>*)o)->back)();
  else   (((::std::list<int>*)o)->back)();
}

static  void method_13678( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::list<int>*)o)->back)();
  else   (((const ::std::list<int>*)o)->back)();
}

static  void method_13679( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::list<int>*)o)->push_front)(*(const int*)arg[0]);
}

static  void method_13680( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::list<int>*)o)->pop_front)();
}

static  void method_13681( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::list<int>*)o)->push_back)(*(const int*)arg[0]);
}

static  void method_13682( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::list<int>*)o)->pop_back)();
}

static  void method_13683( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_List_iterator<int>)((((::std::list<int>*)o)->insert)(*(::std::_List_iterator<int>*)arg[0],
    *(const int*)arg[1]));
  else   (((::std::list<int>*)o)->insert)(*(::std::_List_iterator<int>*)arg[0],
    *(const int*)arg[1]);
}

static  void method_13684( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::list<int>*)o)->insert)(*(::std::_List_iterator<int>*)arg[0],
    *(::std::size_t*)arg[1],
    *(const int*)arg[2]);
}

static  void method_13685( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_List_iterator<int>)((((::std::list<int>*)o)->erase)(*(::std::_List_iterator<int>*)arg[0]));
  else   (((::std::list<int>*)o)->erase)(*(::std::_List_iterator<int>*)arg[0]);
}

static  void method_13686( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_List_iterator<int>)((((::std::list<int>*)o)->erase)(*(::std::_List_iterator<int>*)arg[0],
    *(::std::_List_iterator<int>*)arg[1]));
  else   (((::std::list<int>*)o)->erase)(*(::std::_List_iterator<int>*)arg[0],
    *(::std::_List_iterator<int>*)arg[1]);
}

static  void method_13687( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::list<int>*)o)->swap)(*(::std::list<int>*)arg[0]);
}

static  void method_13688( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::list<int>*)o)->clear)();
}

static  void method_13689( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::list<int>*)o)->splice)(*(::std::_List_iterator<int>*)arg[0],
    *(::std::list<int>*)arg[1]);
}

static  void method_13690( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::list<int>*)o)->splice)(*(::std::_List_iterator<int>*)arg[0],
    *(::std::list<int>*)arg[1],
    *(::std::_List_iterator<int>*)arg[2]);
}

static  void method_13691( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::list<int>*)o)->splice)(*(::std::_List_iterator<int>*)arg[0],
    *(::std::list<int>*)arg[1],
    *(::std::_List_iterator<int>*)arg[2],
    *(::std::_List_iterator<int>*)arg[3]);
}

static  void method_13692( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::list<int>*)o)->remove)(*(const int*)arg[0]);
}

static  void method_13693( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::list<int>*)o)->unique)();
}

static  void method_13694( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::list<int>*)o)->merge)(*(::std::list<int>*)arg[0]);
}

static  void method_13695( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::list<int>*)o)->reverse)();
}

static  void method_13696( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::list<int>*)o)->sort)();
}

static void method_newdel_1603( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::list<int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::list<int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::list<int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::list<int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::list<int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x228( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_List_base<int,std::allocator<int> >")), ::Reflex::BaseOffset< ::std::list<int>,::std::_List_base<int,std::allocator<int> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x229( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::list<int> >::Generate();
  else ::Reflex::Proxy< ::std::list<int> >::Generate();
}

//------Dictionary for class list<int,std::allocator<int> > -------------------------------
void __std__list_int__db_datamem(Reflex::Class*);
void __std__list_int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__list_int__datamem_bld(&__std__list_int__db_datamem);
Reflex::GenreflexMemberBuilder __std__list_int__funcmem_bld(&__std__list_int__db_funcmem);
void __std__list_int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::list<int>"), typeid(::std::list<int>), sizeof(::std::list<int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1191, ::Reflex::BaseOffset< ::std::list<int>, ::std::_List_base<int,std::allocator<int> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_22, Reflex::Literal("std::list<int>::_Alloc_value_type"))
  .AddTypedef(type_1191, Reflex::Literal("std::list<int>::_Base"))
  .AddTypedef(type_1339, Reflex::Literal("std::list<int>::_Tp_alloc_type"))
  .AddTypedef(type_22, Reflex::Literal("std::list<int>::value_type"))
  .AddTypedef(type_2054, Reflex::Literal("std::list<int>::pointer"))
  .AddTypedef(type_4401, Reflex::Literal("std::list<int>::const_pointer"))
  .AddTypedef(type_3569, Reflex::Literal("std::list<int>::reference"))
  .AddTypedef(type_4404, Reflex::Literal("std::list<int>::const_reference"))
  .AddTypedef(type_2041, Reflex::Literal("std::list<int>::iterator"))
  .AddTypedef(type_798, Reflex::Literal("std::list<int>::const_iterator"))
  .AddTypedef(type_1874, Reflex::Literal("std::list<int>::const_reverse_iterator"))
  .AddTypedef(type_1875, Reflex::Literal("std::list<int>::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::list<int>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::list<int>::difference_type"))
  .AddTypedef(type_1339, Reflex::Literal("std::list<int>::allocator_type"))
  .AddTypedef(type_1287, Reflex::Literal("std::list<int>::_Node"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~list"), destructor_13654, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("list"), constructor_13656, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20319), Reflex::Literal("list"), constructor_13657, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_4404, type_20319), Reflex::Literal("list"), constructor_13658, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21275), Reflex::Literal("list"), constructor_13659, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1603, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x228, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x229, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__list_int__funcmem_bld);
}

//------Delayed data member builder for class list<int,std::allocator<int> > -------------------
void __std__list_int__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class list<int,std::allocator<int> > -------------------
void __std__list_int__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21276, type_21275), Reflex::Literal("operator="), operator_13660, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_4404), Reflex::Literal("assign"), method_13661, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1339), Reflex::Literal("get_allocator"), method_13662, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2041), Reflex::Literal("begin"), method_13663, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_798), Reflex::Literal("begin"), method_13664, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2041), Reflex::Literal("end"), method_13665, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_798), Reflex::Literal("end"), method_13666, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_13671, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_13672, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_13673, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_22), Reflex::Literal("resize"), method_13674, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3569), Reflex::Literal("front"), method_13675, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4404), Reflex::Literal("front"), method_13676, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3569), Reflex::Literal("back"), method_13677, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4404), Reflex::Literal("back"), method_13678, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_4404), Reflex::Literal("push_front"), method_13679, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_front"), method_13680, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_4404), Reflex::Literal("push_back"), method_13681, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_13682, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2041, type_2041, type_4404), Reflex::Literal("insert"), method_13683, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2041, type_1654, type_4404), Reflex::Literal("insert"), method_13684, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2041, type_2041), Reflex::Literal("erase"), method_13685, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2041, type_2041, type_2041), Reflex::Literal("erase"), method_13686, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_21276), Reflex::Literal("swap"), method_13687, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_13688, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2041, type_21276), Reflex::Literal("splice"), method_13689, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2041, type_21276, type_2041), Reflex::Literal("splice"), method_13690, 0, "__position;__x;__i", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_2041, type_21276, type_2041, type_2041), Reflex::Literal("splice"), method_13691, 0, "__position;__x;__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_4404), Reflex::Literal("remove"), method_13692, 0, "__value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("unique"), method_13693, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_21276), Reflex::Literal("merge"), method_13694, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("reverse"), method_13695, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("sort"), method_13696, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------------------
static void destructor_13830(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->::std::map<std::basic_string<char>,std::basic_string<char> >::~map)();
}
static void constructor_13831( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,std::basic_string<char> >();
  else ::new(mem) ::std::map<std::basic_string<char>,std::basic_string<char> >();
}

static void constructor_13832( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,std::basic_string<char> >(*(const ::std::less<std::basic_string<char> >*)arg[0]);
  else ::new(mem) ::std::map<std::basic_string<char>,std::basic_string<char> >(*(const ::std::less<std::basic_string<char> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,std::basic_string<char> >(*(const ::std::less<std::basic_string<char> >*)arg[0],
      *(const ::std::allocator<std::pair<const std::basic_string<char>,std::basic_string<char> > >*)arg[1]);
  else ::new(mem) ::std::map<std::basic_string<char>,std::basic_string<char> >(*(const ::std::less<std::basic_string<char> >*)arg[0],
      *(const ::std::allocator<std::pair<const std::basic_string<char>,std::basic_string<char> > >*)arg[1]);
  }
}

static void constructor_13833( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,std::basic_string<char> >(*(const ::std::map<std::basic_string<char>,std::basic_string<char> >*)arg[0]);
  else ::new(mem) ::std::map<std::basic_string<char>,std::basic_string<char> >(*(const ::std::map<std::basic_string<char>,std::basic_string<char> >*)arg[0]);
}

static  void operator_13834( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->operator=)(*(const ::std::map<std::basic_string<char>,std::basic_string<char> >*)arg[0]);
  else   (((::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->operator=)(*(const ::std::map<std::basic_string<char>,std::basic_string<char> >*)arg[0]);
}

static  void method_13835( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const std::basic_string<char>,std::basic_string<char> > >)((((const ::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->get_allocator)());
  else   (((const ::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->get_allocator)();
}

static  void method_13836( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::basic_string<char> > >)((((::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->begin)());
  else   (((::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->begin)();
}

static  void method_13837( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::basic_string<char> > >)((((const ::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->begin)());
  else   (((const ::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->begin)();
}

static  void method_13838( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::basic_string<char> > >)((((::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->end)());
  else   (((::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->end)();
}

static  void method_13839( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::basic_string<char> > >)((((const ::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->end)());
  else   (((const ::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->end)();
}

static  void method_13844( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->empty)());
  else   (((const ::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->empty)();
}

static  void method_13845( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->size)());
  else   (((const ::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->size)();
}

static  void method_13846( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->max_size)());
  else   (((const ::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->max_size)();
}

static  void operator_13847( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->operator[])(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->operator[])(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13848( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13849( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13850( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::basic_string<char> > >,bool>)((((::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->insert)(*(const ::std::pair<const std::basic_string<char>,std::basic_string<char> >*)arg[0]));
  else   (((::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->insert)(*(const ::std::pair<const std::basic_string<char>,std::basic_string<char> >*)arg[0]);
}

static  void method_13851( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::basic_string<char> > >)((((::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::basic_string<char> > >*)arg[0],
    *(const ::std::pair<const std::basic_string<char>,std::basic_string<char> >*)arg[1]));
  else   (((::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::basic_string<char> > >*)arg[0],
    *(const ::std::pair<const std::basic_string<char>,std::basic_string<char> >*)arg[1]);
}

static  void method_13852( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::basic_string<char> > >*)arg[0]);
}

static  void method_13853( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->erase)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->erase)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13854( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::basic_string<char> > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::basic_string<char> > >*)arg[1]);
}

static  void method_13855( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->swap)(*(::std::map<std::basic_string<char>,std::basic_string<char> >*)arg[0]);
}

static  void method_13856( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->clear)();
}

static  void method_13857( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<std::basic_string<char> >)((((const ::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->key_comp)());
  else   (((const ::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->key_comp)();
}

static  void method_13859( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::basic_string<char> > >)((((::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->find)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->find)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13860( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::basic_string<char> > >)((((const ::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->find)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->find)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13861( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->count)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->count)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13862( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::basic_string<char> > >)((((::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13863( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::basic_string<char> > >)((((const ::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13864( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::basic_string<char> > >)((((::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13865( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::basic_string<char> > >)((((const ::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13866( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::basic_string<char> > >,std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::basic_string<char> > > >)((((::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_13867( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::basic_string<char> > >,std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::basic_string<char> > > >)((((const ::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,std::basic_string<char> >*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]);
}

static void method_newdel_1615( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,std::basic_string<char> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,std::basic_string<char> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,std::basic_string<char> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,std::basic_string<char> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,std::basic_string<char> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x231( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<std::basic_string<char>,std::basic_string<char> > >::Generate();
  else ::Reflex::Proxy< ::std::map<std::basic_string<char>,std::basic_string<char> > >::Generate();
}

//------Dictionary for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------------------
void __std__map_std__basic_string_char__std__basic_string_char_s__db_datamem(Reflex::Class*);
void __std__map_std__basic_string_char__std__basic_string_char_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_std__basic_string_char__std__basic_string_char_s__datamem_bld(&__std__map_std__basic_string_char__std__basic_string_char_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_std__basic_string_char__std__basic_string_char_s__funcmem_bld(&__std__map_std__basic_string_char__std__basic_string_char_s__db_funcmem);
void __std__map_std__basic_string_char__std__basic_string_char_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<std::basic_string<char>,std::basic_string<char> >"), typeid(::std::map<std::basic_string<char>,std::basic_string<char> >), sizeof(::std::map<std::basic_string<char>,std::basic_string<char> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1104, Reflex::Literal("std::map<std::basic_string<char>,std::basic_string<char> >::key_type"))
  .AddTypedef(type_1104, Reflex::Literal("std::map<std::basic_string<char>,std::basic_string<char> >::mapped_type"))
  .AddTypedef(type_858, Reflex::Literal("std::map<std::basic_string<char>,std::basic_string<char> >::value_type"))
  .AddTypedef(type_2023, Reflex::Literal("std::map<std::basic_string<char>,std::basic_string<char> >::key_compare"))
  .AddTypedef(type_1374, Reflex::Literal("std::map<std::basic_string<char>,std::basic_string<char> >::allocator_type"))
  .AddTypedef(type_858, Reflex::Literal("std::map<std::basic_string<char>,std::basic_string<char> >::_Alloc_value_type"))
  .AddTypedef(type_1374, Reflex::Literal("std::map<std::basic_string<char>,std::basic_string<char> >::_Pair_alloc_type"))
  .AddTypedef(type_1132, Reflex::Literal("std::map<std::basic_string<char>,std::basic_string<char> >::_Rep_type"))
  .AddTypedef(type_8829, Reflex::Literal("std::map<std::basic_string<char>,std::basic_string<char> >::pointer"))
  .AddTypedef(type_8831, Reflex::Literal("std::map<std::basic_string<char>,std::basic_string<char> >::const_pointer"))
  .AddTypedef(type_8833, Reflex::Literal("std::map<std::basic_string<char>,std::basic_string<char> >::reference"))
  .AddTypedef(type_8835, Reflex::Literal("std::map<std::basic_string<char>,std::basic_string<char> >::const_reference"))
  .AddTypedef(type_1268, Reflex::Literal("std::map<std::basic_string<char>,std::basic_string<char> >::iterator"))
  .AddTypedef(type_1910, Reflex::Literal("std::map<std::basic_string<char>,std::basic_string<char> >::const_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::map<std::basic_string<char>,std::basic_string<char> >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::map<std::basic_string<char>,std::basic_string<char> >::difference_type"))
  .AddTypedef(type_1837, Reflex::Literal("std::map<std::basic_string<char>,std::basic_string<char> >::reverse_iterator"))
  .AddTypedef(type_1836, Reflex::Literal("std::map<std::basic_string<char>,std::basic_string<char> >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_13830, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_13831, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20471, type_20622), Reflex::Literal("map"), constructor_13832, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20224), Reflex::Literal("map"), constructor_13833, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1615, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x231, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_std__basic_string_char__std__basic_string_char_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_std__basic_string_char__std__basic_string_char_s__funcmem_bld);
}

//------Delayed data member builder for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------
void __std__map_std__basic_string_char__std__basic_string_char_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1132, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_std__basic_string_char__std__basic_string_char_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------
void __std__map_std__basic_string_char__std__basic_string_char_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21285, type_20224), Reflex::Literal("operator="), operator_13834, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1374), Reflex::Literal("get_allocator"), method_13835, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1268), Reflex::Literal("begin"), method_13836, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1910), Reflex::Literal("begin"), method_13837, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1268), Reflex::Literal("end"), method_13838, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1910), Reflex::Literal("end"), method_13839, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_13844, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_13845, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_13846, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_4981), Reflex::Literal("operator[]"), operator_13847, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_4981), Reflex::Literal("at"), method_13848, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4981, type_4981), Reflex::Literal("at"), method_13849, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_958, type_8835), Reflex::Literal("insert"), method_13850, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1268, type_1268, type_8835), Reflex::Literal("insert"), method_13851, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1268), Reflex::Literal("erase"), method_13852, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4981), Reflex::Literal("erase"), method_13853, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1268, type_1268), Reflex::Literal("erase"), method_13854, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_21285), Reflex::Literal("swap"), method_13855, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_13856, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2023), Reflex::Literal("key_comp"), method_13857, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1268, type_4981), Reflex::Literal("find"), method_13859, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1910, type_4981), Reflex::Literal("find"), method_13860, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4981), Reflex::Literal("count"), method_13861, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1268, type_4981), Reflex::Literal("lower_bound"), method_13862, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1910, type_4981), Reflex::Literal("lower_bound"), method_13863, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1268, type_4981), Reflex::Literal("upper_bound"), method_13864, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1910, type_4981), Reflex::Literal("upper_bound"), method_13865, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_957, type_4981), Reflex::Literal("equal_range"), method_13866, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_956, type_4981), Reflex::Literal("equal_range"), method_13867, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<short unsigned int,short unsigned int,std::less<short unsigned int>,std::allocator<std::pair<const short unsigned int, short unsigned int> > > -------------------------------
static void destructor_13888(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned short,unsigned short>*)o)->::std::map<unsigned short,unsigned short>::~map)();
}
static void constructor_13889( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned short,unsigned short>();
  else ::new(mem) ::std::map<unsigned short,unsigned short>();
}

static void constructor_13890( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned short,unsigned short>(*(const ::std::less<unsigned short>*)arg[0]);
  else ::new(mem) ::std::map<unsigned short,unsigned short>(*(const ::std::less<unsigned short>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned short,unsigned short>(*(const ::std::less<unsigned short>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned short,unsigned short> >*)arg[1]);
  else ::new(mem) ::std::map<unsigned short,unsigned short>(*(const ::std::less<unsigned short>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned short,unsigned short> >*)arg[1]);
  }
}

static void constructor_13891( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned short,unsigned short>(*(const ::std::map<unsigned short,unsigned short>*)arg[0]);
  else ::new(mem) ::std::map<unsigned short,unsigned short>(*(const ::std::map<unsigned short,unsigned short>*)arg[0]);
}

static  void operator_13892( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned short,unsigned short>*)o)->operator=)(*(const ::std::map<unsigned short,unsigned short>*)arg[0]);
  else   (((::std::map<unsigned short,unsigned short>*)o)->operator=)(*(const ::std::map<unsigned short,unsigned short>*)arg[0]);
}

static  void method_13893( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned short,unsigned short> >)((((const ::std::map<unsigned short,unsigned short>*)o)->get_allocator)());
  else   (((const ::std::map<unsigned short,unsigned short>*)o)->get_allocator)();
}

static  void method_13894( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned short,unsigned short> >)((((::std::map<unsigned short,unsigned short>*)o)->begin)());
  else   (((::std::map<unsigned short,unsigned short>*)o)->begin)();
}

static  void method_13895( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned short,unsigned short> >)((((const ::std::map<unsigned short,unsigned short>*)o)->begin)());
  else   (((const ::std::map<unsigned short,unsigned short>*)o)->begin)();
}

static  void method_13896( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned short,unsigned short> >)((((::std::map<unsigned short,unsigned short>*)o)->end)());
  else   (((::std::map<unsigned short,unsigned short>*)o)->end)();
}

static  void method_13897( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned short,unsigned short> >)((((const ::std::map<unsigned short,unsigned short>*)o)->end)());
  else   (((const ::std::map<unsigned short,unsigned short>*)o)->end)();
}

static  void method_13902( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned short,unsigned short>*)o)->empty)());
  else   (((const ::std::map<unsigned short,unsigned short>*)o)->empty)();
}

static  void method_13903( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned short,unsigned short>*)o)->size)());
  else   (((const ::std::map<unsigned short,unsigned short>*)o)->size)();
}

static  void method_13904( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned short,unsigned short>*)o)->max_size)());
  else   (((const ::std::map<unsigned short,unsigned short>*)o)->max_size)();
}

static  void operator_13905( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned short,unsigned short>*)o)->operator[])(*(const unsigned short*)arg[0]);
  else   (((::std::map<unsigned short,unsigned short>*)o)->operator[])(*(const unsigned short*)arg[0]);
}

static  void method_13906( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned short,unsigned short>*)o)->at)(*(const unsigned short*)arg[0]);
  else   (((::std::map<unsigned short,unsigned short>*)o)->at)(*(const unsigned short*)arg[0]);
}

static  void method_13907( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned short,unsigned short>*)o)->at)(*(const unsigned short*)arg[0]);
  else   (((const ::std::map<unsigned short,unsigned short>*)o)->at)(*(const unsigned short*)arg[0]);
}

static  void method_13908( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned short,unsigned short> >,bool>)((((::std::map<unsigned short,unsigned short>*)o)->insert)(*(const ::std::pair<const unsigned short,unsigned short>*)arg[0]));
  else   (((::std::map<unsigned short,unsigned short>*)o)->insert)(*(const ::std::pair<const unsigned short,unsigned short>*)arg[0]);
}

static  void method_13909( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned short,unsigned short> >)((((::std::map<unsigned short,unsigned short>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned short,unsigned short> >*)arg[0],
    *(const ::std::pair<const unsigned short,unsigned short>*)arg[1]));
  else   (((::std::map<unsigned short,unsigned short>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned short,unsigned short> >*)arg[0],
    *(const ::std::pair<const unsigned short,unsigned short>*)arg[1]);
}

static  void method_13910( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned short,unsigned short>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned short,unsigned short> >*)arg[0]);
}

static  void method_13911( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned short,unsigned short>*)o)->erase)(*(const unsigned short*)arg[0]));
  else   (((::std::map<unsigned short,unsigned short>*)o)->erase)(*(const unsigned short*)arg[0]);
}

static  void method_13912( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned short,unsigned short>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned short,unsigned short> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned short,unsigned short> >*)arg[1]);
}

static  void method_13913( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned short,unsigned short>*)o)->swap)(*(::std::map<unsigned short,unsigned short>*)arg[0]);
}

static  void method_13914( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned short,unsigned short>*)o)->clear)();
}

static  void method_13915( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned short>)((((const ::std::map<unsigned short,unsigned short>*)o)->key_comp)());
  else   (((const ::std::map<unsigned short,unsigned short>*)o)->key_comp)();
}

static  void method_13917( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned short,unsigned short> >)((((::std::map<unsigned short,unsigned short>*)o)->find)(*(const unsigned short*)arg[0]));
  else   (((::std::map<unsigned short,unsigned short>*)o)->find)(*(const unsigned short*)arg[0]);
}

static  void method_13918( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned short,unsigned short> >)((((const ::std::map<unsigned short,unsigned short>*)o)->find)(*(const unsigned short*)arg[0]));
  else   (((const ::std::map<unsigned short,unsigned short>*)o)->find)(*(const unsigned short*)arg[0]);
}

static  void method_13919( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned short,unsigned short>*)o)->count)(*(const unsigned short*)arg[0]));
  else   (((const ::std::map<unsigned short,unsigned short>*)o)->count)(*(const unsigned short*)arg[0]);
}

static  void method_13920( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned short,unsigned short> >)((((::std::map<unsigned short,unsigned short>*)o)->lower_bound)(*(const unsigned short*)arg[0]));
  else   (((::std::map<unsigned short,unsigned short>*)o)->lower_bound)(*(const unsigned short*)arg[0]);
}

static  void method_13921( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned short,unsigned short> >)((((const ::std::map<unsigned short,unsigned short>*)o)->lower_bound)(*(const unsigned short*)arg[0]));
  else   (((const ::std::map<unsigned short,unsigned short>*)o)->lower_bound)(*(const unsigned short*)arg[0]);
}

static  void method_13922( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned short,unsigned short> >)((((::std::map<unsigned short,unsigned short>*)o)->upper_bound)(*(const unsigned short*)arg[0]));
  else   (((::std::map<unsigned short,unsigned short>*)o)->upper_bound)(*(const unsigned short*)arg[0]);
}

static  void method_13923( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned short,unsigned short> >)((((const ::std::map<unsigned short,unsigned short>*)o)->upper_bound)(*(const unsigned short*)arg[0]));
  else   (((const ::std::map<unsigned short,unsigned short>*)o)->upper_bound)(*(const unsigned short*)arg[0]);
}

static  void method_13924( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned short,unsigned short> >,std::_Rb_tree_iterator<std::pair<const unsigned short,unsigned short> > >)((((::std::map<unsigned short,unsigned short>*)o)->equal_range)(*(const unsigned short*)arg[0]));
  else   (((::std::map<unsigned short,unsigned short>*)o)->equal_range)(*(const unsigned short*)arg[0]);
}

static  void method_13925( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned short,unsigned short> >,std::_Rb_tree_const_iterator<std::pair<const unsigned short,unsigned short> > >)((((const ::std::map<unsigned short,unsigned short>*)o)->equal_range)(*(const unsigned short*)arg[0]));
  else   (((const ::std::map<unsigned short,unsigned short>*)o)->equal_range)(*(const unsigned short*)arg[0]);
}

static void method_newdel_1616( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned short,unsigned short> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned short,unsigned short> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned short,unsigned short> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned short,unsigned short> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned short,unsigned short> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x233( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned short,unsigned short> >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned short,unsigned short> >::Generate();
}

//------Dictionary for class map<short unsigned int,short unsigned int,std::less<short unsigned int>,std::allocator<std::pair<const short unsigned int, short unsigned int> > > -------------------------------
void __std__map_unsignedsshort_unsignedsshort__db_datamem(Reflex::Class*);
void __std__map_unsignedsshort_unsignedsshort__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsshort_unsignedsshort__datamem_bld(&__std__map_unsignedsshort_unsignedsshort__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsshort_unsignedsshort__funcmem_bld(&__std__map_unsignedsshort_unsignedsshort__db_funcmem);
void __std__map_unsignedsshort_unsignedsshort__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned short,unsigned short>"), typeid(::std::map<unsigned short,unsigned short>), sizeof(::std::map<unsigned short,unsigned short>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_167, Reflex::Literal("std::map<unsigned short,unsigned short>::key_type"))
  .AddTypedef(type_167, Reflex::Literal("std::map<unsigned short,unsigned short>::mapped_type"))
  .AddTypedef(type_865, Reflex::Literal("std::map<unsigned short,unsigned short>::value_type"))
  .AddTypedef(type_2026, Reflex::Literal("std::map<unsigned short,unsigned short>::key_compare"))
  .AddTypedef(type_1378, Reflex::Literal("std::map<unsigned short,unsigned short>::allocator_type"))
  .AddTypedef(type_865, Reflex::Literal("std::map<unsigned short,unsigned short>::_Alloc_value_type"))
  .AddTypedef(type_1378, Reflex::Literal("std::map<unsigned short,unsigned short>::_Pair_alloc_type"))
  .AddTypedef(type_1114, Reflex::Literal("std::map<unsigned short,unsigned short>::_Rep_type"))
  .AddTypedef(type_6939, Reflex::Literal("std::map<unsigned short,unsigned short>::pointer"))
  .AddTypedef(type_6941, Reflex::Literal("std::map<unsigned short,unsigned short>::const_pointer"))
  .AddTypedef(type_6943, Reflex::Literal("std::map<unsigned short,unsigned short>::reference"))
  .AddTypedef(type_6945, Reflex::Literal("std::map<unsigned short,unsigned short>::const_reference"))
  .AddTypedef(type_1250, Reflex::Literal("std::map<unsigned short,unsigned short>::iterator"))
  .AddTypedef(type_1892, Reflex::Literal("std::map<unsigned short,unsigned short>::const_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::map<unsigned short,unsigned short>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::map<unsigned short,unsigned short>::difference_type"))
  .AddTypedef(type_1801, Reflex::Literal("std::map<unsigned short,unsigned short>::reverse_iterator"))
  .AddTypedef(type_1800, Reflex::Literal("std::map<unsigned short,unsigned short>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_13888, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_13889, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20492, type_20493), Reflex::Literal("map"), constructor_13890, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21286), Reflex::Literal("map"), constructor_13891, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1616, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x233, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsshort_unsignedsshort__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsshort_unsignedsshort__funcmem_bld);
}

//------Delayed data member builder for class map<short unsigned int,short unsigned int,std::less<short unsigned int>,std::allocator<std::pair<const short unsigned int, short unsigned int> > > -------------------
void __std__map_unsignedsshort_unsignedsshort__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1114, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsshort_unsignedsshort_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<short unsigned int,short unsigned int,std::less<short unsigned int>,std::allocator<std::pair<const short unsigned int, short unsigned int> > > -------------------
void __std__map_unsignedsshort_unsignedsshort__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21287, type_21286), Reflex::Literal("operator="), operator_13892, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1378), Reflex::Literal("get_allocator"), method_13893, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1250), Reflex::Literal("begin"), method_13894, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1892), Reflex::Literal("begin"), method_13895, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1250), Reflex::Literal("end"), method_13896, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1892), Reflex::Literal("end"), method_13897, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_13902, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_13903, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_13904, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3472, type_3762), Reflex::Literal("operator[]"), operator_13905, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3472, type_3762), Reflex::Literal("at"), method_13906, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3762, type_3762), Reflex::Literal("at"), method_13907, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_903, type_6945), Reflex::Literal("insert"), method_13908, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1250, type_1250, type_6945), Reflex::Literal("insert"), method_13909, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1250), Reflex::Literal("erase"), method_13910, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_3762), Reflex::Literal("erase"), method_13911, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1250, type_1250), Reflex::Literal("erase"), method_13912, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_21287), Reflex::Literal("swap"), method_13913, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_13914, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2026), Reflex::Literal("key_comp"), method_13915, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1250, type_3762), Reflex::Literal("find"), method_13917, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1892, type_3762), Reflex::Literal("find"), method_13918, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_3762), Reflex::Literal("count"), method_13919, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1250, type_3762), Reflex::Literal("lower_bound"), method_13920, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1892, type_3762), Reflex::Literal("lower_bound"), method_13921, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1250, type_3762), Reflex::Literal("upper_bound"), method_13922, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1892, type_3762), Reflex::Literal("upper_bound"), method_13923, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_902, type_3762), Reflex::Literal("equal_range"), method_13924, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_901, type_3762), Reflex::Literal("equal_range"), method_13925, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<short unsigned int,std::vector<short unsigned int, std::allocator<short unsigned int> >,std::less<short unsigned int>,std::allocator<std::pair<const short unsigned int, std::vector<short unsigned int, std::allocator<short unsigned int> > > > > -------------------------------
static void destructor_13946(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned short,std::vector<unsigned short> >*)o)->::std::map<unsigned short,std::vector<unsigned short> >::~map)();
}
static void constructor_13947( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned short,std::vector<unsigned short> >();
  else ::new(mem) ::std::map<unsigned short,std::vector<unsigned short> >();
}

static void constructor_13948( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned short,std::vector<unsigned short> >(*(const ::std::less<unsigned short>*)arg[0]);
  else ::new(mem) ::std::map<unsigned short,std::vector<unsigned short> >(*(const ::std::less<unsigned short>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned short,std::vector<unsigned short> >(*(const ::std::less<unsigned short>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned short,std::vector<unsigned short> > >*)arg[1]);
  else ::new(mem) ::std::map<unsigned short,std::vector<unsigned short> >(*(const ::std::less<unsigned short>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned short,std::vector<unsigned short> > >*)arg[1]);
  }
}

static void constructor_13949( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned short,std::vector<unsigned short> >(*(const ::std::map<unsigned short,std::vector<unsigned short> >*)arg[0]);
  else ::new(mem) ::std::map<unsigned short,std::vector<unsigned short> >(*(const ::std::map<unsigned short,std::vector<unsigned short> >*)arg[0]);
}

static  void operator_13950( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned short,std::vector<unsigned short> >*)o)->operator=)(*(const ::std::map<unsigned short,std::vector<unsigned short> >*)arg[0]);
  else   (((::std::map<unsigned short,std::vector<unsigned short> >*)o)->operator=)(*(const ::std::map<unsigned short,std::vector<unsigned short> >*)arg[0]);
}

static  void method_13951( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned short,std::vector<unsigned short> > >)((((const ::std::map<unsigned short,std::vector<unsigned short> >*)o)->get_allocator)());
  else   (((const ::std::map<unsigned short,std::vector<unsigned short> >*)o)->get_allocator)();
}

static  void method_13952( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned short,std::vector<unsigned short> > >)((((::std::map<unsigned short,std::vector<unsigned short> >*)o)->begin)());
  else   (((::std::map<unsigned short,std::vector<unsigned short> >*)o)->begin)();
}

static  void method_13953( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned short,std::vector<unsigned short> > >)((((const ::std::map<unsigned short,std::vector<unsigned short> >*)o)->begin)());
  else   (((const ::std::map<unsigned short,std::vector<unsigned short> >*)o)->begin)();
}

static  void method_13954( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned short,std::vector<unsigned short> > >)((((::std::map<unsigned short,std::vector<unsigned short> >*)o)->end)());
  else   (((::std::map<unsigned short,std::vector<unsigned short> >*)o)->end)();
}

static  void method_13955( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned short,std::vector<unsigned short> > >)((((const ::std::map<unsigned short,std::vector<unsigned short> >*)o)->end)());
  else   (((const ::std::map<unsigned short,std::vector<unsigned short> >*)o)->end)();
}

static  void method_13960( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned short,std::vector<unsigned short> >*)o)->empty)());
  else   (((const ::std::map<unsigned short,std::vector<unsigned short> >*)o)->empty)();
}

static  void method_13961( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned short,std::vector<unsigned short> >*)o)->size)());
  else   (((const ::std::map<unsigned short,std::vector<unsigned short> >*)o)->size)();
}

static  void method_13962( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned short,std::vector<unsigned short> >*)o)->max_size)());
  else   (((const ::std::map<unsigned short,std::vector<unsigned short> >*)o)->max_size)();
}

static  void operator_13963( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned short,std::vector<unsigned short> >*)o)->operator[])(*(const unsigned short*)arg[0]);
  else   (((::std::map<unsigned short,std::vector<unsigned short> >*)o)->operator[])(*(const unsigned short*)arg[0]);
}

static  void method_13964( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned short,std::vector<unsigned short> >*)o)->at)(*(const unsigned short*)arg[0]);
  else   (((::std::map<unsigned short,std::vector<unsigned short> >*)o)->at)(*(const unsigned short*)arg[0]);
}

static  void method_13965( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned short,std::vector<unsigned short> >*)o)->at)(*(const unsigned short*)arg[0]);
  else   (((const ::std::map<unsigned short,std::vector<unsigned short> >*)o)->at)(*(const unsigned short*)arg[0]);
}

static  void method_13966( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned short,std::vector<unsigned short> > >,bool>)((((::std::map<unsigned short,std::vector<unsigned short> >*)o)->insert)(*(const ::std::pair<const unsigned short,std::vector<unsigned short> >*)arg[0]));
  else   (((::std::map<unsigned short,std::vector<unsigned short> >*)o)->insert)(*(const ::std::pair<const unsigned short,std::vector<unsigned short> >*)arg[0]);
}

static  void method_13967( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned short,std::vector<unsigned short> > >)((((::std::map<unsigned short,std::vector<unsigned short> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned short,std::vector<unsigned short> > >*)arg[0],
    *(const ::std::pair<const unsigned short,std::vector<unsigned short> >*)arg[1]));
  else   (((::std::map<unsigned short,std::vector<unsigned short> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned short,std::vector<unsigned short> > >*)arg[0],
    *(const ::std::pair<const unsigned short,std::vector<unsigned short> >*)arg[1]);
}

static  void method_13968( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned short,std::vector<unsigned short> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned short,std::vector<unsigned short> > >*)arg[0]);
}

static  void method_13969( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned short,std::vector<unsigned short> >*)o)->erase)(*(const unsigned short*)arg[0]));
  else   (((::std::map<unsigned short,std::vector<unsigned short> >*)o)->erase)(*(const unsigned short*)arg[0]);
}

static  void method_13970( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned short,std::vector<unsigned short> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned short,std::vector<unsigned short> > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned short,std::vector<unsigned short> > >*)arg[1]);
}

static  void method_13971( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned short,std::vector<unsigned short> >*)o)->swap)(*(::std::map<unsigned short,std::vector<unsigned short> >*)arg[0]);
}

static  void method_13972( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned short,std::vector<unsigned short> >*)o)->clear)();
}

static  void method_13973( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned short>)((((const ::std::map<unsigned short,std::vector<unsigned short> >*)o)->key_comp)());
  else   (((const ::std::map<unsigned short,std::vector<unsigned short> >*)o)->key_comp)();
}

static  void method_13975( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned short,std::vector<unsigned short> > >)((((::std::map<unsigned short,std::vector<unsigned short> >*)o)->find)(*(const unsigned short*)arg[0]));
  else   (((::std::map<unsigned short,std::vector<unsigned short> >*)o)->find)(*(const unsigned short*)arg[0]);
}

static  void method_13976( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned short,std::vector<unsigned short> > >)((((const ::std::map<unsigned short,std::vector<unsigned short> >*)o)->find)(*(const unsigned short*)arg[0]));
  else   (((const ::std::map<unsigned short,std::vector<unsigned short> >*)o)->find)(*(const unsigned short*)arg[0]);
}

static  void method_13977( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned short,std::vector<unsigned short> >*)o)->count)(*(const unsigned short*)arg[0]));
  else   (((const ::std::map<unsigned short,std::vector<unsigned short> >*)o)->count)(*(const unsigned short*)arg[0]);
}

static  void method_13978( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned short,std::vector<unsigned short> > >)((((::std::map<unsigned short,std::vector<unsigned short> >*)o)->lower_bound)(*(const unsigned short*)arg[0]));
  else   (((::std::map<unsigned short,std::vector<unsigned short> >*)o)->lower_bound)(*(const unsigned short*)arg[0]);
}

static  void method_13979( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned short,std::vector<unsigned short> > >)((((const ::std::map<unsigned short,std::vector<unsigned short> >*)o)->lower_bound)(*(const unsigned short*)arg[0]));
  else   (((const ::std::map<unsigned short,std::vector<unsigned short> >*)o)->lower_bound)(*(const unsigned short*)arg[0]);
}

static  void method_13980( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned short,std::vector<unsigned short> > >)((((::std::map<unsigned short,std::vector<unsigned short> >*)o)->upper_bound)(*(const unsigned short*)arg[0]));
  else   (((::std::map<unsigned short,std::vector<unsigned short> >*)o)->upper_bound)(*(const unsigned short*)arg[0]);
}

static  void method_13981( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned short,std::vector<unsigned short> > >)((((const ::std::map<unsigned short,std::vector<unsigned short> >*)o)->upper_bound)(*(const unsigned short*)arg[0]));
  else   (((const ::std::map<unsigned short,std::vector<unsigned short> >*)o)->upper_bound)(*(const unsigned short*)arg[0]);
}

static  void method_13982( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned short,std::vector<unsigned short> > >,std::_Rb_tree_iterator<std::pair<const unsigned short,std::vector<unsigned short> > > >)((((::std::map<unsigned short,std::vector<unsigned short> >*)o)->equal_range)(*(const unsigned short*)arg[0]));
  else   (((::std::map<unsigned short,std::vector<unsigned short> >*)o)->equal_range)(*(const unsigned short*)arg[0]);
}

static  void method_13983( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned short,std::vector<unsigned short> > >,std::_Rb_tree_const_iterator<std::pair<const unsigned short,std::vector<unsigned short> > > >)((((const ::std::map<unsigned short,std::vector<unsigned short> >*)o)->equal_range)(*(const unsigned short*)arg[0]));
  else   (((const ::std::map<unsigned short,std::vector<unsigned short> >*)o)->equal_range)(*(const unsigned short*)arg[0]);
}

static void method_newdel_1617( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned short,std::vector<unsigned short> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned short,std::vector<unsigned short> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned short,std::vector<unsigned short> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned short,std::vector<unsigned short> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned short,std::vector<unsigned short> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x235( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned short,std::vector<unsigned short> > >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned short,std::vector<unsigned short> > >::Generate();
}

//------Dictionary for class map<short unsigned int,std::vector<short unsigned int, std::allocator<short unsigned int> >,std::less<short unsigned int>,std::allocator<std::pair<const short unsigned int, std::vector<short unsigned int, std::allocator<short unsigned int> > > > > -------------------------------
void __std__map_unsignedsshort_std__vector_unsignedsshort_s__db_datamem(Reflex::Class*);
void __std__map_unsignedsshort_std__vector_unsignedsshort_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsshort_std__vector_unsignedsshort_s__datamem_bld(&__std__map_unsignedsshort_std__vector_unsignedsshort_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsshort_std__vector_unsignedsshort_s__funcmem_bld(&__std__map_unsignedsshort_std__vector_unsignedsshort_s__db_funcmem);
void __std__map_unsignedsshort_std__vector_unsignedsshort_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned short,std::vector<unsigned short> >"), typeid(::std::map<unsigned short,std::vector<unsigned short> >), sizeof(::std::map<unsigned short,std::vector<unsigned short> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_167, Reflex::Literal("std::map<unsigned short,std::vector<unsigned short> >::key_type"))
  .AddTypedef(type_1051, Reflex::Literal("std::map<unsigned short,std::vector<unsigned short> >::mapped_type"))
  .AddTypedef(type_866, Reflex::Literal("std::map<unsigned short,std::vector<unsigned short> >::value_type"))
  .AddTypedef(type_2026, Reflex::Literal("std::map<unsigned short,std::vector<unsigned short> >::key_compare"))
  .AddTypedef(type_1380, Reflex::Literal("std::map<unsigned short,std::vector<unsigned short> >::allocator_type"))
  .AddTypedef(type_866, Reflex::Literal("std::map<unsigned short,std::vector<unsigned short> >::_Alloc_value_type"))
  .AddTypedef(type_1380, Reflex::Literal("std::map<unsigned short,std::vector<unsigned short> >::_Pair_alloc_type"))
  .AddTypedef(type_1115, Reflex::Literal("std::map<unsigned short,std::vector<unsigned short> >::_Rep_type"))
  .AddTypedef(type_7044, Reflex::Literal("std::map<unsigned short,std::vector<unsigned short> >::pointer"))
  .AddTypedef(type_7046, Reflex::Literal("std::map<unsigned short,std::vector<unsigned short> >::const_pointer"))
  .AddTypedef(type_7048, Reflex::Literal("std::map<unsigned short,std::vector<unsigned short> >::reference"))
  .AddTypedef(type_7050, Reflex::Literal("std::map<unsigned short,std::vector<unsigned short> >::const_reference"))
  .AddTypedef(type_1251, Reflex::Literal("std::map<unsigned short,std::vector<unsigned short> >::iterator"))
  .AddTypedef(type_1893, Reflex::Literal("std::map<unsigned short,std::vector<unsigned short> >::const_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::map<unsigned short,std::vector<unsigned short> >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::map<unsigned short,std::vector<unsigned short> >::difference_type"))
  .AddTypedef(type_1803, Reflex::Literal("std::map<unsigned short,std::vector<unsigned short> >::reverse_iterator"))
  .AddTypedef(type_1802, Reflex::Literal("std::map<unsigned short,std::vector<unsigned short> >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_13946, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_13947, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20492, type_20500), Reflex::Literal("map"), constructor_13948, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21288), Reflex::Literal("map"), constructor_13949, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1617, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x235, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsshort_std__vector_unsignedsshort_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsshort_std__vector_unsignedsshort_s__funcmem_bld);
}

//------Delayed data member builder for class map<short unsigned int,std::vector<short unsigned int, std::allocator<short unsigned int> >,std::less<short unsigned int>,std::allocator<std::pair<const short unsigned int, std::vector<short unsigned int, std::allocator<short unsigned int> > > > > -------------------
void __std__map_unsignedsshort_std__vector_unsignedsshort_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1115, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsshort_std__vector_unsignedsshort_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<short unsigned int,std::vector<short unsigned int, std::allocator<short unsigned int> >,std::less<short unsigned int>,std::allocator<std::pair<const short unsigned int, std::vector<short unsigned int, std::allocator<short unsigned int> > > > > -------------------
void __std__map_unsignedsshort_std__vector_unsignedsshort_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21289, type_21288), Reflex::Literal("operator="), operator_13950, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1380), Reflex::Literal("get_allocator"), method_13951, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1251), Reflex::Literal("begin"), method_13952, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1893), Reflex::Literal("begin"), method_13953, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1251), Reflex::Literal("end"), method_13954, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1893), Reflex::Literal("end"), method_13955, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_13960, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_13961, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_13962, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4144, type_3762), Reflex::Literal("operator[]"), operator_13963, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4144, type_3762), Reflex::Literal("at"), method_13964, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4146, type_3762), Reflex::Literal("at"), method_13965, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_906, type_7050), Reflex::Literal("insert"), method_13966, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1251, type_1251, type_7050), Reflex::Literal("insert"), method_13967, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1251), Reflex::Literal("erase"), method_13968, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_3762), Reflex::Literal("erase"), method_13969, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1251, type_1251), Reflex::Literal("erase"), method_13970, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_21289), Reflex::Literal("swap"), method_13971, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_13972, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2026), Reflex::Literal("key_comp"), method_13973, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1251, type_3762), Reflex::Literal("find"), method_13975, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1893, type_3762), Reflex::Literal("find"), method_13976, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_3762), Reflex::Literal("count"), method_13977, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1251, type_3762), Reflex::Literal("lower_bound"), method_13978, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1893, type_3762), Reflex::Literal("lower_bound"), method_13979, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1251, type_3762), Reflex::Literal("upper_bound"), method_13980, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1893, type_3762), Reflex::Literal("upper_bound"), method_13981, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_905, type_3762), Reflex::Literal("equal_range"), method_13982, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_904, type_3762), Reflex::Literal("equal_range"), method_13983, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<short unsigned int,float,std::less<short unsigned int>,std::allocator<std::pair<const short unsigned int, float> > > -------------------------------
static void destructor_14004(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned short,float>*)o)->::std::map<unsigned short,float>::~map)();
}
static void constructor_14005( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned short,float>();
  else ::new(mem) ::std::map<unsigned short,float>();
}

static void constructor_14006( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned short,float>(*(const ::std::less<unsigned short>*)arg[0]);
  else ::new(mem) ::std::map<unsigned short,float>(*(const ::std::less<unsigned short>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned short,float>(*(const ::std::less<unsigned short>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned short,float> >*)arg[1]);
  else ::new(mem) ::std::map<unsigned short,float>(*(const ::std::less<unsigned short>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned short,float> >*)arg[1]);
  }
}

static void constructor_14007( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned short,float>(*(const ::std::map<unsigned short,float>*)arg[0]);
  else ::new(mem) ::std::map<unsigned short,float>(*(const ::std::map<unsigned short,float>*)arg[0]);
}

static  void operator_14008( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned short,float>*)o)->operator=)(*(const ::std::map<unsigned short,float>*)arg[0]);
  else   (((::std::map<unsigned short,float>*)o)->operator=)(*(const ::std::map<unsigned short,float>*)arg[0]);
}

static  void method_14009( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned short,float> >)((((const ::std::map<unsigned short,float>*)o)->get_allocator)());
  else   (((const ::std::map<unsigned short,float>*)o)->get_allocator)();
}

static  void method_14010( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned short,float> >)((((::std::map<unsigned short,float>*)o)->begin)());
  else   (((::std::map<unsigned short,float>*)o)->begin)();
}

static  void method_14011( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned short,float> >)((((const ::std::map<unsigned short,float>*)o)->begin)());
  else   (((const ::std::map<unsigned short,float>*)o)->begin)();
}

static  void method_14012( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned short,float> >)((((::std::map<unsigned short,float>*)o)->end)());
  else   (((::std::map<unsigned short,float>*)o)->end)();
}

static  void method_14013( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned short,float> >)((((const ::std::map<unsigned short,float>*)o)->end)());
  else   (((const ::std::map<unsigned short,float>*)o)->end)();
}

static  void method_14018( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned short,float>*)o)->empty)());
  else   (((const ::std::map<unsigned short,float>*)o)->empty)();
}

static  void method_14019( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned short,float>*)o)->size)());
  else   (((const ::std::map<unsigned short,float>*)o)->size)();
}

static  void method_14020( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned short,float>*)o)->max_size)());
  else   (((const ::std::map<unsigned short,float>*)o)->max_size)();
}

static  void operator_14021( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned short,float>*)o)->operator[])(*(const unsigned short*)arg[0]);
  else   (((::std::map<unsigned short,float>*)o)->operator[])(*(const unsigned short*)arg[0]);
}

static  void method_14022( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned short,float>*)o)->at)(*(const unsigned short*)arg[0]);
  else   (((::std::map<unsigned short,float>*)o)->at)(*(const unsigned short*)arg[0]);
}

static  void method_14023( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned short,float>*)o)->at)(*(const unsigned short*)arg[0]);
  else   (((const ::std::map<unsigned short,float>*)o)->at)(*(const unsigned short*)arg[0]);
}

static  void method_14024( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned short,float> >,bool>)((((::std::map<unsigned short,float>*)o)->insert)(*(const ::std::pair<const unsigned short,float>*)arg[0]));
  else   (((::std::map<unsigned short,float>*)o)->insert)(*(const ::std::pair<const unsigned short,float>*)arg[0]);
}

static  void method_14025( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned short,float> >)((((::std::map<unsigned short,float>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned short,float> >*)arg[0],
    *(const ::std::pair<const unsigned short,float>*)arg[1]));
  else   (((::std::map<unsigned short,float>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned short,float> >*)arg[0],
    *(const ::std::pair<const unsigned short,float>*)arg[1]);
}

static  void method_14026( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned short,float>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned short,float> >*)arg[0]);
}

static  void method_14027( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned short,float>*)o)->erase)(*(const unsigned short*)arg[0]));
  else   (((::std::map<unsigned short,float>*)o)->erase)(*(const unsigned short*)arg[0]);
}

static  void method_14028( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned short,float>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned short,float> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned short,float> >*)arg[1]);
}

static  void method_14029( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned short,float>*)o)->swap)(*(::std::map<unsigned short,float>*)arg[0]);
}

static  void method_14030( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned short,float>*)o)->clear)();
}

static  void method_14031( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned short>)((((const ::std::map<unsigned short,float>*)o)->key_comp)());
  else   (((const ::std::map<unsigned short,float>*)o)->key_comp)();
}

static  void method_14033( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned short,float> >)((((::std::map<unsigned short,float>*)o)->find)(*(const unsigned short*)arg[0]));
  else   (((::std::map<unsigned short,float>*)o)->find)(*(const unsigned short*)arg[0]);
}

static  void method_14034( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned short,float> >)((((const ::std::map<unsigned short,float>*)o)->find)(*(const unsigned short*)arg[0]));
  else   (((const ::std::map<unsigned short,float>*)o)->find)(*(const unsigned short*)arg[0]);
}

static  void method_14035( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned short,float>*)o)->count)(*(const unsigned short*)arg[0]));
  else   (((const ::std::map<unsigned short,float>*)o)->count)(*(const unsigned short*)arg[0]);
}

static  void method_14036( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned short,float> >)((((::std::map<unsigned short,float>*)o)->lower_bound)(*(const unsigned short*)arg[0]));
  else   (((::std::map<unsigned short,float>*)o)->lower_bound)(*(const unsigned short*)arg[0]);
}

static  void method_14037( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned short,float> >)((((const ::std::map<unsigned short,float>*)o)->lower_bound)(*(const unsigned short*)arg[0]));
  else   (((const ::std::map<unsigned short,float>*)o)->lower_bound)(*(const unsigned short*)arg[0]);
}

static  void method_14038( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned short,float> >)((((::std::map<unsigned short,float>*)o)->upper_bound)(*(const unsigned short*)arg[0]));
  else   (((::std::map<unsigned short,float>*)o)->upper_bound)(*(const unsigned short*)arg[0]);
}

static  void method_14039( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned short,float> >)((((const ::std::map<unsigned short,float>*)o)->upper_bound)(*(const unsigned short*)arg[0]));
  else   (((const ::std::map<unsigned short,float>*)o)->upper_bound)(*(const unsigned short*)arg[0]);
}

static  void method_14040( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned short,float> >,std::_Rb_tree_iterator<std::pair<const unsigned short,float> > >)((((::std::map<unsigned short,float>*)o)->equal_range)(*(const unsigned short*)arg[0]));
  else   (((::std::map<unsigned short,float>*)o)->equal_range)(*(const unsigned short*)arg[0]);
}

static  void method_14041( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned short,float> >,std::_Rb_tree_const_iterator<std::pair<const unsigned short,float> > >)((((const ::std::map<unsigned short,float>*)o)->equal_range)(*(const unsigned short*)arg[0]));
  else   (((const ::std::map<unsigned short,float>*)o)->equal_range)(*(const unsigned short*)arg[0]);
}

static void method_newdel_1618( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned short,float> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned short,float> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned short,float> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned short,float> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned short,float> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x237( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned short,float> >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned short,float> >::Generate();
}

//------Dictionary for class map<short unsigned int,float,std::less<short unsigned int>,std::allocator<std::pair<const short unsigned int, float> > > -------------------------------
void __std__map_unsignedsshort_float__db_datamem(Reflex::Class*);
void __std__map_unsignedsshort_float__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsshort_float__datamem_bld(&__std__map_unsignedsshort_float__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsshort_float__funcmem_bld(&__std__map_unsignedsshort_float__db_funcmem);
void __std__map_unsignedsshort_float__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned short,float>"), typeid(::std::map<unsigned short,float>), sizeof(::std::map<unsigned short,float>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_167, Reflex::Literal("std::map<unsigned short,float>::key_type"))
  .AddTypedef(type_2058, Reflex::Literal("std::map<unsigned short,float>::mapped_type"))
  .AddTypedef(type_867, Reflex::Literal("std::map<unsigned short,float>::value_type"))
  .AddTypedef(type_2026, Reflex::Literal("std::map<unsigned short,float>::key_compare"))
  .AddTypedef(type_1382, Reflex::Literal("std::map<unsigned short,float>::allocator_type"))
  .AddTypedef(type_867, Reflex::Literal("std::map<unsigned short,float>::_Alloc_value_type"))
  .AddTypedef(type_1382, Reflex::Literal("std::map<unsigned short,float>::_Pair_alloc_type"))
  .AddTypedef(type_1116, Reflex::Literal("std::map<unsigned short,float>::_Rep_type"))
  .AddTypedef(type_7149, Reflex::Literal("std::map<unsigned short,float>::pointer"))
  .AddTypedef(type_7151, Reflex::Literal("std::map<unsigned short,float>::const_pointer"))
  .AddTypedef(type_7153, Reflex::Literal("std::map<unsigned short,float>::reference"))
  .AddTypedef(type_7155, Reflex::Literal("std::map<unsigned short,float>::const_reference"))
  .AddTypedef(type_1252, Reflex::Literal("std::map<unsigned short,float>::iterator"))
  .AddTypedef(type_1894, Reflex::Literal("std::map<unsigned short,float>::const_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::map<unsigned short,float>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::map<unsigned short,float>::difference_type"))
  .AddTypedef(type_1805, Reflex::Literal("std::map<unsigned short,float>::reverse_iterator"))
  .AddTypedef(type_1804, Reflex::Literal("std::map<unsigned short,float>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_14004, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_14005, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20492, type_20507), Reflex::Literal("map"), constructor_14006, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21290), Reflex::Literal("map"), constructor_14007, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1618, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x237, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsshort_float__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsshort_float__funcmem_bld);
}

//------Delayed data member builder for class map<short unsigned int,float,std::less<short unsigned int>,std::allocator<std::pair<const short unsigned int, float> > > -------------------
void __std__map_unsignedsshort_float__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1116, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsshort_float_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<short unsigned int,float,std::less<short unsigned int>,std::allocator<std::pair<const short unsigned int, float> > > -------------------
void __std__map_unsignedsshort_float__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21291, type_21290), Reflex::Literal("operator="), operator_14008, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1382), Reflex::Literal("get_allocator"), method_14009, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1252), Reflex::Literal("begin"), method_14010, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1894), Reflex::Literal("begin"), method_14011, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1252), Reflex::Literal("end"), method_14012, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1894), Reflex::Literal("end"), method_14013, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_14018, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_14019, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_14020, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3579, type_3762), Reflex::Literal("operator[]"), operator_14021, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3579, type_3762), Reflex::Literal("at"), method_14022, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4790, type_3762), Reflex::Literal("at"), method_14023, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_909, type_7155), Reflex::Literal("insert"), method_14024, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1252, type_1252, type_7155), Reflex::Literal("insert"), method_14025, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1252), Reflex::Literal("erase"), method_14026, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_3762), Reflex::Literal("erase"), method_14027, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1252, type_1252), Reflex::Literal("erase"), method_14028, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_21291), Reflex::Literal("swap"), method_14029, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_14030, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2026), Reflex::Literal("key_comp"), method_14031, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1252, type_3762), Reflex::Literal("find"), method_14033, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1894, type_3762), Reflex::Literal("find"), method_14034, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_3762), Reflex::Literal("count"), method_14035, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1252, type_3762), Reflex::Literal("lower_bound"), method_14036, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1894, type_3762), Reflex::Literal("lower_bound"), method_14037, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1252, type_3762), Reflex::Literal("upper_bound"), method_14038, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1894, type_3762), Reflex::Literal("upper_bound"), method_14039, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_908, type_3762), Reflex::Literal("equal_range"), method_14040, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_907, type_3762), Reflex::Literal("equal_range"), method_14041, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<long unsigned int,long unsigned int,std::less<long unsigned int>,std::allocator<std::pair<const long unsigned int, long unsigned int> > > -------------------------------
static void destructor_14062(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned long,unsigned long>*)o)->::std::map<unsigned long,unsigned long>::~map)();
}
static void constructor_14063( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned long,unsigned long>();
  else ::new(mem) ::std::map<unsigned long,unsigned long>();
}

static void constructor_14064( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned long,unsigned long>(*(const ::std::less<unsigned long>*)arg[0]);
  else ::new(mem) ::std::map<unsigned long,unsigned long>(*(const ::std::less<unsigned long>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned long,unsigned long>(*(const ::std::less<unsigned long>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned long,unsigned long> >*)arg[1]);
  else ::new(mem) ::std::map<unsigned long,unsigned long>(*(const ::std::less<unsigned long>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned long,unsigned long> >*)arg[1]);
  }
}

static void constructor_14065( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned long,unsigned long>(*(const ::std::map<unsigned long,unsigned long>*)arg[0]);
  else ::new(mem) ::std::map<unsigned long,unsigned long>(*(const ::std::map<unsigned long,unsigned long>*)arg[0]);
}

static  void operator_14066( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned long,unsigned long>*)o)->operator=)(*(const ::std::map<unsigned long,unsigned long>*)arg[0]);
  else   (((::std::map<unsigned long,unsigned long>*)o)->operator=)(*(const ::std::map<unsigned long,unsigned long>*)arg[0]);
}

static  void method_14067( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned long,unsigned long> >)((((const ::std::map<unsigned long,unsigned long>*)o)->get_allocator)());
  else   (((const ::std::map<unsigned long,unsigned long>*)o)->get_allocator)();
}

static  void method_14068( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned long,unsigned long> >)((((::std::map<unsigned long,unsigned long>*)o)->begin)());
  else   (((::std::map<unsigned long,unsigned long>*)o)->begin)();
}

static  void method_14069( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned long,unsigned long> >)((((const ::std::map<unsigned long,unsigned long>*)o)->begin)());
  else   (((const ::std::map<unsigned long,unsigned long>*)o)->begin)();
}

static  void method_14070( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned long,unsigned long> >)((((::std::map<unsigned long,unsigned long>*)o)->end)());
  else   (((::std::map<unsigned long,unsigned long>*)o)->end)();
}

static  void method_14071( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned long,unsigned long> >)((((const ::std::map<unsigned long,unsigned long>*)o)->end)());
  else   (((const ::std::map<unsigned long,unsigned long>*)o)->end)();
}

static  void method_14076( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned long,unsigned long>*)o)->empty)());
  else   (((const ::std::map<unsigned long,unsigned long>*)o)->empty)();
}

static  void method_14077( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned long,unsigned long>*)o)->size)());
  else   (((const ::std::map<unsigned long,unsigned long>*)o)->size)();
}

static  void method_14078( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned long,unsigned long>*)o)->max_size)());
  else   (((const ::std::map<unsigned long,unsigned long>*)o)->max_size)();
}

static  void operator_14079( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned long,unsigned long>*)o)->operator[])(*(const unsigned long*)arg[0]);
  else   (((::std::map<unsigned long,unsigned long>*)o)->operator[])(*(const unsigned long*)arg[0]);
}

static  void method_14080( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned long,unsigned long>*)o)->at)(*(const unsigned long*)arg[0]);
  else   (((::std::map<unsigned long,unsigned long>*)o)->at)(*(const unsigned long*)arg[0]);
}

static  void method_14081( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned long,unsigned long>*)o)->at)(*(const unsigned long*)arg[0]);
  else   (((const ::std::map<unsigned long,unsigned long>*)o)->at)(*(const unsigned long*)arg[0]);
}

static  void method_14082( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned long,unsigned long> >,bool>)((((::std::map<unsigned long,unsigned long>*)o)->insert)(*(const ::std::pair<const unsigned long,unsigned long>*)arg[0]));
  else   (((::std::map<unsigned long,unsigned long>*)o)->insert)(*(const ::std::pair<const unsigned long,unsigned long>*)arg[0]);
}

static  void method_14083( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned long,unsigned long> >)((((::std::map<unsigned long,unsigned long>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned long,unsigned long> >*)arg[0],
    *(const ::std::pair<const unsigned long,unsigned long>*)arg[1]));
  else   (((::std::map<unsigned long,unsigned long>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned long,unsigned long> >*)arg[0],
    *(const ::std::pair<const unsigned long,unsigned long>*)arg[1]);
}

static  void method_14084( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned long,unsigned long>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned long,unsigned long> >*)arg[0]);
}

static  void method_14085( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned long,unsigned long>*)o)->erase)(*(const unsigned long*)arg[0]));
  else   (((::std::map<unsigned long,unsigned long>*)o)->erase)(*(const unsigned long*)arg[0]);
}

static  void method_14086( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned long,unsigned long>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned long,unsigned long> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned long,unsigned long> >*)arg[1]);
}

static  void method_14087( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned long,unsigned long>*)o)->swap)(*(::std::map<unsigned long,unsigned long>*)arg[0]);
}

static  void method_14088( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned long,unsigned long>*)o)->clear)();
}

static  void method_14089( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned long>)((((const ::std::map<unsigned long,unsigned long>*)o)->key_comp)());
  else   (((const ::std::map<unsigned long,unsigned long>*)o)->key_comp)();
}

static  void method_14091( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned long,unsigned long> >)((((::std::map<unsigned long,unsigned long>*)o)->find)(*(const unsigned long*)arg[0]));
  else   (((::std::map<unsigned long,unsigned long>*)o)->find)(*(const unsigned long*)arg[0]);
}

static  void method_14092( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned long,unsigned long> >)((((const ::std::map<unsigned long,unsigned long>*)o)->find)(*(const unsigned long*)arg[0]));
  else   (((const ::std::map<unsigned long,unsigned long>*)o)->find)(*(const unsigned long*)arg[0]);
}

static  void method_14093( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned long,unsigned long>*)o)->count)(*(const unsigned long*)arg[0]));
  else   (((const ::std::map<unsigned long,unsigned long>*)o)->count)(*(const unsigned long*)arg[0]);
}

static  void method_14094( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned long,unsigned long> >)((((::std::map<unsigned long,unsigned long>*)o)->lower_bound)(*(const unsigned long*)arg[0]));
  else   (((::std::map<unsigned long,unsigned long>*)o)->lower_bound)(*(const unsigned long*)arg[0]);
}

static  void method_14095( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned long,unsigned long> >)((((const ::std::map<unsigned long,unsigned long>*)o)->lower_bound)(*(const unsigned long*)arg[0]));
  else   (((const ::std::map<unsigned long,unsigned long>*)o)->lower_bound)(*(const unsigned long*)arg[0]);
}

static  void method_14096( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned long,unsigned long> >)((((::std::map<unsigned long,unsigned long>*)o)->upper_bound)(*(const unsigned long*)arg[0]));
  else   (((::std::map<unsigned long,unsigned long>*)o)->upper_bound)(*(const unsigned long*)arg[0]);
}

static  void method_14097( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned long,unsigned long> >)((((const ::std::map<unsigned long,unsigned long>*)o)->upper_bound)(*(const unsigned long*)arg[0]));
  else   (((const ::std::map<unsigned long,unsigned long>*)o)->upper_bound)(*(const unsigned long*)arg[0]);
}

static  void method_14098( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned long,unsigned long> >,std::_Rb_tree_iterator<std::pair<const unsigned long,unsigned long> > >)((((::std::map<unsigned long,unsigned long>*)o)->equal_range)(*(const unsigned long*)arg[0]));
  else   (((::std::map<unsigned long,unsigned long>*)o)->equal_range)(*(const unsigned long*)arg[0]);
}

static  void method_14099( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned long,unsigned long> >,std::_Rb_tree_const_iterator<std::pair<const unsigned long,unsigned long> > >)((((const ::std::map<unsigned long,unsigned long>*)o)->equal_range)(*(const unsigned long*)arg[0]));
  else   (((const ::std::map<unsigned long,unsigned long>*)o)->equal_range)(*(const unsigned long*)arg[0]);
}

static void method_newdel_1619( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned long,unsigned long> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned long,unsigned long> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned long,unsigned long> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned long,unsigned long> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned long,unsigned long> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x239( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned long,unsigned long> >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned long,unsigned long> >::Generate();
}

//------Dictionary for class map<long unsigned int,long unsigned int,std::less<long unsigned int>,std::allocator<std::pair<const long unsigned int, long unsigned int> > > -------------------------------
void __std__map_unsignedslong_unsignedslong__db_datamem(Reflex::Class*);
void __std__map_unsignedslong_unsignedslong__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedslong_unsignedslong__datamem_bld(&__std__map_unsignedslong_unsignedslong__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedslong_unsignedslong__funcmem_bld(&__std__map_unsignedslong_unsignedslong__db_funcmem);
void __std__map_unsignedslong_unsignedslong__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned long,unsigned long>"), typeid(::std::map<unsigned long,unsigned long>), sizeof(::std::map<unsigned long,unsigned long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_75, Reflex::Literal("std::map<unsigned long,unsigned long>::key_type"))
  .AddTypedef(type_75, Reflex::Literal("std::map<unsigned long,unsigned long>::mapped_type"))
  .AddTypedef(type_868, Reflex::Literal("std::map<unsigned long,unsigned long>::value_type"))
  .AddTypedef(type_2027, Reflex::Literal("std::map<unsigned long,unsigned long>::key_compare"))
  .AddTypedef(type_1384, Reflex::Literal("std::map<unsigned long,unsigned long>::allocator_type"))
  .AddTypedef(type_868, Reflex::Literal("std::map<unsigned long,unsigned long>::_Alloc_value_type"))
  .AddTypedef(type_1384, Reflex::Literal("std::map<unsigned long,unsigned long>::_Pair_alloc_type"))
  .AddTypedef(type_1117, Reflex::Literal("std::map<unsigned long,unsigned long>::_Rep_type"))
  .AddTypedef(type_7254, Reflex::Literal("std::map<unsigned long,unsigned long>::pointer"))
  .AddTypedef(type_7256, Reflex::Literal("std::map<unsigned long,unsigned long>::const_pointer"))
  .AddTypedef(type_7258, Reflex::Literal("std::map<unsigned long,unsigned long>::reference"))
  .AddTypedef(type_7260, Reflex::Literal("std::map<unsigned long,unsigned long>::const_reference"))
  .AddTypedef(type_1253, Reflex::Literal("std::map<unsigned long,unsigned long>::iterator"))
  .AddTypedef(type_1895, Reflex::Literal("std::map<unsigned long,unsigned long>::const_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::map<unsigned long,unsigned long>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::map<unsigned long,unsigned long>::difference_type"))
  .AddTypedef(type_1807, Reflex::Literal("std::map<unsigned long,unsigned long>::reverse_iterator"))
  .AddTypedef(type_1806, Reflex::Literal("std::map<unsigned long,unsigned long>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_14062, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_14063, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20514, type_20515), Reflex::Literal("map"), constructor_14064, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21292), Reflex::Literal("map"), constructor_14065, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1619, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x239, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedslong_unsignedslong__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedslong_unsignedslong__funcmem_bld);
}

//------Delayed data member builder for class map<long unsigned int,long unsigned int,std::less<long unsigned int>,std::allocator<std::pair<const long unsigned int, long unsigned int> > > -------------------
void __std__map_unsignedslong_unsignedslong__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1117, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedslong_unsignedslong_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<long unsigned int,long unsigned int,std::less<long unsigned int>,std::allocator<std::pair<const long unsigned int, long unsigned int> > > -------------------
void __std__map_unsignedslong_unsignedslong__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21293, type_21292), Reflex::Literal("operator="), operator_14066, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1384), Reflex::Literal("get_allocator"), method_14067, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1253), Reflex::Literal("begin"), method_14068, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1895), Reflex::Literal("begin"), method_14069, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1253), Reflex::Literal("end"), method_14070, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1895), Reflex::Literal("end"), method_14071, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_14076, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_14077, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_14078, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3483, type_3825), Reflex::Literal("operator[]"), operator_14079, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3483, type_3825), Reflex::Literal("at"), method_14080, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3825, type_3825), Reflex::Literal("at"), method_14081, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_912, type_7260), Reflex::Literal("insert"), method_14082, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1253, type_1253, type_7260), Reflex::Literal("insert"), method_14083, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1253), Reflex::Literal("erase"), method_14084, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_3825), Reflex::Literal("erase"), method_14085, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1253, type_1253), Reflex::Literal("erase"), method_14086, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_21293), Reflex::Literal("swap"), method_14087, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_14088, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2027), Reflex::Literal("key_comp"), method_14089, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1253, type_3825), Reflex::Literal("find"), method_14091, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1895, type_3825), Reflex::Literal("find"), method_14092, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_3825), Reflex::Literal("count"), method_14093, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1253, type_3825), Reflex::Literal("lower_bound"), method_14094, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1895, type_3825), Reflex::Literal("lower_bound"), method_14095, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1253, type_3825), Reflex::Literal("upper_bound"), method_14096, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1895, type_3825), Reflex::Literal("upper_bound"), method_14097, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_911, type_3825), Reflex::Literal("equal_range"), method_14098, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_910, type_3825), Reflex::Literal("equal_range"), method_14099, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<long unsigned int,std::vector<long unsigned int, std::allocator<long unsigned int> >,std::less<long unsigned int>,std::allocator<std::pair<const long unsigned int, std::vector<long unsigned int, std::allocator<long unsigned int> > > > > -------------------------------
static void destructor_14120(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned long,std::vector<unsigned long> >*)o)->::std::map<unsigned long,std::vector<unsigned long> >::~map)();
}
static void constructor_14121( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned long,std::vector<unsigned long> >();
  else ::new(mem) ::std::map<unsigned long,std::vector<unsigned long> >();
}

static void constructor_14122( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned long,std::vector<unsigned long> >(*(const ::std::less<unsigned long>*)arg[0]);
  else ::new(mem) ::std::map<unsigned long,std::vector<unsigned long> >(*(const ::std::less<unsigned long>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned long,std::vector<unsigned long> >(*(const ::std::less<unsigned long>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned long,std::vector<unsigned long> > >*)arg[1]);
  else ::new(mem) ::std::map<unsigned long,std::vector<unsigned long> >(*(const ::std::less<unsigned long>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned long,std::vector<unsigned long> > >*)arg[1]);
  }
}

static void constructor_14123( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned long,std::vector<unsigned long> >(*(const ::std::map<unsigned long,std::vector<unsigned long> >*)arg[0]);
  else ::new(mem) ::std::map<unsigned long,std::vector<unsigned long> >(*(const ::std::map<unsigned long,std::vector<unsigned long> >*)arg[0]);
}

static  void operator_14124( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned long,std::vector<unsigned long> >*)o)->operator=)(*(const ::std::map<unsigned long,std::vector<unsigned long> >*)arg[0]);
  else   (((::std::map<unsigned long,std::vector<unsigned long> >*)o)->operator=)(*(const ::std::map<unsigned long,std::vector<unsigned long> >*)arg[0]);
}

static  void method_14125( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned long,std::vector<unsigned long> > >)((((const ::std::map<unsigned long,std::vector<unsigned long> >*)o)->get_allocator)());
  else   (((const ::std::map<unsigned long,std::vector<unsigned long> >*)o)->get_allocator)();
}

static  void method_14126( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned long,std::vector<unsigned long> > >)((((::std::map<unsigned long,std::vector<unsigned long> >*)o)->begin)());
  else   (((::std::map<unsigned long,std::vector<unsigned long> >*)o)->begin)();
}

static  void method_14127( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned long,std::vector<unsigned long> > >)((((const ::std::map<unsigned long,std::vector<unsigned long> >*)o)->begin)());
  else   (((const ::std::map<unsigned long,std::vector<unsigned long> >*)o)->begin)();
}

static  void method_14128( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned long,std::vector<unsigned long> > >)((((::std::map<unsigned long,std::vector<unsigned long> >*)o)->end)());
  else   (((::std::map<unsigned long,std::vector<unsigned long> >*)o)->end)();
}

static  void method_14129( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned long,std::vector<unsigned long> > >)((((const ::std::map<unsigned long,std::vector<unsigned long> >*)o)->end)());
  else   (((const ::std::map<unsigned long,std::vector<unsigned long> >*)o)->end)();
}

static  void method_14134( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned long,std::vector<unsigned long> >*)o)->empty)());
  else   (((const ::std::map<unsigned long,std::vector<unsigned long> >*)o)->empty)();
}

static  void method_14135( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned long,std::vector<unsigned long> >*)o)->size)());
  else   (((const ::std::map<unsigned long,std::vector<unsigned long> >*)o)->size)();
}

static  void method_14136( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned long,std::vector<unsigned long> >*)o)->max_size)());
  else   (((const ::std::map<unsigned long,std::vector<unsigned long> >*)o)->max_size)();
}

static  void operator_14137( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned long,std::vector<unsigned long> >*)o)->operator[])(*(const unsigned long*)arg[0]);
  else   (((::std::map<unsigned long,std::vector<unsigned long> >*)o)->operator[])(*(const unsigned long*)arg[0]);
}

static  void method_14138( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned long,std::vector<unsigned long> >*)o)->at)(*(const unsigned long*)arg[0]);
  else   (((::std::map<unsigned long,std::vector<unsigned long> >*)o)->at)(*(const unsigned long*)arg[0]);
}

static  void method_14139( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned long,std::vector<unsigned long> >*)o)->at)(*(const unsigned long*)arg[0]);
  else   (((const ::std::map<unsigned long,std::vector<unsigned long> >*)o)->at)(*(const unsigned long*)arg[0]);
}

static  void method_14140( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned long,std::vector<unsigned long> > >,bool>)((((::std::map<unsigned long,std::vector<unsigned long> >*)o)->insert)(*(const ::std::pair<const unsigned long,std::vector<unsigned long> >*)arg[0]));
  else   (((::std::map<unsigned long,std::vector<unsigned long> >*)o)->insert)(*(const ::std::pair<const unsigned long,std::vector<unsigned long> >*)arg[0]);
}

static  void method_14141( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned long,std::vector<unsigned long> > >)((((::std::map<unsigned long,std::vector<unsigned long> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned long,std::vector<unsigned long> > >*)arg[0],
    *(const ::std::pair<const unsigned long,std::vector<unsigned long> >*)arg[1]));
  else   (((::std::map<unsigned long,std::vector<unsigned long> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned long,std::vector<unsigned long> > >*)arg[0],
    *(const ::std::pair<const unsigned long,std::vector<unsigned long> >*)arg[1]);
}

static  void method_14142( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned long,std::vector<unsigned long> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned long,std::vector<unsigned long> > >*)arg[0]);
}

static  void method_14143( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned long,std::vector<unsigned long> >*)o)->erase)(*(const unsigned long*)arg[0]));
  else   (((::std::map<unsigned long,std::vector<unsigned long> >*)o)->erase)(*(const unsigned long*)arg[0]);
}

static  void method_14144( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned long,std::vector<unsigned long> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned long,std::vector<unsigned long> > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned long,std::vector<unsigned long> > >*)arg[1]);
}

static  void method_14145( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned long,std::vector<unsigned long> >*)o)->swap)(*(::std::map<unsigned long,std::vector<unsigned long> >*)arg[0]);
}

static  void method_14146( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned long,std::vector<unsigned long> >*)o)->clear)();
}

static  void method_14147( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned long>)((((const ::std::map<unsigned long,std::vector<unsigned long> >*)o)->key_comp)());
  else   (((const ::std::map<unsigned long,std::vector<unsigned long> >*)o)->key_comp)();
}

static  void method_14149( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned long,std::vector<unsigned long> > >)((((::std::map<unsigned long,std::vector<unsigned long> >*)o)->find)(*(const unsigned long*)arg[0]));
  else   (((::std::map<unsigned long,std::vector<unsigned long> >*)o)->find)(*(const unsigned long*)arg[0]);
}

static  void method_14150( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned long,std::vector<unsigned long> > >)((((const ::std::map<unsigned long,std::vector<unsigned long> >*)o)->find)(*(const unsigned long*)arg[0]));
  else   (((const ::std::map<unsigned long,std::vector<unsigned long> >*)o)->find)(*(const unsigned long*)arg[0]);
}

static  void method_14151( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned long,std::vector<unsigned long> >*)o)->count)(*(const unsigned long*)arg[0]));
  else   (((const ::std::map<unsigned long,std::vector<unsigned long> >*)o)->count)(*(const unsigned long*)arg[0]);
}

static  void method_14152( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned long,std::vector<unsigned long> > >)((((::std::map<unsigned long,std::vector<unsigned long> >*)o)->lower_bound)(*(const unsigned long*)arg[0]));
  else   (((::std::map<unsigned long,std::vector<unsigned long> >*)o)->lower_bound)(*(const unsigned long*)arg[0]);
}

static  void method_14153( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned long,std::vector<unsigned long> > >)((((const ::std::map<unsigned long,std::vector<unsigned long> >*)o)->lower_bound)(*(const unsigned long*)arg[0]));
  else   (((const ::std::map<unsigned long,std::vector<unsigned long> >*)o)->lower_bound)(*(const unsigned long*)arg[0]);
}

static  void method_14154( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned long,std::vector<unsigned long> > >)((((::std::map<unsigned long,std::vector<unsigned long> >*)o)->upper_bound)(*(const unsigned long*)arg[0]));
  else   (((::std::map<unsigned long,std::vector<unsigned long> >*)o)->upper_bound)(*(const unsigned long*)arg[0]);
}

static  void method_14155( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned long,std::vector<unsigned long> > >)((((const ::std::map<unsigned long,std::vector<unsigned long> >*)o)->upper_bound)(*(const unsigned long*)arg[0]));
  else   (((const ::std::map<unsigned long,std::vector<unsigned long> >*)o)->upper_bound)(*(const unsigned long*)arg[0]);
}

static  void method_14156( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned long,std::vector<unsigned long> > >,std::_Rb_tree_iterator<std::pair<const unsigned long,std::vector<unsigned long> > > >)((((::std::map<unsigned long,std::vector<unsigned long> >*)o)->equal_range)(*(const unsigned long*)arg[0]));
  else   (((::std::map<unsigned long,std::vector<unsigned long> >*)o)->equal_range)(*(const unsigned long*)arg[0]);
}

static  void method_14157( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned long,std::vector<unsigned long> > >,std::_Rb_tree_const_iterator<std::pair<const unsigned long,std::vector<unsigned long> > > >)((((const ::std::map<unsigned long,std::vector<unsigned long> >*)o)->equal_range)(*(const unsigned long*)arg[0]));
  else   (((const ::std::map<unsigned long,std::vector<unsigned long> >*)o)->equal_range)(*(const unsigned long*)arg[0]);
}

static void method_newdel_1620( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned long,std::vector<unsigned long> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned long,std::vector<unsigned long> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned long,std::vector<unsigned long> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned long,std::vector<unsigned long> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned long,std::vector<unsigned long> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x241( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned long,std::vector<unsigned long> > >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned long,std::vector<unsigned long> > >::Generate();
}

//------Dictionary for class map<long unsigned int,std::vector<long unsigned int, std::allocator<long unsigned int> >,std::less<long unsigned int>,std::allocator<std::pair<const long unsigned int, std::vector<long unsigned int, std::allocator<long unsigned int> > > > > -------------------------------
void __std__map_unsignedslong_std__vector_unsignedslong_s__db_datamem(Reflex::Class*);
void __std__map_unsignedslong_std__vector_unsignedslong_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedslong_std__vector_unsignedslong_s__datamem_bld(&__std__map_unsignedslong_std__vector_unsignedslong_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedslong_std__vector_unsignedslong_s__funcmem_bld(&__std__map_unsignedslong_std__vector_unsignedslong_s__db_funcmem);
void __std__map_unsignedslong_std__vector_unsignedslong_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned long,std::vector<unsigned long> >"), typeid(::std::map<unsigned long,std::vector<unsigned long> >), sizeof(::std::map<unsigned long,std::vector<unsigned long> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_75, Reflex::Literal("std::map<unsigned long,std::vector<unsigned long> >::key_type"))
  .AddTypedef(type_1052, Reflex::Literal("std::map<unsigned long,std::vector<unsigned long> >::mapped_type"))
  .AddTypedef(type_869, Reflex::Literal("std::map<unsigned long,std::vector<unsigned long> >::value_type"))
  .AddTypedef(type_2027, Reflex::Literal("std::map<unsigned long,std::vector<unsigned long> >::key_compare"))
  .AddTypedef(type_1386, Reflex::Literal("std::map<unsigned long,std::vector<unsigned long> >::allocator_type"))
  .AddTypedef(type_869, Reflex::Literal("std::map<unsigned long,std::vector<unsigned long> >::_Alloc_value_type"))
  .AddTypedef(type_1386, Reflex::Literal("std::map<unsigned long,std::vector<unsigned long> >::_Pair_alloc_type"))
  .AddTypedef(type_1118, Reflex::Literal("std::map<unsigned long,std::vector<unsigned long> >::_Rep_type"))
  .AddTypedef(type_7359, Reflex::Literal("std::map<unsigned long,std::vector<unsigned long> >::pointer"))
  .AddTypedef(type_7361, Reflex::Literal("std::map<unsigned long,std::vector<unsigned long> >::const_pointer"))
  .AddTypedef(type_7363, Reflex::Literal("std::map<unsigned long,std::vector<unsigned long> >::reference"))
  .AddTypedef(type_7365, Reflex::Literal("std::map<unsigned long,std::vector<unsigned long> >::const_reference"))
  .AddTypedef(type_1254, Reflex::Literal("std::map<unsigned long,std::vector<unsigned long> >::iterator"))
  .AddTypedef(type_1896, Reflex::Literal("std::map<unsigned long,std::vector<unsigned long> >::const_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::map<unsigned long,std::vector<unsigned long> >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::map<unsigned long,std::vector<unsigned long> >::difference_type"))
  .AddTypedef(type_1809, Reflex::Literal("std::map<unsigned long,std::vector<unsigned long> >::reverse_iterator"))
  .AddTypedef(type_1808, Reflex::Literal("std::map<unsigned long,std::vector<unsigned long> >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_14120, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_14121, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20514, type_20522), Reflex::Literal("map"), constructor_14122, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21294), Reflex::Literal("map"), constructor_14123, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1620, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x241, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedslong_std__vector_unsignedslong_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedslong_std__vector_unsignedslong_s__funcmem_bld);
}

//------Delayed data member builder for class map<long unsigned int,std::vector<long unsigned int, std::allocator<long unsigned int> >,std::less<long unsigned int>,std::allocator<std::pair<const long unsigned int, std::vector<long unsigned int, std::allocator<long unsigned int> > > > > -------------------
void __std__map_unsignedslong_std__vector_unsignedslong_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1118, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedslong_std__vector_unsignedslong_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<long unsigned int,std::vector<long unsigned int, std::allocator<long unsigned int> >,std::less<long unsigned int>,std::allocator<std::pair<const long unsigned int, std::vector<long unsigned int, std::allocator<long unsigned int> > > > > -------------------
void __std__map_unsignedslong_std__vector_unsignedslong_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21295, type_21294), Reflex::Literal("operator="), operator_14124, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1386), Reflex::Literal("get_allocator"), method_14125, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1254), Reflex::Literal("begin"), method_14126, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1896), Reflex::Literal("begin"), method_14127, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1254), Reflex::Literal("end"), method_14128, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1896), Reflex::Literal("end"), method_14129, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_14134, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_14135, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_14136, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20292, type_3825), Reflex::Literal("operator[]"), operator_14137, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20292, type_3825), Reflex::Literal("at"), method_14138, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20187, type_3825), Reflex::Literal("at"), method_14139, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_915, type_7365), Reflex::Literal("insert"), method_14140, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1254, type_1254, type_7365), Reflex::Literal("insert"), method_14141, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1254), Reflex::Literal("erase"), method_14142, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_3825), Reflex::Literal("erase"), method_14143, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1254, type_1254), Reflex::Literal("erase"), method_14144, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_21295), Reflex::Literal("swap"), method_14145, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_14146, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2027), Reflex::Literal("key_comp"), method_14147, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1254, type_3825), Reflex::Literal("find"), method_14149, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1896, type_3825), Reflex::Literal("find"), method_14150, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_3825), Reflex::Literal("count"), method_14151, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1254, type_3825), Reflex::Literal("lower_bound"), method_14152, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1896, type_3825), Reflex::Literal("lower_bound"), method_14153, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1254, type_3825), Reflex::Literal("upper_bound"), method_14154, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1896, type_3825), Reflex::Literal("upper_bound"), method_14155, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_914, type_3825), Reflex::Literal("equal_range"), method_14156, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_913, type_3825), Reflex::Literal("equal_range"), method_14157, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<long long unsigned int,std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::less<long long unsigned int>,std::allocator<std::pair<const long long unsigned int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------------------
static void destructor_14178(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned long long,std::basic_string<char> >*)o)->::std::map<unsigned long long,std::basic_string<char> >::~map)();
}
static void constructor_14179( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned long long,std::basic_string<char> >();
  else ::new(mem) ::std::map<unsigned long long,std::basic_string<char> >();
}

static void constructor_14180( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned long long,std::basic_string<char> >(*(const ::std::less<unsigned long long>*)arg[0]);
  else ::new(mem) ::std::map<unsigned long long,std::basic_string<char> >(*(const ::std::less<unsigned long long>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned long long,std::basic_string<char> >(*(const ::std::less<unsigned long long>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned long long,std::basic_string<char> > >*)arg[1]);
  else ::new(mem) ::std::map<unsigned long long,std::basic_string<char> >(*(const ::std::less<unsigned long long>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned long long,std::basic_string<char> > >*)arg[1]);
  }
}

static void constructor_14181( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned long long,std::basic_string<char> >(*(const ::std::map<unsigned long long,std::basic_string<char> >*)arg[0]);
  else ::new(mem) ::std::map<unsigned long long,std::basic_string<char> >(*(const ::std::map<unsigned long long,std::basic_string<char> >*)arg[0]);
}

static  void operator_14182( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned long long,std::basic_string<char> >*)o)->operator=)(*(const ::std::map<unsigned long long,std::basic_string<char> >*)arg[0]);
  else   (((::std::map<unsigned long long,std::basic_string<char> >*)o)->operator=)(*(const ::std::map<unsigned long long,std::basic_string<char> >*)arg[0]);
}

static  void method_14183( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned long long,std::basic_string<char> > >)((((const ::std::map<unsigned long long,std::basic_string<char> >*)o)->get_allocator)());
  else   (((const ::std::map<unsigned long long,std::basic_string<char> >*)o)->get_allocator)();
}

static  void method_14184( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned long long,std::basic_string<char> > >)((((::std::map<unsigned long long,std::basic_string<char> >*)o)->begin)());
  else   (((::std::map<unsigned long long,std::basic_string<char> >*)o)->begin)();
}

static  void method_14185( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned long long,std::basic_string<char> > >)((((const ::std::map<unsigned long long,std::basic_string<char> >*)o)->begin)());
  else   (((const ::std::map<unsigned long long,std::basic_string<char> >*)o)->begin)();
}

static  void method_14186( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned long long,std::basic_string<char> > >)((((::std::map<unsigned long long,std::basic_string<char> >*)o)->end)());
  else   (((::std::map<unsigned long long,std::basic_string<char> >*)o)->end)();
}

static  void method_14187( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned long long,std::basic_string<char> > >)((((const ::std::map<unsigned long long,std::basic_string<char> >*)o)->end)());
  else   (((const ::std::map<unsigned long long,std::basic_string<char> >*)o)->end)();
}

static  void method_14192( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned long long,std::basic_string<char> >*)o)->empty)());
  else   (((const ::std::map<unsigned long long,std::basic_string<char> >*)o)->empty)();
}

static  void method_14193( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned long long,std::basic_string<char> >*)o)->size)());
  else   (((const ::std::map<unsigned long long,std::basic_string<char> >*)o)->size)();
}

static  void method_14194( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned long long,std::basic_string<char> >*)o)->max_size)());
  else   (((const ::std::map<unsigned long long,std::basic_string<char> >*)o)->max_size)();
}

static  void operator_14195( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned long long,std::basic_string<char> >*)o)->operator[])(*(const unsigned long long*)arg[0]);
  else   (((::std::map<unsigned long long,std::basic_string<char> >*)o)->operator[])(*(const unsigned long long*)arg[0]);
}

static  void method_14196( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned long long,std::basic_string<char> >*)o)->at)(*(const unsigned long long*)arg[0]);
  else   (((::std::map<unsigned long long,std::basic_string<char> >*)o)->at)(*(const unsigned long long*)arg[0]);
}

static  void method_14197( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned long long,std::basic_string<char> >*)o)->at)(*(const unsigned long long*)arg[0]);
  else   (((const ::std::map<unsigned long long,std::basic_string<char> >*)o)->at)(*(const unsigned long long*)arg[0]);
}

static  void method_14198( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned long long,std::basic_string<char> > >,bool>)((((::std::map<unsigned long long,std::basic_string<char> >*)o)->insert)(*(const ::std::pair<const unsigned long long,std::basic_string<char> >*)arg[0]));
  else   (((::std::map<unsigned long long,std::basic_string<char> >*)o)->insert)(*(const ::std::pair<const unsigned long long,std::basic_string<char> >*)arg[0]);
}

static  void method_14199( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned long long,std::basic_string<char> > >)((((::std::map<unsigned long long,std::basic_string<char> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned long long,std::basic_string<char> > >*)arg[0],
    *(const ::std::pair<const unsigned long long,std::basic_string<char> >*)arg[1]));
  else   (((::std::map<unsigned long long,std::basic_string<char> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned long long,std::basic_string<char> > >*)arg[0],
    *(const ::std::pair<const unsigned long long,std::basic_string<char> >*)arg[1]);
}

static  void method_14200( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned long long,std::basic_string<char> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned long long,std::basic_string<char> > >*)arg[0]);
}

static  void method_14201( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned long long,std::basic_string<char> >*)o)->erase)(*(const unsigned long long*)arg[0]));
  else   (((::std::map<unsigned long long,std::basic_string<char> >*)o)->erase)(*(const unsigned long long*)arg[0]);
}

static  void method_14202( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned long long,std::basic_string<char> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned long long,std::basic_string<char> > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned long long,std::basic_string<char> > >*)arg[1]);
}

static  void method_14203( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned long long,std::basic_string<char> >*)o)->swap)(*(::std::map<unsigned long long,std::basic_string<char> >*)arg[0]);
}

static  void method_14204( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned long long,std::basic_string<char> >*)o)->clear)();
}

static  void method_14205( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned long long>)((((const ::std::map<unsigned long long,std::basic_string<char> >*)o)->key_comp)());
  else   (((const ::std::map<unsigned long long,std::basic_string<char> >*)o)->key_comp)();
}

static  void method_14207( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned long long,std::basic_string<char> > >)((((::std::map<unsigned long long,std::basic_string<char> >*)o)->find)(*(const unsigned long long*)arg[0]));
  else   (((::std::map<unsigned long long,std::basic_string<char> >*)o)->find)(*(const unsigned long long*)arg[0]);
}

static  void method_14208( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned long long,std::basic_string<char> > >)((((const ::std::map<unsigned long long,std::basic_string<char> >*)o)->find)(*(const unsigned long long*)arg[0]));
  else   (((const ::std::map<unsigned long long,std::basic_string<char> >*)o)->find)(*(const unsigned long long*)arg[0]);
}

static  void method_14209( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned long long,std::basic_string<char> >*)o)->count)(*(const unsigned long long*)arg[0]));
  else   (((const ::std::map<unsigned long long,std::basic_string<char> >*)o)->count)(*(const unsigned long long*)arg[0]);
}

static  void method_14210( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned long long,std::basic_string<char> > >)((((::std::map<unsigned long long,std::basic_string<char> >*)o)->lower_bound)(*(const unsigned long long*)arg[0]));
  else   (((::std::map<unsigned long long,std::basic_string<char> >*)o)->lower_bound)(*(const unsigned long long*)arg[0]);
}

static  void method_14211( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned long long,std::basic_string<char> > >)((((const ::std::map<unsigned long long,std::basic_string<char> >*)o)->lower_bound)(*(const unsigned long long*)arg[0]));
  else   (((const ::std::map<unsigned long long,std::basic_string<char> >*)o)->lower_bound)(*(const unsigned long long*)arg[0]);
}

static  void method_14212( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned long long,std::basic_string<char> > >)((((::std::map<unsigned long long,std::basic_string<char> >*)o)->upper_bound)(*(const unsigned long long*)arg[0]));
  else   (((::std::map<unsigned long long,std::basic_string<char> >*)o)->upper_bound)(*(const unsigned long long*)arg[0]);
}

static  void method_14213( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned long long,std::basic_string<char> > >)((((const ::std::map<unsigned long long,std::basic_string<char> >*)o)->upper_bound)(*(const unsigned long long*)arg[0]));
  else   (((const ::std::map<unsigned long long,std::basic_string<char> >*)o)->upper_bound)(*(const unsigned long long*)arg[0]);
}

static  void method_14214( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned long long,std::basic_string<char> > >,std::_Rb_tree_iterator<std::pair<const unsigned long long,std::basic_string<char> > > >)((((::std::map<unsigned long long,std::basic_string<char> >*)o)->equal_range)(*(const unsigned long long*)arg[0]));
  else   (((::std::map<unsigned long long,std::basic_string<char> >*)o)->equal_range)(*(const unsigned long long*)arg[0]);
}

static  void method_14215( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned long long,std::basic_string<char> > >,std::_Rb_tree_const_iterator<std::pair<const unsigned long long,std::basic_string<char> > > >)((((const ::std::map<unsigned long long,std::basic_string<char> >*)o)->equal_range)(*(const unsigned long long*)arg[0]));
  else   (((const ::std::map<unsigned long long,std::basic_string<char> >*)o)->equal_range)(*(const unsigned long long*)arg[0]);
}

static void method_newdel_1621( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned long long,std::basic_string<char> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned long long,std::basic_string<char> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned long long,std::basic_string<char> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned long long,std::basic_string<char> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned long long,std::basic_string<char> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x243( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned long long,std::basic_string<char> > >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned long long,std::basic_string<char> > >::Generate();
}

//------Dictionary for class map<long long unsigned int,std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::less<long long unsigned int>,std::allocator<std::pair<const long long unsigned int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------------------
void __std__map_unsignedslongslong_std__basic_string_char_s__db_datamem(Reflex::Class*);
void __std__map_unsignedslongslong_std__basic_string_char_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedslongslong_std__basic_string_char_s__datamem_bld(&__std__map_unsignedslongslong_std__basic_string_char_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedslongslong_std__basic_string_char_s__funcmem_bld(&__std__map_unsignedslongslong_std__basic_string_char_s__db_funcmem);
void __std__map_unsignedslongslong_std__basic_string_char_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned long long,std::basic_string<char> >"), typeid(::std::map<unsigned long long,std::basic_string<char> >), sizeof(::std::map<unsigned long long,std::basic_string<char> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2144, Reflex::Literal("std::map<unsigned long long,std::basic_string<char> >::key_type"))
  .AddTypedef(type_1104, Reflex::Literal("std::map<unsigned long long,std::basic_string<char> >::mapped_type"))
  .AddTypedef(type_870, Reflex::Literal("std::map<unsigned long long,std::basic_string<char> >::value_type"))
  .AddTypedef(type_2028, Reflex::Literal("std::map<unsigned long long,std::basic_string<char> >::key_compare"))
  .AddTypedef(type_1388, Reflex::Literal("std::map<unsigned long long,std::basic_string<char> >::allocator_type"))
  .AddTypedef(type_870, Reflex::Literal("std::map<unsigned long long,std::basic_string<char> >::_Alloc_value_type"))
  .AddTypedef(type_1388, Reflex::Literal("std::map<unsigned long long,std::basic_string<char> >::_Pair_alloc_type"))
  .AddTypedef(type_1119, Reflex::Literal("std::map<unsigned long long,std::basic_string<char> >::_Rep_type"))
  .AddTypedef(type_7464, Reflex::Literal("std::map<unsigned long long,std::basic_string<char> >::pointer"))
  .AddTypedef(type_7466, Reflex::Literal("std::map<unsigned long long,std::basic_string<char> >::const_pointer"))
  .AddTypedef(type_7468, Reflex::Literal("std::map<unsigned long long,std::basic_string<char> >::reference"))
  .AddTypedef(type_7470, Reflex::Literal("std::map<unsigned long long,std::basic_string<char> >::const_reference"))
  .AddTypedef(type_1255, Reflex::Literal("std::map<unsigned long long,std::basic_string<char> >::iterator"))
  .AddTypedef(type_1897, Reflex::Literal("std::map<unsigned long long,std::basic_string<char> >::const_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::map<unsigned long long,std::basic_string<char> >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::map<unsigned long long,std::basic_string<char> >::difference_type"))
  .AddTypedef(type_1811, Reflex::Literal("std::map<unsigned long long,std::basic_string<char> >::reverse_iterator"))
  .AddTypedef(type_1810, Reflex::Literal("std::map<unsigned long long,std::basic_string<char> >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_14178, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_14179, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20529, type_20530), Reflex::Literal("map"), constructor_14180, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21296), Reflex::Literal("map"), constructor_14181, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1621, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x243, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedslongslong_std__basic_string_char_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedslongslong_std__basic_string_char_s__funcmem_bld);
}

//------Delayed data member builder for class map<long long unsigned int,std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::less<long long unsigned int>,std::allocator<std::pair<const long long unsigned int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------
void __std__map_unsignedslongslong_std__basic_string_char_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1119, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedslongslong_std__basic_string_char_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<long long unsigned int,std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::less<long long unsigned int>,std::allocator<std::pair<const long long unsigned int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------
void __std__map_unsignedslongslong_std__basic_string_char_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21297, type_21296), Reflex::Literal("operator="), operator_14182, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1388), Reflex::Literal("get_allocator"), method_14183, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1255), Reflex::Literal("begin"), method_14184, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1897), Reflex::Literal("begin"), method_14185, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1255), Reflex::Literal("end"), method_14186, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1897), Reflex::Literal("end"), method_14187, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_14192, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_14193, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_14194, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_3888), Reflex::Literal("operator[]"), operator_14195, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_3888), Reflex::Literal("at"), method_14196, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4981, type_3888), Reflex::Literal("at"), method_14197, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_918, type_7470), Reflex::Literal("insert"), method_14198, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1255, type_1255, type_7470), Reflex::Literal("insert"), method_14199, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1255), Reflex::Literal("erase"), method_14200, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_3888), Reflex::Literal("erase"), method_14201, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1255, type_1255), Reflex::Literal("erase"), method_14202, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_21297), Reflex::Literal("swap"), method_14203, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_14204, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2028), Reflex::Literal("key_comp"), method_14205, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1255, type_3888), Reflex::Literal("find"), method_14207, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1897, type_3888), Reflex::Literal("find"), method_14208, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_3888), Reflex::Literal("count"), method_14209, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1255, type_3888), Reflex::Literal("lower_bound"), method_14210, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1897, type_3888), Reflex::Literal("lower_bound"), method_14211, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1255, type_3888), Reflex::Literal("upper_bound"), method_14212, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1897, type_3888), Reflex::Literal("upper_bound"), method_14213, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_917, type_3888), Reflex::Literal("equal_range"), method_14214, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_916, type_3888), Reflex::Literal("equal_range"), method_14215, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<unsigned int,unsigned int,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, unsigned int> > > -------------------------------
static void destructor_14236(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned int,unsigned int>*)o)->::std::map<unsigned int,unsigned int>::~map)();
}
static void constructor_14237( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,unsigned int>();
  else ::new(mem) ::std::map<unsigned int,unsigned int>();
}

static void constructor_14238( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,unsigned int>(*(const ::std::less<unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,unsigned int>(*(const ::std::less<unsigned int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,unsigned int>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,unsigned int> >*)arg[1]);
  else ::new(mem) ::std::map<unsigned int,unsigned int>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,unsigned int> >*)arg[1]);
  }
}

static void constructor_14239( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,unsigned int>(*(const ::std::map<unsigned int,unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,unsigned int>(*(const ::std::map<unsigned int,unsigned int>*)arg[0]);
}

static  void operator_14240( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,unsigned int>*)o)->operator=)(*(const ::std::map<unsigned int,unsigned int>*)arg[0]);
  else   (((::std::map<unsigned int,unsigned int>*)o)->operator=)(*(const ::std::map<unsigned int,unsigned int>*)arg[0]);
}

static  void method_14241( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned int,unsigned int> >)((((const ::std::map<unsigned int,unsigned int>*)o)->get_allocator)());
  else   (((const ::std::map<unsigned int,unsigned int>*)o)->get_allocator)();
}

static  void method_14242( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,unsigned int> >)((((::std::map<unsigned int,unsigned int>*)o)->begin)());
  else   (((::std::map<unsigned int,unsigned int>*)o)->begin)();
}

static  void method_14243( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,unsigned int> >)((((const ::std::map<unsigned int,unsigned int>*)o)->begin)());
  else   (((const ::std::map<unsigned int,unsigned int>*)o)->begin)();
}

static  void method_14244( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,unsigned int> >)((((::std::map<unsigned int,unsigned int>*)o)->end)());
  else   (((::std::map<unsigned int,unsigned int>*)o)->end)();
}

static  void method_14245( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,unsigned int> >)((((const ::std::map<unsigned int,unsigned int>*)o)->end)());
  else   (((const ::std::map<unsigned int,unsigned int>*)o)->end)();
}

static  void method_14250( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned int,unsigned int>*)o)->empty)());
  else   (((const ::std::map<unsigned int,unsigned int>*)o)->empty)();
}

static  void method_14251( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,unsigned int>*)o)->size)());
  else   (((const ::std::map<unsigned int,unsigned int>*)o)->size)();
}

static  void method_14252( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,unsigned int>*)o)->max_size)());
  else   (((const ::std::map<unsigned int,unsigned int>*)o)->max_size)();
}

static  void operator_14253( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,unsigned int>*)o)->operator[])(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,unsigned int>*)o)->operator[])(*(const unsigned int*)arg[0]);
}

static  void method_14254( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,unsigned int>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,unsigned int>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14255( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned int,unsigned int>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((const ::std::map<unsigned int,unsigned int>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14256( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,unsigned int> >,bool>)((((::std::map<unsigned int,unsigned int>*)o)->insert)(*(const ::std::pair<const unsigned int,unsigned int>*)arg[0]));
  else   (((::std::map<unsigned int,unsigned int>*)o)->insert)(*(const ::std::pair<const unsigned int,unsigned int>*)arg[0]);
}

static  void method_14257( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,unsigned int> >)((((::std::map<unsigned int,unsigned int>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,unsigned int> >*)arg[0],
    *(const ::std::pair<const unsigned int,unsigned int>*)arg[1]));
  else   (((::std::map<unsigned int,unsigned int>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,unsigned int> >*)arg[0],
    *(const ::std::pair<const unsigned int,unsigned int>*)arg[1]);
}

static  void method_14258( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,unsigned int>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,unsigned int> >*)arg[0]);
}

static  void method_14259( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned int,unsigned int>*)o)->erase)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,unsigned int>*)o)->erase)(*(const unsigned int*)arg[0]);
}

static  void method_14260( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,unsigned int>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,unsigned int> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned int,unsigned int> >*)arg[1]);
}

static  void method_14261( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,unsigned int>*)o)->swap)(*(::std::map<unsigned int,unsigned int>*)arg[0]);
}

static  void method_14262( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned int,unsigned int>*)o)->clear)();
}

static  void method_14263( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned int>)((((const ::std::map<unsigned int,unsigned int>*)o)->key_comp)());
  else   (((const ::std::map<unsigned int,unsigned int>*)o)->key_comp)();
}

static  void method_14265( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,unsigned int> >)((((::std::map<unsigned int,unsigned int>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,unsigned int>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14266( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,unsigned int> >)((((const ::std::map<unsigned int,unsigned int>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,unsigned int>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14267( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,unsigned int>*)o)->count)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,unsigned int>*)o)->count)(*(const unsigned int*)arg[0]);
}

static  void method_14268( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,unsigned int> >)((((::std::map<unsigned int,unsigned int>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,unsigned int>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14269( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,unsigned int> >)((((const ::std::map<unsigned int,unsigned int>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,unsigned int>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14270( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,unsigned int> >)((((::std::map<unsigned int,unsigned int>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,unsigned int>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14271( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,unsigned int> >)((((const ::std::map<unsigned int,unsigned int>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,unsigned int>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14272( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,unsigned int> >,std::_Rb_tree_iterator<std::pair<const unsigned int,unsigned int> > >)((((::std::map<unsigned int,unsigned int>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,unsigned int>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static  void method_14273( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,unsigned int> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,unsigned int> > >)((((const ::std::map<unsigned int,unsigned int>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,unsigned int>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static void method_newdel_1622( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,unsigned int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,unsigned int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,unsigned int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,unsigned int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,unsigned int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x245( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned int,unsigned int> >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned int,unsigned int> >::Generate();
}

//------Dictionary for class map<unsigned int,unsigned int,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, unsigned int> > > -------------------------------
void __std__map_unsignedsint_unsignedsint__db_datamem(Reflex::Class*);
void __std__map_unsignedsint_unsignedsint__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_unsignedsint__datamem_bld(&__std__map_unsignedsint_unsignedsint__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_unsignedsint__funcmem_bld(&__std__map_unsignedsint_unsignedsint__db_funcmem);
void __std__map_unsignedsint_unsignedsint__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned int,unsigned int>"), typeid(::std::map<unsigned int,unsigned int>), sizeof(::std::map<unsigned int,unsigned int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_78, Reflex::Literal("std::map<unsigned int,unsigned int>::key_type"))
  .AddTypedef(type_78, Reflex::Literal("std::map<unsigned int,unsigned int>::mapped_type"))
  .AddTypedef(type_871, Reflex::Literal("std::map<unsigned int,unsigned int>::value_type"))
  .AddTypedef(type_2029, Reflex::Literal("std::map<unsigned int,unsigned int>::key_compare"))
  .AddTypedef(type_1390, Reflex::Literal("std::map<unsigned int,unsigned int>::allocator_type"))
  .AddTypedef(type_871, Reflex::Literal("std::map<unsigned int,unsigned int>::_Alloc_value_type"))
  .AddTypedef(type_1390, Reflex::Literal("std::map<unsigned int,unsigned int>::_Pair_alloc_type"))
  .AddTypedef(type_1120, Reflex::Literal("std::map<unsigned int,unsigned int>::_Rep_type"))
  .AddTypedef(type_7569, Reflex::Literal("std::map<unsigned int,unsigned int>::pointer"))
  .AddTypedef(type_7571, Reflex::Literal("std::map<unsigned int,unsigned int>::const_pointer"))
  .AddTypedef(type_7573, Reflex::Literal("std::map<unsigned int,unsigned int>::reference"))
  .AddTypedef(type_7575, Reflex::Literal("std::map<unsigned int,unsigned int>::const_reference"))
  .AddTypedef(type_1256, Reflex::Literal("std::map<unsigned int,unsigned int>::iterator"))
  .AddTypedef(type_1898, Reflex::Literal("std::map<unsigned int,unsigned int>::const_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::map<unsigned int,unsigned int>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::map<unsigned int,unsigned int>::difference_type"))
  .AddTypedef(type_1813, Reflex::Literal("std::map<unsigned int,unsigned int>::reverse_iterator"))
  .AddTypedef(type_1812, Reflex::Literal("std::map<unsigned int,unsigned int>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_14236, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_14237, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20537, type_20538), Reflex::Literal("map"), constructor_14238, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21298), Reflex::Literal("map"), constructor_14239, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1622, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x245, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsint_unsignedsint__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsint_unsignedsint__funcmem_bld);
}

//------Delayed data member builder for class map<unsigned int,unsigned int,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, unsigned int> > > -------------------
void __std__map_unsignedsint_unsignedsint__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1120, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsint_unsignedsint_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<unsigned int,unsigned int,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, unsigned int> > > -------------------
void __std__map_unsignedsint_unsignedsint__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21299, type_21298), Reflex::Literal("operator="), operator_14240, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1390), Reflex::Literal("get_allocator"), method_14241, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1256), Reflex::Literal("begin"), method_14242, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1898), Reflex::Literal("begin"), method_14243, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1256), Reflex::Literal("end"), method_14244, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1898), Reflex::Literal("end"), method_14245, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_14250, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_14251, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_14252, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3505, type_3951), Reflex::Literal("operator[]"), operator_14253, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3505, type_3951), Reflex::Literal("at"), method_14254, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3951, type_3951), Reflex::Literal("at"), method_14255, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_921, type_7575), Reflex::Literal("insert"), method_14256, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1256, type_1256, type_7575), Reflex::Literal("insert"), method_14257, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1256), Reflex::Literal("erase"), method_14258, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_3951), Reflex::Literal("erase"), method_14259, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1256, type_1256), Reflex::Literal("erase"), method_14260, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_21299), Reflex::Literal("swap"), method_14261, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_14262, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2029), Reflex::Literal("key_comp"), method_14263, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1256, type_3951), Reflex::Literal("find"), method_14265, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1898, type_3951), Reflex::Literal("find"), method_14266, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_3951), Reflex::Literal("count"), method_14267, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1256, type_3951), Reflex::Literal("lower_bound"), method_14268, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1898, type_3951), Reflex::Literal("lower_bound"), method_14269, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1256, type_3951), Reflex::Literal("upper_bound"), method_14270, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1898, type_3951), Reflex::Literal("upper_bound"), method_14271, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_920, type_3951), Reflex::Literal("equal_range"), method_14272, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_919, type_3951), Reflex::Literal("equal_range"), method_14273, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<unsigned int,std::vector<unsigned int, std::allocator<unsigned int> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<unsigned int, std::allocator<unsigned int> > > > > -------------------------------
static void destructor_14294(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned int,std::vector<unsigned int> >*)o)->::std::map<unsigned int,std::vector<unsigned int> >::~map)();
}
static void constructor_14295( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<unsigned int> >();
  else ::new(mem) ::std::map<unsigned int,std::vector<unsigned int> >();
}

static void constructor_14296( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<unsigned int> >(*(const ::std::less<unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,std::vector<unsigned int> >(*(const ::std::less<unsigned int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<unsigned int> >(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,std::vector<unsigned int> > >*)arg[1]);
  else ::new(mem) ::std::map<unsigned int,std::vector<unsigned int> >(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,std::vector<unsigned int> > >*)arg[1]);
  }
}

static void constructor_14297( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<unsigned int> >(*(const ::std::map<unsigned int,std::vector<unsigned int> >*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,std::vector<unsigned int> >(*(const ::std::map<unsigned int,std::vector<unsigned int> >*)arg[0]);
}

static  void operator_14298( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::vector<unsigned int> >*)o)->operator=)(*(const ::std::map<unsigned int,std::vector<unsigned int> >*)arg[0]);
  else   (((::std::map<unsigned int,std::vector<unsigned int> >*)o)->operator=)(*(const ::std::map<unsigned int,std::vector<unsigned int> >*)arg[0]);
}

static  void method_14299( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned int,std::vector<unsigned int> > >)((((const ::std::map<unsigned int,std::vector<unsigned int> >*)o)->get_allocator)());
  else   (((const ::std::map<unsigned int,std::vector<unsigned int> >*)o)->get_allocator)();
}

static  void method_14300( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<unsigned int> > >)((((::std::map<unsigned int,std::vector<unsigned int> >*)o)->begin)());
  else   (((::std::map<unsigned int,std::vector<unsigned int> >*)o)->begin)();
}

static  void method_14301( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<unsigned int> > >)((((const ::std::map<unsigned int,std::vector<unsigned int> >*)o)->begin)());
  else   (((const ::std::map<unsigned int,std::vector<unsigned int> >*)o)->begin)();
}

static  void method_14302( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<unsigned int> > >)((((::std::map<unsigned int,std::vector<unsigned int> >*)o)->end)());
  else   (((::std::map<unsigned int,std::vector<unsigned int> >*)o)->end)();
}

static  void method_14303( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<unsigned int> > >)((((const ::std::map<unsigned int,std::vector<unsigned int> >*)o)->end)());
  else   (((const ::std::map<unsigned int,std::vector<unsigned int> >*)o)->end)();
}

static  void method_14308( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned int,std::vector<unsigned int> >*)o)->empty)());
  else   (((const ::std::map<unsigned int,std::vector<unsigned int> >*)o)->empty)();
}

static  void method_14309( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::vector<unsigned int> >*)o)->size)());
  else   (((const ::std::map<unsigned int,std::vector<unsigned int> >*)o)->size)();
}

static  void method_14310( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::vector<unsigned int> >*)o)->max_size)());
  else   (((const ::std::map<unsigned int,std::vector<unsigned int> >*)o)->max_size)();
}

static  void operator_14311( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::vector<unsigned int> >*)o)->operator[])(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,std::vector<unsigned int> >*)o)->operator[])(*(const unsigned int*)arg[0]);
}

static  void method_14312( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::vector<unsigned int> >*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,std::vector<unsigned int> >*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14313( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned int,std::vector<unsigned int> >*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((const ::std::map<unsigned int,std::vector<unsigned int> >*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14314( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<unsigned int> > >,bool>)((((::std::map<unsigned int,std::vector<unsigned int> >*)o)->insert)(*(const ::std::pair<const unsigned int,std::vector<unsigned int> >*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<unsigned int> >*)o)->insert)(*(const ::std::pair<const unsigned int,std::vector<unsigned int> >*)arg[0]);
}

static  void method_14315( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<unsigned int> > >)((((::std::map<unsigned int,std::vector<unsigned int> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<unsigned int> > >*)arg[0],
    *(const ::std::pair<const unsigned int,std::vector<unsigned int> >*)arg[1]));
  else   (((::std::map<unsigned int,std::vector<unsigned int> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<unsigned int> > >*)arg[0],
    *(const ::std::pair<const unsigned int,std::vector<unsigned int> >*)arg[1]);
}

static  void method_14316( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::vector<unsigned int> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<unsigned int> > >*)arg[0]);
}

static  void method_14317( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned int,std::vector<unsigned int> >*)o)->erase)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<unsigned int> >*)o)->erase)(*(const unsigned int*)arg[0]);
}

static  void method_14318( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::vector<unsigned int> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<unsigned int> > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<unsigned int> > >*)arg[1]);
}

static  void method_14319( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::vector<unsigned int> >*)o)->swap)(*(::std::map<unsigned int,std::vector<unsigned int> >*)arg[0]);
}

static  void method_14320( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned int,std::vector<unsigned int> >*)o)->clear)();
}

static  void method_14321( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned int>)((((const ::std::map<unsigned int,std::vector<unsigned int> >*)o)->key_comp)());
  else   (((const ::std::map<unsigned int,std::vector<unsigned int> >*)o)->key_comp)();
}

static  void method_14323( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<unsigned int> > >)((((::std::map<unsigned int,std::vector<unsigned int> >*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<unsigned int> >*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14324( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<unsigned int> > >)((((const ::std::map<unsigned int,std::vector<unsigned int> >*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<unsigned int> >*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14325( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::vector<unsigned int> >*)o)->count)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<unsigned int> >*)o)->count)(*(const unsigned int*)arg[0]);
}

static  void method_14326( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<unsigned int> > >)((((::std::map<unsigned int,std::vector<unsigned int> >*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<unsigned int> >*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14327( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<unsigned int> > >)((((const ::std::map<unsigned int,std::vector<unsigned int> >*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<unsigned int> >*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14328( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<unsigned int> > >)((((::std::map<unsigned int,std::vector<unsigned int> >*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<unsigned int> >*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14329( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<unsigned int> > >)((((const ::std::map<unsigned int,std::vector<unsigned int> >*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<unsigned int> >*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14330( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<unsigned int> > >,std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<unsigned int> > > >)((((::std::map<unsigned int,std::vector<unsigned int> >*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<unsigned int> >*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static  void method_14331( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<unsigned int> > >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<unsigned int> > > >)((((const ::std::map<unsigned int,std::vector<unsigned int> >*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<unsigned int> >*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static void method_newdel_1623( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<unsigned int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<unsigned int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<unsigned int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<unsigned int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<unsigned int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x247( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned int,std::vector<unsigned int> > >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned int,std::vector<unsigned int> > >::Generate();
}

//------Dictionary for class map<unsigned int,std::vector<unsigned int, std::allocator<unsigned int> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<unsigned int, std::allocator<unsigned int> > > > > -------------------------------
void __std__map_unsignedsint_std__vector_unsignedsint_s__db_datamem(Reflex::Class*);
void __std__map_unsignedsint_std__vector_unsignedsint_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_std__vector_unsignedsint_s__datamem_bld(&__std__map_unsignedsint_std__vector_unsignedsint_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_std__vector_unsignedsint_s__funcmem_bld(&__std__map_unsignedsint_std__vector_unsignedsint_s__db_funcmem);
void __std__map_unsignedsint_std__vector_unsignedsint_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned int,std::vector<unsigned int> >"), typeid(::std::map<unsigned int,std::vector<unsigned int> >), sizeof(::std::map<unsigned int,std::vector<unsigned int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_78, Reflex::Literal("std::map<unsigned int,std::vector<unsigned int> >::key_type"))
  .AddTypedef(type_1054, Reflex::Literal("std::map<unsigned int,std::vector<unsigned int> >::mapped_type"))
  .AddTypedef(type_872, Reflex::Literal("std::map<unsigned int,std::vector<unsigned int> >::value_type"))
  .AddTypedef(type_2029, Reflex::Literal("std::map<unsigned int,std::vector<unsigned int> >::key_compare"))
  .AddTypedef(type_1392, Reflex::Literal("std::map<unsigned int,std::vector<unsigned int> >::allocator_type"))
  .AddTypedef(type_872, Reflex::Literal("std::map<unsigned int,std::vector<unsigned int> >::_Alloc_value_type"))
  .AddTypedef(type_1392, Reflex::Literal("std::map<unsigned int,std::vector<unsigned int> >::_Pair_alloc_type"))
  .AddTypedef(type_1121, Reflex::Literal("std::map<unsigned int,std::vector<unsigned int> >::_Rep_type"))
  .AddTypedef(type_7674, Reflex::Literal("std::map<unsigned int,std::vector<unsigned int> >::pointer"))
  .AddTypedef(type_7676, Reflex::Literal("std::map<unsigned int,std::vector<unsigned int> >::const_pointer"))
  .AddTypedef(type_7678, Reflex::Literal("std::map<unsigned int,std::vector<unsigned int> >::reference"))
  .AddTypedef(type_7680, Reflex::Literal("std::map<unsigned int,std::vector<unsigned int> >::const_reference"))
  .AddTypedef(type_1257, Reflex::Literal("std::map<unsigned int,std::vector<unsigned int> >::iterator"))
  .AddTypedef(type_1899, Reflex::Literal("std::map<unsigned int,std::vector<unsigned int> >::const_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::map<unsigned int,std::vector<unsigned int> >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::map<unsigned int,std::vector<unsigned int> >::difference_type"))
  .AddTypedef(type_1815, Reflex::Literal("std::map<unsigned int,std::vector<unsigned int> >::reverse_iterator"))
  .AddTypedef(type_1814, Reflex::Literal("std::map<unsigned int,std::vector<unsigned int> >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_14294, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_14295, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20537, type_20545), Reflex::Literal("map"), constructor_14296, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21300), Reflex::Literal("map"), constructor_14297, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1623, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x247, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsint_std__vector_unsignedsint_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsint_std__vector_unsignedsint_s__funcmem_bld);
}

//------Delayed data member builder for class map<unsigned int,std::vector<unsigned int, std::allocator<unsigned int> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<unsigned int, std::allocator<unsigned int> > > > > -------------------
void __std__map_unsignedsint_std__vector_unsignedsint_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1121, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsint_std__vector_unsignedsint_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<unsigned int,std::vector<unsigned int, std::allocator<unsigned int> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<unsigned int, std::allocator<unsigned int> > > > > -------------------
void __std__map_unsignedsint_std__vector_unsignedsint_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21301, type_21300), Reflex::Literal("operator="), operator_14298, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1392), Reflex::Literal("get_allocator"), method_14299, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1257), Reflex::Literal("begin"), method_14300, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1899), Reflex::Literal("begin"), method_14301, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1257), Reflex::Literal("end"), method_14302, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1899), Reflex::Literal("end"), method_14303, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_14308, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_14309, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_14310, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4209, type_3951), Reflex::Literal("operator[]"), operator_14311, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4209, type_3951), Reflex::Literal("at"), method_14312, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4211, type_3951), Reflex::Literal("at"), method_14313, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_924, type_7680), Reflex::Literal("insert"), method_14314, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1257, type_1257, type_7680), Reflex::Literal("insert"), method_14315, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1257), Reflex::Literal("erase"), method_14316, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_3951), Reflex::Literal("erase"), method_14317, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1257, type_1257), Reflex::Literal("erase"), method_14318, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_21301), Reflex::Literal("swap"), method_14319, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_14320, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2029), Reflex::Literal("key_comp"), method_14321, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1257, type_3951), Reflex::Literal("find"), method_14323, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1899, type_3951), Reflex::Literal("find"), method_14324, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_3951), Reflex::Literal("count"), method_14325, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1257, type_3951), Reflex::Literal("lower_bound"), method_14326, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1899, type_3951), Reflex::Literal("lower_bound"), method_14327, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1257, type_3951), Reflex::Literal("upper_bound"), method_14328, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1899, type_3951), Reflex::Literal("upper_bound"), method_14329, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_923, type_3951), Reflex::Literal("equal_range"), method_14330, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_922, type_3951), Reflex::Literal("equal_range"), method_14331, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<unsigned int,std::vector<std::pair<unsigned int, float>, std::allocator<std::pair<unsigned int, float> > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<std::pair<unsigned int, float>, std::allocator<std::pair<unsigned int, float> > > > > > -------------------------------
static void destructor_14352(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >::~map)();
}
static void constructor_14353( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >();
  else ::new(mem) ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >();
}

static void constructor_14354( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >(*(const ::std::less<unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >(*(const ::std::less<unsigned int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > > >*)arg[1]);
  else ::new(mem) ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > > >*)arg[1]);
  }
}

static void constructor_14355( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >(*(const ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >(*(const ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)arg[0]);
}

static  void operator_14356( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->operator=)(*(const ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)arg[0]);
  else   (((::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->operator=)(*(const ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)arg[0]);
}

static  void method_14357( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > > >)((((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->get_allocator)());
  else   (((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->get_allocator)();
}

static  void method_14358( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > > >)((((::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->begin)());
  else   (((::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->begin)();
}

static  void method_14359( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > > >)((((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->begin)());
  else   (((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->begin)();
}

static  void method_14360( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > > >)((((::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->end)());
  else   (((::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->end)();
}

static  void method_14361( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > > >)((((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->end)());
  else   (((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->end)();
}

static  void method_14366( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->empty)());
  else   (((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->empty)();
}

static  void method_14367( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->size)());
  else   (((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->size)();
}

static  void method_14368( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->max_size)());
  else   (((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->max_size)();
}

static  void operator_14369( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->operator[])(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->operator[])(*(const unsigned int*)arg[0]);
}

static  void method_14370( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14371( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14372( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > > >,bool>)((((::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->insert)(*(const ::std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > >*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->insert)(*(const ::std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > >*)arg[0]);
}

static  void method_14373( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > > >)((((::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > > >*)arg[0],
    *(const ::std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > >*)arg[1]));
  else   (((::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > > >*)arg[0],
    *(const ::std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > >*)arg[1]);
}

static  void method_14374( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > > >*)arg[0]);
}

static  void method_14375( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->erase)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->erase)(*(const unsigned int*)arg[0]);
}

static  void method_14376( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > > >*)arg[1]);
}

static  void method_14377( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->swap)(*(::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)arg[0]);
}

static  void method_14378( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->clear)();
}

static  void method_14379( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned int>)((((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->key_comp)());
  else   (((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->key_comp)();
}

static  void method_14381( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > > >)((((::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14382( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > > >)((((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14383( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->count)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->count)(*(const unsigned int*)arg[0]);
}

static  void method_14384( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > > >)((((::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14385( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > > >)((((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14386( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > > >)((((::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14387( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > > >)((((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14388( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > > >,std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > > > >)((((::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static  void method_14389( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > > >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,float> > > > >)((((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static void method_newdel_1624( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x249( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > > >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > > >::Generate();
}

//------Dictionary for class map<unsigned int,std::vector<std::pair<unsigned int, float>, std::allocator<std::pair<unsigned int, float> > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<std::pair<unsigned int, float>, std::allocator<std::pair<unsigned int, float> > > > > > -------------------------------
void __std__map_unsignedsint_std__vector_std__pair_unsignedsint_float_s_s__db_datamem(Reflex::Class*);
void __std__map_unsignedsint_std__vector_std__pair_unsignedsint_float_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_std__vector_std__pair_unsignedsint_float_s_s__datamem_bld(&__std__map_unsignedsint_std__vector_std__pair_unsignedsint_float_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_std__vector_std__pair_unsignedsint_float_s_s__funcmem_bld(&__std__map_unsignedsint_std__vector_std__pair_unsignedsint_float_s_s__db_funcmem);
void __std__map_unsignedsint_std__vector_std__pair_unsignedsint_float_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >"), typeid(::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >), sizeof(::std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_78, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >::key_type"))
  .AddTypedef(type_1074, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >::mapped_type"))
  .AddTypedef(type_926, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >::value_type"))
  .AddTypedef(type_2029, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >::key_compare"))
  .AddTypedef(type_1394, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >::allocator_type"))
  .AddTypedef(type_926, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >::_Alloc_value_type"))
  .AddTypedef(type_1394, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >::_Pair_alloc_type"))
  .AddTypedef(type_1122, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >::_Rep_type"))
  .AddTypedef(type_7779, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >::pointer"))
  .AddTypedef(type_7781, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >::const_pointer"))
  .AddTypedef(type_7783, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >::reference"))
  .AddTypedef(type_7785, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >::const_reference"))
  .AddTypedef(type_1258, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >::iterator"))
  .AddTypedef(type_1900, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >::const_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >::difference_type"))
  .AddTypedef(type_1817, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >::reverse_iterator"))
  .AddTypedef(type_1816, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,float> > >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_14352, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_14353, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20537, type_20552), Reflex::Literal("map"), constructor_14354, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21302), Reflex::Literal("map"), constructor_14355, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1624, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x249, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsint_std__vector_std__pair_unsignedsint_float_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsint_std__vector_std__pair_unsignedsint_float_s_s__funcmem_bld);
}

//------Delayed data member builder for class map<unsigned int,std::vector<std::pair<unsigned int, float>, std::allocator<std::pair<unsigned int, float> > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<std::pair<unsigned int, float>, std::allocator<std::pair<unsigned int, float> > > > > > -------------------
void __std__map_unsignedsint_std__vector_std__pair_unsignedsint_float_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1122, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsint_std__vector_std__pair_unsignedsint_float_s_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<unsigned int,std::vector<std::pair<unsigned int, float>, std::allocator<std::pair<unsigned int, float> > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<std::pair<unsigned int, float>, std::allocator<std::pair<unsigned int, float> > > > > > -------------------
void __std__map_unsignedsint_std__vector_std__pair_unsignedsint_float_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21303, type_21302), Reflex::Literal("operator="), operator_14356, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1394), Reflex::Literal("get_allocator"), method_14357, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1258), Reflex::Literal("begin"), method_14358, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1900), Reflex::Literal("begin"), method_14359, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1258), Reflex::Literal("end"), method_14360, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1900), Reflex::Literal("end"), method_14361, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_14366, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_14367, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_14368, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20360, type_3951), Reflex::Literal("operator[]"), operator_14369, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20360, type_3951), Reflex::Literal("at"), method_14370, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20359, type_3951), Reflex::Literal("at"), method_14371, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_928, type_7785), Reflex::Literal("insert"), method_14372, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1258, type_1258, type_7785), Reflex::Literal("insert"), method_14373, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1258), Reflex::Literal("erase"), method_14374, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_3951), Reflex::Literal("erase"), method_14375, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1258, type_1258), Reflex::Literal("erase"), method_14376, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_21303), Reflex::Literal("swap"), method_14377, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_14378, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2029), Reflex::Literal("key_comp"), method_14379, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1258, type_3951), Reflex::Literal("find"), method_14381, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1900, type_3951), Reflex::Literal("find"), method_14382, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_3951), Reflex::Literal("count"), method_14383, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1258, type_3951), Reflex::Literal("lower_bound"), method_14384, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1900, type_3951), Reflex::Literal("lower_bound"), method_14385, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1258, type_3951), Reflex::Literal("upper_bound"), method_14386, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1900, type_3951), Reflex::Literal("upper_bound"), method_14387, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_927, type_3951), Reflex::Literal("equal_range"), method_14388, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_925, type_3951), Reflex::Literal("equal_range"), method_14389, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<unsigned int,std::vector<std::pair<unsigned int, double>, std::allocator<std::pair<unsigned int, double> > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<std::pair<unsigned int, double>, std::allocator<std::pair<unsigned int, double> > > > > > -------------------------------
static void destructor_14410(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >::~map)();
}
static void constructor_14411( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >();
  else ::new(mem) ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >();
}

static void constructor_14412( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >(*(const ::std::less<unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >(*(const ::std::less<unsigned int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > >*)arg[1]);
  else ::new(mem) ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > >*)arg[1]);
  }
}

static void constructor_14413( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >(*(const ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >(*(const ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)arg[0]);
}

static  void operator_14414( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->operator=)(*(const ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)arg[0]);
  else   (((::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->operator=)(*(const ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)arg[0]);
}

static  void method_14415( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > >)((((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->get_allocator)());
  else   (((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->get_allocator)();
}

static  void method_14416( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > >)((((::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->begin)());
  else   (((::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->begin)();
}

static  void method_14417( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > >)((((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->begin)());
  else   (((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->begin)();
}

static  void method_14418( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > >)((((::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->end)());
  else   (((::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->end)();
}

static  void method_14419( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > >)((((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->end)());
  else   (((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->end)();
}

static  void method_14424( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->empty)());
  else   (((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->empty)();
}

static  void method_14425( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->size)());
  else   (((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->size)();
}

static  void method_14426( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->max_size)());
  else   (((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->max_size)();
}

static  void operator_14427( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->operator[])(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->operator[])(*(const unsigned int*)arg[0]);
}

static  void method_14428( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14429( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14430( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > >,bool>)((((::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->insert)(*(const ::std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > >*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->insert)(*(const ::std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > >*)arg[0]);
}

static  void method_14431( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > >)((((::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > >*)arg[0],
    *(const ::std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > >*)arg[1]));
  else   (((::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > >*)arg[0],
    *(const ::std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > >*)arg[1]);
}

static  void method_14432( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > >*)arg[0]);
}

static  void method_14433( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->erase)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->erase)(*(const unsigned int*)arg[0]);
}

static  void method_14434( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > >*)arg[1]);
}

static  void method_14435( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->swap)(*(::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)arg[0]);
}

static  void method_14436( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->clear)();
}

static  void method_14437( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned int>)((((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->key_comp)());
  else   (((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->key_comp)();
}

static  void method_14439( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > >)((((::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14440( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > >)((((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14441( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->count)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->count)(*(const unsigned int*)arg[0]);
}

static  void method_14442( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > >)((((::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14443( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > >)((((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14444( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > >)((((::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14445( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > >)((((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14446( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > >,std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > > >)((((::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static  void method_14447( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > > >)((((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static void method_newdel_1625( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x251( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > > >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > > >::Generate();
}

//------Dictionary for class map<unsigned int,std::vector<std::pair<unsigned int, double>, std::allocator<std::pair<unsigned int, double> > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<std::pair<unsigned int, double>, std::allocator<std::pair<unsigned int, double> > > > > > -------------------------------
void __std__map_unsignedsint_std__vector_std__pair_unsignedsint_double_s_s__db_datamem(Reflex::Class*);
void __std__map_unsignedsint_std__vector_std__pair_unsignedsint_double_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_std__vector_std__pair_unsignedsint_double_s_s__datamem_bld(&__std__map_unsignedsint_std__vector_std__pair_unsignedsint_double_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_std__vector_std__pair_unsignedsint_double_s_s__funcmem_bld(&__std__map_unsignedsint_std__vector_std__pair_unsignedsint_double_s_s__db_funcmem);
void __std__map_unsignedsint_std__vector_std__pair_unsignedsint_double_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >"), typeid(::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >), sizeof(::std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_78, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >::key_type"))
  .AddTypedef(type_1075, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >::mapped_type"))
  .AddTypedef(type_873, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >::value_type"))
  .AddTypedef(type_2029, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >::key_compare"))
  .AddTypedef(type_1396, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >::allocator_type"))
  .AddTypedef(type_873, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >::_Alloc_value_type"))
  .AddTypedef(type_1396, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >::_Pair_alloc_type"))
  .AddTypedef(type_1123, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >::_Rep_type"))
  .AddTypedef(type_7884, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >::pointer"))
  .AddTypedef(type_7886, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >::const_pointer"))
  .AddTypedef(type_7888, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >::reference"))
  .AddTypedef(type_7890, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >::const_reference"))
  .AddTypedef(type_1259, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >::iterator"))
  .AddTypedef(type_1901, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >::const_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >::difference_type"))
  .AddTypedef(type_1819, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >::reverse_iterator"))
  .AddTypedef(type_1818, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,double> > >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_14410, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_14411, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20537, type_20559), Reflex::Literal("map"), constructor_14412, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21304), Reflex::Literal("map"), constructor_14413, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1625, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x251, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsint_std__vector_std__pair_unsignedsint_double_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsint_std__vector_std__pair_unsignedsint_double_s_s__funcmem_bld);
}

//------Delayed data member builder for class map<unsigned int,std::vector<std::pair<unsigned int, double>, std::allocator<std::pair<unsigned int, double> > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<std::pair<unsigned int, double>, std::allocator<std::pair<unsigned int, double> > > > > > -------------------
void __std__map_unsignedsint_std__vector_std__pair_unsignedsint_double_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1123, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsint_std__vector_std__pair_unsignedsint_double_s_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<unsigned int,std::vector<std::pair<unsigned int, double>, std::allocator<std::pair<unsigned int, double> > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<std::pair<unsigned int, double>, std::allocator<std::pair<unsigned int, double> > > > > > -------------------
void __std__map_unsignedsint_std__vector_std__pair_unsignedsint_double_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21305, type_21304), Reflex::Literal("operator="), operator_14414, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1396), Reflex::Literal("get_allocator"), method_14415, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1259), Reflex::Literal("begin"), method_14416, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1901), Reflex::Literal("begin"), method_14417, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1259), Reflex::Literal("end"), method_14418, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1901), Reflex::Literal("end"), method_14419, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_14424, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_14425, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_14426, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20363, type_3951), Reflex::Literal("operator[]"), operator_14427, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20363, type_3951), Reflex::Literal("at"), method_14428, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20194, type_3951), Reflex::Literal("at"), method_14429, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_931, type_7890), Reflex::Literal("insert"), method_14430, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1259, type_1259, type_7890), Reflex::Literal("insert"), method_14431, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1259), Reflex::Literal("erase"), method_14432, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_3951), Reflex::Literal("erase"), method_14433, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1259, type_1259), Reflex::Literal("erase"), method_14434, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_21305), Reflex::Literal("swap"), method_14435, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_14436, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2029), Reflex::Literal("key_comp"), method_14437, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1259, type_3951), Reflex::Literal("find"), method_14439, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1901, type_3951), Reflex::Literal("find"), method_14440, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_3951), Reflex::Literal("count"), method_14441, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1259, type_3951), Reflex::Literal("lower_bound"), method_14442, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1901, type_3951), Reflex::Literal("lower_bound"), method_14443, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1259, type_3951), Reflex::Literal("upper_bound"), method_14444, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1901, type_3951), Reflex::Literal("upper_bound"), method_14445, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_930, type_3951), Reflex::Literal("equal_range"), method_14446, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_929, type_3951), Reflex::Literal("equal_range"), method_14447, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<unsigned int,std::vector<std::pair<unsigned int, bool>, std::allocator<std::pair<unsigned int, bool> > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<std::pair<unsigned int, bool>, std::allocator<std::pair<unsigned int, bool> > > > > > -------------------------------
static void destructor_14468(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >::~map)();
}
static void constructor_14469( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >();
  else ::new(mem) ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >();
}

static void constructor_14470( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >(*(const ::std::less<unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >(*(const ::std::less<unsigned int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > >*)arg[1]);
  else ::new(mem) ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > >*)arg[1]);
  }
}

static void constructor_14471( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >(*(const ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >(*(const ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)arg[0]);
}

static  void operator_14472( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->operator=)(*(const ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)arg[0]);
  else   (((::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->operator=)(*(const ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)arg[0]);
}

static  void method_14473( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > >)((((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->get_allocator)());
  else   (((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->get_allocator)();
}

static  void method_14474( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > >)((((::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->begin)());
  else   (((::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->begin)();
}

static  void method_14475( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > >)((((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->begin)());
  else   (((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->begin)();
}

static  void method_14476( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > >)((((::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->end)());
  else   (((::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->end)();
}

static  void method_14477( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > >)((((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->end)());
  else   (((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->end)();
}

static  void method_14482( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->empty)());
  else   (((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->empty)();
}

static  void method_14483( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->size)());
  else   (((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->size)();
}

static  void method_14484( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->max_size)());
  else   (((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->max_size)();
}

static  void operator_14485( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->operator[])(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->operator[])(*(const unsigned int*)arg[0]);
}

static  void method_14486( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14487( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14488( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > >,bool>)((((::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->insert)(*(const ::std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > >*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->insert)(*(const ::std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > >*)arg[0]);
}

static  void method_14489( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > >)((((::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > >*)arg[0],
    *(const ::std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > >*)arg[1]));
  else   (((::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > >*)arg[0],
    *(const ::std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > >*)arg[1]);
}

static  void method_14490( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > >*)arg[0]);
}

static  void method_14491( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->erase)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->erase)(*(const unsigned int*)arg[0]);
}

static  void method_14492( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > >*)arg[1]);
}

static  void method_14493( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->swap)(*(::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)arg[0]);
}

static  void method_14494( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->clear)();
}

static  void method_14495( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned int>)((((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->key_comp)());
  else   (((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->key_comp)();
}

static  void method_14497( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > >)((((::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14498( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > >)((((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14499( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->count)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->count)(*(const unsigned int*)arg[0]);
}

static  void method_14500( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > >)((((::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14501( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > >)((((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14502( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > >)((((::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14503( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > >)((((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14504( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > >,std::_Rb_tree_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > > >)((((::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static  void method_14505( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > > >)((((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static void method_newdel_1626( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x253( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > > >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > > >::Generate();
}

//------Dictionary for class map<unsigned int,std::vector<std::pair<unsigned int, bool>, std::allocator<std::pair<unsigned int, bool> > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<std::pair<unsigned int, bool>, std::allocator<std::pair<unsigned int, bool> > > > > > -------------------------------
void __std__map_unsignedsint_std__vector_std__pair_unsignedsint_bool_s_s__db_datamem(Reflex::Class*);
void __std__map_unsignedsint_std__vector_std__pair_unsignedsint_bool_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_std__vector_std__pair_unsignedsint_bool_s_s__datamem_bld(&__std__map_unsignedsint_std__vector_std__pair_unsignedsint_bool_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_std__vector_std__pair_unsignedsint_bool_s_s__funcmem_bld(&__std__map_unsignedsint_std__vector_std__pair_unsignedsint_bool_s_s__db_funcmem);
void __std__map_unsignedsint_std__vector_std__pair_unsignedsint_bool_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >"), typeid(::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >), sizeof(::std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_78, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >::key_type"))
  .AddTypedef(type_1076, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >::mapped_type"))
  .AddTypedef(type_874, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >::value_type"))
  .AddTypedef(type_2029, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >::key_compare"))
  .AddTypedef(type_1398, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >::allocator_type"))
  .AddTypedef(type_874, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >::_Alloc_value_type"))
  .AddTypedef(type_1398, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >::_Pair_alloc_type"))
  .AddTypedef(type_1124, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >::_Rep_type"))
  .AddTypedef(type_7989, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >::pointer"))
  .AddTypedef(type_7991, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >::const_pointer"))
  .AddTypedef(type_7993, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >::reference"))
  .AddTypedef(type_7995, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >::const_reference"))
  .AddTypedef(type_1260, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >::iterator"))
  .AddTypedef(type_1902, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >::const_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >::difference_type"))
  .AddTypedef(type_1821, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >::reverse_iterator"))
  .AddTypedef(type_1820, Reflex::Literal("std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_14468, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_14469, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20537, type_20566), Reflex::Literal("map"), constructor_14470, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21306), Reflex::Literal("map"), constructor_14471, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1626, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x253, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsint_std__vector_std__pair_unsignedsint_bool_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsint_std__vector_std__pair_unsignedsint_bool_s_s__funcmem_bld);
}

//------Delayed data member builder for class map<unsigned int,std::vector<std::pair<unsigned int, bool>, std::allocator<std::pair<unsigned int, bool> > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<std::pair<unsigned int, bool>, std::allocator<std::pair<unsigned int, bool> > > > > > -------------------
void __std__map_unsignedsint_std__vector_std__pair_unsignedsint_bool_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1124, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsint_std__vector_std__pair_unsignedsint_bool_s_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<unsigned int,std::vector<std::pair<unsigned int, bool>, std::allocator<std::pair<unsigned int, bool> > >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::vector<std::pair<unsigned int, bool>, std::allocator<std::pair<unsigned int, bool> > > > > > -------------------
void __std__map_unsignedsint_std__vector_std__pair_unsignedsint_bool_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21307, type_21306), Reflex::Literal("operator="), operator_14472, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1398), Reflex::Literal("get_allocator"), method_14473, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1260), Reflex::Literal("begin"), method_14474, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1902), Reflex::Literal("begin"), method_14475, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1260), Reflex::Literal("end"), method_14476, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1902), Reflex::Literal("end"), method_14477, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_14482, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_14483, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_14484, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20366, type_3951), Reflex::Literal("operator[]"), operator_14485, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20366, type_3951), Reflex::Literal("at"), method_14486, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20197, type_3951), Reflex::Literal("at"), method_14487, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_934, type_7995), Reflex::Literal("insert"), method_14488, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1260, type_1260, type_7995), Reflex::Literal("insert"), method_14489, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1260), Reflex::Literal("erase"), method_14490, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_3951), Reflex::Literal("erase"), method_14491, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1260, type_1260), Reflex::Literal("erase"), method_14492, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_21307), Reflex::Literal("swap"), method_14493, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_14494, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2029), Reflex::Literal("key_comp"), method_14495, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1260, type_3951), Reflex::Literal("find"), method_14497, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1902, type_3951), Reflex::Literal("find"), method_14498, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_3951), Reflex::Literal("count"), method_14499, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1260, type_3951), Reflex::Literal("lower_bound"), method_14500, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1902, type_3951), Reflex::Literal("lower_bound"), method_14501, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1260, type_3951), Reflex::Literal("upper_bound"), method_14502, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1902, type_3951), Reflex::Literal("upper_bound"), method_14503, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_933, type_3951), Reflex::Literal("equal_range"), method_14504, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932, type_3951), Reflex::Literal("equal_range"), method_14505, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<unsigned int,std::pair<unsigned int, unsigned int>,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::pair<unsigned int, unsigned int> > > > -------------------------------
static void destructor_14526(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->::std::map<unsigned int,std::pair<unsigned int,unsigned int> >::~map)();
}
static void constructor_14527( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::pair<unsigned int,unsigned int> >();
  else ::new(mem) ::std::map<unsigned int,std::pair<unsigned int,unsigned int> >();
}

static void constructor_14528( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::pair<unsigned int,unsigned int> >(*(const ::std::less<unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,std::pair<unsigned int,unsigned int> >(*(const ::std::less<unsigned int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::pair<unsigned int,unsigned int> >(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > >*)arg[1]);
  else ::new(mem) ::std::map<unsigned int,std::pair<unsigned int,unsigned int> >(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > >*)arg[1]);
  }
}

static void constructor_14529( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::pair<unsigned int,unsigned int> >(*(const ::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,std::pair<unsigned int,unsigned int> >(*(const ::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)arg[0]);
}

static  void operator_14530( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->operator=)(*(const ::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)arg[0]);
  else   (((::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->operator=)(*(const ::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)arg[0]);
}

static  void method_14531( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > >)((((const ::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->get_allocator)());
  else   (((const ::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->get_allocator)();
}

static  void method_14532( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > >)((((::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->begin)());
  else   (((::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->begin)();
}

static  void method_14533( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > >)((((const ::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->begin)());
  else   (((const ::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->begin)();
}

static  void method_14534( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > >)((((::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->end)());
  else   (((::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->end)();
}

static  void method_14535( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > >)((((const ::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->end)());
  else   (((const ::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->end)();
}

static  void method_14540( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->empty)());
  else   (((const ::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->empty)();
}

static  void method_14541( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->size)());
  else   (((const ::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->size)();
}

static  void method_14542( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->max_size)());
  else   (((const ::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->max_size)();
}

static  void operator_14543( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->operator[])(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->operator[])(*(const unsigned int*)arg[0]);
}

static  void method_14544( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14545( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((const ::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14546( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > >,bool>)((((::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->insert)(*(const ::std::pair<const unsigned int,std::pair<unsigned int,unsigned int> >*)arg[0]));
  else   (((::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->insert)(*(const ::std::pair<const unsigned int,std::pair<unsigned int,unsigned int> >*)arg[0]);
}

static  void method_14547( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > >)((((::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > >*)arg[0],
    *(const ::std::pair<const unsigned int,std::pair<unsigned int,unsigned int> >*)arg[1]));
  else   (((::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > >*)arg[0],
    *(const ::std::pair<const unsigned int,std::pair<unsigned int,unsigned int> >*)arg[1]);
}

static  void method_14548( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > >*)arg[0]);
}

static  void method_14549( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->erase)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->erase)(*(const unsigned int*)arg[0]);
}

static  void method_14550( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > >*)arg[1]);
}

static  void method_14551( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->swap)(*(::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)arg[0]);
}

static  void method_14552( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->clear)();
}

static  void method_14553( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned int>)((((const ::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->key_comp)());
  else   (((const ::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->key_comp)();
}

static  void method_14555( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > >)((((::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14556( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > >)((((const ::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14557( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->count)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->count)(*(const unsigned int*)arg[0]);
}

static  void method_14558( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > >)((((::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14559( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > >)((((const ::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14560( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > >)((((::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14561( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > >)((((const ::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14562( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > >,std::_Rb_tree_iterator<std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > > >)((((::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static  void method_14563( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > > >)((((const ::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::pair<unsigned int,unsigned int> >*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static void method_newdel_1627( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::pair<unsigned int,unsigned int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::pair<unsigned int,unsigned int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::pair<unsigned int,unsigned int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::pair<unsigned int,unsigned int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::pair<unsigned int,unsigned int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x255( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned int,std::pair<unsigned int,unsigned int> > >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned int,std::pair<unsigned int,unsigned int> > >::Generate();
}

//------Dictionary for class map<unsigned int,std::pair<unsigned int, unsigned int>,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::pair<unsigned int, unsigned int> > > > -------------------------------
void __std__map_unsignedsint_std__pair_unsignedsint_unsignedsint_s__db_datamem(Reflex::Class*);
void __std__map_unsignedsint_std__pair_unsignedsint_unsignedsint_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_std__pair_unsignedsint_unsignedsint_s__datamem_bld(&__std__map_unsignedsint_std__pair_unsignedsint_unsignedsint_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_std__pair_unsignedsint_unsignedsint_s__funcmem_bld(&__std__map_unsignedsint_std__pair_unsignedsint_unsignedsint_s__db_funcmem);
void __std__map_unsignedsint_std__pair_unsignedsint_unsignedsint_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned int,std::pair<unsigned int,unsigned int> >"), typeid(::std::map<unsigned int,std::pair<unsigned int,unsigned int> >), sizeof(::std::map<unsigned int,std::pair<unsigned int,unsigned int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_78, Reflex::Literal("std::map<unsigned int,std::pair<unsigned int,unsigned int> >::key_type"))
  .AddTypedef(type_814, Reflex::Literal("std::map<unsigned int,std::pair<unsigned int,unsigned int> >::mapped_type"))
  .AddTypedef(type_875, Reflex::Literal("std::map<unsigned int,std::pair<unsigned int,unsigned int> >::value_type"))
  .AddTypedef(type_2029, Reflex::Literal("std::map<unsigned int,std::pair<unsigned int,unsigned int> >::key_compare"))
  .AddTypedef(type_1400, Reflex::Literal("std::map<unsigned int,std::pair<unsigned int,unsigned int> >::allocator_type"))
  .AddTypedef(type_875, Reflex::Literal("std::map<unsigned int,std::pair<unsigned int,unsigned int> >::_Alloc_value_type"))
  .AddTypedef(type_1400, Reflex::Literal("std::map<unsigned int,std::pair<unsigned int,unsigned int> >::_Pair_alloc_type"))
  .AddTypedef(type_1125, Reflex::Literal("std::map<unsigned int,std::pair<unsigned int,unsigned int> >::_Rep_type"))
  .AddTypedef(type_8094, Reflex::Literal("std::map<unsigned int,std::pair<unsigned int,unsigned int> >::pointer"))
  .AddTypedef(type_8096, Reflex::Literal("std::map<unsigned int,std::pair<unsigned int,unsigned int> >::const_pointer"))
  .AddTypedef(type_8098, Reflex::Literal("std::map<unsigned int,std::pair<unsigned int,unsigned int> >::reference"))
  .AddTypedef(type_8100, Reflex::Literal("std::map<unsigned int,std::pair<unsigned int,unsigned int> >::const_reference"))
  .AddTypedef(type_1261, Reflex::Literal("std::map<unsigned int,std::pair<unsigned int,unsigned int> >::iterator"))
  .AddTypedef(type_1903, Reflex::Literal("std::map<unsigned int,std::pair<unsigned int,unsigned int> >::const_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::map<unsigned int,std::pair<unsigned int,unsigned int> >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::map<unsigned int,std::pair<unsigned int,unsigned int> >::difference_type"))
  .AddTypedef(type_1823, Reflex::Literal("std::map<unsigned int,std::pair<unsigned int,unsigned int> >::reverse_iterator"))
  .AddTypedef(type_1822, Reflex::Literal("std::map<unsigned int,std::pair<unsigned int,unsigned int> >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_14526, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_14527, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20537, type_20573), Reflex::Literal("map"), constructor_14528, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21308), Reflex::Literal("map"), constructor_14529, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1627, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x255, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsint_std__pair_unsignedsint_unsignedsint_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsint_std__pair_unsignedsint_unsignedsint_s__funcmem_bld);
}

//------Delayed data member builder for class map<unsigned int,std::pair<unsigned int, unsigned int>,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::pair<unsigned int, unsigned int> > > > -------------------
void __std__map_unsignedsint_std__pair_unsignedsint_unsignedsint_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1125, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsint_std__pair_unsignedsint_unsignedsint_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<unsigned int,std::pair<unsigned int, unsigned int>,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::pair<unsigned int, unsigned int> > > > -------------------
void __std__map_unsignedsint_std__pair_unsignedsint_unsignedsint_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21309, type_21308), Reflex::Literal("operator="), operator_14530, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1400), Reflex::Literal("get_allocator"), method_14531, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1261), Reflex::Literal("begin"), method_14532, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1903), Reflex::Literal("begin"), method_14533, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1261), Reflex::Literal("end"), method_14534, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1903), Reflex::Literal("end"), method_14535, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_14540, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_14541, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_14542, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5109, type_3951), Reflex::Literal("operator[]"), operator_14543, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5109, type_3951), Reflex::Literal("at"), method_14544, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5111, type_3951), Reflex::Literal("at"), method_14545, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_937, type_8100), Reflex::Literal("insert"), method_14546, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1261, type_1261, type_8100), Reflex::Literal("insert"), method_14547, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1261), Reflex::Literal("erase"), method_14548, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_3951), Reflex::Literal("erase"), method_14549, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1261, type_1261), Reflex::Literal("erase"), method_14550, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_21309), Reflex::Literal("swap"), method_14551, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_14552, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2029), Reflex::Literal("key_comp"), method_14553, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1261, type_3951), Reflex::Literal("find"), method_14555, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1903, type_3951), Reflex::Literal("find"), method_14556, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_3951), Reflex::Literal("count"), method_14557, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1261, type_3951), Reflex::Literal("lower_bound"), method_14558, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1903, type_3951), Reflex::Literal("lower_bound"), method_14559, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1261, type_3951), Reflex::Literal("upper_bound"), method_14560, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1903, type_3951), Reflex::Literal("upper_bound"), method_14561, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_936, type_3951), Reflex::Literal("equal_range"), method_14562, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_935, type_3951), Reflex::Literal("equal_range"), method_14563, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<unsigned int,std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------------------
static void destructor_14584(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned int,std::basic_string<char> >*)o)->::std::map<unsigned int,std::basic_string<char> >::~map)();
}
static void constructor_14585( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::basic_string<char> >();
  else ::new(mem) ::std::map<unsigned int,std::basic_string<char> >();
}

static void constructor_14586( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::basic_string<char> >(*(const ::std::less<unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,std::basic_string<char> >(*(const ::std::less<unsigned int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::basic_string<char> >(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[1]);
  else ::new(mem) ::std::map<unsigned int,std::basic_string<char> >(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[1]);
  }
}

static void constructor_14587( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,std::basic_string<char> >(*(const ::std::map<unsigned int,std::basic_string<char> >*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,std::basic_string<char> >(*(const ::std::map<unsigned int,std::basic_string<char> >*)arg[0]);
}

static  void operator_14588( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::basic_string<char> >*)o)->operator=)(*(const ::std::map<unsigned int,std::basic_string<char> >*)arg[0]);
  else   (((::std::map<unsigned int,std::basic_string<char> >*)o)->operator=)(*(const ::std::map<unsigned int,std::basic_string<char> >*)arg[0]);
}

static  void method_14589( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned int,std::basic_string<char> > >)((((const ::std::map<unsigned int,std::basic_string<char> >*)o)->get_allocator)());
  else   (((const ::std::map<unsigned int,std::basic_string<char> >*)o)->get_allocator)();
}

static  void method_14590( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((::std::map<unsigned int,std::basic_string<char> >*)o)->begin)());
  else   (((::std::map<unsigned int,std::basic_string<char> >*)o)->begin)();
}

static  void method_14591( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((const ::std::map<unsigned int,std::basic_string<char> >*)o)->begin)());
  else   (((const ::std::map<unsigned int,std::basic_string<char> >*)o)->begin)();
}

static  void method_14592( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((::std::map<unsigned int,std::basic_string<char> >*)o)->end)());
  else   (((::std::map<unsigned int,std::basic_string<char> >*)o)->end)();
}

static  void method_14593( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((const ::std::map<unsigned int,std::basic_string<char> >*)o)->end)());
  else   (((const ::std::map<unsigned int,std::basic_string<char> >*)o)->end)();
}

static  void method_14598( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned int,std::basic_string<char> >*)o)->empty)());
  else   (((const ::std::map<unsigned int,std::basic_string<char> >*)o)->empty)();
}

static  void method_14599( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::basic_string<char> >*)o)->size)());
  else   (((const ::std::map<unsigned int,std::basic_string<char> >*)o)->size)();
}

static  void method_14600( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::basic_string<char> >*)o)->max_size)());
  else   (((const ::std::map<unsigned int,std::basic_string<char> >*)o)->max_size)();
}

static  void operator_14601( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::basic_string<char> >*)o)->operator[])(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,std::basic_string<char> >*)o)->operator[])(*(const unsigned int*)arg[0]);
}

static  void method_14602( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,std::basic_string<char> >*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,std::basic_string<char> >*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14603( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned int,std::basic_string<char> >*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((const ::std::map<unsigned int,std::basic_string<char> >*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14604( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >,bool>)((((::std::map<unsigned int,std::basic_string<char> >*)o)->insert)(*(const ::std::pair<const unsigned int,std::basic_string<char> >*)arg[0]));
  else   (((::std::map<unsigned int,std::basic_string<char> >*)o)->insert)(*(const ::std::pair<const unsigned int,std::basic_string<char> >*)arg[0]);
}

static  void method_14605( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((::std::map<unsigned int,std::basic_string<char> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0],
    *(const ::std::pair<const unsigned int,std::basic_string<char> >*)arg[1]));
  else   (((::std::map<unsigned int,std::basic_string<char> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0],
    *(const ::std::pair<const unsigned int,std::basic_string<char> >*)arg[1]);
}

static  void method_14606( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::basic_string<char> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0]);
}

static  void method_14607( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned int,std::basic_string<char> >*)o)->erase)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::basic_string<char> >*)o)->erase)(*(const unsigned int*)arg[0]);
}

static  void method_14608( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::basic_string<char> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >*)arg[1]);
}

static  void method_14609( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,std::basic_string<char> >*)o)->swap)(*(::std::map<unsigned int,std::basic_string<char> >*)arg[0]);
}

static  void method_14610( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned int,std::basic_string<char> >*)o)->clear)();
}

static  void method_14611( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned int>)((((const ::std::map<unsigned int,std::basic_string<char> >*)o)->key_comp)());
  else   (((const ::std::map<unsigned int,std::basic_string<char> >*)o)->key_comp)();
}

static  void method_14613( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((::std::map<unsigned int,std::basic_string<char> >*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::basic_string<char> >*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14614( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((const ::std::map<unsigned int,std::basic_string<char> >*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::basic_string<char> >*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14615( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,std::basic_string<char> >*)o)->count)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::basic_string<char> >*)o)->count)(*(const unsigned int*)arg[0]);
}

static  void method_14616( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((::std::map<unsigned int,std::basic_string<char> >*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::basic_string<char> >*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14617( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((const ::std::map<unsigned int,std::basic_string<char> >*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::basic_string<char> >*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14618( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((::std::map<unsigned int,std::basic_string<char> >*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::basic_string<char> >*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14619( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >)((((const ::std::map<unsigned int,std::basic_string<char> >*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::basic_string<char> >*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14620( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > >,std::_Rb_tree_iterator<std::pair<const unsigned int,std::basic_string<char> > > >)((((::std::map<unsigned int,std::basic_string<char> >*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,std::basic_string<char> >*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static  void method_14621( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,std::basic_string<char> > > >)((((const ::std::map<unsigned int,std::basic_string<char> >*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,std::basic_string<char> >*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static void method_newdel_1628( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::basic_string<char> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::basic_string<char> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::basic_string<char> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::basic_string<char> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,std::basic_string<char> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x257( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned int,std::basic_string<char> > >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned int,std::basic_string<char> > >::Generate();
}

//------Dictionary for class map<unsigned int,std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------------------
void __std__map_unsignedsint_std__basic_string_char_s__db_datamem(Reflex::Class*);
void __std__map_unsignedsint_std__basic_string_char_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_std__basic_string_char_s__datamem_bld(&__std__map_unsignedsint_std__basic_string_char_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_std__basic_string_char_s__funcmem_bld(&__std__map_unsignedsint_std__basic_string_char_s__db_funcmem);
void __std__map_unsignedsint_std__basic_string_char_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned int,std::basic_string<char> >"), typeid(::std::map<unsigned int,std::basic_string<char> >), sizeof(::std::map<unsigned int,std::basic_string<char> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_78, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::key_type"))
  .AddTypedef(type_1104, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::mapped_type"))
  .AddTypedef(type_876, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::value_type"))
  .AddTypedef(type_2029, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::key_compare"))
  .AddTypedef(type_1402, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::allocator_type"))
  .AddTypedef(type_876, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::_Alloc_value_type"))
  .AddTypedef(type_1402, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::_Pair_alloc_type"))
  .AddTypedef(type_1126, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::_Rep_type"))
  .AddTypedef(type_8199, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::pointer"))
  .AddTypedef(type_8201, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::const_pointer"))
  .AddTypedef(type_8203, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::reference"))
  .AddTypedef(type_8205, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::const_reference"))
  .AddTypedef(type_1262, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::iterator"))
  .AddTypedef(type_1904, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::const_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::difference_type"))
  .AddTypedef(type_1825, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::reverse_iterator"))
  .AddTypedef(type_1824, Reflex::Literal("std::map<unsigned int,std::basic_string<char> >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_14584, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_14585, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20537, type_20580), Reflex::Literal("map"), constructor_14586, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21310), Reflex::Literal("map"), constructor_14587, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1628, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x257, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsint_std__basic_string_char_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsint_std__basic_string_char_s__funcmem_bld);
}

//------Delayed data member builder for class map<unsigned int,std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------
void __std__map_unsignedsint_std__basic_string_char_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1126, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsint_std__basic_string_char_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<unsigned int,std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------
void __std__map_unsignedsint_std__basic_string_char_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21311, type_21310), Reflex::Literal("operator="), operator_14588, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1402), Reflex::Literal("get_allocator"), method_14589, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1262), Reflex::Literal("begin"), method_14590, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1904), Reflex::Literal("begin"), method_14591, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1262), Reflex::Literal("end"), method_14592, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1904), Reflex::Literal("end"), method_14593, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_14598, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_14599, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_14600, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_3951), Reflex::Literal("operator[]"), operator_14601, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_3951), Reflex::Literal("at"), method_14602, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4981, type_3951), Reflex::Literal("at"), method_14603, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_940, type_8205), Reflex::Literal("insert"), method_14604, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1262, type_1262, type_8205), Reflex::Literal("insert"), method_14605, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1262), Reflex::Literal("erase"), method_14606, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_3951), Reflex::Literal("erase"), method_14607, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1262, type_1262), Reflex::Literal("erase"), method_14608, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_21311), Reflex::Literal("swap"), method_14609, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_14610, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2029), Reflex::Literal("key_comp"), method_14611, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1262, type_3951), Reflex::Literal("find"), method_14613, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1904, type_3951), Reflex::Literal("find"), method_14614, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_3951), Reflex::Literal("count"), method_14615, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1262, type_3951), Reflex::Literal("lower_bound"), method_14616, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1904, type_3951), Reflex::Literal("lower_bound"), method_14617, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1262, type_3951), Reflex::Literal("upper_bound"), method_14618, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1904, type_3951), Reflex::Literal("upper_bound"), method_14619, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_939, type_3951), Reflex::Literal("equal_range"), method_14620, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_938, type_3951), Reflex::Literal("equal_range"), method_14621, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<unsigned int,short int,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, short int> > > -------------------------------
static void destructor_14642(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned int,short>*)o)->::std::map<unsigned int,short>::~map)();
}
static void constructor_14643( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,short>();
  else ::new(mem) ::std::map<unsigned int,short>();
}

static void constructor_14644( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,short>(*(const ::std::less<unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,short>(*(const ::std::less<unsigned int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,short>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,short> >*)arg[1]);
  else ::new(mem) ::std::map<unsigned int,short>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,short> >*)arg[1]);
  }
}

static void constructor_14645( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,short>(*(const ::std::map<unsigned int,short>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,short>(*(const ::std::map<unsigned int,short>*)arg[0]);
}

static  void operator_14646( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,short>*)o)->operator=)(*(const ::std::map<unsigned int,short>*)arg[0]);
  else   (((::std::map<unsigned int,short>*)o)->operator=)(*(const ::std::map<unsigned int,short>*)arg[0]);
}

static  void method_14647( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned int,short> >)((((const ::std::map<unsigned int,short>*)o)->get_allocator)());
  else   (((const ::std::map<unsigned int,short>*)o)->get_allocator)();
}

static  void method_14648( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,short> >)((((::std::map<unsigned int,short>*)o)->begin)());
  else   (((::std::map<unsigned int,short>*)o)->begin)();
}

static  void method_14649( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,short> >)((((const ::std::map<unsigned int,short>*)o)->begin)());
  else   (((const ::std::map<unsigned int,short>*)o)->begin)();
}

static  void method_14650( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,short> >)((((::std::map<unsigned int,short>*)o)->end)());
  else   (((::std::map<unsigned int,short>*)o)->end)();
}

static  void method_14651( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,short> >)((((const ::std::map<unsigned int,short>*)o)->end)());
  else   (((const ::std::map<unsigned int,short>*)o)->end)();
}

static  void method_14656( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned int,short>*)o)->empty)());
  else   (((const ::std::map<unsigned int,short>*)o)->empty)();
}

static  void method_14657( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,short>*)o)->size)());
  else   (((const ::std::map<unsigned int,short>*)o)->size)();
}

static  void method_14658( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,short>*)o)->max_size)());
  else   (((const ::std::map<unsigned int,short>*)o)->max_size)();
}

static  void operator_14659( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,short>*)o)->operator[])(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,short>*)o)->operator[])(*(const unsigned int*)arg[0]);
}

static  void method_14660( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,short>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,short>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14661( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned int,short>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((const ::std::map<unsigned int,short>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14662( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,short> >,bool>)((((::std::map<unsigned int,short>*)o)->insert)(*(const ::std::pair<const unsigned int,short>*)arg[0]));
  else   (((::std::map<unsigned int,short>*)o)->insert)(*(const ::std::pair<const unsigned int,short>*)arg[0]);
}

static  void method_14663( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,short> >)((((::std::map<unsigned int,short>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,short> >*)arg[0],
    *(const ::std::pair<const unsigned int,short>*)arg[1]));
  else   (((::std::map<unsigned int,short>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,short> >*)arg[0],
    *(const ::std::pair<const unsigned int,short>*)arg[1]);
}

static  void method_14664( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,short>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,short> >*)arg[0]);
}

static  void method_14665( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned int,short>*)o)->erase)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,short>*)o)->erase)(*(const unsigned int*)arg[0]);
}

static  void method_14666( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,short>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,short> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned int,short> >*)arg[1]);
}

static  void method_14667( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,short>*)o)->swap)(*(::std::map<unsigned int,short>*)arg[0]);
}

static  void method_14668( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned int,short>*)o)->clear)();
}

static  void method_14669( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned int>)((((const ::std::map<unsigned int,short>*)o)->key_comp)());
  else   (((const ::std::map<unsigned int,short>*)o)->key_comp)();
}

static  void method_14671( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,short> >)((((::std::map<unsigned int,short>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,short>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14672( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,short> >)((((const ::std::map<unsigned int,short>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,short>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14673( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,short>*)o)->count)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,short>*)o)->count)(*(const unsigned int*)arg[0]);
}

static  void method_14674( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,short> >)((((::std::map<unsigned int,short>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,short>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14675( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,short> >)((((const ::std::map<unsigned int,short>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,short>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14676( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,short> >)((((::std::map<unsigned int,short>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,short>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14677( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,short> >)((((const ::std::map<unsigned int,short>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,short>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14678( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,short> >,std::_Rb_tree_iterator<std::pair<const unsigned int,short> > >)((((::std::map<unsigned int,short>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,short>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static  void method_14679( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,short> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,short> > >)((((const ::std::map<unsigned int,short>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,short>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static void method_newdel_1629( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,short> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,short> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,short> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,short> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,short> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x259( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned int,short> >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned int,short> >::Generate();
}

//------Dictionary for class map<unsigned int,short int,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, short int> > > -------------------------------
void __std__map_unsignedsint_short__db_datamem(Reflex::Class*);
void __std__map_unsignedsint_short__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_short__datamem_bld(&__std__map_unsignedsint_short__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_short__funcmem_bld(&__std__map_unsignedsint_short__db_funcmem);
void __std__map_unsignedsint_short__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned int,short>"), typeid(::std::map<unsigned int,short>), sizeof(::std::map<unsigned int,short>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_78, Reflex::Literal("std::map<unsigned int,short>::key_type"))
  .AddTypedef(type_113, Reflex::Literal("std::map<unsigned int,short>::mapped_type"))
  .AddTypedef(type_877, Reflex::Literal("std::map<unsigned int,short>::value_type"))
  .AddTypedef(type_2029, Reflex::Literal("std::map<unsigned int,short>::key_compare"))
  .AddTypedef(type_1404, Reflex::Literal("std::map<unsigned int,short>::allocator_type"))
  .AddTypedef(type_877, Reflex::Literal("std::map<unsigned int,short>::_Alloc_value_type"))
  .AddTypedef(type_1404, Reflex::Literal("std::map<unsigned int,short>::_Pair_alloc_type"))
  .AddTypedef(type_1127, Reflex::Literal("std::map<unsigned int,short>::_Rep_type"))
  .AddTypedef(type_8304, Reflex::Literal("std::map<unsigned int,short>::pointer"))
  .AddTypedef(type_8306, Reflex::Literal("std::map<unsigned int,short>::const_pointer"))
  .AddTypedef(type_8308, Reflex::Literal("std::map<unsigned int,short>::reference"))
  .AddTypedef(type_8310, Reflex::Literal("std::map<unsigned int,short>::const_reference"))
  .AddTypedef(type_1263, Reflex::Literal("std::map<unsigned int,short>::iterator"))
  .AddTypedef(type_1905, Reflex::Literal("std::map<unsigned int,short>::const_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::map<unsigned int,short>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::map<unsigned int,short>::difference_type"))
  .AddTypedef(type_1827, Reflex::Literal("std::map<unsigned int,short>::reverse_iterator"))
  .AddTypedef(type_1826, Reflex::Literal("std::map<unsigned int,short>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_14642, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_14643, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20537, type_20587), Reflex::Literal("map"), constructor_14644, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21312), Reflex::Literal("map"), constructor_14645, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1629, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x259, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsint_short__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsint_short__funcmem_bld);
}

//------Delayed data member builder for class map<unsigned int,short int,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, short int> > > -------------------
void __std__map_unsignedsint_short__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1127, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsint_short_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<unsigned int,short int,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, short int> > > -------------------
void __std__map_unsignedsint_short__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21313, type_21312), Reflex::Literal("operator="), operator_14646, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1404), Reflex::Literal("get_allocator"), method_14647, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1263), Reflex::Literal("begin"), method_14648, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1905), Reflex::Literal("begin"), method_14649, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1263), Reflex::Literal("end"), method_14650, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1905), Reflex::Literal("end"), method_14651, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_14656, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_14657, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_14658, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3527, type_3951), Reflex::Literal("operator[]"), operator_14659, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3527, type_3951), Reflex::Literal("at"), method_14660, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4662, type_3951), Reflex::Literal("at"), method_14661, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_943, type_8310), Reflex::Literal("insert"), method_14662, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1263, type_1263, type_8310), Reflex::Literal("insert"), method_14663, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1263), Reflex::Literal("erase"), method_14664, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_3951), Reflex::Literal("erase"), method_14665, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1263, type_1263), Reflex::Literal("erase"), method_14666, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_21313), Reflex::Literal("swap"), method_14667, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_14668, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2029), Reflex::Literal("key_comp"), method_14669, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1263, type_3951), Reflex::Literal("find"), method_14671, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1905, type_3951), Reflex::Literal("find"), method_14672, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_3951), Reflex::Literal("count"), method_14673, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1263, type_3951), Reflex::Literal("lower_bound"), method_14674, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1905, type_3951), Reflex::Literal("lower_bound"), method_14675, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1263, type_3951), Reflex::Literal("upper_bound"), method_14676, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1905, type_3951), Reflex::Literal("upper_bound"), method_14677, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_942, type_3951), Reflex::Literal("equal_range"), method_14678, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_941, type_3951), Reflex::Literal("equal_range"), method_14679, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, int> > > -------------------------------
static void destructor_14700(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned int,int>*)o)->::std::map<unsigned int,int>::~map)();
}
static void constructor_14701( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,int>();
  else ::new(mem) ::std::map<unsigned int,int>();
}

static void constructor_14702( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,int>(*(const ::std::less<unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,int>(*(const ::std::less<unsigned int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,int>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,int> >*)arg[1]);
  else ::new(mem) ::std::map<unsigned int,int>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,int> >*)arg[1]);
  }
}

static void constructor_14703( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,int>(*(const ::std::map<unsigned int,int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,int>(*(const ::std::map<unsigned int,int>*)arg[0]);
}

static  void operator_14704( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,int>*)o)->operator=)(*(const ::std::map<unsigned int,int>*)arg[0]);
  else   (((::std::map<unsigned int,int>*)o)->operator=)(*(const ::std::map<unsigned int,int>*)arg[0]);
}

static  void method_14705( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned int,int> >)((((const ::std::map<unsigned int,int>*)o)->get_allocator)());
  else   (((const ::std::map<unsigned int,int>*)o)->get_allocator)();
}

static  void method_14706( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,int> >)((((::std::map<unsigned int,int>*)o)->begin)());
  else   (((::std::map<unsigned int,int>*)o)->begin)();
}

static  void method_14707( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,int> >)((((const ::std::map<unsigned int,int>*)o)->begin)());
  else   (((const ::std::map<unsigned int,int>*)o)->begin)();
}

static  void method_14708( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,int> >)((((::std::map<unsigned int,int>*)o)->end)());
  else   (((::std::map<unsigned int,int>*)o)->end)();
}

static  void method_14709( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,int> >)((((const ::std::map<unsigned int,int>*)o)->end)());
  else   (((const ::std::map<unsigned int,int>*)o)->end)();
}

static  void method_14714( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned int,int>*)o)->empty)());
  else   (((const ::std::map<unsigned int,int>*)o)->empty)();
}

static  void method_14715( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,int>*)o)->size)());
  else   (((const ::std::map<unsigned int,int>*)o)->size)();
}

static  void method_14716( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,int>*)o)->max_size)());
  else   (((const ::std::map<unsigned int,int>*)o)->max_size)();
}

static  void operator_14717( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,int>*)o)->operator[])(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,int>*)o)->operator[])(*(const unsigned int*)arg[0]);
}

static  void method_14718( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,int>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,int>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14719( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned int,int>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((const ::std::map<unsigned int,int>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14720( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,int> >,bool>)((((::std::map<unsigned int,int>*)o)->insert)(*(const ::std::pair<const unsigned int,int>*)arg[0]));
  else   (((::std::map<unsigned int,int>*)o)->insert)(*(const ::std::pair<const unsigned int,int>*)arg[0]);
}

static  void method_14721( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,int> >)((((::std::map<unsigned int,int>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,int> >*)arg[0],
    *(const ::std::pair<const unsigned int,int>*)arg[1]));
  else   (((::std::map<unsigned int,int>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,int> >*)arg[0],
    *(const ::std::pair<const unsigned int,int>*)arg[1]);
}

static  void method_14722( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,int>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,int> >*)arg[0]);
}

static  void method_14723( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned int,int>*)o)->erase)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,int>*)o)->erase)(*(const unsigned int*)arg[0]);
}

static  void method_14724( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,int>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,int> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned int,int> >*)arg[1]);
}

static  void method_14725( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,int>*)o)->swap)(*(::std::map<unsigned int,int>*)arg[0]);
}

static  void method_14726( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned int,int>*)o)->clear)();
}

static  void method_14727( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned int>)((((const ::std::map<unsigned int,int>*)o)->key_comp)());
  else   (((const ::std::map<unsigned int,int>*)o)->key_comp)();
}

static  void method_14729( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,int> >)((((::std::map<unsigned int,int>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,int>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14730( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,int> >)((((const ::std::map<unsigned int,int>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,int>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14731( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,int>*)o)->count)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,int>*)o)->count)(*(const unsigned int*)arg[0]);
}

static  void method_14732( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,int> >)((((::std::map<unsigned int,int>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,int>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14733( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,int> >)((((const ::std::map<unsigned int,int>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,int>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14734( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,int> >)((((::std::map<unsigned int,int>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,int>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14735( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,int> >)((((const ::std::map<unsigned int,int>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,int>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14736( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,int> >,std::_Rb_tree_iterator<std::pair<const unsigned int,int> > >)((((::std::map<unsigned int,int>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,int>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static  void method_14737( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,int> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,int> > >)((((const ::std::map<unsigned int,int>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,int>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static void method_newdel_1630( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x261( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned int,int> >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned int,int> >::Generate();
}

//------Dictionary for class map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, int> > > -------------------------------
void __std__map_unsignedsint_int__db_datamem(Reflex::Class*);
void __std__map_unsignedsint_int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_int__datamem_bld(&__std__map_unsignedsint_int__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_int__funcmem_bld(&__std__map_unsignedsint_int__db_funcmem);
void __std__map_unsignedsint_int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned int,int>"), typeid(::std::map<unsigned int,int>), sizeof(::std::map<unsigned int,int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_78, Reflex::Literal("std::map<unsigned int,int>::key_type"))
  .AddTypedef(type_22, Reflex::Literal("std::map<unsigned int,int>::mapped_type"))
  .AddTypedef(type_878, Reflex::Literal("std::map<unsigned int,int>::value_type"))
  .AddTypedef(type_2029, Reflex::Literal("std::map<unsigned int,int>::key_compare"))
  .AddTypedef(type_1406, Reflex::Literal("std::map<unsigned int,int>::allocator_type"))
  .AddTypedef(type_878, Reflex::Literal("std::map<unsigned int,int>::_Alloc_value_type"))
  .AddTypedef(type_1406, Reflex::Literal("std::map<unsigned int,int>::_Pair_alloc_type"))
  .AddTypedef(type_1128, Reflex::Literal("std::map<unsigned int,int>::_Rep_type"))
  .AddTypedef(type_8409, Reflex::Literal("std::map<unsigned int,int>::pointer"))
  .AddTypedef(type_8411, Reflex::Literal("std::map<unsigned int,int>::const_pointer"))
  .AddTypedef(type_8413, Reflex::Literal("std::map<unsigned int,int>::reference"))
  .AddTypedef(type_8415, Reflex::Literal("std::map<unsigned int,int>::const_reference"))
  .AddTypedef(type_1264, Reflex::Literal("std::map<unsigned int,int>::iterator"))
  .AddTypedef(type_1906, Reflex::Literal("std::map<unsigned int,int>::const_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::map<unsigned int,int>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::map<unsigned int,int>::difference_type"))
  .AddTypedef(type_1829, Reflex::Literal("std::map<unsigned int,int>::reverse_iterator"))
  .AddTypedef(type_1828, Reflex::Literal("std::map<unsigned int,int>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_14700, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_14701, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20537, type_20594), Reflex::Literal("map"), constructor_14702, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21314), Reflex::Literal("map"), constructor_14703, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1630, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x261, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsint_int__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsint_int__funcmem_bld);
}

//------Delayed data member builder for class map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, int> > > -------------------
void __std__map_unsignedsint_int__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1128, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsint_int_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<unsigned int,int,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, int> > > -------------------
void __std__map_unsignedsint_int__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21315, type_21314), Reflex::Literal("operator="), operator_14704, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1406), Reflex::Literal("get_allocator"), method_14705, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1264), Reflex::Literal("begin"), method_14706, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1906), Reflex::Literal("begin"), method_14707, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1264), Reflex::Literal("end"), method_14708, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1906), Reflex::Literal("end"), method_14709, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_14714, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_14715, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_14716, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3569, type_3951), Reflex::Literal("operator[]"), operator_14717, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3569, type_3951), Reflex::Literal("at"), method_14718, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4404, type_3951), Reflex::Literal("at"), method_14719, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_946, type_8415), Reflex::Literal("insert"), method_14720, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1264, type_1264, type_8415), Reflex::Literal("insert"), method_14721, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1264), Reflex::Literal("erase"), method_14722, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_3951), Reflex::Literal("erase"), method_14723, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1264, type_1264), Reflex::Literal("erase"), method_14724, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_21315), Reflex::Literal("swap"), method_14725, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_14726, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2029), Reflex::Literal("key_comp"), method_14727, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1264, type_3951), Reflex::Literal("find"), method_14729, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1906, type_3951), Reflex::Literal("find"), method_14730, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_3951), Reflex::Literal("count"), method_14731, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1264, type_3951), Reflex::Literal("lower_bound"), method_14732, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1906, type_3951), Reflex::Literal("lower_bound"), method_14733, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1264, type_3951), Reflex::Literal("upper_bound"), method_14734, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1906, type_3951), Reflex::Literal("upper_bound"), method_14735, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_945, type_3951), Reflex::Literal("equal_range"), method_14736, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_944, type_3951), Reflex::Literal("equal_range"), method_14737, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<unsigned int,float,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, float> > > -------------------------------
static void destructor_14758(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned int,float>*)o)->::std::map<unsigned int,float>::~map)();
}
static void constructor_14759( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,float>();
  else ::new(mem) ::std::map<unsigned int,float>();
}

static void constructor_14760( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,float>(*(const ::std::less<unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,float>(*(const ::std::less<unsigned int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,float>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,float> >*)arg[1]);
  else ::new(mem) ::std::map<unsigned int,float>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,float> >*)arg[1]);
  }
}

static void constructor_14761( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,float>(*(const ::std::map<unsigned int,float>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,float>(*(const ::std::map<unsigned int,float>*)arg[0]);
}

static  void operator_14762( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,float>*)o)->operator=)(*(const ::std::map<unsigned int,float>*)arg[0]);
  else   (((::std::map<unsigned int,float>*)o)->operator=)(*(const ::std::map<unsigned int,float>*)arg[0]);
}

static  void method_14763( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned int,float> >)((((const ::std::map<unsigned int,float>*)o)->get_allocator)());
  else   (((const ::std::map<unsigned int,float>*)o)->get_allocator)();
}

static  void method_14764( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,float> >)((((::std::map<unsigned int,float>*)o)->begin)());
  else   (((::std::map<unsigned int,float>*)o)->begin)();
}

static  void method_14765( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,float> >)((((const ::std::map<unsigned int,float>*)o)->begin)());
  else   (((const ::std::map<unsigned int,float>*)o)->begin)();
}

static  void method_14766( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,float> >)((((::std::map<unsigned int,float>*)o)->end)());
  else   (((::std::map<unsigned int,float>*)o)->end)();
}

static  void method_14767( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,float> >)((((const ::std::map<unsigned int,float>*)o)->end)());
  else   (((const ::std::map<unsigned int,float>*)o)->end)();
}

static  void method_14772( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned int,float>*)o)->empty)());
  else   (((const ::std::map<unsigned int,float>*)o)->empty)();
}

static  void method_14773( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,float>*)o)->size)());
  else   (((const ::std::map<unsigned int,float>*)o)->size)();
}

static  void method_14774( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,float>*)o)->max_size)());
  else   (((const ::std::map<unsigned int,float>*)o)->max_size)();
}

static  void operator_14775( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,float>*)o)->operator[])(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,float>*)o)->operator[])(*(const unsigned int*)arg[0]);
}

static  void method_14776( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,float>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,float>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14777( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned int,float>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((const ::std::map<unsigned int,float>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14778( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,float> >,bool>)((((::std::map<unsigned int,float>*)o)->insert)(*(const ::std::pair<const unsigned int,float>*)arg[0]));
  else   (((::std::map<unsigned int,float>*)o)->insert)(*(const ::std::pair<const unsigned int,float>*)arg[0]);
}

static  void method_14779( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,float> >)((((::std::map<unsigned int,float>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,float> >*)arg[0],
    *(const ::std::pair<const unsigned int,float>*)arg[1]));
  else   (((::std::map<unsigned int,float>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,float> >*)arg[0],
    *(const ::std::pair<const unsigned int,float>*)arg[1]);
}

static  void method_14780( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,float>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,float> >*)arg[0]);
}

static  void method_14781( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned int,float>*)o)->erase)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,float>*)o)->erase)(*(const unsigned int*)arg[0]);
}

static  void method_14782( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,float>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,float> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned int,float> >*)arg[1]);
}

static  void method_14783( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,float>*)o)->swap)(*(::std::map<unsigned int,float>*)arg[0]);
}

static  void method_14784( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned int,float>*)o)->clear)();
}

static  void method_14785( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned int>)((((const ::std::map<unsigned int,float>*)o)->key_comp)());
  else   (((const ::std::map<unsigned int,float>*)o)->key_comp)();
}

static  void method_14787( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,float> >)((((::std::map<unsigned int,float>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,float>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14788( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,float> >)((((const ::std::map<unsigned int,float>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,float>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14789( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,float>*)o)->count)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,float>*)o)->count)(*(const unsigned int*)arg[0]);
}

static  void method_14790( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,float> >)((((::std::map<unsigned int,float>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,float>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14791( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,float> >)((((const ::std::map<unsigned int,float>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,float>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14792( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,float> >)((((::std::map<unsigned int,float>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,float>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14793( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,float> >)((((const ::std::map<unsigned int,float>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,float>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14794( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,float> >,std::_Rb_tree_iterator<std::pair<const unsigned int,float> > >)((((::std::map<unsigned int,float>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,float>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static  void method_14795( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,float> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,float> > >)((((const ::std::map<unsigned int,float>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,float>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static void method_newdel_1631( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,float> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,float> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,float> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,float> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,float> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x263( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned int,float> >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned int,float> >::Generate();
}

//------Dictionary for class map<unsigned int,float,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, float> > > -------------------------------
void __std__map_unsignedsint_float__db_datamem(Reflex::Class*);
void __std__map_unsignedsint_float__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_float__datamem_bld(&__std__map_unsignedsint_float__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_float__funcmem_bld(&__std__map_unsignedsint_float__db_funcmem);
void __std__map_unsignedsint_float__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned int,float>"), typeid(::std::map<unsigned int,float>), sizeof(::std::map<unsigned int,float>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_78, Reflex::Literal("std::map<unsigned int,float>::key_type"))
  .AddTypedef(type_2058, Reflex::Literal("std::map<unsigned int,float>::mapped_type"))
  .AddTypedef(type_879, Reflex::Literal("std::map<unsigned int,float>::value_type"))
  .AddTypedef(type_2029, Reflex::Literal("std::map<unsigned int,float>::key_compare"))
  .AddTypedef(type_1408, Reflex::Literal("std::map<unsigned int,float>::allocator_type"))
  .AddTypedef(type_879, Reflex::Literal("std::map<unsigned int,float>::_Alloc_value_type"))
  .AddTypedef(type_1408, Reflex::Literal("std::map<unsigned int,float>::_Pair_alloc_type"))
  .AddTypedef(type_1129, Reflex::Literal("std::map<unsigned int,float>::_Rep_type"))
  .AddTypedef(type_8514, Reflex::Literal("std::map<unsigned int,float>::pointer"))
  .AddTypedef(type_8516, Reflex::Literal("std::map<unsigned int,float>::const_pointer"))
  .AddTypedef(type_8518, Reflex::Literal("std::map<unsigned int,float>::reference"))
  .AddTypedef(type_8520, Reflex::Literal("std::map<unsigned int,float>::const_reference"))
  .AddTypedef(type_1265, Reflex::Literal("std::map<unsigned int,float>::iterator"))
  .AddTypedef(type_1907, Reflex::Literal("std::map<unsigned int,float>::const_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::map<unsigned int,float>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::map<unsigned int,float>::difference_type"))
  .AddTypedef(type_1831, Reflex::Literal("std::map<unsigned int,float>::reverse_iterator"))
  .AddTypedef(type_1830, Reflex::Literal("std::map<unsigned int,float>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_14758, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_14759, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20537, type_20601), Reflex::Literal("map"), constructor_14760, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21316), Reflex::Literal("map"), constructor_14761, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1631, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x263, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsint_float__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsint_float__funcmem_bld);
}

//------Delayed data member builder for class map<unsigned int,float,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, float> > > -------------------
void __std__map_unsignedsint_float__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1129, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsint_float_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<unsigned int,float,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, float> > > -------------------
void __std__map_unsignedsint_float__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21317, type_21316), Reflex::Literal("operator="), operator_14762, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1408), Reflex::Literal("get_allocator"), method_14763, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1265), Reflex::Literal("begin"), method_14764, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1907), Reflex::Literal("begin"), method_14765, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1265), Reflex::Literal("end"), method_14766, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1907), Reflex::Literal("end"), method_14767, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_14772, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_14773, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_14774, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3579, type_3951), Reflex::Literal("operator[]"), operator_14775, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3579, type_3951), Reflex::Literal("at"), method_14776, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4790, type_3951), Reflex::Literal("at"), method_14777, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_949, type_8520), Reflex::Literal("insert"), method_14778, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1265, type_1265, type_8520), Reflex::Literal("insert"), method_14779, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1265), Reflex::Literal("erase"), method_14780, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_3951), Reflex::Literal("erase"), method_14781, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1265, type_1265), Reflex::Literal("erase"), method_14782, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_21317), Reflex::Literal("swap"), method_14783, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_14784, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2029), Reflex::Literal("key_comp"), method_14785, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1265, type_3951), Reflex::Literal("find"), method_14787, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1907, type_3951), Reflex::Literal("find"), method_14788, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_3951), Reflex::Literal("count"), method_14789, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1265, type_3951), Reflex::Literal("lower_bound"), method_14790, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1907, type_3951), Reflex::Literal("lower_bound"), method_14791, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1265, type_3951), Reflex::Literal("upper_bound"), method_14792, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1907, type_3951), Reflex::Literal("upper_bound"), method_14793, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_948, type_3951), Reflex::Literal("equal_range"), method_14794, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_947, type_3951), Reflex::Literal("equal_range"), method_14795, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, double> > > -------------------------------
static void destructor_14816(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned int,double>*)o)->::std::map<unsigned int,double>::~map)();
}
static void constructor_14817( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,double>();
  else ::new(mem) ::std::map<unsigned int,double>();
}

static void constructor_14818( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,double>(*(const ::std::less<unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,double>(*(const ::std::less<unsigned int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,double>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,double> >*)arg[1]);
  else ::new(mem) ::std::map<unsigned int,double>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,double> >*)arg[1]);
  }
}

static void constructor_14819( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,double>(*(const ::std::map<unsigned int,double>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,double>(*(const ::std::map<unsigned int,double>*)arg[0]);
}

static  void operator_14820( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,double>*)o)->operator=)(*(const ::std::map<unsigned int,double>*)arg[0]);
  else   (((::std::map<unsigned int,double>*)o)->operator=)(*(const ::std::map<unsigned int,double>*)arg[0]);
}

static  void method_14821( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned int,double> >)((((const ::std::map<unsigned int,double>*)o)->get_allocator)());
  else   (((const ::std::map<unsigned int,double>*)o)->get_allocator)();
}

static  void method_14822( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,double> >)((((::std::map<unsigned int,double>*)o)->begin)());
  else   (((::std::map<unsigned int,double>*)o)->begin)();
}

static  void method_14823( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,double> >)((((const ::std::map<unsigned int,double>*)o)->begin)());
  else   (((const ::std::map<unsigned int,double>*)o)->begin)();
}

static  void method_14824( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,double> >)((((::std::map<unsigned int,double>*)o)->end)());
  else   (((::std::map<unsigned int,double>*)o)->end)();
}

static  void method_14825( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,double> >)((((const ::std::map<unsigned int,double>*)o)->end)());
  else   (((const ::std::map<unsigned int,double>*)o)->end)();
}

static  void method_14830( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned int,double>*)o)->empty)());
  else   (((const ::std::map<unsigned int,double>*)o)->empty)();
}

static  void method_14831( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,double>*)o)->size)());
  else   (((const ::std::map<unsigned int,double>*)o)->size)();
}

static  void method_14832( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,double>*)o)->max_size)());
  else   (((const ::std::map<unsigned int,double>*)o)->max_size)();
}

static  void operator_14833( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,double>*)o)->operator[])(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,double>*)o)->operator[])(*(const unsigned int*)arg[0]);
}

static  void method_14834( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,double>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,double>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14835( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned int,double>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((const ::std::map<unsigned int,double>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14836( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,double> >,bool>)((((::std::map<unsigned int,double>*)o)->insert)(*(const ::std::pair<const unsigned int,double>*)arg[0]));
  else   (((::std::map<unsigned int,double>*)o)->insert)(*(const ::std::pair<const unsigned int,double>*)arg[0]);
}

static  void method_14837( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,double> >)((((::std::map<unsigned int,double>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,double> >*)arg[0],
    *(const ::std::pair<const unsigned int,double>*)arg[1]));
  else   (((::std::map<unsigned int,double>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,double> >*)arg[0],
    *(const ::std::pair<const unsigned int,double>*)arg[1]);
}

static  void method_14838( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,double>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,double> >*)arg[0]);
}

static  void method_14839( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned int,double>*)o)->erase)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,double>*)o)->erase)(*(const unsigned int*)arg[0]);
}

static  void method_14840( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,double>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,double> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned int,double> >*)arg[1]);
}

static  void method_14841( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,double>*)o)->swap)(*(::std::map<unsigned int,double>*)arg[0]);
}

static  void method_14842( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned int,double>*)o)->clear)();
}

static  void method_14843( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned int>)((((const ::std::map<unsigned int,double>*)o)->key_comp)());
  else   (((const ::std::map<unsigned int,double>*)o)->key_comp)();
}

static  void method_14845( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,double> >)((((::std::map<unsigned int,double>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,double>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14846( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,double> >)((((const ::std::map<unsigned int,double>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,double>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14847( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,double>*)o)->count)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,double>*)o)->count)(*(const unsigned int*)arg[0]);
}

static  void method_14848( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,double> >)((((::std::map<unsigned int,double>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,double>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14849( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,double> >)((((const ::std::map<unsigned int,double>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,double>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14850( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,double> >)((((::std::map<unsigned int,double>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,double>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14851( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,double> >)((((const ::std::map<unsigned int,double>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,double>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14852( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,double> >,std::_Rb_tree_iterator<std::pair<const unsigned int,double> > >)((((::std::map<unsigned int,double>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,double>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static  void method_14853( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,double> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,double> > >)((((const ::std::map<unsigned int,double>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,double>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static void method_newdel_1632( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,double> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,double> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,double> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,double> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,double> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x265( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned int,double> >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned int,double> >::Generate();
}

//------Dictionary for class map<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, double> > > -------------------------------
void __std__map_unsignedsint_double__db_datamem(Reflex::Class*);
void __std__map_unsignedsint_double__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_double__datamem_bld(&__std__map_unsignedsint_double__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_double__funcmem_bld(&__std__map_unsignedsint_double__db_funcmem);
void __std__map_unsignedsint_double__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned int,double>"), typeid(::std::map<unsigned int,double>), sizeof(::std::map<unsigned int,double>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_78, Reflex::Literal("std::map<unsigned int,double>::key_type"))
  .AddTypedef(type_2052, Reflex::Literal("std::map<unsigned int,double>::mapped_type"))
  .AddTypedef(type_880, Reflex::Literal("std::map<unsigned int,double>::value_type"))
  .AddTypedef(type_2029, Reflex::Literal("std::map<unsigned int,double>::key_compare"))
  .AddTypedef(type_1410, Reflex::Literal("std::map<unsigned int,double>::allocator_type"))
  .AddTypedef(type_880, Reflex::Literal("std::map<unsigned int,double>::_Alloc_value_type"))
  .AddTypedef(type_1410, Reflex::Literal("std::map<unsigned int,double>::_Pair_alloc_type"))
  .AddTypedef(type_1130, Reflex::Literal("std::map<unsigned int,double>::_Rep_type"))
  .AddTypedef(type_8619, Reflex::Literal("std::map<unsigned int,double>::pointer"))
  .AddTypedef(type_8621, Reflex::Literal("std::map<unsigned int,double>::const_pointer"))
  .AddTypedef(type_8623, Reflex::Literal("std::map<unsigned int,double>::reference"))
  .AddTypedef(type_8625, Reflex::Literal("std::map<unsigned int,double>::const_reference"))
  .AddTypedef(type_1266, Reflex::Literal("std::map<unsigned int,double>::iterator"))
  .AddTypedef(type_1908, Reflex::Literal("std::map<unsigned int,double>::const_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::map<unsigned int,double>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::map<unsigned int,double>::difference_type"))
  .AddTypedef(type_1833, Reflex::Literal("std::map<unsigned int,double>::reverse_iterator"))
  .AddTypedef(type_1832, Reflex::Literal("std::map<unsigned int,double>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_14816, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_14817, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20537, type_20608), Reflex::Literal("map"), constructor_14818, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21318), Reflex::Literal("map"), constructor_14819, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1632, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x265, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsint_double__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsint_double__funcmem_bld);
}

//------Delayed data member builder for class map<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, double> > > -------------------
void __std__map_unsignedsint_double__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1130, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsint_double_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<unsigned int,double,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, double> > > -------------------
void __std__map_unsignedsint_double__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21319, type_21318), Reflex::Literal("operator="), operator_14820, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1410), Reflex::Literal("get_allocator"), method_14821, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1266), Reflex::Literal("begin"), method_14822, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1908), Reflex::Literal("begin"), method_14823, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1266), Reflex::Literal("end"), method_14824, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1908), Reflex::Literal("end"), method_14825, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_14830, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_14831, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_14832, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3590, type_3951), Reflex::Literal("operator[]"), operator_14833, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3590, type_3951), Reflex::Literal("at"), method_14834, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4918, type_3951), Reflex::Literal("at"), method_14835, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_952, type_8625), Reflex::Literal("insert"), method_14836, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1266, type_1266, type_8625), Reflex::Literal("insert"), method_14837, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1266), Reflex::Literal("erase"), method_14838, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_3951), Reflex::Literal("erase"), method_14839, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1266, type_1266), Reflex::Literal("erase"), method_14840, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_21319), Reflex::Literal("swap"), method_14841, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_14842, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2029), Reflex::Literal("key_comp"), method_14843, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1266, type_3951), Reflex::Literal("find"), method_14845, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1908, type_3951), Reflex::Literal("find"), method_14846, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_3951), Reflex::Literal("count"), method_14847, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1266, type_3951), Reflex::Literal("lower_bound"), method_14848, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1908, type_3951), Reflex::Literal("lower_bound"), method_14849, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1266, type_3951), Reflex::Literal("upper_bound"), method_14850, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1908, type_3951), Reflex::Literal("upper_bound"), method_14851, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_951, type_3951), Reflex::Literal("equal_range"), method_14852, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_950, type_3951), Reflex::Literal("equal_range"), method_14853, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<unsigned int,bool,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, bool> > > -------------------------------
static void destructor_14874(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<unsigned int,bool>*)o)->::std::map<unsigned int,bool>::~map)();
}
static void constructor_14875( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,bool>();
  else ::new(mem) ::std::map<unsigned int,bool>();
}

static void constructor_14876( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,bool>(*(const ::std::less<unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,bool>(*(const ::std::less<unsigned int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,bool>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,bool> >*)arg[1]);
  else ::new(mem) ::std::map<unsigned int,bool>(*(const ::std::less<unsigned int>*)arg[0],
      *(const ::std::allocator<std::pair<const unsigned int,bool> >*)arg[1]);
  }
}

static void constructor_14877( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<unsigned int,bool>(*(const ::std::map<unsigned int,bool>*)arg[0]);
  else ::new(mem) ::std::map<unsigned int,bool>(*(const ::std::map<unsigned int,bool>*)arg[0]);
}

static  void operator_14878( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,bool>*)o)->operator=)(*(const ::std::map<unsigned int,bool>*)arg[0]);
  else   (((::std::map<unsigned int,bool>*)o)->operator=)(*(const ::std::map<unsigned int,bool>*)arg[0]);
}

static  void method_14879( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const unsigned int,bool> >)((((const ::std::map<unsigned int,bool>*)o)->get_allocator)());
  else   (((const ::std::map<unsigned int,bool>*)o)->get_allocator)();
}

static  void method_14880( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,bool> >)((((::std::map<unsigned int,bool>*)o)->begin)());
  else   (((::std::map<unsigned int,bool>*)o)->begin)();
}

static  void method_14881( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,bool> >)((((const ::std::map<unsigned int,bool>*)o)->begin)());
  else   (((const ::std::map<unsigned int,bool>*)o)->begin)();
}

static  void method_14882( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,bool> >)((((::std::map<unsigned int,bool>*)o)->end)());
  else   (((::std::map<unsigned int,bool>*)o)->end)();
}

static  void method_14883( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,bool> >)((((const ::std::map<unsigned int,bool>*)o)->end)());
  else   (((const ::std::map<unsigned int,bool>*)o)->end)();
}

static  void method_14888( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<unsigned int,bool>*)o)->empty)());
  else   (((const ::std::map<unsigned int,bool>*)o)->empty)();
}

static  void method_14889( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,bool>*)o)->size)());
  else   (((const ::std::map<unsigned int,bool>*)o)->size)();
}

static  void method_14890( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,bool>*)o)->max_size)());
  else   (((const ::std::map<unsigned int,bool>*)o)->max_size)();
}

static  void operator_14891( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,bool>*)o)->operator[])(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,bool>*)o)->operator[])(*(const unsigned int*)arg[0]);
}

static  void method_14892( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<unsigned int,bool>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((::std::map<unsigned int,bool>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14893( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<unsigned int,bool>*)o)->at)(*(const unsigned int*)arg[0]);
  else   (((const ::std::map<unsigned int,bool>*)o)->at)(*(const unsigned int*)arg[0]);
}

static  void method_14894( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,bool> >,bool>)((((::std::map<unsigned int,bool>*)o)->insert)(*(const ::std::pair<const unsigned int,bool>*)arg[0]));
  else   (((::std::map<unsigned int,bool>*)o)->insert)(*(const ::std::pair<const unsigned int,bool>*)arg[0]);
}

static  void method_14895( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,bool> >)((((::std::map<unsigned int,bool>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,bool> >*)arg[0],
    *(const ::std::pair<const unsigned int,bool>*)arg[1]));
  else   (((::std::map<unsigned int,bool>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,bool> >*)arg[0],
    *(const ::std::pair<const unsigned int,bool>*)arg[1]);
}

static  void method_14896( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,bool>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,bool> >*)arg[0]);
}

static  void method_14897( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<unsigned int,bool>*)o)->erase)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,bool>*)o)->erase)(*(const unsigned int*)arg[0]);
}

static  void method_14898( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,bool>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const unsigned int,bool> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const unsigned int,bool> >*)arg[1]);
}

static  void method_14899( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<unsigned int,bool>*)o)->swap)(*(::std::map<unsigned int,bool>*)arg[0]);
}

static  void method_14900( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<unsigned int,bool>*)o)->clear)();
}

static  void method_14901( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<unsigned int>)((((const ::std::map<unsigned int,bool>*)o)->key_comp)());
  else   (((const ::std::map<unsigned int,bool>*)o)->key_comp)();
}

static  void method_14903( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,bool> >)((((::std::map<unsigned int,bool>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,bool>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14904( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,bool> >)((((const ::std::map<unsigned int,bool>*)o)->find)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,bool>*)o)->find)(*(const unsigned int*)arg[0]);
}

static  void method_14905( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<unsigned int,bool>*)o)->count)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,bool>*)o)->count)(*(const unsigned int*)arg[0]);
}

static  void method_14906( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,bool> >)((((::std::map<unsigned int,bool>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,bool>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14907( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,bool> >)((((const ::std::map<unsigned int,bool>*)o)->lower_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,bool>*)o)->lower_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14908( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const unsigned int,bool> >)((((::std::map<unsigned int,bool>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,bool>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14909( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const unsigned int,bool> >)((((const ::std::map<unsigned int,bool>*)o)->upper_bound)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,bool>*)o)->upper_bound)(*(const unsigned int*)arg[0]);
}

static  void method_14910( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const unsigned int,bool> >,std::_Rb_tree_iterator<std::pair<const unsigned int,bool> > >)((((::std::map<unsigned int,bool>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((::std::map<unsigned int,bool>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static  void method_14911( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const unsigned int,bool> >,std::_Rb_tree_const_iterator<std::pair<const unsigned int,bool> > >)((((const ::std::map<unsigned int,bool>*)o)->equal_range)(*(const unsigned int*)arg[0]));
  else   (((const ::std::map<unsigned int,bool>*)o)->equal_range)(*(const unsigned int*)arg[0]);
}

static void method_newdel_1633( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,bool> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,bool> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,bool> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,bool> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<unsigned int,bool> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x267( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<unsigned int,bool> >::Generate();
  else ::Reflex::Proxy< ::std::map<unsigned int,bool> >::Generate();
}

//------Dictionary for class map<unsigned int,bool,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, bool> > > -------------------------------
void __std__map_unsignedsint_bool__db_datamem(Reflex::Class*);
void __std__map_unsignedsint_bool__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_bool__datamem_bld(&__std__map_unsignedsint_bool__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_unsignedsint_bool__funcmem_bld(&__std__map_unsignedsint_bool__db_funcmem);
void __std__map_unsignedsint_bool__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<unsigned int,bool>"), typeid(::std::map<unsigned int,bool>), sizeof(::std::map<unsigned int,bool>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_78, Reflex::Literal("std::map<unsigned int,bool>::key_type"))
  .AddTypedef(type_2083, Reflex::Literal("std::map<unsigned int,bool>::mapped_type"))
  .AddTypedef(type_881, Reflex::Literal("std::map<unsigned int,bool>::value_type"))
  .AddTypedef(type_2029, Reflex::Literal("std::map<unsigned int,bool>::key_compare"))
  .AddTypedef(type_1412, Reflex::Literal("std::map<unsigned int,bool>::allocator_type"))
  .AddTypedef(type_881, Reflex::Literal("std::map<unsigned int,bool>::_Alloc_value_type"))
  .AddTypedef(type_1412, Reflex::Literal("std::map<unsigned int,bool>::_Pair_alloc_type"))
  .AddTypedef(type_1131, Reflex::Literal("std::map<unsigned int,bool>::_Rep_type"))
  .AddTypedef(type_8724, Reflex::Literal("std::map<unsigned int,bool>::pointer"))
  .AddTypedef(type_8726, Reflex::Literal("std::map<unsigned int,bool>::const_pointer"))
  .AddTypedef(type_8728, Reflex::Literal("std::map<unsigned int,bool>::reference"))
  .AddTypedef(type_8730, Reflex::Literal("std::map<unsigned int,bool>::const_reference"))
  .AddTypedef(type_1267, Reflex::Literal("std::map<unsigned int,bool>::iterator"))
  .AddTypedef(type_1909, Reflex::Literal("std::map<unsigned int,bool>::const_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::map<unsigned int,bool>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::map<unsigned int,bool>::difference_type"))
  .AddTypedef(type_1835, Reflex::Literal("std::map<unsigned int,bool>::reverse_iterator"))
  .AddTypedef(type_1834, Reflex::Literal("std::map<unsigned int,bool>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_14874, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_14875, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20537, type_20615), Reflex::Literal("map"), constructor_14876, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21320), Reflex::Literal("map"), constructor_14877, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1633, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x267, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_unsignedsint_bool__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_unsignedsint_bool__funcmem_bld);
}

//------Delayed data member builder for class map<unsigned int,bool,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, bool> > > -------------------
void __std__map_unsignedsint_bool__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1131, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_unsignedsint_bool_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<unsigned int,bool,std::less<unsigned int>,std::allocator<std::pair<const unsigned int, bool> > > -------------------
void __std__map_unsignedsint_bool__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21321, type_21320), Reflex::Literal("operator="), operator_14878, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1412), Reflex::Literal("get_allocator"), method_14879, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1267), Reflex::Literal("begin"), method_14880, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1909), Reflex::Literal("begin"), method_14881, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1267), Reflex::Literal("end"), method_14882, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1909), Reflex::Literal("end"), method_14883, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_14888, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_14889, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_14890, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11876, type_3951), Reflex::Literal("operator[]"), operator_14891, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11876, type_3951), Reflex::Literal("at"), method_14892, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11878, type_3951), Reflex::Literal("at"), method_14893, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_955, type_8730), Reflex::Literal("insert"), method_14894, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1267, type_1267, type_8730), Reflex::Literal("insert"), method_14895, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1267), Reflex::Literal("erase"), method_14896, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_3951), Reflex::Literal("erase"), method_14897, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1267, type_1267), Reflex::Literal("erase"), method_14898, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_21321), Reflex::Literal("swap"), method_14899, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_14900, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2029), Reflex::Literal("key_comp"), method_14901, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1267, type_3951), Reflex::Literal("find"), method_14903, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1909, type_3951), Reflex::Literal("find"), method_14904, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_3951), Reflex::Literal("count"), method_14905, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1267, type_3951), Reflex::Literal("lower_bound"), method_14906, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1909, type_3951), Reflex::Literal("lower_bound"), method_14907, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1267, type_3951), Reflex::Literal("upper_bound"), method_14908, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1909, type_3951), Reflex::Literal("upper_bound"), method_14909, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_954, type_3951), Reflex::Literal("equal_range"), method_14910, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_953, type_3951), Reflex::Literal("equal_range"), method_14911, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<std::pair<short int, short int>,std::pair<short int, std::vector<short int, std::allocator<short int> > >,std::less<std::pair<short int, short int> >,std::allocator<std::pair<const std::pair<short int, short int>, std::pair<short int, std::vector<short int, std::allocator<short int> > > > > > -------------------------------
static void destructor_14932(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >::~map)();
}
static void constructor_14933( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >();
  else ::new(mem) ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >();
}

static void constructor_14934( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >(*(const ::std::less<std::pair<short,short> >*)arg[0]);
  else ::new(mem) ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >(*(const ::std::less<std::pair<short,short> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >(*(const ::std::less<std::pair<short,short> >*)arg[0],
      *(const ::std::allocator<std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > >*)arg[1]);
  else ::new(mem) ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >(*(const ::std::less<std::pair<short,short> >*)arg[0],
      *(const ::std::allocator<std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > >*)arg[1]);
  }
}

static void constructor_14935( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >(*(const ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)arg[0]);
  else ::new(mem) ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >(*(const ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)arg[0]);
}

static  void operator_14936( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->operator=)(*(const ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)arg[0]);
  else   (((::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->operator=)(*(const ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)arg[0]);
}

static  void method_14937( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > >)((((const ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->get_allocator)());
  else   (((const ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->get_allocator)();
}

static  void method_14938( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > >)((((::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->begin)());
  else   (((::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->begin)();
}

static  void method_14939( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > >)((((const ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->begin)());
  else   (((const ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->begin)();
}

static  void method_14940( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > >)((((::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->end)());
  else   (((::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->end)();
}

static  void method_14941( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > >)((((const ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->end)());
  else   (((const ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->end)();
}

static  void method_14946( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->empty)());
  else   (((const ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->empty)();
}

static  void method_14947( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->size)());
  else   (((const ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->size)();
}

static  void method_14948( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->max_size)());
  else   (((const ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->max_size)();
}

static  void operator_14949( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->operator[])(*(const ::std::pair<short,short>*)arg[0]);
  else   (((::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->operator[])(*(const ::std::pair<short,short>*)arg[0]);
}

static  void method_14950( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->at)(*(const ::std::pair<short,short>*)arg[0]);
  else   (((::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->at)(*(const ::std::pair<short,short>*)arg[0]);
}

static  void method_14951( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->at)(*(const ::std::pair<short,short>*)arg[0]);
  else   (((const ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->at)(*(const ::std::pair<short,short>*)arg[0]);
}

static  void method_14952( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > >,bool>)((((::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->insert)(*(const ::std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > >*)arg[0]));
  else   (((::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->insert)(*(const ::std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > >*)arg[0]);
}

static  void method_14953( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > >)((((::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > >*)arg[0],
    *(const ::std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > >*)arg[1]));
  else   (((::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > >*)arg[0],
    *(const ::std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > >*)arg[1]);
}

static  void method_14954( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > >*)arg[0]);
}

static  void method_14955( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->erase)(*(const ::std::pair<short,short>*)arg[0]));
  else   (((::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->erase)(*(const ::std::pair<short,short>*)arg[0]);
}

static  void method_14956( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > >*)arg[1]);
}

static  void method_14957( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->swap)(*(::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)arg[0]);
}

static  void method_14958( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->clear)();
}

static  void method_14959( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<std::pair<short,short> >)((((const ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->key_comp)());
  else   (((const ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->key_comp)();
}

static  void method_14961( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > >)((((::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->find)(*(const ::std::pair<short,short>*)arg[0]));
  else   (((::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->find)(*(const ::std::pair<short,short>*)arg[0]);
}

static  void method_14962( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > >)((((const ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->find)(*(const ::std::pair<short,short>*)arg[0]));
  else   (((const ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->find)(*(const ::std::pair<short,short>*)arg[0]);
}

static  void method_14963( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->count)(*(const ::std::pair<short,short>*)arg[0]));
  else   (((const ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->count)(*(const ::std::pair<short,short>*)arg[0]);
}

static  void method_14964( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > >)((((::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->lower_bound)(*(const ::std::pair<short,short>*)arg[0]));
  else   (((::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->lower_bound)(*(const ::std::pair<short,short>*)arg[0]);
}

static  void method_14965( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > >)((((const ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->lower_bound)(*(const ::std::pair<short,short>*)arg[0]));
  else   (((const ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->lower_bound)(*(const ::std::pair<short,short>*)arg[0]);
}

static  void method_14966( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > >)((((::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->upper_bound)(*(const ::std::pair<short,short>*)arg[0]));
  else   (((::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->upper_bound)(*(const ::std::pair<short,short>*)arg[0]);
}

static  void method_14967( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > >)((((const ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->upper_bound)(*(const ::std::pair<short,short>*)arg[0]));
  else   (((const ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->upper_bound)(*(const ::std::pair<short,short>*)arg[0]);
}

static  void method_14968( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > >,std::_Rb_tree_iterator<std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > > >)((((::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->equal_range)(*(const ::std::pair<short,short>*)arg[0]));
  else   (((::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->equal_range)(*(const ::std::pair<short,short>*)arg[0]);
}

static  void method_14969( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > >,std::_Rb_tree_const_iterator<std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > > >)((((const ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->equal_range)(*(const ::std::pair<short,short>*)arg[0]));
  else   (((const ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >*)o)->equal_range)(*(const ::std::pair<short,short>*)arg[0]);
}

static void method_newdel_1634( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x269( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > > >::Generate();
  else ::Reflex::Proxy< ::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > > >::Generate();
}

//------Dictionary for class map<std::pair<short int, short int>,std::pair<short int, std::vector<short int, std::allocator<short int> > >,std::less<std::pair<short int, short int> >,std::allocator<std::pair<const std::pair<short int, short int>, std::pair<short int, std::vector<short int, std::allocator<short int> > > > > > -------------------------------
void __std__map_std__pair_short_short__std__pair_short_std__vector_short_s_s__db_datamem(Reflex::Class*);
void __std__map_std__pair_short_short__std__pair_short_std__vector_short_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_std__pair_short_short__std__pair_short_std__vector_short_s_s__datamem_bld(&__std__map_std__pair_short_short__std__pair_short_std__vector_short_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_std__pair_short_short__std__pair_short_std__vector_short_s_s__funcmem_bld(&__std__map_std__pair_short_short__std__pair_short_std__vector_short_s_s__db_funcmem);
void __std__map_std__pair_short_short__std__pair_short_std__vector_short_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >"), typeid(::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >), sizeof(::std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_851, Reflex::Literal("std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >::key_type"))
  .AddTypedef(type_850, Reflex::Literal("std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >::mapped_type"))
  .AddTypedef(type_882, Reflex::Literal("std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >::value_type"))
  .AddTypedef(type_2030, Reflex::Literal("std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >::key_compare"))
  .AddTypedef(type_1415, Reflex::Literal("std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >::allocator_type"))
  .AddTypedef(type_882, Reflex::Literal("std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >::_Alloc_value_type"))
  .AddTypedef(type_1415, Reflex::Literal("std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >::_Pair_alloc_type"))
  .AddTypedef(type_1133, Reflex::Literal("std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >::_Rep_type"))
  .AddTypedef(type_8934, Reflex::Literal("std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >::pointer"))
  .AddTypedef(type_8936, Reflex::Literal("std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >::const_pointer"))
  .AddTypedef(type_8938, Reflex::Literal("std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >::reference"))
  .AddTypedef(type_8940, Reflex::Literal("std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >::const_reference"))
  .AddTypedef(type_1269, Reflex::Literal("std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >::iterator"))
  .AddTypedef(type_1911, Reflex::Literal("std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >::const_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >::difference_type"))
  .AddTypedef(type_1839, Reflex::Literal("std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >::reverse_iterator"))
  .AddTypedef(type_1838, Reflex::Literal("std::map<std::pair<short,short>,std::pair<short,std::vector<short> > >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_14932, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_14933, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20629, type_20630), Reflex::Literal("map"), constructor_14934, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21322), Reflex::Literal("map"), constructor_14935, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1634, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x269, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_std__pair_short_short__std__pair_short_std__vector_short_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_std__pair_short_short__std__pair_short_std__vector_short_s_s__funcmem_bld);
}

//------Delayed data member builder for class map<std::pair<short int, short int>,std::pair<short int, std::vector<short int, std::allocator<short int> > >,std::less<std::pair<short int, short int> >,std::allocator<std::pair<const std::pair<short int, short int>, std::pair<short int, std::vector<short int, std::allocator<short int> > > > > > -------------------
void __std__map_std__pair_short_short__std__pair_short_std__vector_short_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1133, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_std__pair_short_short__std__pair_short_std__vector_short_s_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<std::pair<short int, short int>,std::pair<short int, std::vector<short int, std::allocator<short int> > >,std::less<std::pair<short int, short int> >,std::allocator<std::pair<const std::pair<short int, short int>, std::pair<short int, std::vector<short int, std::allocator<short int> > > > > > -------------------
void __std__map_std__pair_short_short__std__pair_short_std__vector_short_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21323, type_21322), Reflex::Literal("operator="), operator_14936, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1415), Reflex::Literal("get_allocator"), method_14937, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1269), Reflex::Literal("begin"), method_14938, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1911), Reflex::Literal("begin"), method_14939, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1269), Reflex::Literal("end"), method_14940, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1911), Reflex::Literal("end"), method_14941, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_14946, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_14947, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_14948, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20208, type_20206), Reflex::Literal("operator[]"), operator_14949, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20208, type_20206), Reflex::Literal("at"), method_14950, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20207, type_20206), Reflex::Literal("at"), method_14951, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_961, type_8940), Reflex::Literal("insert"), method_14952, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1269, type_1269, type_8940), Reflex::Literal("insert"), method_14953, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1269), Reflex::Literal("erase"), method_14954, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_20206), Reflex::Literal("erase"), method_14955, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1269, type_1269), Reflex::Literal("erase"), method_14956, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_21323), Reflex::Literal("swap"), method_14957, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_14958, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2030), Reflex::Literal("key_comp"), method_14959, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1269, type_20206), Reflex::Literal("find"), method_14961, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1911, type_20206), Reflex::Literal("find"), method_14962, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_20206), Reflex::Literal("count"), method_14963, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1269, type_20206), Reflex::Literal("lower_bound"), method_14964, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1911, type_20206), Reflex::Literal("lower_bound"), method_14965, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1269, type_20206), Reflex::Literal("upper_bound"), method_14966, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1911, type_20206), Reflex::Literal("upper_bound"), method_14967, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_960, type_20206), Reflex::Literal("equal_range"), method_14968, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_959, type_20206), Reflex::Literal("equal_range"), method_14969, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<std::pair<int, int>,int,std::less<std::pair<int, int> >,std::allocator<std::pair<const std::pair<int, int>, int> > > -------------------------------
static void destructor_14990(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<std::pair<int,int>,int>*)o)->::std::map<std::pair<int,int>,int>::~map)();
}
static void constructor_14991( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::pair<int,int>,int>();
  else ::new(mem) ::std::map<std::pair<int,int>,int>();
}

static void constructor_14992( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::pair<int,int>,int>(*(const ::std::less<std::pair<int,int> >*)arg[0]);
  else ::new(mem) ::std::map<std::pair<int,int>,int>(*(const ::std::less<std::pair<int,int> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::pair<int,int>,int>(*(const ::std::less<std::pair<int,int> >*)arg[0],
      *(const ::std::allocator<std::pair<const std::pair<int,int>,int> >*)arg[1]);
  else ::new(mem) ::std::map<std::pair<int,int>,int>(*(const ::std::less<std::pair<int,int> >*)arg[0],
      *(const ::std::allocator<std::pair<const std::pair<int,int>,int> >*)arg[1]);
  }
}

static void constructor_14993( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::pair<int,int>,int>(*(const ::std::map<std::pair<int,int>,int>*)arg[0]);
  else ::new(mem) ::std::map<std::pair<int,int>,int>(*(const ::std::map<std::pair<int,int>,int>*)arg[0]);
}

static  void operator_14994( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::pair<int,int>,int>*)o)->operator=)(*(const ::std::map<std::pair<int,int>,int>*)arg[0]);
  else   (((::std::map<std::pair<int,int>,int>*)o)->operator=)(*(const ::std::map<std::pair<int,int>,int>*)arg[0]);
}

static  void method_14995( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const std::pair<int,int>,int> >)((((const ::std::map<std::pair<int,int>,int>*)o)->get_allocator)());
  else   (((const ::std::map<std::pair<int,int>,int>*)o)->get_allocator)();
}

static  void method_14996( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,int> >)((((::std::map<std::pair<int,int>,int>*)o)->begin)());
  else   (((::std::map<std::pair<int,int>,int>*)o)->begin)();
}

static  void method_14997( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::pair<int,int>,int> >)((((const ::std::map<std::pair<int,int>,int>*)o)->begin)());
  else   (((const ::std::map<std::pair<int,int>,int>*)o)->begin)();
}

static  void method_14998( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,int> >)((((::std::map<std::pair<int,int>,int>*)o)->end)());
  else   (((::std::map<std::pair<int,int>,int>*)o)->end)();
}

static  void method_14999( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::pair<int,int>,int> >)((((const ::std::map<std::pair<int,int>,int>*)o)->end)());
  else   (((const ::std::map<std::pair<int,int>,int>*)o)->end)();
}

static  void method_15004( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<std::pair<int,int>,int>*)o)->empty)());
  else   (((const ::std::map<std::pair<int,int>,int>*)o)->empty)();
}

static  void method_15005( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::pair<int,int>,int>*)o)->size)());
  else   (((const ::std::map<std::pair<int,int>,int>*)o)->size)();
}

static  void method_15006( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::pair<int,int>,int>*)o)->max_size)());
  else   (((const ::std::map<std::pair<int,int>,int>*)o)->max_size)();
}

static  void operator_15007( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::pair<int,int>,int>*)o)->operator[])(*(const ::std::pair<int,int>*)arg[0]);
  else   (((::std::map<std::pair<int,int>,int>*)o)->operator[])(*(const ::std::pair<int,int>*)arg[0]);
}

static  void method_15008( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::pair<int,int>,int>*)o)->at)(*(const ::std::pair<int,int>*)arg[0]);
  else   (((::std::map<std::pair<int,int>,int>*)o)->at)(*(const ::std::pair<int,int>*)arg[0]);
}

static  void method_15009( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<std::pair<int,int>,int>*)o)->at)(*(const ::std::pair<int,int>*)arg[0]);
  else   (((const ::std::map<std::pair<int,int>,int>*)o)->at)(*(const ::std::pair<int,int>*)arg[0]);
}

static  void method_15010( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,int> >,bool>)((((::std::map<std::pair<int,int>,int>*)o)->insert)(*(const ::std::pair<const std::pair<int,int>,int>*)arg[0]));
  else   (((::std::map<std::pair<int,int>,int>*)o)->insert)(*(const ::std::pair<const std::pair<int,int>,int>*)arg[0]);
}

static  void method_15011( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,int> >)((((::std::map<std::pair<int,int>,int>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,int> >*)arg[0],
    *(const ::std::pair<const std::pair<int,int>,int>*)arg[1]));
  else   (((::std::map<std::pair<int,int>,int>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,int> >*)arg[0],
    *(const ::std::pair<const std::pair<int,int>,int>*)arg[1]);
}

static  void method_15012( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::pair<int,int>,int>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,int> >*)arg[0]);
}

static  void method_15013( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<std::pair<int,int>,int>*)o)->erase)(*(const ::std::pair<int,int>*)arg[0]));
  else   (((::std::map<std::pair<int,int>,int>*)o)->erase)(*(const ::std::pair<int,int>*)arg[0]);
}

static  void method_15014( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::pair<int,int>,int>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,int> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,int> >*)arg[1]);
}

static  void method_15015( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::pair<int,int>,int>*)o)->swap)(*(::std::map<std::pair<int,int>,int>*)arg[0]);
}

static  void method_15016( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<std::pair<int,int>,int>*)o)->clear)();
}

static  void method_15017( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<std::pair<int,int> >)((((const ::std::map<std::pair<int,int>,int>*)o)->key_comp)());
  else   (((const ::std::map<std::pair<int,int>,int>*)o)->key_comp)();
}

static  void method_15019( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,int> >)((((::std::map<std::pair<int,int>,int>*)o)->find)(*(const ::std::pair<int,int>*)arg[0]));
  else   (((::std::map<std::pair<int,int>,int>*)o)->find)(*(const ::std::pair<int,int>*)arg[0]);
}

static  void method_15020( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::pair<int,int>,int> >)((((const ::std::map<std::pair<int,int>,int>*)o)->find)(*(const ::std::pair<int,int>*)arg[0]));
  else   (((const ::std::map<std::pair<int,int>,int>*)o)->find)(*(const ::std::pair<int,int>*)arg[0]);
}

static  void method_15021( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::pair<int,int>,int>*)o)->count)(*(const ::std::pair<int,int>*)arg[0]));
  else   (((const ::std::map<std::pair<int,int>,int>*)o)->count)(*(const ::std::pair<int,int>*)arg[0]);
}

static  void method_15022( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,int> >)((((::std::map<std::pair<int,int>,int>*)o)->lower_bound)(*(const ::std::pair<int,int>*)arg[0]));
  else   (((::std::map<std::pair<int,int>,int>*)o)->lower_bound)(*(const ::std::pair<int,int>*)arg[0]);
}

static  void method_15023( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::pair<int,int>,int> >)((((const ::std::map<std::pair<int,int>,int>*)o)->lower_bound)(*(const ::std::pair<int,int>*)arg[0]));
  else   (((const ::std::map<std::pair<int,int>,int>*)o)->lower_bound)(*(const ::std::pair<int,int>*)arg[0]);
}

static  void method_15024( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,int> >)((((::std::map<std::pair<int,int>,int>*)o)->upper_bound)(*(const ::std::pair<int,int>*)arg[0]));
  else   (((::std::map<std::pair<int,int>,int>*)o)->upper_bound)(*(const ::std::pair<int,int>*)arg[0]);
}

static  void method_15025( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::pair<int,int>,int> >)((((const ::std::map<std::pair<int,int>,int>*)o)->upper_bound)(*(const ::std::pair<int,int>*)arg[0]));
  else   (((const ::std::map<std::pair<int,int>,int>*)o)->upper_bound)(*(const ::std::pair<int,int>*)arg[0]);
}

static  void method_15026( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,int> >,std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,int> > >)((((::std::map<std::pair<int,int>,int>*)o)->equal_range)(*(const ::std::pair<int,int>*)arg[0]));
  else   (((::std::map<std::pair<int,int>,int>*)o)->equal_range)(*(const ::std::pair<int,int>*)arg[0]);
}

static  void method_15027( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const std::pair<int,int>,int> >,std::_Rb_tree_const_iterator<std::pair<const std::pair<int,int>,int> > >)((((const ::std::map<std::pair<int,int>,int>*)o)->equal_range)(*(const ::std::pair<int,int>*)arg[0]));
  else   (((const ::std::map<std::pair<int,int>,int>*)o)->equal_range)(*(const ::std::pair<int,int>*)arg[0]);
}

static void method_newdel_1635( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<std::pair<int,int>,int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<std::pair<int,int>,int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<std::pair<int,int>,int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<std::pair<int,int>,int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<std::pair<int,int>,int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x271( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<std::pair<int,int>,int> >::Generate();
  else ::Reflex::Proxy< ::std::map<std::pair<int,int>,int> >::Generate();
}

//------Dictionary for class map<std::pair<int, int>,int,std::less<std::pair<int, int> >,std::allocator<std::pair<const std::pair<int, int>, int> > > -------------------------------
void __std__map_std__pair_int_int__int__db_datamem(Reflex::Class*);
void __std__map_std__pair_int_int__int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_std__pair_int_int__int__datamem_bld(&__std__map_std__pair_int_int__int__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_std__pair_int_int__int__funcmem_bld(&__std__map_std__pair_int_int__int__db_funcmem);
void __std__map_std__pair_int_int__int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<std::pair<int,int>,int>"), typeid(::std::map<std::pair<int,int>,int>), sizeof(::std::map<std::pair<int,int>,int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_825, Reflex::Literal("std::map<std::pair<int,int>,int>::key_type"))
  .AddTypedef(type_22, Reflex::Literal("std::map<std::pair<int,int>,int>::mapped_type"))
  .AddTypedef(type_883, Reflex::Literal("std::map<std::pair<int,int>,int>::value_type"))
  .AddTypedef(type_2031, Reflex::Literal("std::map<std::pair<int,int>,int>::key_compare"))
  .AddTypedef(type_1417, Reflex::Literal("std::map<std::pair<int,int>,int>::allocator_type"))
  .AddTypedef(type_883, Reflex::Literal("std::map<std::pair<int,int>,int>::_Alloc_value_type"))
  .AddTypedef(type_1417, Reflex::Literal("std::map<std::pair<int,int>,int>::_Pair_alloc_type"))
  .AddTypedef(type_1134, Reflex::Literal("std::map<std::pair<int,int>,int>::_Rep_type"))
  .AddTypedef(type_9039, Reflex::Literal("std::map<std::pair<int,int>,int>::pointer"))
  .AddTypedef(type_9041, Reflex::Literal("std::map<std::pair<int,int>,int>::const_pointer"))
  .AddTypedef(type_9043, Reflex::Literal("std::map<std::pair<int,int>,int>::reference"))
  .AddTypedef(type_9045, Reflex::Literal("std::map<std::pair<int,int>,int>::const_reference"))
  .AddTypedef(type_1270, Reflex::Literal("std::map<std::pair<int,int>,int>::iterator"))
  .AddTypedef(type_1912, Reflex::Literal("std::map<std::pair<int,int>,int>::const_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::map<std::pair<int,int>,int>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::map<std::pair<int,int>,int>::difference_type"))
  .AddTypedef(type_1841, Reflex::Literal("std::map<std::pair<int,int>,int>::reverse_iterator"))
  .AddTypedef(type_1840, Reflex::Literal("std::map<std::pair<int,int>,int>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_14990, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_14991, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20638, type_20639), Reflex::Literal("map"), constructor_14992, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21324), Reflex::Literal("map"), constructor_14993, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1635, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x271, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_std__pair_int_int__int__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_std__pair_int_int__int__funcmem_bld);
}

//------Delayed data member builder for class map<std::pair<int, int>,int,std::less<std::pair<int, int> >,std::allocator<std::pair<const std::pair<int, int>, int> > > -------------------
void __std__map_std__pair_int_int__int__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1134, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_std__pair_int_int__int_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<std::pair<int, int>,int,std::less<std::pair<int, int> >,std::allocator<std::pair<const std::pair<int, int>, int> > > -------------------
void __std__map_std__pair_int_int__int__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21325, type_21324), Reflex::Literal("operator="), operator_14994, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1417), Reflex::Literal("get_allocator"), method_14995, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1270), Reflex::Literal("begin"), method_14996, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1912), Reflex::Literal("begin"), method_14997, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1270), Reflex::Literal("end"), method_14998, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1912), Reflex::Literal("end"), method_14999, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_15004, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_15005, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_15006, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3569, type_5826), Reflex::Literal("operator[]"), operator_15007, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3569, type_5826), Reflex::Literal("at"), method_15008, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4404, type_5826), Reflex::Literal("at"), method_15009, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_964, type_9045), Reflex::Literal("insert"), method_15010, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1270, type_1270, type_9045), Reflex::Literal("insert"), method_15011, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1270), Reflex::Literal("erase"), method_15012, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_5826), Reflex::Literal("erase"), method_15013, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1270, type_1270), Reflex::Literal("erase"), method_15014, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_21325), Reflex::Literal("swap"), method_15015, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_15016, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2031), Reflex::Literal("key_comp"), method_15017, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1270, type_5826), Reflex::Literal("find"), method_15019, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1912, type_5826), Reflex::Literal("find"), method_15020, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_5826), Reflex::Literal("count"), method_15021, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1270, type_5826), Reflex::Literal("lower_bound"), method_15022, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1912, type_5826), Reflex::Literal("lower_bound"), method_15023, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1270, type_5826), Reflex::Literal("upper_bound"), method_15024, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1912, type_5826), Reflex::Literal("upper_bound"), method_15025, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_963, type_5826), Reflex::Literal("equal_range"), method_15026, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_962, type_5826), Reflex::Literal("equal_range"), method_15027, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<std::pair<int, int>,double,std::less<std::pair<int, int> >,std::allocator<std::pair<const std::pair<int, int>, double> > > -------------------------------
static void destructor_15048(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<std::pair<int,int>,double>*)o)->::std::map<std::pair<int,int>,double>::~map)();
}
static void constructor_15049( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::pair<int,int>,double>();
  else ::new(mem) ::std::map<std::pair<int,int>,double>();
}

static void constructor_15050( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::pair<int,int>,double>(*(const ::std::less<std::pair<int,int> >*)arg[0]);
  else ::new(mem) ::std::map<std::pair<int,int>,double>(*(const ::std::less<std::pair<int,int> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::pair<int,int>,double>(*(const ::std::less<std::pair<int,int> >*)arg[0],
      *(const ::std::allocator<std::pair<const std::pair<int,int>,double> >*)arg[1]);
  else ::new(mem) ::std::map<std::pair<int,int>,double>(*(const ::std::less<std::pair<int,int> >*)arg[0],
      *(const ::std::allocator<std::pair<const std::pair<int,int>,double> >*)arg[1]);
  }
}

static void constructor_15051( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::pair<int,int>,double>(*(const ::std::map<std::pair<int,int>,double>*)arg[0]);
  else ::new(mem) ::std::map<std::pair<int,int>,double>(*(const ::std::map<std::pair<int,int>,double>*)arg[0]);
}

static  void operator_15052( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::pair<int,int>,double>*)o)->operator=)(*(const ::std::map<std::pair<int,int>,double>*)arg[0]);
  else   (((::std::map<std::pair<int,int>,double>*)o)->operator=)(*(const ::std::map<std::pair<int,int>,double>*)arg[0]);
}

static  void method_15053( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const std::pair<int,int>,double> >)((((const ::std::map<std::pair<int,int>,double>*)o)->get_allocator)());
  else   (((const ::std::map<std::pair<int,int>,double>*)o)->get_allocator)();
}

static  void method_15054( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,double> >)((((::std::map<std::pair<int,int>,double>*)o)->begin)());
  else   (((::std::map<std::pair<int,int>,double>*)o)->begin)();
}

static  void method_15055( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::pair<int,int>,double> >)((((const ::std::map<std::pair<int,int>,double>*)o)->begin)());
  else   (((const ::std::map<std::pair<int,int>,double>*)o)->begin)();
}

static  void method_15056( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,double> >)((((::std::map<std::pair<int,int>,double>*)o)->end)());
  else   (((::std::map<std::pair<int,int>,double>*)o)->end)();
}

static  void method_15057( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::pair<int,int>,double> >)((((const ::std::map<std::pair<int,int>,double>*)o)->end)());
  else   (((const ::std::map<std::pair<int,int>,double>*)o)->end)();
}

static  void method_15062( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<std::pair<int,int>,double>*)o)->empty)());
  else   (((const ::std::map<std::pair<int,int>,double>*)o)->empty)();
}

static  void method_15063( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::pair<int,int>,double>*)o)->size)());
  else   (((const ::std::map<std::pair<int,int>,double>*)o)->size)();
}

static  void method_15064( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::pair<int,int>,double>*)o)->max_size)());
  else   (((const ::std::map<std::pair<int,int>,double>*)o)->max_size)();
}

static  void operator_15065( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::pair<int,int>,double>*)o)->operator[])(*(const ::std::pair<int,int>*)arg[0]);
  else   (((::std::map<std::pair<int,int>,double>*)o)->operator[])(*(const ::std::pair<int,int>*)arg[0]);
}

static  void method_15066( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::pair<int,int>,double>*)o)->at)(*(const ::std::pair<int,int>*)arg[0]);
  else   (((::std::map<std::pair<int,int>,double>*)o)->at)(*(const ::std::pair<int,int>*)arg[0]);
}

static  void method_15067( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<std::pair<int,int>,double>*)o)->at)(*(const ::std::pair<int,int>*)arg[0]);
  else   (((const ::std::map<std::pair<int,int>,double>*)o)->at)(*(const ::std::pair<int,int>*)arg[0]);
}

static  void method_15068( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,double> >,bool>)((((::std::map<std::pair<int,int>,double>*)o)->insert)(*(const ::std::pair<const std::pair<int,int>,double>*)arg[0]));
  else   (((::std::map<std::pair<int,int>,double>*)o)->insert)(*(const ::std::pair<const std::pair<int,int>,double>*)arg[0]);
}

static  void method_15069( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,double> >)((((::std::map<std::pair<int,int>,double>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,double> >*)arg[0],
    *(const ::std::pair<const std::pair<int,int>,double>*)arg[1]));
  else   (((::std::map<std::pair<int,int>,double>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,double> >*)arg[0],
    *(const ::std::pair<const std::pair<int,int>,double>*)arg[1]);
}

static  void method_15070( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::pair<int,int>,double>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,double> >*)arg[0]);
}

static  void method_15071( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<std::pair<int,int>,double>*)o)->erase)(*(const ::std::pair<int,int>*)arg[0]));
  else   (((::std::map<std::pair<int,int>,double>*)o)->erase)(*(const ::std::pair<int,int>*)arg[0]);
}

static  void method_15072( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::pair<int,int>,double>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,double> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,double> >*)arg[1]);
}

static  void method_15073( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::pair<int,int>,double>*)o)->swap)(*(::std::map<std::pair<int,int>,double>*)arg[0]);
}

static  void method_15074( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<std::pair<int,int>,double>*)o)->clear)();
}

static  void method_15075( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<std::pair<int,int> >)((((const ::std::map<std::pair<int,int>,double>*)o)->key_comp)());
  else   (((const ::std::map<std::pair<int,int>,double>*)o)->key_comp)();
}

static  void method_15077( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,double> >)((((::std::map<std::pair<int,int>,double>*)o)->find)(*(const ::std::pair<int,int>*)arg[0]));
  else   (((::std::map<std::pair<int,int>,double>*)o)->find)(*(const ::std::pair<int,int>*)arg[0]);
}

static  void method_15078( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::pair<int,int>,double> >)((((const ::std::map<std::pair<int,int>,double>*)o)->find)(*(const ::std::pair<int,int>*)arg[0]));
  else   (((const ::std::map<std::pair<int,int>,double>*)o)->find)(*(const ::std::pair<int,int>*)arg[0]);
}

static  void method_15079( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::pair<int,int>,double>*)o)->count)(*(const ::std::pair<int,int>*)arg[0]));
  else   (((const ::std::map<std::pair<int,int>,double>*)o)->count)(*(const ::std::pair<int,int>*)arg[0]);
}

static  void method_15080( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,double> >)((((::std::map<std::pair<int,int>,double>*)o)->lower_bound)(*(const ::std::pair<int,int>*)arg[0]));
  else   (((::std::map<std::pair<int,int>,double>*)o)->lower_bound)(*(const ::std::pair<int,int>*)arg[0]);
}

static  void method_15081( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::pair<int,int>,double> >)((((const ::std::map<std::pair<int,int>,double>*)o)->lower_bound)(*(const ::std::pair<int,int>*)arg[0]));
  else   (((const ::std::map<std::pair<int,int>,double>*)o)->lower_bound)(*(const ::std::pair<int,int>*)arg[0]);
}

static  void method_15082( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,double> >)((((::std::map<std::pair<int,int>,double>*)o)->upper_bound)(*(const ::std::pair<int,int>*)arg[0]));
  else   (((::std::map<std::pair<int,int>,double>*)o)->upper_bound)(*(const ::std::pair<int,int>*)arg[0]);
}

static  void method_15083( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::pair<int,int>,double> >)((((const ::std::map<std::pair<int,int>,double>*)o)->upper_bound)(*(const ::std::pair<int,int>*)arg[0]));
  else   (((const ::std::map<std::pair<int,int>,double>*)o)->upper_bound)(*(const ::std::pair<int,int>*)arg[0]);
}

static  void method_15084( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,double> >,std::_Rb_tree_iterator<std::pair<const std::pair<int,int>,double> > >)((((::std::map<std::pair<int,int>,double>*)o)->equal_range)(*(const ::std::pair<int,int>*)arg[0]));
  else   (((::std::map<std::pair<int,int>,double>*)o)->equal_range)(*(const ::std::pair<int,int>*)arg[0]);
}

static  void method_15085( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const std::pair<int,int>,double> >,std::_Rb_tree_const_iterator<std::pair<const std::pair<int,int>,double> > >)((((const ::std::map<std::pair<int,int>,double>*)o)->equal_range)(*(const ::std::pair<int,int>*)arg[0]));
  else   (((const ::std::map<std::pair<int,int>,double>*)o)->equal_range)(*(const ::std::pair<int,int>*)arg[0]);
}

static void method_newdel_1636( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<std::pair<int,int>,double> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<std::pair<int,int>,double> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<std::pair<int,int>,double> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<std::pair<int,int>,double> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<std::pair<int,int>,double> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x273( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<std::pair<int,int>,double> >::Generate();
  else ::Reflex::Proxy< ::std::map<std::pair<int,int>,double> >::Generate();
}

//------Dictionary for class map<std::pair<int, int>,double,std::less<std::pair<int, int> >,std::allocator<std::pair<const std::pair<int, int>, double> > > -------------------------------
void __std__map_std__pair_int_int__double__db_datamem(Reflex::Class*);
void __std__map_std__pair_int_int__double__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_std__pair_int_int__double__datamem_bld(&__std__map_std__pair_int_int__double__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_std__pair_int_int__double__funcmem_bld(&__std__map_std__pair_int_int__double__db_funcmem);
void __std__map_std__pair_int_int__double__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<std::pair<int,int>,double>"), typeid(::std::map<std::pair<int,int>,double>), sizeof(::std::map<std::pair<int,int>,double>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_825, Reflex::Literal("std::map<std::pair<int,int>,double>::key_type"))
  .AddTypedef(type_2052, Reflex::Literal("std::map<std::pair<int,int>,double>::mapped_type"))
  .AddTypedef(type_966, Reflex::Literal("std::map<std::pair<int,int>,double>::value_type"))
  .AddTypedef(type_2031, Reflex::Literal("std::map<std::pair<int,int>,double>::key_compare"))
  .AddTypedef(type_1419, Reflex::Literal("std::map<std::pair<int,int>,double>::allocator_type"))
  .AddTypedef(type_966, Reflex::Literal("std::map<std::pair<int,int>,double>::_Alloc_value_type"))
  .AddTypedef(type_1419, Reflex::Literal("std::map<std::pair<int,int>,double>::_Pair_alloc_type"))
  .AddTypedef(type_1135, Reflex::Literal("std::map<std::pair<int,int>,double>::_Rep_type"))
  .AddTypedef(type_9144, Reflex::Literal("std::map<std::pair<int,int>,double>::pointer"))
  .AddTypedef(type_9146, Reflex::Literal("std::map<std::pair<int,int>,double>::const_pointer"))
  .AddTypedef(type_9148, Reflex::Literal("std::map<std::pair<int,int>,double>::reference"))
  .AddTypedef(type_9150, Reflex::Literal("std::map<std::pair<int,int>,double>::const_reference"))
  .AddTypedef(type_1271, Reflex::Literal("std::map<std::pair<int,int>,double>::iterator"))
  .AddTypedef(type_1913, Reflex::Literal("std::map<std::pair<int,int>,double>::const_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::map<std::pair<int,int>,double>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::map<std::pair<int,int>,double>::difference_type"))
  .AddTypedef(type_1843, Reflex::Literal("std::map<std::pair<int,int>,double>::reverse_iterator"))
  .AddTypedef(type_1842, Reflex::Literal("std::map<std::pair<int,int>,double>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_15048, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_15049, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20638, type_20646), Reflex::Literal("map"), constructor_15050, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21326), Reflex::Literal("map"), constructor_15051, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1636, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x273, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_std__pair_int_int__double__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_std__pair_int_int__double__funcmem_bld);
}

//------Delayed data member builder for class map<std::pair<int, int>,double,std::less<std::pair<int, int> >,std::allocator<std::pair<const std::pair<int, int>, double> > > -------------------
void __std__map_std__pair_int_int__double__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1135, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_std__pair_int_int__double_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<std::pair<int, int>,double,std::less<std::pair<int, int> >,std::allocator<std::pair<const std::pair<int, int>, double> > > -------------------
void __std__map_std__pair_int_int__double__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21327, type_21326), Reflex::Literal("operator="), operator_15052, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1419), Reflex::Literal("get_allocator"), method_15053, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1271), Reflex::Literal("begin"), method_15054, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1913), Reflex::Literal("begin"), method_15055, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1271), Reflex::Literal("end"), method_15056, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1913), Reflex::Literal("end"), method_15057, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_15062, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_15063, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_15064, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3590, type_5826), Reflex::Literal("operator[]"), operator_15065, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3590, type_5826), Reflex::Literal("at"), method_15066, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4918, type_5826), Reflex::Literal("at"), method_15067, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_968, type_9150), Reflex::Literal("insert"), method_15068, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1271, type_1271, type_9150), Reflex::Literal("insert"), method_15069, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1271), Reflex::Literal("erase"), method_15070, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_5826), Reflex::Literal("erase"), method_15071, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1271, type_1271), Reflex::Literal("erase"), method_15072, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_21327), Reflex::Literal("swap"), method_15073, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_15074, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2031), Reflex::Literal("key_comp"), method_15075, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1271, type_5826), Reflex::Literal("find"), method_15077, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1913, type_5826), Reflex::Literal("find"), method_15078, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_5826), Reflex::Literal("count"), method_15079, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1271, type_5826), Reflex::Literal("lower_bound"), method_15080, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1913, type_5826), Reflex::Literal("lower_bound"), method_15081, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1271, type_5826), Reflex::Literal("upper_bound"), method_15082, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1913, type_5826), Reflex::Literal("upper_bound"), method_15083, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_967, type_5826), Reflex::Literal("equal_range"), method_15084, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_965, type_5826), Reflex::Literal("equal_range"), method_15085, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,long unsigned int,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, long unsigned int> > > -------------------------------
static void destructor_15106(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<std::basic_string<char>,unsigned long>*)o)->::std::map<std::basic_string<char>,unsigned long>::~map)();
}
static void constructor_15107( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,unsigned long>();
  else ::new(mem) ::std::map<std::basic_string<char>,unsigned long>();
}

static void constructor_15108( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,unsigned long>(*(const ::std::less<std::basic_string<char> >*)arg[0]);
  else ::new(mem) ::std::map<std::basic_string<char>,unsigned long>(*(const ::std::less<std::basic_string<char> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,unsigned long>(*(const ::std::less<std::basic_string<char> >*)arg[0],
      *(const ::std::allocator<std::pair<const std::basic_string<char>,unsigned long> >*)arg[1]);
  else ::new(mem) ::std::map<std::basic_string<char>,unsigned long>(*(const ::std::less<std::basic_string<char> >*)arg[0],
      *(const ::std::allocator<std::pair<const std::basic_string<char>,unsigned long> >*)arg[1]);
  }
}

static void constructor_15109( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,unsigned long>(*(const ::std::map<std::basic_string<char>,unsigned long>*)arg[0]);
  else ::new(mem) ::std::map<std::basic_string<char>,unsigned long>(*(const ::std::map<std::basic_string<char>,unsigned long>*)arg[0]);
}

static  void operator_15110( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,unsigned long>*)o)->operator=)(*(const ::std::map<std::basic_string<char>,unsigned long>*)arg[0]);
  else   (((::std::map<std::basic_string<char>,unsigned long>*)o)->operator=)(*(const ::std::map<std::basic_string<char>,unsigned long>*)arg[0]);
}

static  void method_15111( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const std::basic_string<char>,unsigned long> >)((((const ::std::map<std::basic_string<char>,unsigned long>*)o)->get_allocator)());
  else   (((const ::std::map<std::basic_string<char>,unsigned long>*)o)->get_allocator)();
}

static  void method_15112( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,unsigned long> >)((((::std::map<std::basic_string<char>,unsigned long>*)o)->begin)());
  else   (((::std::map<std::basic_string<char>,unsigned long>*)o)->begin)();
}

static  void method_15113( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,unsigned long> >)((((const ::std::map<std::basic_string<char>,unsigned long>*)o)->begin)());
  else   (((const ::std::map<std::basic_string<char>,unsigned long>*)o)->begin)();
}

static  void method_15114( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,unsigned long> >)((((::std::map<std::basic_string<char>,unsigned long>*)o)->end)());
  else   (((::std::map<std::basic_string<char>,unsigned long>*)o)->end)();
}

static  void method_15115( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,unsigned long> >)((((const ::std::map<std::basic_string<char>,unsigned long>*)o)->end)());
  else   (((const ::std::map<std::basic_string<char>,unsigned long>*)o)->end)();
}

static  void method_15120( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<std::basic_string<char>,unsigned long>*)o)->empty)());
  else   (((const ::std::map<std::basic_string<char>,unsigned long>*)o)->empty)();
}

static  void method_15121( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,unsigned long>*)o)->size)());
  else   (((const ::std::map<std::basic_string<char>,unsigned long>*)o)->size)();
}

static  void method_15122( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,unsigned long>*)o)->max_size)());
  else   (((const ::std::map<std::basic_string<char>,unsigned long>*)o)->max_size)();
}

static  void operator_15123( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,unsigned long>*)o)->operator[])(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::map<std::basic_string<char>,unsigned long>*)o)->operator[])(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15124( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,unsigned long>*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::map<std::basic_string<char>,unsigned long>*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15125( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<std::basic_string<char>,unsigned long>*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::std::map<std::basic_string<char>,unsigned long>*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15126( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,unsigned long> >,bool>)((((::std::map<std::basic_string<char>,unsigned long>*)o)->insert)(*(const ::std::pair<const std::basic_string<char>,unsigned long>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,unsigned long>*)o)->insert)(*(const ::std::pair<const std::basic_string<char>,unsigned long>*)arg[0]);
}

static  void method_15127( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,unsigned long> >)((((::std::map<std::basic_string<char>,unsigned long>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,unsigned long> >*)arg[0],
    *(const ::std::pair<const std::basic_string<char>,unsigned long>*)arg[1]));
  else   (((::std::map<std::basic_string<char>,unsigned long>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,unsigned long> >*)arg[0],
    *(const ::std::pair<const std::basic_string<char>,unsigned long>*)arg[1]);
}

static  void method_15128( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,unsigned long>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,unsigned long> >*)arg[0]);
}

static  void method_15129( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<std::basic_string<char>,unsigned long>*)o)->erase)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,unsigned long>*)o)->erase)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15130( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,unsigned long>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,unsigned long> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,unsigned long> >*)arg[1]);
}

static  void method_15131( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,unsigned long>*)o)->swap)(*(::std::map<std::basic_string<char>,unsigned long>*)arg[0]);
}

static  void method_15132( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<std::basic_string<char>,unsigned long>*)o)->clear)();
}

static  void method_15133( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<std::basic_string<char> >)((((const ::std::map<std::basic_string<char>,unsigned long>*)o)->key_comp)());
  else   (((const ::std::map<std::basic_string<char>,unsigned long>*)o)->key_comp)();
}

static  void method_15135( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,unsigned long> >)((((::std::map<std::basic_string<char>,unsigned long>*)o)->find)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,unsigned long>*)o)->find)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15136( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,unsigned long> >)((((const ::std::map<std::basic_string<char>,unsigned long>*)o)->find)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,unsigned long>*)o)->find)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15137( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,unsigned long>*)o)->count)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,unsigned long>*)o)->count)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15138( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,unsigned long> >)((((::std::map<std::basic_string<char>,unsigned long>*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,unsigned long>*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15139( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,unsigned long> >)((((const ::std::map<std::basic_string<char>,unsigned long>*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,unsigned long>*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15140( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,unsigned long> >)((((::std::map<std::basic_string<char>,unsigned long>*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,unsigned long>*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15141( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,unsigned long> >)((((const ::std::map<std::basic_string<char>,unsigned long>*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,unsigned long>*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15142( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,unsigned long> >,std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,unsigned long> > >)((((::std::map<std::basic_string<char>,unsigned long>*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,unsigned long>*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15143( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,unsigned long> >,std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,unsigned long> > >)((((const ::std::map<std::basic_string<char>,unsigned long>*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,unsigned long>*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]);
}

static void method_newdel_1637( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,unsigned long> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,unsigned long> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,unsigned long> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,unsigned long> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,unsigned long> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x275( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<std::basic_string<char>,unsigned long> >::Generate();
  else ::Reflex::Proxy< ::std::map<std::basic_string<char>,unsigned long> >::Generate();
}

//------Dictionary for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,long unsigned int,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, long unsigned int> > > -------------------------------
void __std__map_std__basic_string_char__unsignedslong__db_datamem(Reflex::Class*);
void __std__map_std__basic_string_char__unsignedslong__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_std__basic_string_char__unsignedslong__datamem_bld(&__std__map_std__basic_string_char__unsignedslong__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_std__basic_string_char__unsignedslong__funcmem_bld(&__std__map_std__basic_string_char__unsignedslong__db_funcmem);
void __std__map_std__basic_string_char__unsignedslong__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<std::basic_string<char>,unsigned long>"), typeid(::std::map<std::basic_string<char>,unsigned long>), sizeof(::std::map<std::basic_string<char>,unsigned long>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1104, Reflex::Literal("std::map<std::basic_string<char>,unsigned long>::key_type"))
  .AddTypedef(type_75, Reflex::Literal("std::map<std::basic_string<char>,unsigned long>::mapped_type"))
  .AddTypedef(type_970, Reflex::Literal("std::map<std::basic_string<char>,unsigned long>::value_type"))
  .AddTypedef(type_2023, Reflex::Literal("std::map<std::basic_string<char>,unsigned long>::key_compare"))
  .AddTypedef(type_1421, Reflex::Literal("std::map<std::basic_string<char>,unsigned long>::allocator_type"))
  .AddTypedef(type_970, Reflex::Literal("std::map<std::basic_string<char>,unsigned long>::_Alloc_value_type"))
  .AddTypedef(type_1421, Reflex::Literal("std::map<std::basic_string<char>,unsigned long>::_Pair_alloc_type"))
  .AddTypedef(type_1136, Reflex::Literal("std::map<std::basic_string<char>,unsigned long>::_Rep_type"))
  .AddTypedef(type_9249, Reflex::Literal("std::map<std::basic_string<char>,unsigned long>::pointer"))
  .AddTypedef(type_9251, Reflex::Literal("std::map<std::basic_string<char>,unsigned long>::const_pointer"))
  .AddTypedef(type_9253, Reflex::Literal("std::map<std::basic_string<char>,unsigned long>::reference"))
  .AddTypedef(type_9255, Reflex::Literal("std::map<std::basic_string<char>,unsigned long>::const_reference"))
  .AddTypedef(type_1272, Reflex::Literal("std::map<std::basic_string<char>,unsigned long>::iterator"))
  .AddTypedef(type_1914, Reflex::Literal("std::map<std::basic_string<char>,unsigned long>::const_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::map<std::basic_string<char>,unsigned long>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::map<std::basic_string<char>,unsigned long>::difference_type"))
  .AddTypedef(type_1845, Reflex::Literal("std::map<std::basic_string<char>,unsigned long>::reverse_iterator"))
  .AddTypedef(type_1844, Reflex::Literal("std::map<std::basic_string<char>,unsigned long>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_15106, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_15107, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20471, type_20653), Reflex::Literal("map"), constructor_15108, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21328), Reflex::Literal("map"), constructor_15109, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1637, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x275, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_std__basic_string_char__unsignedslong__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_std__basic_string_char__unsignedslong__funcmem_bld);
}

//------Delayed data member builder for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,long unsigned int,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, long unsigned int> > > -------------------
void __std__map_std__basic_string_char__unsignedslong__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1136, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_std__basic_string_char__unsignedslong_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,long unsigned int,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, long unsigned int> > > -------------------
void __std__map_std__basic_string_char__unsignedslong__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21329, type_21328), Reflex::Literal("operator="), operator_15110, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1421), Reflex::Literal("get_allocator"), method_15111, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1272), Reflex::Literal("begin"), method_15112, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1914), Reflex::Literal("begin"), method_15113, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1272), Reflex::Literal("end"), method_15114, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1914), Reflex::Literal("end"), method_15115, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_15120, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_15121, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_15122, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3483, type_4981), Reflex::Literal("operator[]"), operator_15123, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3483, type_4981), Reflex::Literal("at"), method_15124, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3825, type_4981), Reflex::Literal("at"), method_15125, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_972, type_9255), Reflex::Literal("insert"), method_15126, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1272, type_1272, type_9255), Reflex::Literal("insert"), method_15127, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1272), Reflex::Literal("erase"), method_15128, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4981), Reflex::Literal("erase"), method_15129, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1272, type_1272), Reflex::Literal("erase"), method_15130, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_21329), Reflex::Literal("swap"), method_15131, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_15132, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2023), Reflex::Literal("key_comp"), method_15133, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1272, type_4981), Reflex::Literal("find"), method_15135, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1914, type_4981), Reflex::Literal("find"), method_15136, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4981), Reflex::Literal("count"), method_15137, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1272, type_4981), Reflex::Literal("lower_bound"), method_15138, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1914, type_4981), Reflex::Literal("lower_bound"), method_15139, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1272, type_4981), Reflex::Literal("upper_bound"), method_15140, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1914, type_4981), Reflex::Literal("upper_bound"), method_15141, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_971, type_4981), Reflex::Literal("equal_range"), method_15142, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_969, type_4981), Reflex::Literal("equal_range"), method_15143, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,unsigned int,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, unsigned int> > > -------------------------------
static void destructor_15164(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<std::basic_string<char>,unsigned int>*)o)->::std::map<std::basic_string<char>,unsigned int>::~map)();
}
static void constructor_15165( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,unsigned int>();
  else ::new(mem) ::std::map<std::basic_string<char>,unsigned int>();
}

static void constructor_15166( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,unsigned int>(*(const ::std::less<std::basic_string<char> >*)arg[0]);
  else ::new(mem) ::std::map<std::basic_string<char>,unsigned int>(*(const ::std::less<std::basic_string<char> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,unsigned int>(*(const ::std::less<std::basic_string<char> >*)arg[0],
      *(const ::std::allocator<std::pair<const std::basic_string<char>,unsigned int> >*)arg[1]);
  else ::new(mem) ::std::map<std::basic_string<char>,unsigned int>(*(const ::std::less<std::basic_string<char> >*)arg[0],
      *(const ::std::allocator<std::pair<const std::basic_string<char>,unsigned int> >*)arg[1]);
  }
}

static void constructor_15167( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,unsigned int>(*(const ::std::map<std::basic_string<char>,unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<std::basic_string<char>,unsigned int>(*(const ::std::map<std::basic_string<char>,unsigned int>*)arg[0]);
}

static  void operator_15168( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,unsigned int>*)o)->operator=)(*(const ::std::map<std::basic_string<char>,unsigned int>*)arg[0]);
  else   (((::std::map<std::basic_string<char>,unsigned int>*)o)->operator=)(*(const ::std::map<std::basic_string<char>,unsigned int>*)arg[0]);
}

static  void method_15169( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const std::basic_string<char>,unsigned int> >)((((const ::std::map<std::basic_string<char>,unsigned int>*)o)->get_allocator)());
  else   (((const ::std::map<std::basic_string<char>,unsigned int>*)o)->get_allocator)();
}

static  void method_15170( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,unsigned int> >)((((::std::map<std::basic_string<char>,unsigned int>*)o)->begin)());
  else   (((::std::map<std::basic_string<char>,unsigned int>*)o)->begin)();
}

static  void method_15171( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,unsigned int> >)((((const ::std::map<std::basic_string<char>,unsigned int>*)o)->begin)());
  else   (((const ::std::map<std::basic_string<char>,unsigned int>*)o)->begin)();
}

static  void method_15172( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,unsigned int> >)((((::std::map<std::basic_string<char>,unsigned int>*)o)->end)());
  else   (((::std::map<std::basic_string<char>,unsigned int>*)o)->end)();
}

static  void method_15173( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,unsigned int> >)((((const ::std::map<std::basic_string<char>,unsigned int>*)o)->end)());
  else   (((const ::std::map<std::basic_string<char>,unsigned int>*)o)->end)();
}

static  void method_15178( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<std::basic_string<char>,unsigned int>*)o)->empty)());
  else   (((const ::std::map<std::basic_string<char>,unsigned int>*)o)->empty)();
}

static  void method_15179( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,unsigned int>*)o)->size)());
  else   (((const ::std::map<std::basic_string<char>,unsigned int>*)o)->size)();
}

static  void method_15180( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,unsigned int>*)o)->max_size)());
  else   (((const ::std::map<std::basic_string<char>,unsigned int>*)o)->max_size)();
}

static  void operator_15181( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,unsigned int>*)o)->operator[])(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::map<std::basic_string<char>,unsigned int>*)o)->operator[])(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15182( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,unsigned int>*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::map<std::basic_string<char>,unsigned int>*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15183( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<std::basic_string<char>,unsigned int>*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::std::map<std::basic_string<char>,unsigned int>*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15184( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,unsigned int> >,bool>)((((::std::map<std::basic_string<char>,unsigned int>*)o)->insert)(*(const ::std::pair<const std::basic_string<char>,unsigned int>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,unsigned int>*)o)->insert)(*(const ::std::pair<const std::basic_string<char>,unsigned int>*)arg[0]);
}

static  void method_15185( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,unsigned int> >)((((::std::map<std::basic_string<char>,unsigned int>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,unsigned int> >*)arg[0],
    *(const ::std::pair<const std::basic_string<char>,unsigned int>*)arg[1]));
  else   (((::std::map<std::basic_string<char>,unsigned int>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,unsigned int> >*)arg[0],
    *(const ::std::pair<const std::basic_string<char>,unsigned int>*)arg[1]);
}

static  void method_15186( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,unsigned int>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,unsigned int> >*)arg[0]);
}

static  void method_15187( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<std::basic_string<char>,unsigned int>*)o)->erase)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,unsigned int>*)o)->erase)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15188( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,unsigned int>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,unsigned int> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,unsigned int> >*)arg[1]);
}

static  void method_15189( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,unsigned int>*)o)->swap)(*(::std::map<std::basic_string<char>,unsigned int>*)arg[0]);
}

static  void method_15190( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<std::basic_string<char>,unsigned int>*)o)->clear)();
}

static  void method_15191( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<std::basic_string<char> >)((((const ::std::map<std::basic_string<char>,unsigned int>*)o)->key_comp)());
  else   (((const ::std::map<std::basic_string<char>,unsigned int>*)o)->key_comp)();
}

static  void method_15193( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,unsigned int> >)((((::std::map<std::basic_string<char>,unsigned int>*)o)->find)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,unsigned int>*)o)->find)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15194( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,unsigned int> >)((((const ::std::map<std::basic_string<char>,unsigned int>*)o)->find)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,unsigned int>*)o)->find)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15195( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,unsigned int>*)o)->count)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,unsigned int>*)o)->count)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15196( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,unsigned int> >)((((::std::map<std::basic_string<char>,unsigned int>*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,unsigned int>*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15197( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,unsigned int> >)((((const ::std::map<std::basic_string<char>,unsigned int>*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,unsigned int>*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15198( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,unsigned int> >)((((::std::map<std::basic_string<char>,unsigned int>*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,unsigned int>*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15199( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,unsigned int> >)((((const ::std::map<std::basic_string<char>,unsigned int>*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,unsigned int>*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15200( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,unsigned int> >,std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,unsigned int> > >)((((::std::map<std::basic_string<char>,unsigned int>*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,unsigned int>*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15201( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,unsigned int> >,std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,unsigned int> > >)((((const ::std::map<std::basic_string<char>,unsigned int>*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,unsigned int>*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]);
}

static void method_newdel_1638( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,unsigned int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,unsigned int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,unsigned int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,unsigned int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,unsigned int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x277( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<std::basic_string<char>,unsigned int> >::Generate();
  else ::Reflex::Proxy< ::std::map<std::basic_string<char>,unsigned int> >::Generate();
}

//------Dictionary for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,unsigned int,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, unsigned int> > > -------------------------------
void __std__map_std__basic_string_char__unsignedsint__db_datamem(Reflex::Class*);
void __std__map_std__basic_string_char__unsignedsint__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_std__basic_string_char__unsignedsint__datamem_bld(&__std__map_std__basic_string_char__unsignedsint__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_std__basic_string_char__unsignedsint__funcmem_bld(&__std__map_std__basic_string_char__unsignedsint__db_funcmem);
void __std__map_std__basic_string_char__unsignedsint__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<std::basic_string<char>,unsigned int>"), typeid(::std::map<std::basic_string<char>,unsigned int>), sizeof(::std::map<std::basic_string<char>,unsigned int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1104, Reflex::Literal("std::map<std::basic_string<char>,unsigned int>::key_type"))
  .AddTypedef(type_78, Reflex::Literal("std::map<std::basic_string<char>,unsigned int>::mapped_type"))
  .AddTypedef(type_884, Reflex::Literal("std::map<std::basic_string<char>,unsigned int>::value_type"))
  .AddTypedef(type_2023, Reflex::Literal("std::map<std::basic_string<char>,unsigned int>::key_compare"))
  .AddTypedef(type_1423, Reflex::Literal("std::map<std::basic_string<char>,unsigned int>::allocator_type"))
  .AddTypedef(type_884, Reflex::Literal("std::map<std::basic_string<char>,unsigned int>::_Alloc_value_type"))
  .AddTypedef(type_1423, Reflex::Literal("std::map<std::basic_string<char>,unsigned int>::_Pair_alloc_type"))
  .AddTypedef(type_1137, Reflex::Literal("std::map<std::basic_string<char>,unsigned int>::_Rep_type"))
  .AddTypedef(type_9354, Reflex::Literal("std::map<std::basic_string<char>,unsigned int>::pointer"))
  .AddTypedef(type_9356, Reflex::Literal("std::map<std::basic_string<char>,unsigned int>::const_pointer"))
  .AddTypedef(type_9358, Reflex::Literal("std::map<std::basic_string<char>,unsigned int>::reference"))
  .AddTypedef(type_9360, Reflex::Literal("std::map<std::basic_string<char>,unsigned int>::const_reference"))
  .AddTypedef(type_1273, Reflex::Literal("std::map<std::basic_string<char>,unsigned int>::iterator"))
  .AddTypedef(type_1915, Reflex::Literal("std::map<std::basic_string<char>,unsigned int>::const_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::map<std::basic_string<char>,unsigned int>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::map<std::basic_string<char>,unsigned int>::difference_type"))
  .AddTypedef(type_1847, Reflex::Literal("std::map<std::basic_string<char>,unsigned int>::reverse_iterator"))
  .AddTypedef(type_1846, Reflex::Literal("std::map<std::basic_string<char>,unsigned int>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_15164, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_15165, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20471, type_20660), Reflex::Literal("map"), constructor_15166, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21330), Reflex::Literal("map"), constructor_15167, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1638, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x277, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_std__basic_string_char__unsignedsint__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_std__basic_string_char__unsignedsint__funcmem_bld);
}

//------Delayed data member builder for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,unsigned int,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, unsigned int> > > -------------------
void __std__map_std__basic_string_char__unsignedsint__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1137, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_std__basic_string_char__unsignedsint_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,unsigned int,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, unsigned int> > > -------------------
void __std__map_std__basic_string_char__unsignedsint__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21331, type_21330), Reflex::Literal("operator="), operator_15168, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1423), Reflex::Literal("get_allocator"), method_15169, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1273), Reflex::Literal("begin"), method_15170, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1915), Reflex::Literal("begin"), method_15171, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1273), Reflex::Literal("end"), method_15172, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1915), Reflex::Literal("end"), method_15173, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_15178, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_15179, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_15180, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3505, type_4981), Reflex::Literal("operator[]"), operator_15181, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3505, type_4981), Reflex::Literal("at"), method_15182, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3951, type_4981), Reflex::Literal("at"), method_15183, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_975, type_9360), Reflex::Literal("insert"), method_15184, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1273, type_1273, type_9360), Reflex::Literal("insert"), method_15185, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1273), Reflex::Literal("erase"), method_15186, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4981), Reflex::Literal("erase"), method_15187, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1273, type_1273), Reflex::Literal("erase"), method_15188, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_21331), Reflex::Literal("swap"), method_15189, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_15190, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2023), Reflex::Literal("key_comp"), method_15191, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1273, type_4981), Reflex::Literal("find"), method_15193, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1915, type_4981), Reflex::Literal("find"), method_15194, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4981), Reflex::Literal("count"), method_15195, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1273, type_4981), Reflex::Literal("lower_bound"), method_15196, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1915, type_4981), Reflex::Literal("lower_bound"), method_15197, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1273, type_4981), Reflex::Literal("upper_bound"), method_15198, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1915, type_4981), Reflex::Literal("upper_bound"), method_15199, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_974, type_4981), Reflex::Literal("equal_range"), method_15200, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_973, type_4981), Reflex::Literal("equal_range"), method_15201, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, double>, std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, double> > >,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, double>, std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, double> > > > > > -------------------------------
static void destructor_15222(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >::~map)();
}
static void constructor_15223( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >();
  else ::new(mem) ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >();
}

static void constructor_15224( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >(*(const ::std::less<std::basic_string<char> >*)arg[0]);
  else ::new(mem) ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >(*(const ::std::less<std::basic_string<char> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >(*(const ::std::less<std::basic_string<char> >*)arg[0],
      *(const ::std::allocator<std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >*)arg[1]);
  else ::new(mem) ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >(*(const ::std::less<std::basic_string<char> >*)arg[0],
      *(const ::std::allocator<std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >*)arg[1]);
  }
}

static void constructor_15225( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >(*(const ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)arg[0]);
  else ::new(mem) ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >(*(const ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)arg[0]);
}

static  void operator_15226( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->operator=)(*(const ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)arg[0]);
  else   (((::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->operator=)(*(const ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)arg[0]);
}

static  void method_15227( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >)((((const ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->get_allocator)());
  else   (((const ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->get_allocator)();
}

static  void method_15228( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >)((((::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->begin)());
  else   (((::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->begin)();
}

static  void method_15229( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >)((((const ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->begin)());
  else   (((const ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->begin)();
}

static  void method_15230( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >)((((::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->end)());
  else   (((::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->end)();
}

static  void method_15231( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >)((((const ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->end)());
  else   (((const ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->end)();
}

static  void method_15236( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->empty)());
  else   (((const ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->empty)();
}

static  void method_15237( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->size)());
  else   (((const ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->size)();
}

static  void method_15238( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->max_size)());
  else   (((const ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->max_size)();
}

static  void operator_15239( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->operator[])(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->operator[])(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15240( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15241( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15242( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >,bool>)((((::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->insert)(*(const ::std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)arg[0]));
  else   (((::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->insert)(*(const ::std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)arg[0]);
}

static  void method_15243( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >)((((::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >*)arg[0],
    *(const ::std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)arg[1]));
  else   (((::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >*)arg[0],
    *(const ::std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)arg[1]);
}

static  void method_15244( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >*)arg[0]);
}

static  void method_15245( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->erase)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->erase)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15246( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >*)arg[1]);
}

static  void method_15247( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->swap)(*(::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)arg[0]);
}

static  void method_15248( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->clear)();
}

static  void method_15249( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<std::basic_string<char> >)((((const ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->key_comp)());
  else   (((const ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->key_comp)();
}

static  void method_15251( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >)((((::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->find)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->find)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15252( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >)((((const ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->find)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->find)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15253( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->count)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->count)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15254( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >)((((::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15255( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >)((((const ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15256( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >)((((::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15257( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >)((((const ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15258( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >,std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > > >)((((::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15259( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >,std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > > >)((((const ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]);
}

static void method_newdel_1639( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x279( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >::Generate();
  else ::Reflex::Proxy< ::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > >::Generate();
}

//------Dictionary for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, double>, std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, double> > >,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, double>, std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, double> > > > > > -------------------------------
void __std__map_std__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s__db_datamem(Reflex::Class*);
void __std__map_std__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_std__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s__datamem_bld(&__std__map_std__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_std__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s__funcmem_bld(&__std__map_std__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s__db_funcmem);
void __std__map_std__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >"), typeid(::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >), sizeof(::std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1104, Reflex::Literal("std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >::key_type"))
  .AddTypedef(type_1081, Reflex::Literal("std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >::mapped_type"))
  .AddTypedef(type_885, Reflex::Literal("std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >::value_type"))
  .AddTypedef(type_2023, Reflex::Literal("std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >::key_compare"))
  .AddTypedef(type_1425, Reflex::Literal("std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >::allocator_type"))
  .AddTypedef(type_885, Reflex::Literal("std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >::_Alloc_value_type"))
  .AddTypedef(type_1425, Reflex::Literal("std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >::_Pair_alloc_type"))
  .AddTypedef(type_1138, Reflex::Literal("std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >::_Rep_type"))
  .AddTypedef(type_9459, Reflex::Literal("std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >::pointer"))
  .AddTypedef(type_9461, Reflex::Literal("std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >::const_pointer"))
  .AddTypedef(type_9463, Reflex::Literal("std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >::reference"))
  .AddTypedef(type_9465, Reflex::Literal("std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >::const_reference"))
  .AddTypedef(type_1274, Reflex::Literal("std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >::iterator"))
  .AddTypedef(type_1916, Reflex::Literal("std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >::const_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >::difference_type"))
  .AddTypedef(type_1849, Reflex::Literal("std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >::reverse_iterator"))
  .AddTypedef(type_1848, Reflex::Literal("std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_15222, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_15223, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20471, type_20667), Reflex::Literal("map"), constructor_15224, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21332), Reflex::Literal("map"), constructor_15225, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1639, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x279, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_std__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_std__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s__funcmem_bld);
}

//------Delayed data member builder for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, double>, std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, double> > >,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, double>, std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, double> > > > > > -------------------
void __std__map_std__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1138, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_std__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, double>, std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, double> > >,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, double>, std::allocator<std::pair<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, double> > > > > > -------------------
void __std__map_std__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21333, type_21332), Reflex::Literal("operator="), operator_15226, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1425), Reflex::Literal("get_allocator"), method_15227, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1274), Reflex::Literal("begin"), method_15228, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1916), Reflex::Literal("begin"), method_15229, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1274), Reflex::Literal("end"), method_15230, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1916), Reflex::Literal("end"), method_15231, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_15236, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_15237, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_15238, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20384, type_4981), Reflex::Literal("operator[]"), operator_15239, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20384, type_4981), Reflex::Literal("at"), method_15240, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20216, type_4981), Reflex::Literal("at"), method_15241, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_978, type_9465), Reflex::Literal("insert"), method_15242, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1274, type_1274, type_9465), Reflex::Literal("insert"), method_15243, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1274), Reflex::Literal("erase"), method_15244, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4981), Reflex::Literal("erase"), method_15245, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1274, type_1274), Reflex::Literal("erase"), method_15246, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_21333), Reflex::Literal("swap"), method_15247, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_15248, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2023), Reflex::Literal("key_comp"), method_15249, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1274, type_4981), Reflex::Literal("find"), method_15251, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1916, type_4981), Reflex::Literal("find"), method_15252, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4981), Reflex::Literal("count"), method_15253, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1274, type_4981), Reflex::Literal("lower_bound"), method_15254, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1916, type_4981), Reflex::Literal("lower_bound"), method_15255, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1274, type_4981), Reflex::Literal("upper_bound"), method_15256, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1916, type_4981), Reflex::Literal("upper_bound"), method_15257, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_977, type_4981), Reflex::Literal("equal_range"), method_15258, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_976, type_4981), Reflex::Literal("equal_range"), method_15259, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > >,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > > > -------------------------------
static void destructor_15280(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >::~map)();
}
static void constructor_15281( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >();
  else ::new(mem) ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >();
}

static void constructor_15282( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >(*(const ::std::less<std::basic_string<char> >*)arg[0]);
  else ::new(mem) ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >(*(const ::std::less<std::basic_string<char> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >(*(const ::std::less<std::basic_string<char> >*)arg[0],
      *(const ::std::allocator<std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > >*)arg[1]);
  else ::new(mem) ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >(*(const ::std::less<std::basic_string<char> >*)arg[0],
      *(const ::std::allocator<std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > >*)arg[1]);
  }
}

static void constructor_15283( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >(*(const ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)arg[0]);
  else ::new(mem) ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >(*(const ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)arg[0]);
}

static  void operator_15284( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->operator=)(*(const ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)arg[0]);
  else   (((::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->operator=)(*(const ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)arg[0]);
}

static  void method_15285( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > >)((((const ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->get_allocator)());
  else   (((const ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->get_allocator)();
}

static  void method_15286( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > >)((((::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->begin)());
  else   (((::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->begin)();
}

static  void method_15287( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > >)((((const ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->begin)());
  else   (((const ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->begin)();
}

static  void method_15288( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > >)((((::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->end)());
  else   (((::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->end)();
}

static  void method_15289( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > >)((((const ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->end)());
  else   (((const ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->end)();
}

static  void method_15294( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->empty)());
  else   (((const ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->empty)();
}

static  void method_15295( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->size)());
  else   (((const ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->size)();
}

static  void method_15296( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->max_size)());
  else   (((const ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->max_size)();
}

static  void operator_15297( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->operator[])(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->operator[])(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15298( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15299( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15300( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > >,bool>)((((::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->insert)(*(const ::std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > >*)arg[0]));
  else   (((::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->insert)(*(const ::std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > >*)arg[0]);
}

static  void method_15301( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > >)((((::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > >*)arg[0],
    *(const ::std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > >*)arg[1]));
  else   (((::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > >*)arg[0],
    *(const ::std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > >*)arg[1]);
}

static  void method_15302( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > >*)arg[0]);
}

static  void method_15303( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->erase)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->erase)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15304( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > >*)arg[1]);
}

static  void method_15305( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->swap)(*(::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)arg[0]);
}

static  void method_15306( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->clear)();
}

static  void method_15307( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<std::basic_string<char> >)((((const ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->key_comp)());
  else   (((const ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->key_comp)();
}

static  void method_15309( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > >)((((::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->find)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->find)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15310( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > >)((((const ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->find)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->find)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15311( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->count)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->count)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15312( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > >)((((::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15313( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > >)((((const ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15314( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > >)((((::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15315( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > >)((((const ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15316( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > >,std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > > >)((((::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15317( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > >,std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > > >)((((const ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]);
}

static void method_newdel_1640( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x281( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > > >::Generate();
  else ::Reflex::Proxy< ::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > > >::Generate();
}

//------Dictionary for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > >,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > > > -------------------------------
void __std__map_std__basic_string_char__std__vector_std__basic_string_char_s_s__db_datamem(Reflex::Class*);
void __std__map_std__basic_string_char__std__vector_std__basic_string_char_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_std__basic_string_char__std__vector_std__basic_string_char_s_s__datamem_bld(&__std__map_std__basic_string_char__std__vector_std__basic_string_char_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_std__basic_string_char__std__vector_std__basic_string_char_s_s__funcmem_bld(&__std__map_std__basic_string_char__std__vector_std__basic_string_char_s_s__db_funcmem);
void __std__map_std__basic_string_char__std__vector_std__basic_string_char_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >"), typeid(::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >), sizeof(::std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1104, Reflex::Literal("std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >::key_type"))
  .AddTypedef(type_1070, Reflex::Literal("std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >::mapped_type"))
  .AddTypedef(type_886, Reflex::Literal("std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >::value_type"))
  .AddTypedef(type_2023, Reflex::Literal("std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >::key_compare"))
  .AddTypedef(type_1427, Reflex::Literal("std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >::allocator_type"))
  .AddTypedef(type_886, Reflex::Literal("std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >::_Alloc_value_type"))
  .AddTypedef(type_1427, Reflex::Literal("std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >::_Pair_alloc_type"))
  .AddTypedef(type_1139, Reflex::Literal("std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >::_Rep_type"))
  .AddTypedef(type_9564, Reflex::Literal("std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >::pointer"))
  .AddTypedef(type_9566, Reflex::Literal("std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >::const_pointer"))
  .AddTypedef(type_9568, Reflex::Literal("std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >::reference"))
  .AddTypedef(type_9570, Reflex::Literal("std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >::const_reference"))
  .AddTypedef(type_1275, Reflex::Literal("std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >::iterator"))
  .AddTypedef(type_1917, Reflex::Literal("std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >::const_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >::difference_type"))
  .AddTypedef(type_1851, Reflex::Literal("std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >::reverse_iterator"))
  .AddTypedef(type_1850, Reflex::Literal("std::map<std::basic_string<char>,std::vector<std::basic_string<char> > >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_15280, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_15281, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20471, type_20674), Reflex::Literal("map"), constructor_15282, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21334), Reflex::Literal("map"), constructor_15283, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1640, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x281, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_std__basic_string_char__std__vector_std__basic_string_char_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_std__basic_string_char__std__vector_std__basic_string_char_s_s__funcmem_bld);
}

//------Delayed data member builder for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > >,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > > > -------------------
void __std__map_std__basic_string_char__std__vector_std__basic_string_char_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1139, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_std__basic_string_char__std__vector_std__basic_string_char_s_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > >,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > > > -------------------
void __std__map_std__basic_string_char__std__vector_std__basic_string_char_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21335, type_21334), Reflex::Literal("operator="), operator_15284, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1427), Reflex::Literal("get_allocator"), method_15285, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1275), Reflex::Literal("begin"), method_15286, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1917), Reflex::Literal("begin"), method_15287, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1275), Reflex::Literal("end"), method_15288, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1917), Reflex::Literal("end"), method_15289, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_15294, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_15295, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_15296, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20344, type_4981), Reflex::Literal("operator[]"), operator_15297, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20344, type_4981), Reflex::Literal("at"), method_15298, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20219, type_4981), Reflex::Literal("at"), method_15299, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_981, type_9570), Reflex::Literal("insert"), method_15300, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1275, type_1275, type_9570), Reflex::Literal("insert"), method_15301, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1275), Reflex::Literal("erase"), method_15302, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4981), Reflex::Literal("erase"), method_15303, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1275, type_1275), Reflex::Literal("erase"), method_15304, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_21335), Reflex::Literal("swap"), method_15305, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_15306, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2023), Reflex::Literal("key_comp"), method_15307, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1275, type_4981), Reflex::Literal("find"), method_15309, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1917, type_4981), Reflex::Literal("find"), method_15310, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4981), Reflex::Literal("count"), method_15311, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1275, type_4981), Reflex::Literal("lower_bound"), method_15312, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1917, type_4981), Reflex::Literal("lower_bound"), method_15313, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1275, type_4981), Reflex::Literal("upper_bound"), method_15314, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1917, type_4981), Reflex::Literal("upper_bound"), method_15315, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_980, type_4981), Reflex::Literal("equal_range"), method_15316, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_979, type_4981), Reflex::Literal("equal_range"), method_15317, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::pair<unsigned int, unsigned int>,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<unsigned int, unsigned int> > > > -------------------------------
static void destructor_15338(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >::~map)();
}
static void constructor_15339( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >();
  else ::new(mem) ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >();
}

static void constructor_15340( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >(*(const ::std::less<std::basic_string<char> >*)arg[0]);
  else ::new(mem) ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >(*(const ::std::less<std::basic_string<char> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >(*(const ::std::less<std::basic_string<char> >*)arg[0],
      *(const ::std::allocator<std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > >*)arg[1]);
  else ::new(mem) ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >(*(const ::std::less<std::basic_string<char> >*)arg[0],
      *(const ::std::allocator<std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > >*)arg[1]);
  }
}

static void constructor_15341( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >(*(const ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)arg[0]);
  else ::new(mem) ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >(*(const ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)arg[0]);
}

static  void operator_15342( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->operator=)(*(const ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)arg[0]);
  else   (((::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->operator=)(*(const ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)arg[0]);
}

static  void method_15343( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > >)((((const ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->get_allocator)());
  else   (((const ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->get_allocator)();
}

static  void method_15344( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > >)((((::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->begin)());
  else   (((::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->begin)();
}

static  void method_15345( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > >)((((const ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->begin)());
  else   (((const ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->begin)();
}

static  void method_15346( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > >)((((::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->end)());
  else   (((::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->end)();
}

static  void method_15347( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > >)((((const ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->end)());
  else   (((const ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->end)();
}

static  void method_15352( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->empty)());
  else   (((const ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->empty)();
}

static  void method_15353( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->size)());
  else   (((const ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->size)();
}

static  void method_15354( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->max_size)());
  else   (((const ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->max_size)();
}

static  void operator_15355( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->operator[])(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->operator[])(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15356( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15357( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15358( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > >,bool>)((((::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->insert)(*(const ::std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)arg[0]));
  else   (((::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->insert)(*(const ::std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)arg[0]);
}

static  void method_15359( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > >)((((::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > >*)arg[0],
    *(const ::std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)arg[1]));
  else   (((::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > >*)arg[0],
    *(const ::std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)arg[1]);
}

static  void method_15360( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > >*)arg[0]);
}

static  void method_15361( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->erase)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->erase)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15362( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > >*)arg[1]);
}

static  void method_15363( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->swap)(*(::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)arg[0]);
}

static  void method_15364( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->clear)();
}

static  void method_15365( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<std::basic_string<char> >)((((const ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->key_comp)());
  else   (((const ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->key_comp)();
}

static  void method_15367( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > >)((((::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->find)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->find)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15368( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > >)((((const ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->find)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->find)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15369( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->count)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->count)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15370( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > >)((((::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15371( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > >)((((const ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15372( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > >)((((::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15373( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > >)((((const ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15374( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > >,std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > > >)((((::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15375( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > >,std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > > >)((((const ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]);
}

static void method_newdel_1641( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x283( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> > >::Generate();
  else ::Reflex::Proxy< ::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> > >::Generate();
}

//------Dictionary for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::pair<unsigned int, unsigned int>,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<unsigned int, unsigned int> > > > -------------------------------
void __std__map_std__basic_string_char__std__pair_unsignedsint_unsignedsint_s__db_datamem(Reflex::Class*);
void __std__map_std__basic_string_char__std__pair_unsignedsint_unsignedsint_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_std__basic_string_char__std__pair_unsignedsint_unsignedsint_s__datamem_bld(&__std__map_std__basic_string_char__std__pair_unsignedsint_unsignedsint_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_std__basic_string_char__std__pair_unsignedsint_unsignedsint_s__funcmem_bld(&__std__map_std__basic_string_char__std__pair_unsignedsint_unsignedsint_s__db_funcmem);
void __std__map_std__basic_string_char__std__pair_unsignedsint_unsignedsint_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >"), typeid(::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >), sizeof(::std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1104, Reflex::Literal("std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >::key_type"))
  .AddTypedef(type_814, Reflex::Literal("std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >::mapped_type"))
  .AddTypedef(type_887, Reflex::Literal("std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >::value_type"))
  .AddTypedef(type_2023, Reflex::Literal("std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >::key_compare"))
  .AddTypedef(type_1429, Reflex::Literal("std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >::allocator_type"))
  .AddTypedef(type_887, Reflex::Literal("std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >::_Alloc_value_type"))
  .AddTypedef(type_1429, Reflex::Literal("std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >::_Pair_alloc_type"))
  .AddTypedef(type_1140, Reflex::Literal("std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >::_Rep_type"))
  .AddTypedef(type_9669, Reflex::Literal("std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >::pointer"))
  .AddTypedef(type_9671, Reflex::Literal("std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >::const_pointer"))
  .AddTypedef(type_9673, Reflex::Literal("std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >::reference"))
  .AddTypedef(type_9675, Reflex::Literal("std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >::const_reference"))
  .AddTypedef(type_1276, Reflex::Literal("std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >::iterator"))
  .AddTypedef(type_1918, Reflex::Literal("std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >::const_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >::difference_type"))
  .AddTypedef(type_1853, Reflex::Literal("std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >::reverse_iterator"))
  .AddTypedef(type_1852, Reflex::Literal("std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_15338, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_15339, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20471, type_20681), Reflex::Literal("map"), constructor_15340, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21336), Reflex::Literal("map"), constructor_15341, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1641, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x283, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_std__basic_string_char__std__pair_unsignedsint_unsignedsint_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_std__basic_string_char__std__pair_unsignedsint_unsignedsint_s__funcmem_bld);
}

//------Delayed data member builder for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::pair<unsigned int, unsigned int>,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<unsigned int, unsigned int> > > > -------------------
void __std__map_std__basic_string_char__std__pair_unsignedsint_unsignedsint_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1140, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_std__basic_string_char__std__pair_unsignedsint_unsignedsint_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::pair<unsigned int, unsigned int>,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::pair<unsigned int, unsigned int> > > > -------------------
void __std__map_std__basic_string_char__std__pair_unsignedsint_unsignedsint_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21337, type_21336), Reflex::Literal("operator="), operator_15342, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1429), Reflex::Literal("get_allocator"), method_15343, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1276), Reflex::Literal("begin"), method_15344, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1918), Reflex::Literal("begin"), method_15345, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1276), Reflex::Literal("end"), method_15346, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1918), Reflex::Literal("end"), method_15347, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_15352, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_15353, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_15354, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5109, type_4981), Reflex::Literal("operator[]"), operator_15355, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5109, type_4981), Reflex::Literal("at"), method_15356, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5111, type_4981), Reflex::Literal("at"), method_15357, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_984, type_9675), Reflex::Literal("insert"), method_15358, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1276, type_1276, type_9675), Reflex::Literal("insert"), method_15359, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1276), Reflex::Literal("erase"), method_15360, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4981), Reflex::Literal("erase"), method_15361, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1276, type_1276), Reflex::Literal("erase"), method_15362, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_21337), Reflex::Literal("swap"), method_15363, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_15364, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2023), Reflex::Literal("key_comp"), method_15365, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1276, type_4981), Reflex::Literal("find"), method_15367, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1918, type_4981), Reflex::Literal("find"), method_15368, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4981), Reflex::Literal("count"), method_15369, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1276, type_4981), Reflex::Literal("lower_bound"), method_15370, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1918, type_4981), Reflex::Literal("lower_bound"), method_15371, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1276, type_4981), Reflex::Literal("upper_bound"), method_15372, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1918, type_4981), Reflex::Literal("upper_bound"), method_15373, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_983, type_4981), Reflex::Literal("equal_range"), method_15374, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_982, type_4981), Reflex::Literal("equal_range"), method_15375, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > > > > -------------------------------
static void destructor_15396(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >::~map)();
}
static void constructor_15397( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >();
  else ::new(mem) ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >();
}

static void constructor_15398( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >(*(const ::std::less<std::basic_string<char> >*)arg[0]);
  else ::new(mem) ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >(*(const ::std::less<std::basic_string<char> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >(*(const ::std::less<std::basic_string<char> >*)arg[0],
      *(const ::std::allocator<std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >*)arg[1]);
  else ::new(mem) ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >(*(const ::std::less<std::basic_string<char> >*)arg[0],
      *(const ::std::allocator<std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >*)arg[1]);
  }
}

static void constructor_15399( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >(*(const ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)arg[0]);
  else ::new(mem) ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >(*(const ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)arg[0]);
}

static  void operator_15400( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->operator=)(*(const ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)arg[0]);
  else   (((::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->operator=)(*(const ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)arg[0]);
}

static  void method_15401( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >)((((const ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->get_allocator)());
  else   (((const ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->get_allocator)();
}

static  void method_15402( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >)((((::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->begin)());
  else   (((::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->begin)();
}

static  void method_15403( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >)((((const ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->begin)());
  else   (((const ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->begin)();
}

static  void method_15404( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >)((((::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->end)());
  else   (((::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->end)();
}

static  void method_15405( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >)((((const ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->end)());
  else   (((const ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->end)();
}

static  void method_15410( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->empty)());
  else   (((const ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->empty)();
}

static  void method_15411( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->size)());
  else   (((const ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->size)();
}

static  void method_15412( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->max_size)());
  else   (((const ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->max_size)();
}

static  void operator_15413( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->operator[])(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->operator[])(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15414( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15415( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15416( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >,bool>)((((::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->insert)(*(const ::std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)arg[0]));
  else   (((::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->insert)(*(const ::std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)arg[0]);
}

static  void method_15417( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >)((((::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >*)arg[0],
    *(const ::std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)arg[1]));
  else   (((::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >*)arg[0],
    *(const ::std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)arg[1]);
}

static  void method_15418( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >*)arg[0]);
}

static  void method_15419( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->erase)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->erase)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15420( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >*)arg[1]);
}

static  void method_15421( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->swap)(*(::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)arg[0]);
}

static  void method_15422( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->clear)();
}

static  void method_15423( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<std::basic_string<char> >)((((const ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->key_comp)());
  else   (((const ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->key_comp)();
}

static  void method_15425( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >)((((::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->find)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->find)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15426( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >)((((const ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->find)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->find)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15427( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->count)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->count)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15428( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >)((((::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15429( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >)((((const ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15430( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >)((((::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15431( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >)((((const ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15432( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >,std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > > >)((((::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15433( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >,std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > > >)((((const ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]);
}

static void method_newdel_1642( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x285( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >::Generate();
  else ::Reflex::Proxy< ::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > >::Generate();
}

//------Dictionary for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > > > > -------------------------------
void __std__map_std__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s__db_datamem(Reflex::Class*);
void __std__map_std__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_std__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s__datamem_bld(&__std__map_std__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_std__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s__funcmem_bld(&__std__map_std__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s__db_funcmem);
void __std__map_std__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >"), typeid(::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >), sizeof(::std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1104, Reflex::Literal("std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >::key_type"))
  .AddTypedef(type_1615, Reflex::Literal("std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >::mapped_type"))
  .AddTypedef(type_888, Reflex::Literal("std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >::value_type"))
  .AddTypedef(type_2023, Reflex::Literal("std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >::key_compare"))
  .AddTypedef(type_1431, Reflex::Literal("std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >::allocator_type"))
  .AddTypedef(type_888, Reflex::Literal("std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >::_Alloc_value_type"))
  .AddTypedef(type_1431, Reflex::Literal("std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >::_Pair_alloc_type"))
  .AddTypedef(type_1141, Reflex::Literal("std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >::_Rep_type"))
  .AddTypedef(type_9774, Reflex::Literal("std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >::pointer"))
  .AddTypedef(type_9776, Reflex::Literal("std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >::const_pointer"))
  .AddTypedef(type_9778, Reflex::Literal("std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >::reference"))
  .AddTypedef(type_9780, Reflex::Literal("std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >::const_reference"))
  .AddTypedef(type_1277, Reflex::Literal("std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >::iterator"))
  .AddTypedef(type_1919, Reflex::Literal("std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >::const_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >::difference_type"))
  .AddTypedef(type_1855, Reflex::Literal("std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >::reverse_iterator"))
  .AddTypedef(type_1854, Reflex::Literal("std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_15396, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_15397, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20471, type_20688), Reflex::Literal("map"), constructor_15398, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21338), Reflex::Literal("map"), constructor_15399, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1642, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x285, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_std__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_std__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s__funcmem_bld);
}

//------Delayed data member builder for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > > > > -------------------
void __std__map_std__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1141, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_std__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > >,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >, std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > > > > -------------------
void __std__map_std__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21339, type_21338), Reflex::Literal("operator="), operator_15400, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1431), Reflex::Literal("get_allocator"), method_15401, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1277), Reflex::Literal("begin"), method_15402, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1919), Reflex::Literal("begin"), method_15403, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1277), Reflex::Literal("end"), method_15404, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1919), Reflex::Literal("end"), method_15405, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_15410, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_15411, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_15412, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21285, type_4981), Reflex::Literal("operator[]"), operator_15413, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21285, type_4981), Reflex::Literal("at"), method_15414, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20224, type_4981), Reflex::Literal("at"), method_15415, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_987, type_9780), Reflex::Literal("insert"), method_15416, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1277, type_1277, type_9780), Reflex::Literal("insert"), method_15417, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1277), Reflex::Literal("erase"), method_15418, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4981), Reflex::Literal("erase"), method_15419, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1277, type_1277), Reflex::Literal("erase"), method_15420, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_21339), Reflex::Literal("swap"), method_15421, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_15422, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2023), Reflex::Literal("key_comp"), method_15423, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1277, type_4981), Reflex::Literal("find"), method_15425, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1919, type_4981), Reflex::Literal("find"), method_15426, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4981), Reflex::Literal("count"), method_15427, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1277, type_4981), Reflex::Literal("lower_bound"), method_15428, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1919, type_4981), Reflex::Literal("lower_bound"), method_15429, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1277, type_4981), Reflex::Literal("upper_bound"), method_15430, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1919, type_4981), Reflex::Literal("upper_bound"), method_15431, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_986, type_4981), Reflex::Literal("equal_range"), method_15432, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_985, type_4981), Reflex::Literal("equal_range"), method_15433, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,int,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > > -------------------------------
static void destructor_15454(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<std::basic_string<char>,int>*)o)->::std::map<std::basic_string<char>,int>::~map)();
}
static void constructor_15455( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,int>();
  else ::new(mem) ::std::map<std::basic_string<char>,int>();
}

static void constructor_15456( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,int>(*(const ::std::less<std::basic_string<char> >*)arg[0]);
  else ::new(mem) ::std::map<std::basic_string<char>,int>(*(const ::std::less<std::basic_string<char> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,int>(*(const ::std::less<std::basic_string<char> >*)arg[0],
      *(const ::std::allocator<std::pair<const std::basic_string<char>,int> >*)arg[1]);
  else ::new(mem) ::std::map<std::basic_string<char>,int>(*(const ::std::less<std::basic_string<char> >*)arg[0],
      *(const ::std::allocator<std::pair<const std::basic_string<char>,int> >*)arg[1]);
  }
}

static void constructor_15457( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,int>(*(const ::std::map<std::basic_string<char>,int>*)arg[0]);
  else ::new(mem) ::std::map<std::basic_string<char>,int>(*(const ::std::map<std::basic_string<char>,int>*)arg[0]);
}

static  void operator_15458( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,int>*)o)->operator=)(*(const ::std::map<std::basic_string<char>,int>*)arg[0]);
  else   (((::std::map<std::basic_string<char>,int>*)o)->operator=)(*(const ::std::map<std::basic_string<char>,int>*)arg[0]);
}

static  void method_15459( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const std::basic_string<char>,int> >)((((const ::std::map<std::basic_string<char>,int>*)o)->get_allocator)());
  else   (((const ::std::map<std::basic_string<char>,int>*)o)->get_allocator)();
}

static  void method_15460( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,int> >)((((::std::map<std::basic_string<char>,int>*)o)->begin)());
  else   (((::std::map<std::basic_string<char>,int>*)o)->begin)();
}

static  void method_15461( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,int> >)((((const ::std::map<std::basic_string<char>,int>*)o)->begin)());
  else   (((const ::std::map<std::basic_string<char>,int>*)o)->begin)();
}

static  void method_15462( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,int> >)((((::std::map<std::basic_string<char>,int>*)o)->end)());
  else   (((::std::map<std::basic_string<char>,int>*)o)->end)();
}

static  void method_15463( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,int> >)((((const ::std::map<std::basic_string<char>,int>*)o)->end)());
  else   (((const ::std::map<std::basic_string<char>,int>*)o)->end)();
}

static  void method_15468( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<std::basic_string<char>,int>*)o)->empty)());
  else   (((const ::std::map<std::basic_string<char>,int>*)o)->empty)();
}

static  void method_15469( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,int>*)o)->size)());
  else   (((const ::std::map<std::basic_string<char>,int>*)o)->size)();
}

static  void method_15470( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,int>*)o)->max_size)());
  else   (((const ::std::map<std::basic_string<char>,int>*)o)->max_size)();
}

static  void operator_15471( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,int>*)o)->operator[])(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::map<std::basic_string<char>,int>*)o)->operator[])(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15472( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,int>*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::map<std::basic_string<char>,int>*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15473( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<std::basic_string<char>,int>*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::std::map<std::basic_string<char>,int>*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15474( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,int> >,bool>)((((::std::map<std::basic_string<char>,int>*)o)->insert)(*(const ::std::pair<const std::basic_string<char>,int>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,int>*)o)->insert)(*(const ::std::pair<const std::basic_string<char>,int>*)arg[0]);
}

static  void method_15475( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,int> >)((((::std::map<std::basic_string<char>,int>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,int> >*)arg[0],
    *(const ::std::pair<const std::basic_string<char>,int>*)arg[1]));
  else   (((::std::map<std::basic_string<char>,int>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,int> >*)arg[0],
    *(const ::std::pair<const std::basic_string<char>,int>*)arg[1]);
}

static  void method_15476( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,int>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,int> >*)arg[0]);
}

static  void method_15477( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<std::basic_string<char>,int>*)o)->erase)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,int>*)o)->erase)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15478( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,int>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,int> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,int> >*)arg[1]);
}

static  void method_15479( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,int>*)o)->swap)(*(::std::map<std::basic_string<char>,int>*)arg[0]);
}

static  void method_15480( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<std::basic_string<char>,int>*)o)->clear)();
}

static  void method_15481( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<std::basic_string<char> >)((((const ::std::map<std::basic_string<char>,int>*)o)->key_comp)());
  else   (((const ::std::map<std::basic_string<char>,int>*)o)->key_comp)();
}

static  void method_15483( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,int> >)((((::std::map<std::basic_string<char>,int>*)o)->find)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,int>*)o)->find)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15484( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,int> >)((((const ::std::map<std::basic_string<char>,int>*)o)->find)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,int>*)o)->find)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15485( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,int>*)o)->count)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,int>*)o)->count)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15486( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,int> >)((((::std::map<std::basic_string<char>,int>*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,int>*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15487( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,int> >)((((const ::std::map<std::basic_string<char>,int>*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,int>*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15488( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,int> >)((((::std::map<std::basic_string<char>,int>*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,int>*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15489( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,int> >)((((const ::std::map<std::basic_string<char>,int>*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,int>*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15490( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,int> >,std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,int> > >)((((::std::map<std::basic_string<char>,int>*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,int>*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15491( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,int> >,std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,int> > >)((((const ::std::map<std::basic_string<char>,int>*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,int>*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]);
}

static void method_newdel_1643( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x287( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<std::basic_string<char>,int> >::Generate();
  else ::Reflex::Proxy< ::std::map<std::basic_string<char>,int> >::Generate();
}

//------Dictionary for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,int,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > > -------------------------------
void __std__map_std__basic_string_char__int__db_datamem(Reflex::Class*);
void __std__map_std__basic_string_char__int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_std__basic_string_char__int__datamem_bld(&__std__map_std__basic_string_char__int__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_std__basic_string_char__int__funcmem_bld(&__std__map_std__basic_string_char__int__db_funcmem);
void __std__map_std__basic_string_char__int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<std::basic_string<char>,int>"), typeid(::std::map<std::basic_string<char>,int>), sizeof(::std::map<std::basic_string<char>,int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1104, Reflex::Literal("std::map<std::basic_string<char>,int>::key_type"))
  .AddTypedef(type_22, Reflex::Literal("std::map<std::basic_string<char>,int>::mapped_type"))
  .AddTypedef(type_889, Reflex::Literal("std::map<std::basic_string<char>,int>::value_type"))
  .AddTypedef(type_2023, Reflex::Literal("std::map<std::basic_string<char>,int>::key_compare"))
  .AddTypedef(type_1433, Reflex::Literal("std::map<std::basic_string<char>,int>::allocator_type"))
  .AddTypedef(type_889, Reflex::Literal("std::map<std::basic_string<char>,int>::_Alloc_value_type"))
  .AddTypedef(type_1433, Reflex::Literal("std::map<std::basic_string<char>,int>::_Pair_alloc_type"))
  .AddTypedef(type_1142, Reflex::Literal("std::map<std::basic_string<char>,int>::_Rep_type"))
  .AddTypedef(type_9879, Reflex::Literal("std::map<std::basic_string<char>,int>::pointer"))
  .AddTypedef(type_9881, Reflex::Literal("std::map<std::basic_string<char>,int>::const_pointer"))
  .AddTypedef(type_9883, Reflex::Literal("std::map<std::basic_string<char>,int>::reference"))
  .AddTypedef(type_9885, Reflex::Literal("std::map<std::basic_string<char>,int>::const_reference"))
  .AddTypedef(type_1278, Reflex::Literal("std::map<std::basic_string<char>,int>::iterator"))
  .AddTypedef(type_1920, Reflex::Literal("std::map<std::basic_string<char>,int>::const_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::map<std::basic_string<char>,int>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::map<std::basic_string<char>,int>::difference_type"))
  .AddTypedef(type_1857, Reflex::Literal("std::map<std::basic_string<char>,int>::reverse_iterator"))
  .AddTypedef(type_1856, Reflex::Literal("std::map<std::basic_string<char>,int>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_15454, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_15455, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20471, type_20695), Reflex::Literal("map"), constructor_15456, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21340), Reflex::Literal("map"), constructor_15457, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1643, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x287, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_std__basic_string_char__int__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_std__basic_string_char__int__funcmem_bld);
}

//------Delayed data member builder for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,int,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > > -------------------
void __std__map_std__basic_string_char__int__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1142, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_std__basic_string_char__int_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,int,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, int> > > -------------------
void __std__map_std__basic_string_char__int__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21341, type_21340), Reflex::Literal("operator="), operator_15458, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1433), Reflex::Literal("get_allocator"), method_15459, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1278), Reflex::Literal("begin"), method_15460, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1920), Reflex::Literal("begin"), method_15461, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1278), Reflex::Literal("end"), method_15462, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1920), Reflex::Literal("end"), method_15463, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_15468, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_15469, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_15470, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3569, type_4981), Reflex::Literal("operator[]"), operator_15471, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3569, type_4981), Reflex::Literal("at"), method_15472, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4404, type_4981), Reflex::Literal("at"), method_15473, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_990, type_9885), Reflex::Literal("insert"), method_15474, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1278, type_1278, type_9885), Reflex::Literal("insert"), method_15475, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1278), Reflex::Literal("erase"), method_15476, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4981), Reflex::Literal("erase"), method_15477, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1278, type_1278), Reflex::Literal("erase"), method_15478, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_21341), Reflex::Literal("swap"), method_15479, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_15480, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2023), Reflex::Literal("key_comp"), method_15481, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1278, type_4981), Reflex::Literal("find"), method_15483, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1920, type_4981), Reflex::Literal("find"), method_15484, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4981), Reflex::Literal("count"), method_15485, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1278, type_4981), Reflex::Literal("lower_bound"), method_15486, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1920, type_4981), Reflex::Literal("lower_bound"), method_15487, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1278, type_4981), Reflex::Literal("upper_bound"), method_15488, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1920, type_4981), Reflex::Literal("upper_bound"), method_15489, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_989, type_4981), Reflex::Literal("equal_range"), method_15490, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_988, type_4981), Reflex::Literal("equal_range"), method_15491, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,bool,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool> > > -------------------------------
static void destructor_15512(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<std::basic_string<char>,bool>*)o)->::std::map<std::basic_string<char>,bool>::~map)();
}
static void constructor_15513( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,bool>();
  else ::new(mem) ::std::map<std::basic_string<char>,bool>();
}

static void constructor_15514( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,bool>(*(const ::std::less<std::basic_string<char> >*)arg[0]);
  else ::new(mem) ::std::map<std::basic_string<char>,bool>(*(const ::std::less<std::basic_string<char> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,bool>(*(const ::std::less<std::basic_string<char> >*)arg[0],
      *(const ::std::allocator<std::pair<const std::basic_string<char>,bool> >*)arg[1]);
  else ::new(mem) ::std::map<std::basic_string<char>,bool>(*(const ::std::less<std::basic_string<char> >*)arg[0],
      *(const ::std::allocator<std::pair<const std::basic_string<char>,bool> >*)arg[1]);
  }
}

static void constructor_15515( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,bool>(*(const ::std::map<std::basic_string<char>,bool>*)arg[0]);
  else ::new(mem) ::std::map<std::basic_string<char>,bool>(*(const ::std::map<std::basic_string<char>,bool>*)arg[0]);
}

static  void operator_15516( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,bool>*)o)->operator=)(*(const ::std::map<std::basic_string<char>,bool>*)arg[0]);
  else   (((::std::map<std::basic_string<char>,bool>*)o)->operator=)(*(const ::std::map<std::basic_string<char>,bool>*)arg[0]);
}

static  void method_15517( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const std::basic_string<char>,bool> >)((((const ::std::map<std::basic_string<char>,bool>*)o)->get_allocator)());
  else   (((const ::std::map<std::basic_string<char>,bool>*)o)->get_allocator)();
}

static  void method_15518( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,bool> >)((((::std::map<std::basic_string<char>,bool>*)o)->begin)());
  else   (((::std::map<std::basic_string<char>,bool>*)o)->begin)();
}

static  void method_15519( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,bool> >)((((const ::std::map<std::basic_string<char>,bool>*)o)->begin)());
  else   (((const ::std::map<std::basic_string<char>,bool>*)o)->begin)();
}

static  void method_15520( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,bool> >)((((::std::map<std::basic_string<char>,bool>*)o)->end)());
  else   (((::std::map<std::basic_string<char>,bool>*)o)->end)();
}

static  void method_15521( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,bool> >)((((const ::std::map<std::basic_string<char>,bool>*)o)->end)());
  else   (((const ::std::map<std::basic_string<char>,bool>*)o)->end)();
}

static  void method_15526( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<std::basic_string<char>,bool>*)o)->empty)());
  else   (((const ::std::map<std::basic_string<char>,bool>*)o)->empty)();
}

static  void method_15527( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,bool>*)o)->size)());
  else   (((const ::std::map<std::basic_string<char>,bool>*)o)->size)();
}

static  void method_15528( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,bool>*)o)->max_size)());
  else   (((const ::std::map<std::basic_string<char>,bool>*)o)->max_size)();
}

static  void operator_15529( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,bool>*)o)->operator[])(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::map<std::basic_string<char>,bool>*)o)->operator[])(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15530( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,bool>*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::map<std::basic_string<char>,bool>*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15531( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<std::basic_string<char>,bool>*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::std::map<std::basic_string<char>,bool>*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15532( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,bool> >,bool>)((((::std::map<std::basic_string<char>,bool>*)o)->insert)(*(const ::std::pair<const std::basic_string<char>,bool>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,bool>*)o)->insert)(*(const ::std::pair<const std::basic_string<char>,bool>*)arg[0]);
}

static  void method_15533( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,bool> >)((((::std::map<std::basic_string<char>,bool>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,bool> >*)arg[0],
    *(const ::std::pair<const std::basic_string<char>,bool>*)arg[1]));
  else   (((::std::map<std::basic_string<char>,bool>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,bool> >*)arg[0],
    *(const ::std::pair<const std::basic_string<char>,bool>*)arg[1]);
}

static  void method_15534( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,bool>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,bool> >*)arg[0]);
}

static  void method_15535( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<std::basic_string<char>,bool>*)o)->erase)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,bool>*)o)->erase)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15536( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,bool>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,bool> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,bool> >*)arg[1]);
}

static  void method_15537( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,bool>*)o)->swap)(*(::std::map<std::basic_string<char>,bool>*)arg[0]);
}

static  void method_15538( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<std::basic_string<char>,bool>*)o)->clear)();
}

static  void method_15539( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<std::basic_string<char> >)((((const ::std::map<std::basic_string<char>,bool>*)o)->key_comp)());
  else   (((const ::std::map<std::basic_string<char>,bool>*)o)->key_comp)();
}

static  void method_15541( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,bool> >)((((::std::map<std::basic_string<char>,bool>*)o)->find)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,bool>*)o)->find)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15542( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,bool> >)((((const ::std::map<std::basic_string<char>,bool>*)o)->find)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,bool>*)o)->find)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15543( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,bool>*)o)->count)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,bool>*)o)->count)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15544( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,bool> >)((((::std::map<std::basic_string<char>,bool>*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,bool>*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15545( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,bool> >)((((const ::std::map<std::basic_string<char>,bool>*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,bool>*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15546( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,bool> >)((((::std::map<std::basic_string<char>,bool>*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,bool>*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15547( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,bool> >)((((const ::std::map<std::basic_string<char>,bool>*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,bool>*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15548( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,bool> >,std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,bool> > >)((((::std::map<std::basic_string<char>,bool>*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,bool>*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_15549( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,bool> >,std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,bool> > >)((((const ::std::map<std::basic_string<char>,bool>*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,bool>*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]);
}

static void method_newdel_1644( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,bool> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,bool> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,bool> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,bool> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,bool> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x289( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<std::basic_string<char>,bool> >::Generate();
  else ::Reflex::Proxy< ::std::map<std::basic_string<char>,bool> >::Generate();
}

//------Dictionary for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,bool,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool> > > -------------------------------
void __std__map_std__basic_string_char__bool__db_datamem(Reflex::Class*);
void __std__map_std__basic_string_char__bool__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_std__basic_string_char__bool__datamem_bld(&__std__map_std__basic_string_char__bool__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_std__basic_string_char__bool__funcmem_bld(&__std__map_std__basic_string_char__bool__db_funcmem);
void __std__map_std__basic_string_char__bool__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<std::basic_string<char>,bool>"), typeid(::std::map<std::basic_string<char>,bool>), sizeof(::std::map<std::basic_string<char>,bool>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1104, Reflex::Literal("std::map<std::basic_string<char>,bool>::key_type"))
  .AddTypedef(type_2083, Reflex::Literal("std::map<std::basic_string<char>,bool>::mapped_type"))
  .AddTypedef(type_890, Reflex::Literal("std::map<std::basic_string<char>,bool>::value_type"))
  .AddTypedef(type_2023, Reflex::Literal("std::map<std::basic_string<char>,bool>::key_compare"))
  .AddTypedef(type_1435, Reflex::Literal("std::map<std::basic_string<char>,bool>::allocator_type"))
  .AddTypedef(type_890, Reflex::Literal("std::map<std::basic_string<char>,bool>::_Alloc_value_type"))
  .AddTypedef(type_1435, Reflex::Literal("std::map<std::basic_string<char>,bool>::_Pair_alloc_type"))
  .AddTypedef(type_1143, Reflex::Literal("std::map<std::basic_string<char>,bool>::_Rep_type"))
  .AddTypedef(type_9984, Reflex::Literal("std::map<std::basic_string<char>,bool>::pointer"))
  .AddTypedef(type_9986, Reflex::Literal("std::map<std::basic_string<char>,bool>::const_pointer"))
  .AddTypedef(type_9988, Reflex::Literal("std::map<std::basic_string<char>,bool>::reference"))
  .AddTypedef(type_9990, Reflex::Literal("std::map<std::basic_string<char>,bool>::const_reference"))
  .AddTypedef(type_1279, Reflex::Literal("std::map<std::basic_string<char>,bool>::iterator"))
  .AddTypedef(type_1921, Reflex::Literal("std::map<std::basic_string<char>,bool>::const_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::map<std::basic_string<char>,bool>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::map<std::basic_string<char>,bool>::difference_type"))
  .AddTypedef(type_1859, Reflex::Literal("std::map<std::basic_string<char>,bool>::reverse_iterator"))
  .AddTypedef(type_1858, Reflex::Literal("std::map<std::basic_string<char>,bool>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_15512, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_15513, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20471, type_20702), Reflex::Literal("map"), constructor_15514, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21342), Reflex::Literal("map"), constructor_15515, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1644, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x289, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_std__basic_string_char__bool__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_std__basic_string_char__bool__funcmem_bld);
}

//------Delayed data member builder for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,bool,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool> > > -------------------
void __std__map_std__basic_string_char__bool__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1143, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_std__basic_string_char__bool_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,bool,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, bool> > > -------------------
void __std__map_std__basic_string_char__bool__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21343, type_21342), Reflex::Literal("operator="), operator_15516, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1435), Reflex::Literal("get_allocator"), method_15517, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1279), Reflex::Literal("begin"), method_15518, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1921), Reflex::Literal("begin"), method_15519, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1279), Reflex::Literal("end"), method_15520, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1921), Reflex::Literal("end"), method_15521, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_15526, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_15527, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_15528, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11876, type_4981), Reflex::Literal("operator[]"), operator_15529, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11876, type_4981), Reflex::Literal("at"), method_15530, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11878, type_4981), Reflex::Literal("at"), method_15531, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_993, type_9990), Reflex::Literal("insert"), method_15532, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1279, type_1279, type_9990), Reflex::Literal("insert"), method_15533, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1279), Reflex::Literal("erase"), method_15534, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4981), Reflex::Literal("erase"), method_15535, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1279, type_1279), Reflex::Literal("erase"), method_15536, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_21343), Reflex::Literal("swap"), method_15537, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_15538, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2023), Reflex::Literal("key_comp"), method_15539, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1279, type_4981), Reflex::Literal("find"), method_15541, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1921, type_4981), Reflex::Literal("find"), method_15542, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4981), Reflex::Literal("count"), method_15543, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1279, type_4981), Reflex::Literal("lower_bound"), method_15544, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1921, type_4981), Reflex::Literal("lower_bound"), method_15545, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1279, type_4981), Reflex::Literal("upper_bound"), method_15546, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1921, type_4981), Reflex::Literal("upper_bound"), method_15547, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_992, type_4981), Reflex::Literal("equal_range"), method_15548, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_991, type_4981), Reflex::Literal("equal_range"), method_15549, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<short int,unsigned int,std::less<short int>,std::allocator<std::pair<const short int, unsigned int> > > -------------------------------
static void destructor_15570(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<short,unsigned int>*)o)->::std::map<short,unsigned int>::~map)();
}
static void constructor_15571( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<short,unsigned int>();
  else ::new(mem) ::std::map<short,unsigned int>();
}

static void constructor_15572( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<short,unsigned int>(*(const ::std::less<short>*)arg[0]);
  else ::new(mem) ::std::map<short,unsigned int>(*(const ::std::less<short>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<short,unsigned int>(*(const ::std::less<short>*)arg[0],
      *(const ::std::allocator<std::pair<const short,unsigned int> >*)arg[1]);
  else ::new(mem) ::std::map<short,unsigned int>(*(const ::std::less<short>*)arg[0],
      *(const ::std::allocator<std::pair<const short,unsigned int> >*)arg[1]);
  }
}

static void constructor_15573( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<short,unsigned int>(*(const ::std::map<short,unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<short,unsigned int>(*(const ::std::map<short,unsigned int>*)arg[0]);
}

static  void operator_15574( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<short,unsigned int>*)o)->operator=)(*(const ::std::map<short,unsigned int>*)arg[0]);
  else   (((::std::map<short,unsigned int>*)o)->operator=)(*(const ::std::map<short,unsigned int>*)arg[0]);
}

static  void method_15575( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const short,unsigned int> >)((((const ::std::map<short,unsigned int>*)o)->get_allocator)());
  else   (((const ::std::map<short,unsigned int>*)o)->get_allocator)();
}

static  void method_15576( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const short,unsigned int> >)((((::std::map<short,unsigned int>*)o)->begin)());
  else   (((::std::map<short,unsigned int>*)o)->begin)();
}

static  void method_15577( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const short,unsigned int> >)((((const ::std::map<short,unsigned int>*)o)->begin)());
  else   (((const ::std::map<short,unsigned int>*)o)->begin)();
}

static  void method_15578( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const short,unsigned int> >)((((::std::map<short,unsigned int>*)o)->end)());
  else   (((::std::map<short,unsigned int>*)o)->end)();
}

static  void method_15579( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const short,unsigned int> >)((((const ::std::map<short,unsigned int>*)o)->end)());
  else   (((const ::std::map<short,unsigned int>*)o)->end)();
}

static  void method_15584( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<short,unsigned int>*)o)->empty)());
  else   (((const ::std::map<short,unsigned int>*)o)->empty)();
}

static  void method_15585( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<short,unsigned int>*)o)->size)());
  else   (((const ::std::map<short,unsigned int>*)o)->size)();
}

static  void method_15586( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<short,unsigned int>*)o)->max_size)());
  else   (((const ::std::map<short,unsigned int>*)o)->max_size)();
}

static  void operator_15587( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<short,unsigned int>*)o)->operator[])(*(const short*)arg[0]);
  else   (((::std::map<short,unsigned int>*)o)->operator[])(*(const short*)arg[0]);
}

static  void method_15588( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<short,unsigned int>*)o)->at)(*(const short*)arg[0]);
  else   (((::std::map<short,unsigned int>*)o)->at)(*(const short*)arg[0]);
}

static  void method_15589( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<short,unsigned int>*)o)->at)(*(const short*)arg[0]);
  else   (((const ::std::map<short,unsigned int>*)o)->at)(*(const short*)arg[0]);
}

static  void method_15590( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const short,unsigned int> >,bool>)((((::std::map<short,unsigned int>*)o)->insert)(*(const ::std::pair<const short,unsigned int>*)arg[0]));
  else   (((::std::map<short,unsigned int>*)o)->insert)(*(const ::std::pair<const short,unsigned int>*)arg[0]);
}

static  void method_15591( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const short,unsigned int> >)((((::std::map<short,unsigned int>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const short,unsigned int> >*)arg[0],
    *(const ::std::pair<const short,unsigned int>*)arg[1]));
  else   (((::std::map<short,unsigned int>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const short,unsigned int> >*)arg[0],
    *(const ::std::pair<const short,unsigned int>*)arg[1]);
}

static  void method_15592( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<short,unsigned int>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const short,unsigned int> >*)arg[0]);
}

static  void method_15593( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<short,unsigned int>*)o)->erase)(*(const short*)arg[0]));
  else   (((::std::map<short,unsigned int>*)o)->erase)(*(const short*)arg[0]);
}

static  void method_15594( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<short,unsigned int>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const short,unsigned int> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const short,unsigned int> >*)arg[1]);
}

static  void method_15595( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<short,unsigned int>*)o)->swap)(*(::std::map<short,unsigned int>*)arg[0]);
}

static  void method_15596( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<short,unsigned int>*)o)->clear)();
}

static  void method_15597( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<short>)((((const ::std::map<short,unsigned int>*)o)->key_comp)());
  else   (((const ::std::map<short,unsigned int>*)o)->key_comp)();
}

static  void method_15599( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const short,unsigned int> >)((((::std::map<short,unsigned int>*)o)->find)(*(const short*)arg[0]));
  else   (((::std::map<short,unsigned int>*)o)->find)(*(const short*)arg[0]);
}

static  void method_15600( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const short,unsigned int> >)((((const ::std::map<short,unsigned int>*)o)->find)(*(const short*)arg[0]));
  else   (((const ::std::map<short,unsigned int>*)o)->find)(*(const short*)arg[0]);
}

static  void method_15601( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<short,unsigned int>*)o)->count)(*(const short*)arg[0]));
  else   (((const ::std::map<short,unsigned int>*)o)->count)(*(const short*)arg[0]);
}

static  void method_15602( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const short,unsigned int> >)((((::std::map<short,unsigned int>*)o)->lower_bound)(*(const short*)arg[0]));
  else   (((::std::map<short,unsigned int>*)o)->lower_bound)(*(const short*)arg[0]);
}

static  void method_15603( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const short,unsigned int> >)((((const ::std::map<short,unsigned int>*)o)->lower_bound)(*(const short*)arg[0]));
  else   (((const ::std::map<short,unsigned int>*)o)->lower_bound)(*(const short*)arg[0]);
}

static  void method_15604( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const short,unsigned int> >)((((::std::map<short,unsigned int>*)o)->upper_bound)(*(const short*)arg[0]));
  else   (((::std::map<short,unsigned int>*)o)->upper_bound)(*(const short*)arg[0]);
}

static  void method_15605( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const short,unsigned int> >)((((const ::std::map<short,unsigned int>*)o)->upper_bound)(*(const short*)arg[0]));
  else   (((const ::std::map<short,unsigned int>*)o)->upper_bound)(*(const short*)arg[0]);
}

static  void method_15606( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const short,unsigned int> >,std::_Rb_tree_iterator<std::pair<const short,unsigned int> > >)((((::std::map<short,unsigned int>*)o)->equal_range)(*(const short*)arg[0]));
  else   (((::std::map<short,unsigned int>*)o)->equal_range)(*(const short*)arg[0]);
}

static  void method_15607( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const short,unsigned int> >,std::_Rb_tree_const_iterator<std::pair<const short,unsigned int> > >)((((const ::std::map<short,unsigned int>*)o)->equal_range)(*(const short*)arg[0]));
  else   (((const ::std::map<short,unsigned int>*)o)->equal_range)(*(const short*)arg[0]);
}

static void method_newdel_1645( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<short,unsigned int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<short,unsigned int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<short,unsigned int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<short,unsigned int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<short,unsigned int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x291( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<short,unsigned int> >::Generate();
  else ::Reflex::Proxy< ::std::map<short,unsigned int> >::Generate();
}

//------Dictionary for class map<short int,unsigned int,std::less<short int>,std::allocator<std::pair<const short int, unsigned int> > > -------------------------------
void __std__map_short_unsignedsint__db_datamem(Reflex::Class*);
void __std__map_short_unsignedsint__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_short_unsignedsint__datamem_bld(&__std__map_short_unsignedsint__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_short_unsignedsint__funcmem_bld(&__std__map_short_unsignedsint__db_funcmem);
void __std__map_short_unsignedsint__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<short,unsigned int>"), typeid(::std::map<short,unsigned int>), sizeof(::std::map<short,unsigned int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_113, Reflex::Literal("std::map<short,unsigned int>::key_type"))
  .AddTypedef(type_78, Reflex::Literal("std::map<short,unsigned int>::mapped_type"))
  .AddTypedef(type_891, Reflex::Literal("std::map<short,unsigned int>::value_type"))
  .AddTypedef(type_2022, Reflex::Literal("std::map<short,unsigned int>::key_compare"))
  .AddTypedef(type_1437, Reflex::Literal("std::map<short,unsigned int>::allocator_type"))
  .AddTypedef(type_891, Reflex::Literal("std::map<short,unsigned int>::_Alloc_value_type"))
  .AddTypedef(type_1437, Reflex::Literal("std::map<short,unsigned int>::_Pair_alloc_type"))
  .AddTypedef(type_1144, Reflex::Literal("std::map<short,unsigned int>::_Rep_type"))
  .AddTypedef(type_10089, Reflex::Literal("std::map<short,unsigned int>::pointer"))
  .AddTypedef(type_10091, Reflex::Literal("std::map<short,unsigned int>::const_pointer"))
  .AddTypedef(type_10093, Reflex::Literal("std::map<short,unsigned int>::reference"))
  .AddTypedef(type_10095, Reflex::Literal("std::map<short,unsigned int>::const_reference"))
  .AddTypedef(type_1280, Reflex::Literal("std::map<short,unsigned int>::iterator"))
  .AddTypedef(type_1922, Reflex::Literal("std::map<short,unsigned int>::const_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::map<short,unsigned int>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::map<short,unsigned int>::difference_type"))
  .AddTypedef(type_1861, Reflex::Literal("std::map<short,unsigned int>::reverse_iterator"))
  .AddTypedef(type_1860, Reflex::Literal("std::map<short,unsigned int>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_15570, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_15571, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20709, type_20710), Reflex::Literal("map"), constructor_15572, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21344), Reflex::Literal("map"), constructor_15573, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1645, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x291, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_short_unsignedsint__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_short_unsignedsint__funcmem_bld);
}

//------Delayed data member builder for class map<short int,unsigned int,std::less<short int>,std::allocator<std::pair<const short int, unsigned int> > > -------------------
void __std__map_short_unsignedsint__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1144, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_short_unsignedsint_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<short int,unsigned int,std::less<short int>,std::allocator<std::pair<const short int, unsigned int> > > -------------------
void __std__map_short_unsignedsint__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21345, type_21344), Reflex::Literal("operator="), operator_15574, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1437), Reflex::Literal("get_allocator"), method_15575, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1280), Reflex::Literal("begin"), method_15576, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1922), Reflex::Literal("begin"), method_15577, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1280), Reflex::Literal("end"), method_15578, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1922), Reflex::Literal("end"), method_15579, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_15584, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_15585, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_15586, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3505, type_4662), Reflex::Literal("operator[]"), operator_15587, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3505, type_4662), Reflex::Literal("at"), method_15588, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3951, type_4662), Reflex::Literal("at"), method_15589, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_996, type_10095), Reflex::Literal("insert"), method_15590, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1280, type_1280, type_10095), Reflex::Literal("insert"), method_15591, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1280), Reflex::Literal("erase"), method_15592, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4662), Reflex::Literal("erase"), method_15593, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1280, type_1280), Reflex::Literal("erase"), method_15594, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_21345), Reflex::Literal("swap"), method_15595, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_15596, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2022), Reflex::Literal("key_comp"), method_15597, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1280, type_4662), Reflex::Literal("find"), method_15599, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1922, type_4662), Reflex::Literal("find"), method_15600, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4662), Reflex::Literal("count"), method_15601, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1280, type_4662), Reflex::Literal("lower_bound"), method_15602, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1922, type_4662), Reflex::Literal("lower_bound"), method_15603, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1280, type_4662), Reflex::Literal("upper_bound"), method_15604, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1922, type_4662), Reflex::Literal("upper_bound"), method_15605, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_995, type_4662), Reflex::Literal("equal_range"), method_15606, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_994, type_4662), Reflex::Literal("equal_range"), method_15607, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<int,unsigned int,std::less<int>,std::allocator<std::pair<const int, unsigned int> > > -------------------------------
static void destructor_15628(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<int,unsigned int>*)o)->::std::map<int,unsigned int>::~map)();
}
static void constructor_15629( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,unsigned int>();
  else ::new(mem) ::std::map<int,unsigned int>();
}

static void constructor_15630( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,unsigned int>(*(const ::std::less<int>*)arg[0]);
  else ::new(mem) ::std::map<int,unsigned int>(*(const ::std::less<int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,unsigned int>(*(const ::std::less<int>*)arg[0],
      *(const ::std::allocator<std::pair<const int,unsigned int> >*)arg[1]);
  else ::new(mem) ::std::map<int,unsigned int>(*(const ::std::less<int>*)arg[0],
      *(const ::std::allocator<std::pair<const int,unsigned int> >*)arg[1]);
  }
}

static void constructor_15631( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,unsigned int>(*(const ::std::map<int,unsigned int>*)arg[0]);
  else ::new(mem) ::std::map<int,unsigned int>(*(const ::std::map<int,unsigned int>*)arg[0]);
}

static  void operator_15632( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,unsigned int>*)o)->operator=)(*(const ::std::map<int,unsigned int>*)arg[0]);
  else   (((::std::map<int,unsigned int>*)o)->operator=)(*(const ::std::map<int,unsigned int>*)arg[0]);
}

static  void method_15633( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const int,unsigned int> >)((((const ::std::map<int,unsigned int>*)o)->get_allocator)());
  else   (((const ::std::map<int,unsigned int>*)o)->get_allocator)();
}

static  void method_15634( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,unsigned int> >)((((::std::map<int,unsigned int>*)o)->begin)());
  else   (((::std::map<int,unsigned int>*)o)->begin)();
}

static  void method_15635( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,unsigned int> >)((((const ::std::map<int,unsigned int>*)o)->begin)());
  else   (((const ::std::map<int,unsigned int>*)o)->begin)();
}

static  void method_15636( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,unsigned int> >)((((::std::map<int,unsigned int>*)o)->end)());
  else   (((::std::map<int,unsigned int>*)o)->end)();
}

static  void method_15637( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,unsigned int> >)((((const ::std::map<int,unsigned int>*)o)->end)());
  else   (((const ::std::map<int,unsigned int>*)o)->end)();
}

static  void method_15642( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<int,unsigned int>*)o)->empty)());
  else   (((const ::std::map<int,unsigned int>*)o)->empty)();
}

static  void method_15643( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<int,unsigned int>*)o)->size)());
  else   (((const ::std::map<int,unsigned int>*)o)->size)();
}

static  void method_15644( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<int,unsigned int>*)o)->max_size)());
  else   (((const ::std::map<int,unsigned int>*)o)->max_size)();
}

static  void operator_15645( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,unsigned int>*)o)->operator[])(*(const int*)arg[0]);
  else   (((::std::map<int,unsigned int>*)o)->operator[])(*(const int*)arg[0]);
}

static  void method_15646( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,unsigned int>*)o)->at)(*(const int*)arg[0]);
  else   (((::std::map<int,unsigned int>*)o)->at)(*(const int*)arg[0]);
}

static  void method_15647( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<int,unsigned int>*)o)->at)(*(const int*)arg[0]);
  else   (((const ::std::map<int,unsigned int>*)o)->at)(*(const int*)arg[0]);
}

static  void method_15648( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const int,unsigned int> >,bool>)((((::std::map<int,unsigned int>*)o)->insert)(*(const ::std::pair<const int,unsigned int>*)arg[0]));
  else   (((::std::map<int,unsigned int>*)o)->insert)(*(const ::std::pair<const int,unsigned int>*)arg[0]);
}

static  void method_15649( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,unsigned int> >)((((::std::map<int,unsigned int>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const int,unsigned int> >*)arg[0],
    *(const ::std::pair<const int,unsigned int>*)arg[1]));
  else   (((::std::map<int,unsigned int>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const int,unsigned int> >*)arg[0],
    *(const ::std::pair<const int,unsigned int>*)arg[1]);
}

static  void method_15650( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,unsigned int>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const int,unsigned int> >*)arg[0]);
}

static  void method_15651( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<int,unsigned int>*)o)->erase)(*(const int*)arg[0]));
  else   (((::std::map<int,unsigned int>*)o)->erase)(*(const int*)arg[0]);
}

static  void method_15652( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,unsigned int>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const int,unsigned int> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const int,unsigned int> >*)arg[1]);
}

static  void method_15653( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,unsigned int>*)o)->swap)(*(::std::map<int,unsigned int>*)arg[0]);
}

static  void method_15654( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<int,unsigned int>*)o)->clear)();
}

static  void method_15655( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<int>)((((const ::std::map<int,unsigned int>*)o)->key_comp)());
  else   (((const ::std::map<int,unsigned int>*)o)->key_comp)();
}

static  void method_15657( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,unsigned int> >)((((::std::map<int,unsigned int>*)o)->find)(*(const int*)arg[0]));
  else   (((::std::map<int,unsigned int>*)o)->find)(*(const int*)arg[0]);
}

static  void method_15658( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,unsigned int> >)((((const ::std::map<int,unsigned int>*)o)->find)(*(const int*)arg[0]));
  else   (((const ::std::map<int,unsigned int>*)o)->find)(*(const int*)arg[0]);
}

static  void method_15659( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<int,unsigned int>*)o)->count)(*(const int*)arg[0]));
  else   (((const ::std::map<int,unsigned int>*)o)->count)(*(const int*)arg[0]);
}

static  void method_15660( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,unsigned int> >)((((::std::map<int,unsigned int>*)o)->lower_bound)(*(const int*)arg[0]));
  else   (((::std::map<int,unsigned int>*)o)->lower_bound)(*(const int*)arg[0]);
}

static  void method_15661( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,unsigned int> >)((((const ::std::map<int,unsigned int>*)o)->lower_bound)(*(const int*)arg[0]));
  else   (((const ::std::map<int,unsigned int>*)o)->lower_bound)(*(const int*)arg[0]);
}

static  void method_15662( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,unsigned int> >)((((::std::map<int,unsigned int>*)o)->upper_bound)(*(const int*)arg[0]));
  else   (((::std::map<int,unsigned int>*)o)->upper_bound)(*(const int*)arg[0]);
}

static  void method_15663( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,unsigned int> >)((((const ::std::map<int,unsigned int>*)o)->upper_bound)(*(const int*)arg[0]));
  else   (((const ::std::map<int,unsigned int>*)o)->upper_bound)(*(const int*)arg[0]);
}

static  void method_15664( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const int,unsigned int> >,std::_Rb_tree_iterator<std::pair<const int,unsigned int> > >)((((::std::map<int,unsigned int>*)o)->equal_range)(*(const int*)arg[0]));
  else   (((::std::map<int,unsigned int>*)o)->equal_range)(*(const int*)arg[0]);
}

static  void method_15665( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const int,unsigned int> >,std::_Rb_tree_const_iterator<std::pair<const int,unsigned int> > >)((((const ::std::map<int,unsigned int>*)o)->equal_range)(*(const int*)arg[0]));
  else   (((const ::std::map<int,unsigned int>*)o)->equal_range)(*(const int*)arg[0]);
}

static void method_newdel_1646( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<int,unsigned int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<int,unsigned int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<int,unsigned int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<int,unsigned int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<int,unsigned int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x293( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<int,unsigned int> >::Generate();
  else ::Reflex::Proxy< ::std::map<int,unsigned int> >::Generate();
}

//------Dictionary for class map<int,unsigned int,std::less<int>,std::allocator<std::pair<const int, unsigned int> > > -------------------------------
void __std__map_int_unsignedsint__db_datamem(Reflex::Class*);
void __std__map_int_unsignedsint__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_int_unsignedsint__datamem_bld(&__std__map_int_unsignedsint__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_int_unsignedsint__funcmem_bld(&__std__map_int_unsignedsint__db_funcmem);
void __std__map_int_unsignedsint__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<int,unsigned int>"), typeid(::std::map<int,unsigned int>), sizeof(::std::map<int,unsigned int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_22, Reflex::Literal("std::map<int,unsigned int>::key_type"))
  .AddTypedef(type_78, Reflex::Literal("std::map<int,unsigned int>::mapped_type"))
  .AddTypedef(type_892, Reflex::Literal("std::map<int,unsigned int>::value_type"))
  .AddTypedef(type_2024, Reflex::Literal("std::map<int,unsigned int>::key_compare"))
  .AddTypedef(type_1440, Reflex::Literal("std::map<int,unsigned int>::allocator_type"))
  .AddTypedef(type_892, Reflex::Literal("std::map<int,unsigned int>::_Alloc_value_type"))
  .AddTypedef(type_1440, Reflex::Literal("std::map<int,unsigned int>::_Pair_alloc_type"))
  .AddTypedef(type_1146, Reflex::Literal("std::map<int,unsigned int>::_Rep_type"))
  .AddTypedef(type_10299, Reflex::Literal("std::map<int,unsigned int>::pointer"))
  .AddTypedef(type_10301, Reflex::Literal("std::map<int,unsigned int>::const_pointer"))
  .AddTypedef(type_10303, Reflex::Literal("std::map<int,unsigned int>::reference"))
  .AddTypedef(type_10305, Reflex::Literal("std::map<int,unsigned int>::const_reference"))
  .AddTypedef(type_1282, Reflex::Literal("std::map<int,unsigned int>::iterator"))
  .AddTypedef(type_1924, Reflex::Literal("std::map<int,unsigned int>::const_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::map<int,unsigned int>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::map<int,unsigned int>::difference_type"))
  .AddTypedef(type_1865, Reflex::Literal("std::map<int,unsigned int>::reverse_iterator"))
  .AddTypedef(type_1864, Reflex::Literal("std::map<int,unsigned int>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_15628, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_15629, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20477, type_20724), Reflex::Literal("map"), constructor_15630, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21346), Reflex::Literal("map"), constructor_15631, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1646, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x293, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_int_unsignedsint__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_int_unsignedsint__funcmem_bld);
}

//------Delayed data member builder for class map<int,unsigned int,std::less<int>,std::allocator<std::pair<const int, unsigned int> > > -------------------
void __std__map_int_unsignedsint__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1146, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_int_unsignedsint_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<int,unsigned int,std::less<int>,std::allocator<std::pair<const int, unsigned int> > > -------------------
void __std__map_int_unsignedsint__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21347, type_21346), Reflex::Literal("operator="), operator_15632, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1440), Reflex::Literal("get_allocator"), method_15633, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1282), Reflex::Literal("begin"), method_15634, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1924), Reflex::Literal("begin"), method_15635, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1282), Reflex::Literal("end"), method_15636, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1924), Reflex::Literal("end"), method_15637, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_15642, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_15643, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_15644, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3505, type_4404), Reflex::Literal("operator[]"), operator_15645, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3505, type_4404), Reflex::Literal("at"), method_15646, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3951, type_4404), Reflex::Literal("at"), method_15647, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1002, type_10305), Reflex::Literal("insert"), method_15648, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1282, type_1282, type_10305), Reflex::Literal("insert"), method_15649, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1282), Reflex::Literal("erase"), method_15650, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4404), Reflex::Literal("erase"), method_15651, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1282, type_1282), Reflex::Literal("erase"), method_15652, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_21347), Reflex::Literal("swap"), method_15653, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_15654, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2024), Reflex::Literal("key_comp"), method_15655, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1282, type_4404), Reflex::Literal("find"), method_15657, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1924, type_4404), Reflex::Literal("find"), method_15658, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4404), Reflex::Literal("count"), method_15659, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1282, type_4404), Reflex::Literal("lower_bound"), method_15660, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1924, type_4404), Reflex::Literal("lower_bound"), method_15661, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1282, type_4404), Reflex::Literal("upper_bound"), method_15662, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1924, type_4404), Reflex::Literal("upper_bound"), method_15663, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1001, type_4404), Reflex::Literal("equal_range"), method_15664, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1000, type_4404), Reflex::Literal("equal_range"), method_15665, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<int,std::pair<long unsigned int, long unsigned int>,std::less<int>,std::allocator<std::pair<const int, std::pair<long unsigned int, long unsigned int> > > > -------------------------------
static void destructor_15686(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->::std::map<int,std::pair<unsigned long,unsigned long> >::~map)();
}
static void constructor_15687( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,std::pair<unsigned long,unsigned long> >();
  else ::new(mem) ::std::map<int,std::pair<unsigned long,unsigned long> >();
}

static void constructor_15688( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,std::pair<unsigned long,unsigned long> >(*(const ::std::less<int>*)arg[0]);
  else ::new(mem) ::std::map<int,std::pair<unsigned long,unsigned long> >(*(const ::std::less<int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,std::pair<unsigned long,unsigned long> >(*(const ::std::less<int>*)arg[0],
      *(const ::std::allocator<std::pair<const int,std::pair<unsigned long,unsigned long> > >*)arg[1]);
  else ::new(mem) ::std::map<int,std::pair<unsigned long,unsigned long> >(*(const ::std::less<int>*)arg[0],
      *(const ::std::allocator<std::pair<const int,std::pair<unsigned long,unsigned long> > >*)arg[1]);
  }
}

static void constructor_15689( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,std::pair<unsigned long,unsigned long> >(*(const ::std::map<int,std::pair<unsigned long,unsigned long> >*)arg[0]);
  else ::new(mem) ::std::map<int,std::pair<unsigned long,unsigned long> >(*(const ::std::map<int,std::pair<unsigned long,unsigned long> >*)arg[0]);
}

static  void operator_15690( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->operator=)(*(const ::std::map<int,std::pair<unsigned long,unsigned long> >*)arg[0]);
  else   (((::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->operator=)(*(const ::std::map<int,std::pair<unsigned long,unsigned long> >*)arg[0]);
}

static  void method_15691( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const int,std::pair<unsigned long,unsigned long> > >)((((const ::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->get_allocator)());
  else   (((const ::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->get_allocator)();
}

static  void method_15692( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,std::pair<unsigned long,unsigned long> > >)((((::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->begin)());
  else   (((::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->begin)();
}

static  void method_15693( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,std::pair<unsigned long,unsigned long> > >)((((const ::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->begin)());
  else   (((const ::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->begin)();
}

static  void method_15694( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,std::pair<unsigned long,unsigned long> > >)((((::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->end)());
  else   (((::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->end)();
}

static  void method_15695( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,std::pair<unsigned long,unsigned long> > >)((((const ::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->end)());
  else   (((const ::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->end)();
}

static  void method_15700( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->empty)());
  else   (((const ::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->empty)();
}

static  void method_15701( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->size)());
  else   (((const ::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->size)();
}

static  void method_15702( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->max_size)());
  else   (((const ::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->max_size)();
}

static  void operator_15703( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->operator[])(*(const int*)arg[0]);
  else   (((::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->operator[])(*(const int*)arg[0]);
}

static  void method_15704( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->at)(*(const int*)arg[0]);
  else   (((::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->at)(*(const int*)arg[0]);
}

static  void method_15705( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->at)(*(const int*)arg[0]);
  else   (((const ::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->at)(*(const int*)arg[0]);
}

static  void method_15706( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const int,std::pair<unsigned long,unsigned long> > >,bool>)((((::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->insert)(*(const ::std::pair<const int,std::pair<unsigned long,unsigned long> >*)arg[0]));
  else   (((::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->insert)(*(const ::std::pair<const int,std::pair<unsigned long,unsigned long> >*)arg[0]);
}

static  void method_15707( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,std::pair<unsigned long,unsigned long> > >)((((::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const int,std::pair<unsigned long,unsigned long> > >*)arg[0],
    *(const ::std::pair<const int,std::pair<unsigned long,unsigned long> >*)arg[1]));
  else   (((::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const int,std::pair<unsigned long,unsigned long> > >*)arg[0],
    *(const ::std::pair<const int,std::pair<unsigned long,unsigned long> >*)arg[1]);
}

static  void method_15708( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const int,std::pair<unsigned long,unsigned long> > >*)arg[0]);
}

static  void method_15709( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->erase)(*(const int*)arg[0]));
  else   (((::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->erase)(*(const int*)arg[0]);
}

static  void method_15710( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const int,std::pair<unsigned long,unsigned long> > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const int,std::pair<unsigned long,unsigned long> > >*)arg[1]);
}

static  void method_15711( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->swap)(*(::std::map<int,std::pair<unsigned long,unsigned long> >*)arg[0]);
}

static  void method_15712( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->clear)();
}

static  void method_15713( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<int>)((((const ::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->key_comp)());
  else   (((const ::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->key_comp)();
}

static  void method_15715( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,std::pair<unsigned long,unsigned long> > >)((((::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->find)(*(const int*)arg[0]));
  else   (((::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->find)(*(const int*)arg[0]);
}

static  void method_15716( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,std::pair<unsigned long,unsigned long> > >)((((const ::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->find)(*(const int*)arg[0]));
  else   (((const ::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->find)(*(const int*)arg[0]);
}

static  void method_15717( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->count)(*(const int*)arg[0]));
  else   (((const ::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->count)(*(const int*)arg[0]);
}

static  void method_15718( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,std::pair<unsigned long,unsigned long> > >)((((::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->lower_bound)(*(const int*)arg[0]));
  else   (((::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->lower_bound)(*(const int*)arg[0]);
}

static  void method_15719( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,std::pair<unsigned long,unsigned long> > >)((((const ::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->lower_bound)(*(const int*)arg[0]));
  else   (((const ::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->lower_bound)(*(const int*)arg[0]);
}

static  void method_15720( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,std::pair<unsigned long,unsigned long> > >)((((::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->upper_bound)(*(const int*)arg[0]));
  else   (((::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->upper_bound)(*(const int*)arg[0]);
}

static  void method_15721( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,std::pair<unsigned long,unsigned long> > >)((((const ::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->upper_bound)(*(const int*)arg[0]));
  else   (((const ::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->upper_bound)(*(const int*)arg[0]);
}

static  void method_15722( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const int,std::pair<unsigned long,unsigned long> > >,std::_Rb_tree_iterator<std::pair<const int,std::pair<unsigned long,unsigned long> > > >)((((::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->equal_range)(*(const int*)arg[0]));
  else   (((::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->equal_range)(*(const int*)arg[0]);
}

static  void method_15723( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const int,std::pair<unsigned long,unsigned long> > >,std::_Rb_tree_const_iterator<std::pair<const int,std::pair<unsigned long,unsigned long> > > >)((((const ::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->equal_range)(*(const int*)arg[0]));
  else   (((const ::std::map<int,std::pair<unsigned long,unsigned long> >*)o)->equal_range)(*(const int*)arg[0]);
}

static void method_newdel_1647( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<int,std::pair<unsigned long,unsigned long> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<int,std::pair<unsigned long,unsigned long> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<int,std::pair<unsigned long,unsigned long> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<int,std::pair<unsigned long,unsigned long> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<int,std::pair<unsigned long,unsigned long> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x295( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<int,std::pair<unsigned long,unsigned long> > >::Generate();
  else ::Reflex::Proxy< ::std::map<int,std::pair<unsigned long,unsigned long> > >::Generate();
}

//------Dictionary for class map<int,std::pair<long unsigned int, long unsigned int>,std::less<int>,std::allocator<std::pair<const int, std::pair<long unsigned int, long unsigned int> > > > -------------------------------
void __std__map_int_std__pair_unsignedslong_unsignedslong_s__db_datamem(Reflex::Class*);
void __std__map_int_std__pair_unsignedslong_unsignedslong_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_int_std__pair_unsignedslong_unsignedslong_s__datamem_bld(&__std__map_int_std__pair_unsignedslong_unsignedslong_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_int_std__pair_unsignedslong_unsignedslong_s__funcmem_bld(&__std__map_int_std__pair_unsignedslong_unsignedslong_s__db_funcmem);
void __std__map_int_std__pair_unsignedslong_unsignedslong_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<int,std::pair<unsigned long,unsigned long> >"), typeid(::std::map<int,std::pair<unsigned long,unsigned long> >), sizeof(::std::map<int,std::pair<unsigned long,unsigned long> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_22, Reflex::Literal("std::map<int,std::pair<unsigned long,unsigned long> >::key_type"))
  .AddTypedef(type_840, Reflex::Literal("std::map<int,std::pair<unsigned long,unsigned long> >::mapped_type"))
  .AddTypedef(type_893, Reflex::Literal("std::map<int,std::pair<unsigned long,unsigned long> >::value_type"))
  .AddTypedef(type_2024, Reflex::Literal("std::map<int,std::pair<unsigned long,unsigned long> >::key_compare"))
  .AddTypedef(type_1442, Reflex::Literal("std::map<int,std::pair<unsigned long,unsigned long> >::allocator_type"))
  .AddTypedef(type_893, Reflex::Literal("std::map<int,std::pair<unsigned long,unsigned long> >::_Alloc_value_type"))
  .AddTypedef(type_1442, Reflex::Literal("std::map<int,std::pair<unsigned long,unsigned long> >::_Pair_alloc_type"))
  .AddTypedef(type_1147, Reflex::Literal("std::map<int,std::pair<unsigned long,unsigned long> >::_Rep_type"))
  .AddTypedef(type_10404, Reflex::Literal("std::map<int,std::pair<unsigned long,unsigned long> >::pointer"))
  .AddTypedef(type_10406, Reflex::Literal("std::map<int,std::pair<unsigned long,unsigned long> >::const_pointer"))
  .AddTypedef(type_10408, Reflex::Literal("std::map<int,std::pair<unsigned long,unsigned long> >::reference"))
  .AddTypedef(type_10410, Reflex::Literal("std::map<int,std::pair<unsigned long,unsigned long> >::const_reference"))
  .AddTypedef(type_1283, Reflex::Literal("std::map<int,std::pair<unsigned long,unsigned long> >::iterator"))
  .AddTypedef(type_1925, Reflex::Literal("std::map<int,std::pair<unsigned long,unsigned long> >::const_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::map<int,std::pair<unsigned long,unsigned long> >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::map<int,std::pair<unsigned long,unsigned long> >::difference_type"))
  .AddTypedef(type_1867, Reflex::Literal("std::map<int,std::pair<unsigned long,unsigned long> >::reverse_iterator"))
  .AddTypedef(type_1866, Reflex::Literal("std::map<int,std::pair<unsigned long,unsigned long> >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_15686, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_15687, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20477, type_20731), Reflex::Literal("map"), constructor_15688, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21348), Reflex::Literal("map"), constructor_15689, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1647, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x295, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_int_std__pair_unsignedslong_unsignedslong_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_int_std__pair_unsignedslong_unsignedslong_s__funcmem_bld);
}

//------Delayed data member builder for class map<int,std::pair<long unsigned int, long unsigned int>,std::less<int>,std::allocator<std::pair<const int, std::pair<long unsigned int, long unsigned int> > > > -------------------
void __std__map_int_std__pair_unsignedslong_unsignedslong_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1147, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_int_std__pair_unsignedslong_unsignedslong_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<int,std::pair<long unsigned int, long unsigned int>,std::less<int>,std::allocator<std::pair<const int, std::pair<long unsigned int, long unsigned int> > > > -------------------
void __std__map_int_std__pair_unsignedslong_unsignedslong_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21349, type_21348), Reflex::Literal("operator="), operator_15690, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1442), Reflex::Literal("get_allocator"), method_15691, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1283), Reflex::Literal("begin"), method_15692, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1925), Reflex::Literal("begin"), method_15693, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1283), Reflex::Literal("end"), method_15694, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1925), Reflex::Literal("end"), method_15695, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_15700, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_15701, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_15702, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20183, type_4404), Reflex::Literal("operator[]"), operator_15703, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20183, type_4404), Reflex::Literal("at"), method_15704, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20184, type_4404), Reflex::Literal("at"), method_15705, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1005, type_10410), Reflex::Literal("insert"), method_15706, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1283, type_1283, type_10410), Reflex::Literal("insert"), method_15707, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1283), Reflex::Literal("erase"), method_15708, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4404), Reflex::Literal("erase"), method_15709, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1283, type_1283), Reflex::Literal("erase"), method_15710, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_21349), Reflex::Literal("swap"), method_15711, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_15712, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2024), Reflex::Literal("key_comp"), method_15713, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1283, type_4404), Reflex::Literal("find"), method_15715, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1925, type_4404), Reflex::Literal("find"), method_15716, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4404), Reflex::Literal("count"), method_15717, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1283, type_4404), Reflex::Literal("lower_bound"), method_15718, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1925, type_4404), Reflex::Literal("lower_bound"), method_15719, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1283, type_4404), Reflex::Literal("upper_bound"), method_15720, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1925, type_4404), Reflex::Literal("upper_bound"), method_15721, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1004, type_4404), Reflex::Literal("equal_range"), method_15722, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1003, type_4404), Reflex::Literal("equal_range"), method_15723, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<int,std::pair<unsigned int, unsigned int>,std::less<int>,std::allocator<std::pair<const int, std::pair<unsigned int, unsigned int> > > > -------------------------------
static void destructor_15744(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->::std::map<int,std::pair<unsigned int,unsigned int> >::~map)();
}
static void constructor_15745( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,std::pair<unsigned int,unsigned int> >();
  else ::new(mem) ::std::map<int,std::pair<unsigned int,unsigned int> >();
}

static void constructor_15746( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,std::pair<unsigned int,unsigned int> >(*(const ::std::less<int>*)arg[0]);
  else ::new(mem) ::std::map<int,std::pair<unsigned int,unsigned int> >(*(const ::std::less<int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,std::pair<unsigned int,unsigned int> >(*(const ::std::less<int>*)arg[0],
      *(const ::std::allocator<std::pair<const int,std::pair<unsigned int,unsigned int> > >*)arg[1]);
  else ::new(mem) ::std::map<int,std::pair<unsigned int,unsigned int> >(*(const ::std::less<int>*)arg[0],
      *(const ::std::allocator<std::pair<const int,std::pair<unsigned int,unsigned int> > >*)arg[1]);
  }
}

static void constructor_15747( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,std::pair<unsigned int,unsigned int> >(*(const ::std::map<int,std::pair<unsigned int,unsigned int> >*)arg[0]);
  else ::new(mem) ::std::map<int,std::pair<unsigned int,unsigned int> >(*(const ::std::map<int,std::pair<unsigned int,unsigned int> >*)arg[0]);
}

static  void operator_15748( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->operator=)(*(const ::std::map<int,std::pair<unsigned int,unsigned int> >*)arg[0]);
  else   (((::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->operator=)(*(const ::std::map<int,std::pair<unsigned int,unsigned int> >*)arg[0]);
}

static  void method_15749( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const int,std::pair<unsigned int,unsigned int> > >)((((const ::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->get_allocator)());
  else   (((const ::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->get_allocator)();
}

static  void method_15750( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,std::pair<unsigned int,unsigned int> > >)((((::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->begin)());
  else   (((::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->begin)();
}

static  void method_15751( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,std::pair<unsigned int,unsigned int> > >)((((const ::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->begin)());
  else   (((const ::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->begin)();
}

static  void method_15752( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,std::pair<unsigned int,unsigned int> > >)((((::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->end)());
  else   (((::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->end)();
}

static  void method_15753( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,std::pair<unsigned int,unsigned int> > >)((((const ::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->end)());
  else   (((const ::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->end)();
}

static  void method_15758( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->empty)());
  else   (((const ::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->empty)();
}

static  void method_15759( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->size)());
  else   (((const ::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->size)();
}

static  void method_15760( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->max_size)());
  else   (((const ::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->max_size)();
}

static  void operator_15761( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->operator[])(*(const int*)arg[0]);
  else   (((::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->operator[])(*(const int*)arg[0]);
}

static  void method_15762( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->at)(*(const int*)arg[0]);
  else   (((::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->at)(*(const int*)arg[0]);
}

static  void method_15763( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->at)(*(const int*)arg[0]);
  else   (((const ::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->at)(*(const int*)arg[0]);
}

static  void method_15764( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const int,std::pair<unsigned int,unsigned int> > >,bool>)((((::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->insert)(*(const ::std::pair<const int,std::pair<unsigned int,unsigned int> >*)arg[0]));
  else   (((::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->insert)(*(const ::std::pair<const int,std::pair<unsigned int,unsigned int> >*)arg[0]);
}

static  void method_15765( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,std::pair<unsigned int,unsigned int> > >)((((::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const int,std::pair<unsigned int,unsigned int> > >*)arg[0],
    *(const ::std::pair<const int,std::pair<unsigned int,unsigned int> >*)arg[1]));
  else   (((::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const int,std::pair<unsigned int,unsigned int> > >*)arg[0],
    *(const ::std::pair<const int,std::pair<unsigned int,unsigned int> >*)arg[1]);
}

static  void method_15766( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const int,std::pair<unsigned int,unsigned int> > >*)arg[0]);
}

static  void method_15767( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->erase)(*(const int*)arg[0]));
  else   (((::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->erase)(*(const int*)arg[0]);
}

static  void method_15768( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const int,std::pair<unsigned int,unsigned int> > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const int,std::pair<unsigned int,unsigned int> > >*)arg[1]);
}

static  void method_15769( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->swap)(*(::std::map<int,std::pair<unsigned int,unsigned int> >*)arg[0]);
}

static  void method_15770( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->clear)();
}

static  void method_15771( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<int>)((((const ::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->key_comp)());
  else   (((const ::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->key_comp)();
}

static  void method_15773( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,std::pair<unsigned int,unsigned int> > >)((((::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->find)(*(const int*)arg[0]));
  else   (((::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->find)(*(const int*)arg[0]);
}

static  void method_15774( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,std::pair<unsigned int,unsigned int> > >)((((const ::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->find)(*(const int*)arg[0]));
  else   (((const ::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->find)(*(const int*)arg[0]);
}

static  void method_15775( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->count)(*(const int*)arg[0]));
  else   (((const ::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->count)(*(const int*)arg[0]);
}

static  void method_15776( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,std::pair<unsigned int,unsigned int> > >)((((::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->lower_bound)(*(const int*)arg[0]));
  else   (((::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->lower_bound)(*(const int*)arg[0]);
}

static  void method_15777( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,std::pair<unsigned int,unsigned int> > >)((((const ::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->lower_bound)(*(const int*)arg[0]));
  else   (((const ::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->lower_bound)(*(const int*)arg[0]);
}

static  void method_15778( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,std::pair<unsigned int,unsigned int> > >)((((::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->upper_bound)(*(const int*)arg[0]));
  else   (((::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->upper_bound)(*(const int*)arg[0]);
}

static  void method_15779( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,std::pair<unsigned int,unsigned int> > >)((((const ::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->upper_bound)(*(const int*)arg[0]));
  else   (((const ::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->upper_bound)(*(const int*)arg[0]);
}

static  void method_15780( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const int,std::pair<unsigned int,unsigned int> > >,std::_Rb_tree_iterator<std::pair<const int,std::pair<unsigned int,unsigned int> > > >)((((::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->equal_range)(*(const int*)arg[0]));
  else   (((::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->equal_range)(*(const int*)arg[0]);
}

static  void method_15781( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const int,std::pair<unsigned int,unsigned int> > >,std::_Rb_tree_const_iterator<std::pair<const int,std::pair<unsigned int,unsigned int> > > >)((((const ::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->equal_range)(*(const int*)arg[0]));
  else   (((const ::std::map<int,std::pair<unsigned int,unsigned int> >*)o)->equal_range)(*(const int*)arg[0]);
}

static void method_newdel_1648( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<int,std::pair<unsigned int,unsigned int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<int,std::pair<unsigned int,unsigned int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<int,std::pair<unsigned int,unsigned int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<int,std::pair<unsigned int,unsigned int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<int,std::pair<unsigned int,unsigned int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x297( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<int,std::pair<unsigned int,unsigned int> > >::Generate();
  else ::Reflex::Proxy< ::std::map<int,std::pair<unsigned int,unsigned int> > >::Generate();
}

//------Dictionary for class map<int,std::pair<unsigned int, unsigned int>,std::less<int>,std::allocator<std::pair<const int, std::pair<unsigned int, unsigned int> > > > -------------------------------
void __std__map_int_std__pair_unsignedsint_unsignedsint_s__db_datamem(Reflex::Class*);
void __std__map_int_std__pair_unsignedsint_unsignedsint_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_int_std__pair_unsignedsint_unsignedsint_s__datamem_bld(&__std__map_int_std__pair_unsignedsint_unsignedsint_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_int_std__pair_unsignedsint_unsignedsint_s__funcmem_bld(&__std__map_int_std__pair_unsignedsint_unsignedsint_s__db_funcmem);
void __std__map_int_std__pair_unsignedsint_unsignedsint_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<int,std::pair<unsigned int,unsigned int> >"), typeid(::std::map<int,std::pair<unsigned int,unsigned int> >), sizeof(::std::map<int,std::pair<unsigned int,unsigned int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_22, Reflex::Literal("std::map<int,std::pair<unsigned int,unsigned int> >::key_type"))
  .AddTypedef(type_814, Reflex::Literal("std::map<int,std::pair<unsigned int,unsigned int> >::mapped_type"))
  .AddTypedef(type_894, Reflex::Literal("std::map<int,std::pair<unsigned int,unsigned int> >::value_type"))
  .AddTypedef(type_2024, Reflex::Literal("std::map<int,std::pair<unsigned int,unsigned int> >::key_compare"))
  .AddTypedef(type_1444, Reflex::Literal("std::map<int,std::pair<unsigned int,unsigned int> >::allocator_type"))
  .AddTypedef(type_894, Reflex::Literal("std::map<int,std::pair<unsigned int,unsigned int> >::_Alloc_value_type"))
  .AddTypedef(type_1444, Reflex::Literal("std::map<int,std::pair<unsigned int,unsigned int> >::_Pair_alloc_type"))
  .AddTypedef(type_1148, Reflex::Literal("std::map<int,std::pair<unsigned int,unsigned int> >::_Rep_type"))
  .AddTypedef(type_10509, Reflex::Literal("std::map<int,std::pair<unsigned int,unsigned int> >::pointer"))
  .AddTypedef(type_10511, Reflex::Literal("std::map<int,std::pair<unsigned int,unsigned int> >::const_pointer"))
  .AddTypedef(type_10513, Reflex::Literal("std::map<int,std::pair<unsigned int,unsigned int> >::reference"))
  .AddTypedef(type_10515, Reflex::Literal("std::map<int,std::pair<unsigned int,unsigned int> >::const_reference"))
  .AddTypedef(type_1284, Reflex::Literal("std::map<int,std::pair<unsigned int,unsigned int> >::iterator"))
  .AddTypedef(type_1926, Reflex::Literal("std::map<int,std::pair<unsigned int,unsigned int> >::const_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::map<int,std::pair<unsigned int,unsigned int> >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::map<int,std::pair<unsigned int,unsigned int> >::difference_type"))
  .AddTypedef(type_1869, Reflex::Literal("std::map<int,std::pair<unsigned int,unsigned int> >::reverse_iterator"))
  .AddTypedef(type_1868, Reflex::Literal("std::map<int,std::pair<unsigned int,unsigned int> >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_15744, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_15745, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20477, type_20738), Reflex::Literal("map"), constructor_15746, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21350), Reflex::Literal("map"), constructor_15747, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1648, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x297, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_int_std__pair_unsignedsint_unsignedsint_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_int_std__pair_unsignedsint_unsignedsint_s__funcmem_bld);
}

//------Delayed data member builder for class map<int,std::pair<unsigned int, unsigned int>,std::less<int>,std::allocator<std::pair<const int, std::pair<unsigned int, unsigned int> > > > -------------------
void __std__map_int_std__pair_unsignedsint_unsignedsint_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1148, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_int_std__pair_unsignedsint_unsignedsint_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<int,std::pair<unsigned int, unsigned int>,std::less<int>,std::allocator<std::pair<const int, std::pair<unsigned int, unsigned int> > > > -------------------
void __std__map_int_std__pair_unsignedsint_unsignedsint_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21351, type_21350), Reflex::Literal("operator="), operator_15748, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1444), Reflex::Literal("get_allocator"), method_15749, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1284), Reflex::Literal("begin"), method_15750, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1926), Reflex::Literal("begin"), method_15751, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1284), Reflex::Literal("end"), method_15752, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1926), Reflex::Literal("end"), method_15753, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_15758, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_15759, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_15760, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5109, type_4404), Reflex::Literal("operator[]"), operator_15761, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5109, type_4404), Reflex::Literal("at"), method_15762, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5111, type_4404), Reflex::Literal("at"), method_15763, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1008, type_10515), Reflex::Literal("insert"), method_15764, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1284, type_1284, type_10515), Reflex::Literal("insert"), method_15765, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1284), Reflex::Literal("erase"), method_15766, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4404), Reflex::Literal("erase"), method_15767, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1284, type_1284), Reflex::Literal("erase"), method_15768, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_21351), Reflex::Literal("swap"), method_15769, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_15770, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2024), Reflex::Literal("key_comp"), method_15771, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1284, type_4404), Reflex::Literal("find"), method_15773, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1926, type_4404), Reflex::Literal("find"), method_15774, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4404), Reflex::Literal("count"), method_15775, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1284, type_4404), Reflex::Literal("lower_bound"), method_15776, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1926, type_4404), Reflex::Literal("lower_bound"), method_15777, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1284, type_4404), Reflex::Literal("upper_bound"), method_15778, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1926, type_4404), Reflex::Literal("upper_bound"), method_15779, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1007, type_4404), Reflex::Literal("equal_range"), method_15780, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1006, type_4404), Reflex::Literal("equal_range"), method_15781, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<int,std::pair<double, double>,std::less<int>,std::allocator<std::pair<const int, std::pair<double, double> > > > -------------------------------
static void destructor_15802(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<int,std::pair<double,double> >*)o)->::std::map<int,std::pair<double,double> >::~map)();
}
static void constructor_15803( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,std::pair<double,double> >();
  else ::new(mem) ::std::map<int,std::pair<double,double> >();
}

static void constructor_15804( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,std::pair<double,double> >(*(const ::std::less<int>*)arg[0]);
  else ::new(mem) ::std::map<int,std::pair<double,double> >(*(const ::std::less<int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,std::pair<double,double> >(*(const ::std::less<int>*)arg[0],
      *(const ::std::allocator<std::pair<const int,std::pair<double,double> > >*)arg[1]);
  else ::new(mem) ::std::map<int,std::pair<double,double> >(*(const ::std::less<int>*)arg[0],
      *(const ::std::allocator<std::pair<const int,std::pair<double,double> > >*)arg[1]);
  }
}

static void constructor_15805( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,std::pair<double,double> >(*(const ::std::map<int,std::pair<double,double> >*)arg[0]);
  else ::new(mem) ::std::map<int,std::pair<double,double> >(*(const ::std::map<int,std::pair<double,double> >*)arg[0]);
}

static  void operator_15806( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,std::pair<double,double> >*)o)->operator=)(*(const ::std::map<int,std::pair<double,double> >*)arg[0]);
  else   (((::std::map<int,std::pair<double,double> >*)o)->operator=)(*(const ::std::map<int,std::pair<double,double> >*)arg[0]);
}

static  void method_15807( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const int,std::pair<double,double> > >)((((const ::std::map<int,std::pair<double,double> >*)o)->get_allocator)());
  else   (((const ::std::map<int,std::pair<double,double> >*)o)->get_allocator)();
}

static  void method_15808( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,std::pair<double,double> > >)((((::std::map<int,std::pair<double,double> >*)o)->begin)());
  else   (((::std::map<int,std::pair<double,double> >*)o)->begin)();
}

static  void method_15809( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,std::pair<double,double> > >)((((const ::std::map<int,std::pair<double,double> >*)o)->begin)());
  else   (((const ::std::map<int,std::pair<double,double> >*)o)->begin)();
}

static  void method_15810( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,std::pair<double,double> > >)((((::std::map<int,std::pair<double,double> >*)o)->end)());
  else   (((::std::map<int,std::pair<double,double> >*)o)->end)();
}

static  void method_15811( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,std::pair<double,double> > >)((((const ::std::map<int,std::pair<double,double> >*)o)->end)());
  else   (((const ::std::map<int,std::pair<double,double> >*)o)->end)();
}

static  void method_15816( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<int,std::pair<double,double> >*)o)->empty)());
  else   (((const ::std::map<int,std::pair<double,double> >*)o)->empty)();
}

static  void method_15817( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<int,std::pair<double,double> >*)o)->size)());
  else   (((const ::std::map<int,std::pair<double,double> >*)o)->size)();
}

static  void method_15818( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<int,std::pair<double,double> >*)o)->max_size)());
  else   (((const ::std::map<int,std::pair<double,double> >*)o)->max_size)();
}

static  void operator_15819( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,std::pair<double,double> >*)o)->operator[])(*(const int*)arg[0]);
  else   (((::std::map<int,std::pair<double,double> >*)o)->operator[])(*(const int*)arg[0]);
}

static  void method_15820( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,std::pair<double,double> >*)o)->at)(*(const int*)arg[0]);
  else   (((::std::map<int,std::pair<double,double> >*)o)->at)(*(const int*)arg[0]);
}

static  void method_15821( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<int,std::pair<double,double> >*)o)->at)(*(const int*)arg[0]);
  else   (((const ::std::map<int,std::pair<double,double> >*)o)->at)(*(const int*)arg[0]);
}

static  void method_15822( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const int,std::pair<double,double> > >,bool>)((((::std::map<int,std::pair<double,double> >*)o)->insert)(*(const ::std::pair<const int,std::pair<double,double> >*)arg[0]));
  else   (((::std::map<int,std::pair<double,double> >*)o)->insert)(*(const ::std::pair<const int,std::pair<double,double> >*)arg[0]);
}

static  void method_15823( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,std::pair<double,double> > >)((((::std::map<int,std::pair<double,double> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const int,std::pair<double,double> > >*)arg[0],
    *(const ::std::pair<const int,std::pair<double,double> >*)arg[1]));
  else   (((::std::map<int,std::pair<double,double> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const int,std::pair<double,double> > >*)arg[0],
    *(const ::std::pair<const int,std::pair<double,double> >*)arg[1]);
}

static  void method_15824( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,std::pair<double,double> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const int,std::pair<double,double> > >*)arg[0]);
}

static  void method_15825( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<int,std::pair<double,double> >*)o)->erase)(*(const int*)arg[0]));
  else   (((::std::map<int,std::pair<double,double> >*)o)->erase)(*(const int*)arg[0]);
}

static  void method_15826( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,std::pair<double,double> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const int,std::pair<double,double> > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const int,std::pair<double,double> > >*)arg[1]);
}

static  void method_15827( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,std::pair<double,double> >*)o)->swap)(*(::std::map<int,std::pair<double,double> >*)arg[0]);
}

static  void method_15828( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<int,std::pair<double,double> >*)o)->clear)();
}

static  void method_15829( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<int>)((((const ::std::map<int,std::pair<double,double> >*)o)->key_comp)());
  else   (((const ::std::map<int,std::pair<double,double> >*)o)->key_comp)();
}

static  void method_15831( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,std::pair<double,double> > >)((((::std::map<int,std::pair<double,double> >*)o)->find)(*(const int*)arg[0]));
  else   (((::std::map<int,std::pair<double,double> >*)o)->find)(*(const int*)arg[0]);
}

static  void method_15832( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,std::pair<double,double> > >)((((const ::std::map<int,std::pair<double,double> >*)o)->find)(*(const int*)arg[0]));
  else   (((const ::std::map<int,std::pair<double,double> >*)o)->find)(*(const int*)arg[0]);
}

static  void method_15833( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<int,std::pair<double,double> >*)o)->count)(*(const int*)arg[0]));
  else   (((const ::std::map<int,std::pair<double,double> >*)o)->count)(*(const int*)arg[0]);
}

static  void method_15834( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,std::pair<double,double> > >)((((::std::map<int,std::pair<double,double> >*)o)->lower_bound)(*(const int*)arg[0]));
  else   (((::std::map<int,std::pair<double,double> >*)o)->lower_bound)(*(const int*)arg[0]);
}

static  void method_15835( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,std::pair<double,double> > >)((((const ::std::map<int,std::pair<double,double> >*)o)->lower_bound)(*(const int*)arg[0]));
  else   (((const ::std::map<int,std::pair<double,double> >*)o)->lower_bound)(*(const int*)arg[0]);
}

static  void method_15836( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,std::pair<double,double> > >)((((::std::map<int,std::pair<double,double> >*)o)->upper_bound)(*(const int*)arg[0]));
  else   (((::std::map<int,std::pair<double,double> >*)o)->upper_bound)(*(const int*)arg[0]);
}

static  void method_15837( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,std::pair<double,double> > >)((((const ::std::map<int,std::pair<double,double> >*)o)->upper_bound)(*(const int*)arg[0]));
  else   (((const ::std::map<int,std::pair<double,double> >*)o)->upper_bound)(*(const int*)arg[0]);
}

static  void method_15838( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const int,std::pair<double,double> > >,std::_Rb_tree_iterator<std::pair<const int,std::pair<double,double> > > >)((((::std::map<int,std::pair<double,double> >*)o)->equal_range)(*(const int*)arg[0]));
  else   (((::std::map<int,std::pair<double,double> >*)o)->equal_range)(*(const int*)arg[0]);
}

static  void method_15839( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const int,std::pair<double,double> > >,std::_Rb_tree_const_iterator<std::pair<const int,std::pair<double,double> > > >)((((const ::std::map<int,std::pair<double,double> >*)o)->equal_range)(*(const int*)arg[0]));
  else   (((const ::std::map<int,std::pair<double,double> >*)o)->equal_range)(*(const int*)arg[0]);
}

static void method_newdel_1649( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<int,std::pair<double,double> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<int,std::pair<double,double> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<int,std::pair<double,double> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<int,std::pair<double,double> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<int,std::pair<double,double> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x299( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<int,std::pair<double,double> > >::Generate();
  else ::Reflex::Proxy< ::std::map<int,std::pair<double,double> > >::Generate();
}

//------Dictionary for class map<int,std::pair<double, double>,std::less<int>,std::allocator<std::pair<const int, std::pair<double, double> > > > -------------------------------
void __std__map_int_std__pair_double_double_s__db_datamem(Reflex::Class*);
void __std__map_int_std__pair_double_double_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_int_std__pair_double_double_s__datamem_bld(&__std__map_int_std__pair_double_double_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_int_std__pair_double_double_s__funcmem_bld(&__std__map_int_std__pair_double_double_s__db_funcmem);
void __std__map_int_std__pair_double_double_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<int,std::pair<double,double> >"), typeid(::std::map<int,std::pair<double,double> >), sizeof(::std::map<int,std::pair<double,double> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_22, Reflex::Literal("std::map<int,std::pair<double,double> >::key_type"))
  .AddTypedef(type_827, Reflex::Literal("std::map<int,std::pair<double,double> >::mapped_type"))
  .AddTypedef(type_895, Reflex::Literal("std::map<int,std::pair<double,double> >::value_type"))
  .AddTypedef(type_2024, Reflex::Literal("std::map<int,std::pair<double,double> >::key_compare"))
  .AddTypedef(type_1446, Reflex::Literal("std::map<int,std::pair<double,double> >::allocator_type"))
  .AddTypedef(type_895, Reflex::Literal("std::map<int,std::pair<double,double> >::_Alloc_value_type"))
  .AddTypedef(type_1446, Reflex::Literal("std::map<int,std::pair<double,double> >::_Pair_alloc_type"))
  .AddTypedef(type_1149, Reflex::Literal("std::map<int,std::pair<double,double> >::_Rep_type"))
  .AddTypedef(type_10614, Reflex::Literal("std::map<int,std::pair<double,double> >::pointer"))
  .AddTypedef(type_10616, Reflex::Literal("std::map<int,std::pair<double,double> >::const_pointer"))
  .AddTypedef(type_10618, Reflex::Literal("std::map<int,std::pair<double,double> >::reference"))
  .AddTypedef(type_10620, Reflex::Literal("std::map<int,std::pair<double,double> >::const_reference"))
  .AddTypedef(type_1285, Reflex::Literal("std::map<int,std::pair<double,double> >::iterator"))
  .AddTypedef(type_1927, Reflex::Literal("std::map<int,std::pair<double,double> >::const_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::map<int,std::pair<double,double> >::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::map<int,std::pair<double,double> >::difference_type"))
  .AddTypedef(type_1871, Reflex::Literal("std::map<int,std::pair<double,double> >::reverse_iterator"))
  .AddTypedef(type_1870, Reflex::Literal("std::map<int,std::pair<double,double> >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_15802, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_15803, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20477, type_20745), Reflex::Literal("map"), constructor_15804, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21352), Reflex::Literal("map"), constructor_15805, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1649, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x299, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_int_std__pair_double_double_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_int_std__pair_double_double_s__funcmem_bld);
}

//------Delayed data member builder for class map<int,std::pair<double, double>,std::less<int>,std::allocator<std::pair<const int, std::pair<double, double> > > > -------------------
void __std__map_int_std__pair_double_double_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1149, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_int_std__pair_double_double_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<int,std::pair<double, double>,std::less<int>,std::allocator<std::pair<const int, std::pair<double, double> > > > -------------------
void __std__map_int_std__pair_double_double_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21353, type_21352), Reflex::Literal("operator="), operator_15806, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1446), Reflex::Literal("get_allocator"), method_15807, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1285), Reflex::Literal("begin"), method_15808, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1927), Reflex::Literal("begin"), method_15809, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1285), Reflex::Literal("end"), method_15810, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1927), Reflex::Literal("end"), method_15811, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_15816, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_15817, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_15818, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5954, type_4404), Reflex::Literal("operator[]"), operator_15819, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5954, type_4404), Reflex::Literal("at"), method_15820, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5956, type_4404), Reflex::Literal("at"), method_15821, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1011, type_10620), Reflex::Literal("insert"), method_15822, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1285, type_1285, type_10620), Reflex::Literal("insert"), method_15823, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1285), Reflex::Literal("erase"), method_15824, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4404), Reflex::Literal("erase"), method_15825, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1285, type_1285), Reflex::Literal("erase"), method_15826, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_21353), Reflex::Literal("swap"), method_15827, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_15828, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2024), Reflex::Literal("key_comp"), method_15829, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1285, type_4404), Reflex::Literal("find"), method_15831, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1927, type_4404), Reflex::Literal("find"), method_15832, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4404), Reflex::Literal("count"), method_15833, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1285, type_4404), Reflex::Literal("lower_bound"), method_15834, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1927, type_4404), Reflex::Literal("lower_bound"), method_15835, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1285, type_4404), Reflex::Literal("upper_bound"), method_15836, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1927, type_4404), Reflex::Literal("upper_bound"), method_15837, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1010, type_4404), Reflex::Literal("equal_range"), method_15838, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1009, type_4404), Reflex::Literal("equal_range"), method_15839, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class map<int,int,std::less<int>,std::allocator<std::pair<const int, int> > > -------------------------------
static void destructor_15860(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<int,int>*)o)->::std::map<int,int>::~map)();
}
static void constructor_15861( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,int>();
  else ::new(mem) ::std::map<int,int>();
}

static void constructor_15862( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,int>(*(const ::std::less<int>*)arg[0]);
  else ::new(mem) ::std::map<int,int>(*(const ::std::less<int>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,int>(*(const ::std::less<int>*)arg[0],
      *(const ::std::allocator<std::pair<const int,int> >*)arg[1]);
  else ::new(mem) ::std::map<int,int>(*(const ::std::less<int>*)arg[0],
      *(const ::std::allocator<std::pair<const int,int> >*)arg[1]);
  }
}

static void constructor_15863( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<int,int>(*(const ::std::map<int,int>*)arg[0]);
  else ::new(mem) ::std::map<int,int>(*(const ::std::map<int,int>*)arg[0]);
}

static  void operator_15864( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,int>*)o)->operator=)(*(const ::std::map<int,int>*)arg[0]);
  else   (((::std::map<int,int>*)o)->operator=)(*(const ::std::map<int,int>*)arg[0]);
}

static  void method_15865( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const int,int> >)((((const ::std::map<int,int>*)o)->get_allocator)());
  else   (((const ::std::map<int,int>*)o)->get_allocator)();
}

static  void method_15866( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,int> >)((((::std::map<int,int>*)o)->begin)());
  else   (((::std::map<int,int>*)o)->begin)();
}

static  void method_15867( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,int> >)((((const ::std::map<int,int>*)o)->begin)());
  else   (((const ::std::map<int,int>*)o)->begin)();
}

static  void method_15868( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,int> >)((((::std::map<int,int>*)o)->end)());
  else   (((::std::map<int,int>*)o)->end)();
}

static  void method_15869( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,int> >)((((const ::std::map<int,int>*)o)->end)());
  else   (((const ::std::map<int,int>*)o)->end)();
}

static  void method_15874( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<int,int>*)o)->empty)());
  else   (((const ::std::map<int,int>*)o)->empty)();
}

static  void method_15875( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<int,int>*)o)->size)());
  else   (((const ::std::map<int,int>*)o)->size)();
}

static  void method_15876( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<int,int>*)o)->max_size)());
  else   (((const ::std::map<int,int>*)o)->max_size)();
}

static  void operator_15877( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,int>*)o)->operator[])(*(const int*)arg[0]);
  else   (((::std::map<int,int>*)o)->operator[])(*(const int*)arg[0]);
}

static  void method_15878( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<int,int>*)o)->at)(*(const int*)arg[0]);
  else   (((::std::map<int,int>*)o)->at)(*(const int*)arg[0]);
}

static  void method_15879( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<int,int>*)o)->at)(*(const int*)arg[0]);
  else   (((const ::std::map<int,int>*)o)->at)(*(const int*)arg[0]);
}

static  void method_15880( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const int,int> >,bool>)((((::std::map<int,int>*)o)->insert)(*(const ::std::pair<const int,int>*)arg[0]));
  else   (((::std::map<int,int>*)o)->insert)(*(const ::std::pair<const int,int>*)arg[0]);
}

static  void method_15881( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,int> >)((((::std::map<int,int>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const int,int> >*)arg[0],
    *(const ::std::pair<const int,int>*)arg[1]));
  else   (((::std::map<int,int>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const int,int> >*)arg[0],
    *(const ::std::pair<const int,int>*)arg[1]);
}

static  void method_15882( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,int>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const int,int> >*)arg[0]);
}

static  void method_15883( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<int,int>*)o)->erase)(*(const int*)arg[0]));
  else   (((::std::map<int,int>*)o)->erase)(*(const int*)arg[0]);
}

static  void method_15884( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,int>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const int,int> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const int,int> >*)arg[1]);
}

static  void method_15885( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<int,int>*)o)->swap)(*(::std::map<int,int>*)arg[0]);
}

static  void method_15886( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<int,int>*)o)->clear)();
}

static  void method_15887( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<int>)((((const ::std::map<int,int>*)o)->key_comp)());
  else   (((const ::std::map<int,int>*)o)->key_comp)();
}

static  void method_15889( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,int> >)((((::std::map<int,int>*)o)->find)(*(const int*)arg[0]));
  else   (((::std::map<int,int>*)o)->find)(*(const int*)arg[0]);
}

static  void method_15890( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,int> >)((((const ::std::map<int,int>*)o)->find)(*(const int*)arg[0]));
  else   (((const ::std::map<int,int>*)o)->find)(*(const int*)arg[0]);
}

static  void method_15891( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<int,int>*)o)->count)(*(const int*)arg[0]));
  else   (((const ::std::map<int,int>*)o)->count)(*(const int*)arg[0]);
}

static  void method_15892( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,int> >)((((::std::map<int,int>*)o)->lower_bound)(*(const int*)arg[0]));
  else   (((::std::map<int,int>*)o)->lower_bound)(*(const int*)arg[0]);
}

static  void method_15893( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,int> >)((((const ::std::map<int,int>*)o)->lower_bound)(*(const int*)arg[0]));
  else   (((const ::std::map<int,int>*)o)->lower_bound)(*(const int*)arg[0]);
}

static  void method_15894( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const int,int> >)((((::std::map<int,int>*)o)->upper_bound)(*(const int*)arg[0]));
  else   (((::std::map<int,int>*)o)->upper_bound)(*(const int*)arg[0]);
}

static  void method_15895( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const int,int> >)((((const ::std::map<int,int>*)o)->upper_bound)(*(const int*)arg[0]));
  else   (((const ::std::map<int,int>*)o)->upper_bound)(*(const int*)arg[0]);
}

static  void method_15896( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const int,int> >,std::_Rb_tree_iterator<std::pair<const int,int> > >)((((::std::map<int,int>*)o)->equal_range)(*(const int*)arg[0]));
  else   (((::std::map<int,int>*)o)->equal_range)(*(const int*)arg[0]);
}

static  void method_15897( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const int,int> >,std::_Rb_tree_const_iterator<std::pair<const int,int> > >)((((const ::std::map<int,int>*)o)->equal_range)(*(const int*)arg[0]));
  else   (((const ::std::map<int,int>*)o)->equal_range)(*(const int*)arg[0]);
}

static void method_newdel_1650( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<int,int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<int,int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<int,int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<int,int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<int,int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x301( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<int,int> >::Generate();
  else ::Reflex::Proxy< ::std::map<int,int> >::Generate();
}

//------Dictionary for class map<int,int,std::less<int>,std::allocator<std::pair<const int, int> > > -------------------------------
void __std__map_int_int__db_datamem(Reflex::Class*);
void __std__map_int_int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_int_int__datamem_bld(&__std__map_int_int__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_int_int__funcmem_bld(&__std__map_int_int__db_funcmem);
void __std__map_int_int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<int,int>"), typeid(::std::map<int,int>), sizeof(::std::map<int,int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_22, Reflex::Literal("std::map<int,int>::key_type"))
  .AddTypedef(type_22, Reflex::Literal("std::map<int,int>::mapped_type"))
  .AddTypedef(type_896, Reflex::Literal("std::map<int,int>::value_type"))
  .AddTypedef(type_2024, Reflex::Literal("std::map<int,int>::key_compare"))
  .AddTypedef(type_1448, Reflex::Literal("std::map<int,int>::allocator_type"))
  .AddTypedef(type_896, Reflex::Literal("std::map<int,int>::_Alloc_value_type"))
  .AddTypedef(type_1448, Reflex::Literal("std::map<int,int>::_Pair_alloc_type"))
  .AddTypedef(type_1150, Reflex::Literal("std::map<int,int>::_Rep_type"))
  .AddTypedef(type_10719, Reflex::Literal("std::map<int,int>::pointer"))
  .AddTypedef(type_10721, Reflex::Literal("std::map<int,int>::const_pointer"))
  .AddTypedef(type_10723, Reflex::Literal("std::map<int,int>::reference"))
  .AddTypedef(type_10725, Reflex::Literal("std::map<int,int>::const_reference"))
  .AddTypedef(type_1286, Reflex::Literal("std::map<int,int>::iterator"))
  .AddTypedef(type_1928, Reflex::Literal("std::map<int,int>::const_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::map<int,int>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::map<int,int>::difference_type"))
  .AddTypedef(type_1873, Reflex::Literal("std::map<int,int>::reverse_iterator"))
  .AddTypedef(type_1872, Reflex::Literal("std::map<int,int>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_15860, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_15861, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20477, type_20752), Reflex::Literal("map"), constructor_15862, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21354), Reflex::Literal("map"), constructor_15863, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1650, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x301, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_int_int__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_int_int__funcmem_bld);
}

//------Delayed data member builder for class map<int,int,std::less<int>,std::allocator<std::pair<const int, int> > > -------------------
void __std__map_int_int__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1150, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_int_int_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<int,int,std::less<int>,std::allocator<std::pair<const int, int> > > -------------------
void __std__map_int_int__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21355, type_21354), Reflex::Literal("operator="), operator_15864, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1448), Reflex::Literal("get_allocator"), method_15865, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1286), Reflex::Literal("begin"), method_15866, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1928), Reflex::Literal("begin"), method_15867, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1286), Reflex::Literal("end"), method_15868, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1928), Reflex::Literal("end"), method_15869, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_15874, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_15875, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_15876, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3569, type_4404), Reflex::Literal("operator[]"), operator_15877, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3569, type_4404), Reflex::Literal("at"), method_15878, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4404, type_4404), Reflex::Literal("at"), method_15879, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1014, type_10725), Reflex::Literal("insert"), method_15880, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1286, type_1286, type_10725), Reflex::Literal("insert"), method_15881, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1286), Reflex::Literal("erase"), method_15882, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4404), Reflex::Literal("erase"), method_15883, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1286, type_1286), Reflex::Literal("erase"), method_15884, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_21355), Reflex::Literal("swap"), method_15885, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_15886, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2024), Reflex::Literal("key_comp"), method_15887, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1286, type_4404), Reflex::Literal("find"), method_15889, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1928, type_4404), Reflex::Literal("find"), method_15890, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4404), Reflex::Literal("count"), method_15891, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1286, type_4404), Reflex::Literal("lower_bound"), method_15892, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1928, type_4404), Reflex::Literal("lower_bound"), method_15893, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1286, type_4404), Reflex::Literal("upper_bound"), method_15894, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1928, type_4404), Reflex::Literal("upper_bound"), method_15895, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1013, type_4404), Reflex::Literal("equal_range"), method_15896, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1012, type_4404), Reflex::Literal("equal_range"), method_15897, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class deque<int,std::allocator<int> > -------------------------------
static void constructor_16072( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::deque<int>();
  else ::new(mem) ::std::deque<int>();
}

static void constructor_16073( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::deque<int>(*(const ::std::allocator<int>*)arg[0]);
  else ::new(mem) ::std::deque<int>(*(const ::std::allocator<int>*)arg[0]);
}

static void constructor_16074( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::deque<int>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::deque<int>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::deque<int>(*(::std::size_t*)arg[0],
      *(const int*)arg[1]);
  else ::new(mem) ::std::deque<int>(*(::std::size_t*)arg[0],
      *(const int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::deque<int>(*(::std::size_t*)arg[0],
      *(const int*)arg[1],
      *(const ::std::allocator<int>*)arg[2]);
  else ::new(mem) ::std::deque<int>(*(::std::size_t*)arg[0],
      *(const int*)arg[1],
      *(const ::std::allocator<int>*)arg[2]);
  }
}

static void constructor_16075( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::deque<int>(*(const ::std::deque<int>*)arg[0]);
  else ::new(mem) ::std::deque<int>(*(const ::std::deque<int>*)arg[0]);
}

static void destructor_16076(void*, void * o, const std::vector<void*>&, void *) {
(((::std::deque<int>*)o)->::std::deque<int>::~deque)();
}
static  void operator_16077( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::deque<int>*)o)->operator=)(*(const ::std::deque<int>*)arg[0]);
  else   (((::std::deque<int>*)o)->operator=)(*(const ::std::deque<int>*)arg[0]);
}

static  void method_16078( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::deque<int>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const int*)arg[1]);
}

static  void method_16079( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<int>)((((const ::std::deque<int>*)o)->get_allocator)());
  else   (((const ::std::deque<int>*)o)->get_allocator)();
}

static  void method_16080( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Deque_iterator<int,int&,int*>)((((::std::deque<int>*)o)->begin)());
  else   (((::std::deque<int>*)o)->begin)();
}

static  void method_16081( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Deque_iterator<int,const int&,const int*>)((((const ::std::deque<int>*)o)->begin)());
  else   (((const ::std::deque<int>*)o)->begin)();
}

static  void method_16082( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Deque_iterator<int,int&,int*>)((((::std::deque<int>*)o)->end)());
  else   (((::std::deque<int>*)o)->end)();
}

static  void method_16083( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Deque_iterator<int,const int&,const int*>)((((const ::std::deque<int>*)o)->end)());
  else   (((const ::std::deque<int>*)o)->end)();
}

static  void method_16088( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::deque<int>*)o)->size)());
  else   (((const ::std::deque<int>*)o)->size)();
}

static  void method_16089( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::deque<int>*)o)->max_size)());
  else   (((const ::std::deque<int>*)o)->max_size)();
}

static  void method_16090( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::deque<int>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::deque<int>*)o)->resize)(*(::std::size_t*)arg[0],
      *(int*)arg[1]);
  }
}

static  void method_16091( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::deque<int>*)o)->empty)());
  else   (((const ::std::deque<int>*)o)->empty)();
}

static  void operator_16092( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::deque<int>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::deque<int>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_16093( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::deque<int>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::deque<int>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_16095( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::deque<int>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::deque<int>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_16096( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::deque<int>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::deque<int>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_16097( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::deque<int>*)o)->front)();
  else   (((::std::deque<int>*)o)->front)();
}

static  void method_16098( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::deque<int>*)o)->front)();
  else   (((const ::std::deque<int>*)o)->front)();
}

static  void method_16099( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::deque<int>*)o)->back)();
  else   (((::std::deque<int>*)o)->back)();
}

static  void method_16100( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::deque<int>*)o)->back)();
  else   (((const ::std::deque<int>*)o)->back)();
}

static  void method_16101( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::deque<int>*)o)->push_front)(*(const int*)arg[0]);
}

static  void method_16102( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::deque<int>*)o)->push_back)(*(const int*)arg[0]);
}

static  void method_16103( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::deque<int>*)o)->pop_front)();
}

static  void method_16104( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::deque<int>*)o)->pop_back)();
}

static  void method_16105( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Deque_iterator<int,int&,int*>)((((::std::deque<int>*)o)->insert)(*(::std::_Deque_iterator<int,int&,int*>*)arg[0],
    *(const int*)arg[1]));
  else   (((::std::deque<int>*)o)->insert)(*(::std::_Deque_iterator<int,int&,int*>*)arg[0],
    *(const int*)arg[1]);
}

static  void method_16106( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::deque<int>*)o)->insert)(*(::std::_Deque_iterator<int,int&,int*>*)arg[0],
    *(::std::size_t*)arg[1],
    *(const int*)arg[2]);
}

static  void method_16107( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Deque_iterator<int,int&,int*>)((((::std::deque<int>*)o)->erase)(*(::std::_Deque_iterator<int,int&,int*>*)arg[0]));
  else   (((::std::deque<int>*)o)->erase)(*(::std::_Deque_iterator<int,int&,int*>*)arg[0]);
}

static  void method_16108( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Deque_iterator<int,int&,int*>)((((::std::deque<int>*)o)->erase)(*(::std::_Deque_iterator<int,int&,int*>*)arg[0],
    *(::std::_Deque_iterator<int,int&,int*>*)arg[1]));
  else   (((::std::deque<int>*)o)->erase)(*(::std::_Deque_iterator<int,int&,int*>*)arg[0],
    *(::std::_Deque_iterator<int,int&,int*>*)arg[1]);
}

static  void method_16109( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::deque<int>*)o)->swap)(*(::std::deque<int>*)arg[0]);
}

static  void method_16110( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::deque<int>*)o)->clear)();
}

static void method_newdel_1888( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::deque<int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::deque<int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::deque<int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::deque<int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::deque<int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x303( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Deque_base<int,std::allocator<int> >")), ::Reflex::BaseOffset< ::std::deque<int>,::std::_Deque_base<int,std::allocator<int> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x304( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::deque<int> >::Generate();
  else ::Reflex::Proxy< ::std::deque<int> >::Generate();
}

//------Dictionary for class deque<int,std::allocator<int> > -------------------------------
void __std__deque_int__db_datamem(Reflex::Class*);
void __std__deque_int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__deque_int__datamem_bld(&__std__deque_int__db_datamem);
Reflex::GenreflexMemberBuilder __std__deque_int__funcmem_bld(&__std__deque_int__db_funcmem);
void __std__deque_int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::deque<int>"), typeid(::std::deque<int>), sizeof(::std::deque<int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_1311, ::Reflex::BaseOffset< ::std::deque<int>, ::std::_Deque_base<int,std::allocator<int> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_22, Reflex::Literal("std::deque<int>::_Alloc_value_type"))
  .AddTypedef(type_1311, Reflex::Literal("std::deque<int>::_Base"))
  .AddTypedef(type_1339, Reflex::Literal("std::deque<int>::_Tp_alloc_type"))
  .AddTypedef(type_22, Reflex::Literal("std::deque<int>::value_type"))
  .AddTypedef(type_2054, Reflex::Literal("std::deque<int>::pointer"))
  .AddTypedef(type_4401, Reflex::Literal("std::deque<int>::const_pointer"))
  .AddTypedef(type_3569, Reflex::Literal("std::deque<int>::reference"))
  .AddTypedef(type_4404, Reflex::Literal("std::deque<int>::const_reference"))
  .AddTypedef(type_1309, Reflex::Literal("std::deque<int>::iterator"))
  .AddTypedef(type_1310, Reflex::Literal("std::deque<int>::const_iterator"))
  .AddTypedef(type_1876, Reflex::Literal("std::deque<int>::const_reverse_iterator"))
  .AddTypedef(type_1877, Reflex::Literal("std::deque<int>::reverse_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::deque<int>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::deque<int>::difference_type"))
  .AddTypedef(type_1339, Reflex::Literal("std::deque<int>::allocator_type"))
  .AddTypedef(type_11330, Reflex::Literal("std::deque<int>::_Map_pointer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("deque"), constructor_16072, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20319), Reflex::Literal("deque"), constructor_16073, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1654, type_4404, type_20319), Reflex::Literal("deque"), constructor_16074, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21384), Reflex::Literal("deque"), constructor_16075, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~deque"), destructor_16076, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1888, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x303, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x304, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__deque_int__funcmem_bld);
}

//------Delayed data member builder for class deque<int,std::allocator<int> > -------------------
void __std__deque_int__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class deque<int,std::allocator<int> > -------------------
void __std__deque_int__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21385, type_21384), Reflex::Literal("operator="), operator_16077, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_4404), Reflex::Literal("assign"), method_16078, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1339), Reflex::Literal("get_allocator"), method_16079, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309), Reflex::Literal("begin"), method_16080, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1310), Reflex::Literal("begin"), method_16081, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309), Reflex::Literal("end"), method_16082, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1310), Reflex::Literal("end"), method_16083, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_16088, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_16089, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1654, type_22), Reflex::Literal("resize"), method_16090, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_16091, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3569, type_1654), Reflex::Literal("operator[]"), operator_16092, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4404, type_1654), Reflex::Literal("operator[]"), operator_16093, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3569, type_1654), Reflex::Literal("at"), method_16095, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4404, type_1654), Reflex::Literal("at"), method_16096, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3569), Reflex::Literal("front"), method_16097, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4404), Reflex::Literal("front"), method_16098, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3569), Reflex::Literal("back"), method_16099, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4404), Reflex::Literal("back"), method_16100, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_4404), Reflex::Literal("push_front"), method_16101, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_4404), Reflex::Literal("push_back"), method_16102, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_front"), method_16103, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("pop_back"), method_16104, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_1309, type_4404), Reflex::Literal("insert"), method_16105, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1309, type_1654, type_4404), Reflex::Literal("insert"), method_16106, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_1309), Reflex::Literal("erase"), method_16107, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1309, type_1309, type_1309), Reflex::Literal("erase"), method_16108, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_21385), Reflex::Literal("swap"), method_16109, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_16110, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class bitset<7> -------------------------------
static void destructor_16134(void*, void * o, const std::vector<void*>&, void *) {
(((::std::bitset<7>*)o)->::std::bitset<7>::~bitset)();
}
static  void operator_16135( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::bitset<7>*)o)->operator=)(*(const ::std::bitset<7>*)arg[0]);
  else   (((::std::bitset<7>*)o)->operator=)(*(const ::std::bitset<7>*)arg[0]);
}

static void constructor_16136( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::bitset<7>(*(const ::std::bitset<7>*)arg[0]);
  else ::new(mem) ::std::bitset<7>(*(const ::std::bitset<7>*)arg[0]);
}

static void constructor_16138( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::bitset<7>();
  else ::new(mem) ::std::bitset<7>();
}

static void constructor_16139( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::bitset<7>(*(unsigned long*)arg[0]);
  else ::new(mem) ::std::bitset<7>(*(unsigned long*)arg[0]);
}

static  void operator_16140( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::bitset<7>*)o)->operator&=)(*(const ::std::bitset<7>*)arg[0]);
  else   (((::std::bitset<7>*)o)->operator&=)(*(const ::std::bitset<7>*)arg[0]);
}

static  void operator_16141( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::bitset<7>*)o)->operator|=)(*(const ::std::bitset<7>*)arg[0]);
  else   (((::std::bitset<7>*)o)->operator|=)(*(const ::std::bitset<7>*)arg[0]);
}

static  void operator_16142( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::bitset<7>*)o)->operator^=)(*(const ::std::bitset<7>*)arg[0]);
  else   (((::std::bitset<7>*)o)->operator^=)(*(const ::std::bitset<7>*)arg[0]);
}

static  void operator_16143( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::bitset<7>*)o)->operator<<=)(*(::std::size_t*)arg[0]);
  else   (((::std::bitset<7>*)o)->operator<<=)(*(::std::size_t*)arg[0]);
}

static  void operator_16144( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::bitset<7>*)o)->operator>>=)(*(::std::size_t*)arg[0]);
  else   (((::std::bitset<7>*)o)->operator>>=)(*(::std::size_t*)arg[0]);
}

static  void method_16145( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::bitset<7>*)o)->_Unchecked_set)(*(::std::size_t*)arg[0]);
  else   (((::std::bitset<7>*)o)->_Unchecked_set)(*(::std::size_t*)arg[0]);
}

static  void method_16146( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::bitset<7>*)o)->_Unchecked_set)(*(::std::size_t*)arg[0],
    *(int*)arg[1]);
  else   (((::std::bitset<7>*)o)->_Unchecked_set)(*(::std::size_t*)arg[0],
    *(int*)arg[1]);
}

static  void method_16147( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::bitset<7>*)o)->_Unchecked_reset)(*(::std::size_t*)arg[0]);
  else   (((::std::bitset<7>*)o)->_Unchecked_reset)(*(::std::size_t*)arg[0]);
}

static  void method_16148( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::bitset<7>*)o)->_Unchecked_flip)(*(::std::size_t*)arg[0]);
  else   (((::std::bitset<7>*)o)->_Unchecked_flip)(*(::std::size_t*)arg[0]);
}

static  void method_16149( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::bitset<7>*)o)->_Unchecked_test)(*(::std::size_t*)arg[0]));
  else   (((const ::std::bitset<7>*)o)->_Unchecked_test)(*(::std::size_t*)arg[0]);
}

static  void method_16150( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::bitset<7>*)o)->set)();
  else   (((::std::bitset<7>*)o)->set)();
}

static  void method_16151( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = (void*)&(((::std::bitset<7>*)o)->set)(*(::std::size_t*)arg[0]);
    else     (((::std::bitset<7>*)o)->set)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = (void*)&(((::std::bitset<7>*)o)->set)(*(::std::size_t*)arg[0],
      *(bool*)arg[1]);
    else     (((::std::bitset<7>*)o)->set)(*(::std::size_t*)arg[0],
      *(bool*)arg[1]);
  }
}

static  void method_16152( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::bitset<7>*)o)->reset)();
  else   (((::std::bitset<7>*)o)->reset)();
}

static  void method_16153( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::bitset<7>*)o)->reset)(*(::std::size_t*)arg[0]);
  else   (((::std::bitset<7>*)o)->reset)(*(::std::size_t*)arg[0]);
}

static  void method_16154( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::bitset<7>*)o)->flip)();
  else   (((::std::bitset<7>*)o)->flip)();
}

static  void method_16155( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::bitset<7>*)o)->flip)(*(::std::size_t*)arg[0]);
  else   (((::std::bitset<7>*)o)->flip)(*(::std::size_t*)arg[0]);
}

static  void operator_16156( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::bitset<7>)((((const ::std::bitset<7>*)o)->operator~)());
  else   (((const ::std::bitset<7>*)o)->operator~)();
}

static  void operator_16157( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::bitset<7>::reference)((((::std::bitset<7>*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((::std::bitset<7>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_16158( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::bitset<7>*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::std::bitset<7>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_16159( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::std::bitset<7>*)o)->to_ulong)());
  else   (((const ::std::bitset<7>*)o)->to_ulong)();
}

static  void method_16160( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::std::bitset<7>*)o)->to_string)());
  else   (((const ::std::bitset<7>*)o)->to_string)();
}

static  void method_16161( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::std::bitset<7>*)o)->to_string)(*(char*)arg[0]));
    else     (((const ::std::bitset<7>*)o)->to_string)(*(char*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (std::basic_string<char>)((((const ::std::bitset<7>*)o)->to_string)(*(char*)arg[0],
      *(char*)arg[1]));
    else     (((const ::std::bitset<7>*)o)->to_string)(*(char*)arg[0],
      *(char*)arg[1]);
  }
}

static  void method_16162( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::bitset<7>*)o)->count)());
  else   (((const ::std::bitset<7>*)o)->count)();
}

static  void method_16163( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::bitset<7>*)o)->size)());
  else   (((const ::std::bitset<7>*)o)->size)();
}

static  void operator_16164( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::bitset<7>*)o)->operator==)(*(const ::std::bitset<7>*)arg[0]));
  else   (((const ::std::bitset<7>*)o)->operator==)(*(const ::std::bitset<7>*)arg[0]);
}

static  void operator_16165( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::bitset<7>*)o)->operator!=)(*(const ::std::bitset<7>*)arg[0]));
  else   (((const ::std::bitset<7>*)o)->operator!=)(*(const ::std::bitset<7>*)arg[0]);
}

static  void method_16166( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::bitset<7>*)o)->test)(*(::std::size_t*)arg[0]));
  else   (((const ::std::bitset<7>*)o)->test)(*(::std::size_t*)arg[0]);
}

static  void method_16167( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::bitset<7>*)o)->all)());
  else   (((const ::std::bitset<7>*)o)->all)();
}

static  void method_16168( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::bitset<7>*)o)->any)());
  else   (((const ::std::bitset<7>*)o)->any)();
}

static  void method_16169( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::bitset<7>*)o)->none)());
  else   (((const ::std::bitset<7>*)o)->none)();
}

static  void operator_16170( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::bitset<7>)((((const ::std::bitset<7>*)o)->operator<<)(*(::std::size_t*)arg[0]));
  else   (((const ::std::bitset<7>*)o)->operator<<)(*(::std::size_t*)arg[0]);
}

static  void operator_16171( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::bitset<7>)((((const ::std::bitset<7>*)o)->operator>>)(*(::std::size_t*)arg[0]));
  else   (((const ::std::bitset<7>*)o)->operator>>)(*(::std::size_t*)arg[0]);
}

static  void method_16172( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::bitset<7>*)o)->_Find_first)());
  else   (((const ::std::bitset<7>*)o)->_Find_first)();
}

static  void method_16173( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::bitset<7>*)o)->_Find_next)(*(::std::size_t*)arg[0]));
  else   (((const ::std::bitset<7>*)o)->_Find_next)(*(::std::size_t*)arg[0]);
}

static void method_newdel_1929( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::bitset<7> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::bitset<7> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::bitset<7> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::bitset<7> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::bitset<7> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x306( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Base_bitset<1>")), ::Reflex::BaseOffset< ::std::bitset<7>,::std::_Base_bitset<1> >::Get(),::Reflex::PRIVATE), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x307( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::Reflex::StdBitSetHelper< ::std::bitset<7> > >::Generate();
  else ::Reflex::Proxy< ::Reflex::StdBitSetHelper< ::std::bitset<7> > >::Generate();
}

//------Dictionary for class bitset<7> -------------------------------
void __std__bitset_7__db_datamem(Reflex::Class*);
void __std__bitset_7__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__bitset_7__datamem_bld(&__std__bitset_7__db_datamem);
Reflex::GenreflexMemberBuilder __std__bitset_7__funcmem_bld(&__std__bitset_7__db_funcmem);
void __std__bitset_7__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::bitset<7>"), typeid(::std::bitset<7>), sizeof(::std::bitset<7>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2044, ::Reflex::BaseOffset< ::std::bitset<7>, ::std::_Base_bitset<1> >::Get(), ::Reflex::PRIVATE)
  .AddTypedef(type_2044, Reflex::Literal("std::bitset<7>::_Base"))
  .AddTypedef(type_75, Reflex::Literal("std::bitset<7>::_WordT"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~bitset"), destructor_16134, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21386, type_21387), Reflex::Literal("operator="), operator_16135, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21387), Reflex::Literal("bitset"), constructor_16136, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("bitset"), constructor_16138, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_75), Reflex::Literal("bitset"), constructor_16139, 0, "__val", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1929, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x306, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x307, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__bitset_7__funcmem_bld);
}

//------Delayed data member builder for class bitset<7> -------------------
void __std__bitset_7__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class bitset<7> -------------------
void __std__bitset_7__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21386, type_21387), Reflex::Literal("operator&="), operator_16140, 0, "__rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21386, type_21387), Reflex::Literal("operator|="), operator_16141, 0, "__rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21386, type_21387), Reflex::Literal("operator^="), operator_16142, 0, "__rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21386, type_1654), Reflex::Literal("operator<<="), operator_16143, 0, "__position", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21386, type_1654), Reflex::Literal("operator>>="), operator_16144, 0, "__position", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21386, type_1654), Reflex::Literal("_Unchecked_set"), method_16145, 0, "__pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21386, type_1654, type_22), Reflex::Literal("_Unchecked_set"), method_16146, 0, "__pos;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21386, type_1654), Reflex::Literal("_Unchecked_reset"), method_16147, 0, "__pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21386, type_1654), Reflex::Literal("_Unchecked_flip"), method_16148, 0, "__pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083, type_1654), Reflex::Literal("_Unchecked_test"), method_16149, 0, "__pos", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21386), Reflex::Literal("set"), method_16150, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21386, type_1654, type_2083), Reflex::Literal("set"), method_16151, 0, "__position;__val=true", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21386), Reflex::Literal("reset"), method_16152, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21386, type_1654), Reflex::Literal("reset"), method_16153, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21386), Reflex::Literal("flip"), method_16154, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21386, type_1654), Reflex::Literal("flip"), method_16155, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1929), Reflex::Literal("operator~"), operator_16156, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16133, type_1654), Reflex::Literal("operator[]"), operator_16157, 0, "__position", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083, type_1654), Reflex::Literal("operator[]"), operator_16158, 0, "__position", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_75), Reflex::Literal("to_ulong"), method_16159, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1104), Reflex::Literal("to_string"), method_16160, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1104, type_2616, type_2616), Reflex::Literal("to_string"), method_16161, 0, "__zero;__one='1'", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("count"), method_16162, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_16163, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083, type_21387), Reflex::Literal("operator=="), operator_16164, 0, "__rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083, type_21387), Reflex::Literal("operator!="), operator_16165, 0, "__rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083, type_1654), Reflex::Literal("test"), method_16166, 0, "__position", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("all"), method_16167, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("any"), method_16168, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("none"), method_16169, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1929, type_1654), Reflex::Literal("operator<<"), operator_16170, 0, "__position", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1929, type_1654), Reflex::Literal("operator>>"), operator_16171, 0, "__position", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("_Find_first"), method_16172, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_1654), Reflex::Literal("_Find_next"), method_16173, 0, "__prev", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class bidirectional_iterator_tag -------------------------------
static void destructor_16924(void*, void * o, const std::vector<void*>&, void *) {
(((::std::bidirectional_iterator_tag*)o)->::std::bidirectional_iterator_tag::~bidirectional_iterator_tag)();
}
static  void operator_16925( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::bidirectional_iterator_tag*)o)->operator=)(*(const ::std::bidirectional_iterator_tag*)arg[0]);
  else   (((::std::bidirectional_iterator_tag*)o)->operator=)(*(const ::std::bidirectional_iterator_tag*)arg[0]);
}

static void constructor_16926( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::bidirectional_iterator_tag(*(const ::std::bidirectional_iterator_tag*)arg[0]);
  else ::new(mem) ::std::bidirectional_iterator_tag(*(const ::std::bidirectional_iterator_tag*)arg[0]);
}

static void constructor_16927( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::bidirectional_iterator_tag();
  else ::new(mem) ::std::bidirectional_iterator_tag();
}

static void method_newdel_2006( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::bidirectional_iterator_tag >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::bidirectional_iterator_tag >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::bidirectional_iterator_tag >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::bidirectional_iterator_tag >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::bidirectional_iterator_tag >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x309( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::forward_iterator_tag")), ::Reflex::BaseOffset< ::std::bidirectional_iterator_tag,::std::forward_iterator_tag >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::input_iterator_tag")), ::Reflex::BaseOffset< ::std::bidirectional_iterator_tag,::std::input_iterator_tag >::Get(),::Reflex::PUBLIC), 1));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class bidirectional_iterator_tag -------------------------------
void __std__bidirectional_iterator_tag_db_datamem(Reflex::Class*);
void __std__bidirectional_iterator_tag_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__bidirectional_iterator_tag_datamem_bld(&__std__bidirectional_iterator_tag_db_datamem);
Reflex::GenreflexMemberBuilder __std__bidirectional_iterator_tag_funcmem_bld(&__std__bidirectional_iterator_tag_db_funcmem);
void __std__bidirectional_iterator_tag_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::bidirectional_iterator_tag"), typeid(::std::bidirectional_iterator_tag), sizeof(::std::bidirectional_iterator_tag), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddBase(type_1292, ::Reflex::BaseOffset< ::std::bidirectional_iterator_tag, ::std::forward_iterator_tag >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~bidirectional_iterator_tag"), destructor_16924, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21837, type_21838), Reflex::Literal("operator="), operator_16925, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21838), Reflex::Literal("bidirectional_iterator_tag"), constructor_16926, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("bidirectional_iterator_tag"), constructor_16927, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2006, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x309, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class bidirectional_iterator_tag -------------------
void __std__bidirectional_iterator_tag_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class bidirectional_iterator_tag -------------------
void __std__bidirectional_iterator_tag_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class less<int> -------------------------------
static void destructor_16951(void*, void * o, const std::vector<void*>&, void *) {
(((::std::less<int>*)o)->::std::less<int>::~less)();
}
static  void operator_16952( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::less<int>*)o)->operator=)(*(const ::std::less<int>*)arg[0]);
  else   (((::std::less<int>*)o)->operator=)(*(const ::std::less<int>*)arg[0]);
}

static void constructor_16953( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::less<int>(*(const ::std::less<int>*)arg[0]);
  else ::new(mem) ::std::less<int>(*(const ::std::less<int>*)arg[0]);
}

static void constructor_16954( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::less<int>();
  else ::new(mem) ::std::less<int>();
}

static  void operator_16955( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::less<int>*)o)->operator())(*(const int*)arg[0],
    *(const int*)arg[1]));
  else   (((const ::std::less<int>*)o)->operator())(*(const int*)arg[0],
    *(const int*)arg[1]);
}

static void method_newdel_2024( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::less<int> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::less<int> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::less<int> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::less<int> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::less<int> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x311( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::binary_function<int,int,bool>")), ::Reflex::BaseOffset< ::std::less<int>,::std::binary_function<int,int,bool> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class less<int> -------------------------------
void __std__less_int__db_datamem(Reflex::Class*);
void __std__less_int__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__less_int__datamem_bld(&__std__less_int__db_datamem);
Reflex::GenreflexMemberBuilder __std__less_int__funcmem_bld(&__std__less_int__db_funcmem);
void __std__less_int__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::less<int>"), typeid(::std::less<int>), sizeof(::std::less<int>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddBase(type_1664, ::Reflex::BaseOffset< ::std::less<int>, ::std::binary_function<int,int,bool> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~less"), destructor_16951, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21847, type_20477), Reflex::Literal("operator="), operator_16952, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20477), Reflex::Literal("less"), constructor_16953, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("less"), constructor_16954, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2024, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x311, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__less_int__funcmem_bld);
}

//------Delayed data member builder for class less<int> -------------------
void __std__less_int__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class less<int> -------------------
void __std__less_int__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083, type_4404, type_4404), Reflex::Literal("operator()"), operator_16955, 0, "__x;__y", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST);
}
//------Stub functions for class multimap<double,double,std::less<double>,std::allocator<std::pair<const double, double> > > -------------------------------
static void destructor_17028(void*, void * o, const std::vector<void*>&, void *) {
(((::std::multimap<double,double>*)o)->::std::multimap<double,double>::~multimap)();
}
static void constructor_17029( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::multimap<double,double>();
  else ::new(mem) ::std::multimap<double,double>();
}

static void constructor_17030( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::multimap<double,double>(*(const ::std::less<double>*)arg[0]);
  else ::new(mem) ::std::multimap<double,double>(*(const ::std::less<double>*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::multimap<double,double>(*(const ::std::less<double>*)arg[0],
      *(const ::std::allocator<std::pair<const double,double> >*)arg[1]);
  else ::new(mem) ::std::multimap<double,double>(*(const ::std::less<double>*)arg[0],
      *(const ::std::allocator<std::pair<const double,double> >*)arg[1]);
  }
}

static void constructor_17031( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::multimap<double,double>(*(const ::std::multimap<double,double>*)arg[0]);
  else ::new(mem) ::std::multimap<double,double>(*(const ::std::multimap<double,double>*)arg[0]);
}

static  void operator_17032( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::multimap<double,double>*)o)->operator=)(*(const ::std::multimap<double,double>*)arg[0]);
  else   (((::std::multimap<double,double>*)o)->operator=)(*(const ::std::multimap<double,double>*)arg[0]);
}

static  void method_17033( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const double,double> >)((((const ::std::multimap<double,double>*)o)->get_allocator)());
  else   (((const ::std::multimap<double,double>*)o)->get_allocator)();
}

static  void method_17034( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const double,double> >)((((::std::multimap<double,double>*)o)->begin)());
  else   (((::std::multimap<double,double>*)o)->begin)();
}

static  void method_17035( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const double,double> >)((((const ::std::multimap<double,double>*)o)->begin)());
  else   (((const ::std::multimap<double,double>*)o)->begin)();
}

static  void method_17036( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const double,double> >)((((::std::multimap<double,double>*)o)->end)());
  else   (((::std::multimap<double,double>*)o)->end)();
}

static  void method_17037( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const double,double> >)((((const ::std::multimap<double,double>*)o)->end)());
  else   (((const ::std::multimap<double,double>*)o)->end)();
}

static  void method_17042( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::multimap<double,double>*)o)->empty)());
  else   (((const ::std::multimap<double,double>*)o)->empty)();
}

static  void method_17043( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::multimap<double,double>*)o)->size)());
  else   (((const ::std::multimap<double,double>*)o)->size)();
}

static  void method_17044( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::multimap<double,double>*)o)->max_size)());
  else   (((const ::std::multimap<double,double>*)o)->max_size)();
}

static  void method_17045( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const double,double> >)((((::std::multimap<double,double>*)o)->insert)(*(const ::std::pair<const double,double>*)arg[0]));
  else   (((::std::multimap<double,double>*)o)->insert)(*(const ::std::pair<const double,double>*)arg[0]);
}

static  void method_17046( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const double,double> >)((((::std::multimap<double,double>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const double,double> >*)arg[0],
    *(const ::std::pair<const double,double>*)arg[1]));
  else   (((::std::multimap<double,double>*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const double,double> >*)arg[0],
    *(const ::std::pair<const double,double>*)arg[1]);
}

static  void method_17047( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::multimap<double,double>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const double,double> >*)arg[0]);
}

static  void method_17048( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::multimap<double,double>*)o)->erase)(*(const double*)arg[0]));
  else   (((::std::multimap<double,double>*)o)->erase)(*(const double*)arg[0]);
}

static  void method_17049( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::multimap<double,double>*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const double,double> >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const double,double> >*)arg[1]);
}

static  void method_17050( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::multimap<double,double>*)o)->swap)(*(::std::multimap<double,double>*)arg[0]);
}

static  void method_17051( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::multimap<double,double>*)o)->clear)();
}

static  void method_17052( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<double>)((((const ::std::multimap<double,double>*)o)->key_comp)());
  else   (((const ::std::multimap<double,double>*)o)->key_comp)();
}

static  void method_17054( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const double,double> >)((((::std::multimap<double,double>*)o)->find)(*(const double*)arg[0]));
  else   (((::std::multimap<double,double>*)o)->find)(*(const double*)arg[0]);
}

static  void method_17055( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const double,double> >)((((const ::std::multimap<double,double>*)o)->find)(*(const double*)arg[0]));
  else   (((const ::std::multimap<double,double>*)o)->find)(*(const double*)arg[0]);
}

static  void method_17056( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::multimap<double,double>*)o)->count)(*(const double*)arg[0]));
  else   (((const ::std::multimap<double,double>*)o)->count)(*(const double*)arg[0]);
}

static  void method_17057( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const double,double> >)((((::std::multimap<double,double>*)o)->lower_bound)(*(const double*)arg[0]));
  else   (((::std::multimap<double,double>*)o)->lower_bound)(*(const double*)arg[0]);
}

static  void method_17058( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const double,double> >)((((const ::std::multimap<double,double>*)o)->lower_bound)(*(const double*)arg[0]));
  else   (((const ::std::multimap<double,double>*)o)->lower_bound)(*(const double*)arg[0]);
}

static  void method_17059( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const double,double> >)((((::std::multimap<double,double>*)o)->upper_bound)(*(const double*)arg[0]));
  else   (((::std::multimap<double,double>*)o)->upper_bound)(*(const double*)arg[0]);
}

static  void method_17060( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const double,double> >)((((const ::std::multimap<double,double>*)o)->upper_bound)(*(const double*)arg[0]));
  else   (((const ::std::multimap<double,double>*)o)->upper_bound)(*(const double*)arg[0]);
}

static  void method_17061( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const double,double> >,std::_Rb_tree_iterator<std::pair<const double,double> > >)((((::std::multimap<double,double>*)o)->equal_range)(*(const double*)arg[0]));
  else   (((::std::multimap<double,double>*)o)->equal_range)(*(const double*)arg[0]);
}

static  void method_17062( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const double,double> >,std::_Rb_tree_const_iterator<std::pair<const double,double> > >)((((const ::std::multimap<double,double>*)o)->equal_range)(*(const double*)arg[0]));
  else   (((const ::std::multimap<double,double>*)o)->equal_range)(*(const double*)arg[0]);
}

static void method_newdel_2039( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::multimap<double,double> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::multimap<double,double> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::multimap<double,double> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::multimap<double,double> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::multimap<double,double> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x313( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::multimap<double,double> >::Generate();
  else ::Reflex::Proxy< ::std::multimap<double,double> >::Generate();
}

//------Dictionary for class multimap<double,double,std::less<double>,std::allocator<std::pair<const double, double> > > -------------------------------
void __std__multimap_double_double__db_datamem(Reflex::Class*);
void __std__multimap_double_double__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__multimap_double_double__datamem_bld(&__std__multimap_double_double__db_datamem);
Reflex::GenreflexMemberBuilder __std__multimap_double_double__funcmem_bld(&__std__multimap_double_double__db_funcmem);
void __std__multimap_double_double__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::multimap<double,double>"), typeid(::std::multimap<double,double>), sizeof(::std::multimap<double,double>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2052, Reflex::Literal("std::multimap<double,double>::key_type"))
  .AddTypedef(type_2052, Reflex::Literal("std::multimap<double,double>::mapped_type"))
  .AddTypedef(type_898, Reflex::Literal("std::multimap<double,double>::value_type"))
  .AddTypedef(type_2025, Reflex::Literal("std::multimap<double,double>::key_compare"))
  .AddTypedef(type_1376, Reflex::Literal("std::multimap<double,double>::allocator_type"))
  .AddTypedef(type_898, Reflex::Literal("std::multimap<double,double>::_Alloc_value_type"))
  .AddTypedef(type_1376, Reflex::Literal("std::multimap<double,double>::_Pair_alloc_type"))
  .AddTypedef(type_1113, Reflex::Literal("std::multimap<double,double>::_Rep_type"))
  .AddTypedef(type_6834, Reflex::Literal("std::multimap<double,double>::pointer"))
  .AddTypedef(type_6836, Reflex::Literal("std::multimap<double,double>::const_pointer"))
  .AddTypedef(type_6838, Reflex::Literal("std::multimap<double,double>::reference"))
  .AddTypedef(type_6840, Reflex::Literal("std::multimap<double,double>::const_reference"))
  .AddTypedef(type_1249, Reflex::Literal("std::multimap<double,double>::iterator"))
  .AddTypedef(type_1891, Reflex::Literal("std::multimap<double,double>::const_iterator"))
  .AddTypedef(type_1654, Reflex::Literal("std::multimap<double,double>::size_type"))
  .AddTypedef(type_1592, Reflex::Literal("std::multimap<double,double>::difference_type"))
  .AddTypedef(type_1799, Reflex::Literal("std::multimap<double,double>::reverse_iterator"))
  .AddTypedef(type_1798, Reflex::Literal("std::multimap<double,double>::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~multimap"), destructor_17028, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("multimap"), constructor_17029, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20484, type_20485), Reflex::Literal("multimap"), constructor_17030, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21861), Reflex::Literal("multimap"), constructor_17031, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2039, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x313, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__multimap_double_double__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__multimap_double_double__funcmem_bld);
}

//------Delayed data member builder for class multimap<double,double,std::less<double>,std::allocator<std::pair<const double, double> > > -------------------
void __std__multimap_double_double__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1113, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__multimap_double_double_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class multimap<double,double,std::less<double>,std::allocator<std::pair<const double, double> > > -------------------
void __std__multimap_double_double__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21862, type_21861), Reflex::Literal("operator="), operator_17032, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1376), Reflex::Literal("get_allocator"), method_17033, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1249), Reflex::Literal("begin"), method_17034, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1891), Reflex::Literal("begin"), method_17035, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1249), Reflex::Literal("end"), method_17036, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1891), Reflex::Literal("end"), method_17037, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2083), Reflex::Literal("empty"), method_17042, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("size"), method_17043, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654), Reflex::Literal("max_size"), method_17044, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1249, type_6840), Reflex::Literal("insert"), method_17045, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1249, type_1249, type_6840), Reflex::Literal("insert"), method_17046, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1249), Reflex::Literal("erase"), method_17047, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4918), Reflex::Literal("erase"), method_17048, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_1249, type_1249), Reflex::Literal("erase"), method_17049, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150, type_21862), Reflex::Literal("swap"), method_17050, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2150), Reflex::Literal("clear"), method_17051, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2025), Reflex::Literal("key_comp"), method_17052, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1249, type_4918), Reflex::Literal("find"), method_17054, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1891, type_4918), Reflex::Literal("find"), method_17055, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1654, type_4918), Reflex::Literal("count"), method_17056, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1249, type_4918), Reflex::Literal("lower_bound"), method_17057, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1891, type_4918), Reflex::Literal("lower_bound"), method_17058, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1249, type_4918), Reflex::Literal("upper_bound"), method_17059, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1891, type_4918), Reflex::Literal("upper_bound"), method_17060, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_899, type_4918), Reflex::Literal("equal_range"), method_17061, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_897, type_4918), Reflex::Literal("equal_range"), method_17062, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class __normal_iterator<std::basic_string<char, std::char_traits<char>, std::allocator<char> >*,std::vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------------------
static void destructor_19610(void*, void * o, const std::vector<void*>&, void *) {
(((::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)o)->::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >::~__normal_iterator)();
}
static  void operator_19611( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[0]);
}

static void constructor_19612( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >(*(const ::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >(*(const ::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)arg[0]);
}

static void constructor_19613( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >();
  else ::new(mem) ::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >();
}

static void constructor_19614( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >(*(::std::basic_string<char>* const*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >(*(::std::basic_string<char>* const*)arg[0]);
}

static  void operator_19615( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)o)->operator*)();
  else   (((const ::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)o)->operator*)();
}

static  void operator_19616( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)o)->operator->)());
  else   (((const ::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)o)->operator->)();
}

static  void operator_19617( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)o)->operator++)();
  else   (((::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)o)->operator++)();
}

static  void operator_19618( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)o)->operator++)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_19619( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)o)->operator--)();
  else   (((::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)o)->operator--)();
}

static  void operator_19620( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)o)->operator--)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_19621( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((const ::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_19622( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_19623( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((const ::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_19624( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_19625( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >)((((const ::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void method_19626( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)o)->base)();
  else   (((const ::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >*)o)->base)();
}

static void method_newdel_2337( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __normal_iterator<std::basic_string<char, std::char_traits<char>, std::allocator<char> >*,std::vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------------------
void ____gnu_cxx____normal_iterator_std__basic_string_char_p_std__vector_std__basic_string_char_s_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____normal_iterator_std__basic_string_char_p_std__vector_std__basic_string_char_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_std__basic_string_char_p_std__vector_std__basic_string_char_s_s__datamem_bld(&____gnu_cxx____normal_iterator_std__basic_string_char_p_std__vector_std__basic_string_char_s_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_std__basic_string_char_p_std__vector_std__basic_string_char_s_s__funcmem_bld(&____gnu_cxx____normal_iterator_std__basic_string_char_p_std__vector_std__basic_string_char_s_s__db_funcmem);
void ____gnu_cxx____normal_iterator_std__basic_string_char_p_std__vector_std__basic_string_char_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >"), typeid(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >), sizeof(::__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1038, Reflex::Literal("__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >::__traits_type"))
  .AddTypedef(type_3514, Reflex::Literal("__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >::iterator_type"))
  .AddTypedef(type_1326, Reflex::Literal("__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >::iterator_category"))
  .AddTypedef(type_1104, Reflex::Literal("__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >::value_type"))
  .AddTypedef(type_1592, Reflex::Literal("__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >::difference_type"))
  .AddTypedef(type_3516, Reflex::Literal("__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >::reference"))
  .AddTypedef(type_3514, Reflex::Literal("__gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > >::pointer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__normal_iterator"), destructor_19610, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22171, type_22172), Reflex::Literal("operator="), operator_19611, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_22172), Reflex::Literal("__normal_iterator"), constructor_19612, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__normal_iterator"), constructor_19613, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_22173), Reflex::Literal("__normal_iterator"), constructor_19614, 0, "__i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2337, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&____gnu_cxx____normal_iterator_std__basic_string_char_p_std__vector_std__basic_string_char_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____normal_iterator_std__basic_string_char_p_std__vector_std__basic_string_char_s_s__funcmem_bld);
}

//------Delayed data member builder for class __normal_iterator<std::basic_string<char, std::char_traits<char>, std::allocator<char> >*,std::vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------
void ____gnu_cxx____normal_iterator_std__basic_string_char_p_std__vector_std__basic_string_char_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3514, Reflex::Literal("_M_current"), OffsetOf(__shadow__::____gnu_cxx____normal_iterator_std__basic_string_char_p_std__vector_std__basic_string_char_s_s_, _M_current), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class __normal_iterator<std::basic_string<char, std::char_traits<char>, std::allocator<char> >*,std::vector<std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::allocator<std::basic_string<char, std::char_traits<char>, std::allocator<char> > > > > -------------------
void ____gnu_cxx____normal_iterator_std__basic_string_char_p_std__vector_std__basic_string_char_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516), Reflex::Literal("operator*"), operator_19615, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3514), Reflex::Literal("operator->"), operator_19616, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22171), Reflex::Literal("operator++"), operator_19617, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2337, type_22), Reflex::Literal("operator++"), operator_19618, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22171), Reflex::Literal("operator--"), operator_19619, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2337, type_22), Reflex::Literal("operator--"), operator_19620, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_22158), Reflex::Literal("operator[]"), operator_19621, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22171, type_22158), Reflex::Literal("operator+="), operator_19622, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2337, type_22158), Reflex::Literal("operator+"), operator_19623, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22171, type_22158), Reflex::Literal("operator-="), operator_19624, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2337, type_22158), Reflex::Literal("operator-"), operator_19625, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_22173), Reflex::Literal("base"), method_19626, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __std__pair_int_double__dict(); 
      __std__pair_unsignedslongslong_std__basic_string_char_s__dict(); 
      __std__pair_unsignedsint_unsignedsint__dict(); 
      __std__pair_unsignedsint_int__dict(); 
      __std__pair_unsignedsint_float__dict(); 
      __std__pair_unsignedsint_double__dict(); 
      __std__pair_unsignedsint_bool__dict(); 
      __std__pair_double_std__vector_double_s__dict(); 
      __std__pair_std__vector_std__pair_double_std__vector_double_s_s__bool__dict(); 
      __std__pair_std__basic_string_char__int__dict(); 
      __std__pair_std__basic_string_char__float__dict(); 
      __std__pair_std__basic_string_char__double__dict(); 
      __std__pair_std__basic_string_char__bool__dict(); 
      __std__pair_int_int__dict(); 
      __std__pair_float_float__dict(); 
      __std__pair_double_double__dict(); 
      __std__pair_constsshort_short__dict(); 
      __std__pair_unsignedsshort_unsignedsshort__dict(); 
      __std__pair_unsignedsshort_std__vector_unsignedsshort_s__dict(); 
      __std__pair_unsignedsshort_float__dict(); 
      __std__pair_unsignedslong_unsignedslong__dict(); 
      __std__pair_unsignedslong_std__vector_unsignedslong_s__dict(); 
      __std__pair_unsignedsint_unsignedslong__dict(); 
      __std__pair_unsignedsint_std__vector_unsignedsint_s__dict(); 
      __std__pair_unsignedsint_std__vector_std__pair_unsignedsint_double_s_s__dict(); 
      __std__pair_unsignedsint_std__vector_std__pair_unsignedsint_bool_s_s__dict(); 
      __std__pair_unsignedsint_std__pair_unsignedsint_unsignedsint_s__dict(); 
      __std__pair_unsignedsint_std__basic_string_char_s__dict(); 
      __std__pair_unsignedsint_short__dict(); 
      __std__pair_std__pair_short_short__std__pair_short_std__vector_short_s_s__dict(); 
      __std__pair_short_std__vector_short_s__dict(); 
      __std__pair_short_short__dict(); 
      __std__pair_std__pair_int_int__int__dict(); 
      __std__pair_std__basic_string_char__unsignedsint__dict(); 
      __std__pair_std__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s__dict(); 
      __std__pair_std__basic_string_char__std__vector_std__basic_string_char_s_s__dict(); 
      __std__pair_std__basic_string_char__std__pair_unsignedsint_unsignedsint_s__dict(); 
      __std__pair_std__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s__dict(); 
      __std__pair_constsstd__basic_string_char__std__basic_string_char_s__dict(); 
      __std__pair_std__basic_string_char__std__basic_string_char_s__dict(); 
      __std__pair_short_unsignedsint__dict(); 
      __std__pair_int_unsignedsint__dict(); 
      __std__pair_int_std__pair_unsignedslong_unsignedslong_s__dict(); 
      __std__pair_int_std__pair_unsignedsint_unsignedsint_s__dict(); 
      __std__pair_int_std__pair_double_double_s__dict(); 
      __std__pair_constsunsignedsshort_unsignedsshort__dict(); 
      __std__pair_constsunsignedsshort_std__vector_unsignedsshort_s__dict(); 
      __std__pair_constsunsignedsshort_float__dict(); 
      __std__pair_constsunsignedslong_unsignedslong__dict(); 
      __std__pair_constsunsignedslong_std__vector_unsignedslong_s__dict(); 
      __std__pair_constsunsignedslongslong_std__basic_string_char_s__dict(); 
      __std__pair_constsunsignedsint_unsignedsint__dict(); 
      __std__pair_constsunsignedsint_std__vector_unsignedsint_s__dict(); 
      __std__pair_constsunsignedsint_std__vector_std__pair_unsignedsint_double_s_s__dict(); 
      __std__pair_constsunsignedsint_std__vector_std__pair_unsignedsint_bool_s_s__dict(); 
      __std__pair_constsunsignedsint_std__pair_unsignedsint_unsignedsint_s__dict(); 
      __std__pair_constsunsignedsint_std__basic_string_char_s__dict(); 
      __std__pair_constsunsignedsint_short__dict(); 
      __std__pair_constsunsignedsint_int__dict(); 
      __std__pair_constsunsignedsint_float__dict(); 
      __std__pair_constsunsignedsint_double__dict(); 
      __std__pair_constsunsignedsint_bool__dict(); 
      __std__pair_constsstd__pair_short_short__std__pair_short_std__vector_short_s_s__dict(); 
      __std__pair_constsstd__pair_int_int__int__dict(); 
      __std__pair_constsstd__basic_string_char__unsignedsint__dict(); 
      __std__pair_constsstd__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s__dict(); 
      __std__pair_constsstd__basic_string_char__std__vector_std__basic_string_char_s_s__dict(); 
      __std__pair_constsstd__basic_string_char__std__pair_unsignedsint_unsignedsint_s__dict(); 
      __std__pair_constsstd__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s__dict(); 
      __std__pair_constsstd__basic_string_char__int__dict(); 
      __std__pair_constsstd__basic_string_char__bool__dict(); 
      __std__pair_constsshort_unsignedsint__dict(); 
      __std__pair_constsint_unsignedsint__dict(); 
      __std__pair_constsint_std__pair_unsignedslong_unsignedslong_s__dict(); 
      __std__pair_constsint_std__pair_unsignedsint_unsignedsint_s__dict(); 
      __std__pair_constsint_std__pair_double_double_s__dict(); 
      __std__pair_constsint_int__dict(); 
      __std__input_iterator_tag_dict(); 
      __std__vector_constsvoidp__dict(); 
      __std__vector_unsignedsshort__dict(); 
      __std__vector_unsignedslong__dict(); 
      __std__vector_unsignedslongslong__dict(); 
      __std__vector_unsignedsint__dict(); 
      __std__vector_unsignedschar__dict(); 
      __std__vector_unsignedscharp__dict(); 
      __std__vector_std__vector_unsignedsshort_s__dict(); 
      __std__vector_std__vector_unsignedsint_s__dict(); 
      __std__vector_int__dict(); 
      __std__vector_std__vector_int_s__dict(); 
      __std__vector_std__vector_std__vector_int_s_s__dict(); 
      __std__vector_std__pair_int_double_s__dict(); 
      __std__vector_std__vector_std__pair_int_double_s_s__dict(); 
      __std__vector_short__dict(); 
      __std__vector_std__vector_short_s__dict(); 
      __std__vector_float__dict(); 
      __std__vector_std__vector_float_s__dict(); 
      __std__vector_double__dict(); 
      __std__vector_std__vector_double_s__dict(); 
      __std__basic_string_char__dict(); 
      __std__vector_std__basic_string_char_s__dict(); 
      __std__vector_std__pair_unsignedslongslong_std__basic_string_char_s_s__dict(); 
      __std__vector_std__pair_unsignedsint_unsignedsint_s__dict(); 
      __std__vector_std__pair_unsignedsint_int_s__dict(); 
      __std__vector_std__pair_unsignedsint_float_s__dict(); 
      __std__vector_std__pair_unsignedsint_double_s__dict(); 
      __std__vector_std__pair_unsignedsint_bool_s__dict(); 
      __std__vector_std__pair_std__vector_std__pair_double_std__vector_double_s_s__bool_s__dict(); 
      __std__vector_std__pair_double_std__vector_double_s_s__dict(); 
      __std__vector_std__pair_std__basic_string_char__int_s__dict(); 
      __std__vector_std__pair_std__basic_string_char__float_s__dict(); 
      __std__vector_std__pair_std__basic_string_char__double_s__dict(); 
      __std__vector_std__pair_std__basic_string_char__bool_s__dict(); 
      __std__vector_std__pair_int_int_s__dict(); 
      __std__vector_std__pair_float_float_s__dict(); 
      __std__vector_std__pair_double_double_s__dict(); 
      __std__map_short_short__dict(); 
      __std__vector_std__map_short_short_s__dict(); 
      __std__vector_long__dict(); 
      __std__vector_longslong__dict(); 
      __std__vector_longsdouble__dict(); 
      __std__vector_char__dict(); 
      __std__vector_charp__dict(); 
      __std__vector_bool__dict(); 
      __std__forward_iterator_tag_dict(); 
      __std__random_access_iterator_tag_dict(); 
      __std__allocator_int__dict(); 
      __std__allocator_short__dict(); 
      __std__allocator_double__dict(); 
      __std__allocator_char__dict(); 
      __std__set_std__basic_string_char_s__dict(); 
      __std__set_int__dict(); 
      __std__output_iterator_tag_dict(); 
      __std__list_int__dict(); 
      __std__map_std__basic_string_char__std__basic_string_char_s__dict(); 
      __std__map_unsignedsshort_unsignedsshort__dict(); 
      __std__map_unsignedsshort_std__vector_unsignedsshort_s__dict(); 
      __std__map_unsignedsshort_float__dict(); 
      __std__map_unsignedslong_unsignedslong__dict(); 
      __std__map_unsignedslong_std__vector_unsignedslong_s__dict(); 
      __std__map_unsignedslongslong_std__basic_string_char_s__dict(); 
      __std__map_unsignedsint_unsignedsint__dict(); 
      __std__map_unsignedsint_std__vector_unsignedsint_s__dict(); 
      __std__map_unsignedsint_std__vector_std__pair_unsignedsint_float_s_s__dict(); 
      __std__map_unsignedsint_std__vector_std__pair_unsignedsint_double_s_s__dict(); 
      __std__map_unsignedsint_std__vector_std__pair_unsignedsint_bool_s_s__dict(); 
      __std__map_unsignedsint_std__pair_unsignedsint_unsignedsint_s__dict(); 
      __std__map_unsignedsint_std__basic_string_char_s__dict(); 
      __std__map_unsignedsint_short__dict(); 
      __std__map_unsignedsint_int__dict(); 
      __std__map_unsignedsint_float__dict(); 
      __std__map_unsignedsint_double__dict(); 
      __std__map_unsignedsint_bool__dict(); 
      __std__map_std__pair_short_short__std__pair_short_std__vector_short_s_s__dict(); 
      __std__map_std__pair_int_int__int__dict(); 
      __std__map_std__pair_int_int__double__dict(); 
      __std__map_std__basic_string_char__unsignedslong__dict(); 
      __std__map_std__basic_string_char__unsignedsint__dict(); 
      __std__map_std__basic_string_char__std__vector_std__pair_std__basic_string_char__double_s_s__dict(); 
      __std__map_std__basic_string_char__std__vector_std__basic_string_char_s_s__dict(); 
      __std__map_std__basic_string_char__std__pair_unsignedsint_unsignedsint_s__dict(); 
      __std__map_std__basic_string_char__std__map_std__basic_string_char__std__basic_string_char_s_s__dict(); 
      __std__map_std__basic_string_char__int__dict(); 
      __std__map_std__basic_string_char__bool__dict(); 
      __std__map_short_unsignedsint__dict(); 
      __std__map_int_unsignedsint__dict(); 
      __std__map_int_std__pair_unsignedslong_unsignedslong_s__dict(); 
      __std__map_int_std__pair_unsignedsint_unsignedsint_s__dict(); 
      __std__map_int_std__pair_double_double_s__dict(); 
      __std__map_int_int__dict(); 
      __std__deque_int__dict(); 
      __std__bitset_7__dict(); 
      __std__bidirectional_iterator_tag_dict(); 
      __std__less_int__dict(); 
      __std__multimap_double_double__dict(); 
      ____gnu_cxx____normal_iterator_std__basic_string_char_p_std__vector_std__basic_string_char_s_s__dict(); 
    }
    ~Dictionaries() {
      type_812.Unload(); // class std::pair<int,double> 
      type_813.Unload(); // class std::pair<unsigned long long,std::basic_string<char> > 
      type_814.Unload(); // class std::pair<unsigned int,unsigned int> 
      type_815.Unload(); // class std::pair<unsigned int,int> 
      type_816.Unload(); // class std::pair<unsigned int,float> 
      type_817.Unload(); // class std::pair<unsigned int,double> 
      type_818.Unload(); // class std::pair<unsigned int,bool> 
      type_820.Unload(); // class std::pair<double,std::vector<double> > 
      type_819.Unload(); // class std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> 
      type_821.Unload(); // class std::pair<std::basic_string<char>,int> 
      type_822.Unload(); // class std::pair<std::basic_string<char>,float> 
      type_823.Unload(); // class std::pair<std::basic_string<char>,double> 
      type_824.Unload(); // class std::pair<std::basic_string<char>,bool> 
      type_825.Unload(); // class std::pair<int,int> 
      type_826.Unload(); // class std::pair<float,float> 
      type_827.Unload(); // class std::pair<double,double> 
      type_828.Unload(); // class std::pair<const short,short> 
      type_837.Unload(); // class std::pair<unsigned short,unsigned short> 
      type_838.Unload(); // class std::pair<unsigned short,std::vector<unsigned short> > 
      type_839.Unload(); // class std::pair<unsigned short,float> 
      type_840.Unload(); // class std::pair<unsigned long,unsigned long> 
      type_841.Unload(); // class std::pair<unsigned long,std::vector<unsigned long> > 
      type_842.Unload(); // class std::pair<unsigned int,unsigned long> 
      type_843.Unload(); // class std::pair<unsigned int,std::vector<unsigned int> > 
      type_844.Unload(); // class std::pair<unsigned int,std::vector<std::pair<unsigned int,double> > > 
      type_845.Unload(); // class std::pair<unsigned int,std::vector<std::pair<unsigned int,bool> > > 
      type_846.Unload(); // class std::pair<unsigned int,std::pair<unsigned int,unsigned int> > 
      type_847.Unload(); // class std::pair<unsigned int,std::basic_string<char> > 
      type_848.Unload(); // class std::pair<unsigned int,short> 
      type_849.Unload(); // class std::pair<std::pair<short,short>,std::pair<short,std::vector<short> > > 
      type_850.Unload(); // class std::pair<short,std::vector<short> > 
      type_851.Unload(); // class std::pair<short,short> 
      type_852.Unload(); // class std::pair<std::pair<int,int>,int> 
      type_853.Unload(); // class std::pair<std::basic_string<char>,unsigned int> 
      type_854.Unload(); // class std::pair<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > 
      type_855.Unload(); // class std::pair<std::basic_string<char>,std::vector<std::basic_string<char> > > 
      type_856.Unload(); // class std::pair<std::basic_string<char>,std::pair<unsigned int,unsigned int> > 
      type_857.Unload(); // class std::pair<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > 
      type_858.Unload(); // class std::pair<const std::basic_string<char>,std::basic_string<char> > 
      type_859.Unload(); // class std::pair<std::basic_string<char>,std::basic_string<char> > 
      type_860.Unload(); // class std::pair<short,unsigned int> 
      type_861.Unload(); // class std::pair<int,unsigned int> 
      type_862.Unload(); // class std::pair<int,std::pair<unsigned long,unsigned long> > 
      type_863.Unload(); // class std::pair<int,std::pair<unsigned int,unsigned int> > 
      type_864.Unload(); // class std::pair<int,std::pair<double,double> > 
      type_865.Unload(); // class std::pair<const unsigned short,unsigned short> 
      type_866.Unload(); // class std::pair<const unsigned short,std::vector<unsigned short> > 
      type_867.Unload(); // class std::pair<const unsigned short,float> 
      type_868.Unload(); // class std::pair<const unsigned long,unsigned long> 
      type_869.Unload(); // class std::pair<const unsigned long,std::vector<unsigned long> > 
      type_870.Unload(); // class std::pair<const unsigned long long,std::basic_string<char> > 
      type_871.Unload(); // class std::pair<const unsigned int,unsigned int> 
      type_872.Unload(); // class std::pair<const unsigned int,std::vector<unsigned int> > 
      type_873.Unload(); // class std::pair<const unsigned int,std::vector<std::pair<unsigned int,double> > > 
      type_874.Unload(); // class std::pair<const unsigned int,std::vector<std::pair<unsigned int,bool> > > 
      type_875.Unload(); // class std::pair<const unsigned int,std::pair<unsigned int,unsigned int> > 
      type_876.Unload(); // class std::pair<const unsigned int,std::basic_string<char> > 
      type_877.Unload(); // class std::pair<const unsigned int,short> 
      type_878.Unload(); // class std::pair<const unsigned int,int> 
      type_879.Unload(); // class std::pair<const unsigned int,float> 
      type_880.Unload(); // class std::pair<const unsigned int,double> 
      type_881.Unload(); // class std::pair<const unsigned int,bool> 
      type_882.Unload(); // class std::pair<const std::pair<short,short>,std::pair<short,std::vector<short> > > 
      type_883.Unload(); // class std::pair<const std::pair<int,int>,int> 
      type_884.Unload(); // class std::pair<const std::basic_string<char>,unsigned int> 
      type_885.Unload(); // class std::pair<const std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > 
      type_886.Unload(); // class std::pair<const std::basic_string<char>,std::vector<std::basic_string<char> > > 
      type_887.Unload(); // class std::pair<const std::basic_string<char>,std::pair<unsigned int,unsigned int> > 
      type_888.Unload(); // class std::pair<const std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > 
      type_889.Unload(); // class std::pair<const std::basic_string<char>,int> 
      type_890.Unload(); // class std::pair<const std::basic_string<char>,bool> 
      type_891.Unload(); // class std::pair<const short,unsigned int> 
      type_892.Unload(); // class std::pair<const int,unsigned int> 
      type_893.Unload(); // class std::pair<const int,std::pair<unsigned long,unsigned long> > 
      type_894.Unload(); // class std::pair<const int,std::pair<unsigned int,unsigned int> > 
      type_895.Unload(); // class std::pair<const int,std::pair<double,double> > 
      type_896.Unload(); // class std::pair<const int,int> 
      type_1018.Unload(); // class std::input_iterator_tag 
      type_1049.Unload(); // class std::vector<const void*> 
      type_1051.Unload(); // class std::vector<unsigned short> 
      type_1052.Unload(); // class std::vector<unsigned long> 
      type_1053.Unload(); // class std::vector<unsigned long long> 
      type_1054.Unload(); // class std::vector<unsigned int> 
      type_1055.Unload(); // class std::vector<unsigned char> 
      type_1056.Unload(); // class std::vector<unsigned char*> 
      type_1057.Unload(); // class std::vector<std::vector<unsigned short> > 
      type_1058.Unload(); // class std::vector<std::vector<unsigned int> > 
      type_1061.Unload(); // class std::vector<int> 
      type_1060.Unload(); // class std::vector<std::vector<int> > 
      type_1059.Unload(); // class std::vector<std::vector<std::vector<int> > > 
      type_1063.Unload(); // class std::vector<std::pair<int,double> > 
      type_1062.Unload(); // class std::vector<std::vector<std::pair<int,double> > > 
      type_1065.Unload(); // class std::vector<short> 
      type_1064.Unload(); // class std::vector<std::vector<short> > 
      type_1067.Unload(); // class std::vector<float> 
      type_1066.Unload(); // class std::vector<std::vector<float> > 
      type_1069.Unload(); // class std::vector<double> 
      type_1068.Unload(); // class std::vector<std::vector<double> > 
      type_1104.Unload(); // class std::basic_string<char> 
      type_1070.Unload(); // class std::vector<std::basic_string<char> > 
      type_1071.Unload(); // class std::vector<std::pair<unsigned long long,std::basic_string<char> > > 
      type_1072.Unload(); // class std::vector<std::pair<unsigned int,unsigned int> > 
      type_1073.Unload(); // class std::vector<std::pair<unsigned int,int> > 
      type_1074.Unload(); // class std::vector<std::pair<unsigned int,float> > 
      type_1075.Unload(); // class std::vector<std::pair<unsigned int,double> > 
      type_1076.Unload(); // class std::vector<std::pair<unsigned int,bool> > 
      type_1077.Unload(); // class std::vector<std::pair<std::vector<std::pair<double,std::vector<double> > >,bool> > 
      type_1078.Unload(); // class std::vector<std::pair<double,std::vector<double> > > 
      type_1079.Unload(); // class std::vector<std::pair<std::basic_string<char>,int> > 
      type_1080.Unload(); // class std::vector<std::pair<std::basic_string<char>,float> > 
      type_1081.Unload(); // class std::vector<std::pair<std::basic_string<char>,double> > 
      type_1082.Unload(); // class std::vector<std::pair<std::basic_string<char>,bool> > 
      type_1083.Unload(); // class std::vector<std::pair<int,int> > 
      type_1084.Unload(); // class std::vector<std::pair<float,float> > 
      type_1085.Unload(); // class std::vector<std::pair<double,double> > 
      type_1614.Unload(); // class std::map<short,short> 
      type_1086.Unload(); // class std::vector<std::map<short,short> > 
      type_1087.Unload(); // class std::vector<long> 
      type_1088.Unload(); // class std::vector<long long> 
      type_1089.Unload(); // class std::vector<long double> 
      type_1090.Unload(); // class std::vector<char> 
      type_1091.Unload(); // class std::vector<char*> 
      type_1092.Unload(); // class std::vector<bool> 
      type_1292.Unload(); // class std::forward_iterator_tag 
      type_1326.Unload(); // class std::random_access_iterator_tag 
      type_1339.Unload(); // class std::allocator<int> 
      type_1343.Unload(); // class std::allocator<short> 
      type_1347.Unload(); // class std::allocator<double> 
      type_1350.Unload(); // class std::allocator<char> 
      type_1585.Unload(); // class std::set<std::basic_string<char> > 
      type_1586.Unload(); // class std::set<int> 
      type_1589.Unload(); // class std::output_iterator_tag 
      type_1603.Unload(); // class std::list<int> 
      type_1615.Unload(); // class std::map<std::basic_string<char>,std::basic_string<char> > 
      type_1616.Unload(); // class std::map<unsigned short,unsigned short> 
      type_1617.Unload(); // class std::map<unsigned short,std::vector<unsigned short> > 
      type_1618.Unload(); // class std::map<unsigned short,float> 
      type_1619.Unload(); // class std::map<unsigned long,unsigned long> 
      type_1620.Unload(); // class std::map<unsigned long,std::vector<unsigned long> > 
      type_1621.Unload(); // class std::map<unsigned long long,std::basic_string<char> > 
      type_1622.Unload(); // class std::map<unsigned int,unsigned int> 
      type_1623.Unload(); // class std::map<unsigned int,std::vector<unsigned int> > 
      type_1624.Unload(); // class std::map<unsigned int,std::vector<std::pair<unsigned int,float> > > 
      type_1625.Unload(); // class std::map<unsigned int,std::vector<std::pair<unsigned int,double> > > 
      type_1626.Unload(); // class std::map<unsigned int,std::vector<std::pair<unsigned int,bool> > > 
      type_1627.Unload(); // class std::map<unsigned int,std::pair<unsigned int,unsigned int> > 
      type_1628.Unload(); // class std::map<unsigned int,std::basic_string<char> > 
      type_1629.Unload(); // class std::map<unsigned int,short> 
      type_1630.Unload(); // class std::map<unsigned int,int> 
      type_1631.Unload(); // class std::map<unsigned int,float> 
      type_1632.Unload(); // class std::map<unsigned int,double> 
      type_1633.Unload(); // class std::map<unsigned int,bool> 
      type_1634.Unload(); // class std::map<std::pair<short,short>,std::pair<short,std::vector<short> > > 
      type_1635.Unload(); // class std::map<std::pair<int,int>,int> 
      type_1636.Unload(); // class std::map<std::pair<int,int>,double> 
      type_1637.Unload(); // class std::map<std::basic_string<char>,unsigned long> 
      type_1638.Unload(); // class std::map<std::basic_string<char>,unsigned int> 
      type_1639.Unload(); // class std::map<std::basic_string<char>,std::vector<std::pair<std::basic_string<char>,double> > > 
      type_1640.Unload(); // class std::map<std::basic_string<char>,std::vector<std::basic_string<char> > > 
      type_1641.Unload(); // class std::map<std::basic_string<char>,std::pair<unsigned int,unsigned int> > 
      type_1642.Unload(); // class std::map<std::basic_string<char>,std::map<std::basic_string<char>,std::basic_string<char> > > 
      type_1643.Unload(); // class std::map<std::basic_string<char>,int> 
      type_1644.Unload(); // class std::map<std::basic_string<char>,bool> 
      type_1645.Unload(); // class std::map<short,unsigned int> 
      type_1646.Unload(); // class std::map<int,unsigned int> 
      type_1647.Unload(); // class std::map<int,std::pair<unsigned long,unsigned long> > 
      type_1648.Unload(); // class std::map<int,std::pair<unsigned int,unsigned int> > 
      type_1649.Unload(); // class std::map<int,std::pair<double,double> > 
      type_1650.Unload(); // class std::map<int,int> 
      type_1888.Unload(); // class std::deque<int> 
      type_1929.Unload(); // class std::bitset<7> 
      type_2006.Unload(); // class std::bidirectional_iterator_tag 
      type_2024.Unload(); // class std::less<int> 
      type_2039.Unload(); // class std::multimap<double,double> 
      type_2337.Unload(); // class __gnu_cxx::__normal_iterator<std::basic_string<char>*,std::vector<std::basic_string<char> > > 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
