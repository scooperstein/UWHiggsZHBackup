// Generated at Fri Feb 28 12:36:10 2014. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gccxml/20110825/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gccxml/20110825/bin/gccxml_cc1plus"
  GCCXML_CPP="/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gccxml/20110825/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='2' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='1' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.6.2"' -D__UINT64_C(c)='c ## UL' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__GNUC_MINOR__='6' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -iwrapper"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gccxml/20110825/share/gccxml-0.9/GCC/4.6" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../include/c++/4.6.2" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../include/c++/4.6.2/x86_64-unknown-linux-gnu" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../include/c++/4.6.2/backward" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/include" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/include-fixed" -isystem"/usr/local/include" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gccxml/20110825/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.6.2
Copyright (C) 2011 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "/afs/hep.wisc.edu/user/stephane/sync_setup/src/DataFormats/METReco/src/classes.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("metsig") );
  ::Reflex::NamespaceBuilder nsb2( Reflex::Literal("edm") );
  ::Reflex::NamespaceBuilder nsb3( Reflex::Literal("reco") );
  ::Reflex::NamespaceBuilder nsb4( Reflex::Literal("__gnu_cxx") );
  ::Reflex::NamespaceBuilder nsb5( Reflex::Literal("edm::reftobase") );
  ::Reflex::Type type_72 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_333 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_409 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_932 = ::Reflex::TypeBuilder(Reflex::Literal("float"));
  ::Reflex::Type type_1647 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_192 = ::Reflex::TypeBuilder(Reflex::Literal("short"));
  ::Reflex::Type type_107 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_7952 = ::Reflex::TypeBuilder(Reflex::Literal("reco::MET"));
  ::Reflex::Type type_1653 = ::Reflex::TypeBuilder(Reflex::Literal("CorrMETData"));
  ::Reflex::Type type_373 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_7918 = ::Reflex::TypeBuilder(Reflex::Literal("reco::PFMET"));
  ::Reflex::Type type_364 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_4868 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefCore"));
  ::Reflex::Type type_7970 = ::Reflex::TypeBuilder(Reflex::Literal("reco::GenMET"));
  ::Reflex::Type type_2300 = ::Reflex::TypeBuilder(Reflex::Literal("CommonMETData"));
  ::Reflex::Type type_8011 = ::Reflex::TypeBuilder(Reflex::Literal("reco::CaloMET"));
  ::Reflex::Type type_519 = ::Reflex::TypeBuilder(Reflex::Literal("std::type_info"));
  ::Reflex::Type type_87 = ::Reflex::TypeBuilder(Reflex::Literal("HcalNoiseSummary"));
  ::Reflex::Type type_4866 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ProductID"));
  ::Reflex::Type type_7934 = ::Reflex::TypeBuilder(Reflex::Literal("reco::PhiWedge"));
  ::Reflex::Type type_6560 = ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate"));
  ::Reflex::Type type_468 = ::Reflex::TypeBuilder(Reflex::Literal("SpecificPFMETData"));
  ::Reflex::Type type_3159 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<int>"));
  ::Reflex::Type type_1146 = ::Reflex::TypeBuilder(Reflex::Literal("TMatrixT<double>"));
  ::Reflex::Type type_3163 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<char>"));
  ::Reflex::Type type_7975 = ::Reflex::TypeBuilder(Reflex::Literal("reco::CSCHaloData"));
  ::Reflex::Type type_930 = ::Reflex::TypeBuilder(Reflex::Literal("SpecificCaloMETData"));
  ::Reflex::Type type_3160 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<DetId>"));
  ::Reflex::Type type_2233 = ::Reflex::TypeBuilder(Reflex::Literal("PFMEtSignCovMatrix"));
  ::Reflex::Type type_2320 = ::Reflex::TypeBuilder(Reflex::Literal("SpecificGenMETData"));
  ::Reflex::Type type_3165 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<float>"));
  ::Reflex::Type type_8033 = ::Reflex::TypeBuilder(Reflex::Literal("reco::HcalNoiseHPD"));
  ::Reflex::Type type_7916 = ::Reflex::TypeBuilder(Reflex::Literal("reco::PFClusterMET"));
  ::Reflex::Type type_4835 = ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVectorBase"));
  ::Reflex::Type type_7925 = ::Reflex::TypeBuilder(Reflex::Literal("reco::EcalHaloData"));
  ::Reflex::Type type_7923 = ::Reflex::TypeBuilder(Reflex::Literal("reco::HcalHaloData"));
  ::Reflex::Type type_7976 = ::Reflex::TypeBuilder(Reflex::Literal("reco::HcalNoiseRBX"));
  ::Reflex::Type type_1379 = ::Reflex::EnumTypeBuilder(Reflex::Literal("EcalSubdetector"));
  ::Reflex::Type type_2126 = ::Reflex::TypeBuilder(Reflex::Literal("BoundaryInformation"));
  ::Reflex::Type type_3824 = ::Reflex::TypeBuilder(Reflex::Literal("metsig::SigInputObj"));
  ::Reflex::Type type_7957 = ::Reflex::TypeBuilder(Reflex::Literal("reco::RecoCandidate"));
  ::Reflex::Type type_3171 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<double>"));
  ::Reflex::Type type_4901 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ptr<reco::MET>"));
  ::Reflex::Type type_8009 = ::Reflex::TypeBuilder(Reflex::Literal("reco::MVAMEtJetInfo"));
  ::Reflex::Type type_4912 = ::Reflex::TypeBuilder(Reflex::Literal("edm::EDProductGetter"));
  ::Reflex::Type type_7935 = ::Reflex::TypeBuilder(Reflex::Literal("reco::GlobalHaloData"));
  ::Reflex::Type type_4880 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ValueMap<float>"));
  ::Reflex::Type type_4931 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefCoreWithIndex"));
  ::Reflex::Type type_7946 = ::Reflex::TypeBuilder(Reflex::Literal("reco::BeamHaloSummary"));
  ::Reflex::Type type_1114 = ::Reflex::TypeBuilder(Reflex::Literal("AnomalousECALVariables"));
  ::Reflex::Type type_3146 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::MET>"));
  ::Reflex::Type type_7941 = ::Reflex::TypeBuilder(Reflex::Literal("reco::MVAMEtPFCandInfo"));
  ::Reflex::Type type_3161 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<EcalRecHit>"));
  ::Reflex::Type type_2652 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_4721 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<reco::MET>"));
  ::Reflex::Type type_3143 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<CorrMETData>"));
  ::Reflex::Type type_3157 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::PFMET>"));
  ::Reflex::Type type_3137 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const void*>"));
  ::Reflex::Type type_2907 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<reco::MET>"));
  ::Reflex::Type type_3416 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<reco::MET>"));
  ::Reflex::Type type_3158 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::GenMET>"));
  ::Reflex::Type type_4622 = ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVector<reco::MET>"));
  ::Reflex::Type type_3156 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned int>"));
  ::Reflex::Type type_4703 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<CorrMETData>"));
  ::Reflex::Type type_4719 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<reco::PFMET>"));
  ::Reflex::Type type_3144 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<CommonMETData>"));
  ::Reflex::Type type_3148 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::CaloMET>"));
  ::Reflex::Type type_3138 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long>"));
  ::Reflex::Type type_2882 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<CorrMETData>"));
  ::Reflex::Type type_2901 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<reco::PFMET>"));
  ::Reflex::Type type_4723 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<reco::GenMET>"));
  ::Reflex::Type type_3413 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<CorrMETData>"));
  ::Reflex::Type type_484 = ::Reflex::TypeBuilder(Reflex::Literal("Point3DBase<float,GlobalTag>"));
  ::Reflex::Type type_3150 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::PhiWedge>"));
  ::Reflex::Type type_3428 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<reco::PFMET>"));
  ::Reflex::Type type_28331 = ::Reflex::EnumTypeBuilder(Reflex::Literal("reco::HaloData::Endcap"));
  ::Reflex::Type type_2903 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<reco::GenMET>"));
  ::Reflex::Type type_4705 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<CommonMETData>"));
  ::Reflex::Type type_4725 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<reco::CaloMET>"));
  ::Reflex::Type type_3429 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<reco::GenMET>"));
  ::Reflex::Type type_4773 = ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVectorItr<reco::MET>"));
  ::Reflex::Type type_2884 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<CommonMETData>"));
  ::Reflex::Type type_2905 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<reco::CaloMET>"));
  ::Reflex::Type type_4712 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<reco::PhiWedge>"));
  ::Reflex::Type type_3414 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<CommonMETData>"));
  ::Reflex::Type type_3418 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<reco::CaloMET>"));
  ::Reflex::Type type_2891 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<reco::PhiWedge>"));
  ::Reflex::Type type_3420 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<reco::PhiWedge>"));
  ::Reflex::Type type_3151 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<SpecificPFMETData>"));
  ::Reflex::Type type_12173 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolderBase"));
  ::Reflex::Type type_4713 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<HcalNoiseSummary>"));
  ::Reflex::Type type_3153 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::HcalNoiseRBX>"));
  ::Reflex::Type type_3154 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::HcalNoiseHPD>"));
  ::Reflex::Type type_3155 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::PFClusterMET>"));
  ::Reflex::Type type_2893 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<HcalNoiseSummary>"));
  ::Reflex::Type type_2725 = ::Reflex::TypeBuilder(Reflex::Literal("std::random_access_iterator_tag"));
  ::Reflex::Type type_4709 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<reco::CSCHaloData>"));
  ::Reflex::Type type_3141 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::MVAMEtJetInfo>"));
  ::Reflex::Type type_3139 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<BoundaryInformation>"));
  ::Reflex::Type type_3142 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<metsig::SigInputObj>"));
  ::Reflex::Type type_3152 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<SpecificCaloMETData>"));
  ::Reflex::Type type_4197 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorBase<unsigned int>"));
  ::Reflex::Type type_2888 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<reco::CSCHaloData>"));
  ::Reflex::Type type_4758 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<reco::MET>"));
  ::Reflex::Type type_4697 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<PFMEtSignCovMatrix>"));
  ::Reflex::Type type_4710 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<reco::HcalHaloData>"));
  ::Reflex::Type type_4711 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<reco::EcalHaloData>"));
  ::Reflex::Type type_4717 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<reco::PFClusterMET>"));
  ::Reflex::Type type_3421 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<SpecificPFMETData>"));
  ::Reflex::Type type_2876 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<PFMEtSignCovMatrix>"));
  ::Reflex::Type type_2889 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<reco::HcalHaloData>"));
  ::Reflex::Type type_2890 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<reco::EcalHaloData>"));
  ::Reflex::Type type_2899 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<reco::PFClusterMET>"));
  ::Reflex::Type type_4695 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<BoundaryInformation>"));
  ::Reflex::Type type_4701 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<metsig::SigInputObj>"));
  ::Reflex::Type type_3425 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<reco::HcalNoiseHPD>"));
  ::Reflex::Type type_3426 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<reco::PFClusterMET>"));
  ::Reflex::Type type_2874 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<BoundaryInformation>"));
  ::Reflex::Type type_2880 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<metsig::SigInputObj>"));
  ::Reflex::Type type_4736 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<CorrMETData>"));
  ::Reflex::Type type_4752 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<reco::PFMET>"));
  ::Reflex::Type type_3424 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<reco::HcalNoiseRBX>"));
  ::Reflex::Type type_4708 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<reco::GlobalHaloData>"));
  ::Reflex::Type type_3140 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::MVAMEtPFCandInfo>"));
  ::Reflex::Type type_3409 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<BoundaryInformation>"));
  ::Reflex::Type type_3412 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<metsig::SigInputObj>"));
  ::Reflex::Type type_3422 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<SpecificCaloMETData>"));
  ::Reflex::Type type_4869 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefVectorHolderBase"));
  ::Reflex::Type type_2887 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<reco::GlobalHaloData>"));
  ::Reflex::Type type_4754 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<reco::GenMET>"));
  ::Reflex::Type type_3411 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<reco::MVAMEtJetInfo>"));
  ::Reflex::Type type_4707 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<reco::BeamHaloSummary>"));
  ::Reflex::Type type_4934 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<std::vector<reco::MET> >"));
  ::Reflex::Type type_4738 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<CommonMETData>"));
  ::Reflex::Type type_2886 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<reco::BeamHaloSummary>"));
  ::Reflex::Type type_4756 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<reco::CaloMET>"));
  ::Reflex::Type type_4696 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<AnomalousECALVariables>"));
  ::Reflex::Type type_4885 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<reco::MET> >"));
  ::Reflex::Type type_2875 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<AnomalousECALVariables>"));
  ::Reflex::Type type_4745 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<reco::PhiWedge>"));
  ::Reflex::Type type_2661 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator_traits<reco::PhiWedge*>"));
  ::Reflex::Type type_4720 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<reco::MET> >"));
  ::Reflex::Type type_2906 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<reco::MET> >"));
  ::Reflex::Type type_4933 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<std::vector<reco::PFMET> >"));
  ::Reflex::Type type_3410 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<reco::MVAMEtPFCandInfo>"));
  ::Reflex::Type type_4746 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<HcalNoiseSummary>"));
  ::Reflex::Type type_4884 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<reco::PFMET> >"));
  ::Reflex::Type type_4935 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<std::vector<reco::GenMET> >"));
  ::Reflex::Type type_4702 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<CorrMETData> >"));
  ::Reflex::Type type_4718 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<reco::PFMET> >"));
  ::Reflex::Type type_4814 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<std::vector<reco::MET> >"));
  ::Reflex::Type type_4936 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<std::vector<reco::CaloMET> >"));
  ::Reflex::Type type_2881 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<CorrMETData> >"));
  ::Reflex::Type type_4742 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<reco::CSCHaloData>"));
  ::Reflex::Type type_2900 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<reco::PFMET> >"));
  ::Reflex::Type type_4886 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<reco::GenMET> >"));
  ::Reflex::Type type_4722 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<reco::GenMET> >"));
  ::Reflex::Type type_4887 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<reco::CaloMET> >"));
  ::Reflex::Type type_4730 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<PFMEtSignCovMatrix>"));
  ::Reflex::Type type_4743 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<reco::HcalHaloData>"));
  ::Reflex::Type type_4744 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<reco::EcalHaloData>"));
  ::Reflex::Type type_4750 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<reco::PFClusterMET>"));
  ::Reflex::Type type_2902 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<reco::GenMET> >"));
  ::Reflex::Type type_4704 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<CommonMETData> >"));
  ::Reflex::Type type_4724 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<reco::CaloMET> >"));
  ::Reflex::Type type_4846 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<std::vector<reco::MET> >"));
  ::Reflex::Type type_3149 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<Point3DBase<float,GlobalTag> >"));
  ::Reflex::Type type_4728 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<BoundaryInformation>"));
  ::Reflex::Type type_4734 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<metsig::SigInputObj>"));
  ::Reflex::Type type_2883 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<CommonMETData> >"));
  ::Reflex::Type type_2904 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<reco::CaloMET> >"));
  ::Reflex::Type type_4813 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<std::vector<reco::PFMET> >"));
  ::Reflex::Type type_4741 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<reco::GlobalHaloData>"));
  ::Reflex::Type type_4815 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<std::vector<reco::GenMET> >"));
  ::Reflex::Type type_4816 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<std::vector<reco::CaloMET> >"));
  ::Reflex::Type type_4740 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<reco::BeamHaloSummary>"));
  ::Reflex::Type type_4845 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<std::vector<reco::PFMET> >"));
  ::Reflex::Type type_21290 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseHolder<reco::Candidate>"));
  ::Reflex::Type type_2897 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::reftobase::RefHolderBase>"));
  ::Reflex::Type type_3419 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<Point3DBase<float,GlobalTag> >"));
  ::Reflex::Type type_4729 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<AnomalousECALVariables>"));
  ::Reflex::Type type_4932 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Handle<std::vector<reco::PFClusterMET> >"));
  ::Reflex::Type type_4847 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<std::vector<reco::GenMET> >"));
  ::Reflex::Type type_4848 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<std::vector<reco::CaloMET> >"));
  ::Reflex::Type type_4757 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<reco::MET> >"));
  ::Reflex::Type type_4883 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefProd<std::vector<reco::PFClusterMET> >"));
  ::Reflex::Type type_4716 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<reco::PFClusterMET> >"));
  ::Reflex::Type type_4714 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<reco::HcalNoiseRBX> >"));
  ::Reflex::Type type_4715 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<reco::HcalNoiseHPD> >"));
  ::Reflex::Type type_2898 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<reco::PFClusterMET> >"));
  ::Reflex::Type type_2729 = ::Reflex::TypeBuilder(Reflex::Literal("std::set<CaloTower,reco::HcalNoiseRBX::twrcomp>"));
  ::Reflex::Type type_2667 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator_traits<const reco::HcalNoiseHPD*>"));
  ::Reflex::Type type_2894 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<reco::HcalNoiseRBX> >"));
  ::Reflex::Type type_2895 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<reco::HcalNoiseHPD> >"));
  ::Reflex::Type type_4694 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<BoundaryInformation> >"));
  ::Reflex::Type type_4700 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<metsig::SigInputObj> >"));
  ::Reflex::Type type_4699 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<reco::MVAMEtJetInfo> >"));
  ::Reflex::Type type_2873 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<BoundaryInformation> >"));
  ::Reflex::Type type_2879 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<metsig::SigInputObj> >"));
  ::Reflex::Type type_4735 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<CorrMETData> >"));
  ::Reflex::Type type_4751 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<reco::PFMET> >"));
  ::Reflex::Type type_2878 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<reco::MVAMEtJetInfo> >"));
  ::Reflex::Type type_4753 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<reco::GenMET> >"));
  ::Reflex::Type type_4812 = ::Reflex::TypeBuilder(Reflex::Literal("edm::TestHandle<std::vector<reco::PFClusterMET> >"));
  ::Reflex::Type type_4737 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<CommonMETData> >"));
  ::Reflex::Type type_4755 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<reco::CaloMET> >"));
  ::Reflex::Type type_2892 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_4698 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<reco::MVAMEtPFCandInfo> >"));
  ::Reflex::Type type_4844 = ::Reflex::TypeBuilder(Reflex::Literal("edm::OrphanHandle<std::vector<reco::PFClusterMET> >"));
  ::Reflex::Type type_2877 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<reco::MVAMEtPFCandInfo> >"));
  ::Reflex::Type type_4908 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_2618 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::MET,std::allocator<reco::MET> >"));
  ::Reflex::Type type_4749 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<reco::PFClusterMET> >"));
  ::Reflex::Type type_4747 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<reco::HcalNoiseRBX> >"));
  ::Reflex::Type type_4748 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<reco::HcalNoiseHPD> >"));
  ::Reflex::Type type_4727 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<BoundaryInformation> >"));
  ::Reflex::Type type_4733 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<metsig::SigInputObj> >"));
  ::Reflex::Type type_4732 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<reco::MVAMEtJetInfo> >"));
  ::Reflex::Type type_7269 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >"));
  ::Reflex::Type type_4706 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<Point3DBase<float,GlobalTag> > >"));
  ::Reflex::Type type_2885 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<Point3DBase<float,GlobalTag> > >"));
  ::Reflex::Type type_2619 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<CorrMETData,std::allocator<CorrMETData> >"));
  ::Reflex::Type type_2616 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::PFMET,std::allocator<reco::PFMET> >"));
  ::Reflex::Type type_4731 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<reco::MVAMEtPFCandInfo> >"));
  ::Reflex::Type type_2614 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::GenMET,std::allocator<reco::GenMET> >"));
  ::Reflex::Type type_2592 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<CommonMETData,std::allocator<CommonMETData> >"));
  ::Reflex::Type type_2617 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::CaloMET,std::allocator<reco::CaloMET> >"));
  ::Reflex::Type type_8202 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<reco::MET*,std::vector<reco::MET> >"));
  ::Reflex::Type type_2602 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::PhiWedge,std::allocator<reco::PhiWedge> >"));
  ::Reflex::Type type_2896 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::reftobase::BaseVectorHolder<reco::Candidate> >"));
  ::Reflex::Type type_4739 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<Point3DBase<float,GlobalTag> > >"));
  ::Reflex::Type type_20092 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET>"));
  ::Reflex::Type type_8204 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<CorrMETData*,std::vector<CorrMETData> >"));
  ::Reflex::Type type_8198 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<reco::PFMET*,std::vector<reco::PFMET> >"));
  ::Reflex::Type type_8203 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const reco::MET*,std::vector<reco::MET> >"));
  ::Reflex::Type type_8194 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<reco::GenMET*,std::vector<reco::GenMET> >"));
  ::Reflex::Type type_2595 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<SpecificPFMETData,std::allocator<SpecificPFMETData> >"));
  ::Reflex::Type type_20094 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET>"));
  ::Reflex::Type type_8154 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<CommonMETData*,std::vector<CommonMETData> >"));
  ::Reflex::Type type_8200 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<reco::CaloMET*,std::vector<reco::CaloMET> >"));
  ::Reflex::Type type_2611 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::HcalNoiseHPD,std::allocator<reco::HcalNoiseHPD> >"));
  ::Reflex::Type type_2615 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::PFClusterMET,std::allocator<reco::PFClusterMET> >"));
  ::Reflex::Type type_20095 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET>"));
  ::Reflex::Type type_2597 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::HcalNoiseRBX,std::allocator<reco::HcalNoiseRBX> >"));
  ::Reflex::Type type_8161 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >"));
  ::Reflex::Type type_8205 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const CorrMETData*,std::vector<CorrMETData> >"));
  ::Reflex::Type type_8199 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const reco::PFMET*,std::vector<reco::PFMET> >"));
  ::Reflex::Type type_2598 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<BoundaryInformation,std::allocator<BoundaryInformation> >"));
  ::Reflex::Type type_2591 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<metsig::SigInputObj,std::allocator<metsig::SigInputObj> >"));
  ::Reflex::Type type_20091 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET>"));
  ::Reflex::Type type_2596 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<SpecificCaloMETData,std::allocator<SpecificCaloMETData> >"));
  ::Reflex::Type type_2590 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::MVAMEtJetInfo,std::allocator<reco::MVAMEtJetInfo> >"));
  ::Reflex::Type type_20072 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefToBaseVector<reco::MET> >"));
  ::Reflex::Type type_8195 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const reco::GenMET*,std::vector<reco::GenMET> >"));
  ::Reflex::Type type_8155 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const CommonMETData*,std::vector<CommonMETData> >"));
  ::Reflex::Type type_8201 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const reco::CaloMET*,std::vector<reco::CaloMET> >"));
  ::Reflex::Type type_20070 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefToBaseVector<reco::PFMET> >"));
  ::Reflex::Type type_20074 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefToBaseVector<reco::GenMET> >"));
  ::Reflex::Type type_20076 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefToBaseVector<reco::CaloMET> >"));
  ::Reflex::Type type_8174 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const reco::PhiWedge*,std::vector<reco::PhiWedge> >"));
  ::Reflex::Type type_8162 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<SpecificPFMETData*,std::vector<SpecificPFMETData> >"));
  ::Reflex::Type type_2589 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::MVAMEtPFCandInfo,std::allocator<reco::MVAMEtPFCandInfo> >"));
  ::Reflex::Type type_8191 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >"));
  ::Reflex::Type type_8196 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<reco::PFClusterMET*,std::vector<reco::PFClusterMET> >"));
  ::Reflex::Type type_8166 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<reco::HcalNoiseRBX*,std::vector<reco::HcalNoiseRBX> >"));
  ::Reflex::Type type_8169 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<BoundaryInformation*,std::vector<BoundaryInformation> >"));
  ::Reflex::Type type_8152 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<metsig::SigInputObj*,std::vector<metsig::SigInputObj> >"));
  ::Reflex::Type type_8164 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<SpecificCaloMETData*,std::vector<SpecificCaloMETData> >"));
  ::Reflex::Type type_8150 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<reco::MVAMEtJetInfo*,std::vector<reco::MVAMEtJetInfo> >"));
  ::Reflex::Type type_20093 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET>"));
  ::Reflex::Type type_20068 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefToBaseVector<reco::PFClusterMET> >"));
  ::Reflex::Type type_8163 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const SpecificPFMETData*,std::vector<SpecificPFMETData> >"));
  ::Reflex::Type type_8190 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >"));
  ::Reflex::Type type_3656 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<reco::MET*,std::vector<reco::MET> > >"));
  ::Reflex::Type type_8197 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const reco::PFClusterMET*,std::vector<reco::PFClusterMET> >"));
  ::Reflex::Type type_8167 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const reco::HcalNoiseRBX*,std::vector<reco::HcalNoiseRBX> >"));
  ::Reflex::Type type_8170 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const BoundaryInformation*,std::vector<BoundaryInformation> >"));
  ::Reflex::Type type_8153 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const metsig::SigInputObj*,std::vector<metsig::SigInputObj> >"));
  ::Reflex::Type type_8165 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const SpecificCaloMETData*,std::vector<SpecificCaloMETData> >"));
  ::Reflex::Type type_8148 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<reco::MVAMEtPFCandInfo*,std::vector<reco::MVAMEtPFCandInfo> >"));
  ::Reflex::Type type_8151 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const reco::MVAMEtJetInfo*,std::vector<reco::MVAMEtJetInfo> >"));
  ::Reflex::Type type_3658 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<CorrMETData*,std::vector<CorrMETData> > >"));
  ::Reflex::Type type_3652 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<reco::PFMET*,std::vector<reco::PFMET> > >"));
  ::Reflex::Type type_3655 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const reco::MET*,std::vector<reco::MET> > >"));
  ::Reflex::Type type_2605 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<Point3DBase<float,GlobalTag>,std::allocator<Point3DBase<float,GlobalTag> > >"));
  ::Reflex::Type type_3648 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<reco::GenMET*,std::vector<reco::GenMET> > >"));
  ::Reflex::Type type_3602 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<CommonMETData*,std::vector<CommonMETData> > >"));
  ::Reflex::Type type_3654 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<reco::CaloMET*,std::vector<reco::CaloMET> > >"));
  ::Reflex::Type type_8149 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const reco::MVAMEtPFCandInfo*,std::vector<reco::MVAMEtPFCandInfo> >"));
  ::Reflex::Type type_3657 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const CorrMETData*,std::vector<CorrMETData> > >"));
  ::Reflex::Type type_3622 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> > >"));
  ::Reflex::Type type_3651 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const reco::PFMET*,std::vector<reco::PFMET> > >"));
  ::Reflex::Type type_7287 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>"));
  ::Reflex::Type type_3647 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const reco::GenMET*,std::vector<reco::GenMET> > >"));
  ::Reflex::Type type_3601 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const CommonMETData*,std::vector<CommonMETData> > >"));
  ::Reflex::Type type_3653 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const reco::CaloMET*,std::vector<reco::CaloMET> > >"));
  ::Reflex::Type type_8178 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<Point3DBase<float,GlobalTag>*,std::vector<Point3DBase<float,GlobalTag> > >"));
  ::Reflex::Type type_3621 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const reco::PhiWedge*,std::vector<reco::PhiWedge> > >"));
  ::Reflex::Type type_3608 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<SpecificPFMETData*,std::vector<SpecificPFMETData> > >"));
  ::Reflex::Type type_3640 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> > >"));
  ::Reflex::Type type_3650 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<reco::PFClusterMET*,std::vector<reco::PFClusterMET> > >"));
  ::Reflex::Type type_3612 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<reco::HcalNoiseRBX*,std::vector<reco::HcalNoiseRBX> > >"));
  ::Reflex::Type type_3614 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<BoundaryInformation*,std::vector<BoundaryInformation> > >"));
  ::Reflex::Type type_3600 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<metsig::SigInputObj*,std::vector<metsig::SigInputObj> > >"));
  ::Reflex::Type type_3610 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<SpecificCaloMETData*,std::vector<SpecificCaloMETData> > >"));
  ::Reflex::Type type_3598 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<reco::MVAMEtJetInfo*,std::vector<reco::MVAMEtJetInfo> > >"));
  ::Reflex::Type type_8179 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const Point3DBase<float,GlobalTag>*,std::vector<Point3DBase<float,GlobalTag> > >"));
  ::Reflex::Type type_4913 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >"));
  ::Reflex::Type type_3607 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const SpecificPFMETData*,std::vector<SpecificPFMETData> > >"));
  ::Reflex::Type type_3639 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> > >"));
  ::Reflex::Type type_3649 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const reco::PFClusterMET*,std::vector<reco::PFClusterMET> > >"));
  ::Reflex::Type type_3611 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const reco::HcalNoiseRBX*,std::vector<reco::HcalNoiseRBX> > >"));
  ::Reflex::Type type_3613 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const BoundaryInformation*,std::vector<BoundaryInformation> > >"));
  ::Reflex::Type type_3599 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const metsig::SigInputObj*,std::vector<metsig::SigInputObj> > >"));
  ::Reflex::Type type_3609 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const SpecificCaloMETData*,std::vector<SpecificCaloMETData> > >"));
  ::Reflex::Type type_3596 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<reco::MVAMEtPFCandInfo*,std::vector<reco::MVAMEtPFCandInfo> > >"));
  ::Reflex::Type type_3597 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const reco::MVAMEtJetInfo*,std::vector<reco::MVAMEtJetInfo> > >"));
  ::Reflex::Type type_4641 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >"));
  ::Reflex::Type type_4916 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >"));
  ::Reflex::Type type_3595 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const reco::MVAMEtPFCandInfo*,std::vector<reco::MVAMEtPFCandInfo> > >"));
  ::Reflex::Type type_4917 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >"));
  ::Reflex::Type type_3145 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >"));
  ::Reflex::Type type_4636 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >"));
  ::Reflex::Type type_4604 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorIterator<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >"));
  ::Reflex::Type type_4657 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> >"));
  ::Reflex::Type type_4914 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >"));
  ::Reflex::Type type_3415 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >"));
  ::Reflex::Type type_3628 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<Point3DBase<float,GlobalTag>*,std::vector<Point3DBase<float,GlobalTag> > > >"));
  ::Reflex::Type type_4646 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >"));
  ::Reflex::Type type_4630 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<std::vector<reco::CaloJet>,reco::CaloJet,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloJet>,reco::CaloJet> >"));
  ::Reflex::Type type_4651 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >"));
  ::Reflex::Type type_4603 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorIterator<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >"));
  ::Reflex::Type type_3627 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const Point3DBase<float,GlobalTag>*,std::vector<Point3DBase<float,GlobalTag> > > >"));
  ::Reflex::Type type_4605 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorIterator<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >"));
  ::Reflex::Type type_21297 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >"));
  ::Reflex::Type type_3147 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >"));
  ::Reflex::Type type_4606 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorIterator<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >"));
  ::Reflex::Type type_3417 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >"));
  ::Reflex::Type type_4915 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >"));
  ::Reflex::Type type_21294 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >"));
  ::Reflex::Type type_21295 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >"));
  ::Reflex::Type type_4631 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >"));
  ::Reflex::Type type_4656 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<std::vector<reco::SuperCluster>,reco::SuperCluster,edm::refhelper::FindUsingAdvance<std::vector<reco::SuperCluster>,reco::SuperCluster> >"));
  ::Reflex::Type type_21304 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >"));
  ::Reflex::Type type_21296 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >"));
  ::Reflex::Type type_4602 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVectorIterator<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >"));
  ::Reflex::Type type_21303 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >"));
  ::Reflex::Type type_20073 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >"));
  ::Reflex::Type type_21305 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >"));
  ::Reflex::Type type_21306 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >"));
  ::Reflex::Type type_20071 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >"));
  ::Reflex::Type type_20075 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >"));
  ::Reflex::Type type_21293 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >"));
  ::Reflex::Type type_20077 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >"));
  ::Reflex::Type type_21302 = ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >"));
  ::Reflex::Type type_20069 = ::Reflex::TypeBuilder(Reflex::Literal("edm::refhelper::FindRefVectorUsingAdvance<edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >"));
  ::Reflex::Type type_1948 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<edm::SortedCollection<CaloTower,edm::StrictWeakOrdering<CaloTower> >,CaloTower,edm::refhelper::FindUsingAdvance<edm::SortedCollection<CaloTower,edm::StrictWeakOrdering<CaloTower> >,CaloTower> >"));
  ::Reflex::Type type_4675 = ::Reflex::TypeBuilder(Reflex::Literal("edm::RefVector<edm::SortedCollection<HBHERecHit,edm::StrictWeakOrdering<HBHERecHit> >,HBHERecHit,edm::refhelper::FindUsingAdvance<edm::SortedCollection<HBHERecHit,edm::StrictWeakOrdering<HBHERecHit> >,HBHERecHit> >"));
  ::Reflex::Type type_2730 = ::Reflex::TypeBuilder(Reflex::Literal("std::set<edm::Ref<edm::SortedCollection<HBHERecHit,edm::StrictWeakOrdering<HBHERecHit> >,HBHERecHit,edm::refhelper::FindUsingAdvance<edm::SortedCollection<HBHERecHit,edm::StrictWeakOrdering<HBHERecHit> >,HBHERecHit> >,reco::RefHBHERecHitEnergyComparison>"));
  ::Reflex::Type type_2593 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >,std::allocator<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > >"));
  ::Reflex::Type type_8156 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*,std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > >"));
  ::Reflex::Type type_8157 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*,std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > >"));
  ::Reflex::Type type_2594 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >,std::allocator<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > >"));
  ::Reflex::Type type_3604 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*,std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > > >"));
  ::Reflex::Type type_3603 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*,std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > > >"));
  ::Reflex::Type type_8158 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*,std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > >"));
  ::Reflex::Type type_8159 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*,std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > >"));
  ::Reflex::Type type_3606 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*,std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > > >"));
  ::Reflex::Type type_3605 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*,std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > > >"));
  ::Reflex::Type type_7920 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::MVAMEtPFCandInfoCollection"), type_3140);
  ::Reflex::Type type_7927 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::HcalNoiseRBXCollection"), type_3153);
  ::Reflex::Type type_7959 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::HcalNoiseHPDCollection"), type_3154);
  ::Reflex::Type type_8001 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::MVAMEtJetInfoCollection"), type_3141);
  ::Reflex::Type type_13895 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<reco::PhiWedge>::iterator"), type_8161);
  ::Reflex::Type type_14154 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<reco::HcalNoiseHPD>::const_iterator"), type_8190);
  ::Reflex::Type type_19717 = ::Reflex::ReferenceBuilder(type_87);
  ::Reflex::Type type_87c = ::Reflex::ConstBuilder(type_87);
  ::Reflex::Type type_19718 = ::Reflex::ReferenceBuilder(type_87c);
  ::Reflex::Type type_13956 = ::Reflex::ReferenceBuilder(type_468);
  ::Reflex::Type type_468c = ::Reflex::ConstBuilder(type_468);
  ::Reflex::Type type_13958 = ::Reflex::ReferenceBuilder(type_468c);
  ::Reflex::Type type_14021 = ::Reflex::ReferenceBuilder(type_930);
  ::Reflex::Type type_930c = ::Reflex::ConstBuilder(type_930);
  ::Reflex::Type type_14023 = ::Reflex::ReferenceBuilder(type_930c);
  ::Reflex::Type type_26091 = ::Reflex::ReferenceBuilder(type_1114);
  ::Reflex::Type type_1114c = ::Reflex::ConstBuilder(type_1114);
  ::Reflex::Type type_26092 = ::Reflex::ReferenceBuilder(type_1114c);
  ::Reflex::Type type_13438 = ::Reflex::ReferenceBuilder(type_1653);
  ::Reflex::Type type_1653c = ::Reflex::ConstBuilder(type_1653);
  ::Reflex::Type type_13440 = ::Reflex::ReferenceBuilder(type_1653c);
  ::Reflex::Type type_13178 = ::Reflex::ReferenceBuilder(type_2126);
  ::Reflex::Type type_2126c = ::Reflex::ConstBuilder(type_2126);
  ::Reflex::Type type_13180 = ::Reflex::ReferenceBuilder(type_2126c);
  ::Reflex::Type type_30557 = ::Reflex::ReferenceBuilder(type_2233);
  ::Reflex::Type type_2233c = ::Reflex::ConstBuilder(type_2233);
  ::Reflex::Type type_30558 = ::Reflex::ReferenceBuilder(type_2233c);
  ::Reflex::Type type_1147 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("TMatrixD"), type_1146);
  ::Reflex::Type type_1147c = ::Reflex::ConstBuilder(type_1147);
  ::Reflex::Type type_30559 = ::Reflex::ReferenceBuilder(type_1147c);
  ::Reflex::Type type_10341 = ::Reflex::ReferenceBuilder(type_107);
  ::Reflex::Type type_13503 = ::Reflex::ReferenceBuilder(type_2300);
  ::Reflex::Type type_2300c = ::Reflex::ConstBuilder(type_2300);
  ::Reflex::Type type_13505 = ::Reflex::ReferenceBuilder(type_2300c);
  ::Reflex::Type type_31494 = ::Reflex::ReferenceBuilder(type_2320);
  ::Reflex::Type type_2320c = ::Reflex::ConstBuilder(type_2320);
  ::Reflex::Type type_31495 = ::Reflex::ReferenceBuilder(type_2320c);
  ::Reflex::Type type_13174 = ::Reflex::PointerBuilder(type_2126);
  ::Reflex::Type type_13176 = ::Reflex::PointerBuilder(type_2126c);
  ::Reflex::Type type_3394 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_364);
  ::Reflex::Type type_3290 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_333);
  ::Reflex::Type type_3409c = ::Reflex::ConstBuilder(type_3409);
  ::Reflex::Type type_31705 = ::Reflex::ReferenceBuilder(type_3409c);
  ::Reflex::Type type_3139c = ::Reflex::ConstBuilder(type_3139);
  ::Reflex::Type type_32792 = ::Reflex::ReferenceBuilder(type_3139c);
  ::Reflex::Type type_32793 = ::Reflex::ReferenceBuilder(type_3139);
  ::Reflex::Type type_2653 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::string"), type_2652);
  ::Reflex::Type type_13373 = ::Reflex::ReferenceBuilder(type_3824);
  ::Reflex::Type type_3824c = ::Reflex::ConstBuilder(type_3824);
  ::Reflex::Type type_13375 = ::Reflex::ReferenceBuilder(type_3824c);
  ::Reflex::Type type_2653c = ::Reflex::ConstBuilder(type_2653);
  ::Reflex::Type type_16951 = ::Reflex::ReferenceBuilder(type_2653c);
  ::Reflex::Type type_13369 = ::Reflex::PointerBuilder(type_3824);
  ::Reflex::Type type_13371 = ::Reflex::PointerBuilder(type_3824c);
  ::Reflex::Type type_3412c = ::Reflex::ConstBuilder(type_3412);
  ::Reflex::Type type_31621 = ::Reflex::ReferenceBuilder(type_3412c);
  ::Reflex::Type type_3142c = ::Reflex::ConstBuilder(type_3142);
  ::Reflex::Type type_32801 = ::Reflex::ReferenceBuilder(type_3142c);
  ::Reflex::Type type_32802 = ::Reflex::ReferenceBuilder(type_3142);
  ::Reflex::Type type_13434 = ::Reflex::PointerBuilder(type_1653);
  ::Reflex::Type type_13436 = ::Reflex::PointerBuilder(type_1653c);
  ::Reflex::Type type_3413c = ::Reflex::ConstBuilder(type_3413);
  ::Reflex::Type type_31957 = ::Reflex::ReferenceBuilder(type_3413c);
  ::Reflex::Type type_3143c = ::Reflex::ConstBuilder(type_3143);
  ::Reflex::Type type_32804 = ::Reflex::ReferenceBuilder(type_3143c);
  ::Reflex::Type type_32805 = ::Reflex::ReferenceBuilder(type_3143);
  ::Reflex::Type type_13499 = ::Reflex::PointerBuilder(type_2300);
  ::Reflex::Type type_13501 = ::Reflex::PointerBuilder(type_2300c);
  ::Reflex::Type type_3414c = ::Reflex::ConstBuilder(type_3414);
  ::Reflex::Type type_31633 = ::Reflex::ReferenceBuilder(type_3414c);
  ::Reflex::Type type_3144c = ::Reflex::ConstBuilder(type_3144);
  ::Reflex::Type type_32807 = ::Reflex::ReferenceBuilder(type_3144c);
  ::Reflex::Type type_32808 = ::Reflex::ReferenceBuilder(type_3144);
  ::Reflex::Type type_13633 = ::Reflex::ReferenceBuilder(type_7952);
  ::Reflex::Type type_7952c = ::Reflex::ConstBuilder(type_7952);
  ::Reflex::Type type_13635 = ::Reflex::ReferenceBuilder(type_7952c);
  ::Reflex::Type type_7270 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("math::XYZTLorentzVectorD"), type_7269);
  ::Reflex::Type type_7319 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("math::XYZTLorentzVector"), type_7270);
  ::Reflex::Type type_7319c = ::Reflex::ConstBuilder(type_7319);
  ::Reflex::Type type_39102 = ::Reflex::ReferenceBuilder(type_7319c);
  ::Reflex::Type type_7300 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("math::XYZPointD"), type_7287);
  ::Reflex::Type type_7288 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("math::XYZPoint"), type_7300);
  ::Reflex::Type type_7288c = ::Reflex::ConstBuilder(type_7288);
  ::Reflex::Type type_39103 = ::Reflex::ReferenceBuilder(type_7288c);
  ::Reflex::Type type_13629 = ::Reflex::PointerBuilder(type_7952);
  ::Reflex::Type type_13568 = ::Reflex::ReferenceBuilder(type_4913);
  ::Reflex::Type type_4913c = ::Reflex::ConstBuilder(type_4913);
  ::Reflex::Type type_13570 = ::Reflex::ReferenceBuilder(type_4913c);
  ::Reflex::Type type_4934c = ::Reflex::ConstBuilder(type_4934);
  ::Reflex::Type type_34357 = ::Reflex::ReferenceBuilder(type_4934c);
  ::Reflex::Type type_4846c = ::Reflex::ConstBuilder(type_4846);
  ::Reflex::Type type_34358 = ::Reflex::ReferenceBuilder(type_4846c);
  ::Reflex::Type type_4641c = ::Reflex::ConstBuilder(type_4641);
  ::Reflex::Type type_33834 = ::Reflex::ReferenceBuilder(type_4641c);
  ::Reflex::Type type_3146c = ::Reflex::ConstBuilder(type_3146);
  ::Reflex::Type type_33835 = ::Reflex::PointerBuilder(type_3146c);
  ::Reflex::Type type_4814c = ::Reflex::ConstBuilder(type_4814);
  ::Reflex::Type type_34359 = ::Reflex::ReferenceBuilder(type_4814c);
  ::Reflex::Type type_4866c = ::Reflex::ConstBuilder(type_4866);
  ::Reflex::Type type_19738 = ::Reflex::ReferenceBuilder(type_4866c);
  ::Reflex::Type type_4912c = ::Reflex::ConstBuilder(type_4912);
  ::Reflex::Type type_19828 = ::Reflex::PointerBuilder(type_4912c);
  ::Reflex::Type type_13631 = ::Reflex::PointerBuilder(type_7952c);
  ::Reflex::Type type_4885c = ::Reflex::ConstBuilder(type_4885);
  ::Reflex::Type type_34356 = ::Reflex::ReferenceBuilder(type_4885c);
  ::Reflex::Type type_4868c = ::Reflex::ConstBuilder(type_4868);
  ::Reflex::Type type_21396 = ::Reflex::ReferenceBuilder(type_4868c);
  ::Reflex::Type type_373c = ::Reflex::ConstBuilder(type_373);
  ::Reflex::Type type_10352 = ::Reflex::ReferenceBuilder(type_373c);
  ::Reflex::Type type_13564 = ::Reflex::PointerBuilder(type_4913);
  ::Reflex::Type type_13566 = ::Reflex::PointerBuilder(type_4913c);
  ::Reflex::Type type_3415c = ::Reflex::ConstBuilder(type_3415);
  ::Reflex::Type type_31645 = ::Reflex::ReferenceBuilder(type_3415c);
  ::Reflex::Type type_3145c = ::Reflex::ConstBuilder(type_3145);
  ::Reflex::Type type_32810 = ::Reflex::ReferenceBuilder(type_3145c);
  ::Reflex::Type type_32811 = ::Reflex::ReferenceBuilder(type_3145);
  ::Reflex::Type type_3416c = ::Reflex::ConstBuilder(type_3416);
  ::Reflex::Type type_31945 = ::Reflex::ReferenceBuilder(type_3416c);
  ::Reflex::Type type_23204 = ::Reflex::ReferenceBuilder(type_3146c);
  ::Reflex::Type type_32813 = ::Reflex::ReferenceBuilder(type_3146);
  ::Reflex::Type type_13763 = ::Reflex::ReferenceBuilder(type_8011);
  ::Reflex::Type type_8011c = ::Reflex::ConstBuilder(type_8011);
  ::Reflex::Type type_13765 = ::Reflex::ReferenceBuilder(type_8011c);
  ::Reflex::Type type_13698 = ::Reflex::ReferenceBuilder(type_4914);
  ::Reflex::Type type_4914c = ::Reflex::ConstBuilder(type_4914);
  ::Reflex::Type type_13700 = ::Reflex::ReferenceBuilder(type_4914c);
  ::Reflex::Type type_4936c = ::Reflex::ConstBuilder(type_4936);
  ::Reflex::Type type_34367 = ::Reflex::ReferenceBuilder(type_4936c);
  ::Reflex::Type type_4848c = ::Reflex::ConstBuilder(type_4848);
  ::Reflex::Type type_34368 = ::Reflex::ReferenceBuilder(type_4848c);
  ::Reflex::Type type_4651c = ::Reflex::ConstBuilder(type_4651);
  ::Reflex::Type type_33844 = ::Reflex::ReferenceBuilder(type_4651c);
  ::Reflex::Type type_3148c = ::Reflex::ConstBuilder(type_3148);
  ::Reflex::Type type_33845 = ::Reflex::PointerBuilder(type_3148c);
  ::Reflex::Type type_4816c = ::Reflex::ConstBuilder(type_4816);
  ::Reflex::Type type_34369 = ::Reflex::ReferenceBuilder(type_4816c);
  ::Reflex::Type type_13761 = ::Reflex::PointerBuilder(type_8011c);
  ::Reflex::Type type_4887c = ::Reflex::ConstBuilder(type_4887);
  ::Reflex::Type type_34366 = ::Reflex::ReferenceBuilder(type_4887c);
  ::Reflex::Type type_13694 = ::Reflex::PointerBuilder(type_4914);
  ::Reflex::Type type_13696 = ::Reflex::PointerBuilder(type_4914c);
  ::Reflex::Type type_3417c = ::Reflex::ConstBuilder(type_3417);
  ::Reflex::Type type_31657 = ::Reflex::ReferenceBuilder(type_3417c);
  ::Reflex::Type type_3147c = ::Reflex::ConstBuilder(type_3147);
  ::Reflex::Type type_32815 = ::Reflex::ReferenceBuilder(type_3147c);
  ::Reflex::Type type_32816 = ::Reflex::ReferenceBuilder(type_3147);
  ::Reflex::Type type_13759 = ::Reflex::PointerBuilder(type_8011);
  ::Reflex::Type type_3418c = ::Reflex::ConstBuilder(type_3418);
  ::Reflex::Type type_31933 = ::Reflex::ReferenceBuilder(type_3418c);
  ::Reflex::Type type_23226 = ::Reflex::ReferenceBuilder(type_3148c);
  ::Reflex::Type type_32818 = ::Reflex::ReferenceBuilder(type_3148);
  ::Reflex::Type type_13824 = ::Reflex::PointerBuilder(type_484);
  ::Reflex::Type type_484c = ::Reflex::ConstBuilder(type_484);
  ::Reflex::Type type_13826 = ::Reflex::PointerBuilder(type_484c);
  ::Reflex::Type type_13828 = ::Reflex::ReferenceBuilder(type_484);
  ::Reflex::Type type_13830 = ::Reflex::ReferenceBuilder(type_484c);
  ::Reflex::Type type_3419c = ::Reflex::ConstBuilder(type_3419);
  ::Reflex::Type type_31789 = ::Reflex::ReferenceBuilder(type_3419c);
  ::Reflex::Type type_3149c = ::Reflex::ConstBuilder(type_3149);
  ::Reflex::Type type_32820 = ::Reflex::ReferenceBuilder(type_3149c);
  ::Reflex::Type type_32821 = ::Reflex::ReferenceBuilder(type_3149);
  ::Reflex::Type type_10299 = ::Reflex::ReferenceBuilder(type_7934);
  ::Reflex::Type type_7934c = ::Reflex::ConstBuilder(type_7934);
  ::Reflex::Type type_13893 = ::Reflex::ReferenceBuilder(type_7934c);
  ::Reflex::Type type_10297 = ::Reflex::PointerBuilder(type_7934);
  ::Reflex::Type type_13890 = ::Reflex::PointerBuilder(type_7934c);
  ::Reflex::Type type_3420c = ::Reflex::ConstBuilder(type_3420);
  ::Reflex::Type type_31753 = ::Reflex::ReferenceBuilder(type_3420c);
  ::Reflex::Type type_3150c = ::Reflex::ConstBuilder(type_3150);
  ::Reflex::Type type_32823 = ::Reflex::ReferenceBuilder(type_3150c);
  ::Reflex::Type type_32824 = ::Reflex::ReferenceBuilder(type_3150);
  ::Reflex::Type type_13952 = ::Reflex::PointerBuilder(type_468);
  ::Reflex::Type type_13954 = ::Reflex::PointerBuilder(type_468c);
  ::Reflex::Type type_3421c = ::Reflex::ConstBuilder(type_3421);
  ::Reflex::Type type_31669 = ::Reflex::ReferenceBuilder(type_3421c);
  ::Reflex::Type type_3151c = ::Reflex::ConstBuilder(type_3151);
  ::Reflex::Type type_32826 = ::Reflex::ReferenceBuilder(type_3151c);
  ::Reflex::Type type_32827 = ::Reflex::ReferenceBuilder(type_3151);
  ::Reflex::Type type_14017 = ::Reflex::PointerBuilder(type_930);
  ::Reflex::Type type_14019 = ::Reflex::PointerBuilder(type_930c);
  ::Reflex::Type type_3422c = ::Reflex::ConstBuilder(type_3422);
  ::Reflex::Type type_31681 = ::Reflex::ReferenceBuilder(type_3422c);
  ::Reflex::Type type_3152c = ::Reflex::ConstBuilder(type_3152);
  ::Reflex::Type type_32829 = ::Reflex::ReferenceBuilder(type_3152c);
  ::Reflex::Type type_32830 = ::Reflex::ReferenceBuilder(type_3152);
  ::Reflex::Type type_14150 = ::Reflex::ReferenceBuilder(type_8033);
  ::Reflex::Type type_8033c = ::Reflex::ConstBuilder(type_8033);
  ::Reflex::Type type_10363 = ::Reflex::ReferenceBuilder(type_8033c);
  ::Reflex::Type type_3165c = ::Reflex::ConstBuilder(type_3165);
  ::Reflex::Type type_4675c = ::Reflex::ConstBuilder(type_4675);
  ::Reflex::Type type_1948c = ::Reflex::ConstBuilder(type_1948);
  ::Reflex::Type type_14147 = ::Reflex::PointerBuilder(type_8033);
  ::Reflex::Type type_10361 = ::Reflex::PointerBuilder(type_8033c);
  ::Reflex::Type type_3425c = ::Reflex::ConstBuilder(type_3425);
  ::Reflex::Type type_31861 = ::Reflex::ReferenceBuilder(type_3425c);
  ::Reflex::Type type_3154c = ::Reflex::ConstBuilder(type_3154);
  ::Reflex::Type type_32834 = ::Reflex::ReferenceBuilder(type_3154c);
  ::Reflex::Type type_32835 = ::Reflex::ReferenceBuilder(type_3154);
  ::Reflex::Type type_14214 = ::Reflex::ReferenceBuilder(type_7916);
  ::Reflex::Type type_7916c = ::Reflex::ConstBuilder(type_7916);
  ::Reflex::Type type_14216 = ::Reflex::ReferenceBuilder(type_7916c);
  ::Reflex::Type type_14210 = ::Reflex::PointerBuilder(type_7916);
  ::Reflex::Type type_14212 = ::Reflex::PointerBuilder(type_7916c);
  ::Reflex::Type type_3426c = ::Reflex::ConstBuilder(type_3426);
  ::Reflex::Type type_31909 = ::Reflex::ReferenceBuilder(type_3426c);
  ::Reflex::Type type_3155c = ::Reflex::ConstBuilder(type_3155);
  ::Reflex::Type type_23182 = ::Reflex::ReferenceBuilder(type_3155c);
  ::Reflex::Type type_32837 = ::Reflex::ReferenceBuilder(type_3155);
  ::Reflex::Type type_14341 = ::Reflex::ReferenceBuilder(type_7918);
  ::Reflex::Type type_7918c = ::Reflex::ConstBuilder(type_7918);
  ::Reflex::Type type_14343 = ::Reflex::ReferenceBuilder(type_7918c);
  ::Reflex::Type type_14337 = ::Reflex::PointerBuilder(type_7918);
  ::Reflex::Type type_14339 = ::Reflex::PointerBuilder(type_7918c);
  ::Reflex::Type type_3428c = ::Reflex::ConstBuilder(type_3428);
  ::Reflex::Type type_31921 = ::Reflex::ReferenceBuilder(type_3428c);
  ::Reflex::Type type_3157c = ::Reflex::ConstBuilder(type_3157);
  ::Reflex::Type type_23193 = ::Reflex::ReferenceBuilder(type_3157c);
  ::Reflex::Type type_32841 = ::Reflex::ReferenceBuilder(type_3157);
  ::Reflex::Type type_14406 = ::Reflex::ReferenceBuilder(type_7970);
  ::Reflex::Type type_7970c = ::Reflex::ConstBuilder(type_7970);
  ::Reflex::Type type_14408 = ::Reflex::ReferenceBuilder(type_7970c);
  ::Reflex::Type type_14402 = ::Reflex::PointerBuilder(type_7970);
  ::Reflex::Type type_14404 = ::Reflex::PointerBuilder(type_7970c);
  ::Reflex::Type type_3429c = ::Reflex::ConstBuilder(type_3429);
  ::Reflex::Type type_31897 = ::Reflex::ReferenceBuilder(type_3429c);
  ::Reflex::Type type_3158c = ::Reflex::ConstBuilder(type_3158);
  ::Reflex::Type type_23215 = ::Reflex::ReferenceBuilder(type_3158c);
  ::Reflex::Type type_32843 = ::Reflex::ReferenceBuilder(type_3158);
  ::Reflex::Type type_4622c = ::Reflex::ConstBuilder(type_4622);
  ::Reflex::Type type_33810 = ::Reflex::ReferenceBuilder(type_4622c);
  ::Reflex::Type type_364c = ::Reflex::ConstBuilder(type_364);
  ::Reflex::Type type_4901c = ::Reflex::ConstBuilder(type_4901);
  ::Reflex::Type type_33811 = ::Reflex::ReferenceBuilder(type_4901c);
  ::Reflex::Type type_33812 = ::Reflex::ReferenceBuilder(type_4622);
  ::Reflex::Type type_19832 = ::Reflex::ReferenceBuilder(type_3137);
  ::Reflex::Type type_4915c = ::Reflex::ConstBuilder(type_4915);
  ::Reflex::Type type_4631c = ::Reflex::ConstBuilder(type_4631);
  ::Reflex::Type type_33823 = ::Reflex::ReferenceBuilder(type_4631c);
  ::Reflex::Type type_33824 = ::Reflex::ReferenceBuilder(type_4915c);
  ::Reflex::Type type_4197c = ::Reflex::ConstBuilder(type_4197);
  ::Reflex::Type type_19827 = ::Reflex::ReferenceBuilder(type_4197c);
  ::Reflex::Type type_33825 = ::Reflex::PointerBuilder(type_3155c);
  ::Reflex::Type type_4602c = ::Reflex::ConstBuilder(type_4602);
  ::Reflex::Type type_33826 = ::Reflex::ReferenceBuilder(type_4602c);
  ::Reflex::Type type_33827 = ::Reflex::ReferenceBuilder(type_4631);
  ::Reflex::Type type_4870 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::helper_vector"), type_4869);
  ::Reflex::Type type_19833 = ::Reflex::ReferenceBuilder(type_4870);
  ::Reflex::Type type_4916c = ::Reflex::ConstBuilder(type_4916);
  ::Reflex::Type type_4636c = ::Reflex::ConstBuilder(type_4636);
  ::Reflex::Type type_33829 = ::Reflex::ReferenceBuilder(type_4636c);
  ::Reflex::Type type_33830 = ::Reflex::ReferenceBuilder(type_4916c);
  ::Reflex::Type type_33831 = ::Reflex::PointerBuilder(type_3157c);
  ::Reflex::Type type_4603c = ::Reflex::ConstBuilder(type_4603);
  ::Reflex::Type type_33832 = ::Reflex::ReferenceBuilder(type_4603c);
  ::Reflex::Type type_33833 = ::Reflex::ReferenceBuilder(type_4636);
  ::Reflex::Type type_4604c = ::Reflex::ConstBuilder(type_4604);
  ::Reflex::Type type_33836 = ::Reflex::ReferenceBuilder(type_4604c);
  ::Reflex::Type type_33837 = ::Reflex::ReferenceBuilder(type_4641);
  ::Reflex::Type type_4917c = ::Reflex::ConstBuilder(type_4917);
  ::Reflex::Type type_4646c = ::Reflex::ConstBuilder(type_4646);
  ::Reflex::Type type_33839 = ::Reflex::ReferenceBuilder(type_4646c);
  ::Reflex::Type type_33840 = ::Reflex::ReferenceBuilder(type_4917c);
  ::Reflex::Type type_33841 = ::Reflex::PointerBuilder(type_3158c);
  ::Reflex::Type type_4605c = ::Reflex::ConstBuilder(type_4605);
  ::Reflex::Type type_33842 = ::Reflex::ReferenceBuilder(type_4605c);
  ::Reflex::Type type_33843 = ::Reflex::ReferenceBuilder(type_4646);
  ::Reflex::Type type_4606c = ::Reflex::ConstBuilder(type_4606);
  ::Reflex::Type type_33846 = ::Reflex::ReferenceBuilder(type_4606c);
  ::Reflex::Type type_33847 = ::Reflex::ReferenceBuilder(type_4651);
  ::Reflex::Type type_33876 = ::Reflex::PointerBuilder(type_3139c);
  ::Reflex::Type type_519c = ::Reflex::ConstBuilder(type_519);
  ::Reflex::Type type_4589 = ::Reflex::ReferenceBuilder(type_519c);
  ::Reflex::Type type_33877 = ::Reflex::PointerBuilder(type_3139);
  ::Reflex::Type type_4727c = ::Reflex::ConstBuilder(type_4727);
  ::Reflex::Type type_33878 = ::Reflex::PointerBuilder(type_4727c);
  ::Reflex::Type type_33879 = ::Reflex::ReferenceBuilder(type_4908);
  ::Reflex::Type type_409c = ::Reflex::ConstBuilder(type_409);
  ::Reflex::Type type_4239 = ::Reflex::PointerBuilder(type_409c);
  ::Reflex::Type type_10395 = ::Reflex::ReferenceBuilder(type_4239);
  ::Reflex::Type type_3138c = ::Reflex::ConstBuilder(type_3138);
  ::Reflex::Type type_19897 = ::Reflex::ReferenceBuilder(type_3138c);
  ::Reflex::Type type_4728c = ::Reflex::ConstBuilder(type_4728);
  ::Reflex::Type type_33882 = ::Reflex::PointerBuilder(type_4728c);
  ::Reflex::Type type_33885 = ::Reflex::PointerBuilder(type_1114c);
  ::Reflex::Type type_33886 = ::Reflex::PointerBuilder(type_1114);
  ::Reflex::Type type_4729c = ::Reflex::ConstBuilder(type_4729);
  ::Reflex::Type type_33887 = ::Reflex::PointerBuilder(type_4729c);
  ::Reflex::Type type_33890 = ::Reflex::PointerBuilder(type_2233c);
  ::Reflex::Type type_33891 = ::Reflex::PointerBuilder(type_2233);
  ::Reflex::Type type_4730c = ::Reflex::ConstBuilder(type_4730);
  ::Reflex::Type type_33892 = ::Reflex::PointerBuilder(type_4730c);
  ::Reflex::Type type_33905 = ::Reflex::PointerBuilder(type_3142c);
  ::Reflex::Type type_33906 = ::Reflex::PointerBuilder(type_3142);
  ::Reflex::Type type_4733c = ::Reflex::ConstBuilder(type_4733);
  ::Reflex::Type type_33907 = ::Reflex::PointerBuilder(type_4733c);
  ::Reflex::Type type_4734c = ::Reflex::ConstBuilder(type_4734);
  ::Reflex::Type type_33910 = ::Reflex::PointerBuilder(type_4734c);
  ::Reflex::Type type_33913 = ::Reflex::PointerBuilder(type_3143c);
  ::Reflex::Type type_33914 = ::Reflex::PointerBuilder(type_3143);
  ::Reflex::Type type_4735c = ::Reflex::ConstBuilder(type_4735);
  ::Reflex::Type type_33915 = ::Reflex::PointerBuilder(type_4735c);
  ::Reflex::Type type_4736c = ::Reflex::ConstBuilder(type_4736);
  ::Reflex::Type type_33918 = ::Reflex::PointerBuilder(type_4736c);
  ::Reflex::Type type_33921 = ::Reflex::PointerBuilder(type_3144c);
  ::Reflex::Type type_33922 = ::Reflex::PointerBuilder(type_3144);
  ::Reflex::Type type_4737c = ::Reflex::ConstBuilder(type_4737);
  ::Reflex::Type type_33923 = ::Reflex::PointerBuilder(type_4737c);
  ::Reflex::Type type_4738c = ::Reflex::ConstBuilder(type_4738);
  ::Reflex::Type type_33926 = ::Reflex::PointerBuilder(type_4738c);
  ::Reflex::Type type_33929 = ::Reflex::PointerBuilder(type_3149c);
  ::Reflex::Type type_33930 = ::Reflex::PointerBuilder(type_3149);
  ::Reflex::Type type_4739c = ::Reflex::ConstBuilder(type_4739);
  ::Reflex::Type type_33931 = ::Reflex::PointerBuilder(type_4739c);
  ::Reflex::Type type_39360 = ::Reflex::ReferenceBuilder(type_7946);
  ::Reflex::Type type_7946c = ::Reflex::ConstBuilder(type_7946);
  ::Reflex::Type type_39361 = ::Reflex::ReferenceBuilder(type_7946c);
  ::Reflex::Type type_39362 = ::Reflex::ReferenceBuilder(type_7975);
  ::Reflex::Type type_39324 = ::Reflex::ReferenceBuilder(type_7925);
  ::Reflex::Type type_39322 = ::Reflex::ReferenceBuilder(type_7923);
  ::Reflex::Type type_39345 = ::Reflex::ReferenceBuilder(type_7935);
  ::Reflex::Type type_1647c = ::Reflex::ConstBuilder(type_1647);
  ::Reflex::Type type_32849 = ::Reflex::ReferenceBuilder(type_3163);
  ::Reflex::Type type_3163c = ::Reflex::ConstBuilder(type_3163);
  ::Reflex::Type type_32848 = ::Reflex::ReferenceBuilder(type_3163c);
  ::Reflex::Type type_32845 = ::Reflex::ReferenceBuilder(type_3159);
  ::Reflex::Type type_3159c = ::Reflex::ConstBuilder(type_3159);
  ::Reflex::Type type_32844 = ::Reflex::ReferenceBuilder(type_3159c);
  ::Reflex::Type type_33934 = ::Reflex::PointerBuilder(type_7946c);
  ::Reflex::Type type_33935 = ::Reflex::PointerBuilder(type_7946);
  ::Reflex::Type type_4740c = ::Reflex::ConstBuilder(type_4740);
  ::Reflex::Type type_33936 = ::Reflex::PointerBuilder(type_4740c);
  ::Reflex::Type type_7935c = ::Reflex::ConstBuilder(type_7935);
  ::Reflex::Type type_39346 = ::Reflex::ReferenceBuilder(type_7935c);
  ::Reflex::Type type_33939 = ::Reflex::PointerBuilder(type_7935c);
  ::Reflex::Type type_33940 = ::Reflex::PointerBuilder(type_7935);
  ::Reflex::Type type_4741c = ::Reflex::ConstBuilder(type_4741);
  ::Reflex::Type type_33941 = ::Reflex::PointerBuilder(type_4741c);
  ::Reflex::Type type_7975c = ::Reflex::ConstBuilder(type_7975);
  ::Reflex::Type type_39387 = ::Reflex::ReferenceBuilder(type_7975c);
  ::Reflex::Type type_33859 = ::Reflex::ReferenceBuilder(type_4657);
  ::Reflex::Type type_4657c = ::Reflex::ConstBuilder(type_4657);
  ::Reflex::Type type_33855 = ::Reflex::ReferenceBuilder(type_4657c);
  ::Reflex::Type type_33944 = ::Reflex::PointerBuilder(type_7975c);
  ::Reflex::Type type_33945 = ::Reflex::PointerBuilder(type_7975);
  ::Reflex::Type type_4742c = ::Reflex::ConstBuilder(type_4742);
  ::Reflex::Type type_33946 = ::Reflex::PointerBuilder(type_4742c);
  ::Reflex::Type type_7923c = ::Reflex::ConstBuilder(type_7923);
  ::Reflex::Type type_39323 = ::Reflex::ReferenceBuilder(type_7923c);
  ::Reflex::Type type_33949 = ::Reflex::PointerBuilder(type_7923c);
  ::Reflex::Type type_33950 = ::Reflex::PointerBuilder(type_7923);
  ::Reflex::Type type_4743c = ::Reflex::ConstBuilder(type_4743);
  ::Reflex::Type type_33951 = ::Reflex::PointerBuilder(type_4743c);
  ::Reflex::Type type_7925c = ::Reflex::ConstBuilder(type_7925);
  ::Reflex::Type type_39325 = ::Reflex::ReferenceBuilder(type_7925c);
  ::Reflex::Type type_33853 = ::Reflex::ReferenceBuilder(type_4656);
  ::Reflex::Type type_4656c = ::Reflex::ConstBuilder(type_4656);
  ::Reflex::Type type_33849 = ::Reflex::ReferenceBuilder(type_4656c);
  ::Reflex::Type type_34343 = ::Reflex::ReferenceBuilder(type_4880);
  ::Reflex::Type type_4880c = ::Reflex::ConstBuilder(type_4880);
  ::Reflex::Type type_34342 = ::Reflex::ReferenceBuilder(type_4880c);
  ::Reflex::Type type_33954 = ::Reflex::PointerBuilder(type_7925c);
  ::Reflex::Type type_33955 = ::Reflex::PointerBuilder(type_7925);
  ::Reflex::Type type_4744c = ::Reflex::ConstBuilder(type_4744);
  ::Reflex::Type type_33956 = ::Reflex::PointerBuilder(type_4744c);
  ::Reflex::Type type_4745c = ::Reflex::ConstBuilder(type_4745);
  ::Reflex::Type type_33959 = ::Reflex::PointerBuilder(type_4745c);
  ::Reflex::Type type_33962 = ::Reflex::PointerBuilder(type_87c);
  ::Reflex::Type type_33963 = ::Reflex::PointerBuilder(type_87);
  ::Reflex::Type type_4746c = ::Reflex::ConstBuilder(type_4746);
  ::Reflex::Type type_33964 = ::Reflex::PointerBuilder(type_4746c);
  ::Reflex::Type type_33977 = ::Reflex::PointerBuilder(type_3155);
  ::Reflex::Type type_4749c = ::Reflex::ConstBuilder(type_4749);
  ::Reflex::Type type_33978 = ::Reflex::PointerBuilder(type_4749c);
  ::Reflex::Type type_4750c = ::Reflex::ConstBuilder(type_4750);
  ::Reflex::Type type_33981 = ::Reflex::PointerBuilder(type_4750c);
  ::Reflex::Type type_33984 = ::Reflex::PointerBuilder(type_3157);
  ::Reflex::Type type_4751c = ::Reflex::ConstBuilder(type_4751);
  ::Reflex::Type type_33985 = ::Reflex::PointerBuilder(type_4751c);
  ::Reflex::Type type_4752c = ::Reflex::ConstBuilder(type_4752);
  ::Reflex::Type type_33988 = ::Reflex::PointerBuilder(type_4752c);
  ::Reflex::Type type_33991 = ::Reflex::PointerBuilder(type_3146);
  ::Reflex::Type type_4757c = ::Reflex::ConstBuilder(type_4757);
  ::Reflex::Type type_33992 = ::Reflex::PointerBuilder(type_4757c);
  ::Reflex::Type type_4758c = ::Reflex::ConstBuilder(type_4758);
  ::Reflex::Type type_33995 = ::Reflex::PointerBuilder(type_4758c);
  ::Reflex::Type type_33998 = ::Reflex::PointerBuilder(type_3158);
  ::Reflex::Type type_4753c = ::Reflex::ConstBuilder(type_4753);
  ::Reflex::Type type_33999 = ::Reflex::PointerBuilder(type_4753c);
  ::Reflex::Type type_4754c = ::Reflex::ConstBuilder(type_4754);
  ::Reflex::Type type_34002 = ::Reflex::PointerBuilder(type_4754c);
  ::Reflex::Type type_34005 = ::Reflex::PointerBuilder(type_3148);
  ::Reflex::Type type_4755c = ::Reflex::ConstBuilder(type_4755);
  ::Reflex::Type type_34006 = ::Reflex::PointerBuilder(type_4755c);
  ::Reflex::Type type_4756c = ::Reflex::ConstBuilder(type_4756);
  ::Reflex::Type type_34009 = ::Reflex::PointerBuilder(type_4756c);
  ::Reflex::Type type_34345 = ::Reflex::ReferenceBuilder(type_4883);
  ::Reflex::Type type_4883c = ::Reflex::ConstBuilder(type_4883);
  ::Reflex::Type type_34346 = ::Reflex::ReferenceBuilder(type_4883c);
  ::Reflex::Type type_4932c = ::Reflex::ConstBuilder(type_4932);
  ::Reflex::Type type_34347 = ::Reflex::ReferenceBuilder(type_4932c);
  ::Reflex::Type type_4844c = ::Reflex::ConstBuilder(type_4844);
  ::Reflex::Type type_34348 = ::Reflex::ReferenceBuilder(type_4844c);
  ::Reflex::Type type_4812c = ::Reflex::ConstBuilder(type_4812);
  ::Reflex::Type type_34349 = ::Reflex::ReferenceBuilder(type_4812c);
  ::Reflex::Type type_34350 = ::Reflex::ReferenceBuilder(type_4884);
  ::Reflex::Type type_4884c = ::Reflex::ConstBuilder(type_4884);
  ::Reflex::Type type_34351 = ::Reflex::ReferenceBuilder(type_4884c);
  ::Reflex::Type type_4933c = ::Reflex::ConstBuilder(type_4933);
  ::Reflex::Type type_34352 = ::Reflex::ReferenceBuilder(type_4933c);
  ::Reflex::Type type_4845c = ::Reflex::ConstBuilder(type_4845);
  ::Reflex::Type type_34353 = ::Reflex::ReferenceBuilder(type_4845c);
  ::Reflex::Type type_4813c = ::Reflex::ConstBuilder(type_4813);
  ::Reflex::Type type_34354 = ::Reflex::ReferenceBuilder(type_4813c);
  ::Reflex::Type type_34355 = ::Reflex::ReferenceBuilder(type_4885);
  ::Reflex::Type type_34360 = ::Reflex::ReferenceBuilder(type_4886);
  ::Reflex::Type type_4886c = ::Reflex::ConstBuilder(type_4886);
  ::Reflex::Type type_34361 = ::Reflex::ReferenceBuilder(type_4886c);
  ::Reflex::Type type_4935c = ::Reflex::ConstBuilder(type_4935);
  ::Reflex::Type type_34362 = ::Reflex::ReferenceBuilder(type_4935c);
  ::Reflex::Type type_4847c = ::Reflex::ConstBuilder(type_4847);
  ::Reflex::Type type_34363 = ::Reflex::ReferenceBuilder(type_4847c);
  ::Reflex::Type type_4815c = ::Reflex::ConstBuilder(type_4815);
  ::Reflex::Type type_34364 = ::Reflex::ReferenceBuilder(type_4815c);
  ::Reflex::Type type_34365 = ::Reflex::ReferenceBuilder(type_4887);
  ::Reflex::Type type_34388 = ::Reflex::ReferenceBuilder(type_4901);
  ::Reflex::Type type_34398 = ::Reflex::ReferenceBuilder(type_4915);
  ::Reflex::Type type_34399 = ::Reflex::ReferenceBuilder(type_4916);
  ::Reflex::Type type_34400 = ::Reflex::ReferenceBuilder(type_4917);
  ::Reflex::Type type_13243 = ::Reflex::ReferenceBuilder(type_7941);
  ::Reflex::Type type_7941c = ::Reflex::ConstBuilder(type_7941);
  ::Reflex::Type type_13245 = ::Reflex::ReferenceBuilder(type_7941c);
  ::Reflex::Type type_14086 = ::Reflex::ReferenceBuilder(type_7976);
  ::Reflex::Type type_7976c = ::Reflex::ConstBuilder(type_7976);
  ::Reflex::Type type_14088 = ::Reflex::ReferenceBuilder(type_7976c);
  ::Reflex::Type type_13308 = ::Reflex::ReferenceBuilder(type_8009);
  ::Reflex::Type type_8009c = ::Reflex::ConstBuilder(type_8009);
  ::Reflex::Type type_13310 = ::Reflex::ReferenceBuilder(type_8009c);
  ::Reflex::Type type_21302c = ::Reflex::ConstBuilder(type_21302);
  ::Reflex::Type type_40760 = ::Reflex::ReferenceBuilder(type_21302c);
  ::Reflex::Type type_40761 = ::Reflex::ReferenceBuilder(type_21302);
  ::Reflex::Type type_34376 = ::Reflex::PointerBuilder(type_21290);
  ::Reflex::Type type_6560c = ::Reflex::ConstBuilder(type_6560);
  ::Reflex::Type type_34381 = ::Reflex::PointerBuilder(type_6560c);
  ::Reflex::Type type_2197 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("size_t"), type_364);
  ::Reflex::Type type_21290c = ::Reflex::ConstBuilder(type_21290);
  ::Reflex::Type type_40743 = ::Reflex::ReferenceBuilder(type_21290c);
  ::Reflex::Type type_21585 = ::Reflex::ReferenceBuilder(type_12173);
  ::Reflex::Type type_10457 = ::Reflex::ReferenceBuilder(type_2652);
  ::Reflex::Type type_21303c = ::Reflex::ConstBuilder(type_21303);
  ::Reflex::Type type_40762 = ::Reflex::ReferenceBuilder(type_21303c);
  ::Reflex::Type type_40763 = ::Reflex::ReferenceBuilder(type_21303);
  ::Reflex::Type type_21304c = ::Reflex::ConstBuilder(type_21304);
  ::Reflex::Type type_40764 = ::Reflex::ReferenceBuilder(type_21304c);
  ::Reflex::Type type_40765 = ::Reflex::ReferenceBuilder(type_21304);
  ::Reflex::Type type_21305c = ::Reflex::ConstBuilder(type_21305);
  ::Reflex::Type type_40766 = ::Reflex::ReferenceBuilder(type_21305c);
  ::Reflex::Type type_40767 = ::Reflex::ReferenceBuilder(type_21305);
  ::Reflex::Type type_21306c = ::Reflex::ConstBuilder(type_21306);
  ::Reflex::Type type_40768 = ::Reflex::ReferenceBuilder(type_21306c);
  ::Reflex::Type type_40769 = ::Reflex::ReferenceBuilder(type_21306);
  ::Reflex::Type type_13239 = ::Reflex::PointerBuilder(type_7941);
  ::Reflex::Type type_13241 = ::Reflex::PointerBuilder(type_7941c);
  ::Reflex::Type type_3410c = ::Reflex::ConstBuilder(type_3410);
  ::Reflex::Type type_31597 = ::Reflex::ReferenceBuilder(type_3410c);
  ::Reflex::Type type_3140c = ::Reflex::ConstBuilder(type_3140);
  ::Reflex::Type type_32795 = ::Reflex::ReferenceBuilder(type_3140c);
  ::Reflex::Type type_32796 = ::Reflex::ReferenceBuilder(type_3140);
  ::Reflex::Type type_14082 = ::Reflex::PointerBuilder(type_7976);
  ::Reflex::Type type_14084 = ::Reflex::PointerBuilder(type_7976c);
  ::Reflex::Type type_3424c = ::Reflex::ConstBuilder(type_3424);
  ::Reflex::Type type_31693 = ::Reflex::ReferenceBuilder(type_3424c);
  ::Reflex::Type type_3153c = ::Reflex::ConstBuilder(type_3153);
  ::Reflex::Type type_32832 = ::Reflex::ReferenceBuilder(type_3153c);
  ::Reflex::Type type_32833 = ::Reflex::ReferenceBuilder(type_3153);
  ::Reflex::Type type_13304 = ::Reflex::PointerBuilder(type_8009);
  ::Reflex::Type type_13306 = ::Reflex::PointerBuilder(type_8009c);
  ::Reflex::Type type_3411c = ::Reflex::ConstBuilder(type_3411);
  ::Reflex::Type type_31609 = ::Reflex::ReferenceBuilder(type_3411c);
  ::Reflex::Type type_3141c = ::Reflex::ConstBuilder(type_3141);
  ::Reflex::Type type_32798 = ::Reflex::ReferenceBuilder(type_3141c);
  ::Reflex::Type type_32799 = ::Reflex::ReferenceBuilder(type_3141);
  ::Reflex::Type type_39461 = ::Reflex::ReferenceBuilder(type_8161);
  ::Reflex::Type type_8161c = ::Reflex::ConstBuilder(type_8161);
  ::Reflex::Type type_39462 = ::Reflex::ReferenceBuilder(type_8161c);
  ::Reflex::Type type_10297c = ::Reflex::ConstBuilder(type_10297);
  ::Reflex::Type type_39463 = ::Reflex::ReferenceBuilder(type_10297c);
  ::Reflex::Type type_3290c = ::Reflex::ConstBuilder(type_3290);
  ::Reflex::Type type_39111 = ::Reflex::ReferenceBuilder(type_3290c);
  ::Reflex::Type type_39476 = ::Reflex::ReferenceBuilder(type_8190);
  ::Reflex::Type type_8190c = ::Reflex::ConstBuilder(type_8190);
  ::Reflex::Type type_39477 = ::Reflex::ReferenceBuilder(type_8190c);
  ::Reflex::Type type_10361c = ::Reflex::ConstBuilder(type_10361);
  ::Reflex::Type type_39478 = ::Reflex::ReferenceBuilder(type_10361c);
  ::Reflex::Type type_33895 = ::Reflex::PointerBuilder(type_3140c);
  ::Reflex::Type type_33896 = ::Reflex::PointerBuilder(type_3140);
  ::Reflex::Type type_4731c = ::Reflex::ConstBuilder(type_4731);
  ::Reflex::Type type_33897 = ::Reflex::PointerBuilder(type_4731c);
  ::Reflex::Type type_33900 = ::Reflex::PointerBuilder(type_3141c);
  ::Reflex::Type type_33901 = ::Reflex::PointerBuilder(type_3141);
  ::Reflex::Type type_4732c = ::Reflex::ConstBuilder(type_4732);
  ::Reflex::Type type_33902 = ::Reflex::PointerBuilder(type_4732c);
  ::Reflex::Type type_33967 = ::Reflex::PointerBuilder(type_3153c);
  ::Reflex::Type type_33968 = ::Reflex::PointerBuilder(type_3153);
  ::Reflex::Type type_4747c = ::Reflex::ConstBuilder(type_4747);
  ::Reflex::Type type_33969 = ::Reflex::PointerBuilder(type_4747c);
  ::Reflex::Type type_33972 = ::Reflex::PointerBuilder(type_3154c);
  ::Reflex::Type type_33973 = ::Reflex::PointerBuilder(type_3154);
  ::Reflex::Type type_4748c = ::Reflex::ConstBuilder(type_4748);
  ::Reflex::Type type_33974 = ::Reflex::PointerBuilder(type_4748c);
  ::Reflex::Type type_40746 = ::Reflex::ReferenceBuilder(type_21293);
  ::Reflex::Type type_21293c = ::Reflex::ConstBuilder(type_21293);
  ::Reflex::Type type_40747 = ::Reflex::ReferenceBuilder(type_21293c);
  ::Reflex::Type type_21583 = ::Reflex::PointerBuilder(type_12173);
  ::Reflex::Type type_12173c = ::Reflex::ConstBuilder(type_12173);
  ::Reflex::Type type_40258 = ::Reflex::ReferenceBuilder(type_12173c);
  ::Reflex::Type type_40748 = ::Reflex::ReferenceBuilder(type_21294);
  ::Reflex::Type type_21294c = ::Reflex::ConstBuilder(type_21294);
  ::Reflex::Type type_40749 = ::Reflex::ReferenceBuilder(type_21294c);
  ::Reflex::Type type_40750 = ::Reflex::ReferenceBuilder(type_21295);
  ::Reflex::Type type_21295c = ::Reflex::ConstBuilder(type_21295);
  ::Reflex::Type type_40751 = ::Reflex::ReferenceBuilder(type_21295c);
  ::Reflex::Type type_40752 = ::Reflex::ReferenceBuilder(type_21296);
  ::Reflex::Type type_21296c = ::Reflex::ConstBuilder(type_21296);
  ::Reflex::Type type_40753 = ::Reflex::ReferenceBuilder(type_21296c);
  ::Reflex::Type type_40754 = ::Reflex::ReferenceBuilder(type_21297);
  ::Reflex::Type type_21297c = ::Reflex::ConstBuilder(type_21297);
  ::Reflex::Type type_40755 = ::Reflex::ReferenceBuilder(type_21297c);
  ::Reflex::Type type_4698f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<reco::MVAMEtPFCandInfoCollection>"), type_4698);
  ::Reflex::Type type_4699f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<reco::MVAMEtJetInfoCollection>"), type_4699);
  ::Reflex::Type type_4714f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<reco::HcalNoiseRBXCollection>"), type_4714);
  ::Reflex::Type type_4715f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<reco::HcalNoiseHPDCollection>"), type_4715);
  ::Reflex::Type type_21293f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::reftobase::RefHolder<reco::PFClusterMETRef>"), type_21293);
  ::Reflex::Type type_21294f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::reftobase::RefHolder<reco::PFMETRef>"), type_21294);
  ::Reflex::Type type_21295f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::reftobase::RefHolder<reco::GenMETRef>"), type_21295);
  ::Reflex::Type type_21296f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::reftobase::RefHolder<reco::CaloMETRef>"), type_21296);
  ::Reflex::Type type_21297f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::reftobase::RefHolder<reco::METRef>"), type_21297);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __HcalNoiseSummary
#undef __HcalNoiseSummary
#endif
class __HcalNoiseSummary {
  public:
  __HcalNoiseSummary();
  virtual ~__HcalNoiseSummary() throw();
  int filterstatus_;
  int noisetype_;
  float emenergy_;
  float hadenergy_;
  float trackenergy_;
  float min10_;
  float max10_;
  float rms10_;
  float min25_;
  float max25_;
  float rms25_;
  int cnthit10_;
  int cnthit25_;
  float mine2ts_;
  float mine10ts_;
  float maxe2ts_;
  float maxe10ts_;
  int maxzeros_;
  int maxhpdhits_;
  int maxhpdhitsnoother_;
  int maxrbxhits_;
  float minhpdemf_;
  float minrbxemf_;
  int nproblemRBXs_;
  int nisolnoise_;
  float isolnoisee_;
  float isolnoiseet_;
  int nflatnoise_;
  float flatnoisee_;
  float flatnoiseet_;
  int nspikenoise_;
  float spikenoisee_;
  float spikenoiseet_;
  int ntrianglenoise_;
  float trianglenoisee_;
  float trianglenoiseet_;
  int nts4ts5noise_;
  float ts4ts5noisee_;
  float ts4ts5noiseet_;
  int rechitCount_;
  int rechitCount15_;
  double rechitEnergy_;
  double rechitEnergy15_;
  double calibCharge_;
  bool hasBadRBXTS4TS5_;
  int calibCountTS45_;
  int calibCountgt15TS45_;
  double calibChargeTS45_;
  double calibChargegt15TS45_;
  int hitsInLaserRegion_;
  int hitsInNonLaserRegion_;
  double energyInLaserRegion_;
  double energyInNonLaserRegion_;
  ::edm::RefVector<std::vector<reco::CaloJet>,reco::CaloJet,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloJet>,reco::CaloJet> > problemjets_;
  ::edm::RefVector<edm::SortedCollection<CaloTower,edm::StrictWeakOrdering<CaloTower> >,CaloTower,edm::refhelper::FindUsingAdvance<edm::SortedCollection<CaloTower,edm::StrictWeakOrdering<CaloTower> >,CaloTower> > loosenoisetwrs_;
  ::edm::RefVector<edm::SortedCollection<CaloTower,edm::StrictWeakOrdering<CaloTower> >,CaloTower,edm::refhelper::FindUsingAdvance<edm::SortedCollection<CaloTower,edm::StrictWeakOrdering<CaloTower> >,CaloTower> > tightnoisetwrs_;
  ::edm::RefVector<edm::SortedCollection<CaloTower,edm::StrictWeakOrdering<CaloTower> >,CaloTower,edm::refhelper::FindUsingAdvance<edm::SortedCollection<CaloTower,edm::StrictWeakOrdering<CaloTower> >,CaloTower> > hlnoisetwrs_;
};
#ifdef __SpecificPFMETData
#undef __SpecificPFMETData
#endif
struct __SpecificPFMETData {
  public:
  __SpecificPFMETData();
  double NeutralEMFraction;
  double NeutralHadFraction;
  double ChargedEMFraction;
  double ChargedHadFraction;
  double MuonFraction;
  double Type6Fraction;
  double Type7Fraction;
};
#ifdef __SpecificCaloMETData
#undef __SpecificCaloMETData
#endif
struct __SpecificCaloMETData {
  public:
  __SpecificCaloMETData();
  double MaxEtInEmTowers;
  double MaxEtInHadTowers;
  double HadEtInHO;
  double HadEtInHB;
  double HadEtInHF;
  double HadEtInHE;
  double EmEtInEB;
  double EmEtInEE;
  double EmEtInHF;
  double EtFractionHadronic;
  double EtFractionEm;
  double METSignificance;
  double CaloMETInpHF;
  double CaloMETInmHF;
  double CaloSETInpHF;
  double CaloSETInmHF;
  double CaloMETPhiInpHF;
  double CaloMETPhiInmHF;
};
#ifdef __AnomalousECALVariables
#undef __AnomalousECALVariables
#endif
class __AnomalousECALVariables {
  public:
  __AnomalousECALVariables();
  ::std::vector<BoundaryInformation> v_enNeighboursGap_EB;
  ::std::vector<BoundaryInformation> v_enNeighboursGap_EE;
  ::std::vector<BoundaryInformation> v_boundaryInfoDeadCells_EB;
  ::std::vector<BoundaryInformation> v_boundaryInfoDeadCells_EE;
};
#ifdef __CorrMETData
#undef __CorrMETData
#endif
struct __CorrMETData {
  public:
  __CorrMETData();
  double mex;
  double mey;
  double sumet;
  double significance;
};
#ifdef __BoundaryInformation
#undef __BoundaryInformation
#endif
class __BoundaryInformation {
  public:
  __BoundaryInformation();
  ::std::vector<EcalRecHit> recHits;
  ::std::vector<DetId> detIds;
  ::std::vector<int> channelStatus;
  double boundaryEnergy;
  double boundaryET;
  ::EcalSubdetector subdet;
  bool nextToBorder;
};
#ifdef __PFMEtSignCovMatrix
#undef __PFMEtSignCovMatrix
#endif
class __PFMEtSignCovMatrix {
  public:
  __PFMEtSignCovMatrix();
  double covXX_;
  double covXY_;
  double covYY_;
};
#ifdef __CommonMETData
#undef __CommonMETData
#endif
struct __CommonMETData {
  public:
  __CommonMETData();
  double met;
  double mex;
  double mey;
  double mez;
  double sumet;
  double phi;
};
#ifdef __SpecificGenMETData
#undef __SpecificGenMETData
#endif
struct __SpecificGenMETData {
  public:
  __SpecificGenMETData();
  double NeutralEMEtFraction;
  double NeutralHadEtFraction;
  double ChargedEMEtFraction;
  double ChargedHadEtFraction;
  double MuonEtFraction;
  double InvisibleEtFraction;
  double m_EmEnergy;
  double m_HadEnergy;
  double m_InvisibleEnergy;
  double m_AuxiliaryEnergy;
};
#ifdef __std__vector_BoundaryInformation_
#undef __std__vector_BoundaryInformation_
#endif
class __std__vector_BoundaryInformation_ : protected ::std::_Vector_base<BoundaryInformation,std::allocator<BoundaryInformation> > {
  public:
  __std__vector_BoundaryInformation_();
};
#ifdef __metsig__SigInputObj
#undef __metsig__SigInputObj
#endif
class __metsig__SigInputObj {
  public:
  __metsig__SigInputObj();
  ::std::string type;
  double energy;
  double phi;
  double sigma_e;
  double sigma_tan;
};
#ifdef __std__vector_metsig__SigInputObj_
#undef __std__vector_metsig__SigInputObj_
#endif
class __std__vector_metsig__SigInputObj_ : protected ::std::_Vector_base<metsig::SigInputObj,std::allocator<metsig::SigInputObj> > {
  public:
  __std__vector_metsig__SigInputObj_();
};
#ifdef __std__vector_CorrMETData_
#undef __std__vector_CorrMETData_
#endif
class __std__vector_CorrMETData_ : protected ::std::_Vector_base<CorrMETData,std::allocator<CorrMETData> > {
  public:
  __std__vector_CorrMETData_();
};
#ifdef __std__vector_CommonMETData_
#undef __std__vector_CommonMETData_
#endif
class __std__vector_CommonMETData_ : protected ::std::_Vector_base<CommonMETData,std::allocator<CommonMETData> > {
  public:
  __std__vector_CommonMETData_();
};
#ifdef __reco__MET
#undef __reco__MET
#endif
class __reco__MET : public ::reco::RecoCandidate {
  public:
  __reco__MET();
  virtual ~__reco__MET() throw();
  virtual ::reco::MET* clone() const throw();
  virtual bool overlap(reco::Candidate const&) const throw();
  double sumet;
  double elongit;
  double signif_dxx;
  double signif_dyy;
  double signif_dyx;
  double signif_dxy;
  ::std::vector<CorrMETData> corr;
};
#ifdef __edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_
#undef __edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_
#endif
class __edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_ {
  public:
  __edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_();
  ::edm::RefCoreWithIndex product_;
};
#ifdef __std__vector_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s_
#undef __std__vector_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s_
#endif
class __std__vector_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s_ : protected ::std::_Vector_base<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >,std::allocator<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > > {
  public:
  __std__vector_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s_();
};
#ifdef __std__vector_reco__MET_
#undef __std__vector_reco__MET_
#endif
class __std__vector_reco__MET_ : protected ::std::_Vector_base<reco::MET,std::allocator<reco::MET> > {
  public:
  __std__vector_reco__MET_();
};
#ifdef __reco__CaloMET
#undef __reco__CaloMET
#endif
class __reco__CaloMET : public ::reco::MET {
  public:
  __reco__CaloMET();
  virtual ~__reco__CaloMET() throw();
  virtual bool overlap(reco::Candidate const&) const throw();
  ::SpecificCaloMETData calo_data;
};
#ifdef __edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_
#undef __edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_
#endif
class __edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_ {
  public:
  __edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_();
  ::edm::RefCoreWithIndex product_;
};
#ifdef __std__vector_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s_
#undef __std__vector_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s_
#endif
class __std__vector_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s_ : protected ::std::_Vector_base<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >,std::allocator<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > > {
  public:
  __std__vector_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s_();
};
#ifdef __std__vector_reco__CaloMET_
#undef __std__vector_reco__CaloMET_
#endif
class __std__vector_reco__CaloMET_ : protected ::std::_Vector_base<reco::CaloMET,std::allocator<reco::CaloMET> > {
  public:
  __std__vector_reco__CaloMET_();
};
#ifdef __std__vector_Point3DBase_float_GlobalTag_s_
#undef __std__vector_Point3DBase_float_GlobalTag_s_
#endif
class __std__vector_Point3DBase_float_GlobalTag_s_ : protected ::std::_Vector_base<Point3DBase<float,GlobalTag>,std::allocator<Point3DBase<float,GlobalTag> > > {
  public:
  __std__vector_Point3DBase_float_GlobalTag_s_();
};
#ifdef __reco__PhiWedge
#undef __reco__PhiWedge
#endif
class __reco__PhiWedge {
  public:
  __reco__PhiWedge();
  float energy_;
  int iphi_;
  int constituents_;
  float min_time_;
  float max_time_;
  float PlusZOriginConfidence_;
  int OverlappingCSCTracks_;
  int OverlappingCSCSegments_;
  int OverlappingCSCRecHits_;
  int OverlappingCSCHaloTriggers_;
};
#ifdef __std__vector_reco__PhiWedge_
#undef __std__vector_reco__PhiWedge_
#endif
class __std__vector_reco__PhiWedge_ : protected ::std::_Vector_base<reco::PhiWedge,std::allocator<reco::PhiWedge> > {
  public:
  __std__vector_reco__PhiWedge_();
};
#ifdef __std__vector_SpecificPFMETData_
#undef __std__vector_SpecificPFMETData_
#endif
class __std__vector_SpecificPFMETData_ : protected ::std::_Vector_base<SpecificPFMETData,std::allocator<SpecificPFMETData> > {
  public:
  __std__vector_SpecificPFMETData_();
};
#ifdef __std__vector_SpecificCaloMETData_
#undef __std__vector_SpecificCaloMETData_
#endif
class __std__vector_SpecificCaloMETData_ : protected ::std::_Vector_base<SpecificCaloMETData,std::allocator<SpecificCaloMETData> > {
  public:
  __std__vector_SpecificCaloMETData_();
};
#ifdef __reco__HcalNoiseHPD
#undef __reco__HcalNoiseHPD
#endif
class __reco__HcalNoiseHPD {
  public:
  __reco__HcalNoiseHPD();
  virtual ~__reco__HcalNoiseHPD() throw();
  int idnumber_;
  int totalZeros_;
  int maxZeros_;
  ::std::vector<float> bigCharge_;
  ::std::vector<float> big5Charge_;
  ::edm::RefVector<edm::SortedCollection<HBHERecHit,edm::StrictWeakOrdering<HBHERecHit> >,HBHERecHit,edm::refhelper::FindUsingAdvance<edm::SortedCollection<HBHERecHit,edm::StrictWeakOrdering<HBHERecHit> >,HBHERecHit> > rechits_;
  ::std::set<edm::Ref<edm::SortedCollection<HBHERecHit,edm::StrictWeakOrdering<HBHERecHit> >,HBHERecHit,edm::refhelper::FindUsingAdvance<edm::SortedCollection<HBHERecHit,edm::StrictWeakOrdering<HBHERecHit> >,HBHERecHit> >,reco::RefHBHERecHitEnergyComparison> refrechitset_;
  ::edm::RefVector<edm::SortedCollection<CaloTower,edm::StrictWeakOrdering<CaloTower> >,CaloTower,edm::refhelper::FindUsingAdvance<edm::SortedCollection<CaloTower,edm::StrictWeakOrdering<CaloTower> >,CaloTower> > calotowers_;
};
#ifdef __std__vector_reco__HcalNoiseHPD_
#undef __std__vector_reco__HcalNoiseHPD_
#endif
class __std__vector_reco__HcalNoiseHPD_ : protected ::std::_Vector_base<reco::HcalNoiseHPD,std::allocator<reco::HcalNoiseHPD> > {
  public:
  __std__vector_reco__HcalNoiseHPD_();
};
#ifdef __reco__PFClusterMET
#undef __reco__PFClusterMET
#endif
class __reco__PFClusterMET : public ::reco::MET {
  public:
  __reco__PFClusterMET();
  virtual ~__reco__PFClusterMET() throw();
};
#ifdef __std__vector_reco__PFClusterMET_
#undef __std__vector_reco__PFClusterMET_
#endif
class __std__vector_reco__PFClusterMET_ : protected ::std::_Vector_base<reco::PFClusterMET,std::allocator<reco::PFClusterMET> > {
  public:
  __std__vector_reco__PFClusterMET_();
};
#ifdef __reco__PFMET
#undef __reco__PFMET
#endif
class __reco__PFMET : public ::reco::MET {
  public:
  __reco__PFMET();
  virtual ~__reco__PFMET() throw();
  ::SpecificPFMETData pf_data;
};
#ifdef __std__vector_reco__PFMET_
#undef __std__vector_reco__PFMET_
#endif
class __std__vector_reco__PFMET_ : protected ::std::_Vector_base<reco::PFMET,std::allocator<reco::PFMET> > {
  public:
  __std__vector_reco__PFMET_();
};
#ifdef __reco__GenMET
#undef __reco__GenMET
#endif
class __reco__GenMET : public ::reco::MET {
  public:
  __reco__GenMET();
  virtual ~__reco__GenMET() throw();
  virtual bool overlap(reco::Candidate const&) const throw();
  ::SpecificGenMETData gen_data;
};
#ifdef __std__vector_reco__GenMET_
#undef __std__vector_reco__GenMET_
#endif
class __std__vector_reco__GenMET_ : protected ::std::_Vector_base<reco::GenMET,std::allocator<reco::GenMET> > {
  public:
  __std__vector_reco__GenMET_();
};
#ifdef __edm__PtrVector_reco__MET_
#undef __edm__PtrVector_reco__MET_
#endif
class __edm__PtrVector_reco__MET_ : public ::edm::PtrVectorBase {
  public:
  __edm__PtrVector_reco__MET_();
  virtual ~__edm__PtrVector_reco__MET_() throw();
};
#ifdef __edm__RefVector_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_
#undef __edm__RefVector_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_
#endif
class __edm__RefVector_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_ {
  public:
  __edm__RefVector_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_();
  ::edm::RefVectorBase<unsigned int> refVector_;
};
#ifdef __edm__RefVector_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_
#undef __edm__RefVector_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_
#endif
class __edm__RefVector_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_ {
  public:
  __edm__RefVector_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_();
  ::edm::RefVectorBase<unsigned int> refVector_;
};
#ifdef __edm__RefVector_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_
#undef __edm__RefVector_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_
#endif
class __edm__RefVector_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_ {
  public:
  __edm__RefVector_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_();
  ::edm::RefVectorBase<unsigned int> refVector_;
};
#ifdef __edm__RefVector_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_
#undef __edm__RefVector_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_
#endif
class __edm__RefVector_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_ {
  public:
  __edm__RefVector_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_();
  ::edm::RefVectorBase<unsigned int> refVector_;
};
#ifdef __edm__RefVector_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_
#undef __edm__RefVector_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_
#endif
class __edm__RefVector_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_ {
  public:
  __edm__RefVector_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_();
  ::edm::RefVectorBase<unsigned int> refVector_;
};
#ifdef __edm__Wrapper_std__vector_BoundaryInformation_s_
#undef __edm__Wrapper_std__vector_BoundaryInformation_s_
#endif
class __edm__Wrapper_std__vector_BoundaryInformation_s_ {
  public:
  __edm__Wrapper_std__vector_BoundaryInformation_s_();
  bool present;
  ::std::vector<BoundaryInformation> obj;
};
#ifdef __edm__Wrapper_BoundaryInformation_
#undef __edm__Wrapper_BoundaryInformation_
#endif
class __edm__Wrapper_BoundaryInformation_ {
  public:
  __edm__Wrapper_BoundaryInformation_();
  bool present;
  ::BoundaryInformation obj;
};
#ifdef __edm__Wrapper_AnomalousECALVariables_
#undef __edm__Wrapper_AnomalousECALVariables_
#endif
class __edm__Wrapper_AnomalousECALVariables_ {
  public:
  __edm__Wrapper_AnomalousECALVariables_();
  bool present;
  ::AnomalousECALVariables obj;
};
#ifdef __edm__Wrapper_PFMEtSignCovMatrix_
#undef __edm__Wrapper_PFMEtSignCovMatrix_
#endif
class __edm__Wrapper_PFMEtSignCovMatrix_ {
  public:
  __edm__Wrapper_PFMEtSignCovMatrix_();
  bool present;
  ::PFMEtSignCovMatrix obj;
};
#ifdef __edm__Wrapper_std__vector_metsig__SigInputObj_s_
#undef __edm__Wrapper_std__vector_metsig__SigInputObj_s_
#endif
class __edm__Wrapper_std__vector_metsig__SigInputObj_s_ {
  public:
  __edm__Wrapper_std__vector_metsig__SigInputObj_s_();
  bool present;
  ::std::vector<metsig::SigInputObj> obj;
};
#ifdef __edm__Wrapper_metsig__SigInputObj_
#undef __edm__Wrapper_metsig__SigInputObj_
#endif
class __edm__Wrapper_metsig__SigInputObj_ {
  public:
  __edm__Wrapper_metsig__SigInputObj_();
  bool present;
  ::metsig::SigInputObj obj;
};
#ifdef __edm__Wrapper_std__vector_CorrMETData_s_
#undef __edm__Wrapper_std__vector_CorrMETData_s_
#endif
class __edm__Wrapper_std__vector_CorrMETData_s_ {
  public:
  __edm__Wrapper_std__vector_CorrMETData_s_();
  bool present;
  ::std::vector<CorrMETData> obj;
};
#ifdef __edm__Wrapper_CorrMETData_
#undef __edm__Wrapper_CorrMETData_
#endif
class __edm__Wrapper_CorrMETData_ {
  public:
  __edm__Wrapper_CorrMETData_();
  bool present;
  ::CorrMETData obj;
};
#ifdef __edm__Wrapper_std__vector_CommonMETData_s_
#undef __edm__Wrapper_std__vector_CommonMETData_s_
#endif
class __edm__Wrapper_std__vector_CommonMETData_s_ {
  public:
  __edm__Wrapper_std__vector_CommonMETData_s_();
  bool present;
  ::std::vector<CommonMETData> obj;
};
#ifdef __edm__Wrapper_CommonMETData_
#undef __edm__Wrapper_CommonMETData_
#endif
class __edm__Wrapper_CommonMETData_ {
  public:
  __edm__Wrapper_CommonMETData_();
  bool present;
  ::CommonMETData obj;
};
#ifdef __edm__Wrapper_std__vector_Point3DBase_float_GlobalTag_s_s_
#undef __edm__Wrapper_std__vector_Point3DBase_float_GlobalTag_s_s_
#endif
class __edm__Wrapper_std__vector_Point3DBase_float_GlobalTag_s_s_ {
  public:
  __edm__Wrapper_std__vector_Point3DBase_float_GlobalTag_s_s_();
  bool present;
  ::std::vector<Point3DBase<float,GlobalTag> > obj;
};
#ifdef __reco__BeamHaloSummary
#undef __reco__BeamHaloSummary
#endif
class __reco__BeamHaloSummary {
  public:
  __reco__BeamHaloSummary();
  virtual ~__reco__BeamHaloSummary() throw();
  ::std::vector<char> HcalHaloReport;
  ::std::vector<char> EcalHaloReport;
  ::std::vector<char> CSCHaloReport;
  ::std::vector<char> GlobalHaloReport;
  ::std::vector<int> HcaliPhiSuspects;
  ::std::vector<int> EcaliPhiSuspects;
  ::std::vector<int> GlobaliPhiSuspects;
};
#ifdef __edm__Wrapper_reco__BeamHaloSummary_
#undef __edm__Wrapper_reco__BeamHaloSummary_
#endif
class __edm__Wrapper_reco__BeamHaloSummary_ {
  public:
  __edm__Wrapper_reco__BeamHaloSummary_();
  bool present;
  ::reco::BeamHaloSummary obj;
};
#ifdef __reco__GlobalHaloData
#undef __reco__GlobalHaloData
#endif
class __reco__GlobalHaloData {
  public:
  __reco__GlobalHaloData();
  float METOverSumEt_;
  float dMEx_;
  float dMEy_;
  float dSumEt_;
  ::std::vector<reco::PhiWedge> HcalPhiWedges;
  ::std::vector<reco::PhiWedge> EcalPhiWedges;
};
#ifdef __edm__Wrapper_reco__GlobalHaloData_
#undef __edm__Wrapper_reco__GlobalHaloData_
#endif
class __edm__Wrapper_reco__GlobalHaloData_ {
  public:
  __edm__Wrapper_reco__GlobalHaloData_();
  bool present;
  ::reco::GlobalHaloData obj;
};
#ifdef __reco__CSCHaloData
#undef __reco__CSCHaloData
#endif
class __reco__CSCHaloData {
  public:
  __reco__CSCHaloData();
  virtual ~__reco__CSCHaloData() throw();
  ::edm::RefVector<std::vector<reco::Track>,reco::Track,edm::refhelper::FindUsingAdvance<std::vector<reco::Track>,reco::Track> > TheTrackRefs;
  ::std::vector<Point3DBase<float,GlobalTag> > TheGlobalPositions;
  int nTriggers_PlusZ;
  int nTriggers_MinusZ;
  bool HLTAccept;
  int nTracks_PlusZ;
  int nTracks_MinusZ;
  short nOutOfTimeTriggers_PlusZ;
  short nOutOfTimeTriggers_MinusZ;
  short nOutOfTimeHits;
  short nTracks_Small_dT;
  short nTracks_Small_beta;
  short nTracks_Small_dT_Small_beta;
  short nFlatHaloSegments;
  bool segments_in_both_endcaps;
};
#ifdef __edm__Wrapper_reco__CSCHaloData_
#undef __edm__Wrapper_reco__CSCHaloData_
#endif
class __edm__Wrapper_reco__CSCHaloData_ {
  public:
  __edm__Wrapper_reco__CSCHaloData_();
  bool present;
  ::reco::CSCHaloData obj;
};
#ifdef __reco__HcalHaloData
#undef __reco__HcalHaloData
#endif
class __reco__HcalHaloData {
  public:
  __reco__HcalHaloData();
  ::std::vector<reco::PhiWedge> PhiWedgeCollection;
};
#ifdef __edm__Wrapper_reco__HcalHaloData_
#undef __edm__Wrapper_reco__HcalHaloData_
#endif
class __edm__Wrapper_reco__HcalHaloData_ {
  public:
  __edm__Wrapper_reco__HcalHaloData_();
  bool present;
  ::reco::HcalHaloData obj;
};
#ifdef __reco__EcalHaloData
#undef __reco__EcalHaloData
#endif
class __reco__EcalHaloData {
  public:
  __reco__EcalHaloData();
  ::std::vector<reco::PhiWedge> PhiWedgeCollection;
  ::edm::RefVector<std::vector<reco::SuperCluster>,reco::SuperCluster,edm::refhelper::FindUsingAdvance<std::vector<reco::SuperCluster>,reco::SuperCluster> > TheSuperClusterRefs;
  ::edm::ValueMap<float> ShowerShapes_Roundness;
  ::edm::ValueMap<float> ShowerShapes_Angle;
};
#ifdef __edm__Wrapper_reco__EcalHaloData_
#undef __edm__Wrapper_reco__EcalHaloData_
#endif
class __edm__Wrapper_reco__EcalHaloData_ {
  public:
  __edm__Wrapper_reco__EcalHaloData_();
  bool present;
  ::reco::EcalHaloData obj;
};
#ifdef __edm__Wrapper_reco__PhiWedge_
#undef __edm__Wrapper_reco__PhiWedge_
#endif
class __edm__Wrapper_reco__PhiWedge_ {
  public:
  __edm__Wrapper_reco__PhiWedge_();
  bool present;
  ::reco::PhiWedge obj;
};
#ifdef __edm__Wrapper_HcalNoiseSummary_
#undef __edm__Wrapper_HcalNoiseSummary_
#endif
class __edm__Wrapper_HcalNoiseSummary_ {
  public:
  __edm__Wrapper_HcalNoiseSummary_();
  bool present;
  ::HcalNoiseSummary obj;
};
#ifdef __edm__Wrapper_std__vector_reco__PFClusterMET_s_
#undef __edm__Wrapper_std__vector_reco__PFClusterMET_s_
#endif
class __edm__Wrapper_std__vector_reco__PFClusterMET_s_ {
  public:
  __edm__Wrapper_std__vector_reco__PFClusterMET_s_();
  bool present;
  ::std::vector<reco::PFClusterMET> obj;
};
#ifdef __edm__Wrapper_reco__PFClusterMET_
#undef __edm__Wrapper_reco__PFClusterMET_
#endif
class __edm__Wrapper_reco__PFClusterMET_ {
  public:
  __edm__Wrapper_reco__PFClusterMET_();
  bool present;
  ::reco::PFClusterMET obj;
};
#ifdef __edm__Wrapper_std__vector_reco__PFMET_s_
#undef __edm__Wrapper_std__vector_reco__PFMET_s_
#endif
class __edm__Wrapper_std__vector_reco__PFMET_s_ {
  public:
  __edm__Wrapper_std__vector_reco__PFMET_s_();
  bool present;
  ::std::vector<reco::PFMET> obj;
};
#ifdef __edm__Wrapper_reco__PFMET_
#undef __edm__Wrapper_reco__PFMET_
#endif
class __edm__Wrapper_reco__PFMET_ {
  public:
  __edm__Wrapper_reco__PFMET_();
  bool present;
  ::reco::PFMET obj;
};
#ifdef __edm__Wrapper_std__vector_reco__MET_s_
#undef __edm__Wrapper_std__vector_reco__MET_s_
#endif
class __edm__Wrapper_std__vector_reco__MET_s_ {
  public:
  __edm__Wrapper_std__vector_reco__MET_s_();
  bool present;
  ::std::vector<reco::MET> obj;
};
#ifdef __edm__Wrapper_reco__MET_
#undef __edm__Wrapper_reco__MET_
#endif
class __edm__Wrapper_reco__MET_ {
  public:
  __edm__Wrapper_reco__MET_();
  bool present;
  ::reco::MET obj;
};
#ifdef __edm__Wrapper_std__vector_reco__GenMET_s_
#undef __edm__Wrapper_std__vector_reco__GenMET_s_
#endif
class __edm__Wrapper_std__vector_reco__GenMET_s_ {
  public:
  __edm__Wrapper_std__vector_reco__GenMET_s_();
  bool present;
  ::std::vector<reco::GenMET> obj;
};
#ifdef __edm__Wrapper_reco__GenMET_
#undef __edm__Wrapper_reco__GenMET_
#endif
class __edm__Wrapper_reco__GenMET_ {
  public:
  __edm__Wrapper_reco__GenMET_();
  bool present;
  ::reco::GenMET obj;
};
#ifdef __edm__Wrapper_std__vector_reco__CaloMET_s_
#undef __edm__Wrapper_std__vector_reco__CaloMET_s_
#endif
class __edm__Wrapper_std__vector_reco__CaloMET_s_ {
  public:
  __edm__Wrapper_std__vector_reco__CaloMET_s_();
  bool present;
  ::std::vector<reco::CaloMET> obj;
};
#ifdef __edm__Wrapper_reco__CaloMET_
#undef __edm__Wrapper_reco__CaloMET_
#endif
class __edm__Wrapper_reco__CaloMET_ {
  public:
  __edm__Wrapper_reco__CaloMET_();
  bool present;
  ::reco::CaloMET obj;
};
#ifdef __edm__RefProd_std__vector_reco__PFClusterMET_s_
#undef __edm__RefProd_std__vector_reco__PFClusterMET_s_
#endif
class __edm__RefProd_std__vector_reco__PFClusterMET_s_ {
  public:
  __edm__RefProd_std__vector_reco__PFClusterMET_s_();
  ::edm::RefCore product_;
};
#ifdef __edm__RefProd_std__vector_reco__PFMET_s_
#undef __edm__RefProd_std__vector_reco__PFMET_s_
#endif
class __edm__RefProd_std__vector_reco__PFMET_s_ {
  public:
  __edm__RefProd_std__vector_reco__PFMET_s_();
  ::edm::RefCore product_;
};
#ifdef __edm__RefProd_std__vector_reco__MET_s_
#undef __edm__RefProd_std__vector_reco__MET_s_
#endif
class __edm__RefProd_std__vector_reco__MET_s_ {
  public:
  __edm__RefProd_std__vector_reco__MET_s_();
  ::edm::RefCore product_;
};
#ifdef __edm__RefProd_std__vector_reco__GenMET_s_
#undef __edm__RefProd_std__vector_reco__GenMET_s_
#endif
class __edm__RefProd_std__vector_reco__GenMET_s_ {
  public:
  __edm__RefProd_std__vector_reco__GenMET_s_();
  ::edm::RefCore product_;
};
#ifdef __edm__RefProd_std__vector_reco__CaloMET_s_
#undef __edm__RefProd_std__vector_reco__CaloMET_s_
#endif
class __edm__RefProd_std__vector_reco__CaloMET_s_ {
  public:
  __edm__RefProd_std__vector_reco__CaloMET_s_();
  ::edm::RefCore product_;
};
#ifdef __edm__Ptr_reco__MET_
#undef __edm__Ptr_reco__MET_
#endif
class __edm__Ptr_reco__MET_ {
  public:
  __edm__Ptr_reco__MET_();
  ::edm::RefCore core_;
  unsigned long key_;
};
#ifdef __edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_
#undef __edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_
#endif
class __edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_ {
  public:
  __edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_();
  ::edm::RefCoreWithIndex product_;
};
#ifdef __edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_
#undef __edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_
#endif
class __edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_ {
  public:
  __edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_();
  ::edm::RefCoreWithIndex product_;
};
#ifdef __edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_
#undef __edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_
#endif
class __edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_ {
  public:
  __edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_();
  ::edm::RefCoreWithIndex product_;
};
#ifdef __reco__MVAMEtPFCandInfo
#undef __reco__MVAMEtPFCandInfo
#endif
struct __reco__MVAMEtPFCandInfo {
  public:
  __reco__MVAMEtPFCandInfo();
  ::math::XYZTLorentzVector p4_;
  int charge_;
  int type_;
  bool isWithinJet_;
  bool passesLooseJetId_;
  ::metsig::SigInputObj pfMEtSignObj_;
};
#ifdef __reco__HcalNoiseRBX
#undef __reco__HcalNoiseRBX
#endif
class __reco__HcalNoiseRBX {
  public:
  __reco__HcalNoiseRBX();
  virtual ~__reco__HcalNoiseRBX() throw();
#ifdef __reco__HcalNoiseRBX__twrcomp
#undef __reco__HcalNoiseRBX__twrcomp
#endif
  struct __reco__HcalNoiseRBX__twrcomp {
    public:
    __reco__HcalNoiseRBX__twrcomp();
  };
  int idnumber_;
  ::std::vector<reco::HcalNoiseHPD> hpds_;
  ::std::vector<float> allCharge_;
};
#ifdef __reco__MVAMEtJetInfo
#undef __reco__MVAMEtJetInfo
#endif
struct __reco__MVAMEtJetInfo {
  public:
  __reco__MVAMEtJetInfo();
  ::math::XYZTLorentzVector p4_;
  int type_;
  bool passesLooseJetId_;
  double neutralEnFrac_;
  double offsetEnCorr_;
  ::metsig::SigInputObj pfMEtSignObj_;
};
#ifdef __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_s_
#undef __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_s_
#endif
class __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_s_ : public ::edm::reftobase::BaseHolder<reco::Candidate> {
  public:
  __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_s_();
  virtual ~__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_s_() throw();
  ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > ref_;
};
#ifdef __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_s_
#undef __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_s_
#endif
class __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_s_ : public ::edm::reftobase::BaseHolder<reco::Candidate> {
  public:
  __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_s_();
  virtual ~__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_s_() throw();
  ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > ref_;
};
#ifdef __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s_
#undef __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s_
#endif
class __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s_ : public ::edm::reftobase::BaseHolder<reco::Candidate> {
  public:
  __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s_();
  virtual ~__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s_() throw();
  ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > ref_;
};
#ifdef __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_s_
#undef __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_s_
#endif
class __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_s_ : public ::edm::reftobase::BaseHolder<reco::Candidate> {
  public:
  __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_s_();
  virtual ~__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_s_() throw();
  ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > ref_;
};
#ifdef __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s_
#undef __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s_
#endif
class __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s_ : public ::edm::reftobase::BaseHolder<reco::Candidate> {
  public:
  __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s_();
  virtual ~__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s_() throw();
  ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > ref_;
};
#ifdef __std__vector_reco__MVAMEtPFCandInfo_
#undef __std__vector_reco__MVAMEtPFCandInfo_
#endif
class __std__vector_reco__MVAMEtPFCandInfo_ : protected ::std::_Vector_base<reco::MVAMEtPFCandInfo,std::allocator<reco::MVAMEtPFCandInfo> > {
  public:
  __std__vector_reco__MVAMEtPFCandInfo_();
};
#ifdef __std__vector_reco__HcalNoiseRBX_
#undef __std__vector_reco__HcalNoiseRBX_
#endif
class __std__vector_reco__HcalNoiseRBX_ : protected ::std::_Vector_base<reco::HcalNoiseRBX,std::allocator<reco::HcalNoiseRBX> > {
  public:
  __std__vector_reco__HcalNoiseRBX_();
};
#ifdef __std__vector_reco__MVAMEtJetInfo_
#undef __std__vector_reco__MVAMEtJetInfo_
#endif
class __std__vector_reco__MVAMEtJetInfo_ : protected ::std::_Vector_base<reco::MVAMEtJetInfo,std::allocator<reco::MVAMEtJetInfo> > {
  public:
  __std__vector_reco__MVAMEtJetInfo_();
};
#ifdef ____gnu_cxx____normal_iterator_reco__PhiWedgep_std__vector_reco__PhiWedge_s_
#undef ____gnu_cxx____normal_iterator_reco__PhiWedgep_std__vector_reco__PhiWedge_s_
#endif
class ____gnu_cxx____normal_iterator_reco__PhiWedgep_std__vector_reco__PhiWedge_s_ {
  public:
  ____gnu_cxx____normal_iterator_reco__PhiWedgep_std__vector_reco__PhiWedge_s_();
  void* _M_current;
};
#ifdef ____gnu_cxx____normal_iterator_constsreco__HcalNoiseHPDp_std__vector_reco__HcalNoiseHPD_s_
#undef ____gnu_cxx____normal_iterator_constsreco__HcalNoiseHPDp_std__vector_reco__HcalNoiseHPD_s_
#endif
class ____gnu_cxx____normal_iterator_constsreco__HcalNoiseHPDp_std__vector_reco__HcalNoiseHPD_s_ {
  public:
  ____gnu_cxx____normal_iterator_constsreco__HcalNoiseHPDp_std__vector_reco__HcalNoiseHPD_s_();
  void* _M_current;
};
#ifdef __edm__Wrapper_std__vector_reco__MVAMEtPFCandInfo_s_
#undef __edm__Wrapper_std__vector_reco__MVAMEtPFCandInfo_s_
#endif
class __edm__Wrapper_std__vector_reco__MVAMEtPFCandInfo_s_ {
  public:
  __edm__Wrapper_std__vector_reco__MVAMEtPFCandInfo_s_();
  bool present;
  ::std::vector<reco::MVAMEtPFCandInfo> obj;
};
#ifdef __edm__Wrapper_std__vector_reco__MVAMEtJetInfo_s_
#undef __edm__Wrapper_std__vector_reco__MVAMEtJetInfo_s_
#endif
class __edm__Wrapper_std__vector_reco__MVAMEtJetInfo_s_ {
  public:
  __edm__Wrapper_std__vector_reco__MVAMEtJetInfo_s_();
  bool present;
  ::std::vector<reco::MVAMEtJetInfo> obj;
};
#ifdef __edm__Wrapper_std__vector_reco__HcalNoiseRBX_s_
#undef __edm__Wrapper_std__vector_reco__HcalNoiseRBX_s_
#endif
class __edm__Wrapper_std__vector_reco__HcalNoiseRBX_s_ {
  public:
  __edm__Wrapper_std__vector_reco__HcalNoiseRBX_s_();
  bool present;
  ::std::vector<reco::HcalNoiseRBX> obj;
};
#ifdef __edm__Wrapper_std__vector_reco__HcalNoiseHPD_s_
#undef __edm__Wrapper_std__vector_reco__HcalNoiseHPD_s_
#endif
class __edm__Wrapper_std__vector_reco__HcalNoiseHPD_s_ {
  public:
  __edm__Wrapper_std__vector_reco__HcalNoiseHPD_s_();
  bool present;
  ::std::vector<reco::HcalNoiseHPD> obj;
};
#ifdef __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_s_
#undef __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_s_
#endif
class __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_s_ : public ::edm::reftobase::RefHolderBase {
  public:
  __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_s_();
  virtual ~__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_s_() throw();
  ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > ref_;
};
#ifdef __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_s_
#undef __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_s_
#endif
class __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_s_ : public ::edm::reftobase::RefHolderBase {
  public:
  __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_s_();
  virtual ~__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_s_() throw();
  ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > ref_;
};
#ifdef __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_s_
#undef __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_s_
#endif
class __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_s_ : public ::edm::reftobase::RefHolderBase {
  public:
  __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_s_();
  virtual ~__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_s_() throw();
  ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > ref_;
};
#ifdef __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s_
#undef __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s_
#endif
class __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s_ : public ::edm::reftobase::RefHolderBase {
  public:
  __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s_();
  virtual ~__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s_() throw();
  ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > ref_;
};
#ifdef __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s_
#undef __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s_
#endif
class __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s_ : public ::edm::reftobase::RefHolderBase {
  public:
  __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s_();
  virtual ~__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s_() throw();
  ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > ref_;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class HcalNoiseSummary -------------------------------
static  void operator_4069( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HcalNoiseSummary*)o)->operator=)(*(const ::HcalNoiseSummary*)arg[0]);
  else   (((::HcalNoiseSummary*)o)->operator=)(*(const ::HcalNoiseSummary*)arg[0]);
}

static void constructor_4070( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalNoiseSummary(*(const ::HcalNoiseSummary*)arg[0]);
  else ::new(mem) ::HcalNoiseSummary(*(const ::HcalNoiseSummary*)arg[0]);
}

static void constructor_4071( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HcalNoiseSummary();
  else ::new(mem) ::HcalNoiseSummary();
}

static void destructor_4072(void*, void * o, const std::vector<void*>&, void *) {
(((::HcalNoiseSummary*)o)->::HcalNoiseSummary::~HcalNoiseSummary)();
}
static  void method_4073( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalNoiseSummary*)o)->passLooseNoiseFilter)());
  else   (((const ::HcalNoiseSummary*)o)->passLooseNoiseFilter)();
}

static  void method_4074( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalNoiseSummary*)o)->passTightNoiseFilter)());
  else   (((const ::HcalNoiseSummary*)o)->passTightNoiseFilter)();
}

static  void method_4075( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalNoiseSummary*)o)->passHighLevelNoiseFilter)());
  else   (((const ::HcalNoiseSummary*)o)->passHighLevelNoiseFilter)();
}

static  void method_4076( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalNoiseSummary*)o)->noiseFilterStatus)());
  else   (((const ::HcalNoiseSummary*)o)->noiseFilterStatus)();
}

static  void method_4077( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalNoiseSummary*)o)->noiseType)());
  else   (((const ::HcalNoiseSummary*)o)->noiseType)();
}

static  void method_4078( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalNoiseSummary*)o)->eventEMEnergy)());
  else   (((const ::HcalNoiseSummary*)o)->eventEMEnergy)();
}

static  void method_4079( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalNoiseSummary*)o)->eventHadEnergy)());
  else   (((const ::HcalNoiseSummary*)o)->eventHadEnergy)();
}

static  void method_4080( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalNoiseSummary*)o)->eventTrackEnergy)());
  else   (((const ::HcalNoiseSummary*)o)->eventTrackEnergy)();
}

static  void method_4081( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalNoiseSummary*)o)->eventEMFraction)());
  else   (((const ::HcalNoiseSummary*)o)->eventEMFraction)();
}

static  void method_4082( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalNoiseSummary*)o)->eventChargeFraction)());
  else   (((const ::HcalNoiseSummary*)o)->eventChargeFraction)();
}

static  void method_4083( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalNoiseSummary*)o)->min10GeVHitTime)());
  else   (((const ::HcalNoiseSummary*)o)->min10GeVHitTime)();
}

static  void method_4084( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalNoiseSummary*)o)->max10GeVHitTime)());
  else   (((const ::HcalNoiseSummary*)o)->max10GeVHitTime)();
}

static  void method_4085( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalNoiseSummary*)o)->rms10GeVHitTime)());
  else   (((const ::HcalNoiseSummary*)o)->rms10GeVHitTime)();
}

static  void method_4086( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalNoiseSummary*)o)->min25GeVHitTime)());
  else   (((const ::HcalNoiseSummary*)o)->min25GeVHitTime)();
}

static  void method_4087( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalNoiseSummary*)o)->max25GeVHitTime)());
  else   (((const ::HcalNoiseSummary*)o)->max25GeVHitTime)();
}

static  void method_4088( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalNoiseSummary*)o)->rms25GeVHitTime)());
  else   (((const ::HcalNoiseSummary*)o)->rms25GeVHitTime)();
}

static  void method_4089( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalNoiseSummary*)o)->num10GeVHits)());
  else   (((const ::HcalNoiseSummary*)o)->num10GeVHits)();
}

static  void method_4090( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalNoiseSummary*)o)->num25GeVHits)());
  else   (((const ::HcalNoiseSummary*)o)->num25GeVHits)();
}

static  void method_4091( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalNoiseSummary*)o)->minE2TS)());
  else   (((const ::HcalNoiseSummary*)o)->minE2TS)();
}

static  void method_4092( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalNoiseSummary*)o)->minE10TS)());
  else   (((const ::HcalNoiseSummary*)o)->minE10TS)();
}

static  void method_4093( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalNoiseSummary*)o)->minE2Over10TS)());
  else   (((const ::HcalNoiseSummary*)o)->minE2Over10TS)();
}

static  void method_4094( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalNoiseSummary*)o)->maxE2TS)());
  else   (((const ::HcalNoiseSummary*)o)->maxE2TS)();
}

static  void method_4095( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalNoiseSummary*)o)->maxE10TS)());
  else   (((const ::HcalNoiseSummary*)o)->maxE10TS)();
}

static  void method_4096( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalNoiseSummary*)o)->maxE2Over10TS)());
  else   (((const ::HcalNoiseSummary*)o)->maxE2Over10TS)();
}

static  void method_4097( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalNoiseSummary*)o)->maxZeros)());
  else   (((const ::HcalNoiseSummary*)o)->maxZeros)();
}

static  void method_4098( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalNoiseSummary*)o)->maxHPDHits)());
  else   (((const ::HcalNoiseSummary*)o)->maxHPDHits)();
}

static  void method_4099( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalNoiseSummary*)o)->maxRBXHits)());
  else   (((const ::HcalNoiseSummary*)o)->maxRBXHits)();
}

static  void method_4100( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalNoiseSummary*)o)->maxHPDNoOtherHits)());
  else   (((const ::HcalNoiseSummary*)o)->maxHPDNoOtherHits)();
}

static  void method_4101( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalNoiseSummary*)o)->minHPDEMF)());
  else   (((const ::HcalNoiseSummary*)o)->minHPDEMF)();
}

static  void method_4102( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalNoiseSummary*)o)->minRBXEMF)());
  else   (((const ::HcalNoiseSummary*)o)->minRBXEMF)();
}

static  void method_4103( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalNoiseSummary*)o)->numProblematicRBXs)());
  else   (((const ::HcalNoiseSummary*)o)->numProblematicRBXs)();
}

static  void method_4104( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalNoiseSummary*)o)->numIsolatedNoiseChannels)());
  else   (((const ::HcalNoiseSummary*)o)->numIsolatedNoiseChannels)();
}

static  void method_4105( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalNoiseSummary*)o)->isolatedNoiseSumE)());
  else   (((const ::HcalNoiseSummary*)o)->isolatedNoiseSumE)();
}

static  void method_4106( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalNoiseSummary*)o)->isolatedNoiseSumEt)());
  else   (((const ::HcalNoiseSummary*)o)->isolatedNoiseSumEt)();
}

static  void method_4107( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalNoiseSummary*)o)->numFlatNoiseChannels)());
  else   (((const ::HcalNoiseSummary*)o)->numFlatNoiseChannels)();
}

static  void method_4108( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalNoiseSummary*)o)->flatNoiseSumE)());
  else   (((const ::HcalNoiseSummary*)o)->flatNoiseSumE)();
}

static  void method_4109( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalNoiseSummary*)o)->flatNoiseSumEt)());
  else   (((const ::HcalNoiseSummary*)o)->flatNoiseSumEt)();
}

static  void method_4110( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalNoiseSummary*)o)->numSpikeNoiseChannels)());
  else   (((const ::HcalNoiseSummary*)o)->numSpikeNoiseChannels)();
}

static  void method_4111( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalNoiseSummary*)o)->spikeNoiseSumE)());
  else   (((const ::HcalNoiseSummary*)o)->spikeNoiseSumE)();
}

static  void method_4112( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalNoiseSummary*)o)->spikeNoiseSumEt)());
  else   (((const ::HcalNoiseSummary*)o)->spikeNoiseSumEt)();
}

static  void method_4113( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalNoiseSummary*)o)->numTriangleNoiseChannels)());
  else   (((const ::HcalNoiseSummary*)o)->numTriangleNoiseChannels)();
}

static  void method_4114( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalNoiseSummary*)o)->triangleNoiseSumE)());
  else   (((const ::HcalNoiseSummary*)o)->triangleNoiseSumE)();
}

static  void method_4115( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalNoiseSummary*)o)->triangleNoiseSumEt)());
  else   (((const ::HcalNoiseSummary*)o)->triangleNoiseSumEt)();
}

static  void method_4116( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalNoiseSummary*)o)->numTS4TS5NoiseChannels)());
  else   (((const ::HcalNoiseSummary*)o)->numTS4TS5NoiseChannels)();
}

static  void method_4117( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalNoiseSummary*)o)->TS4TS5NoiseSumE)());
  else   (((const ::HcalNoiseSummary*)o)->TS4TS5NoiseSumE)();
}

static  void method_4118( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::HcalNoiseSummary*)o)->TS4TS5NoiseSumEt)());
  else   (((const ::HcalNoiseSummary*)o)->TS4TS5NoiseSumEt)();
}

static  void method_4119( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalNoiseSummary*)o)->GetRecHitCount)());
  else   (((const ::HcalNoiseSummary*)o)->GetRecHitCount)();
}

static  void method_4120( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalNoiseSummary*)o)->GetRecHitCount15)());
  else   (((const ::HcalNoiseSummary*)o)->GetRecHitCount15)();
}

static  void method_4121( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HcalNoiseSummary*)o)->GetRecHitEnergy)());
  else   (((const ::HcalNoiseSummary*)o)->GetRecHitEnergy)();
}

static  void method_4122( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HcalNoiseSummary*)o)->GetRecHitEnergy15)());
  else   (((const ::HcalNoiseSummary*)o)->GetRecHitEnergy15)();
}

static  void method_4123( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HcalNoiseSummary*)o)->GetTotalCalibCharge)());
  else   (((const ::HcalNoiseSummary*)o)->GetTotalCalibCharge)();
}

static  void method_4124( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HcalNoiseSummary*)o)->HasBadRBXTS4TS5)());
  else   (((const ::HcalNoiseSummary*)o)->HasBadRBXTS4TS5)();
}

static  void method_4125( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalNoiseSummary*)o)->GetCalibCountTS45)());
  else   (((const ::HcalNoiseSummary*)o)->GetCalibCountTS45)();
}

static  void method_4126( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalNoiseSummary*)o)->GetCalibgt15CountTS45)());
  else   (((const ::HcalNoiseSummary*)o)->GetCalibgt15CountTS45)();
}

static  void method_4127( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HcalNoiseSummary*)o)->GetCalibChargeTS45)());
  else   (((const ::HcalNoiseSummary*)o)->GetCalibChargeTS45)();
}

static  void method_4128( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HcalNoiseSummary*)o)->GetCalibgt15ChargeTS45)());
  else   (((const ::HcalNoiseSummary*)o)->GetCalibgt15ChargeTS45)();
}

static  void method_4129( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalNoiseSummary*)o)->GetHitsInNonLaserRegion)());
  else   (((const ::HcalNoiseSummary*)o)->GetHitsInNonLaserRegion)();
}

static  void method_4130( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::HcalNoiseSummary*)o)->GetHitsInLaserRegion)());
  else   (((const ::HcalNoiseSummary*)o)->GetHitsInLaserRegion)();
}

static  void method_4131( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HcalNoiseSummary*)o)->GetEnergyInNonLaserRegion)());
  else   (((const ::HcalNoiseSummary*)o)->GetEnergyInNonLaserRegion)();
}

static  void method_4132( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HcalNoiseSummary*)o)->GetEnergyInLaserRegion)());
  else   (((const ::HcalNoiseSummary*)o)->GetEnergyInLaserRegion)();
}

static  void method_4133( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVector<std::vector<reco::CaloJet>,reco::CaloJet,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloJet>,reco::CaloJet> >)((((const ::HcalNoiseSummary*)o)->problematicJets)());
  else   (((const ::HcalNoiseSummary*)o)->problematicJets)();
}

static  void method_4134( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVector<edm::SortedCollection<CaloTower,edm::StrictWeakOrdering<CaloTower> >,CaloTower,edm::refhelper::FindUsingAdvance<edm::SortedCollection<CaloTower,edm::StrictWeakOrdering<CaloTower> >,CaloTower> >)((((const ::HcalNoiseSummary*)o)->looseNoiseTowers)());
  else   (((const ::HcalNoiseSummary*)o)->looseNoiseTowers)();
}

static  void method_4135( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVector<edm::SortedCollection<CaloTower,edm::StrictWeakOrdering<CaloTower> >,CaloTower,edm::refhelper::FindUsingAdvance<edm::SortedCollection<CaloTower,edm::StrictWeakOrdering<CaloTower> >,CaloTower> >)((((const ::HcalNoiseSummary*)o)->tightNoiseTowers)());
  else   (((const ::HcalNoiseSummary*)o)->tightNoiseTowers)();
}

static  void method_4136( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVector<edm::SortedCollection<CaloTower,edm::StrictWeakOrdering<CaloTower> >,CaloTower,edm::refhelper::FindUsingAdvance<edm::SortedCollection<CaloTower,edm::StrictWeakOrdering<CaloTower> >,CaloTower> >)((((const ::HcalNoiseSummary*)o)->highLevelNoiseTowers)());
  else   (((const ::HcalNoiseSummary*)o)->highLevelNoiseTowers)();
}

static void method_newdel_87( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HcalNoiseSummary >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HcalNoiseSummary >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HcalNoiseSummary >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HcalNoiseSummary >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HcalNoiseSummary >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HcalNoiseSummary -------------------------------
void __HcalNoiseSummary_db_datamem(Reflex::Class*);
void __HcalNoiseSummary_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HcalNoiseSummary_datamem_bld(&__HcalNoiseSummary_db_datamem);
Reflex::GenreflexMemberBuilder __HcalNoiseSummary_funcmem_bld(&__HcalNoiseSummary_db_funcmem);
void __HcalNoiseSummary_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HcalNoiseSummary"), typeid(::HcalNoiseSummary), sizeof(::HcalNoiseSummary), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "14")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19717, type_19718), Reflex::Literal("operator="), operator_4069, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19718), Reflex::Literal("HcalNoiseSummary"), constructor_4070, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalNoiseSummary"), constructor_4071, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalNoiseSummary"), destructor_4072, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_87, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HcalNoiseSummary_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HcalNoiseSummary_funcmem_bld);
}

//------Delayed data member builder for class HcalNoiseSummary -------------------
void __HcalNoiseSummary_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_72, Reflex::Literal("filterstatus_"), OffsetOf(__shadow__::__HcalNoiseSummary, filterstatus_), ::Reflex::PRIVATE)
  .AddDataMember(type_72, Reflex::Literal("noisetype_"), OffsetOf(__shadow__::__HcalNoiseSummary, noisetype_), ::Reflex::PRIVATE)
  .AddDataMember(type_932, Reflex::Literal("emenergy_"), OffsetOf(__shadow__::__HcalNoiseSummary, emenergy_), ::Reflex::PRIVATE)
  .AddDataMember(type_932, Reflex::Literal("hadenergy_"), OffsetOf(__shadow__::__HcalNoiseSummary, hadenergy_), ::Reflex::PRIVATE)
  .AddDataMember(type_932, Reflex::Literal("trackenergy_"), OffsetOf(__shadow__::__HcalNoiseSummary, trackenergy_), ::Reflex::PRIVATE)
  .AddDataMember(type_932, Reflex::Literal("min10_"), OffsetOf(__shadow__::__HcalNoiseSummary, min10_), ::Reflex::PRIVATE)
  .AddDataMember(type_932, Reflex::Literal("max10_"), OffsetOf(__shadow__::__HcalNoiseSummary, max10_), ::Reflex::PRIVATE)
  .AddDataMember(type_932, Reflex::Literal("rms10_"), OffsetOf(__shadow__::__HcalNoiseSummary, rms10_), ::Reflex::PRIVATE)
  .AddDataMember(type_932, Reflex::Literal("min25_"), OffsetOf(__shadow__::__HcalNoiseSummary, min25_), ::Reflex::PRIVATE)
  .AddDataMember(type_932, Reflex::Literal("max25_"), OffsetOf(__shadow__::__HcalNoiseSummary, max25_), ::Reflex::PRIVATE)
  .AddDataMember(type_932, Reflex::Literal("rms25_"), OffsetOf(__shadow__::__HcalNoiseSummary, rms25_), ::Reflex::PRIVATE)
  .AddDataMember(type_72, Reflex::Literal("cnthit10_"), OffsetOf(__shadow__::__HcalNoiseSummary, cnthit10_), ::Reflex::PRIVATE)
  .AddDataMember(type_72, Reflex::Literal("cnthit25_"), OffsetOf(__shadow__::__HcalNoiseSummary, cnthit25_), ::Reflex::PRIVATE)
  .AddDataMember(type_932, Reflex::Literal("mine2ts_"), OffsetOf(__shadow__::__HcalNoiseSummary, mine2ts_), ::Reflex::PRIVATE)
  .AddDataMember(type_932, Reflex::Literal("mine10ts_"), OffsetOf(__shadow__::__HcalNoiseSummary, mine10ts_), ::Reflex::PRIVATE)
  .AddDataMember(type_932, Reflex::Literal("maxe2ts_"), OffsetOf(__shadow__::__HcalNoiseSummary, maxe2ts_), ::Reflex::PRIVATE)
  .AddDataMember(type_932, Reflex::Literal("maxe10ts_"), OffsetOf(__shadow__::__HcalNoiseSummary, maxe10ts_), ::Reflex::PRIVATE)
  .AddDataMember(type_72, Reflex::Literal("maxzeros_"), OffsetOf(__shadow__::__HcalNoiseSummary, maxzeros_), ::Reflex::PRIVATE)
  .AddDataMember(type_72, Reflex::Literal("maxhpdhits_"), OffsetOf(__shadow__::__HcalNoiseSummary, maxhpdhits_), ::Reflex::PRIVATE)
  .AddDataMember(type_72, Reflex::Literal("maxhpdhitsnoother_"), OffsetOf(__shadow__::__HcalNoiseSummary, maxhpdhitsnoother_), ::Reflex::PRIVATE)
  .AddDataMember(type_72, Reflex::Literal("maxrbxhits_"), OffsetOf(__shadow__::__HcalNoiseSummary, maxrbxhits_), ::Reflex::PRIVATE)
  .AddDataMember(type_932, Reflex::Literal("minhpdemf_"), OffsetOf(__shadow__::__HcalNoiseSummary, minhpdemf_), ::Reflex::PRIVATE)
  .AddDataMember(type_932, Reflex::Literal("minrbxemf_"), OffsetOf(__shadow__::__HcalNoiseSummary, minrbxemf_), ::Reflex::PRIVATE)
  .AddDataMember(type_72, Reflex::Literal("nproblemRBXs_"), OffsetOf(__shadow__::__HcalNoiseSummary, nproblemRBXs_), ::Reflex::PRIVATE)
  .AddDataMember(type_72, Reflex::Literal("nisolnoise_"), OffsetOf(__shadow__::__HcalNoiseSummary, nisolnoise_), ::Reflex::PRIVATE)
  .AddDataMember(type_932, Reflex::Literal("isolnoisee_"), OffsetOf(__shadow__::__HcalNoiseSummary, isolnoisee_), ::Reflex::PRIVATE)
  .AddDataMember(type_932, Reflex::Literal("isolnoiseet_"), OffsetOf(__shadow__::__HcalNoiseSummary, isolnoiseet_), ::Reflex::PRIVATE)
  .AddDataMember(type_72, Reflex::Literal("nflatnoise_"), OffsetOf(__shadow__::__HcalNoiseSummary, nflatnoise_), ::Reflex::PRIVATE)
  .AddDataMember(type_932, Reflex::Literal("flatnoisee_"), OffsetOf(__shadow__::__HcalNoiseSummary, flatnoisee_), ::Reflex::PRIVATE)
  .AddDataMember(type_932, Reflex::Literal("flatnoiseet_"), OffsetOf(__shadow__::__HcalNoiseSummary, flatnoiseet_), ::Reflex::PRIVATE)
  .AddDataMember(type_72, Reflex::Literal("nspikenoise_"), OffsetOf(__shadow__::__HcalNoiseSummary, nspikenoise_), ::Reflex::PRIVATE)
  .AddDataMember(type_932, Reflex::Literal("spikenoisee_"), OffsetOf(__shadow__::__HcalNoiseSummary, spikenoisee_), ::Reflex::PRIVATE)
  .AddDataMember(type_932, Reflex::Literal("spikenoiseet_"), OffsetOf(__shadow__::__HcalNoiseSummary, spikenoiseet_), ::Reflex::PRIVATE)
  .AddDataMember(type_72, Reflex::Literal("ntrianglenoise_"), OffsetOf(__shadow__::__HcalNoiseSummary, ntrianglenoise_), ::Reflex::PRIVATE)
  .AddDataMember(type_932, Reflex::Literal("trianglenoisee_"), OffsetOf(__shadow__::__HcalNoiseSummary, trianglenoisee_), ::Reflex::PRIVATE)
  .AddDataMember(type_932, Reflex::Literal("trianglenoiseet_"), OffsetOf(__shadow__::__HcalNoiseSummary, trianglenoiseet_), ::Reflex::PRIVATE)
  .AddDataMember(type_72, Reflex::Literal("nts4ts5noise_"), OffsetOf(__shadow__::__HcalNoiseSummary, nts4ts5noise_), ::Reflex::PRIVATE)
  .AddDataMember(type_932, Reflex::Literal("ts4ts5noisee_"), OffsetOf(__shadow__::__HcalNoiseSummary, ts4ts5noisee_), ::Reflex::PRIVATE)
  .AddDataMember(type_932, Reflex::Literal("ts4ts5noiseet_"), OffsetOf(__shadow__::__HcalNoiseSummary, ts4ts5noiseet_), ::Reflex::PRIVATE)
  .AddDataMember(type_72, Reflex::Literal("rechitCount_"), OffsetOf(__shadow__::__HcalNoiseSummary, rechitCount_), ::Reflex::PRIVATE)
  .AddDataMember(type_72, Reflex::Literal("rechitCount15_"), OffsetOf(__shadow__::__HcalNoiseSummary, rechitCount15_), ::Reflex::PRIVATE)
  .AddDataMember(type_107, Reflex::Literal("rechitEnergy_"), OffsetOf(__shadow__::__HcalNoiseSummary, rechitEnergy_), ::Reflex::PRIVATE)
  .AddDataMember(type_107, Reflex::Literal("rechitEnergy15_"), OffsetOf(__shadow__::__HcalNoiseSummary, rechitEnergy15_), ::Reflex::PRIVATE)
  .AddDataMember(type_107, Reflex::Literal("calibCharge_"), OffsetOf(__shadow__::__HcalNoiseSummary, calibCharge_), ::Reflex::PRIVATE)
  .AddDataMember(type_1647, Reflex::Literal("hasBadRBXTS4TS5_"), OffsetOf(__shadow__::__HcalNoiseSummary, hasBadRBXTS4TS5_), ::Reflex::PRIVATE)
  .AddDataMember(type_72, Reflex::Literal("calibCountTS45_"), OffsetOf(__shadow__::__HcalNoiseSummary, calibCountTS45_), ::Reflex::PRIVATE)
  .AddDataMember(type_72, Reflex::Literal("calibCountgt15TS45_"), OffsetOf(__shadow__::__HcalNoiseSummary, calibCountgt15TS45_), ::Reflex::PRIVATE)
  .AddDataMember(type_107, Reflex::Literal("calibChargeTS45_"), OffsetOf(__shadow__::__HcalNoiseSummary, calibChargeTS45_), ::Reflex::PRIVATE)
  .AddDataMember(type_107, Reflex::Literal("calibChargegt15TS45_"), OffsetOf(__shadow__::__HcalNoiseSummary, calibChargegt15TS45_), ::Reflex::PRIVATE)
  .AddDataMember(type_72, Reflex::Literal("hitsInLaserRegion_"), OffsetOf(__shadow__::__HcalNoiseSummary, hitsInLaserRegion_), ::Reflex::PRIVATE)
  .AddDataMember(type_72, Reflex::Literal("hitsInNonLaserRegion_"), OffsetOf(__shadow__::__HcalNoiseSummary, hitsInNonLaserRegion_), ::Reflex::PRIVATE)
  .AddDataMember(type_107, Reflex::Literal("energyInLaserRegion_"), OffsetOf(__shadow__::__HcalNoiseSummary, energyInLaserRegion_), ::Reflex::PRIVATE)
  .AddDataMember(type_107, Reflex::Literal("energyInNonLaserRegion_"), OffsetOf(__shadow__::__HcalNoiseSummary, energyInNonLaserRegion_), ::Reflex::PRIVATE)
  .AddDataMember(type_4630, Reflex::Literal("problemjets_"), OffsetOf(__shadow__::__HcalNoiseSummary, problemjets_), ::Reflex::PRIVATE)
  .AddDataMember(type_1948, Reflex::Literal("loosenoisetwrs_"), OffsetOf(__shadow__::__HcalNoiseSummary, loosenoisetwrs_), ::Reflex::PRIVATE)
  .AddDataMember(type_1948, Reflex::Literal("tightnoisetwrs_"), OffsetOf(__shadow__::__HcalNoiseSummary, tightnoisetwrs_), ::Reflex::PRIVATE)
  .AddDataMember(type_1948, Reflex::Literal("hlnoisetwrs_"), OffsetOf(__shadow__::__HcalNoiseSummary, hlnoisetwrs_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class HcalNoiseSummary -------------------
void __HcalNoiseSummary_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("passLooseNoiseFilter"), method_4073, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("passTightNoiseFilter"), method_4074, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("passHighLevelNoiseFilter"), method_4075, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("noiseFilterStatus"), method_4076, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("noiseType"), method_4077, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("eventEMEnergy"), method_4078, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("eventHadEnergy"), method_4079, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("eventTrackEnergy"), method_4080, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("eventEMFraction"), method_4081, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("eventChargeFraction"), method_4082, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("min10GeVHitTime"), method_4083, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("max10GeVHitTime"), method_4084, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("rms10GeVHitTime"), method_4085, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("min25GeVHitTime"), method_4086, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("max25GeVHitTime"), method_4087, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("rms25GeVHitTime"), method_4088, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("num10GeVHits"), method_4089, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("num25GeVHits"), method_4090, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("minE2TS"), method_4091, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("minE10TS"), method_4092, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("minE2Over10TS"), method_4093, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("maxE2TS"), method_4094, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("maxE10TS"), method_4095, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("maxE2Over10TS"), method_4096, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("maxZeros"), method_4097, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("maxHPDHits"), method_4098, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("maxRBXHits"), method_4099, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("maxHPDNoOtherHits"), method_4100, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("minHPDEMF"), method_4101, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("minRBXEMF"), method_4102, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("numProblematicRBXs"), method_4103, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("numIsolatedNoiseChannels"), method_4104, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("isolatedNoiseSumE"), method_4105, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("isolatedNoiseSumEt"), method_4106, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("numFlatNoiseChannels"), method_4107, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("flatNoiseSumE"), method_4108, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("flatNoiseSumEt"), method_4109, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("numSpikeNoiseChannels"), method_4110, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("spikeNoiseSumE"), method_4111, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("spikeNoiseSumEt"), method_4112, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("numTriangleNoiseChannels"), method_4113, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("triangleNoiseSumE"), method_4114, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("triangleNoiseSumEt"), method_4115, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("numTS4TS5NoiseChannels"), method_4116, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("TS4TS5NoiseSumE"), method_4117, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("TS4TS5NoiseSumEt"), method_4118, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("GetRecHitCount"), method_4119, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("GetRecHitCount15"), method_4120, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("GetRecHitEnergy"), method_4121, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("GetRecHitEnergy15"), method_4122, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("GetTotalCalibCharge"), method_4123, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("HasBadRBXTS4TS5"), method_4124, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("GetCalibCountTS45"), method_4125, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("GetCalibgt15CountTS45"), method_4126, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("GetCalibChargeTS45"), method_4127, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("GetCalibgt15ChargeTS45"), method_4128, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("GetHitsInNonLaserRegion"), method_4129, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("GetHitsInLaserRegion"), method_4130, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("GetEnergyInNonLaserRegion"), method_4131, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("GetEnergyInLaserRegion"), method_4132, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4630), Reflex::Literal("problematicJets"), method_4133, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1948), Reflex::Literal("looseNoiseTowers"), method_4134, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1948), Reflex::Literal("tightNoiseTowers"), method_4135, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1948), Reflex::Literal("highLevelNoiseTowers"), method_4136, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class SpecificPFMETData -------------------------------
static void destructor_4597(void*, void * o, const std::vector<void*>&, void *) {
(((::SpecificPFMETData*)o)->::SpecificPFMETData::~SpecificPFMETData)();
}
static  void operator_4598( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SpecificPFMETData*)o)->operator=)(*(const ::SpecificPFMETData*)arg[0]);
  else   (((::SpecificPFMETData*)o)->operator=)(*(const ::SpecificPFMETData*)arg[0]);
}

static void constructor_4599( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SpecificPFMETData(*(const ::SpecificPFMETData*)arg[0]);
  else ::new(mem) ::SpecificPFMETData(*(const ::SpecificPFMETData*)arg[0]);
}

static void constructor_4600( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SpecificPFMETData();
  else ::new(mem) ::SpecificPFMETData();
}

static void method_newdel_468( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SpecificPFMETData >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SpecificPFMETData >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SpecificPFMETData >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SpecificPFMETData >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SpecificPFMETData >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class SpecificPFMETData -------------------------------
void __SpecificPFMETData_db_datamem(Reflex::Class*);
void __SpecificPFMETData_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SpecificPFMETData_datamem_bld(&__SpecificPFMETData_db_datamem);
Reflex::GenreflexMemberBuilder __SpecificPFMETData_funcmem_bld(&__SpecificPFMETData_db_funcmem);
void __SpecificPFMETData_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SpecificPFMETData"), typeid(::SpecificPFMETData), sizeof(::SpecificPFMETData), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SpecificPFMETData"), destructor_4597, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13956, type_13958), Reflex::Literal("operator="), operator_4598, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13958), Reflex::Literal("SpecificPFMETData"), constructor_4599, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SpecificPFMETData"), constructor_4600, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_468, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SpecificPFMETData_datamem_bld);
}

//------Delayed data member builder for class SpecificPFMETData -------------------
void __SpecificPFMETData_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_107, Reflex::Literal("NeutralEMFraction"), OffsetOf(__shadow__::__SpecificPFMETData, NeutralEMFraction), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("NeutralHadFraction"), OffsetOf(__shadow__::__SpecificPFMETData, NeutralHadFraction), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("ChargedEMFraction"), OffsetOf(__shadow__::__SpecificPFMETData, ChargedEMFraction), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("ChargedHadFraction"), OffsetOf(__shadow__::__SpecificPFMETData, ChargedHadFraction), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("MuonFraction"), OffsetOf(__shadow__::__SpecificPFMETData, MuonFraction), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("Type6Fraction"), OffsetOf(__shadow__::__SpecificPFMETData, Type6Fraction), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("Type7Fraction"), OffsetOf(__shadow__::__SpecificPFMETData, Type7Fraction), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class SpecificPFMETData -------------------
void __SpecificPFMETData_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class SpecificCaloMETData -------------------------------
static void destructor_6504(void*, void * o, const std::vector<void*>&, void *) {
(((::SpecificCaloMETData*)o)->::SpecificCaloMETData::~SpecificCaloMETData)();
}
static  void operator_6505( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SpecificCaloMETData*)o)->operator=)(*(const ::SpecificCaloMETData*)arg[0]);
  else   (((::SpecificCaloMETData*)o)->operator=)(*(const ::SpecificCaloMETData*)arg[0]);
}

static void constructor_6506( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SpecificCaloMETData(*(const ::SpecificCaloMETData*)arg[0]);
  else ::new(mem) ::SpecificCaloMETData(*(const ::SpecificCaloMETData*)arg[0]);
}

static void constructor_6507( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SpecificCaloMETData();
  else ::new(mem) ::SpecificCaloMETData();
}

static void method_newdel_930( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SpecificCaloMETData >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SpecificCaloMETData >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SpecificCaloMETData >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SpecificCaloMETData >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SpecificCaloMETData >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class SpecificCaloMETData -------------------------------
void __SpecificCaloMETData_db_datamem(Reflex::Class*);
void __SpecificCaloMETData_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SpecificCaloMETData_datamem_bld(&__SpecificCaloMETData_db_datamem);
Reflex::GenreflexMemberBuilder __SpecificCaloMETData_funcmem_bld(&__SpecificCaloMETData_db_funcmem);
void __SpecificCaloMETData_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SpecificCaloMETData"), typeid(::SpecificCaloMETData), sizeof(::SpecificCaloMETData), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SpecificCaloMETData"), destructor_6504, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14021, type_14023), Reflex::Literal("operator="), operator_6505, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14023), Reflex::Literal("SpecificCaloMETData"), constructor_6506, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SpecificCaloMETData"), constructor_6507, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_930, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SpecificCaloMETData_datamem_bld);
}

//------Delayed data member builder for class SpecificCaloMETData -------------------
void __SpecificCaloMETData_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_107, Reflex::Literal("MaxEtInEmTowers"), OffsetOf(__shadow__::__SpecificCaloMETData, MaxEtInEmTowers), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("MaxEtInHadTowers"), OffsetOf(__shadow__::__SpecificCaloMETData, MaxEtInHadTowers), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("HadEtInHO"), OffsetOf(__shadow__::__SpecificCaloMETData, HadEtInHO), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("HadEtInHB"), OffsetOf(__shadow__::__SpecificCaloMETData, HadEtInHB), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("HadEtInHF"), OffsetOf(__shadow__::__SpecificCaloMETData, HadEtInHF), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("HadEtInHE"), OffsetOf(__shadow__::__SpecificCaloMETData, HadEtInHE), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("EmEtInEB"), OffsetOf(__shadow__::__SpecificCaloMETData, EmEtInEB), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("EmEtInEE"), OffsetOf(__shadow__::__SpecificCaloMETData, EmEtInEE), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("EmEtInHF"), OffsetOf(__shadow__::__SpecificCaloMETData, EmEtInHF), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("EtFractionHadronic"), OffsetOf(__shadow__::__SpecificCaloMETData, EtFractionHadronic), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("EtFractionEm"), OffsetOf(__shadow__::__SpecificCaloMETData, EtFractionEm), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("METSignificance"), OffsetOf(__shadow__::__SpecificCaloMETData, METSignificance), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("CaloMETInpHF"), OffsetOf(__shadow__::__SpecificCaloMETData, CaloMETInpHF), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("CaloMETInmHF"), OffsetOf(__shadow__::__SpecificCaloMETData, CaloMETInmHF), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("CaloSETInpHF"), OffsetOf(__shadow__::__SpecificCaloMETData, CaloSETInpHF), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("CaloSETInmHF"), OffsetOf(__shadow__::__SpecificCaloMETData, CaloSETInmHF), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("CaloMETPhiInpHF"), OffsetOf(__shadow__::__SpecificCaloMETData, CaloMETPhiInpHF), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("CaloMETPhiInmHF"), OffsetOf(__shadow__::__SpecificCaloMETData, CaloMETPhiInmHF), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class SpecificCaloMETData -------------------
void __SpecificCaloMETData_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class AnomalousECALVariables -------------------------------
static  void operator_6757( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::AnomalousECALVariables*)o)->operator=)(*(const ::AnomalousECALVariables*)arg[0]);
  else   (((::AnomalousECALVariables*)o)->operator=)(*(const ::AnomalousECALVariables*)arg[0]);
}

static void constructor_6758( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::AnomalousECALVariables(*(const ::AnomalousECALVariables*)arg[0]);
  else ::new(mem) ::AnomalousECALVariables(*(const ::AnomalousECALVariables*)arg[0]);
}

static void constructor_6759( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::AnomalousECALVariables();
  else ::new(mem) ::AnomalousECALVariables();
}

static void constructor_6760( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::AnomalousECALVariables(*(::std::vector<BoundaryInformation>*)arg[0],
      *(::std::vector<BoundaryInformation>*)arg[1],
      *(::std::vector<BoundaryInformation>*)arg[2],
      *(::std::vector<BoundaryInformation>*)arg[3]);
  else ::new(mem) ::AnomalousECALVariables(*(::std::vector<BoundaryInformation>*)arg[0],
      *(::std::vector<BoundaryInformation>*)arg[1],
      *(::std::vector<BoundaryInformation>*)arg[2],
      *(::std::vector<BoundaryInformation>*)arg[3]);
}

static void destructor_6761(void*, void * o, const std::vector<void*>&, void *) {
(((::AnomalousECALVariables*)o)->::AnomalousECALVariables::~AnomalousECALVariables)();
}
static  void method_6762( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (bool)((((const ::AnomalousECALVariables*)o)->isDeadEcalCluster)());
    else     (((const ::AnomalousECALVariables*)o)->isDeadEcalCluster)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::AnomalousECALVariables*)o)->isDeadEcalCluster)(*(double*)arg[0]));
    else     (((const ::AnomalousECALVariables*)o)->isDeadEcalCluster)(*(double*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::AnomalousECALVariables*)o)->isDeadEcalCluster)(*(double*)arg[0],
      *(::std::vector<int>*)arg[1]));
    else     (((const ::AnomalousECALVariables*)o)->isDeadEcalCluster)(*(double*)arg[0],
      *(::std::vector<int>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::AnomalousECALVariables*)o)->isDeadEcalCluster)(*(double*)arg[0],
      *(::std::vector<int>*)arg[1],
      *(::std::vector<int>*)arg[2]));
    else     (((const ::AnomalousECALVariables*)o)->isDeadEcalCluster)(*(double*)arg[0],
      *(::std::vector<int>*)arg[1],
      *(::std::vector<int>*)arg[2]);
  }
}

static  void method_6763( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (bool)((((const ::AnomalousECALVariables*)o)->isGapEcalCluster)());
    else     (((const ::AnomalousECALVariables*)o)->isGapEcalCluster)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::AnomalousECALVariables*)o)->isGapEcalCluster)(*(double*)arg[0]));
    else     (((const ::AnomalousECALVariables*)o)->isGapEcalCluster)(*(double*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (bool)((((const ::AnomalousECALVariables*)o)->isGapEcalCluster)(*(double*)arg[0],
      *(double*)arg[1]));
    else     (((const ::AnomalousECALVariables*)o)->isGapEcalCluster)(*(double*)arg[0],
      *(double*)arg[1]);
  }
}

static void method_newdel_1114( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::AnomalousECALVariables >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::AnomalousECALVariables >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::AnomalousECALVariables >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::AnomalousECALVariables >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::AnomalousECALVariables >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class AnomalousECALVariables -------------------------------
void __AnomalousECALVariables_db_datamem(Reflex::Class*);
void __AnomalousECALVariables_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __AnomalousECALVariables_datamem_bld(&__AnomalousECALVariables_db_datamem);
Reflex::GenreflexMemberBuilder __AnomalousECALVariables_funcmem_bld(&__AnomalousECALVariables_db_funcmem);
void __AnomalousECALVariables_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("AnomalousECALVariables"), typeid(::AnomalousECALVariables), sizeof(::AnomalousECALVariables), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26091, type_26092), Reflex::Literal("operator="), operator_6757, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26092), Reflex::Literal("AnomalousECALVariables"), constructor_6758, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("AnomalousECALVariables"), constructor_6759, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3139, type_3139, type_3139, type_3139), Reflex::Literal("AnomalousECALVariables"), constructor_6760, 0, "p_enNeighboursGap_EB;p_enNeighboursGap_EE;p_boundaryInfoDeadCells_EB;p_boundaryInfoDeadCells_EE", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~AnomalousECALVariables"), destructor_6761, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1114, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__AnomalousECALVariables_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__AnomalousECALVariables_funcmem_bld);
}

//------Delayed data member builder for class AnomalousECALVariables -------------------
void __AnomalousECALVariables_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3139, Reflex::Literal("v_enNeighboursGap_EB"), OffsetOf(__shadow__::__AnomalousECALVariables, v_enNeighboursGap_EB), ::Reflex::PUBLIC)
  .AddDataMember(type_3139, Reflex::Literal("v_enNeighboursGap_EE"), OffsetOf(__shadow__::__AnomalousECALVariables, v_enNeighboursGap_EE), ::Reflex::PUBLIC)
  .AddDataMember(type_3139, Reflex::Literal("v_boundaryInfoDeadCells_EB"), OffsetOf(__shadow__::__AnomalousECALVariables, v_boundaryInfoDeadCells_EB), ::Reflex::PUBLIC)
  .AddDataMember(type_3139, Reflex::Literal("v_boundaryInfoDeadCells_EE"), OffsetOf(__shadow__::__AnomalousECALVariables, v_boundaryInfoDeadCells_EE), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class AnomalousECALVariables -------------------
void __AnomalousECALVariables_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647, type_107, type_3159, type_3159), Reflex::Literal("isDeadEcalCluster"), method_6762, 0, "maxBoundaryEnergy=10;limitDeadCellToChannelStatusEB=std::vector<int, std::allocator<int> >();limitDeadCellToChannelStatusEE=std::vector<int, std::allocator<int> >()", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647, type_107, type_107), Reflex::Literal("isGapEcalCluster"), method_6763, 0, "maxGapEnergyEB=10;maxGapEnergyEE=10", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class CorrMETData -------------------------------
static void destructor_7453(void*, void * o, const std::vector<void*>&, void *) {
(((::CorrMETData*)o)->::CorrMETData::~CorrMETData)();
}
static  void operator_7454( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CorrMETData*)o)->operator=)(*(const ::CorrMETData*)arg[0]);
  else   (((::CorrMETData*)o)->operator=)(*(const ::CorrMETData*)arg[0]);
}

static void constructor_7455( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CorrMETData();
  else ::new(mem) ::CorrMETData();
}

static void constructor_7456( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CorrMETData(*(const ::CorrMETData*)arg[0]);
  else ::new(mem) ::CorrMETData(*(const ::CorrMETData*)arg[0]);
}

static void method_newdel_1653( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::CorrMETData >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::CorrMETData >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::CorrMETData >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::CorrMETData >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::CorrMETData >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class CorrMETData -------------------------------
void __CorrMETData_db_datamem(Reflex::Class*);
void __CorrMETData_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __CorrMETData_datamem_bld(&__CorrMETData_db_datamem);
Reflex::GenreflexMemberBuilder __CorrMETData_funcmem_bld(&__CorrMETData_db_funcmem);
void __CorrMETData_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("CorrMETData"), typeid(::CorrMETData), sizeof(::CorrMETData), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~CorrMETData"), destructor_7453, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13438, type_13440), Reflex::Literal("operator="), operator_7454, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("CorrMETData"), constructor_7455, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13440), Reflex::Literal("CorrMETData"), constructor_7456, 0, "corr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1653, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__CorrMETData_datamem_bld);
}

//------Delayed data member builder for class CorrMETData -------------------
void __CorrMETData_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_107, Reflex::Literal("mex"), OffsetOf(__shadow__::__CorrMETData, mex), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("mey"), OffsetOf(__shadow__::__CorrMETData, mey), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("sumet"), OffsetOf(__shadow__::__CorrMETData, sumet), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("significance"), OffsetOf(__shadow__::__CorrMETData, significance), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class CorrMETData -------------------
void __CorrMETData_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class BoundaryInformation -------------------------------
static void destructor_8404(void*, void * o, const std::vector<void*>&, void *) {
(((::BoundaryInformation*)o)->::BoundaryInformation::~BoundaryInformation)();
}
static  void operator_8405( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::BoundaryInformation*)o)->operator=)(*(const ::BoundaryInformation*)arg[0]);
  else   (((::BoundaryInformation*)o)->operator=)(*(const ::BoundaryInformation*)arg[0]);
}

static void constructor_8406( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BoundaryInformation(*(const ::BoundaryInformation*)arg[0]);
  else ::new(mem) ::BoundaryInformation(*(const ::BoundaryInformation*)arg[0]);
}

static void constructor_8407( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::BoundaryInformation();
  else ::new(mem) ::BoundaryInformation();
}

static void method_newdel_2126( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::BoundaryInformation >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::BoundaryInformation >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::BoundaryInformation >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::BoundaryInformation >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::BoundaryInformation >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class BoundaryInformation -------------------------------
void __BoundaryInformation_db_datamem(Reflex::Class*);
void __BoundaryInformation_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __BoundaryInformation_datamem_bld(&__BoundaryInformation_db_datamem);
Reflex::GenreflexMemberBuilder __BoundaryInformation_funcmem_bld(&__BoundaryInformation_db_funcmem);
void __BoundaryInformation_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("BoundaryInformation"), typeid(::BoundaryInformation), sizeof(::BoundaryInformation), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~BoundaryInformation"), destructor_8404, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13178, type_13180), Reflex::Literal("operator="), operator_8405, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13180), Reflex::Literal("BoundaryInformation"), constructor_8406, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("BoundaryInformation"), constructor_8407, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2126, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__BoundaryInformation_datamem_bld);
}

//------Delayed data member builder for class BoundaryInformation -------------------
void __BoundaryInformation_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3161, Reflex::Literal("recHits"), OffsetOf(__shadow__::__BoundaryInformation, recHits), ::Reflex::PUBLIC)
  .AddDataMember(type_3160, Reflex::Literal("detIds"), OffsetOf(__shadow__::__BoundaryInformation, detIds), ::Reflex::PUBLIC)
  .AddDataMember(type_3159, Reflex::Literal("channelStatus"), OffsetOf(__shadow__::__BoundaryInformation, channelStatus), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("boundaryEnergy"), OffsetOf(__shadow__::__BoundaryInformation, boundaryEnergy), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("boundaryET"), OffsetOf(__shadow__::__BoundaryInformation, boundaryET), ::Reflex::PUBLIC)
  .AddDataMember(type_1379, Reflex::Literal("subdet"), OffsetOf(__shadow__::__BoundaryInformation, subdet), ::Reflex::PUBLIC)
  .AddDataMember(type_1647, Reflex::Literal("nextToBorder"), OffsetOf(__shadow__::__BoundaryInformation, nextToBorder), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class BoundaryInformation -------------------
void __BoundaryInformation_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class PFMEtSignCovMatrix -------------------------------
static  void operator_8419( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PFMEtSignCovMatrix*)o)->operator=)(*(const ::PFMEtSignCovMatrix*)arg[0]);
  else   (((::PFMEtSignCovMatrix*)o)->operator=)(*(const ::PFMEtSignCovMatrix*)arg[0]);
}

static void constructor_8420( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PFMEtSignCovMatrix();
  else ::new(mem) ::PFMEtSignCovMatrix();
}

static void constructor_8421( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PFMEtSignCovMatrix(*(const ::PFMEtSignCovMatrix*)arg[0]);
  else ::new(mem) ::PFMEtSignCovMatrix(*(const ::PFMEtSignCovMatrix*)arg[0]);
}

static void constructor_8422( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::PFMEtSignCovMatrix(*(const ::TMatrixD*)arg[0]);
  else ::new(mem) ::PFMEtSignCovMatrix(*(const ::TMatrixD*)arg[0]);
}

static void destructor_8423(void*, void * o, const std::vector<void*>&, void *) {
(((::PFMEtSignCovMatrix*)o)->::PFMEtSignCovMatrix::~PFMEtSignCovMatrix)();
}
static  void method_8424( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::PFMEtSignCovMatrix*)o)->GetNrows)());
  else   (((const ::PFMEtSignCovMatrix*)o)->GetNrows)();
}

static  void method_8425( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::PFMEtSignCovMatrix*)o)->GetNcols)());
  else   (((const ::PFMEtSignCovMatrix*)o)->GetNcols)();
}

static  void operator_8426( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::PFMEtSignCovMatrix*)o)->operator())(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::PFMEtSignCovMatrix*)o)->operator())(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void operator_8427( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::PFMEtSignCovMatrix*)o)->operator())(*(int*)arg[0],
    *(int*)arg[1]);
  else   (((::PFMEtSignCovMatrix*)o)->operator())(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void converter_8428( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (TMatrixD)((((const ::PFMEtSignCovMatrix*)o)->operator TMatrixD)());
  else   (((const ::PFMEtSignCovMatrix*)o)->operator TMatrixD)();
}

static void method_newdel_2233( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::PFMEtSignCovMatrix >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::PFMEtSignCovMatrix >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::PFMEtSignCovMatrix >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::PFMEtSignCovMatrix >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::PFMEtSignCovMatrix >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class PFMEtSignCovMatrix -------------------------------
void __PFMEtSignCovMatrix_db_datamem(Reflex::Class*);
void __PFMEtSignCovMatrix_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __PFMEtSignCovMatrix_datamem_bld(&__PFMEtSignCovMatrix_db_datamem);
Reflex::GenreflexMemberBuilder __PFMEtSignCovMatrix_funcmem_bld(&__PFMEtSignCovMatrix_db_funcmem);
void __PFMEtSignCovMatrix_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("PFMEtSignCovMatrix"), typeid(::PFMEtSignCovMatrix), sizeof(::PFMEtSignCovMatrix), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "11")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30557, type_30558), Reflex::Literal("operator="), operator_8419, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PFMEtSignCovMatrix"), constructor_8420, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30558), Reflex::Literal("PFMEtSignCovMatrix"), constructor_8421, 0, "bluePrint", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30559), Reflex::Literal("PFMEtSignCovMatrix"), constructor_8422, 0, "bluePrint", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PFMEtSignCovMatrix"), destructor_8423, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2233, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__PFMEtSignCovMatrix_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__PFMEtSignCovMatrix_funcmem_bld);
}

//------Delayed data member builder for class PFMEtSignCovMatrix -------------------
void __PFMEtSignCovMatrix_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_107, Reflex::Literal("covXX_"), OffsetOf(__shadow__::__PFMEtSignCovMatrix, covXX_), ::Reflex::PRIVATE)
  .AddDataMember(type_107, Reflex::Literal("covXY_"), OffsetOf(__shadow__::__PFMEtSignCovMatrix, covXY_), ::Reflex::PRIVATE)
  .AddDataMember(type_107, Reflex::Literal("covYY_"), OffsetOf(__shadow__::__PFMEtSignCovMatrix, covYY_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PFMEtSignCovMatrix -------------------
void __PFMEtSignCovMatrix_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("GetNrows"), method_8424, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("GetNcols"), method_8425, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107, type_72, type_72), Reflex::Literal("operator()"), operator_8426, 0, "row;column", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10341, type_72, type_72), Reflex::Literal("operator()"), operator_8427, 0, "row;column", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1147), Reflex::Literal("operator TMatrixD"), converter_8428, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONVERTER | ::Reflex::CONST);
}
//------Stub functions for class CommonMETData -------------------------------
static void destructor_8554(void*, void * o, const std::vector<void*>&, void *) {
(((::CommonMETData*)o)->::CommonMETData::~CommonMETData)();
}
static  void operator_8555( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::CommonMETData*)o)->operator=)(*(const ::CommonMETData*)arg[0]);
  else   (((::CommonMETData*)o)->operator=)(*(const ::CommonMETData*)arg[0]);
}

static void constructor_8556( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CommonMETData(*(const ::CommonMETData*)arg[0]);
  else ::new(mem) ::CommonMETData(*(const ::CommonMETData*)arg[0]);
}

static void constructor_8557( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::CommonMETData();
  else ::new(mem) ::CommonMETData();
}

static void method_newdel_2300( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::CommonMETData >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::CommonMETData >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::CommonMETData >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::CommonMETData >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::CommonMETData >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class CommonMETData -------------------------------
void __CommonMETData_db_datamem(Reflex::Class*);
void __CommonMETData_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __CommonMETData_datamem_bld(&__CommonMETData_db_datamem);
Reflex::GenreflexMemberBuilder __CommonMETData_funcmem_bld(&__CommonMETData_db_funcmem);
void __CommonMETData_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("CommonMETData"), typeid(::CommonMETData), sizeof(::CommonMETData), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~CommonMETData"), destructor_8554, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13503, type_13505), Reflex::Literal("operator="), operator_8555, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13505), Reflex::Literal("CommonMETData"), constructor_8556, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("CommonMETData"), constructor_8557, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2300, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__CommonMETData_datamem_bld);
}

//------Delayed data member builder for class CommonMETData -------------------
void __CommonMETData_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_107, Reflex::Literal("met"), OffsetOf(__shadow__::__CommonMETData, met), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("mex"), OffsetOf(__shadow__::__CommonMETData, mex), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("mey"), OffsetOf(__shadow__::__CommonMETData, mey), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("mez"), OffsetOf(__shadow__::__CommonMETData, mez), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("sumet"), OffsetOf(__shadow__::__CommonMETData, sumet), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("phi"), OffsetOf(__shadow__::__CommonMETData, phi), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class CommonMETData -------------------
void __CommonMETData_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class SpecificGenMETData -------------------------------
static void destructor_8591(void*, void * o, const std::vector<void*>&, void *) {
(((::SpecificGenMETData*)o)->::SpecificGenMETData::~SpecificGenMETData)();
}
static  void operator_8592( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SpecificGenMETData*)o)->operator=)(*(const ::SpecificGenMETData*)arg[0]);
  else   (((::SpecificGenMETData*)o)->operator=)(*(const ::SpecificGenMETData*)arg[0]);
}

static void constructor_8593( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SpecificGenMETData(*(const ::SpecificGenMETData*)arg[0]);
  else ::new(mem) ::SpecificGenMETData(*(const ::SpecificGenMETData*)arg[0]);
}

static void constructor_8594( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SpecificGenMETData();
  else ::new(mem) ::SpecificGenMETData();
}

static void method_newdel_2320( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SpecificGenMETData >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SpecificGenMETData >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SpecificGenMETData >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SpecificGenMETData >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SpecificGenMETData >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class SpecificGenMETData -------------------------------
void __SpecificGenMETData_db_datamem(Reflex::Class*);
void __SpecificGenMETData_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SpecificGenMETData_datamem_bld(&__SpecificGenMETData_db_datamem);
Reflex::GenreflexMemberBuilder __SpecificGenMETData_funcmem_bld(&__SpecificGenMETData_db_funcmem);
void __SpecificGenMETData_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SpecificGenMETData"), typeid(::SpecificGenMETData), sizeof(::SpecificGenMETData), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SpecificGenMETData"), destructor_8591, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_31494, type_31495), Reflex::Literal("operator="), operator_8592, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31495), Reflex::Literal("SpecificGenMETData"), constructor_8593, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SpecificGenMETData"), constructor_8594, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2320, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SpecificGenMETData_datamem_bld);
}

//------Delayed data member builder for class SpecificGenMETData -------------------
void __SpecificGenMETData_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_107, Reflex::Literal("NeutralEMEtFraction"), OffsetOf(__shadow__::__SpecificGenMETData, NeutralEMEtFraction), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("NeutralHadEtFraction"), OffsetOf(__shadow__::__SpecificGenMETData, NeutralHadEtFraction), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("ChargedEMEtFraction"), OffsetOf(__shadow__::__SpecificGenMETData, ChargedEMEtFraction), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("ChargedHadEtFraction"), OffsetOf(__shadow__::__SpecificGenMETData, ChargedHadEtFraction), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("MuonEtFraction"), OffsetOf(__shadow__::__SpecificGenMETData, MuonEtFraction), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("InvisibleEtFraction"), OffsetOf(__shadow__::__SpecificGenMETData, InvisibleEtFraction), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("m_EmEnergy"), OffsetOf(__shadow__::__SpecificGenMETData, m_EmEnergy), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("m_HadEnergy"), OffsetOf(__shadow__::__SpecificGenMETData, m_HadEnergy), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("m_InvisibleEnergy"), OffsetOf(__shadow__::__SpecificGenMETData, m_InvisibleEnergy), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("m_AuxiliaryEnergy"), OffsetOf(__shadow__::__SpecificGenMETData, m_AuxiliaryEnergy), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class SpecificGenMETData -------------------
void __SpecificGenMETData_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<BoundaryInformation,std::allocator<BoundaryInformation> > -------------------------------
static void constructor_13189( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BoundaryInformation>();
  else ::new(mem) ::std::vector<BoundaryInformation>();
}

static void constructor_13190( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BoundaryInformation>(*(const ::std::allocator<BoundaryInformation>*)arg[0]);
  else ::new(mem) ::std::vector<BoundaryInformation>(*(const ::std::allocator<BoundaryInformation>*)arg[0]);
}

static void constructor_13191( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BoundaryInformation>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<BoundaryInformation>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BoundaryInformation>(*(::std::size_t*)arg[0],
      *(const ::BoundaryInformation*)arg[1]);
  else ::new(mem) ::std::vector<BoundaryInformation>(*(::std::size_t*)arg[0],
      *(const ::BoundaryInformation*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BoundaryInformation>(*(::std::size_t*)arg[0],
      *(const ::BoundaryInformation*)arg[1],
      *(const ::std::allocator<BoundaryInformation>*)arg[2]);
  else ::new(mem) ::std::vector<BoundaryInformation>(*(::std::size_t*)arg[0],
      *(const ::BoundaryInformation*)arg[1],
      *(const ::std::allocator<BoundaryInformation>*)arg[2]);
  }
}

static void constructor_13192( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<BoundaryInformation>(*(const ::std::vector<BoundaryInformation>*)arg[0]);
  else ::new(mem) ::std::vector<BoundaryInformation>(*(const ::std::vector<BoundaryInformation>*)arg[0]);
}

static void destructor_13193(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<BoundaryInformation>*)o)->::std::vector<BoundaryInformation>::~vector)();
}
static  void operator_13194( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BoundaryInformation>*)o)->operator=)(*(const ::std::vector<BoundaryInformation>*)arg[0]);
  else   (((::std::vector<BoundaryInformation>*)o)->operator=)(*(const ::std::vector<BoundaryInformation>*)arg[0]);
}

static  void method_13195( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BoundaryInformation>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::BoundaryInformation*)arg[1]);
}

static  void method_13196( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BoundaryInformation*,std::vector<BoundaryInformation> >)((((::std::vector<BoundaryInformation>*)o)->begin)());
  else   (((::std::vector<BoundaryInformation>*)o)->begin)();
}

static  void method_13197( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const BoundaryInformation*,std::vector<BoundaryInformation> >)((((const ::std::vector<BoundaryInformation>*)o)->begin)());
  else   (((const ::std::vector<BoundaryInformation>*)o)->begin)();
}

static  void method_13198( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BoundaryInformation*,std::vector<BoundaryInformation> >)((((::std::vector<BoundaryInformation>*)o)->end)());
  else   (((::std::vector<BoundaryInformation>*)o)->end)();
}

static  void method_13199( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const BoundaryInformation*,std::vector<BoundaryInformation> >)((((const ::std::vector<BoundaryInformation>*)o)->end)());
  else   (((const ::std::vector<BoundaryInformation>*)o)->end)();
}

static  void method_13204( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BoundaryInformation>*)o)->size)());
  else   (((const ::std::vector<BoundaryInformation>*)o)->size)();
}

static  void method_13205( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BoundaryInformation>*)o)->max_size)());
  else   (((const ::std::vector<BoundaryInformation>*)o)->max_size)();
}

static  void method_13206( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<BoundaryInformation>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<BoundaryInformation>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::BoundaryInformation*)arg[1]);
  }
}

static  void method_13207( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<BoundaryInformation>*)o)->capacity)());
  else   (((const ::std::vector<BoundaryInformation>*)o)->capacity)();
}

static  void method_13208( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<BoundaryInformation>*)o)->empty)());
  else   (((const ::std::vector<BoundaryInformation>*)o)->empty)();
}

static  void method_13209( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BoundaryInformation>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_13210( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BoundaryInformation>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<BoundaryInformation>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_13211( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BoundaryInformation>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<BoundaryInformation>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_13213( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BoundaryInformation>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<BoundaryInformation>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13214( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BoundaryInformation>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<BoundaryInformation>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13215( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BoundaryInformation>*)o)->front)();
  else   (((::std::vector<BoundaryInformation>*)o)->front)();
}

static  void method_13216( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BoundaryInformation>*)o)->front)();
  else   (((const ::std::vector<BoundaryInformation>*)o)->front)();
}

static  void method_13217( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<BoundaryInformation>*)o)->back)();
  else   (((::std::vector<BoundaryInformation>*)o)->back)();
}

static  void method_13218( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<BoundaryInformation>*)o)->back)();
  else   (((const ::std::vector<BoundaryInformation>*)o)->back)();
}

static  void method_13219( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<BoundaryInformation>*)o)->data)());
  else   (((::std::vector<BoundaryInformation>*)o)->data)();
}

static  void method_13220( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<BoundaryInformation>*)o)->data)());
  else   (((const ::std::vector<BoundaryInformation>*)o)->data)();
}

static  void method_13221( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BoundaryInformation>*)o)->push_back)(*(const ::BoundaryInformation*)arg[0]);
}

static  void method_13222( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<BoundaryInformation>*)o)->pop_back)();
}

static  void method_13223( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BoundaryInformation*,std::vector<BoundaryInformation> >)((((::std::vector<BoundaryInformation>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BoundaryInformation*,std::vector<BoundaryInformation> >*)arg[0],
    *(const ::BoundaryInformation*)arg[1]));
  else   (((::std::vector<BoundaryInformation>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BoundaryInformation*,std::vector<BoundaryInformation> >*)arg[0],
    *(const ::BoundaryInformation*)arg[1]);
}

static  void method_13224( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BoundaryInformation>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<BoundaryInformation*,std::vector<BoundaryInformation> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::BoundaryInformation*)arg[2]);
}

static  void method_13225( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BoundaryInformation*,std::vector<BoundaryInformation> >)((((::std::vector<BoundaryInformation>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BoundaryInformation*,std::vector<BoundaryInformation> >*)arg[0]));
  else   (((::std::vector<BoundaryInformation>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BoundaryInformation*,std::vector<BoundaryInformation> >*)arg[0]);
}

static  void method_13226( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<BoundaryInformation*,std::vector<BoundaryInformation> >)((((::std::vector<BoundaryInformation>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BoundaryInformation*,std::vector<BoundaryInformation> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<BoundaryInformation*,std::vector<BoundaryInformation> >*)arg[1]));
  else   (((::std::vector<BoundaryInformation>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<BoundaryInformation*,std::vector<BoundaryInformation> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<BoundaryInformation*,std::vector<BoundaryInformation> >*)arg[1]);
}

static  void method_13227( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<BoundaryInformation>*)o)->swap)(*(::std::vector<BoundaryInformation>*)arg[0]);
}

static  void method_13228( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<BoundaryInformation>*)o)->clear)();
}

static void method_newdel_3139( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<BoundaryInformation> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<BoundaryInformation> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<BoundaryInformation> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<BoundaryInformation> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<BoundaryInformation> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x10( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<BoundaryInformation,std::allocator<BoundaryInformation> >")), ::Reflex::BaseOffset< ::std::vector<BoundaryInformation>,::std::_Vector_base<BoundaryInformation,std::allocator<BoundaryInformation> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x11( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<BoundaryInformation> >::Generate();
  else ::Reflex::Proxy< ::std::vector<BoundaryInformation> >::Generate();
}

//------Dictionary for class vector<BoundaryInformation,std::allocator<BoundaryInformation> > -------------------------------
void __std__vector_BoundaryInformation__db_datamem(Reflex::Class*);
void __std__vector_BoundaryInformation__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_BoundaryInformation__datamem_bld(&__std__vector_BoundaryInformation__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_BoundaryInformation__funcmem_bld(&__std__vector_BoundaryInformation__db_funcmem);
void __std__vector_BoundaryInformation__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<BoundaryInformation>"), typeid(::std::vector<BoundaryInformation>), sizeof(::std::vector<BoundaryInformation>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2598, ::Reflex::BaseOffset< ::std::vector<BoundaryInformation>, ::std::_Vector_base<BoundaryInformation,std::allocator<BoundaryInformation> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2126, Reflex::Literal("std::vector<BoundaryInformation>::_Alloc_value_type"))
  .AddTypedef(type_2598, Reflex::Literal("std::vector<BoundaryInformation>::_Base"))
  .AddTypedef(type_3409, Reflex::Literal("std::vector<BoundaryInformation>::_Tp_alloc_type"))
  .AddTypedef(type_2126, Reflex::Literal("std::vector<BoundaryInformation>::value_type"))
  .AddTypedef(type_13174, Reflex::Literal("std::vector<BoundaryInformation>::pointer"))
  .AddTypedef(type_13176, Reflex::Literal("std::vector<BoundaryInformation>::const_pointer"))
  .AddTypedef(type_13178, Reflex::Literal("std::vector<BoundaryInformation>::reference"))
  .AddTypedef(type_13180, Reflex::Literal("std::vector<BoundaryInformation>::const_reference"))
  .AddTypedef(type_8169, Reflex::Literal("std::vector<BoundaryInformation>::iterator"))
  .AddTypedef(type_8170, Reflex::Literal("std::vector<BoundaryInformation>::const_iterator"))
  .AddTypedef(type_3613, Reflex::Literal("std::vector<BoundaryInformation>::const_reverse_iterator"))
  .AddTypedef(type_3614, Reflex::Literal("std::vector<BoundaryInformation>::reverse_iterator"))
  .AddTypedef(type_3394, Reflex::Literal("std::vector<BoundaryInformation>::size_type"))
  .AddTypedef(type_3290, Reflex::Literal("std::vector<BoundaryInformation>::difference_type"))
  .AddTypedef(type_3409, Reflex::Literal("std::vector<BoundaryInformation>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_13189, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31705), Reflex::Literal("vector"), constructor_13190, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3394, type_13180, type_31705), Reflex::Literal("vector"), constructor_13191, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32792), Reflex::Literal("vector"), constructor_13192, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_13193, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3139, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x10, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x11, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_BoundaryInformation__funcmem_bld);
}

//------Delayed data member builder for class vector<BoundaryInformation,std::allocator<BoundaryInformation> > -------------------
void __std__vector_BoundaryInformation__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<BoundaryInformation,std::allocator<BoundaryInformation> > -------------------
void __std__vector_BoundaryInformation__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32793, type_32792), Reflex::Literal("operator="), operator_13194, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394, type_13180), Reflex::Literal("assign"), method_13195, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8169), Reflex::Literal("begin"), method_13196, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8170), Reflex::Literal("begin"), method_13197, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8169), Reflex::Literal("end"), method_13198, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8170), Reflex::Literal("end"), method_13199, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("size"), method_13204, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("max_size"), method_13205, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394, type_2126), Reflex::Literal("resize"), method_13206, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("capacity"), method_13207, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("empty"), method_13208, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394), Reflex::Literal("reserve"), method_13209, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13178, type_3394), Reflex::Literal("operator[]"), operator_13210, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13180, type_3394), Reflex::Literal("operator[]"), operator_13211, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13178, type_3394), Reflex::Literal("at"), method_13213, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13180, type_3394), Reflex::Literal("at"), method_13214, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13178), Reflex::Literal("front"), method_13215, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13180), Reflex::Literal("front"), method_13216, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13178), Reflex::Literal("back"), method_13217, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13180), Reflex::Literal("back"), method_13218, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13174), Reflex::Literal("data"), method_13219, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13176), Reflex::Literal("data"), method_13220, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_13180), Reflex::Literal("push_back"), method_13221, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("pop_back"), method_13222, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8169, type_8169, type_13180), Reflex::Literal("insert"), method_13223, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_8169, type_3394, type_13180), Reflex::Literal("insert"), method_13224, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8169, type_8169), Reflex::Literal("erase"), method_13225, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8169, type_8169, type_8169), Reflex::Literal("erase"), method_13226, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_32793), Reflex::Literal("swap"), method_13227, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("clear"), method_13228, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class SigInputObj -------------------------------
static  void operator_19696( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::metsig::SigInputObj*)o)->operator=)(*(const ::metsig::SigInputObj*)arg[0]);
  else   (((::metsig::SigInputObj*)o)->operator=)(*(const ::metsig::SigInputObj*)arg[0]);
}

static void constructor_19697( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::metsig::SigInputObj(*(const ::metsig::SigInputObj*)arg[0]);
  else ::new(mem) ::metsig::SigInputObj(*(const ::metsig::SigInputObj*)arg[0]);
}

static void constructor_19698( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::metsig::SigInputObj();
  else ::new(mem) ::metsig::SigInputObj();
}

static void constructor_19699( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::metsig::SigInputObj(*(const ::std::string*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4]);
  else ::new(mem) ::metsig::SigInputObj(*(const ::std::string*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(double*)arg[3],
      *(double*)arg[4]);
}

static void destructor_19700(void*, void * o, const std::vector<void*>&, void *) {
(((::metsig::SigInputObj*)o)->::metsig::SigInputObj::~SigInputObj)();
}
static  void method_19701( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::metsig::SigInputObj*)o)->get_type)();
  else   (((const ::metsig::SigInputObj*)o)->get_type)();
}

static  void method_19702( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::metsig::SigInputObj*)o)->get_energy)());
  else   (((const ::metsig::SigInputObj*)o)->get_energy)();
}

static  void method_19703( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::metsig::SigInputObj*)o)->get_phi)());
  else   (((const ::metsig::SigInputObj*)o)->get_phi)();
}

static  void method_19704( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::metsig::SigInputObj*)o)->get_sigma_e)());
  else   (((const ::metsig::SigInputObj*)o)->get_sigma_e)();
}

static  void method_19705( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::metsig::SigInputObj*)o)->get_sigma_tan)());
  else   (((const ::metsig::SigInputObj*)o)->get_sigma_tan)();
}

static  void method_19706( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::metsig::SigInputObj*)o)->set)(*(const ::std::string*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2],
    *(double*)arg[3],
    *(double*)arg[4]);
}

static void method_newdel_3824( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::metsig::SigInputObj >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::metsig::SigInputObj >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::metsig::SigInputObj >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::metsig::SigInputObj >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::metsig::SigInputObj >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class SigInputObj -------------------------------
void __metsig__SigInputObj_db_datamem(Reflex::Class*);
void __metsig__SigInputObj_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __metsig__SigInputObj_datamem_bld(&__metsig__SigInputObj_db_datamem);
Reflex::GenreflexMemberBuilder __metsig__SigInputObj_funcmem_bld(&__metsig__SigInputObj_db_funcmem);
void __metsig__SigInputObj_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("metsig::SigInputObj"), typeid(::metsig::SigInputObj), sizeof(::metsig::SigInputObj), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13373, type_13375), Reflex::Literal("operator="), operator_19696, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13375), Reflex::Literal("SigInputObj"), constructor_19697, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SigInputObj"), constructor_19698, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_16951, type_107, type_107, type_107, type_107), Reflex::Literal("SigInputObj"), constructor_19699, 0, ";;;;", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SigInputObj"), destructor_19700, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3824, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__metsig__SigInputObj_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__metsig__SigInputObj_funcmem_bld);
}

//------Delayed data member builder for class SigInputObj -------------------
void __metsig__SigInputObj_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2653, Reflex::Literal("type"), OffsetOf(__shadow__::__metsig__SigInputObj, type), ::Reflex::PRIVATE)
  .AddDataMember(type_107, Reflex::Literal("energy"), OffsetOf(__shadow__::__metsig__SigInputObj, energy), ::Reflex::PRIVATE)
  .AddDataMember(type_107, Reflex::Literal("phi"), OffsetOf(__shadow__::__metsig__SigInputObj, phi), ::Reflex::PRIVATE)
  .AddDataMember(type_107, Reflex::Literal("sigma_e"), OffsetOf(__shadow__::__metsig__SigInputObj, sigma_e), ::Reflex::PRIVATE)
  .AddDataMember(type_107, Reflex::Literal("sigma_tan"), OffsetOf(__shadow__::__metsig__SigInputObj, sigma_tan), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SigInputObj -------------------
void __metsig__SigInputObj_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_16951), Reflex::Literal("get_type"), method_19701, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("get_energy"), method_19702, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("get_phi"), method_19703, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("get_sigma_e"), method_19704, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("get_sigma_tan"), method_19705, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_16951, type_107, type_107, type_107, type_107), Reflex::Literal("set"), method_19706, 0, "m_type;m_energy;m_phi;m_sigma_e;m_sigma_tan", ::Reflex::PUBLIC);
}
//------Stub functions for class vector<metsig::SigInputObj,std::allocator<metsig::SigInputObj> > -------------------------------
static void constructor_13384( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<metsig::SigInputObj>();
  else ::new(mem) ::std::vector<metsig::SigInputObj>();
}

static void constructor_13385( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<metsig::SigInputObj>(*(const ::std::allocator<metsig::SigInputObj>*)arg[0]);
  else ::new(mem) ::std::vector<metsig::SigInputObj>(*(const ::std::allocator<metsig::SigInputObj>*)arg[0]);
}

static void constructor_13386( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<metsig::SigInputObj>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<metsig::SigInputObj>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<metsig::SigInputObj>(*(::std::size_t*)arg[0],
      *(const ::metsig::SigInputObj*)arg[1]);
  else ::new(mem) ::std::vector<metsig::SigInputObj>(*(::std::size_t*)arg[0],
      *(const ::metsig::SigInputObj*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<metsig::SigInputObj>(*(::std::size_t*)arg[0],
      *(const ::metsig::SigInputObj*)arg[1],
      *(const ::std::allocator<metsig::SigInputObj>*)arg[2]);
  else ::new(mem) ::std::vector<metsig::SigInputObj>(*(::std::size_t*)arg[0],
      *(const ::metsig::SigInputObj*)arg[1],
      *(const ::std::allocator<metsig::SigInputObj>*)arg[2]);
  }
}

static void constructor_13387( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<metsig::SigInputObj>(*(const ::std::vector<metsig::SigInputObj>*)arg[0]);
  else ::new(mem) ::std::vector<metsig::SigInputObj>(*(const ::std::vector<metsig::SigInputObj>*)arg[0]);
}

static void destructor_13388(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<metsig::SigInputObj>*)o)->::std::vector<metsig::SigInputObj>::~vector)();
}
static  void operator_13389( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<metsig::SigInputObj>*)o)->operator=)(*(const ::std::vector<metsig::SigInputObj>*)arg[0]);
  else   (((::std::vector<metsig::SigInputObj>*)o)->operator=)(*(const ::std::vector<metsig::SigInputObj>*)arg[0]);
}

static  void method_13390( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<metsig::SigInputObj>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::metsig::SigInputObj*)arg[1]);
}

static  void method_13391( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<metsig::SigInputObj*,std::vector<metsig::SigInputObj> >)((((::std::vector<metsig::SigInputObj>*)o)->begin)());
  else   (((::std::vector<metsig::SigInputObj>*)o)->begin)();
}

static  void method_13392( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const metsig::SigInputObj*,std::vector<metsig::SigInputObj> >)((((const ::std::vector<metsig::SigInputObj>*)o)->begin)());
  else   (((const ::std::vector<metsig::SigInputObj>*)o)->begin)();
}

static  void method_13393( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<metsig::SigInputObj*,std::vector<metsig::SigInputObj> >)((((::std::vector<metsig::SigInputObj>*)o)->end)());
  else   (((::std::vector<metsig::SigInputObj>*)o)->end)();
}

static  void method_13394( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const metsig::SigInputObj*,std::vector<metsig::SigInputObj> >)((((const ::std::vector<metsig::SigInputObj>*)o)->end)());
  else   (((const ::std::vector<metsig::SigInputObj>*)o)->end)();
}

static  void method_13399( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<metsig::SigInputObj>*)o)->size)());
  else   (((const ::std::vector<metsig::SigInputObj>*)o)->size)();
}

static  void method_13400( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<metsig::SigInputObj>*)o)->max_size)());
  else   (((const ::std::vector<metsig::SigInputObj>*)o)->max_size)();
}

static  void method_13401( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<metsig::SigInputObj>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<metsig::SigInputObj>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::metsig::SigInputObj*)arg[1]);
  }
}

static  void method_13402( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<metsig::SigInputObj>*)o)->capacity)());
  else   (((const ::std::vector<metsig::SigInputObj>*)o)->capacity)();
}

static  void method_13403( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<metsig::SigInputObj>*)o)->empty)());
  else   (((const ::std::vector<metsig::SigInputObj>*)o)->empty)();
}

static  void method_13404( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<metsig::SigInputObj>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_13405( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<metsig::SigInputObj>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<metsig::SigInputObj>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_13406( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<metsig::SigInputObj>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<metsig::SigInputObj>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_13408( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<metsig::SigInputObj>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<metsig::SigInputObj>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13409( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<metsig::SigInputObj>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<metsig::SigInputObj>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13410( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<metsig::SigInputObj>*)o)->front)();
  else   (((::std::vector<metsig::SigInputObj>*)o)->front)();
}

static  void method_13411( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<metsig::SigInputObj>*)o)->front)();
  else   (((const ::std::vector<metsig::SigInputObj>*)o)->front)();
}

static  void method_13412( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<metsig::SigInputObj>*)o)->back)();
  else   (((::std::vector<metsig::SigInputObj>*)o)->back)();
}

static  void method_13413( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<metsig::SigInputObj>*)o)->back)();
  else   (((const ::std::vector<metsig::SigInputObj>*)o)->back)();
}

static  void method_13414( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<metsig::SigInputObj>*)o)->data)());
  else   (((::std::vector<metsig::SigInputObj>*)o)->data)();
}

static  void method_13415( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<metsig::SigInputObj>*)o)->data)());
  else   (((const ::std::vector<metsig::SigInputObj>*)o)->data)();
}

static  void method_13416( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<metsig::SigInputObj>*)o)->push_back)(*(const ::metsig::SigInputObj*)arg[0]);
}

static  void method_13417( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<metsig::SigInputObj>*)o)->pop_back)();
}

static  void method_13418( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<metsig::SigInputObj*,std::vector<metsig::SigInputObj> >)((((::std::vector<metsig::SigInputObj>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<metsig::SigInputObj*,std::vector<metsig::SigInputObj> >*)arg[0],
    *(const ::metsig::SigInputObj*)arg[1]));
  else   (((::std::vector<metsig::SigInputObj>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<metsig::SigInputObj*,std::vector<metsig::SigInputObj> >*)arg[0],
    *(const ::metsig::SigInputObj*)arg[1]);
}

static  void method_13419( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<metsig::SigInputObj>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<metsig::SigInputObj*,std::vector<metsig::SigInputObj> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::metsig::SigInputObj*)arg[2]);
}

static  void method_13420( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<metsig::SigInputObj*,std::vector<metsig::SigInputObj> >)((((::std::vector<metsig::SigInputObj>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<metsig::SigInputObj*,std::vector<metsig::SigInputObj> >*)arg[0]));
  else   (((::std::vector<metsig::SigInputObj>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<metsig::SigInputObj*,std::vector<metsig::SigInputObj> >*)arg[0]);
}

static  void method_13421( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<metsig::SigInputObj*,std::vector<metsig::SigInputObj> >)((((::std::vector<metsig::SigInputObj>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<metsig::SigInputObj*,std::vector<metsig::SigInputObj> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<metsig::SigInputObj*,std::vector<metsig::SigInputObj> >*)arg[1]));
  else   (((::std::vector<metsig::SigInputObj>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<metsig::SigInputObj*,std::vector<metsig::SigInputObj> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<metsig::SigInputObj*,std::vector<metsig::SigInputObj> >*)arg[1]);
}

static  void method_13422( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<metsig::SigInputObj>*)o)->swap)(*(::std::vector<metsig::SigInputObj>*)arg[0]);
}

static  void method_13423( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<metsig::SigInputObj>*)o)->clear)();
}

static void method_newdel_3142( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<metsig::SigInputObj> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<metsig::SigInputObj> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<metsig::SigInputObj> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<metsig::SigInputObj> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<metsig::SigInputObj> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x14( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<metsig::SigInputObj,std::allocator<metsig::SigInputObj> >")), ::Reflex::BaseOffset< ::std::vector<metsig::SigInputObj>,::std::_Vector_base<metsig::SigInputObj,std::allocator<metsig::SigInputObj> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x15( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<metsig::SigInputObj> >::Generate();
  else ::Reflex::Proxy< ::std::vector<metsig::SigInputObj> >::Generate();
}

//------Dictionary for class vector<metsig::SigInputObj,std::allocator<metsig::SigInputObj> > -------------------------------
void __std__vector_metsig__SigInputObj__db_datamem(Reflex::Class*);
void __std__vector_metsig__SigInputObj__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_metsig__SigInputObj__datamem_bld(&__std__vector_metsig__SigInputObj__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_metsig__SigInputObj__funcmem_bld(&__std__vector_metsig__SigInputObj__db_funcmem);
void __std__vector_metsig__SigInputObj__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<metsig::SigInputObj>"), typeid(::std::vector<metsig::SigInputObj>), sizeof(::std::vector<metsig::SigInputObj>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2591, ::Reflex::BaseOffset< ::std::vector<metsig::SigInputObj>, ::std::_Vector_base<metsig::SigInputObj,std::allocator<metsig::SigInputObj> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3824, Reflex::Literal("std::vector<metsig::SigInputObj>::_Alloc_value_type"))
  .AddTypedef(type_2591, Reflex::Literal("std::vector<metsig::SigInputObj>::_Base"))
  .AddTypedef(type_3412, Reflex::Literal("std::vector<metsig::SigInputObj>::_Tp_alloc_type"))
  .AddTypedef(type_3824, Reflex::Literal("std::vector<metsig::SigInputObj>::value_type"))
  .AddTypedef(type_13369, Reflex::Literal("std::vector<metsig::SigInputObj>::pointer"))
  .AddTypedef(type_13371, Reflex::Literal("std::vector<metsig::SigInputObj>::const_pointer"))
  .AddTypedef(type_13373, Reflex::Literal("std::vector<metsig::SigInputObj>::reference"))
  .AddTypedef(type_13375, Reflex::Literal("std::vector<metsig::SigInputObj>::const_reference"))
  .AddTypedef(type_8152, Reflex::Literal("std::vector<metsig::SigInputObj>::iterator"))
  .AddTypedef(type_8153, Reflex::Literal("std::vector<metsig::SigInputObj>::const_iterator"))
  .AddTypedef(type_3599, Reflex::Literal("std::vector<metsig::SigInputObj>::const_reverse_iterator"))
  .AddTypedef(type_3600, Reflex::Literal("std::vector<metsig::SigInputObj>::reverse_iterator"))
  .AddTypedef(type_3394, Reflex::Literal("std::vector<metsig::SigInputObj>::size_type"))
  .AddTypedef(type_3290, Reflex::Literal("std::vector<metsig::SigInputObj>::difference_type"))
  .AddTypedef(type_3412, Reflex::Literal("std::vector<metsig::SigInputObj>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_13384, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31621), Reflex::Literal("vector"), constructor_13385, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3394, type_13375, type_31621), Reflex::Literal("vector"), constructor_13386, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32801), Reflex::Literal("vector"), constructor_13387, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_13388, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3142, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x14, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x15, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_metsig__SigInputObj__funcmem_bld);
}

//------Delayed data member builder for class vector<metsig::SigInputObj,std::allocator<metsig::SigInputObj> > -------------------
void __std__vector_metsig__SigInputObj__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<metsig::SigInputObj,std::allocator<metsig::SigInputObj> > -------------------
void __std__vector_metsig__SigInputObj__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32802, type_32801), Reflex::Literal("operator="), operator_13389, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394, type_13375), Reflex::Literal("assign"), method_13390, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8152), Reflex::Literal("begin"), method_13391, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8153), Reflex::Literal("begin"), method_13392, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8152), Reflex::Literal("end"), method_13393, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8153), Reflex::Literal("end"), method_13394, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("size"), method_13399, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("max_size"), method_13400, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394, type_3824), Reflex::Literal("resize"), method_13401, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("capacity"), method_13402, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("empty"), method_13403, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394), Reflex::Literal("reserve"), method_13404, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13373, type_3394), Reflex::Literal("operator[]"), operator_13405, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13375, type_3394), Reflex::Literal("operator[]"), operator_13406, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13373, type_3394), Reflex::Literal("at"), method_13408, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13375, type_3394), Reflex::Literal("at"), method_13409, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13373), Reflex::Literal("front"), method_13410, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13375), Reflex::Literal("front"), method_13411, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13373), Reflex::Literal("back"), method_13412, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13375), Reflex::Literal("back"), method_13413, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13369), Reflex::Literal("data"), method_13414, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13371), Reflex::Literal("data"), method_13415, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_13375), Reflex::Literal("push_back"), method_13416, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("pop_back"), method_13417, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8152, type_8152, type_13375), Reflex::Literal("insert"), method_13418, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_8152, type_3394, type_13375), Reflex::Literal("insert"), method_13419, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8152, type_8152), Reflex::Literal("erase"), method_13420, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8152, type_8152, type_8152), Reflex::Literal("erase"), method_13421, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_32802), Reflex::Literal("swap"), method_13422, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("clear"), method_13423, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<CorrMETData,std::allocator<CorrMETData> > -------------------------------
static void constructor_13449( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<CorrMETData>();
  else ::new(mem) ::std::vector<CorrMETData>();
}

static void constructor_13450( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<CorrMETData>(*(const ::std::allocator<CorrMETData>*)arg[0]);
  else ::new(mem) ::std::vector<CorrMETData>(*(const ::std::allocator<CorrMETData>*)arg[0]);
}

static void constructor_13451( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<CorrMETData>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<CorrMETData>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<CorrMETData>(*(::std::size_t*)arg[0],
      *(const ::CorrMETData*)arg[1]);
  else ::new(mem) ::std::vector<CorrMETData>(*(::std::size_t*)arg[0],
      *(const ::CorrMETData*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<CorrMETData>(*(::std::size_t*)arg[0],
      *(const ::CorrMETData*)arg[1],
      *(const ::std::allocator<CorrMETData>*)arg[2]);
  else ::new(mem) ::std::vector<CorrMETData>(*(::std::size_t*)arg[0],
      *(const ::CorrMETData*)arg[1],
      *(const ::std::allocator<CorrMETData>*)arg[2]);
  }
}

static void constructor_13452( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<CorrMETData>(*(const ::std::vector<CorrMETData>*)arg[0]);
  else ::new(mem) ::std::vector<CorrMETData>(*(const ::std::vector<CorrMETData>*)arg[0]);
}

static void destructor_13453(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<CorrMETData>*)o)->::std::vector<CorrMETData>::~vector)();
}
static  void operator_13454( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<CorrMETData>*)o)->operator=)(*(const ::std::vector<CorrMETData>*)arg[0]);
  else   (((::std::vector<CorrMETData>*)o)->operator=)(*(const ::std::vector<CorrMETData>*)arg[0]);
}

static  void method_13455( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<CorrMETData>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::CorrMETData*)arg[1]);
}

static  void method_13456( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<CorrMETData*,std::vector<CorrMETData> >)((((::std::vector<CorrMETData>*)o)->begin)());
  else   (((::std::vector<CorrMETData>*)o)->begin)();
}

static  void method_13457( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const CorrMETData*,std::vector<CorrMETData> >)((((const ::std::vector<CorrMETData>*)o)->begin)());
  else   (((const ::std::vector<CorrMETData>*)o)->begin)();
}

static  void method_13458( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<CorrMETData*,std::vector<CorrMETData> >)((((::std::vector<CorrMETData>*)o)->end)());
  else   (((::std::vector<CorrMETData>*)o)->end)();
}

static  void method_13459( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const CorrMETData*,std::vector<CorrMETData> >)((((const ::std::vector<CorrMETData>*)o)->end)());
  else   (((const ::std::vector<CorrMETData>*)o)->end)();
}

static  void method_13464( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<CorrMETData>*)o)->size)());
  else   (((const ::std::vector<CorrMETData>*)o)->size)();
}

static  void method_13465( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<CorrMETData>*)o)->max_size)());
  else   (((const ::std::vector<CorrMETData>*)o)->max_size)();
}

static  void method_13466( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<CorrMETData>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<CorrMETData>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::CorrMETData*)arg[1]);
  }
}

static  void method_13467( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<CorrMETData>*)o)->capacity)());
  else   (((const ::std::vector<CorrMETData>*)o)->capacity)();
}

static  void method_13468( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<CorrMETData>*)o)->empty)());
  else   (((const ::std::vector<CorrMETData>*)o)->empty)();
}

static  void method_13469( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<CorrMETData>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_13470( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<CorrMETData>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<CorrMETData>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_13471( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<CorrMETData>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<CorrMETData>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_13473( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<CorrMETData>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<CorrMETData>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13474( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<CorrMETData>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<CorrMETData>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13475( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<CorrMETData>*)o)->front)();
  else   (((::std::vector<CorrMETData>*)o)->front)();
}

static  void method_13476( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<CorrMETData>*)o)->front)();
  else   (((const ::std::vector<CorrMETData>*)o)->front)();
}

static  void method_13477( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<CorrMETData>*)o)->back)();
  else   (((::std::vector<CorrMETData>*)o)->back)();
}

static  void method_13478( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<CorrMETData>*)o)->back)();
  else   (((const ::std::vector<CorrMETData>*)o)->back)();
}

static  void method_13479( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<CorrMETData>*)o)->data)());
  else   (((::std::vector<CorrMETData>*)o)->data)();
}

static  void method_13480( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<CorrMETData>*)o)->data)());
  else   (((const ::std::vector<CorrMETData>*)o)->data)();
}

static  void method_13481( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<CorrMETData>*)o)->push_back)(*(const ::CorrMETData*)arg[0]);
}

static  void method_13482( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<CorrMETData>*)o)->pop_back)();
}

static  void method_13483( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<CorrMETData*,std::vector<CorrMETData> >)((((::std::vector<CorrMETData>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<CorrMETData*,std::vector<CorrMETData> >*)arg[0],
    *(const ::CorrMETData*)arg[1]));
  else   (((::std::vector<CorrMETData>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<CorrMETData*,std::vector<CorrMETData> >*)arg[0],
    *(const ::CorrMETData*)arg[1]);
}

static  void method_13484( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<CorrMETData>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<CorrMETData*,std::vector<CorrMETData> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::CorrMETData*)arg[2]);
}

static  void method_13485( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<CorrMETData*,std::vector<CorrMETData> >)((((::std::vector<CorrMETData>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<CorrMETData*,std::vector<CorrMETData> >*)arg[0]));
  else   (((::std::vector<CorrMETData>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<CorrMETData*,std::vector<CorrMETData> >*)arg[0]);
}

static  void method_13486( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<CorrMETData*,std::vector<CorrMETData> >)((((::std::vector<CorrMETData>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<CorrMETData*,std::vector<CorrMETData> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<CorrMETData*,std::vector<CorrMETData> >*)arg[1]));
  else   (((::std::vector<CorrMETData>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<CorrMETData*,std::vector<CorrMETData> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<CorrMETData*,std::vector<CorrMETData> >*)arg[1]);
}

static  void method_13487( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<CorrMETData>*)o)->swap)(*(::std::vector<CorrMETData>*)arg[0]);
}

static  void method_13488( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<CorrMETData>*)o)->clear)();
}

static void method_newdel_3143( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<CorrMETData> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<CorrMETData> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<CorrMETData> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<CorrMETData> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<CorrMETData> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x17( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<CorrMETData,std::allocator<CorrMETData> >")), ::Reflex::BaseOffset< ::std::vector<CorrMETData>,::std::_Vector_base<CorrMETData,std::allocator<CorrMETData> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x18( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<CorrMETData> >::Generate();
  else ::Reflex::Proxy< ::std::vector<CorrMETData> >::Generate();
}

//------Dictionary for class vector<CorrMETData,std::allocator<CorrMETData> > -------------------------------
void __std__vector_CorrMETData__db_datamem(Reflex::Class*);
void __std__vector_CorrMETData__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_CorrMETData__datamem_bld(&__std__vector_CorrMETData__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_CorrMETData__funcmem_bld(&__std__vector_CorrMETData__db_funcmem);
void __std__vector_CorrMETData__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<CorrMETData>"), typeid(::std::vector<CorrMETData>), sizeof(::std::vector<CorrMETData>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2619, ::Reflex::BaseOffset< ::std::vector<CorrMETData>, ::std::_Vector_base<CorrMETData,std::allocator<CorrMETData> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_1653, Reflex::Literal("std::vector<CorrMETData>::_Alloc_value_type"))
  .AddTypedef(type_2619, Reflex::Literal("std::vector<CorrMETData>::_Base"))
  .AddTypedef(type_3413, Reflex::Literal("std::vector<CorrMETData>::_Tp_alloc_type"))
  .AddTypedef(type_1653, Reflex::Literal("std::vector<CorrMETData>::value_type"))
  .AddTypedef(type_13434, Reflex::Literal("std::vector<CorrMETData>::pointer"))
  .AddTypedef(type_13436, Reflex::Literal("std::vector<CorrMETData>::const_pointer"))
  .AddTypedef(type_13438, Reflex::Literal("std::vector<CorrMETData>::reference"))
  .AddTypedef(type_13440, Reflex::Literal("std::vector<CorrMETData>::const_reference"))
  .AddTypedef(type_8204, Reflex::Literal("std::vector<CorrMETData>::iterator"))
  .AddTypedef(type_8205, Reflex::Literal("std::vector<CorrMETData>::const_iterator"))
  .AddTypedef(type_3657, Reflex::Literal("std::vector<CorrMETData>::const_reverse_iterator"))
  .AddTypedef(type_3658, Reflex::Literal("std::vector<CorrMETData>::reverse_iterator"))
  .AddTypedef(type_3394, Reflex::Literal("std::vector<CorrMETData>::size_type"))
  .AddTypedef(type_3290, Reflex::Literal("std::vector<CorrMETData>::difference_type"))
  .AddTypedef(type_3413, Reflex::Literal("std::vector<CorrMETData>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_13449, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31957), Reflex::Literal("vector"), constructor_13450, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3394, type_13440, type_31957), Reflex::Literal("vector"), constructor_13451, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32804), Reflex::Literal("vector"), constructor_13452, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_13453, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3143, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x17, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x18, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_CorrMETData__funcmem_bld);
}

//------Delayed data member builder for class vector<CorrMETData,std::allocator<CorrMETData> > -------------------
void __std__vector_CorrMETData__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<CorrMETData,std::allocator<CorrMETData> > -------------------
void __std__vector_CorrMETData__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32805, type_32804), Reflex::Literal("operator="), operator_13454, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394, type_13440), Reflex::Literal("assign"), method_13455, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8204), Reflex::Literal("begin"), method_13456, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8205), Reflex::Literal("begin"), method_13457, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8204), Reflex::Literal("end"), method_13458, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8205), Reflex::Literal("end"), method_13459, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("size"), method_13464, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("max_size"), method_13465, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394, type_1653), Reflex::Literal("resize"), method_13466, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("capacity"), method_13467, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("empty"), method_13468, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394), Reflex::Literal("reserve"), method_13469, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13438, type_3394), Reflex::Literal("operator[]"), operator_13470, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13440, type_3394), Reflex::Literal("operator[]"), operator_13471, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13438, type_3394), Reflex::Literal("at"), method_13473, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13440, type_3394), Reflex::Literal("at"), method_13474, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13438), Reflex::Literal("front"), method_13475, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13440), Reflex::Literal("front"), method_13476, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13438), Reflex::Literal("back"), method_13477, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13440), Reflex::Literal("back"), method_13478, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13434), Reflex::Literal("data"), method_13479, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13436), Reflex::Literal("data"), method_13480, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_13440), Reflex::Literal("push_back"), method_13481, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("pop_back"), method_13482, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8204, type_8204, type_13440), Reflex::Literal("insert"), method_13483, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_8204, type_3394, type_13440), Reflex::Literal("insert"), method_13484, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8204, type_8204), Reflex::Literal("erase"), method_13485, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8204, type_8204, type_8204), Reflex::Literal("erase"), method_13486, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_32805), Reflex::Literal("swap"), method_13487, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("clear"), method_13488, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<CommonMETData,std::allocator<CommonMETData> > -------------------------------
static void constructor_13514( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<CommonMETData>();
  else ::new(mem) ::std::vector<CommonMETData>();
}

static void constructor_13515( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<CommonMETData>(*(const ::std::allocator<CommonMETData>*)arg[0]);
  else ::new(mem) ::std::vector<CommonMETData>(*(const ::std::allocator<CommonMETData>*)arg[0]);
}

static void constructor_13516( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<CommonMETData>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<CommonMETData>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<CommonMETData>(*(::std::size_t*)arg[0],
      *(const ::CommonMETData*)arg[1]);
  else ::new(mem) ::std::vector<CommonMETData>(*(::std::size_t*)arg[0],
      *(const ::CommonMETData*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<CommonMETData>(*(::std::size_t*)arg[0],
      *(const ::CommonMETData*)arg[1],
      *(const ::std::allocator<CommonMETData>*)arg[2]);
  else ::new(mem) ::std::vector<CommonMETData>(*(::std::size_t*)arg[0],
      *(const ::CommonMETData*)arg[1],
      *(const ::std::allocator<CommonMETData>*)arg[2]);
  }
}

static void constructor_13517( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<CommonMETData>(*(const ::std::vector<CommonMETData>*)arg[0]);
  else ::new(mem) ::std::vector<CommonMETData>(*(const ::std::vector<CommonMETData>*)arg[0]);
}

static void destructor_13518(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<CommonMETData>*)o)->::std::vector<CommonMETData>::~vector)();
}
static  void operator_13519( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<CommonMETData>*)o)->operator=)(*(const ::std::vector<CommonMETData>*)arg[0]);
  else   (((::std::vector<CommonMETData>*)o)->operator=)(*(const ::std::vector<CommonMETData>*)arg[0]);
}

static  void method_13520( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<CommonMETData>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::CommonMETData*)arg[1]);
}

static  void method_13521( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<CommonMETData*,std::vector<CommonMETData> >)((((::std::vector<CommonMETData>*)o)->begin)());
  else   (((::std::vector<CommonMETData>*)o)->begin)();
}

static  void method_13522( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const CommonMETData*,std::vector<CommonMETData> >)((((const ::std::vector<CommonMETData>*)o)->begin)());
  else   (((const ::std::vector<CommonMETData>*)o)->begin)();
}

static  void method_13523( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<CommonMETData*,std::vector<CommonMETData> >)((((::std::vector<CommonMETData>*)o)->end)());
  else   (((::std::vector<CommonMETData>*)o)->end)();
}

static  void method_13524( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const CommonMETData*,std::vector<CommonMETData> >)((((const ::std::vector<CommonMETData>*)o)->end)());
  else   (((const ::std::vector<CommonMETData>*)o)->end)();
}

static  void method_13529( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<CommonMETData>*)o)->size)());
  else   (((const ::std::vector<CommonMETData>*)o)->size)();
}

static  void method_13530( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<CommonMETData>*)o)->max_size)());
  else   (((const ::std::vector<CommonMETData>*)o)->max_size)();
}

static  void method_13531( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<CommonMETData>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<CommonMETData>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::CommonMETData*)arg[1]);
  }
}

static  void method_13532( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<CommonMETData>*)o)->capacity)());
  else   (((const ::std::vector<CommonMETData>*)o)->capacity)();
}

static  void method_13533( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<CommonMETData>*)o)->empty)());
  else   (((const ::std::vector<CommonMETData>*)o)->empty)();
}

static  void method_13534( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<CommonMETData>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_13535( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<CommonMETData>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<CommonMETData>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_13536( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<CommonMETData>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<CommonMETData>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_13538( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<CommonMETData>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<CommonMETData>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13539( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<CommonMETData>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<CommonMETData>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13540( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<CommonMETData>*)o)->front)();
  else   (((::std::vector<CommonMETData>*)o)->front)();
}

static  void method_13541( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<CommonMETData>*)o)->front)();
  else   (((const ::std::vector<CommonMETData>*)o)->front)();
}

static  void method_13542( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<CommonMETData>*)o)->back)();
  else   (((::std::vector<CommonMETData>*)o)->back)();
}

static  void method_13543( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<CommonMETData>*)o)->back)();
  else   (((const ::std::vector<CommonMETData>*)o)->back)();
}

static  void method_13544( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<CommonMETData>*)o)->data)());
  else   (((::std::vector<CommonMETData>*)o)->data)();
}

static  void method_13545( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<CommonMETData>*)o)->data)());
  else   (((const ::std::vector<CommonMETData>*)o)->data)();
}

static  void method_13546( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<CommonMETData>*)o)->push_back)(*(const ::CommonMETData*)arg[0]);
}

static  void method_13547( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<CommonMETData>*)o)->pop_back)();
}

static  void method_13548( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<CommonMETData*,std::vector<CommonMETData> >)((((::std::vector<CommonMETData>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<CommonMETData*,std::vector<CommonMETData> >*)arg[0],
    *(const ::CommonMETData*)arg[1]));
  else   (((::std::vector<CommonMETData>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<CommonMETData*,std::vector<CommonMETData> >*)arg[0],
    *(const ::CommonMETData*)arg[1]);
}

static  void method_13549( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<CommonMETData>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<CommonMETData*,std::vector<CommonMETData> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::CommonMETData*)arg[2]);
}

static  void method_13550( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<CommonMETData*,std::vector<CommonMETData> >)((((::std::vector<CommonMETData>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<CommonMETData*,std::vector<CommonMETData> >*)arg[0]));
  else   (((::std::vector<CommonMETData>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<CommonMETData*,std::vector<CommonMETData> >*)arg[0]);
}

static  void method_13551( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<CommonMETData*,std::vector<CommonMETData> >)((((::std::vector<CommonMETData>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<CommonMETData*,std::vector<CommonMETData> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<CommonMETData*,std::vector<CommonMETData> >*)arg[1]));
  else   (((::std::vector<CommonMETData>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<CommonMETData*,std::vector<CommonMETData> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<CommonMETData*,std::vector<CommonMETData> >*)arg[1]);
}

static  void method_13552( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<CommonMETData>*)o)->swap)(*(::std::vector<CommonMETData>*)arg[0]);
}

static  void method_13553( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<CommonMETData>*)o)->clear)();
}

static void method_newdel_3144( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<CommonMETData> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<CommonMETData> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<CommonMETData> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<CommonMETData> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<CommonMETData> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x20( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<CommonMETData,std::allocator<CommonMETData> >")), ::Reflex::BaseOffset< ::std::vector<CommonMETData>,::std::_Vector_base<CommonMETData,std::allocator<CommonMETData> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x21( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<CommonMETData> >::Generate();
  else ::Reflex::Proxy< ::std::vector<CommonMETData> >::Generate();
}

//------Dictionary for class vector<CommonMETData,std::allocator<CommonMETData> > -------------------------------
void __std__vector_CommonMETData__db_datamem(Reflex::Class*);
void __std__vector_CommonMETData__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_CommonMETData__datamem_bld(&__std__vector_CommonMETData__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_CommonMETData__funcmem_bld(&__std__vector_CommonMETData__db_funcmem);
void __std__vector_CommonMETData__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<CommonMETData>"), typeid(::std::vector<CommonMETData>), sizeof(::std::vector<CommonMETData>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2592, ::Reflex::BaseOffset< ::std::vector<CommonMETData>, ::std::_Vector_base<CommonMETData,std::allocator<CommonMETData> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2300, Reflex::Literal("std::vector<CommonMETData>::_Alloc_value_type"))
  .AddTypedef(type_2592, Reflex::Literal("std::vector<CommonMETData>::_Base"))
  .AddTypedef(type_3414, Reflex::Literal("std::vector<CommonMETData>::_Tp_alloc_type"))
  .AddTypedef(type_2300, Reflex::Literal("std::vector<CommonMETData>::value_type"))
  .AddTypedef(type_13499, Reflex::Literal("std::vector<CommonMETData>::pointer"))
  .AddTypedef(type_13501, Reflex::Literal("std::vector<CommonMETData>::const_pointer"))
  .AddTypedef(type_13503, Reflex::Literal("std::vector<CommonMETData>::reference"))
  .AddTypedef(type_13505, Reflex::Literal("std::vector<CommonMETData>::const_reference"))
  .AddTypedef(type_8154, Reflex::Literal("std::vector<CommonMETData>::iterator"))
  .AddTypedef(type_8155, Reflex::Literal("std::vector<CommonMETData>::const_iterator"))
  .AddTypedef(type_3601, Reflex::Literal("std::vector<CommonMETData>::const_reverse_iterator"))
  .AddTypedef(type_3602, Reflex::Literal("std::vector<CommonMETData>::reverse_iterator"))
  .AddTypedef(type_3394, Reflex::Literal("std::vector<CommonMETData>::size_type"))
  .AddTypedef(type_3290, Reflex::Literal("std::vector<CommonMETData>::difference_type"))
  .AddTypedef(type_3414, Reflex::Literal("std::vector<CommonMETData>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_13514, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31633), Reflex::Literal("vector"), constructor_13515, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3394, type_13505, type_31633), Reflex::Literal("vector"), constructor_13516, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32807), Reflex::Literal("vector"), constructor_13517, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_13518, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3144, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x20, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x21, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_CommonMETData__funcmem_bld);
}

//------Delayed data member builder for class vector<CommonMETData,std::allocator<CommonMETData> > -------------------
void __std__vector_CommonMETData__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<CommonMETData,std::allocator<CommonMETData> > -------------------
void __std__vector_CommonMETData__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32808, type_32807), Reflex::Literal("operator="), operator_13519, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394, type_13505), Reflex::Literal("assign"), method_13520, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8154), Reflex::Literal("begin"), method_13521, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8155), Reflex::Literal("begin"), method_13522, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8154), Reflex::Literal("end"), method_13523, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8155), Reflex::Literal("end"), method_13524, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("size"), method_13529, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("max_size"), method_13530, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394, type_2300), Reflex::Literal("resize"), method_13531, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("capacity"), method_13532, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("empty"), method_13533, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394), Reflex::Literal("reserve"), method_13534, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13503, type_3394), Reflex::Literal("operator[]"), operator_13535, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13505, type_3394), Reflex::Literal("operator[]"), operator_13536, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13503, type_3394), Reflex::Literal("at"), method_13538, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13505, type_3394), Reflex::Literal("at"), method_13539, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13503), Reflex::Literal("front"), method_13540, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13505), Reflex::Literal("front"), method_13541, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13503), Reflex::Literal("back"), method_13542, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13505), Reflex::Literal("back"), method_13543, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13499), Reflex::Literal("data"), method_13544, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13501), Reflex::Literal("data"), method_13545, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_13505), Reflex::Literal("push_back"), method_13546, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("pop_back"), method_13547, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8154, type_8154, type_13505), Reflex::Literal("insert"), method_13548, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_8154, type_3394, type_13505), Reflex::Literal("insert"), method_13549, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8154, type_8154), Reflex::Literal("erase"), method_13550, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8154, type_8154, type_8154), Reflex::Literal("erase"), method_13551, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_32808), Reflex::Literal("swap"), method_13552, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("clear"), method_13553, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class MET -------------------------------
static  void operator_27583( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::MET*)o)->operator=)(*(const ::reco::MET*)arg[0]);
  else   (((::reco::MET*)o)->operator=)(*(const ::reco::MET*)arg[0]);
}

static void constructor_27584( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::MET(*(const ::reco::MET*)arg[0]);
  else ::new(mem) ::reco::MET(*(const ::reco::MET*)arg[0]);
}

static void constructor_27585( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::MET();
  else ::new(mem) ::reco::MET();
}

static void constructor_27586( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::MET(*(const ::math::XYZTLorentzVector*)arg[0],
      *(const ::math::XYZPoint*)arg[1]);
  else ::new(mem) ::reco::MET(*(const ::math::XYZTLorentzVector*)arg[0],
      *(const ::math::XYZPoint*)arg[1]);
}

static void constructor_27587( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::MET(*(double*)arg[0],
      *(const ::math::XYZTLorentzVector*)arg[1],
      *(const ::math::XYZPoint*)arg[2]);
  else ::new(mem) ::reco::MET(*(double*)arg[0],
      *(const ::math::XYZTLorentzVector*)arg[1],
      *(const ::math::XYZPoint*)arg[2]);
}

static void constructor_27588( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::MET(*(double*)arg[0],
      *(::std::vector<CorrMETData>*)arg[1],
      *(const ::math::XYZTLorentzVector*)arg[2],
      *(const ::math::XYZPoint*)arg[3]);
  else ::new(mem) ::reco::MET(*(double*)arg[0],
      *(::std::vector<CorrMETData>*)arg[1],
      *(const ::math::XYZTLorentzVector*)arg[2],
      *(const ::math::XYZPoint*)arg[3]);
}

static  void method_27589( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::reco::MET*)o)->clone)());
  else   (((const ::reco::MET*)o)->clone)();
}

static  void method_27590( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::MET*)o)->sumEt)());
  else   (((const ::reco::MET*)o)->sumEt)();
}

static  void method_27591( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::MET*)o)->mEtSig)());
  else   (((const ::reco::MET*)o)->mEtSig)();
}

static  void method_27592( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::MET*)o)->significance)());
  else   (((const ::reco::MET*)o)->significance)();
}

static  void method_27593( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::MET*)o)->e_longitudinal)());
  else   (((const ::reco::MET*)o)->e_longitudinal)();
}

static  void method_27594( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<double>)((((const ::reco::MET*)o)->dmEx)());
  else   (((const ::reco::MET*)o)->dmEx)();
}

static  void method_27595( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<double>)((((const ::reco::MET*)o)->dmEy)());
  else   (((const ::reco::MET*)o)->dmEy)();
}

static  void method_27596( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<double>)((((const ::reco::MET*)o)->dsumEt)());
  else   (((const ::reco::MET*)o)->dsumEt)();
}

static  void method_27597( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<double>)((((const ::reco::MET*)o)->dSignificance)());
  else   (((const ::reco::MET*)o)->dSignificance)();
}

static  void method_27598( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<CorrMETData>)((((const ::reco::MET*)o)->mEtCorr)());
  else   (((const ::reco::MET*)o)->mEtCorr)();
}

static  void method_27599( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::MET*)o)->setSignificanceMatrix)(*(const ::TMatrixD*)arg[0]);
}

static  void method_27600( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (TMatrixD)((((const ::reco::MET*)o)->getSignificanceMatrix)());
  else   (((const ::reco::MET*)o)->getSignificanceMatrix)();
}

static void destructor_27602(void*, void * o, const std::vector<void*>&, void *) {
(((::reco::MET*)o)->::reco::MET::~MET)();
}
static void method_newdel_7952( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::reco::MET >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::reco::MET >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::reco::MET >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::reco::MET >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::reco::MET >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x23( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::RecoCandidate")), ::Reflex::BaseOffset< ::reco::MET,::reco::RecoCandidate >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::reco::MET,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::reco::MET,::reco::Candidate >::Get(),::Reflex::PUBLIC), 2));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class MET -------------------------------
void __reco__MET_db_datamem(Reflex::Class*);
void __reco__MET_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __reco__MET_datamem_bld(&__reco__MET_db_datamem);
Reflex::GenreflexMemberBuilder __reco__MET_funcmem_bld(&__reco__MET_db_funcmem);
void __reco__MET_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("reco::MET"), typeid(::reco::MET), sizeof(::reco::MET), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddBase(type_7957, ::Reflex::BaseOffset< ::reco::MET, ::reco::RecoCandidate >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13633, type_13635), Reflex::Literal("operator="), operator_27583, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13635), Reflex::Literal("MET"), constructor_27584, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("MET"), constructor_27585, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39102, type_39103), Reflex::Literal("MET"), constructor_27586, 0, "p4_;vtx_", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_107, type_39102, type_39103), Reflex::Literal("MET"), constructor_27587, 0, "sumet_;p4_;vtx_", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_107, type_3143, type_39102, type_39103), Reflex::Literal("MET"), constructor_27588, 0, "sumet_;corr_;p4_;vtx_", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~MET"), destructor_27602, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7952, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x23, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__reco__MET_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__reco__MET_funcmem_bld);
}

//------Delayed data member builder for class MET -------------------
void __reco__MET_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_107, Reflex::Literal("sumet"), OffsetOf(__shadow__::__reco__MET, sumet), ::Reflex::PRIVATE)
  .AddDataMember(type_107, Reflex::Literal("elongit"), OffsetOf(__shadow__::__reco__MET, elongit), ::Reflex::PRIVATE)
  .AddDataMember(type_107, Reflex::Literal("signif_dxx"), OffsetOf(__shadow__::__reco__MET, signif_dxx), ::Reflex::PRIVATE)
  .AddDataMember(type_107, Reflex::Literal("signif_dyy"), OffsetOf(__shadow__::__reco__MET, signif_dyy), ::Reflex::PRIVATE)
  .AddDataMember(type_107, Reflex::Literal("signif_dyx"), OffsetOf(__shadow__::__reco__MET, signif_dyx), ::Reflex::PRIVATE)
  .AddDataMember(type_107, Reflex::Literal("signif_dxy"), OffsetOf(__shadow__::__reco__MET, signif_dxy), ::Reflex::PRIVATE)
  .AddDataMember(type_3143, Reflex::Literal("corr"), OffsetOf(__shadow__::__reco__MET, corr), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class MET -------------------
void __reco__MET_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13629), Reflex::Literal("clone"), method_27589, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("sumEt"), method_27590, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("mEtSig"), method_27591, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("significance"), method_27592, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("e_longitudinal"), method_27593, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3171), Reflex::Literal("dmEx"), method_27594, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3171), Reflex::Literal("dmEy"), method_27595, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3171), Reflex::Literal("dsumEt"), method_27596, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3171), Reflex::Literal("dSignificance"), method_27597, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3143), Reflex::Literal("mEtCorr"), method_27598, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_30559), Reflex::Literal("setSignificanceMatrix"), method_27599, 0, "matrix", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1147), Reflex::Literal("getSignificanceMatrix"), method_27600, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Ref<std::vector<reco::MET, std::allocator<reco::MET> >,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET, std::allocator<reco::MET> >, reco::MET> > -------------------------------
static  void operator_22043( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->operator=)(*(const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)arg[0]);
  else   (((::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->operator=)(*(const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)arg[0]);
}

static void constructor_22044( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >(*(const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >(*(const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)arg[0]);
}

static void constructor_22045( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >();
  else ::new(mem) ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >();
}

static void constructor_22046( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >(*(const ::edm::Handle<std::vector<reco::MET> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >(*(const ::edm::Handle<std::vector<reco::MET> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >(*(const ::edm::Handle<std::vector<reco::MET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >(*(const ::edm::Handle<std::vector<reco::MET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_22047( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >(*(const ::edm::OrphanHandle<std::vector<reco::MET> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >(*(const ::edm::OrphanHandle<std::vector<reco::MET> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >(*(const ::edm::OrphanHandle<std::vector<reco::MET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >(*(const ::edm::OrphanHandle<std::vector<reco::MET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_22048( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >(*(const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >(*(const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >(*(const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >(*(const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_22049( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >((const ::std::vector<reco::MET>*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >((const ::std::vector<reco::MET>*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >((const ::std::vector<reco::MET>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >((const ::std::vector<reco::MET>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_22050( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >(*(const ::edm::TestHandle<std::vector<reco::MET> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >(*(const ::edm::TestHandle<std::vector<reco::MET> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >(*(const ::edm::TestHandle<std::vector<reco::MET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >(*(const ::edm::TestHandle<std::vector<reco::MET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_22051( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_22052( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >(*(const ::edm::ProductID*)arg[0],
      (const ::reco::MET*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<reco::MET>*)arg[3]);
  else ::new(mem) ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >(*(const ::edm::ProductID*)arg[0],
      (const ::reco::MET*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<reco::MET>*)arg[3]);
}

static void constructor_22053( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_22054( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >(*(const ::edm::RefProd<std::vector<reco::MET> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >(*(const ::edm::RefProd<std::vector<reco::MET> >*)arg[0],
      *(unsigned int*)arg[1]);
}

static void destructor_22055(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >::~Ref)();
}
static  void operator_22056( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->operator*)();
  else   (((const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->operator*)();
}

static  void operator_22057( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->operator->)());
  else   (((const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->operator->)();
}

static  void method_22058( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->get)());
  else   (((const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->get)();
}

static  void method_22059( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->isNull)());
  else   (((const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->isNull)();
}

static  void method_22060( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->isNonnull)());
  else   (((const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->isNonnull)();
}

static  void operator_22061( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->operator!)());
  else   (((const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->operator!)();
}

static  void method_22062( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->id)());
  else   (((const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->id)();
}

static  void method_22063( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->productGetter)());
  else   (((const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->productGetter)();
}

static  void method_22064( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->product)());
  else   (((const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->product)();
}

static  void method_22065( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->key)());
  else   (((const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->key)();
}

static  void method_22066( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->index)());
  else   (((const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->index)();
}

static  void method_22067( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->hasProductCache)());
  else   (((const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->hasProductCache)();
}

static  void method_22068( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->isAvailable)());
  else   (((const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->isAvailable)();
}

static  void method_22069( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->isTransient)());
  else   (((const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->isTransient)();
}

static  void method_22070( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->refCore)();
  else   (((const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->refCore)();
}

static  void method_22071( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->Class_Version)());
  else   (((::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->Class_Version)();
}

static void constructor_22072( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_4913( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ref<std::vector<reco::MET, std::allocator<reco::MET> >,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET, std::allocator<reco::MET> >, reco::MET> > -------------------------------
void __edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s__db_datamem(Reflex::Class*);
void __edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s__datamem_bld(&__edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s__funcmem_bld(&__edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s__db_funcmem);
void __edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >"), typeid(::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >), sizeof(::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >::Class_Version())
  .AddTypedef(type_7952, Reflex::Literal("edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >::T"))
  .AddTypedef(type_20092, Reflex::Literal("edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >::F"))
  .AddTypedef(type_20073, Reflex::Literal("edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >::VF"))
  .AddTypedef(type_20072, Reflex::Literal("edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >::VBF"))
  .AddTypedef(type_3146, Reflex::Literal("edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >::product_type"))
  .AddTypedef(type_7952, Reflex::Literal("edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >::value_type"))
  .AddTypedef(type_7952c, Reflex::Literal("edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >::element_type"))
  .AddTypedef(type_20092, Reflex::Literal("edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >::finder_type"))
  .AddTypedef(type_373, Reflex::Literal("edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >::argument_type"))
  .AddTypedef(type_373, Reflex::Literal("edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >::key_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13568, type_13570), Reflex::Literal("operator="), operator_22043, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13570), Reflex::Literal("Ref"), constructor_22044, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ref"), constructor_22045, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34357, type_373, type_1647), Reflex::Literal("Ref"), constructor_22046, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34358, type_373, type_1647), Reflex::Literal("Ref"), constructor_22047, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33834, type_373, type_1647), Reflex::Literal("Ref"), constructor_22048, 0, "refvector;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33835, type_373, type_1647), Reflex::Literal("Ref"), constructor_22049, 0, "iProduct;iItemKey;iSetNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34359, type_373, type_1647), Reflex::Literal("Ref"), constructor_22050, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19738, type_373, type_19828), Reflex::Literal("Ref"), constructor_22051, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19738, type_13631, type_373, type_33835), Reflex::Literal("Ref"), constructor_22052, 0, "iProductID;;iItemKey;iProduct", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19738), Reflex::Literal("Ref"), constructor_22053, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34356, type_373), Reflex::Literal("Ref"), constructor_22054, 0, "refProd;itemKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ref"), destructor_22055, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21396, type_10352), Reflex::Literal("Ref"), constructor_22072, 0, "iRefCore;iKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4913, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s__funcmem_bld);
}

//------Delayed data member builder for class Ref<std::vector<reco::MET, std::allocator<reco::MET> >,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET, std::allocator<reco::MET> >, reco::MET> > -------------------
void __edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4931, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_, product_), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class Ref<std::vector<reco::MET, std::allocator<reco::MET> >,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET, std::allocator<reco::MET> >, reco::MET> > -------------------
void __edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13635), Reflex::Literal("operator*"), operator_22056, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13631), Reflex::Literal("operator->"), operator_22057, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13631), Reflex::Literal("get"), method_22058, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isNull"), method_22059, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isNonnull"), method_22060, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("operator!"), operator_22061, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4866), Reflex::Literal("id"), method_22062, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19828), Reflex::Literal("productGetter"), method_22063, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33835), Reflex::Literal("product"), method_22064, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_373), Reflex::Literal("key"), method_22065, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_373), Reflex::Literal("index"), method_22066, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("hasProductCache"), method_22067, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isAvailable"), method_22068, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isTransient"), method_22069, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21396), Reflex::Literal("refCore"), method_22070, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_192), Reflex::Literal("Class_Version"), method_22071, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class vector<edm::Ref<std::vector<reco::MET, std::allocator<reco::MET> >, reco::MET, edm::refhelper::FindUsingAdvance<std::vector<reco::MET, std::allocator<reco::MET> >, reco::MET> >,std::allocator<edm::Ref<std::vector<reco::MET, std::allocator<reco::MET> >, reco::MET, edm::refhelper::FindUsingAdvance<std::vector<reco::MET, std::allocator<reco::MET> >, reco::MET> > > > -------------------------------
static void constructor_13579( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >();
  else ::new(mem) ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >();
}

static void constructor_13580( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >(*(const ::std::allocator<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)arg[0]);
  else ::new(mem) ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >(*(const ::std::allocator<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)arg[0]);
}

static void constructor_13581( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >(*(::std::size_t*)arg[0],
      *(const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)arg[1]);
  else ::new(mem) ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >(*(::std::size_t*)arg[0],
      *(const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >(*(::std::size_t*)arg[0],
      *(const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)arg[1],
      *(const ::std::allocator<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)arg[2]);
  else ::new(mem) ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >(*(::std::size_t*)arg[0],
      *(const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)arg[1],
      *(const ::std::allocator<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)arg[2]);
  }
}

static void constructor_13582( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >(*(const ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)arg[0]);
  else ::new(mem) ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >(*(const ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)arg[0]);
}

static void destructor_13583(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >::~vector)();
}
static  void operator_13584( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->operator=)(*(const ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)arg[0]);
  else   (((::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->operator=)(*(const ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)arg[0]);
}

static  void method_13585( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)arg[1]);
}

static  void method_13586( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*,std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > >)((((::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->begin)());
  else   (((::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->begin)();
}

static  void method_13587( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*,std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > >)((((const ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->begin)());
  else   (((const ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->begin)();
}

static  void method_13588( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*,std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > >)((((::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->end)());
  else   (((::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->end)();
}

static  void method_13589( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*,std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > >)((((const ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->end)());
  else   (((const ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->end)();
}

static  void method_13594( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->size)());
  else   (((const ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->size)();
}

static  void method_13595( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->max_size)());
  else   (((const ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->max_size)();
}

static  void method_13596( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)arg[1]);
  }
}

static  void method_13597( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->capacity)());
  else   (((const ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->capacity)();
}

static  void method_13598( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->empty)());
  else   (((const ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->empty)();
}

static  void method_13599( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_13600( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_13601( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_13603( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13604( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13605( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->front)();
  else   (((::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->front)();
}

static  void method_13606( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->front)();
  else   (((const ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->front)();
}

static  void method_13607( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->back)();
  else   (((::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->back)();
}

static  void method_13608( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->back)();
  else   (((const ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->back)();
}

static  void method_13609( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->data)());
  else   (((::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->data)();
}

static  void method_13610( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->data)());
  else   (((const ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->data)();
}

static  void method_13611( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->push_back)(*(const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)arg[0]);
}

static  void method_13612( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->pop_back)();
}

static  void method_13613( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*,std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > >)((((::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*,std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > >*)arg[0],
    *(const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)arg[1]));
  else   (((::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*,std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > >*)arg[0],
    *(const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)arg[1]);
}

static  void method_13614( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*,std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)arg[2]);
}

static  void method_13615( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*,std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > >)((((::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*,std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > >*)arg[0]));
  else   (((::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*,std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > >*)arg[0]);
}

static  void method_13616( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*,std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > >)((((::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*,std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*,std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > >*)arg[1]));
  else   (((::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*,std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*,std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > >*)arg[1]);
}

static  void method_13617( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->swap)(*(::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)arg[0]);
}

static  void method_13618( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->clear)();
}

static void method_newdel_3145( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x26( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >,std::allocator<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > >")), ::Reflex::BaseOffset< ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >,::std::_Vector_base<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >,std::allocator<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x27( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > >::Generate();
  else ::Reflex::Proxy< ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > >::Generate();
}

//------Dictionary for class vector<edm::Ref<std::vector<reco::MET, std::allocator<reco::MET> >, reco::MET, edm::refhelper::FindUsingAdvance<std::vector<reco::MET, std::allocator<reco::MET> >, reco::MET> >,std::allocator<edm::Ref<std::vector<reco::MET, std::allocator<reco::MET> >, reco::MET, edm::refhelper::FindUsingAdvance<std::vector<reco::MET, std::allocator<reco::MET> >, reco::MET> > > > -------------------------------
void __std__vector_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s__db_datamem(Reflex::Class*);
void __std__vector_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s__datamem_bld(&__std__vector_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s__funcmem_bld(&__std__vector_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s__db_funcmem);
void __std__vector_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >"), typeid(::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >), sizeof(::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2593, ::Reflex::BaseOffset< ::std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >, ::std::_Vector_base<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >,std::allocator<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_4913, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >::_Alloc_value_type"))
  .AddTypedef(type_2593, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >::_Base"))
  .AddTypedef(type_3415, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >::_Tp_alloc_type"))
  .AddTypedef(type_4913, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >::value_type"))
  .AddTypedef(type_13564, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >::pointer"))
  .AddTypedef(type_13566, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >::const_pointer"))
  .AddTypedef(type_13568, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >::reference"))
  .AddTypedef(type_13570, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >::const_reference"))
  .AddTypedef(type_8156, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >::iterator"))
  .AddTypedef(type_8157, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >::const_iterator"))
  .AddTypedef(type_3603, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >::const_reverse_iterator"))
  .AddTypedef(type_3604, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >::reverse_iterator"))
  .AddTypedef(type_3394, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >::size_type"))
  .AddTypedef(type_3290, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >::difference_type"))
  .AddTypedef(type_3415, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_13579, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31645), Reflex::Literal("vector"), constructor_13580, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3394, type_13570, type_31645), Reflex::Literal("vector"), constructor_13581, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32810), Reflex::Literal("vector"), constructor_13582, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_13583, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3145, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x26, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x27, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s__funcmem_bld);
}

//------Delayed data member builder for class vector<edm::Ref<std::vector<reco::MET, std::allocator<reco::MET> >, reco::MET, edm::refhelper::FindUsingAdvance<std::vector<reco::MET, std::allocator<reco::MET> >, reco::MET> >,std::allocator<edm::Ref<std::vector<reco::MET, std::allocator<reco::MET> >, reco::MET, edm::refhelper::FindUsingAdvance<std::vector<reco::MET, std::allocator<reco::MET> >, reco::MET> > > > -------------------
void __std__vector_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<edm::Ref<std::vector<reco::MET, std::allocator<reco::MET> >, reco::MET, edm::refhelper::FindUsingAdvance<std::vector<reco::MET, std::allocator<reco::MET> >, reco::MET> >,std::allocator<edm::Ref<std::vector<reco::MET, std::allocator<reco::MET> >, reco::MET, edm::refhelper::FindUsingAdvance<std::vector<reco::MET, std::allocator<reco::MET> >, reco::MET> > > > -------------------
void __std__vector_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32811, type_32810), Reflex::Literal("operator="), operator_13584, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394, type_13570), Reflex::Literal("assign"), method_13585, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8156), Reflex::Literal("begin"), method_13586, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8157), Reflex::Literal("begin"), method_13587, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8156), Reflex::Literal("end"), method_13588, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8157), Reflex::Literal("end"), method_13589, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("size"), method_13594, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("max_size"), method_13595, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394, type_4913), Reflex::Literal("resize"), method_13596, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("capacity"), method_13597, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("empty"), method_13598, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394), Reflex::Literal("reserve"), method_13599, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13568, type_3394), Reflex::Literal("operator[]"), operator_13600, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13570, type_3394), Reflex::Literal("operator[]"), operator_13601, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13568, type_3394), Reflex::Literal("at"), method_13603, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13570, type_3394), Reflex::Literal("at"), method_13604, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13568), Reflex::Literal("front"), method_13605, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13570), Reflex::Literal("front"), method_13606, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13568), Reflex::Literal("back"), method_13607, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13570), Reflex::Literal("back"), method_13608, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13564), Reflex::Literal("data"), method_13609, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13566), Reflex::Literal("data"), method_13610, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_13570), Reflex::Literal("push_back"), method_13611, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("pop_back"), method_13612, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8156, type_8156, type_13570), Reflex::Literal("insert"), method_13613, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_8156, type_3394, type_13570), Reflex::Literal("insert"), method_13614, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8156, type_8156), Reflex::Literal("erase"), method_13615, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8156, type_8156, type_8156), Reflex::Literal("erase"), method_13616, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_32811), Reflex::Literal("swap"), method_13617, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("clear"), method_13618, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<reco::MET,std::allocator<reco::MET> > -------------------------------
static void constructor_13644( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::MET>();
  else ::new(mem) ::std::vector<reco::MET>();
}

static void constructor_13645( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::MET>(*(const ::std::allocator<reco::MET>*)arg[0]);
  else ::new(mem) ::std::vector<reco::MET>(*(const ::std::allocator<reco::MET>*)arg[0]);
}

static void constructor_13646( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::MET>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<reco::MET>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::MET>(*(::std::size_t*)arg[0],
      *(const ::reco::MET*)arg[1]);
  else ::new(mem) ::std::vector<reco::MET>(*(::std::size_t*)arg[0],
      *(const ::reco::MET*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::MET>(*(::std::size_t*)arg[0],
      *(const ::reco::MET*)arg[1],
      *(const ::std::allocator<reco::MET>*)arg[2]);
  else ::new(mem) ::std::vector<reco::MET>(*(::std::size_t*)arg[0],
      *(const ::reco::MET*)arg[1],
      *(const ::std::allocator<reco::MET>*)arg[2]);
  }
}

static void constructor_13647( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::MET>(*(const ::std::vector<reco::MET>*)arg[0]);
  else ::new(mem) ::std::vector<reco::MET>(*(const ::std::vector<reco::MET>*)arg[0]);
}

static void destructor_13648(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<reco::MET>*)o)->::std::vector<reco::MET>::~vector)();
}
static  void operator_13649( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::MET>*)o)->operator=)(*(const ::std::vector<reco::MET>*)arg[0]);
  else   (((::std::vector<reco::MET>*)o)->operator=)(*(const ::std::vector<reco::MET>*)arg[0]);
}

static  void method_13650( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::MET>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::reco::MET*)arg[1]);
}

static  void method_13651( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::MET*,std::vector<reco::MET> >)((((::std::vector<reco::MET>*)o)->begin)());
  else   (((::std::vector<reco::MET>*)o)->begin)();
}

static  void method_13652( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::MET*,std::vector<reco::MET> >)((((const ::std::vector<reco::MET>*)o)->begin)());
  else   (((const ::std::vector<reco::MET>*)o)->begin)();
}

static  void method_13653( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::MET*,std::vector<reco::MET> >)((((::std::vector<reco::MET>*)o)->end)());
  else   (((::std::vector<reco::MET>*)o)->end)();
}

static  void method_13654( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::MET*,std::vector<reco::MET> >)((((const ::std::vector<reco::MET>*)o)->end)());
  else   (((const ::std::vector<reco::MET>*)o)->end)();
}

static  void method_13659( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::MET>*)o)->size)());
  else   (((const ::std::vector<reco::MET>*)o)->size)();
}

static  void method_13660( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::MET>*)o)->max_size)());
  else   (((const ::std::vector<reco::MET>*)o)->max_size)();
}

static  void method_13661( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<reco::MET>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<reco::MET>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::reco::MET*)arg[1]);
  }
}

static  void method_13662( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::MET>*)o)->capacity)());
  else   (((const ::std::vector<reco::MET>*)o)->capacity)();
}

static  void method_13663( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<reco::MET>*)o)->empty)());
  else   (((const ::std::vector<reco::MET>*)o)->empty)();
}

static  void method_13664( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::MET>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_13665( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::MET>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::MET>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_13666( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::MET>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::MET>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_13668( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::MET>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::MET>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13669( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::MET>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::MET>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13670( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::MET>*)o)->front)();
  else   (((::std::vector<reco::MET>*)o)->front)();
}

static  void method_13671( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::MET>*)o)->front)();
  else   (((const ::std::vector<reco::MET>*)o)->front)();
}

static  void method_13672( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::MET>*)o)->back)();
  else   (((::std::vector<reco::MET>*)o)->back)();
}

static  void method_13673( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::MET>*)o)->back)();
  else   (((const ::std::vector<reco::MET>*)o)->back)();
}

static  void method_13674( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<reco::MET>*)o)->data)());
  else   (((::std::vector<reco::MET>*)o)->data)();
}

static  void method_13675( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<reco::MET>*)o)->data)());
  else   (((const ::std::vector<reco::MET>*)o)->data)();
}

static  void method_13676( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::MET>*)o)->push_back)(*(const ::reco::MET*)arg[0]);
}

static  void method_13677( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::MET>*)o)->pop_back)();
}

static  void method_13678( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::MET*,std::vector<reco::MET> >)((((::std::vector<reco::MET>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::MET*,std::vector<reco::MET> >*)arg[0],
    *(const ::reco::MET*)arg[1]));
  else   (((::std::vector<reco::MET>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::MET*,std::vector<reco::MET> >*)arg[0],
    *(const ::reco::MET*)arg[1]);
}

static  void method_13679( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::MET>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::MET*,std::vector<reco::MET> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::reco::MET*)arg[2]);
}

static  void method_13680( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::MET*,std::vector<reco::MET> >)((((::std::vector<reco::MET>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::MET*,std::vector<reco::MET> >*)arg[0]));
  else   (((::std::vector<reco::MET>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::MET*,std::vector<reco::MET> >*)arg[0]);
}

static  void method_13681( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::MET*,std::vector<reco::MET> >)((((::std::vector<reco::MET>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::MET*,std::vector<reco::MET> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::MET*,std::vector<reco::MET> >*)arg[1]));
  else   (((::std::vector<reco::MET>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::MET*,std::vector<reco::MET> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::MET*,std::vector<reco::MET> >*)arg[1]);
}

static  void method_13682( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::MET>*)o)->swap)(*(::std::vector<reco::MET>*)arg[0]);
}

static  void method_13683( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::MET>*)o)->clear)();
}

static void method_newdel_3146( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<reco::MET> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<reco::MET> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<reco::MET> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<reco::MET> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<reco::MET> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x29( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::MET,std::allocator<reco::MET> >")), ::Reflex::BaseOffset< ::std::vector<reco::MET>,::std::_Vector_base<reco::MET,std::allocator<reco::MET> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x30( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<reco::MET> >::Generate();
  else ::Reflex::Proxy< ::std::vector<reco::MET> >::Generate();
}

//------Dictionary for class vector<reco::MET,std::allocator<reco::MET> > -------------------------------
void __std__vector_reco__MET__db_datamem(Reflex::Class*);
void __std__vector_reco__MET__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_reco__MET__datamem_bld(&__std__vector_reco__MET__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_reco__MET__funcmem_bld(&__std__vector_reco__MET__db_funcmem);
void __std__vector_reco__MET__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<reco::MET>"), typeid(::std::vector<reco::MET>), sizeof(::std::vector<reco::MET>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2618, ::Reflex::BaseOffset< ::std::vector<reco::MET>, ::std::_Vector_base<reco::MET,std::allocator<reco::MET> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_7952, Reflex::Literal("std::vector<reco::MET>::_Alloc_value_type"))
  .AddTypedef(type_2618, Reflex::Literal("std::vector<reco::MET>::_Base"))
  .AddTypedef(type_3416, Reflex::Literal("std::vector<reco::MET>::_Tp_alloc_type"))
  .AddTypedef(type_7952, Reflex::Literal("std::vector<reco::MET>::value_type"))
  .AddTypedef(type_13629, Reflex::Literal("std::vector<reco::MET>::pointer"))
  .AddTypedef(type_13631, Reflex::Literal("std::vector<reco::MET>::const_pointer"))
  .AddTypedef(type_13633, Reflex::Literal("std::vector<reco::MET>::reference"))
  .AddTypedef(type_13635, Reflex::Literal("std::vector<reco::MET>::const_reference"))
  .AddTypedef(type_8202, Reflex::Literal("std::vector<reco::MET>::iterator"))
  .AddTypedef(type_8203, Reflex::Literal("std::vector<reco::MET>::const_iterator"))
  .AddTypedef(type_3655, Reflex::Literal("std::vector<reco::MET>::const_reverse_iterator"))
  .AddTypedef(type_3656, Reflex::Literal("std::vector<reco::MET>::reverse_iterator"))
  .AddTypedef(type_3394, Reflex::Literal("std::vector<reco::MET>::size_type"))
  .AddTypedef(type_3290, Reflex::Literal("std::vector<reco::MET>::difference_type"))
  .AddTypedef(type_3416, Reflex::Literal("std::vector<reco::MET>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_13644, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31945), Reflex::Literal("vector"), constructor_13645, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3394, type_13635, type_31945), Reflex::Literal("vector"), constructor_13646, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23204), Reflex::Literal("vector"), constructor_13647, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_13648, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3146, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x29, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x30, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_reco__MET__funcmem_bld);
}

//------Delayed data member builder for class vector<reco::MET,std::allocator<reco::MET> > -------------------
void __std__vector_reco__MET__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<reco::MET,std::allocator<reco::MET> > -------------------
void __std__vector_reco__MET__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32813, type_23204), Reflex::Literal("operator="), operator_13649, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394, type_13635), Reflex::Literal("assign"), method_13650, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8202), Reflex::Literal("begin"), method_13651, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8203), Reflex::Literal("begin"), method_13652, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8202), Reflex::Literal("end"), method_13653, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8203), Reflex::Literal("end"), method_13654, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("size"), method_13659, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("max_size"), method_13660, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394, type_7952), Reflex::Literal("resize"), method_13661, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("capacity"), method_13662, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("empty"), method_13663, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394), Reflex::Literal("reserve"), method_13664, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13633, type_3394), Reflex::Literal("operator[]"), operator_13665, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13635, type_3394), Reflex::Literal("operator[]"), operator_13666, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13633, type_3394), Reflex::Literal("at"), method_13668, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13635, type_3394), Reflex::Literal("at"), method_13669, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13633), Reflex::Literal("front"), method_13670, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13635), Reflex::Literal("front"), method_13671, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13633), Reflex::Literal("back"), method_13672, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13635), Reflex::Literal("back"), method_13673, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13629), Reflex::Literal("data"), method_13674, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13631), Reflex::Literal("data"), method_13675, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_13635), Reflex::Literal("push_back"), method_13676, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("pop_back"), method_13677, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8202, type_8202, type_13635), Reflex::Literal("insert"), method_13678, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_8202, type_3394, type_13635), Reflex::Literal("insert"), method_13679, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8202, type_8202), Reflex::Literal("erase"), method_13680, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8202, type_8202, type_8202), Reflex::Literal("erase"), method_13681, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_32813), Reflex::Literal("swap"), method_13682, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("clear"), method_13683, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class CaloMET -------------------------------
static  void operator_28210( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::CaloMET*)o)->operator=)(*(const ::reco::CaloMET*)arg[0]);
  else   (((::reco::CaloMET*)o)->operator=)(*(const ::reco::CaloMET*)arg[0]);
}

static void constructor_28211( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::CaloMET(*(const ::reco::CaloMET*)arg[0]);
  else ::new(mem) ::reco::CaloMET(*(const ::reco::CaloMET*)arg[0]);
}

static void constructor_28212( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::CaloMET();
  else ::new(mem) ::reco::CaloMET();
}

static void constructor_28213( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::CaloMET(*(::SpecificCaloMETData*)arg[0],
      *(double*)arg[1],
      *(const ::math::XYZTLorentzVector*)arg[2],
      *(const ::math::XYZPoint*)arg[3]);
  else ::new(mem) ::reco::CaloMET(*(::SpecificCaloMETData*)arg[0],
      *(double*)arg[1],
      *(const ::math::XYZTLorentzVector*)arg[2],
      *(const ::math::XYZPoint*)arg[3]);
}

static void constructor_28214( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::CaloMET(*(::SpecificCaloMETData*)arg[0],
      *(double*)arg[1],
      *(::std::vector<CorrMETData>*)arg[2],
      *(const ::math::XYZTLorentzVector*)arg[3],
      *(const ::math::XYZPoint*)arg[4]);
  else ::new(mem) ::reco::CaloMET(*(::SpecificCaloMETData*)arg[0],
      *(double*)arg[1],
      *(::std::vector<CorrMETData>*)arg[2],
      *(const ::math::XYZTLorentzVector*)arg[3],
      *(const ::math::XYZPoint*)arg[4]);
}

static void destructor_28215(void*, void * o, const std::vector<void*>&, void *) {
(((::reco::CaloMET*)o)->::reco::CaloMET::~CaloMET)();
}
static  void method_28216( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::CaloMET*)o)->maxEtInEmTowers)());
  else   (((const ::reco::CaloMET*)o)->maxEtInEmTowers)();
}

static  void method_28217( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::CaloMET*)o)->maxEtInHadTowers)());
  else   (((const ::reco::CaloMET*)o)->maxEtInHadTowers)();
}

static  void method_28218( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::CaloMET*)o)->etFractionHadronic)());
  else   (((const ::reco::CaloMET*)o)->etFractionHadronic)();
}

static  void method_28219( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::CaloMET*)o)->emEtFraction)());
  else   (((const ::reco::CaloMET*)o)->emEtFraction)();
}

static  void method_28220( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::CaloMET*)o)->hadEtInHB)());
  else   (((const ::reco::CaloMET*)o)->hadEtInHB)();
}

static  void method_28221( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::CaloMET*)o)->hadEtInHO)());
  else   (((const ::reco::CaloMET*)o)->hadEtInHO)();
}

static  void method_28222( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::CaloMET*)o)->hadEtInHE)());
  else   (((const ::reco::CaloMET*)o)->hadEtInHE)();
}

static  void method_28223( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::CaloMET*)o)->hadEtInHF)());
  else   (((const ::reco::CaloMET*)o)->hadEtInHF)();
}

static  void method_28224( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::CaloMET*)o)->emEtInEB)());
  else   (((const ::reco::CaloMET*)o)->emEtInEB)();
}

static  void method_28225( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::CaloMET*)o)->emEtInEE)());
  else   (((const ::reco::CaloMET*)o)->emEtInEE)();
}

static  void method_28226( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::CaloMET*)o)->emEtInHF)());
  else   (((const ::reco::CaloMET*)o)->emEtInHF)();
}

static  void method_28227( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::CaloMET*)o)->metSignificance)());
  else   (((const ::reco::CaloMET*)o)->metSignificance)();
}

static  void method_28228( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::CaloMET*)o)->CaloSETInpHF)());
  else   (((const ::reco::CaloMET*)o)->CaloSETInpHF)();
}

static  void method_28229( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::CaloMET*)o)->CaloSETInmHF)());
  else   (((const ::reco::CaloMET*)o)->CaloSETInmHF)();
}

static  void method_28230( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::CaloMET*)o)->CaloMETInpHF)());
  else   (((const ::reco::CaloMET*)o)->CaloMETInpHF)();
}

static  void method_28231( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::CaloMET*)o)->CaloMETInmHF)());
  else   (((const ::reco::CaloMET*)o)->CaloMETInmHF)();
}

static  void method_28232( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::CaloMET*)o)->CaloMETPhiInpHF)());
  else   (((const ::reco::CaloMET*)o)->CaloMETPhiInpHF)();
}

static  void method_28233( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::CaloMET*)o)->CaloMETPhiInmHF)());
  else   (((const ::reco::CaloMET*)o)->CaloMETPhiInmHF)();
}

static  void method_28234( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::CaloMET*)o)->SetMetSignificance)(*(double*)arg[0]);
}

static  void method_28235( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (SpecificCaloMETData)((((const ::reco::CaloMET*)o)->getSpecific)());
  else   (((const ::reco::CaloMET*)o)->getSpecific)();
}

static void method_newdel_8011( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::reco::CaloMET >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::reco::CaloMET >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::reco::CaloMET >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::reco::CaloMET >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::reco::CaloMET >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x32( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::MET")), ::Reflex::BaseOffset< ::reco::CaloMET,::reco::MET >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::RecoCandidate")), ::Reflex::BaseOffset< ::reco::CaloMET,::reco::RecoCandidate >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::reco::CaloMET,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::reco::CaloMET,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class CaloMET -------------------------------
void __reco__CaloMET_db_datamem(Reflex::Class*);
void __reco__CaloMET_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __reco__CaloMET_datamem_bld(&__reco__CaloMET_db_datamem);
Reflex::GenreflexMemberBuilder __reco__CaloMET_funcmem_bld(&__reco__CaloMET_db_funcmem);
void __reco__CaloMET_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("reco::CaloMET"), typeid(::reco::CaloMET), sizeof(::reco::CaloMET), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddBase(type_7952, ::Reflex::BaseOffset< ::reco::CaloMET, ::reco::MET >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13763, type_13765), Reflex::Literal("operator="), operator_28210, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13765), Reflex::Literal("CaloMET"), constructor_28211, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("CaloMET"), constructor_28212, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_930, type_107, type_39102, type_39103), Reflex::Literal("CaloMET"), constructor_28213, 0, "calo_data_;sumet_;fP4;fVertex", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_930, type_107, type_3143, type_39102, type_39103), Reflex::Literal("CaloMET"), constructor_28214, 0, "calo_data_;sumet_;corr_;fP4;fVertex", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~CaloMET"), destructor_28215, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_8011, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x32, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__reco__CaloMET_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__reco__CaloMET_funcmem_bld);
}

//------Delayed data member builder for class CaloMET -------------------
void __reco__CaloMET_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_930, Reflex::Literal("calo_data"), OffsetOf(__shadow__::__reco__CaloMET, calo_data), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class CaloMET -------------------
void __reco__CaloMET_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("maxEtInEmTowers"), method_28216, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("maxEtInHadTowers"), method_28217, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("etFractionHadronic"), method_28218, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("emEtFraction"), method_28219, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("hadEtInHB"), method_28220, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("hadEtInHO"), method_28221, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("hadEtInHE"), method_28222, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("hadEtInHF"), method_28223, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("emEtInEB"), method_28224, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("emEtInEE"), method_28225, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("emEtInHF"), method_28226, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("metSignificance"), method_28227, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("CaloSETInpHF"), method_28228, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("CaloSETInmHF"), method_28229, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("CaloMETInpHF"), method_28230, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("CaloMETInmHF"), method_28231, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("CaloMETPhiInpHF"), method_28232, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("CaloMETPhiInmHF"), method_28233, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_107), Reflex::Literal("SetMetSignificance"), method_28234, 0, "metsig", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_930), Reflex::Literal("getSpecific"), method_28235, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Ref<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >, reco::CaloMET> > -------------------------------
static  void operator_22085( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->operator=)(*(const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)arg[0]);
  else   (((::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->operator=)(*(const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)arg[0]);
}

static void constructor_22086( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >(*(const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >(*(const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)arg[0]);
}

static void constructor_22087( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >();
  else ::new(mem) ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >();
}

static void constructor_22088( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >(*(const ::edm::Handle<std::vector<reco::CaloMET> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >(*(const ::edm::Handle<std::vector<reco::CaloMET> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >(*(const ::edm::Handle<std::vector<reco::CaloMET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >(*(const ::edm::Handle<std::vector<reco::CaloMET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_22089( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >(*(const ::edm::OrphanHandle<std::vector<reco::CaloMET> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >(*(const ::edm::OrphanHandle<std::vector<reco::CaloMET> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >(*(const ::edm::OrphanHandle<std::vector<reco::CaloMET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >(*(const ::edm::OrphanHandle<std::vector<reco::CaloMET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_22090( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >(*(const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >(*(const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >(*(const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >(*(const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_22091( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >((const ::std::vector<reco::CaloMET>*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >((const ::std::vector<reco::CaloMET>*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >((const ::std::vector<reco::CaloMET>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >((const ::std::vector<reco::CaloMET>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_22092( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >(*(const ::edm::TestHandle<std::vector<reco::CaloMET> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >(*(const ::edm::TestHandle<std::vector<reco::CaloMET> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >(*(const ::edm::TestHandle<std::vector<reco::CaloMET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >(*(const ::edm::TestHandle<std::vector<reco::CaloMET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_22093( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_22094( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >(*(const ::edm::ProductID*)arg[0],
      (const ::reco::CaloMET*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<reco::CaloMET>*)arg[3]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >(*(const ::edm::ProductID*)arg[0],
      (const ::reco::CaloMET*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<reco::CaloMET>*)arg[3]);
}

static void constructor_22095( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_22096( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >(*(const ::edm::RefProd<std::vector<reco::CaloMET> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >(*(const ::edm::RefProd<std::vector<reco::CaloMET> >*)arg[0],
      *(unsigned int*)arg[1]);
}

static void destructor_22097(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >::~Ref)();
}
static  void operator_22098( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->operator*)();
  else   (((const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->operator*)();
}

static  void operator_22099( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->operator->)());
  else   (((const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->operator->)();
}

static  void method_22100( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->get)());
  else   (((const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->get)();
}

static  void method_22101( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->isNull)());
  else   (((const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->isNull)();
}

static  void method_22102( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->isNonnull)());
  else   (((const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->isNonnull)();
}

static  void operator_22103( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->operator!)());
  else   (((const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->operator!)();
}

static  void method_22104( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->id)());
  else   (((const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->id)();
}

static  void method_22105( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->productGetter)());
  else   (((const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->productGetter)();
}

static  void method_22106( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->product)());
  else   (((const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->product)();
}

static  void method_22107( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->key)());
  else   (((const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->key)();
}

static  void method_22108( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->index)());
  else   (((const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->index)();
}

static  void method_22109( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->hasProductCache)());
  else   (((const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->hasProductCache)();
}

static  void method_22110( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->isAvailable)());
  else   (((const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->isAvailable)();
}

static  void method_22111( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->isTransient)());
  else   (((const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->isTransient)();
}

static  void method_22112( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->refCore)();
  else   (((const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->refCore)();
}

static  void method_22113( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->Class_Version)());
  else   (((::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->Class_Version)();
}

static void constructor_22114( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_4914( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ref<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >, reco::CaloMET> > -------------------------------
void __edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s__db_datamem(Reflex::Class*);
void __edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s__datamem_bld(&__edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s__funcmem_bld(&__edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s__db_funcmem);
void __edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >"), typeid(::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >), sizeof(::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >::Class_Version())
  .AddTypedef(type_8011, Reflex::Literal("edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >::T"))
  .AddTypedef(type_20091, Reflex::Literal("edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >::F"))
  .AddTypedef(type_20077, Reflex::Literal("edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >::VF"))
  .AddTypedef(type_20076, Reflex::Literal("edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >::VBF"))
  .AddTypedef(type_3148, Reflex::Literal("edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >::product_type"))
  .AddTypedef(type_8011, Reflex::Literal("edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >::value_type"))
  .AddTypedef(type_8011c, Reflex::Literal("edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >::element_type"))
  .AddTypedef(type_20091, Reflex::Literal("edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >::finder_type"))
  .AddTypedef(type_373, Reflex::Literal("edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >::argument_type"))
  .AddTypedef(type_373, Reflex::Literal("edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >::key_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13698, type_13700), Reflex::Literal("operator="), operator_22085, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13700), Reflex::Literal("Ref"), constructor_22086, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ref"), constructor_22087, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34367, type_373, type_1647), Reflex::Literal("Ref"), constructor_22088, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34368, type_373, type_1647), Reflex::Literal("Ref"), constructor_22089, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33844, type_373, type_1647), Reflex::Literal("Ref"), constructor_22090, 0, "refvector;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33845, type_373, type_1647), Reflex::Literal("Ref"), constructor_22091, 0, "iProduct;iItemKey;iSetNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34369, type_373, type_1647), Reflex::Literal("Ref"), constructor_22092, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19738, type_373, type_19828), Reflex::Literal("Ref"), constructor_22093, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19738, type_13761, type_373, type_33845), Reflex::Literal("Ref"), constructor_22094, 0, "iProductID;;iItemKey;iProduct", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19738), Reflex::Literal("Ref"), constructor_22095, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34366, type_373), Reflex::Literal("Ref"), constructor_22096, 0, "refProd;itemKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ref"), destructor_22097, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21396, type_10352), Reflex::Literal("Ref"), constructor_22114, 0, "iRefCore;iKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4914, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s__funcmem_bld);
}

//------Delayed data member builder for class Ref<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >, reco::CaloMET> > -------------------
void __edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4931, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_, product_), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class Ref<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >, reco::CaloMET> > -------------------
void __edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13765), Reflex::Literal("operator*"), operator_22098, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13761), Reflex::Literal("operator->"), operator_22099, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13761), Reflex::Literal("get"), method_22100, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isNull"), method_22101, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isNonnull"), method_22102, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("operator!"), operator_22103, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4866), Reflex::Literal("id"), method_22104, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19828), Reflex::Literal("productGetter"), method_22105, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33845), Reflex::Literal("product"), method_22106, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_373), Reflex::Literal("key"), method_22107, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_373), Reflex::Literal("index"), method_22108, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("hasProductCache"), method_22109, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isAvailable"), method_22110, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isTransient"), method_22111, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21396), Reflex::Literal("refCore"), method_22112, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_192), Reflex::Literal("Class_Version"), method_22113, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class vector<edm::Ref<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >, reco::CaloMET, edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >, reco::CaloMET> >,std::allocator<edm::Ref<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >, reco::CaloMET, edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >, reco::CaloMET> > > > -------------------------------
static void constructor_13709( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >();
  else ::new(mem) ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >();
}

static void constructor_13710( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >(*(const ::std::allocator<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)arg[0]);
  else ::new(mem) ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >(*(const ::std::allocator<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)arg[0]);
}

static void constructor_13711( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >(*(::std::size_t*)arg[0],
      *(const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)arg[1]);
  else ::new(mem) ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >(*(::std::size_t*)arg[0],
      *(const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >(*(::std::size_t*)arg[0],
      *(const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)arg[1],
      *(const ::std::allocator<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)arg[2]);
  else ::new(mem) ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >(*(::std::size_t*)arg[0],
      *(const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)arg[1],
      *(const ::std::allocator<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)arg[2]);
  }
}

static void constructor_13712( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >(*(const ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)arg[0]);
  else ::new(mem) ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >(*(const ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)arg[0]);
}

static void destructor_13713(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >::~vector)();
}
static  void operator_13714( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->operator=)(*(const ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)arg[0]);
  else   (((::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->operator=)(*(const ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)arg[0]);
}

static  void method_13715( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)arg[1]);
}

static  void method_13716( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*,std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > >)((((::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->begin)());
  else   (((::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->begin)();
}

static  void method_13717( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*,std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > >)((((const ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->begin)());
  else   (((const ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->begin)();
}

static  void method_13718( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*,std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > >)((((::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->end)());
  else   (((::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->end)();
}

static  void method_13719( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*,std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > >)((((const ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->end)());
  else   (((const ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->end)();
}

static  void method_13724( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->size)());
  else   (((const ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->size)();
}

static  void method_13725( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->max_size)());
  else   (((const ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->max_size)();
}

static  void method_13726( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)arg[1]);
  }
}

static  void method_13727( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->capacity)());
  else   (((const ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->capacity)();
}

static  void method_13728( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->empty)());
  else   (((const ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->empty)();
}

static  void method_13729( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_13730( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_13731( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_13733( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13734( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13735( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->front)();
  else   (((::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->front)();
}

static  void method_13736( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->front)();
  else   (((const ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->front)();
}

static  void method_13737( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->back)();
  else   (((::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->back)();
}

static  void method_13738( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->back)();
  else   (((const ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->back)();
}

static  void method_13739( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->data)());
  else   (((::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->data)();
}

static  void method_13740( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->data)());
  else   (((const ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->data)();
}

static  void method_13741( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->push_back)(*(const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)arg[0]);
}

static  void method_13742( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->pop_back)();
}

static  void method_13743( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*,std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > >)((((::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*,std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > >*)arg[0],
    *(const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)arg[1]));
  else   (((::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*,std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > >*)arg[0],
    *(const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)arg[1]);
}

static  void method_13744( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*,std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)arg[2]);
}

static  void method_13745( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*,std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > >)((((::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*,std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > >*)arg[0]));
  else   (((::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*,std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > >*)arg[0]);
}

static  void method_13746( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*,std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > >)((((::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*,std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*,std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > >*)arg[1]));
  else   (((::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*,std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*,std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > >*)arg[1]);
}

static  void method_13747( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->swap)(*(::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)arg[0]);
}

static  void method_13748( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->clear)();
}

static void method_newdel_3147( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x35( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >,std::allocator<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > >")), ::Reflex::BaseOffset< ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >,::std::_Vector_base<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >,std::allocator<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x36( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > >::Generate();
  else ::Reflex::Proxy< ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > >::Generate();
}

//------Dictionary for class vector<edm::Ref<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >, reco::CaloMET, edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >, reco::CaloMET> >,std::allocator<edm::Ref<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >, reco::CaloMET, edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >, reco::CaloMET> > > > -------------------------------
void __std__vector_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s__db_datamem(Reflex::Class*);
void __std__vector_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s__datamem_bld(&__std__vector_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s__funcmem_bld(&__std__vector_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s__db_funcmem);
void __std__vector_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >"), typeid(::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >), sizeof(::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2594, ::Reflex::BaseOffset< ::std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >, ::std::_Vector_base<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >,std::allocator<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_4914, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >::_Alloc_value_type"))
  .AddTypedef(type_2594, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >::_Base"))
  .AddTypedef(type_3417, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >::_Tp_alloc_type"))
  .AddTypedef(type_4914, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >::value_type"))
  .AddTypedef(type_13694, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >::pointer"))
  .AddTypedef(type_13696, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >::const_pointer"))
  .AddTypedef(type_13698, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >::reference"))
  .AddTypedef(type_13700, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >::const_reference"))
  .AddTypedef(type_8158, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >::iterator"))
  .AddTypedef(type_8159, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >::const_iterator"))
  .AddTypedef(type_3605, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >::const_reverse_iterator"))
  .AddTypedef(type_3606, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >::reverse_iterator"))
  .AddTypedef(type_3394, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >::size_type"))
  .AddTypedef(type_3290, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >::difference_type"))
  .AddTypedef(type_3417, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_13709, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31657), Reflex::Literal("vector"), constructor_13710, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3394, type_13700, type_31657), Reflex::Literal("vector"), constructor_13711, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32815), Reflex::Literal("vector"), constructor_13712, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_13713, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3147, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x35, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x36, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s__funcmem_bld);
}

//------Delayed data member builder for class vector<edm::Ref<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >, reco::CaloMET, edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >, reco::CaloMET> >,std::allocator<edm::Ref<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >, reco::CaloMET, edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >, reco::CaloMET> > > > -------------------
void __std__vector_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<edm::Ref<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >, reco::CaloMET, edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >, reco::CaloMET> >,std::allocator<edm::Ref<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >, reco::CaloMET, edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >, reco::CaloMET> > > > -------------------
void __std__vector_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32816, type_32815), Reflex::Literal("operator="), operator_13714, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394, type_13700), Reflex::Literal("assign"), method_13715, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8158), Reflex::Literal("begin"), method_13716, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8159), Reflex::Literal("begin"), method_13717, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8158), Reflex::Literal("end"), method_13718, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8159), Reflex::Literal("end"), method_13719, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("size"), method_13724, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("max_size"), method_13725, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394, type_4914), Reflex::Literal("resize"), method_13726, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("capacity"), method_13727, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("empty"), method_13728, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394), Reflex::Literal("reserve"), method_13729, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13698, type_3394), Reflex::Literal("operator[]"), operator_13730, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13700, type_3394), Reflex::Literal("operator[]"), operator_13731, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13698, type_3394), Reflex::Literal("at"), method_13733, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13700, type_3394), Reflex::Literal("at"), method_13734, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13698), Reflex::Literal("front"), method_13735, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13700), Reflex::Literal("front"), method_13736, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13698), Reflex::Literal("back"), method_13737, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13700), Reflex::Literal("back"), method_13738, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13694), Reflex::Literal("data"), method_13739, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13696), Reflex::Literal("data"), method_13740, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_13700), Reflex::Literal("push_back"), method_13741, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("pop_back"), method_13742, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8158, type_8158, type_13700), Reflex::Literal("insert"), method_13743, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_8158, type_3394, type_13700), Reflex::Literal("insert"), method_13744, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8158, type_8158), Reflex::Literal("erase"), method_13745, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8158, type_8158, type_8158), Reflex::Literal("erase"), method_13746, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_32816), Reflex::Literal("swap"), method_13747, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("clear"), method_13748, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<reco::CaloMET,std::allocator<reco::CaloMET> > -------------------------------
static void constructor_13774( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::CaloMET>();
  else ::new(mem) ::std::vector<reco::CaloMET>();
}

static void constructor_13775( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::CaloMET>(*(const ::std::allocator<reco::CaloMET>*)arg[0]);
  else ::new(mem) ::std::vector<reco::CaloMET>(*(const ::std::allocator<reco::CaloMET>*)arg[0]);
}

static void constructor_13776( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::CaloMET>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<reco::CaloMET>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::CaloMET>(*(::std::size_t*)arg[0],
      *(const ::reco::CaloMET*)arg[1]);
  else ::new(mem) ::std::vector<reco::CaloMET>(*(::std::size_t*)arg[0],
      *(const ::reco::CaloMET*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::CaloMET>(*(::std::size_t*)arg[0],
      *(const ::reco::CaloMET*)arg[1],
      *(const ::std::allocator<reco::CaloMET>*)arg[2]);
  else ::new(mem) ::std::vector<reco::CaloMET>(*(::std::size_t*)arg[0],
      *(const ::reco::CaloMET*)arg[1],
      *(const ::std::allocator<reco::CaloMET>*)arg[2]);
  }
}

static void constructor_13777( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::CaloMET>(*(const ::std::vector<reco::CaloMET>*)arg[0]);
  else ::new(mem) ::std::vector<reco::CaloMET>(*(const ::std::vector<reco::CaloMET>*)arg[0]);
}

static void destructor_13778(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<reco::CaloMET>*)o)->::std::vector<reco::CaloMET>::~vector)();
}
static  void operator_13779( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::CaloMET>*)o)->operator=)(*(const ::std::vector<reco::CaloMET>*)arg[0]);
  else   (((::std::vector<reco::CaloMET>*)o)->operator=)(*(const ::std::vector<reco::CaloMET>*)arg[0]);
}

static  void method_13780( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::CaloMET>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::reco::CaloMET*)arg[1]);
}

static  void method_13781( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::CaloMET*,std::vector<reco::CaloMET> >)((((::std::vector<reco::CaloMET>*)o)->begin)());
  else   (((::std::vector<reco::CaloMET>*)o)->begin)();
}

static  void method_13782( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::CaloMET*,std::vector<reco::CaloMET> >)((((const ::std::vector<reco::CaloMET>*)o)->begin)());
  else   (((const ::std::vector<reco::CaloMET>*)o)->begin)();
}

static  void method_13783( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::CaloMET*,std::vector<reco::CaloMET> >)((((::std::vector<reco::CaloMET>*)o)->end)());
  else   (((::std::vector<reco::CaloMET>*)o)->end)();
}

static  void method_13784( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::CaloMET*,std::vector<reco::CaloMET> >)((((const ::std::vector<reco::CaloMET>*)o)->end)());
  else   (((const ::std::vector<reco::CaloMET>*)o)->end)();
}

static  void method_13789( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::CaloMET>*)o)->size)());
  else   (((const ::std::vector<reco::CaloMET>*)o)->size)();
}

static  void method_13790( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::CaloMET>*)o)->max_size)());
  else   (((const ::std::vector<reco::CaloMET>*)o)->max_size)();
}

static  void method_13791( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<reco::CaloMET>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<reco::CaloMET>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::reco::CaloMET*)arg[1]);
  }
}

static  void method_13792( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::CaloMET>*)o)->capacity)());
  else   (((const ::std::vector<reco::CaloMET>*)o)->capacity)();
}

static  void method_13793( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<reco::CaloMET>*)o)->empty)());
  else   (((const ::std::vector<reco::CaloMET>*)o)->empty)();
}

static  void method_13794( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::CaloMET>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_13795( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::CaloMET>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::CaloMET>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_13796( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::CaloMET>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::CaloMET>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_13798( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::CaloMET>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::CaloMET>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13799( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::CaloMET>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::CaloMET>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13800( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::CaloMET>*)o)->front)();
  else   (((::std::vector<reco::CaloMET>*)o)->front)();
}

static  void method_13801( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::CaloMET>*)o)->front)();
  else   (((const ::std::vector<reco::CaloMET>*)o)->front)();
}

static  void method_13802( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::CaloMET>*)o)->back)();
  else   (((::std::vector<reco::CaloMET>*)o)->back)();
}

static  void method_13803( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::CaloMET>*)o)->back)();
  else   (((const ::std::vector<reco::CaloMET>*)o)->back)();
}

static  void method_13804( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<reco::CaloMET>*)o)->data)());
  else   (((::std::vector<reco::CaloMET>*)o)->data)();
}

static  void method_13805( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<reco::CaloMET>*)o)->data)());
  else   (((const ::std::vector<reco::CaloMET>*)o)->data)();
}

static  void method_13806( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::CaloMET>*)o)->push_back)(*(const ::reco::CaloMET*)arg[0]);
}

static  void method_13807( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::CaloMET>*)o)->pop_back)();
}

static  void method_13808( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::CaloMET*,std::vector<reco::CaloMET> >)((((::std::vector<reco::CaloMET>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::CaloMET*,std::vector<reco::CaloMET> >*)arg[0],
    *(const ::reco::CaloMET*)arg[1]));
  else   (((::std::vector<reco::CaloMET>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::CaloMET*,std::vector<reco::CaloMET> >*)arg[0],
    *(const ::reco::CaloMET*)arg[1]);
}

static  void method_13809( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::CaloMET>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::CaloMET*,std::vector<reco::CaloMET> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::reco::CaloMET*)arg[2]);
}

static  void method_13810( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::CaloMET*,std::vector<reco::CaloMET> >)((((::std::vector<reco::CaloMET>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::CaloMET*,std::vector<reco::CaloMET> >*)arg[0]));
  else   (((::std::vector<reco::CaloMET>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::CaloMET*,std::vector<reco::CaloMET> >*)arg[0]);
}

static  void method_13811( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::CaloMET*,std::vector<reco::CaloMET> >)((((::std::vector<reco::CaloMET>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::CaloMET*,std::vector<reco::CaloMET> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::CaloMET*,std::vector<reco::CaloMET> >*)arg[1]));
  else   (((::std::vector<reco::CaloMET>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::CaloMET*,std::vector<reco::CaloMET> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::CaloMET*,std::vector<reco::CaloMET> >*)arg[1]);
}

static  void method_13812( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::CaloMET>*)o)->swap)(*(::std::vector<reco::CaloMET>*)arg[0]);
}

static  void method_13813( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::CaloMET>*)o)->clear)();
}

static void method_newdel_3148( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<reco::CaloMET> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<reco::CaloMET> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<reco::CaloMET> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<reco::CaloMET> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<reco::CaloMET> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x38( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::CaloMET,std::allocator<reco::CaloMET> >")), ::Reflex::BaseOffset< ::std::vector<reco::CaloMET>,::std::_Vector_base<reco::CaloMET,std::allocator<reco::CaloMET> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x39( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<reco::CaloMET> >::Generate();
  else ::Reflex::Proxy< ::std::vector<reco::CaloMET> >::Generate();
}

//------Dictionary for class vector<reco::CaloMET,std::allocator<reco::CaloMET> > -------------------------------
void __std__vector_reco__CaloMET__db_datamem(Reflex::Class*);
void __std__vector_reco__CaloMET__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_reco__CaloMET__datamem_bld(&__std__vector_reco__CaloMET__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_reco__CaloMET__funcmem_bld(&__std__vector_reco__CaloMET__db_funcmem);
void __std__vector_reco__CaloMET__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<reco::CaloMET>"), typeid(::std::vector<reco::CaloMET>), sizeof(::std::vector<reco::CaloMET>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2617, ::Reflex::BaseOffset< ::std::vector<reco::CaloMET>, ::std::_Vector_base<reco::CaloMET,std::allocator<reco::CaloMET> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_8011, Reflex::Literal("std::vector<reco::CaloMET>::_Alloc_value_type"))
  .AddTypedef(type_2617, Reflex::Literal("std::vector<reco::CaloMET>::_Base"))
  .AddTypedef(type_3418, Reflex::Literal("std::vector<reco::CaloMET>::_Tp_alloc_type"))
  .AddTypedef(type_8011, Reflex::Literal("std::vector<reco::CaloMET>::value_type"))
  .AddTypedef(type_13759, Reflex::Literal("std::vector<reco::CaloMET>::pointer"))
  .AddTypedef(type_13761, Reflex::Literal("std::vector<reco::CaloMET>::const_pointer"))
  .AddTypedef(type_13763, Reflex::Literal("std::vector<reco::CaloMET>::reference"))
  .AddTypedef(type_13765, Reflex::Literal("std::vector<reco::CaloMET>::const_reference"))
  .AddTypedef(type_8200, Reflex::Literal("std::vector<reco::CaloMET>::iterator"))
  .AddTypedef(type_8201, Reflex::Literal("std::vector<reco::CaloMET>::const_iterator"))
  .AddTypedef(type_3653, Reflex::Literal("std::vector<reco::CaloMET>::const_reverse_iterator"))
  .AddTypedef(type_3654, Reflex::Literal("std::vector<reco::CaloMET>::reverse_iterator"))
  .AddTypedef(type_3394, Reflex::Literal("std::vector<reco::CaloMET>::size_type"))
  .AddTypedef(type_3290, Reflex::Literal("std::vector<reco::CaloMET>::difference_type"))
  .AddTypedef(type_3418, Reflex::Literal("std::vector<reco::CaloMET>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_13774, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31933), Reflex::Literal("vector"), constructor_13775, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3394, type_13765, type_31933), Reflex::Literal("vector"), constructor_13776, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23226), Reflex::Literal("vector"), constructor_13777, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_13778, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3148, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x38, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x39, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_reco__CaloMET__funcmem_bld);
}

//------Delayed data member builder for class vector<reco::CaloMET,std::allocator<reco::CaloMET> > -------------------
void __std__vector_reco__CaloMET__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<reco::CaloMET,std::allocator<reco::CaloMET> > -------------------
void __std__vector_reco__CaloMET__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32818, type_23226), Reflex::Literal("operator="), operator_13779, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394, type_13765), Reflex::Literal("assign"), method_13780, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8200), Reflex::Literal("begin"), method_13781, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8201), Reflex::Literal("begin"), method_13782, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8200), Reflex::Literal("end"), method_13783, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8201), Reflex::Literal("end"), method_13784, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("size"), method_13789, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("max_size"), method_13790, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394, type_8011), Reflex::Literal("resize"), method_13791, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("capacity"), method_13792, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("empty"), method_13793, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394), Reflex::Literal("reserve"), method_13794, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13763, type_3394), Reflex::Literal("operator[]"), operator_13795, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13765, type_3394), Reflex::Literal("operator[]"), operator_13796, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13763, type_3394), Reflex::Literal("at"), method_13798, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13765, type_3394), Reflex::Literal("at"), method_13799, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13763), Reflex::Literal("front"), method_13800, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13765), Reflex::Literal("front"), method_13801, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13763), Reflex::Literal("back"), method_13802, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13765), Reflex::Literal("back"), method_13803, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13759), Reflex::Literal("data"), method_13804, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13761), Reflex::Literal("data"), method_13805, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_13765), Reflex::Literal("push_back"), method_13806, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("pop_back"), method_13807, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8200, type_8200, type_13765), Reflex::Literal("insert"), method_13808, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_8200, type_3394, type_13765), Reflex::Literal("insert"), method_13809, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8200, type_8200), Reflex::Literal("erase"), method_13810, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8200, type_8200, type_8200), Reflex::Literal("erase"), method_13811, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_32818), Reflex::Literal("swap"), method_13812, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("clear"), method_13813, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<Point3DBase<float, GlobalTag>,std::allocator<Point3DBase<float, GlobalTag> > > -------------------------------
static void constructor_13839( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Point3DBase<float,GlobalTag> >();
  else ::new(mem) ::std::vector<Point3DBase<float,GlobalTag> >();
}

static void constructor_13840( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Point3DBase<float,GlobalTag> >(*(const ::std::allocator<Point3DBase<float,GlobalTag> >*)arg[0]);
  else ::new(mem) ::std::vector<Point3DBase<float,GlobalTag> >(*(const ::std::allocator<Point3DBase<float,GlobalTag> >*)arg[0]);
}

static void constructor_13841( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Point3DBase<float,GlobalTag> >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<Point3DBase<float,GlobalTag> >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Point3DBase<float,GlobalTag> >(*(::std::size_t*)arg[0],
      *(const ::Point3DBase<float,GlobalTag>*)arg[1]);
  else ::new(mem) ::std::vector<Point3DBase<float,GlobalTag> >(*(::std::size_t*)arg[0],
      *(const ::Point3DBase<float,GlobalTag>*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Point3DBase<float,GlobalTag> >(*(::std::size_t*)arg[0],
      *(const ::Point3DBase<float,GlobalTag>*)arg[1],
      *(const ::std::allocator<Point3DBase<float,GlobalTag> >*)arg[2]);
  else ::new(mem) ::std::vector<Point3DBase<float,GlobalTag> >(*(::std::size_t*)arg[0],
      *(const ::Point3DBase<float,GlobalTag>*)arg[1],
      *(const ::std::allocator<Point3DBase<float,GlobalTag> >*)arg[2]);
  }
}

static void constructor_13842( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<Point3DBase<float,GlobalTag> >(*(const ::std::vector<Point3DBase<float,GlobalTag> >*)arg[0]);
  else ::new(mem) ::std::vector<Point3DBase<float,GlobalTag> >(*(const ::std::vector<Point3DBase<float,GlobalTag> >*)arg[0]);
}

static void destructor_13843(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<Point3DBase<float,GlobalTag> >*)o)->::std::vector<Point3DBase<float,GlobalTag> >::~vector)();
}
static  void operator_13844( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<Point3DBase<float,GlobalTag> >*)o)->operator=)(*(const ::std::vector<Point3DBase<float,GlobalTag> >*)arg[0]);
  else   (((::std::vector<Point3DBase<float,GlobalTag> >*)o)->operator=)(*(const ::std::vector<Point3DBase<float,GlobalTag> >*)arg[0]);
}

static  void method_13845( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<Point3DBase<float,GlobalTag> >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::Point3DBase<float,GlobalTag>*)arg[1]);
}

static  void method_13846( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Point3DBase<float,GlobalTag>*,std::vector<Point3DBase<float,GlobalTag> > >)((((::std::vector<Point3DBase<float,GlobalTag> >*)o)->begin)());
  else   (((::std::vector<Point3DBase<float,GlobalTag> >*)o)->begin)();
}

static  void method_13847( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const Point3DBase<float,GlobalTag>*,std::vector<Point3DBase<float,GlobalTag> > >)((((const ::std::vector<Point3DBase<float,GlobalTag> >*)o)->begin)());
  else   (((const ::std::vector<Point3DBase<float,GlobalTag> >*)o)->begin)();
}

static  void method_13848( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Point3DBase<float,GlobalTag>*,std::vector<Point3DBase<float,GlobalTag> > >)((((::std::vector<Point3DBase<float,GlobalTag> >*)o)->end)());
  else   (((::std::vector<Point3DBase<float,GlobalTag> >*)o)->end)();
}

static  void method_13849( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const Point3DBase<float,GlobalTag>*,std::vector<Point3DBase<float,GlobalTag> > >)((((const ::std::vector<Point3DBase<float,GlobalTag> >*)o)->end)());
  else   (((const ::std::vector<Point3DBase<float,GlobalTag> >*)o)->end)();
}

static  void method_13854( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<Point3DBase<float,GlobalTag> >*)o)->size)());
  else   (((const ::std::vector<Point3DBase<float,GlobalTag> >*)o)->size)();
}

static  void method_13855( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<Point3DBase<float,GlobalTag> >*)o)->max_size)());
  else   (((const ::std::vector<Point3DBase<float,GlobalTag> >*)o)->max_size)();
}

static  void method_13856( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<Point3DBase<float,GlobalTag> >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<Point3DBase<float,GlobalTag> >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::Point3DBase<float,GlobalTag>*)arg[1]);
  }
}

static  void method_13857( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<Point3DBase<float,GlobalTag> >*)o)->capacity)());
  else   (((const ::std::vector<Point3DBase<float,GlobalTag> >*)o)->capacity)();
}

static  void method_13858( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<Point3DBase<float,GlobalTag> >*)o)->empty)());
  else   (((const ::std::vector<Point3DBase<float,GlobalTag> >*)o)->empty)();
}

static  void method_13859( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<Point3DBase<float,GlobalTag> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_13860( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<Point3DBase<float,GlobalTag> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<Point3DBase<float,GlobalTag> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_13861( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<Point3DBase<float,GlobalTag> >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<Point3DBase<float,GlobalTag> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_13863( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<Point3DBase<float,GlobalTag> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<Point3DBase<float,GlobalTag> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13864( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<Point3DBase<float,GlobalTag> >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<Point3DBase<float,GlobalTag> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13865( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<Point3DBase<float,GlobalTag> >*)o)->front)();
  else   (((::std::vector<Point3DBase<float,GlobalTag> >*)o)->front)();
}

static  void method_13866( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<Point3DBase<float,GlobalTag> >*)o)->front)();
  else   (((const ::std::vector<Point3DBase<float,GlobalTag> >*)o)->front)();
}

static  void method_13867( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<Point3DBase<float,GlobalTag> >*)o)->back)();
  else   (((::std::vector<Point3DBase<float,GlobalTag> >*)o)->back)();
}

static  void method_13868( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<Point3DBase<float,GlobalTag> >*)o)->back)();
  else   (((const ::std::vector<Point3DBase<float,GlobalTag> >*)o)->back)();
}

static  void method_13869( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<Point3DBase<float,GlobalTag> >*)o)->data)());
  else   (((::std::vector<Point3DBase<float,GlobalTag> >*)o)->data)();
}

static  void method_13870( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<Point3DBase<float,GlobalTag> >*)o)->data)());
  else   (((const ::std::vector<Point3DBase<float,GlobalTag> >*)o)->data)();
}

static  void method_13871( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<Point3DBase<float,GlobalTag> >*)o)->push_back)(*(const ::Point3DBase<float,GlobalTag>*)arg[0]);
}

static  void method_13872( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<Point3DBase<float,GlobalTag> >*)o)->pop_back)();
}

static  void method_13873( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Point3DBase<float,GlobalTag>*,std::vector<Point3DBase<float,GlobalTag> > >)((((::std::vector<Point3DBase<float,GlobalTag> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<Point3DBase<float,GlobalTag>*,std::vector<Point3DBase<float,GlobalTag> > >*)arg[0],
    *(const ::Point3DBase<float,GlobalTag>*)arg[1]));
  else   (((::std::vector<Point3DBase<float,GlobalTag> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<Point3DBase<float,GlobalTag>*,std::vector<Point3DBase<float,GlobalTag> > >*)arg[0],
    *(const ::Point3DBase<float,GlobalTag>*)arg[1]);
}

static  void method_13874( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<Point3DBase<float,GlobalTag> >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<Point3DBase<float,GlobalTag>*,std::vector<Point3DBase<float,GlobalTag> > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::Point3DBase<float,GlobalTag>*)arg[2]);
}

static  void method_13875( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Point3DBase<float,GlobalTag>*,std::vector<Point3DBase<float,GlobalTag> > >)((((::std::vector<Point3DBase<float,GlobalTag> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Point3DBase<float,GlobalTag>*,std::vector<Point3DBase<float,GlobalTag> > >*)arg[0]));
  else   (((::std::vector<Point3DBase<float,GlobalTag> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Point3DBase<float,GlobalTag>*,std::vector<Point3DBase<float,GlobalTag> > >*)arg[0]);
}

static  void method_13876( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<Point3DBase<float,GlobalTag>*,std::vector<Point3DBase<float,GlobalTag> > >)((((::std::vector<Point3DBase<float,GlobalTag> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Point3DBase<float,GlobalTag>*,std::vector<Point3DBase<float,GlobalTag> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<Point3DBase<float,GlobalTag>*,std::vector<Point3DBase<float,GlobalTag> > >*)arg[1]));
  else   (((::std::vector<Point3DBase<float,GlobalTag> >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<Point3DBase<float,GlobalTag>*,std::vector<Point3DBase<float,GlobalTag> > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<Point3DBase<float,GlobalTag>*,std::vector<Point3DBase<float,GlobalTag> > >*)arg[1]);
}

static  void method_13877( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<Point3DBase<float,GlobalTag> >*)o)->swap)(*(::std::vector<Point3DBase<float,GlobalTag> >*)arg[0]);
}

static  void method_13878( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<Point3DBase<float,GlobalTag> >*)o)->clear)();
}

static void method_newdel_3149( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<Point3DBase<float,GlobalTag> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<Point3DBase<float,GlobalTag> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<Point3DBase<float,GlobalTag> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<Point3DBase<float,GlobalTag> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<Point3DBase<float,GlobalTag> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x41( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<Point3DBase<float,GlobalTag>,std::allocator<Point3DBase<float,GlobalTag> > >")), ::Reflex::BaseOffset< ::std::vector<Point3DBase<float,GlobalTag> >,::std::_Vector_base<Point3DBase<float,GlobalTag>,std::allocator<Point3DBase<float,GlobalTag> > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x42( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<Point3DBase<float,GlobalTag> > >::Generate();
  else ::Reflex::Proxy< ::std::vector<Point3DBase<float,GlobalTag> > >::Generate();
}

//------Dictionary for class vector<Point3DBase<float, GlobalTag>,std::allocator<Point3DBase<float, GlobalTag> > > -------------------------------
void __std__vector_Point3DBase_float_GlobalTag_s__db_datamem(Reflex::Class*);
void __std__vector_Point3DBase_float_GlobalTag_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_Point3DBase_float_GlobalTag_s__datamem_bld(&__std__vector_Point3DBase_float_GlobalTag_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_Point3DBase_float_GlobalTag_s__funcmem_bld(&__std__vector_Point3DBase_float_GlobalTag_s__db_funcmem);
void __std__vector_Point3DBase_float_GlobalTag_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<Point3DBase<float,GlobalTag> >"), typeid(::std::vector<Point3DBase<float,GlobalTag> >), sizeof(::std::vector<Point3DBase<float,GlobalTag> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2605, ::Reflex::BaseOffset< ::std::vector<Point3DBase<float,GlobalTag> >, ::std::_Vector_base<Point3DBase<float,GlobalTag>,std::allocator<Point3DBase<float,GlobalTag> > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_484, Reflex::Literal("std::vector<Point3DBase<float,GlobalTag> >::_Alloc_value_type"))
  .AddTypedef(type_2605, Reflex::Literal("std::vector<Point3DBase<float,GlobalTag> >::_Base"))
  .AddTypedef(type_3419, Reflex::Literal("std::vector<Point3DBase<float,GlobalTag> >::_Tp_alloc_type"))
  .AddTypedef(type_484, Reflex::Literal("std::vector<Point3DBase<float,GlobalTag> >::value_type"))
  .AddTypedef(type_13824, Reflex::Literal("std::vector<Point3DBase<float,GlobalTag> >::pointer"))
  .AddTypedef(type_13826, Reflex::Literal("std::vector<Point3DBase<float,GlobalTag> >::const_pointer"))
  .AddTypedef(type_13828, Reflex::Literal("std::vector<Point3DBase<float,GlobalTag> >::reference"))
  .AddTypedef(type_13830, Reflex::Literal("std::vector<Point3DBase<float,GlobalTag> >::const_reference"))
  .AddTypedef(type_8178, Reflex::Literal("std::vector<Point3DBase<float,GlobalTag> >::iterator"))
  .AddTypedef(type_8179, Reflex::Literal("std::vector<Point3DBase<float,GlobalTag> >::const_iterator"))
  .AddTypedef(type_3627, Reflex::Literal("std::vector<Point3DBase<float,GlobalTag> >::const_reverse_iterator"))
  .AddTypedef(type_3628, Reflex::Literal("std::vector<Point3DBase<float,GlobalTag> >::reverse_iterator"))
  .AddTypedef(type_3394, Reflex::Literal("std::vector<Point3DBase<float,GlobalTag> >::size_type"))
  .AddTypedef(type_3290, Reflex::Literal("std::vector<Point3DBase<float,GlobalTag> >::difference_type"))
  .AddTypedef(type_3419, Reflex::Literal("std::vector<Point3DBase<float,GlobalTag> >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_13839, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31789), Reflex::Literal("vector"), constructor_13840, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3394, type_13830, type_31789), Reflex::Literal("vector"), constructor_13841, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32820), Reflex::Literal("vector"), constructor_13842, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_13843, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3149, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x41, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x42, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_Point3DBase_float_GlobalTag_s__funcmem_bld);
}

//------Delayed data member builder for class vector<Point3DBase<float, GlobalTag>,std::allocator<Point3DBase<float, GlobalTag> > > -------------------
void __std__vector_Point3DBase_float_GlobalTag_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<Point3DBase<float, GlobalTag>,std::allocator<Point3DBase<float, GlobalTag> > > -------------------
void __std__vector_Point3DBase_float_GlobalTag_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32821, type_32820), Reflex::Literal("operator="), operator_13844, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394, type_13830), Reflex::Literal("assign"), method_13845, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8178), Reflex::Literal("begin"), method_13846, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8179), Reflex::Literal("begin"), method_13847, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8178), Reflex::Literal("end"), method_13848, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8179), Reflex::Literal("end"), method_13849, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("size"), method_13854, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("max_size"), method_13855, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394, type_484), Reflex::Literal("resize"), method_13856, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("capacity"), method_13857, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("empty"), method_13858, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394), Reflex::Literal("reserve"), method_13859, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13828, type_3394), Reflex::Literal("operator[]"), operator_13860, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13830, type_3394), Reflex::Literal("operator[]"), operator_13861, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13828, type_3394), Reflex::Literal("at"), method_13863, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13830, type_3394), Reflex::Literal("at"), method_13864, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13828), Reflex::Literal("front"), method_13865, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13830), Reflex::Literal("front"), method_13866, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13828), Reflex::Literal("back"), method_13867, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13830), Reflex::Literal("back"), method_13868, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13824), Reflex::Literal("data"), method_13869, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13826), Reflex::Literal("data"), method_13870, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_13830), Reflex::Literal("push_back"), method_13871, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("pop_back"), method_13872, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8178, type_8178, type_13830), Reflex::Literal("insert"), method_13873, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_8178, type_3394, type_13830), Reflex::Literal("insert"), method_13874, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8178, type_8178), Reflex::Literal("erase"), method_13875, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8178, type_8178, type_8178), Reflex::Literal("erase"), method_13876, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_32821), Reflex::Literal("swap"), method_13877, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("clear"), method_13878, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class PhiWedge -------------------------------
static  void operator_27367( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::PhiWedge*)o)->operator=)(*(const ::reco::PhiWedge*)arg[0]);
  else   (((::reco::PhiWedge*)o)->operator=)(*(const ::reco::PhiWedge*)arg[0]);
}

static void constructor_27368( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::PhiWedge();
  else ::new(mem) ::reco::PhiWedge();
}

static void constructor_27369( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::PhiWedge(*(float*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2]);
  else ::new(mem) ::reco::PhiWedge(*(float*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2]);
}

static void constructor_27370( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::PhiWedge(*(float*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(float*)arg[3],
      *(float*)arg[4]);
  else ::new(mem) ::reco::PhiWedge(*(float*)arg[0],
      *(int*)arg[1],
      *(int*)arg[2],
      *(float*)arg[3],
      *(float*)arg[4]);
}

static void constructor_27371( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::PhiWedge(*(const ::reco::PhiWedge*)arg[0]);
  else ::new(mem) ::reco::PhiWedge(*(const ::reco::PhiWedge*)arg[0]);
}

static void destructor_27372(void*, void * o, const std::vector<void*>&, void *) {
(((::reco::PhiWedge*)o)->::reco::PhiWedge::~PhiWedge)();
}
static  void method_27373( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::PhiWedge*)o)->Energy)());
  else   (((const ::reco::PhiWedge*)o)->Energy)();
}

static  void method_27374( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::reco::PhiWedge*)o)->NumberOfConstituents)());
  else   (((const ::reco::PhiWedge*)o)->NumberOfConstituents)();
}

static  void method_27375( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::reco::PhiWedge*)o)->iPhi)());
  else   (((const ::reco::PhiWedge*)o)->iPhi)();
}

static  void method_27376( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::PhiWedge*)o)->PhiLow)());
  else   (((const ::reco::PhiWedge*)o)->PhiLow)();
}

static  void method_27377( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::PhiWedge*)o)->PhiHigh)());
  else   (((const ::reco::PhiWedge*)o)->PhiHigh)();
}

static  void method_27378( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::PhiWedge*)o)->MinTime)());
  else   (((const ::reco::PhiWedge*)o)->MinTime)();
}

static  void method_27379( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::PhiWedge*)o)->MaxTime)());
  else   (((const ::reco::PhiWedge*)o)->MaxTime)();
}

static  void method_27380( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::PhiWedge*)o)->ZDirectionConfidence)());
  else   (((const ::reco::PhiWedge*)o)->ZDirectionConfidence)();
}

static  void method_27381( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::PhiWedge*)o)->PlusZDirectionConfidence)());
  else   (((const ::reco::PhiWedge*)o)->PlusZDirectionConfidence)();
}

static  void method_27382( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::PhiWedge*)o)->MinusZDirectionConfidence)());
  else   (((const ::reco::PhiWedge*)o)->MinusZDirectionConfidence)();
}

static  void method_27383( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::PhiWedge*)o)->PlusZOriginConfidence)());
  else   (((const ::reco::PhiWedge*)o)->PlusZOriginConfidence)();
}

static  void method_27384( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::PhiWedge*)o)->MinusZOriginConfidence)());
  else   (((const ::reco::PhiWedge*)o)->MinusZOriginConfidence)();
}

static  void method_27385( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::reco::PhiWedge*)o)->OverlappingCSCTracks)());
  else   (((const ::reco::PhiWedge*)o)->OverlappingCSCTracks)();
}

static  void method_27386( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::reco::PhiWedge*)o)->OverlappingCSCSegments)());
  else   (((const ::reco::PhiWedge*)o)->OverlappingCSCSegments)();
}

static  void method_27387( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::reco::PhiWedge*)o)->OverlappingCSCRecHits)());
  else   (((const ::reco::PhiWedge*)o)->OverlappingCSCRecHits)();
}

static  void method_27388( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::reco::PhiWedge*)o)->OverlappingCSCHaloTriggers)());
  else   (((const ::reco::PhiWedge*)o)->OverlappingCSCHaloTriggers)();
}

static  void method_27389( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::PhiWedge*)o)->SetOverlappingCSCTracks)(*(int*)arg[0]);
}

static  void method_27390( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::PhiWedge*)o)->SetOverlappingCSCSegments)(*(int*)arg[0]);
}

static  void method_27391( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::PhiWedge*)o)->SetOverlappingCSCRecHits)(*(int*)arg[0]);
}

static  void method_27392( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::PhiWedge*)o)->SetOverlappingCSCHaloTriggers)(*(int*)arg[0]);
}

static  void method_27393( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::PhiWedge*)o)->SetMinMaxTime)(*(float*)arg[0],
    *(float*)arg[1]);
}

static  void method_27394( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::PhiWedge*)o)->SetPlusZOriginConfidence)(*(float*)arg[0]);
}

static void method_newdel_7934( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::reco::PhiWedge >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::reco::PhiWedge >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::reco::PhiWedge >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::reco::PhiWedge >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::reco::PhiWedge >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class PhiWedge -------------------------------
void __reco__PhiWedge_db_datamem(Reflex::Class*);
void __reco__PhiWedge_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __reco__PhiWedge_datamem_bld(&__reco__PhiWedge_db_datamem);
Reflex::GenreflexMemberBuilder __reco__PhiWedge_funcmem_bld(&__reco__PhiWedge_db_funcmem);
void __reco__PhiWedge_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("reco::PhiWedge"), typeid(::reco::PhiWedge), sizeof(::reco::PhiWedge), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10299, type_13893), Reflex::Literal("operator="), operator_27367, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PhiWedge"), constructor_27368, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_932, type_72, type_72), Reflex::Literal("PhiWedge"), constructor_27369, 0, "E;iphi;constituents", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_932, type_72, type_72, type_932, type_932), Reflex::Literal("PhiWedge"), constructor_27370, 0, "E;iphi;constituents;min_time;max_time", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13893), Reflex::Literal("PhiWedge"), constructor_27371, 0, "", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PhiWedge"), destructor_27372, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7934, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__reco__PhiWedge_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__reco__PhiWedge_funcmem_bld);
}

//------Delayed data member builder for class PhiWedge -------------------
void __reco__PhiWedge_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_932, Reflex::Literal("energy_"), OffsetOf(__shadow__::__reco__PhiWedge, energy_), ::Reflex::PRIVATE)
  .AddDataMember(type_72, Reflex::Literal("iphi_"), OffsetOf(__shadow__::__reco__PhiWedge, iphi_), ::Reflex::PRIVATE)
  .AddDataMember(type_72, Reflex::Literal("constituents_"), OffsetOf(__shadow__::__reco__PhiWedge, constituents_), ::Reflex::PRIVATE)
  .AddDataMember(type_932, Reflex::Literal("min_time_"), OffsetOf(__shadow__::__reco__PhiWedge, min_time_), ::Reflex::PRIVATE)
  .AddDataMember(type_932, Reflex::Literal("max_time_"), OffsetOf(__shadow__::__reco__PhiWedge, max_time_), ::Reflex::PRIVATE)
  .AddDataMember(type_932, Reflex::Literal("PlusZOriginConfidence_"), OffsetOf(__shadow__::__reco__PhiWedge, PlusZOriginConfidence_), ::Reflex::PRIVATE)
  .AddDataMember(type_72, Reflex::Literal("OverlappingCSCTracks_"), OffsetOf(__shadow__::__reco__PhiWedge, OverlappingCSCTracks_), ::Reflex::PRIVATE)
  .AddDataMember(type_72, Reflex::Literal("OverlappingCSCSegments_"), OffsetOf(__shadow__::__reco__PhiWedge, OverlappingCSCSegments_), ::Reflex::PRIVATE)
  .AddDataMember(type_72, Reflex::Literal("OverlappingCSCRecHits_"), OffsetOf(__shadow__::__reco__PhiWedge, OverlappingCSCRecHits_), ::Reflex::PRIVATE)
  .AddDataMember(type_72, Reflex::Literal("OverlappingCSCHaloTriggers_"), OffsetOf(__shadow__::__reco__PhiWedge, OverlappingCSCHaloTriggers_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PhiWedge -------------------
void __reco__PhiWedge_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("Energy"), method_27373, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("NumberOfConstituents"), method_27374, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("iPhi"), method_27375, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("PhiLow"), method_27376, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("PhiHigh"), method_27377, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("MinTime"), method_27378, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("MaxTime"), method_27379, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("ZDirectionConfidence"), method_27380, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("PlusZDirectionConfidence"), method_27381, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("MinusZDirectionConfidence"), method_27382, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("PlusZOriginConfidence"), method_27383, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("MinusZOriginConfidence"), method_27384, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("OverlappingCSCTracks"), method_27385, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("OverlappingCSCSegments"), method_27386, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("OverlappingCSCRecHits"), method_27387, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("OverlappingCSCHaloTriggers"), method_27388, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_72), Reflex::Literal("SetOverlappingCSCTracks"), method_27389, 0, "x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_72), Reflex::Literal("SetOverlappingCSCSegments"), method_27390, 0, "x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_72), Reflex::Literal("SetOverlappingCSCRecHits"), method_27391, 0, "x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_72), Reflex::Literal("SetOverlappingCSCHaloTriggers"), method_27392, 0, "x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_932, type_932), Reflex::Literal("SetMinMaxTime"), method_27393, 0, "min;max", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_932), Reflex::Literal("SetPlusZOriginConfidence"), method_27394, 0, "x", ::Reflex::PUBLIC);
}
//------Stub functions for class vector<reco::PhiWedge,std::allocator<reco::PhiWedge> > -------------------------------
static void constructor_13902( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::PhiWedge>();
  else ::new(mem) ::std::vector<reco::PhiWedge>();
}

static void constructor_13903( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::PhiWedge>(*(const ::std::allocator<reco::PhiWedge>*)arg[0]);
  else ::new(mem) ::std::vector<reco::PhiWedge>(*(const ::std::allocator<reco::PhiWedge>*)arg[0]);
}

static void constructor_13904( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::PhiWedge>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<reco::PhiWedge>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::PhiWedge>(*(::std::size_t*)arg[0],
      *(const ::reco::PhiWedge*)arg[1]);
  else ::new(mem) ::std::vector<reco::PhiWedge>(*(::std::size_t*)arg[0],
      *(const ::reco::PhiWedge*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::PhiWedge>(*(::std::size_t*)arg[0],
      *(const ::reco::PhiWedge*)arg[1],
      *(const ::std::allocator<reco::PhiWedge>*)arg[2]);
  else ::new(mem) ::std::vector<reco::PhiWedge>(*(::std::size_t*)arg[0],
      *(const ::reco::PhiWedge*)arg[1],
      *(const ::std::allocator<reco::PhiWedge>*)arg[2]);
  }
}

static void constructor_13905( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::PhiWedge>(*(const ::std::vector<reco::PhiWedge>*)arg[0]);
  else ::new(mem) ::std::vector<reco::PhiWedge>(*(const ::std::vector<reco::PhiWedge>*)arg[0]);
}

static void destructor_13906(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<reco::PhiWedge>*)o)->::std::vector<reco::PhiWedge>::~vector)();
}
static  void operator_13907( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::PhiWedge>*)o)->operator=)(*(const ::std::vector<reco::PhiWedge>*)arg[0]);
  else   (((::std::vector<reco::PhiWedge>*)o)->operator=)(*(const ::std::vector<reco::PhiWedge>*)arg[0]);
}

static  void method_13908( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::PhiWedge>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::reco::PhiWedge*)arg[1]);
}

static  void method_13909( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >)((((::std::vector<reco::PhiWedge>*)o)->begin)());
  else   (((::std::vector<reco::PhiWedge>*)o)->begin)();
}

static  void method_13910( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::PhiWedge*,std::vector<reco::PhiWedge> >)((((const ::std::vector<reco::PhiWedge>*)o)->begin)());
  else   (((const ::std::vector<reco::PhiWedge>*)o)->begin)();
}

static  void method_13911( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >)((((::std::vector<reco::PhiWedge>*)o)->end)());
  else   (((::std::vector<reco::PhiWedge>*)o)->end)();
}

static  void method_13912( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::PhiWedge*,std::vector<reco::PhiWedge> >)((((const ::std::vector<reco::PhiWedge>*)o)->end)());
  else   (((const ::std::vector<reco::PhiWedge>*)o)->end)();
}

static  void method_13917( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::PhiWedge>*)o)->size)());
  else   (((const ::std::vector<reco::PhiWedge>*)o)->size)();
}

static  void method_13918( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::PhiWedge>*)o)->max_size)());
  else   (((const ::std::vector<reco::PhiWedge>*)o)->max_size)();
}

static  void method_13919( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<reco::PhiWedge>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<reco::PhiWedge>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::reco::PhiWedge*)arg[1]);
  }
}

static  void method_13920( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::PhiWedge>*)o)->capacity)());
  else   (((const ::std::vector<reco::PhiWedge>*)o)->capacity)();
}

static  void method_13921( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<reco::PhiWedge>*)o)->empty)());
  else   (((const ::std::vector<reco::PhiWedge>*)o)->empty)();
}

static  void method_13922( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::PhiWedge>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_13923( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::PhiWedge>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::PhiWedge>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_13924( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::PhiWedge>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::PhiWedge>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_13926( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::PhiWedge>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::PhiWedge>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13927( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::PhiWedge>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::PhiWedge>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13928( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::PhiWedge>*)o)->front)();
  else   (((::std::vector<reco::PhiWedge>*)o)->front)();
}

static  void method_13929( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::PhiWedge>*)o)->front)();
  else   (((const ::std::vector<reco::PhiWedge>*)o)->front)();
}

static  void method_13930( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::PhiWedge>*)o)->back)();
  else   (((::std::vector<reco::PhiWedge>*)o)->back)();
}

static  void method_13931( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::PhiWedge>*)o)->back)();
  else   (((const ::std::vector<reco::PhiWedge>*)o)->back)();
}

static  void method_13932( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<reco::PhiWedge>*)o)->data)());
  else   (((::std::vector<reco::PhiWedge>*)o)->data)();
}

static  void method_13933( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<reco::PhiWedge>*)o)->data)());
  else   (((const ::std::vector<reco::PhiWedge>*)o)->data)();
}

static  void method_13934( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::PhiWedge>*)o)->push_back)(*(const ::reco::PhiWedge*)arg[0]);
}

static  void method_13935( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::PhiWedge>*)o)->pop_back)();
}

static  void method_13936( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >)((((::std::vector<reco::PhiWedge>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >*)arg[0],
    *(const ::reco::PhiWedge*)arg[1]));
  else   (((::std::vector<reco::PhiWedge>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >*)arg[0],
    *(const ::reco::PhiWedge*)arg[1]);
}

static  void method_13937( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::PhiWedge>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::reco::PhiWedge*)arg[2]);
}

static  void method_13938( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >)((((::std::vector<reco::PhiWedge>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >*)arg[0]));
  else   (((::std::vector<reco::PhiWedge>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >*)arg[0]);
}

static  void method_13939( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >)((((::std::vector<reco::PhiWedge>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >*)arg[1]));
  else   (((::std::vector<reco::PhiWedge>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >*)arg[1]);
}

static  void method_13940( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::PhiWedge>*)o)->swap)(*(::std::vector<reco::PhiWedge>*)arg[0]);
}

static  void method_13941( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::PhiWedge>*)o)->clear)();
}

static void method_newdel_3150( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<reco::PhiWedge> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<reco::PhiWedge> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<reco::PhiWedge> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<reco::PhiWedge> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<reco::PhiWedge> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x45( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::PhiWedge,std::allocator<reco::PhiWedge> >")), ::Reflex::BaseOffset< ::std::vector<reco::PhiWedge>,::std::_Vector_base<reco::PhiWedge,std::allocator<reco::PhiWedge> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x46( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<reco::PhiWedge> >::Generate();
  else ::Reflex::Proxy< ::std::vector<reco::PhiWedge> >::Generate();
}

//------Dictionary for class vector<reco::PhiWedge,std::allocator<reco::PhiWedge> > -------------------------------
void __std__vector_reco__PhiWedge__db_datamem(Reflex::Class*);
void __std__vector_reco__PhiWedge__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_reco__PhiWedge__datamem_bld(&__std__vector_reco__PhiWedge__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_reco__PhiWedge__funcmem_bld(&__std__vector_reco__PhiWedge__db_funcmem);
void __std__vector_reco__PhiWedge__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<reco::PhiWedge>"), typeid(::std::vector<reco::PhiWedge>), sizeof(::std::vector<reco::PhiWedge>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2602, ::Reflex::BaseOffset< ::std::vector<reco::PhiWedge>, ::std::_Vector_base<reco::PhiWedge,std::allocator<reco::PhiWedge> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_7934, Reflex::Literal("std::vector<reco::PhiWedge>::_Alloc_value_type"))
  .AddTypedef(type_2602, Reflex::Literal("std::vector<reco::PhiWedge>::_Base"))
  .AddTypedef(type_3420, Reflex::Literal("std::vector<reco::PhiWedge>::_Tp_alloc_type"))
  .AddTypedef(type_7934, Reflex::Literal("std::vector<reco::PhiWedge>::value_type"))
  .AddTypedef(type_10297, Reflex::Literal("std::vector<reco::PhiWedge>::pointer"))
  .AddTypedef(type_13890, Reflex::Literal("std::vector<reco::PhiWedge>::const_pointer"))
  .AddTypedef(type_10299, Reflex::Literal("std::vector<reco::PhiWedge>::reference"))
  .AddTypedef(type_13893, Reflex::Literal("std::vector<reco::PhiWedge>::const_reference"))
  .AddTypedef(type_8161, Reflex::Literal("std::vector<reco::PhiWedge>::iterator"))
  .AddTypedef(type_8174, Reflex::Literal("std::vector<reco::PhiWedge>::const_iterator"))
  .AddTypedef(type_3621, Reflex::Literal("std::vector<reco::PhiWedge>::const_reverse_iterator"))
  .AddTypedef(type_3622, Reflex::Literal("std::vector<reco::PhiWedge>::reverse_iterator"))
  .AddTypedef(type_3394, Reflex::Literal("std::vector<reco::PhiWedge>::size_type"))
  .AddTypedef(type_3290, Reflex::Literal("std::vector<reco::PhiWedge>::difference_type"))
  .AddTypedef(type_3420, Reflex::Literal("std::vector<reco::PhiWedge>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_13902, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31753), Reflex::Literal("vector"), constructor_13903, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3394, type_13893, type_31753), Reflex::Literal("vector"), constructor_13904, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32823), Reflex::Literal("vector"), constructor_13905, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_13906, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3150, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x45, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x46, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_reco__PhiWedge__funcmem_bld);
}

//------Delayed data member builder for class vector<reco::PhiWedge,std::allocator<reco::PhiWedge> > -------------------
void __std__vector_reco__PhiWedge__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<reco::PhiWedge,std::allocator<reco::PhiWedge> > -------------------
void __std__vector_reco__PhiWedge__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32824, type_32823), Reflex::Literal("operator="), operator_13907, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394, type_13893), Reflex::Literal("assign"), method_13908, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8161), Reflex::Literal("begin"), method_13909, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8174), Reflex::Literal("begin"), method_13910, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8161), Reflex::Literal("end"), method_13911, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8174), Reflex::Literal("end"), method_13912, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("size"), method_13917, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("max_size"), method_13918, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394, type_7934), Reflex::Literal("resize"), method_13919, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("capacity"), method_13920, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("empty"), method_13921, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394), Reflex::Literal("reserve"), method_13922, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10299, type_3394), Reflex::Literal("operator[]"), operator_13923, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13893, type_3394), Reflex::Literal("operator[]"), operator_13924, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10299, type_3394), Reflex::Literal("at"), method_13926, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13893, type_3394), Reflex::Literal("at"), method_13927, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10299), Reflex::Literal("front"), method_13928, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13893), Reflex::Literal("front"), method_13929, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10299), Reflex::Literal("back"), method_13930, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13893), Reflex::Literal("back"), method_13931, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10297), Reflex::Literal("data"), method_13932, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13890), Reflex::Literal("data"), method_13933, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_13893), Reflex::Literal("push_back"), method_13934, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("pop_back"), method_13935, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8161, type_8161, type_13893), Reflex::Literal("insert"), method_13936, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_8161, type_3394, type_13893), Reflex::Literal("insert"), method_13937, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8161, type_8161), Reflex::Literal("erase"), method_13938, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8161, type_8161, type_8161), Reflex::Literal("erase"), method_13939, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_32824), Reflex::Literal("swap"), method_13940, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("clear"), method_13941, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<SpecificPFMETData,std::allocator<SpecificPFMETData> > -------------------------------
static void constructor_13967( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SpecificPFMETData>();
  else ::new(mem) ::std::vector<SpecificPFMETData>();
}

static void constructor_13968( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SpecificPFMETData>(*(const ::std::allocator<SpecificPFMETData>*)arg[0]);
  else ::new(mem) ::std::vector<SpecificPFMETData>(*(const ::std::allocator<SpecificPFMETData>*)arg[0]);
}

static void constructor_13969( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SpecificPFMETData>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<SpecificPFMETData>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SpecificPFMETData>(*(::std::size_t*)arg[0],
      *(const ::SpecificPFMETData*)arg[1]);
  else ::new(mem) ::std::vector<SpecificPFMETData>(*(::std::size_t*)arg[0],
      *(const ::SpecificPFMETData*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SpecificPFMETData>(*(::std::size_t*)arg[0],
      *(const ::SpecificPFMETData*)arg[1],
      *(const ::std::allocator<SpecificPFMETData>*)arg[2]);
  else ::new(mem) ::std::vector<SpecificPFMETData>(*(::std::size_t*)arg[0],
      *(const ::SpecificPFMETData*)arg[1],
      *(const ::std::allocator<SpecificPFMETData>*)arg[2]);
  }
}

static void constructor_13970( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SpecificPFMETData>(*(const ::std::vector<SpecificPFMETData>*)arg[0]);
  else ::new(mem) ::std::vector<SpecificPFMETData>(*(const ::std::vector<SpecificPFMETData>*)arg[0]);
}

static void destructor_13971(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<SpecificPFMETData>*)o)->::std::vector<SpecificPFMETData>::~vector)();
}
static  void operator_13972( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SpecificPFMETData>*)o)->operator=)(*(const ::std::vector<SpecificPFMETData>*)arg[0]);
  else   (((::std::vector<SpecificPFMETData>*)o)->operator=)(*(const ::std::vector<SpecificPFMETData>*)arg[0]);
}

static  void method_13973( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SpecificPFMETData>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::SpecificPFMETData*)arg[1]);
}

static  void method_13974( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SpecificPFMETData*,std::vector<SpecificPFMETData> >)((((::std::vector<SpecificPFMETData>*)o)->begin)());
  else   (((::std::vector<SpecificPFMETData>*)o)->begin)();
}

static  void method_13975( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const SpecificPFMETData*,std::vector<SpecificPFMETData> >)((((const ::std::vector<SpecificPFMETData>*)o)->begin)());
  else   (((const ::std::vector<SpecificPFMETData>*)o)->begin)();
}

static  void method_13976( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SpecificPFMETData*,std::vector<SpecificPFMETData> >)((((::std::vector<SpecificPFMETData>*)o)->end)());
  else   (((::std::vector<SpecificPFMETData>*)o)->end)();
}

static  void method_13977( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const SpecificPFMETData*,std::vector<SpecificPFMETData> >)((((const ::std::vector<SpecificPFMETData>*)o)->end)());
  else   (((const ::std::vector<SpecificPFMETData>*)o)->end)();
}

static  void method_13982( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<SpecificPFMETData>*)o)->size)());
  else   (((const ::std::vector<SpecificPFMETData>*)o)->size)();
}

static  void method_13983( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<SpecificPFMETData>*)o)->max_size)());
  else   (((const ::std::vector<SpecificPFMETData>*)o)->max_size)();
}

static  void method_13984( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<SpecificPFMETData>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<SpecificPFMETData>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::SpecificPFMETData*)arg[1]);
  }
}

static  void method_13985( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<SpecificPFMETData>*)o)->capacity)());
  else   (((const ::std::vector<SpecificPFMETData>*)o)->capacity)();
}

static  void method_13986( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<SpecificPFMETData>*)o)->empty)());
  else   (((const ::std::vector<SpecificPFMETData>*)o)->empty)();
}

static  void method_13987( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SpecificPFMETData>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_13988( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SpecificPFMETData>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<SpecificPFMETData>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_13989( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SpecificPFMETData>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<SpecificPFMETData>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_13991( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SpecificPFMETData>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<SpecificPFMETData>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13992( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SpecificPFMETData>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<SpecificPFMETData>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13993( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SpecificPFMETData>*)o)->front)();
  else   (((::std::vector<SpecificPFMETData>*)o)->front)();
}

static  void method_13994( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SpecificPFMETData>*)o)->front)();
  else   (((const ::std::vector<SpecificPFMETData>*)o)->front)();
}

static  void method_13995( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SpecificPFMETData>*)o)->back)();
  else   (((::std::vector<SpecificPFMETData>*)o)->back)();
}

static  void method_13996( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SpecificPFMETData>*)o)->back)();
  else   (((const ::std::vector<SpecificPFMETData>*)o)->back)();
}

static  void method_13997( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<SpecificPFMETData>*)o)->data)());
  else   (((::std::vector<SpecificPFMETData>*)o)->data)();
}

static  void method_13998( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<SpecificPFMETData>*)o)->data)());
  else   (((const ::std::vector<SpecificPFMETData>*)o)->data)();
}

static  void method_13999( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SpecificPFMETData>*)o)->push_back)(*(const ::SpecificPFMETData*)arg[0]);
}

static  void method_14000( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<SpecificPFMETData>*)o)->pop_back)();
}

static  void method_14001( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SpecificPFMETData*,std::vector<SpecificPFMETData> >)((((::std::vector<SpecificPFMETData>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<SpecificPFMETData*,std::vector<SpecificPFMETData> >*)arg[0],
    *(const ::SpecificPFMETData*)arg[1]));
  else   (((::std::vector<SpecificPFMETData>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<SpecificPFMETData*,std::vector<SpecificPFMETData> >*)arg[0],
    *(const ::SpecificPFMETData*)arg[1]);
}

static  void method_14002( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SpecificPFMETData>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<SpecificPFMETData*,std::vector<SpecificPFMETData> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::SpecificPFMETData*)arg[2]);
}

static  void method_14003( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SpecificPFMETData*,std::vector<SpecificPFMETData> >)((((::std::vector<SpecificPFMETData>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SpecificPFMETData*,std::vector<SpecificPFMETData> >*)arg[0]));
  else   (((::std::vector<SpecificPFMETData>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SpecificPFMETData*,std::vector<SpecificPFMETData> >*)arg[0]);
}

static  void method_14004( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SpecificPFMETData*,std::vector<SpecificPFMETData> >)((((::std::vector<SpecificPFMETData>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SpecificPFMETData*,std::vector<SpecificPFMETData> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<SpecificPFMETData*,std::vector<SpecificPFMETData> >*)arg[1]));
  else   (((::std::vector<SpecificPFMETData>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SpecificPFMETData*,std::vector<SpecificPFMETData> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<SpecificPFMETData*,std::vector<SpecificPFMETData> >*)arg[1]);
}

static  void method_14005( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SpecificPFMETData>*)o)->swap)(*(::std::vector<SpecificPFMETData>*)arg[0]);
}

static  void method_14006( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<SpecificPFMETData>*)o)->clear)();
}

static void method_newdel_3151( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<SpecificPFMETData> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<SpecificPFMETData> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<SpecificPFMETData> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<SpecificPFMETData> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<SpecificPFMETData> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x48( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<SpecificPFMETData,std::allocator<SpecificPFMETData> >")), ::Reflex::BaseOffset< ::std::vector<SpecificPFMETData>,::std::_Vector_base<SpecificPFMETData,std::allocator<SpecificPFMETData> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x49( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<SpecificPFMETData> >::Generate();
  else ::Reflex::Proxy< ::std::vector<SpecificPFMETData> >::Generate();
}

//------Dictionary for class vector<SpecificPFMETData,std::allocator<SpecificPFMETData> > -------------------------------
void __std__vector_SpecificPFMETData__db_datamem(Reflex::Class*);
void __std__vector_SpecificPFMETData__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_SpecificPFMETData__datamem_bld(&__std__vector_SpecificPFMETData__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_SpecificPFMETData__funcmem_bld(&__std__vector_SpecificPFMETData__db_funcmem);
void __std__vector_SpecificPFMETData__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<SpecificPFMETData>"), typeid(::std::vector<SpecificPFMETData>), sizeof(::std::vector<SpecificPFMETData>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2595, ::Reflex::BaseOffset< ::std::vector<SpecificPFMETData>, ::std::_Vector_base<SpecificPFMETData,std::allocator<SpecificPFMETData> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_468, Reflex::Literal("std::vector<SpecificPFMETData>::_Alloc_value_type"))
  .AddTypedef(type_2595, Reflex::Literal("std::vector<SpecificPFMETData>::_Base"))
  .AddTypedef(type_3421, Reflex::Literal("std::vector<SpecificPFMETData>::_Tp_alloc_type"))
  .AddTypedef(type_468, Reflex::Literal("std::vector<SpecificPFMETData>::value_type"))
  .AddTypedef(type_13952, Reflex::Literal("std::vector<SpecificPFMETData>::pointer"))
  .AddTypedef(type_13954, Reflex::Literal("std::vector<SpecificPFMETData>::const_pointer"))
  .AddTypedef(type_13956, Reflex::Literal("std::vector<SpecificPFMETData>::reference"))
  .AddTypedef(type_13958, Reflex::Literal("std::vector<SpecificPFMETData>::const_reference"))
  .AddTypedef(type_8162, Reflex::Literal("std::vector<SpecificPFMETData>::iterator"))
  .AddTypedef(type_8163, Reflex::Literal("std::vector<SpecificPFMETData>::const_iterator"))
  .AddTypedef(type_3607, Reflex::Literal("std::vector<SpecificPFMETData>::const_reverse_iterator"))
  .AddTypedef(type_3608, Reflex::Literal("std::vector<SpecificPFMETData>::reverse_iterator"))
  .AddTypedef(type_3394, Reflex::Literal("std::vector<SpecificPFMETData>::size_type"))
  .AddTypedef(type_3290, Reflex::Literal("std::vector<SpecificPFMETData>::difference_type"))
  .AddTypedef(type_3421, Reflex::Literal("std::vector<SpecificPFMETData>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_13967, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31669), Reflex::Literal("vector"), constructor_13968, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3394, type_13958, type_31669), Reflex::Literal("vector"), constructor_13969, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32826), Reflex::Literal("vector"), constructor_13970, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_13971, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3151, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x48, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x49, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_SpecificPFMETData__funcmem_bld);
}

//------Delayed data member builder for class vector<SpecificPFMETData,std::allocator<SpecificPFMETData> > -------------------
void __std__vector_SpecificPFMETData__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<SpecificPFMETData,std::allocator<SpecificPFMETData> > -------------------
void __std__vector_SpecificPFMETData__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32827, type_32826), Reflex::Literal("operator="), operator_13972, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394, type_13958), Reflex::Literal("assign"), method_13973, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8162), Reflex::Literal("begin"), method_13974, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8163), Reflex::Literal("begin"), method_13975, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8162), Reflex::Literal("end"), method_13976, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8163), Reflex::Literal("end"), method_13977, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("size"), method_13982, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("max_size"), method_13983, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394, type_468), Reflex::Literal("resize"), method_13984, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("capacity"), method_13985, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("empty"), method_13986, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394), Reflex::Literal("reserve"), method_13987, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13956, type_3394), Reflex::Literal("operator[]"), operator_13988, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13958, type_3394), Reflex::Literal("operator[]"), operator_13989, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13956, type_3394), Reflex::Literal("at"), method_13991, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13958, type_3394), Reflex::Literal("at"), method_13992, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13956), Reflex::Literal("front"), method_13993, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13958), Reflex::Literal("front"), method_13994, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13956), Reflex::Literal("back"), method_13995, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13958), Reflex::Literal("back"), method_13996, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13952), Reflex::Literal("data"), method_13997, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13954), Reflex::Literal("data"), method_13998, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_13958), Reflex::Literal("push_back"), method_13999, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("pop_back"), method_14000, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8162, type_8162, type_13958), Reflex::Literal("insert"), method_14001, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_8162, type_3394, type_13958), Reflex::Literal("insert"), method_14002, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8162, type_8162), Reflex::Literal("erase"), method_14003, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8162, type_8162, type_8162), Reflex::Literal("erase"), method_14004, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_32827), Reflex::Literal("swap"), method_14005, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("clear"), method_14006, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<SpecificCaloMETData,std::allocator<SpecificCaloMETData> > -------------------------------
static void constructor_14032( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SpecificCaloMETData>();
  else ::new(mem) ::std::vector<SpecificCaloMETData>();
}

static void constructor_14033( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SpecificCaloMETData>(*(const ::std::allocator<SpecificCaloMETData>*)arg[0]);
  else ::new(mem) ::std::vector<SpecificCaloMETData>(*(const ::std::allocator<SpecificCaloMETData>*)arg[0]);
}

static void constructor_14034( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SpecificCaloMETData>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<SpecificCaloMETData>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SpecificCaloMETData>(*(::std::size_t*)arg[0],
      *(const ::SpecificCaloMETData*)arg[1]);
  else ::new(mem) ::std::vector<SpecificCaloMETData>(*(::std::size_t*)arg[0],
      *(const ::SpecificCaloMETData*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SpecificCaloMETData>(*(::std::size_t*)arg[0],
      *(const ::SpecificCaloMETData*)arg[1],
      *(const ::std::allocator<SpecificCaloMETData>*)arg[2]);
  else ::new(mem) ::std::vector<SpecificCaloMETData>(*(::std::size_t*)arg[0],
      *(const ::SpecificCaloMETData*)arg[1],
      *(const ::std::allocator<SpecificCaloMETData>*)arg[2]);
  }
}

static void constructor_14035( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<SpecificCaloMETData>(*(const ::std::vector<SpecificCaloMETData>*)arg[0]);
  else ::new(mem) ::std::vector<SpecificCaloMETData>(*(const ::std::vector<SpecificCaloMETData>*)arg[0]);
}

static void destructor_14036(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<SpecificCaloMETData>*)o)->::std::vector<SpecificCaloMETData>::~vector)();
}
static  void operator_14037( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SpecificCaloMETData>*)o)->operator=)(*(const ::std::vector<SpecificCaloMETData>*)arg[0]);
  else   (((::std::vector<SpecificCaloMETData>*)o)->operator=)(*(const ::std::vector<SpecificCaloMETData>*)arg[0]);
}

static  void method_14038( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SpecificCaloMETData>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::SpecificCaloMETData*)arg[1]);
}

static  void method_14039( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SpecificCaloMETData*,std::vector<SpecificCaloMETData> >)((((::std::vector<SpecificCaloMETData>*)o)->begin)());
  else   (((::std::vector<SpecificCaloMETData>*)o)->begin)();
}

static  void method_14040( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const SpecificCaloMETData*,std::vector<SpecificCaloMETData> >)((((const ::std::vector<SpecificCaloMETData>*)o)->begin)());
  else   (((const ::std::vector<SpecificCaloMETData>*)o)->begin)();
}

static  void method_14041( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SpecificCaloMETData*,std::vector<SpecificCaloMETData> >)((((::std::vector<SpecificCaloMETData>*)o)->end)());
  else   (((::std::vector<SpecificCaloMETData>*)o)->end)();
}

static  void method_14042( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const SpecificCaloMETData*,std::vector<SpecificCaloMETData> >)((((const ::std::vector<SpecificCaloMETData>*)o)->end)());
  else   (((const ::std::vector<SpecificCaloMETData>*)o)->end)();
}

static  void method_14047( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<SpecificCaloMETData>*)o)->size)());
  else   (((const ::std::vector<SpecificCaloMETData>*)o)->size)();
}

static  void method_14048( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<SpecificCaloMETData>*)o)->max_size)());
  else   (((const ::std::vector<SpecificCaloMETData>*)o)->max_size)();
}

static  void method_14049( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<SpecificCaloMETData>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<SpecificCaloMETData>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::SpecificCaloMETData*)arg[1]);
  }
}

static  void method_14050( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<SpecificCaloMETData>*)o)->capacity)());
  else   (((const ::std::vector<SpecificCaloMETData>*)o)->capacity)();
}

static  void method_14051( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<SpecificCaloMETData>*)o)->empty)());
  else   (((const ::std::vector<SpecificCaloMETData>*)o)->empty)();
}

static  void method_14052( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SpecificCaloMETData>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_14053( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SpecificCaloMETData>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<SpecificCaloMETData>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_14054( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SpecificCaloMETData>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<SpecificCaloMETData>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_14056( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SpecificCaloMETData>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<SpecificCaloMETData>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14057( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SpecificCaloMETData>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<SpecificCaloMETData>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14058( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SpecificCaloMETData>*)o)->front)();
  else   (((::std::vector<SpecificCaloMETData>*)o)->front)();
}

static  void method_14059( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SpecificCaloMETData>*)o)->front)();
  else   (((const ::std::vector<SpecificCaloMETData>*)o)->front)();
}

static  void method_14060( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<SpecificCaloMETData>*)o)->back)();
  else   (((::std::vector<SpecificCaloMETData>*)o)->back)();
}

static  void method_14061( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<SpecificCaloMETData>*)o)->back)();
  else   (((const ::std::vector<SpecificCaloMETData>*)o)->back)();
}

static  void method_14062( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<SpecificCaloMETData>*)o)->data)());
  else   (((::std::vector<SpecificCaloMETData>*)o)->data)();
}

static  void method_14063( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<SpecificCaloMETData>*)o)->data)());
  else   (((const ::std::vector<SpecificCaloMETData>*)o)->data)();
}

static  void method_14064( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SpecificCaloMETData>*)o)->push_back)(*(const ::SpecificCaloMETData*)arg[0]);
}

static  void method_14065( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<SpecificCaloMETData>*)o)->pop_back)();
}

static  void method_14066( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SpecificCaloMETData*,std::vector<SpecificCaloMETData> >)((((::std::vector<SpecificCaloMETData>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<SpecificCaloMETData*,std::vector<SpecificCaloMETData> >*)arg[0],
    *(const ::SpecificCaloMETData*)arg[1]));
  else   (((::std::vector<SpecificCaloMETData>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<SpecificCaloMETData*,std::vector<SpecificCaloMETData> >*)arg[0],
    *(const ::SpecificCaloMETData*)arg[1]);
}

static  void method_14067( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SpecificCaloMETData>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<SpecificCaloMETData*,std::vector<SpecificCaloMETData> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::SpecificCaloMETData*)arg[2]);
}

static  void method_14068( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SpecificCaloMETData*,std::vector<SpecificCaloMETData> >)((((::std::vector<SpecificCaloMETData>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SpecificCaloMETData*,std::vector<SpecificCaloMETData> >*)arg[0]));
  else   (((::std::vector<SpecificCaloMETData>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SpecificCaloMETData*,std::vector<SpecificCaloMETData> >*)arg[0]);
}

static  void method_14069( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<SpecificCaloMETData*,std::vector<SpecificCaloMETData> >)((((::std::vector<SpecificCaloMETData>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SpecificCaloMETData*,std::vector<SpecificCaloMETData> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<SpecificCaloMETData*,std::vector<SpecificCaloMETData> >*)arg[1]));
  else   (((::std::vector<SpecificCaloMETData>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<SpecificCaloMETData*,std::vector<SpecificCaloMETData> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<SpecificCaloMETData*,std::vector<SpecificCaloMETData> >*)arg[1]);
}

static  void method_14070( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<SpecificCaloMETData>*)o)->swap)(*(::std::vector<SpecificCaloMETData>*)arg[0]);
}

static  void method_14071( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<SpecificCaloMETData>*)o)->clear)();
}

static void method_newdel_3152( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<SpecificCaloMETData> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<SpecificCaloMETData> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<SpecificCaloMETData> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<SpecificCaloMETData> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<SpecificCaloMETData> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x51( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<SpecificCaloMETData,std::allocator<SpecificCaloMETData> >")), ::Reflex::BaseOffset< ::std::vector<SpecificCaloMETData>,::std::_Vector_base<SpecificCaloMETData,std::allocator<SpecificCaloMETData> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x52( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<SpecificCaloMETData> >::Generate();
  else ::Reflex::Proxy< ::std::vector<SpecificCaloMETData> >::Generate();
}

//------Dictionary for class vector<SpecificCaloMETData,std::allocator<SpecificCaloMETData> > -------------------------------
void __std__vector_SpecificCaloMETData__db_datamem(Reflex::Class*);
void __std__vector_SpecificCaloMETData__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_SpecificCaloMETData__datamem_bld(&__std__vector_SpecificCaloMETData__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_SpecificCaloMETData__funcmem_bld(&__std__vector_SpecificCaloMETData__db_funcmem);
void __std__vector_SpecificCaloMETData__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<SpecificCaloMETData>"), typeid(::std::vector<SpecificCaloMETData>), sizeof(::std::vector<SpecificCaloMETData>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2596, ::Reflex::BaseOffset< ::std::vector<SpecificCaloMETData>, ::std::_Vector_base<SpecificCaloMETData,std::allocator<SpecificCaloMETData> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_930, Reflex::Literal("std::vector<SpecificCaloMETData>::_Alloc_value_type"))
  .AddTypedef(type_2596, Reflex::Literal("std::vector<SpecificCaloMETData>::_Base"))
  .AddTypedef(type_3422, Reflex::Literal("std::vector<SpecificCaloMETData>::_Tp_alloc_type"))
  .AddTypedef(type_930, Reflex::Literal("std::vector<SpecificCaloMETData>::value_type"))
  .AddTypedef(type_14017, Reflex::Literal("std::vector<SpecificCaloMETData>::pointer"))
  .AddTypedef(type_14019, Reflex::Literal("std::vector<SpecificCaloMETData>::const_pointer"))
  .AddTypedef(type_14021, Reflex::Literal("std::vector<SpecificCaloMETData>::reference"))
  .AddTypedef(type_14023, Reflex::Literal("std::vector<SpecificCaloMETData>::const_reference"))
  .AddTypedef(type_8164, Reflex::Literal("std::vector<SpecificCaloMETData>::iterator"))
  .AddTypedef(type_8165, Reflex::Literal("std::vector<SpecificCaloMETData>::const_iterator"))
  .AddTypedef(type_3609, Reflex::Literal("std::vector<SpecificCaloMETData>::const_reverse_iterator"))
  .AddTypedef(type_3610, Reflex::Literal("std::vector<SpecificCaloMETData>::reverse_iterator"))
  .AddTypedef(type_3394, Reflex::Literal("std::vector<SpecificCaloMETData>::size_type"))
  .AddTypedef(type_3290, Reflex::Literal("std::vector<SpecificCaloMETData>::difference_type"))
  .AddTypedef(type_3422, Reflex::Literal("std::vector<SpecificCaloMETData>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_14032, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31681), Reflex::Literal("vector"), constructor_14033, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3394, type_14023, type_31681), Reflex::Literal("vector"), constructor_14034, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32829), Reflex::Literal("vector"), constructor_14035, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_14036, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3152, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x51, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x52, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_SpecificCaloMETData__funcmem_bld);
}

//------Delayed data member builder for class vector<SpecificCaloMETData,std::allocator<SpecificCaloMETData> > -------------------
void __std__vector_SpecificCaloMETData__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<SpecificCaloMETData,std::allocator<SpecificCaloMETData> > -------------------
void __std__vector_SpecificCaloMETData__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32830, type_32829), Reflex::Literal("operator="), operator_14037, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394, type_14023), Reflex::Literal("assign"), method_14038, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8164), Reflex::Literal("begin"), method_14039, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8165), Reflex::Literal("begin"), method_14040, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8164), Reflex::Literal("end"), method_14041, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8165), Reflex::Literal("end"), method_14042, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("size"), method_14047, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("max_size"), method_14048, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394, type_930), Reflex::Literal("resize"), method_14049, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("capacity"), method_14050, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("empty"), method_14051, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394), Reflex::Literal("reserve"), method_14052, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14021, type_3394), Reflex::Literal("operator[]"), operator_14053, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14023, type_3394), Reflex::Literal("operator[]"), operator_14054, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14021, type_3394), Reflex::Literal("at"), method_14056, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14023, type_3394), Reflex::Literal("at"), method_14057, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14021), Reflex::Literal("front"), method_14058, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14023), Reflex::Literal("front"), method_14059, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14021), Reflex::Literal("back"), method_14060, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14023), Reflex::Literal("back"), method_14061, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14017), Reflex::Literal("data"), method_14062, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14019), Reflex::Literal("data"), method_14063, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_14023), Reflex::Literal("push_back"), method_14064, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("pop_back"), method_14065, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8164, type_8164, type_14023), Reflex::Literal("insert"), method_14066, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_8164, type_3394, type_14023), Reflex::Literal("insert"), method_14067, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8164, type_8164), Reflex::Literal("erase"), method_14068, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8164, type_8164, type_8164), Reflex::Literal("erase"), method_14069, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_32830), Reflex::Literal("swap"), method_14070, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("clear"), method_14071, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class HcalNoiseHPD -------------------------------
static  void operator_28340( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::HcalNoiseHPD*)o)->operator=)(*(const ::reco::HcalNoiseHPD*)arg[0]);
  else   (((::reco::HcalNoiseHPD*)o)->operator=)(*(const ::reco::HcalNoiseHPD*)arg[0]);
}

static void constructor_28341( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::HcalNoiseHPD(*(const ::reco::HcalNoiseHPD*)arg[0]);
  else ::new(mem) ::reco::HcalNoiseHPD(*(const ::reco::HcalNoiseHPD*)arg[0]);
}

static void constructor_28342( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::HcalNoiseHPD();
  else ::new(mem) ::reco::HcalNoiseHPD();
}

static void destructor_28343(void*, void * o, const std::vector<void*>&, void *) {
(((::reco::HcalNoiseHPD*)o)->::reco::HcalNoiseHPD::~HcalNoiseHPD)();
}
static  void method_28344( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::reco::HcalNoiseHPD*)o)->idnumber)());
  else   (((const ::reco::HcalNoiseHPD*)o)->idnumber)();
}

static  void method_28345( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<float>)((((const ::reco::HcalNoiseHPD*)o)->bigCharge)());
  else   (((const ::reco::HcalNoiseHPD*)o)->bigCharge)();
}

static  void method_28346( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::HcalNoiseHPD*)o)->bigChargeTotal)());
  else   (((const ::reco::HcalNoiseHPD*)o)->bigChargeTotal)();
}

static  void method_28347( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (float)((((const ::reco::HcalNoiseHPD*)o)->bigChargeHighest2TS)());
    else     (((const ::reco::HcalNoiseHPD*)o)->bigChargeHighest2TS)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (float)((((const ::reco::HcalNoiseHPD*)o)->bigChargeHighest2TS)(*(unsigned int*)arg[0]));
    else     (((const ::reco::HcalNoiseHPD*)o)->bigChargeHighest2TS)(*(unsigned int*)arg[0]);
  }
}

static  void method_28348( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (float)((((const ::reco::HcalNoiseHPD*)o)->bigChargeHighest3TS)());
    else     (((const ::reco::HcalNoiseHPD*)o)->bigChargeHighest3TS)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (float)((((const ::reco::HcalNoiseHPD*)o)->bigChargeHighest3TS)(*(unsigned int*)arg[0]));
    else     (((const ::reco::HcalNoiseHPD*)o)->bigChargeHighest3TS)(*(unsigned int*)arg[0]);
  }
}

static  void method_28349( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<float>)((((const ::reco::HcalNoiseHPD*)o)->big5Charge)());
  else   (((const ::reco::HcalNoiseHPD*)o)->big5Charge)();
}

static  void method_28350( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::HcalNoiseHPD*)o)->big5ChargeTotal)());
  else   (((const ::reco::HcalNoiseHPD*)o)->big5ChargeTotal)();
}

static  void method_28351( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (float)((((const ::reco::HcalNoiseHPD*)o)->big5ChargeHighest2TS)());
    else     (((const ::reco::HcalNoiseHPD*)o)->big5ChargeHighest2TS)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (float)((((const ::reco::HcalNoiseHPD*)o)->big5ChargeHighest2TS)(*(unsigned int*)arg[0]));
    else     (((const ::reco::HcalNoiseHPD*)o)->big5ChargeHighest2TS)(*(unsigned int*)arg[0]);
  }
}

static  void method_28352( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (float)((((const ::reco::HcalNoiseHPD*)o)->big5ChargeHighest3TS)());
    else     (((const ::reco::HcalNoiseHPD*)o)->big5ChargeHighest3TS)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (float)((((const ::reco::HcalNoiseHPD*)o)->big5ChargeHighest3TS)(*(unsigned int*)arg[0]));
    else     (((const ::reco::HcalNoiseHPD*)o)->big5ChargeHighest3TS)(*(unsigned int*)arg[0]);
  }
}

static  void method_28353( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::reco::HcalNoiseHPD*)o)->totalZeros)());
  else   (((const ::reco::HcalNoiseHPD*)o)->totalZeros)();
}

static  void method_28354( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::reco::HcalNoiseHPD*)o)->maxZeros)());
  else   (((const ::reco::HcalNoiseHPD*)o)->maxZeros)();
}

static  void method_28355( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVector<edm::SortedCollection<HBHERecHit,edm::StrictWeakOrdering<HBHERecHit> >,HBHERecHit,edm::refhelper::FindUsingAdvance<edm::SortedCollection<HBHERecHit,edm::StrictWeakOrdering<HBHERecHit> >,HBHERecHit> >)((((const ::reco::HcalNoiseHPD*)o)->recHits)());
  else   (((const ::reco::HcalNoiseHPD*)o)->recHits)();
}

static  void method_28356( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (float)((((const ::reco::HcalNoiseHPD*)o)->recHitEnergy)());
    else     (((const ::reco::HcalNoiseHPD*)o)->recHitEnergy)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (float)((((const ::reco::HcalNoiseHPD*)o)->recHitEnergy)(*(float*)arg[0]));
    else     (((const ::reco::HcalNoiseHPD*)o)->recHitEnergy)(*(float*)arg[0]);
  }
}

static  void method_28357( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (float)((((const ::reco::HcalNoiseHPD*)o)->minRecHitTime)());
    else     (((const ::reco::HcalNoiseHPD*)o)->minRecHitTime)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (float)((((const ::reco::HcalNoiseHPD*)o)->minRecHitTime)(*(float*)arg[0]));
    else     (((const ::reco::HcalNoiseHPD*)o)->minRecHitTime)(*(float*)arg[0]);
  }
}

static  void method_28358( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (float)((((const ::reco::HcalNoiseHPD*)o)->maxRecHitTime)());
    else     (((const ::reco::HcalNoiseHPD*)o)->maxRecHitTime)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (float)((((const ::reco::HcalNoiseHPD*)o)->maxRecHitTime)(*(float*)arg[0]));
    else     (((const ::reco::HcalNoiseHPD*)o)->maxRecHitTime)(*(float*)arg[0]);
  }
}

static  void method_28359( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (int)((((const ::reco::HcalNoiseHPD*)o)->numRecHits)());
    else     (((const ::reco::HcalNoiseHPD*)o)->numRecHits)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (int)((((const ::reco::HcalNoiseHPD*)o)->numRecHits)(*(float*)arg[0]));
    else     (((const ::reco::HcalNoiseHPD*)o)->numRecHits)(*(float*)arg[0]);
  }
}

static  void method_28360( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVector<edm::SortedCollection<CaloTower,edm::StrictWeakOrdering<CaloTower> >,CaloTower,edm::refhelper::FindUsingAdvance<edm::SortedCollection<CaloTower,edm::StrictWeakOrdering<CaloTower> >,CaloTower> >)((((const ::reco::HcalNoiseHPD*)o)->caloTowers)());
  else   (((const ::reco::HcalNoiseHPD*)o)->caloTowers)();
}

static  void method_28361( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::HcalNoiseHPD*)o)->caloTowerHadE)());
  else   (((const ::reco::HcalNoiseHPD*)o)->caloTowerHadE)();
}

static  void method_28362( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::HcalNoiseHPD*)o)->caloTowerEmE)());
  else   (((const ::reco::HcalNoiseHPD*)o)->caloTowerEmE)();
}

static  void method_28363( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::HcalNoiseHPD*)o)->caloTowerTotalE)());
  else   (((const ::reco::HcalNoiseHPD*)o)->caloTowerTotalE)();
}

static  void method_28364( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::HcalNoiseHPD*)o)->caloTowerEmFraction)());
  else   (((const ::reco::HcalNoiseHPD*)o)->caloTowerEmFraction)();
}

static void method_newdel_8033( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::reco::HcalNoiseHPD >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::reco::HcalNoiseHPD >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::reco::HcalNoiseHPD >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::reco::HcalNoiseHPD >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::reco::HcalNoiseHPD >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HcalNoiseHPD -------------------------------
void __reco__HcalNoiseHPD_db_datamem(Reflex::Class*);
void __reco__HcalNoiseHPD_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __reco__HcalNoiseHPD_datamem_bld(&__reco__HcalNoiseHPD_db_datamem);
Reflex::GenreflexMemberBuilder __reco__HcalNoiseHPD_funcmem_bld(&__reco__HcalNoiseHPD_db_funcmem);
void __reco__HcalNoiseHPD_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("reco::HcalNoiseHPD"), typeid(::reco::HcalNoiseHPD), sizeof(::reco::HcalNoiseHPD), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14150, type_10363), Reflex::Literal("operator="), operator_28340, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10363), Reflex::Literal("HcalNoiseHPD"), constructor_28341, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalNoiseHPD"), constructor_28342, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalNoiseHPD"), destructor_28343, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_8033, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__reco__HcalNoiseHPD_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__reco__HcalNoiseHPD_funcmem_bld);
}

//------Delayed data member builder for class HcalNoiseHPD -------------------
void __reco__HcalNoiseHPD_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_72, Reflex::Literal("idnumber_"), OffsetOf(__shadow__::__reco__HcalNoiseHPD, idnumber_), ::Reflex::PRIVATE)
  .AddDataMember(type_72, Reflex::Literal("totalZeros_"), OffsetOf(__shadow__::__reco__HcalNoiseHPD, totalZeros_), ::Reflex::PRIVATE)
  .AddDataMember(type_72, Reflex::Literal("maxZeros_"), OffsetOf(__shadow__::__reco__HcalNoiseHPD, maxZeros_), ::Reflex::PRIVATE)
  .AddDataMember(type_3165, Reflex::Literal("bigCharge_"), OffsetOf(__shadow__::__reco__HcalNoiseHPD, bigCharge_), ::Reflex::PRIVATE)
  .AddDataMember(type_3165, Reflex::Literal("big5Charge_"), OffsetOf(__shadow__::__reco__HcalNoiseHPD, big5Charge_), ::Reflex::PRIVATE)
  .AddDataMember(type_4675, Reflex::Literal("rechits_"), OffsetOf(__shadow__::__reco__HcalNoiseHPD, rechits_), ::Reflex::PRIVATE)
  .AddDataMember(type_2730, Reflex::Literal("refrechitset_"), OffsetOf(__shadow__::__reco__HcalNoiseHPD, refrechitset_), ::Reflex::PRIVATE | ::Reflex::TRANSIENT)
  .AddDataMember(type_1948, Reflex::Literal("calotowers_"), OffsetOf(__shadow__::__reco__HcalNoiseHPD, calotowers_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class HcalNoiseHPD -------------------
void __reco__HcalNoiseHPD_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("idnumber"), method_28344, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3165c), Reflex::Literal("bigCharge"), method_28345, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("bigChargeTotal"), method_28346, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932, type_373), Reflex::Literal("bigChargeHighest2TS"), method_28347, 0, "firstts=4", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932, type_373), Reflex::Literal("bigChargeHighest3TS"), method_28348, 0, "firstts=4", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3165c), Reflex::Literal("big5Charge"), method_28349, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("big5ChargeTotal"), method_28350, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932, type_373), Reflex::Literal("big5ChargeHighest2TS"), method_28351, 0, "firstts=4", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932, type_373), Reflex::Literal("big5ChargeHighest3TS"), method_28352, 0, "firstts=4", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("totalZeros"), method_28353, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("maxZeros"), method_28354, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4675c), Reflex::Literal("recHits"), method_28355, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932, type_932), Reflex::Literal("recHitEnergy"), method_28356, 0, "threshold=1.5e+0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932, type_932), Reflex::Literal("minRecHitTime"), method_28357, 0, "threshold=1.0e+1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932, type_932), Reflex::Literal("maxRecHitTime"), method_28358, 0, "threshold=1.0e+1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72, type_932), Reflex::Literal("numRecHits"), method_28359, 0, "threshold=1.5e+0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1948c), Reflex::Literal("caloTowers"), method_28360, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("caloTowerHadE"), method_28361, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("caloTowerEmE"), method_28362, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("caloTowerTotalE"), method_28363, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("caloTowerEmFraction"), method_28364, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class vector<reco::HcalNoiseHPD,std::allocator<reco::HcalNoiseHPD> > -------------------------------
static void constructor_14160( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::HcalNoiseHPD>();
  else ::new(mem) ::std::vector<reco::HcalNoiseHPD>();
}

static void constructor_14161( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::HcalNoiseHPD>(*(const ::std::allocator<reco::HcalNoiseHPD>*)arg[0]);
  else ::new(mem) ::std::vector<reco::HcalNoiseHPD>(*(const ::std::allocator<reco::HcalNoiseHPD>*)arg[0]);
}

static void constructor_14162( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::HcalNoiseHPD>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<reco::HcalNoiseHPD>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::HcalNoiseHPD>(*(::std::size_t*)arg[0],
      *(const ::reco::HcalNoiseHPD*)arg[1]);
  else ::new(mem) ::std::vector<reco::HcalNoiseHPD>(*(::std::size_t*)arg[0],
      *(const ::reco::HcalNoiseHPD*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::HcalNoiseHPD>(*(::std::size_t*)arg[0],
      *(const ::reco::HcalNoiseHPD*)arg[1],
      *(const ::std::allocator<reco::HcalNoiseHPD>*)arg[2]);
  else ::new(mem) ::std::vector<reco::HcalNoiseHPD>(*(::std::size_t*)arg[0],
      *(const ::reco::HcalNoiseHPD*)arg[1],
      *(const ::std::allocator<reco::HcalNoiseHPD>*)arg[2]);
  }
}

static void constructor_14163( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::HcalNoiseHPD>(*(const ::std::vector<reco::HcalNoiseHPD>*)arg[0]);
  else ::new(mem) ::std::vector<reco::HcalNoiseHPD>(*(const ::std::vector<reco::HcalNoiseHPD>*)arg[0]);
}

static void destructor_14164(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<reco::HcalNoiseHPD>*)o)->::std::vector<reco::HcalNoiseHPD>::~vector)();
}
static  void operator_14165( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::HcalNoiseHPD>*)o)->operator=)(*(const ::std::vector<reco::HcalNoiseHPD>*)arg[0]);
  else   (((::std::vector<reco::HcalNoiseHPD>*)o)->operator=)(*(const ::std::vector<reco::HcalNoiseHPD>*)arg[0]);
}

static  void method_14166( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::HcalNoiseHPD>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::reco::HcalNoiseHPD*)arg[1]);
}

static  void method_14167( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >)((((::std::vector<reco::HcalNoiseHPD>*)o)->begin)());
  else   (((::std::vector<reco::HcalNoiseHPD>*)o)->begin)();
}

static  void method_14168( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >)((((const ::std::vector<reco::HcalNoiseHPD>*)o)->begin)());
  else   (((const ::std::vector<reco::HcalNoiseHPD>*)o)->begin)();
}

static  void method_14169( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >)((((::std::vector<reco::HcalNoiseHPD>*)o)->end)());
  else   (((::std::vector<reco::HcalNoiseHPD>*)o)->end)();
}

static  void method_14170( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >)((((const ::std::vector<reco::HcalNoiseHPD>*)o)->end)());
  else   (((const ::std::vector<reco::HcalNoiseHPD>*)o)->end)();
}

static  void method_14175( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::HcalNoiseHPD>*)o)->size)());
  else   (((const ::std::vector<reco::HcalNoiseHPD>*)o)->size)();
}

static  void method_14176( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::HcalNoiseHPD>*)o)->max_size)());
  else   (((const ::std::vector<reco::HcalNoiseHPD>*)o)->max_size)();
}

static  void method_14177( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<reco::HcalNoiseHPD>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<reco::HcalNoiseHPD>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::reco::HcalNoiseHPD*)arg[1]);
  }
}

static  void method_14178( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::HcalNoiseHPD>*)o)->capacity)());
  else   (((const ::std::vector<reco::HcalNoiseHPD>*)o)->capacity)();
}

static  void method_14179( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<reco::HcalNoiseHPD>*)o)->empty)());
  else   (((const ::std::vector<reco::HcalNoiseHPD>*)o)->empty)();
}

static  void method_14180( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::HcalNoiseHPD>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_14181( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::HcalNoiseHPD>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::HcalNoiseHPD>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_14182( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::HcalNoiseHPD>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::HcalNoiseHPD>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_14184( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::HcalNoiseHPD>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::HcalNoiseHPD>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14185( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::HcalNoiseHPD>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::HcalNoiseHPD>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14186( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::HcalNoiseHPD>*)o)->front)();
  else   (((::std::vector<reco::HcalNoiseHPD>*)o)->front)();
}

static  void method_14187( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::HcalNoiseHPD>*)o)->front)();
  else   (((const ::std::vector<reco::HcalNoiseHPD>*)o)->front)();
}

static  void method_14188( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::HcalNoiseHPD>*)o)->back)();
  else   (((::std::vector<reco::HcalNoiseHPD>*)o)->back)();
}

static  void method_14189( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::HcalNoiseHPD>*)o)->back)();
  else   (((const ::std::vector<reco::HcalNoiseHPD>*)o)->back)();
}

static  void method_14190( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<reco::HcalNoiseHPD>*)o)->data)());
  else   (((::std::vector<reco::HcalNoiseHPD>*)o)->data)();
}

static  void method_14191( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<reco::HcalNoiseHPD>*)o)->data)());
  else   (((const ::std::vector<reco::HcalNoiseHPD>*)o)->data)();
}

static  void method_14192( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::HcalNoiseHPD>*)o)->push_back)(*(const ::reco::HcalNoiseHPD*)arg[0]);
}

static  void method_14193( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::HcalNoiseHPD>*)o)->pop_back)();
}

static  void method_14194( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >)((((::std::vector<reco::HcalNoiseHPD>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >*)arg[0],
    *(const ::reco::HcalNoiseHPD*)arg[1]));
  else   (((::std::vector<reco::HcalNoiseHPD>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >*)arg[0],
    *(const ::reco::HcalNoiseHPD*)arg[1]);
}

static  void method_14195( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::HcalNoiseHPD>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::reco::HcalNoiseHPD*)arg[2]);
}

static  void method_14196( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >)((((::std::vector<reco::HcalNoiseHPD>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >*)arg[0]));
  else   (((::std::vector<reco::HcalNoiseHPD>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >*)arg[0]);
}

static  void method_14197( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >)((((::std::vector<reco::HcalNoiseHPD>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >*)arg[1]));
  else   (((::std::vector<reco::HcalNoiseHPD>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >*)arg[1]);
}

static  void method_14198( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::HcalNoiseHPD>*)o)->swap)(*(::std::vector<reco::HcalNoiseHPD>*)arg[0]);
}

static  void method_14199( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::HcalNoiseHPD>*)o)->clear)();
}

static void method_newdel_3154( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<reco::HcalNoiseHPD> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<reco::HcalNoiseHPD> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<reco::HcalNoiseHPD> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<reco::HcalNoiseHPD> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<reco::HcalNoiseHPD> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x55( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::HcalNoiseHPD,std::allocator<reco::HcalNoiseHPD> >")), ::Reflex::BaseOffset< ::std::vector<reco::HcalNoiseHPD>,::std::_Vector_base<reco::HcalNoiseHPD,std::allocator<reco::HcalNoiseHPD> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x56( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<reco::HcalNoiseHPD> >::Generate();
  else ::Reflex::Proxy< ::std::vector<reco::HcalNoiseHPD> >::Generate();
}

//------Dictionary for class vector<reco::HcalNoiseHPD,std::allocator<reco::HcalNoiseHPD> > -------------------------------
void __std__vector_reco__HcalNoiseHPD__db_datamem(Reflex::Class*);
void __std__vector_reco__HcalNoiseHPD__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_reco__HcalNoiseHPD__datamem_bld(&__std__vector_reco__HcalNoiseHPD__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_reco__HcalNoiseHPD__funcmem_bld(&__std__vector_reco__HcalNoiseHPD__db_funcmem);
void __std__vector_reco__HcalNoiseHPD__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<reco::HcalNoiseHPD>"), typeid(::std::vector<reco::HcalNoiseHPD>), sizeof(::std::vector<reco::HcalNoiseHPD>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2611, ::Reflex::BaseOffset< ::std::vector<reco::HcalNoiseHPD>, ::std::_Vector_base<reco::HcalNoiseHPD,std::allocator<reco::HcalNoiseHPD> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_8033, Reflex::Literal("std::vector<reco::HcalNoiseHPD>::_Alloc_value_type"))
  .AddTypedef(type_2611, Reflex::Literal("std::vector<reco::HcalNoiseHPD>::_Base"))
  .AddTypedef(type_3425, Reflex::Literal("std::vector<reco::HcalNoiseHPD>::_Tp_alloc_type"))
  .AddTypedef(type_8033, Reflex::Literal("std::vector<reco::HcalNoiseHPD>::value_type"))
  .AddTypedef(type_14147, Reflex::Literal("std::vector<reco::HcalNoiseHPD>::pointer"))
  .AddTypedef(type_10361, Reflex::Literal("std::vector<reco::HcalNoiseHPD>::const_pointer"))
  .AddTypedef(type_14150, Reflex::Literal("std::vector<reco::HcalNoiseHPD>::reference"))
  .AddTypedef(type_10363, Reflex::Literal("std::vector<reco::HcalNoiseHPD>::const_reference"))
  .AddTypedef(type_8191, Reflex::Literal("std::vector<reco::HcalNoiseHPD>::iterator"))
  .AddTypedef(type_8190, Reflex::Literal("std::vector<reco::HcalNoiseHPD>::const_iterator"))
  .AddTypedef(type_3639, Reflex::Literal("std::vector<reco::HcalNoiseHPD>::const_reverse_iterator"))
  .AddTypedef(type_3640, Reflex::Literal("std::vector<reco::HcalNoiseHPD>::reverse_iterator"))
  .AddTypedef(type_3394, Reflex::Literal("std::vector<reco::HcalNoiseHPD>::size_type"))
  .AddTypedef(type_3290, Reflex::Literal("std::vector<reco::HcalNoiseHPD>::difference_type"))
  .AddTypedef(type_3425, Reflex::Literal("std::vector<reco::HcalNoiseHPD>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_14160, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31861), Reflex::Literal("vector"), constructor_14161, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3394, type_10363, type_31861), Reflex::Literal("vector"), constructor_14162, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32834), Reflex::Literal("vector"), constructor_14163, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_14164, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3154, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x55, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x56, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_reco__HcalNoiseHPD__funcmem_bld);
}

//------Delayed data member builder for class vector<reco::HcalNoiseHPD,std::allocator<reco::HcalNoiseHPD> > -------------------
void __std__vector_reco__HcalNoiseHPD__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<reco::HcalNoiseHPD,std::allocator<reco::HcalNoiseHPD> > -------------------
void __std__vector_reco__HcalNoiseHPD__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32835, type_32834), Reflex::Literal("operator="), operator_14165, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394, type_10363), Reflex::Literal("assign"), method_14166, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8191), Reflex::Literal("begin"), method_14167, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8190), Reflex::Literal("begin"), method_14168, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8191), Reflex::Literal("end"), method_14169, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8190), Reflex::Literal("end"), method_14170, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("size"), method_14175, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("max_size"), method_14176, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394, type_8033), Reflex::Literal("resize"), method_14177, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("capacity"), method_14178, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("empty"), method_14179, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394), Reflex::Literal("reserve"), method_14180, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14150, type_3394), Reflex::Literal("operator[]"), operator_14181, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10363, type_3394), Reflex::Literal("operator[]"), operator_14182, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14150, type_3394), Reflex::Literal("at"), method_14184, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10363, type_3394), Reflex::Literal("at"), method_14185, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14150), Reflex::Literal("front"), method_14186, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10363), Reflex::Literal("front"), method_14187, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14150), Reflex::Literal("back"), method_14188, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10363), Reflex::Literal("back"), method_14189, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14147), Reflex::Literal("data"), method_14190, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10361), Reflex::Literal("data"), method_14191, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_10363), Reflex::Literal("push_back"), method_14192, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("pop_back"), method_14193, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8191, type_8191, type_10363), Reflex::Literal("insert"), method_14194, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_8191, type_3394, type_10363), Reflex::Literal("insert"), method_14195, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8191, type_8191), Reflex::Literal("erase"), method_14196, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8191, type_8191, type_8191), Reflex::Literal("erase"), method_14197, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_32835), Reflex::Literal("swap"), method_14198, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("clear"), method_14199, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class PFClusterMET -------------------------------
static  void operator_27097( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::PFClusterMET*)o)->operator=)(*(const ::reco::PFClusterMET*)arg[0]);
  else   (((::reco::PFClusterMET*)o)->operator=)(*(const ::reco::PFClusterMET*)arg[0]);
}

static void constructor_27098( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::PFClusterMET(*(const ::reco::PFClusterMET*)arg[0]);
  else ::new(mem) ::reco::PFClusterMET(*(const ::reco::PFClusterMET*)arg[0]);
}

static void constructor_27099( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::PFClusterMET();
  else ::new(mem) ::reco::PFClusterMET();
}

static void constructor_27100( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::PFClusterMET(*(double*)arg[0],
      *(const ::math::XYZTLorentzVector*)arg[1],
      *(const ::math::XYZPoint*)arg[2]);
  else ::new(mem) ::reco::PFClusterMET(*(double*)arg[0],
      *(const ::math::XYZTLorentzVector*)arg[1],
      *(const ::math::XYZPoint*)arg[2]);
}

static void destructor_27101(void*, void * o, const std::vector<void*>&, void *) {
(((::reco::PFClusterMET*)o)->::reco::PFClusterMET::~PFClusterMET)();
}
static void method_newdel_7916( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::reco::PFClusterMET >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::reco::PFClusterMET >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::reco::PFClusterMET >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::reco::PFClusterMET >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::reco::PFClusterMET >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x58( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::MET")), ::Reflex::BaseOffset< ::reco::PFClusterMET,::reco::MET >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::RecoCandidate")), ::Reflex::BaseOffset< ::reco::PFClusterMET,::reco::RecoCandidate >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::reco::PFClusterMET,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::reco::PFClusterMET,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PFClusterMET -------------------------------
void __reco__PFClusterMET_db_datamem(Reflex::Class*);
void __reco__PFClusterMET_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __reco__PFClusterMET_datamem_bld(&__reco__PFClusterMET_db_datamem);
Reflex::GenreflexMemberBuilder __reco__PFClusterMET_funcmem_bld(&__reco__PFClusterMET_db_funcmem);
void __reco__PFClusterMET_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("reco::PFClusterMET"), typeid(::reco::PFClusterMET), sizeof(::reco::PFClusterMET), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddBase(type_7952, ::Reflex::BaseOffset< ::reco::PFClusterMET, ::reco::MET >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14214, type_14216), Reflex::Literal("operator="), operator_27097, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14216), Reflex::Literal("PFClusterMET"), constructor_27098, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PFClusterMET"), constructor_27099, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_107, type_39102, type_39103), Reflex::Literal("PFClusterMET"), constructor_27100, 0, "sumet_;fP4;fVertex", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PFClusterMET"), destructor_27101, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7916, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x58, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL);
}

//------Delayed data member builder for class PFClusterMET -------------------
void __reco__PFClusterMET_db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class PFClusterMET -------------------
void __reco__PFClusterMET_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<reco::PFClusterMET,std::allocator<reco::PFClusterMET> > -------------------------------
static void constructor_14225( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::PFClusterMET>();
  else ::new(mem) ::std::vector<reco::PFClusterMET>();
}

static void constructor_14226( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::PFClusterMET>(*(const ::std::allocator<reco::PFClusterMET>*)arg[0]);
  else ::new(mem) ::std::vector<reco::PFClusterMET>(*(const ::std::allocator<reco::PFClusterMET>*)arg[0]);
}

static void constructor_14227( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::PFClusterMET>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<reco::PFClusterMET>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::PFClusterMET>(*(::std::size_t*)arg[0],
      *(const ::reco::PFClusterMET*)arg[1]);
  else ::new(mem) ::std::vector<reco::PFClusterMET>(*(::std::size_t*)arg[0],
      *(const ::reco::PFClusterMET*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::PFClusterMET>(*(::std::size_t*)arg[0],
      *(const ::reco::PFClusterMET*)arg[1],
      *(const ::std::allocator<reco::PFClusterMET>*)arg[2]);
  else ::new(mem) ::std::vector<reco::PFClusterMET>(*(::std::size_t*)arg[0],
      *(const ::reco::PFClusterMET*)arg[1],
      *(const ::std::allocator<reco::PFClusterMET>*)arg[2]);
  }
}

static void constructor_14228( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::PFClusterMET>(*(const ::std::vector<reco::PFClusterMET>*)arg[0]);
  else ::new(mem) ::std::vector<reco::PFClusterMET>(*(const ::std::vector<reco::PFClusterMET>*)arg[0]);
}

static void destructor_14229(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<reco::PFClusterMET>*)o)->::std::vector<reco::PFClusterMET>::~vector)();
}
static  void operator_14230( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::PFClusterMET>*)o)->operator=)(*(const ::std::vector<reco::PFClusterMET>*)arg[0]);
  else   (((::std::vector<reco::PFClusterMET>*)o)->operator=)(*(const ::std::vector<reco::PFClusterMET>*)arg[0]);
}

static  void method_14231( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::PFClusterMET>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::reco::PFClusterMET*)arg[1]);
}

static  void method_14232( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::PFClusterMET*,std::vector<reco::PFClusterMET> >)((((::std::vector<reco::PFClusterMET>*)o)->begin)());
  else   (((::std::vector<reco::PFClusterMET>*)o)->begin)();
}

static  void method_14233( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::PFClusterMET*,std::vector<reco::PFClusterMET> >)((((const ::std::vector<reco::PFClusterMET>*)o)->begin)());
  else   (((const ::std::vector<reco::PFClusterMET>*)o)->begin)();
}

static  void method_14234( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::PFClusterMET*,std::vector<reco::PFClusterMET> >)((((::std::vector<reco::PFClusterMET>*)o)->end)());
  else   (((::std::vector<reco::PFClusterMET>*)o)->end)();
}

static  void method_14235( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::PFClusterMET*,std::vector<reco::PFClusterMET> >)((((const ::std::vector<reco::PFClusterMET>*)o)->end)());
  else   (((const ::std::vector<reco::PFClusterMET>*)o)->end)();
}

static  void method_14240( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::PFClusterMET>*)o)->size)());
  else   (((const ::std::vector<reco::PFClusterMET>*)o)->size)();
}

static  void method_14241( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::PFClusterMET>*)o)->max_size)());
  else   (((const ::std::vector<reco::PFClusterMET>*)o)->max_size)();
}

static  void method_14242( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<reco::PFClusterMET>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<reco::PFClusterMET>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::reco::PFClusterMET*)arg[1]);
  }
}

static  void method_14243( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::PFClusterMET>*)o)->capacity)());
  else   (((const ::std::vector<reco::PFClusterMET>*)o)->capacity)();
}

static  void method_14244( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<reco::PFClusterMET>*)o)->empty)());
  else   (((const ::std::vector<reco::PFClusterMET>*)o)->empty)();
}

static  void method_14245( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::PFClusterMET>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_14246( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::PFClusterMET>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::PFClusterMET>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_14247( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::PFClusterMET>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::PFClusterMET>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_14249( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::PFClusterMET>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::PFClusterMET>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14250( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::PFClusterMET>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::PFClusterMET>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14251( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::PFClusterMET>*)o)->front)();
  else   (((::std::vector<reco::PFClusterMET>*)o)->front)();
}

static  void method_14252( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::PFClusterMET>*)o)->front)();
  else   (((const ::std::vector<reco::PFClusterMET>*)o)->front)();
}

static  void method_14253( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::PFClusterMET>*)o)->back)();
  else   (((::std::vector<reco::PFClusterMET>*)o)->back)();
}

static  void method_14254( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::PFClusterMET>*)o)->back)();
  else   (((const ::std::vector<reco::PFClusterMET>*)o)->back)();
}

static  void method_14255( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<reco::PFClusterMET>*)o)->data)());
  else   (((::std::vector<reco::PFClusterMET>*)o)->data)();
}

static  void method_14256( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<reco::PFClusterMET>*)o)->data)());
  else   (((const ::std::vector<reco::PFClusterMET>*)o)->data)();
}

static  void method_14257( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::PFClusterMET>*)o)->push_back)(*(const ::reco::PFClusterMET*)arg[0]);
}

static  void method_14258( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::PFClusterMET>*)o)->pop_back)();
}

static  void method_14259( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::PFClusterMET*,std::vector<reco::PFClusterMET> >)((((::std::vector<reco::PFClusterMET>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::PFClusterMET*,std::vector<reco::PFClusterMET> >*)arg[0],
    *(const ::reco::PFClusterMET*)arg[1]));
  else   (((::std::vector<reco::PFClusterMET>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::PFClusterMET*,std::vector<reco::PFClusterMET> >*)arg[0],
    *(const ::reco::PFClusterMET*)arg[1]);
}

static  void method_14260( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::PFClusterMET>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::PFClusterMET*,std::vector<reco::PFClusterMET> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::reco::PFClusterMET*)arg[2]);
}

static  void method_14261( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::PFClusterMET*,std::vector<reco::PFClusterMET> >)((((::std::vector<reco::PFClusterMET>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::PFClusterMET*,std::vector<reco::PFClusterMET> >*)arg[0]));
  else   (((::std::vector<reco::PFClusterMET>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::PFClusterMET*,std::vector<reco::PFClusterMET> >*)arg[0]);
}

static  void method_14262( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::PFClusterMET*,std::vector<reco::PFClusterMET> >)((((::std::vector<reco::PFClusterMET>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::PFClusterMET*,std::vector<reco::PFClusterMET> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::PFClusterMET*,std::vector<reco::PFClusterMET> >*)arg[1]));
  else   (((::std::vector<reco::PFClusterMET>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::PFClusterMET*,std::vector<reco::PFClusterMET> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::PFClusterMET*,std::vector<reco::PFClusterMET> >*)arg[1]);
}

static  void method_14263( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::PFClusterMET>*)o)->swap)(*(::std::vector<reco::PFClusterMET>*)arg[0]);
}

static  void method_14264( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::PFClusterMET>*)o)->clear)();
}

static void method_newdel_3155( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<reco::PFClusterMET> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<reco::PFClusterMET> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<reco::PFClusterMET> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<reco::PFClusterMET> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<reco::PFClusterMET> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x60( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::PFClusterMET,std::allocator<reco::PFClusterMET> >")), ::Reflex::BaseOffset< ::std::vector<reco::PFClusterMET>,::std::_Vector_base<reco::PFClusterMET,std::allocator<reco::PFClusterMET> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x61( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<reco::PFClusterMET> >::Generate();
  else ::Reflex::Proxy< ::std::vector<reco::PFClusterMET> >::Generate();
}

//------Dictionary for class vector<reco::PFClusterMET,std::allocator<reco::PFClusterMET> > -------------------------------
void __std__vector_reco__PFClusterMET__db_datamem(Reflex::Class*);
void __std__vector_reco__PFClusterMET__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_reco__PFClusterMET__datamem_bld(&__std__vector_reco__PFClusterMET__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_reco__PFClusterMET__funcmem_bld(&__std__vector_reco__PFClusterMET__db_funcmem);
void __std__vector_reco__PFClusterMET__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<reco::PFClusterMET>"), typeid(::std::vector<reco::PFClusterMET>), sizeof(::std::vector<reco::PFClusterMET>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2615, ::Reflex::BaseOffset< ::std::vector<reco::PFClusterMET>, ::std::_Vector_base<reco::PFClusterMET,std::allocator<reco::PFClusterMET> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_7916, Reflex::Literal("std::vector<reco::PFClusterMET>::_Alloc_value_type"))
  .AddTypedef(type_2615, Reflex::Literal("std::vector<reco::PFClusterMET>::_Base"))
  .AddTypedef(type_3426, Reflex::Literal("std::vector<reco::PFClusterMET>::_Tp_alloc_type"))
  .AddTypedef(type_7916, Reflex::Literal("std::vector<reco::PFClusterMET>::value_type"))
  .AddTypedef(type_14210, Reflex::Literal("std::vector<reco::PFClusterMET>::pointer"))
  .AddTypedef(type_14212, Reflex::Literal("std::vector<reco::PFClusterMET>::const_pointer"))
  .AddTypedef(type_14214, Reflex::Literal("std::vector<reco::PFClusterMET>::reference"))
  .AddTypedef(type_14216, Reflex::Literal("std::vector<reco::PFClusterMET>::const_reference"))
  .AddTypedef(type_8196, Reflex::Literal("std::vector<reco::PFClusterMET>::iterator"))
  .AddTypedef(type_8197, Reflex::Literal("std::vector<reco::PFClusterMET>::const_iterator"))
  .AddTypedef(type_3649, Reflex::Literal("std::vector<reco::PFClusterMET>::const_reverse_iterator"))
  .AddTypedef(type_3650, Reflex::Literal("std::vector<reco::PFClusterMET>::reverse_iterator"))
  .AddTypedef(type_3394, Reflex::Literal("std::vector<reco::PFClusterMET>::size_type"))
  .AddTypedef(type_3290, Reflex::Literal("std::vector<reco::PFClusterMET>::difference_type"))
  .AddTypedef(type_3426, Reflex::Literal("std::vector<reco::PFClusterMET>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_14225, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31909), Reflex::Literal("vector"), constructor_14226, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3394, type_14216, type_31909), Reflex::Literal("vector"), constructor_14227, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23182), Reflex::Literal("vector"), constructor_14228, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_14229, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3155, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x60, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x61, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_reco__PFClusterMET__funcmem_bld);
}

//------Delayed data member builder for class vector<reco::PFClusterMET,std::allocator<reco::PFClusterMET> > -------------------
void __std__vector_reco__PFClusterMET__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<reco::PFClusterMET,std::allocator<reco::PFClusterMET> > -------------------
void __std__vector_reco__PFClusterMET__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32837, type_23182), Reflex::Literal("operator="), operator_14230, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394, type_14216), Reflex::Literal("assign"), method_14231, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8196), Reflex::Literal("begin"), method_14232, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8197), Reflex::Literal("begin"), method_14233, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8196), Reflex::Literal("end"), method_14234, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8197), Reflex::Literal("end"), method_14235, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("size"), method_14240, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("max_size"), method_14241, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394, type_7916), Reflex::Literal("resize"), method_14242, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("capacity"), method_14243, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("empty"), method_14244, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394), Reflex::Literal("reserve"), method_14245, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14214, type_3394), Reflex::Literal("operator[]"), operator_14246, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14216, type_3394), Reflex::Literal("operator[]"), operator_14247, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14214, type_3394), Reflex::Literal("at"), method_14249, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14216, type_3394), Reflex::Literal("at"), method_14250, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14214), Reflex::Literal("front"), method_14251, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14216), Reflex::Literal("front"), method_14252, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14214), Reflex::Literal("back"), method_14253, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14216), Reflex::Literal("back"), method_14254, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14210), Reflex::Literal("data"), method_14255, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14212), Reflex::Literal("data"), method_14256, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_14216), Reflex::Literal("push_back"), method_14257, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("pop_back"), method_14258, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8196, type_8196, type_14216), Reflex::Literal("insert"), method_14259, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_8196, type_3394, type_14216), Reflex::Literal("insert"), method_14260, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8196, type_8196), Reflex::Literal("erase"), method_14261, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8196, type_8196, type_8196), Reflex::Literal("erase"), method_14262, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_32837), Reflex::Literal("swap"), method_14263, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("clear"), method_14264, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class PFMET -------------------------------
static  void operator_27103( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::PFMET*)o)->operator=)(*(const ::reco::PFMET*)arg[0]);
  else   (((::reco::PFMET*)o)->operator=)(*(const ::reco::PFMET*)arg[0]);
}

static void constructor_27104( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::PFMET(*(const ::reco::PFMET*)arg[0]);
  else ::new(mem) ::reco::PFMET(*(const ::reco::PFMET*)arg[0]);
}

static void constructor_27105( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::PFMET();
  else ::new(mem) ::reco::PFMET();
}

static void constructor_27106( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::PFMET(*(::SpecificPFMETData*)arg[0],
      *(double*)arg[1],
      *(const ::math::XYZTLorentzVector*)arg[2],
      *(const ::math::XYZPoint*)arg[3]);
  else ::new(mem) ::reco::PFMET(*(::SpecificPFMETData*)arg[0],
      *(double*)arg[1],
      *(const ::math::XYZTLorentzVector*)arg[2],
      *(const ::math::XYZPoint*)arg[3]);
}

static void destructor_27107(void*, void * o, const std::vector<void*>&, void *) {
(((::reco::PFMET*)o)->::reco::PFMET::~PFMET)();
}
static  void method_27108( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PFMET*)o)->photonEtFraction)());
  else   (((const ::reco::PFMET*)o)->photonEtFraction)();
}

static  void method_27109( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PFMET*)o)->photonEt)());
  else   (((const ::reco::PFMET*)o)->photonEt)();
}

static  void method_27110( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PFMET*)o)->neutralHadronEtFraction)());
  else   (((const ::reco::PFMET*)o)->neutralHadronEtFraction)();
}

static  void method_27111( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PFMET*)o)->neutralHadronEt)());
  else   (((const ::reco::PFMET*)o)->neutralHadronEt)();
}

static  void method_27112( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PFMET*)o)->electronEtFraction)());
  else   (((const ::reco::PFMET*)o)->electronEtFraction)();
}

static  void method_27113( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PFMET*)o)->electronEt)());
  else   (((const ::reco::PFMET*)o)->electronEt)();
}

static  void method_27114( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PFMET*)o)->chargedHadronEtFraction)());
  else   (((const ::reco::PFMET*)o)->chargedHadronEtFraction)();
}

static  void method_27115( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PFMET*)o)->chargedHadronEt)());
  else   (((const ::reco::PFMET*)o)->chargedHadronEt)();
}

static  void method_27116( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PFMET*)o)->muonEtFraction)());
  else   (((const ::reco::PFMET*)o)->muonEtFraction)();
}

static  void method_27117( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PFMET*)o)->muonEt)());
  else   (((const ::reco::PFMET*)o)->muonEt)();
}

static  void method_27118( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PFMET*)o)->HFHadronEtFraction)());
  else   (((const ::reco::PFMET*)o)->HFHadronEtFraction)();
}

static  void method_27119( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PFMET*)o)->HFHadronEt)());
  else   (((const ::reco::PFMET*)o)->HFHadronEt)();
}

static  void method_27120( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PFMET*)o)->HFEMEtFraction)());
  else   (((const ::reco::PFMET*)o)->HFEMEtFraction)();
}

static  void method_27121( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PFMET*)o)->HFEMEt)());
  else   (((const ::reco::PFMET*)o)->HFEMEt)();
}

static  void method_27122( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PFMET*)o)->NeutralEMEtFraction)());
  else   (((const ::reco::PFMET*)o)->NeutralEMEtFraction)();
}

static  void method_27123( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PFMET*)o)->NeutralEMEt)());
  else   (((const ::reco::PFMET*)o)->NeutralEMEt)();
}

static  void method_27124( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PFMET*)o)->NeutralHadEtFraction)());
  else   (((const ::reco::PFMET*)o)->NeutralHadEtFraction)();
}

static  void method_27125( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PFMET*)o)->NeutralHadEt)());
  else   (((const ::reco::PFMET*)o)->NeutralHadEt)();
}

static  void method_27126( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PFMET*)o)->ChargedEMEtFraction)());
  else   (((const ::reco::PFMET*)o)->ChargedEMEtFraction)();
}

static  void method_27127( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PFMET*)o)->ChargedEMEt)());
  else   (((const ::reco::PFMET*)o)->ChargedEMEt)();
}

static  void method_27128( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PFMET*)o)->ChargedHadEtFraction)());
  else   (((const ::reco::PFMET*)o)->ChargedHadEtFraction)();
}

static  void method_27129( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PFMET*)o)->ChargedHadEt)());
  else   (((const ::reco::PFMET*)o)->ChargedHadEt)();
}

static  void method_27130( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PFMET*)o)->MuonEtFraction)());
  else   (((const ::reco::PFMET*)o)->MuonEtFraction)();
}

static  void method_27131( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PFMET*)o)->MuonEt)());
  else   (((const ::reco::PFMET*)o)->MuonEt)();
}

static  void method_27132( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PFMET*)o)->Type6EtFraction)());
  else   (((const ::reco::PFMET*)o)->Type6EtFraction)();
}

static  void method_27133( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PFMET*)o)->Type6Et)());
  else   (((const ::reco::PFMET*)o)->Type6Et)();
}

static  void method_27134( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PFMET*)o)->Type7EtFraction)());
  else   (((const ::reco::PFMET*)o)->Type7EtFraction)();
}

static  void method_27135( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PFMET*)o)->Type7Et)());
  else   (((const ::reco::PFMET*)o)->Type7Et)();
}

static  void method_27136( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PFMET*)o)->NeutralEMFraction)());
  else   (((const ::reco::PFMET*)o)->NeutralEMFraction)();
}

static  void method_27137( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PFMET*)o)->NeutralHadFraction)());
  else   (((const ::reco::PFMET*)o)->NeutralHadFraction)();
}

static  void method_27138( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PFMET*)o)->ChargedEMFraction)());
  else   (((const ::reco::PFMET*)o)->ChargedEMFraction)();
}

static  void method_27139( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PFMET*)o)->ChargedHadFraction)());
  else   (((const ::reco::PFMET*)o)->ChargedHadFraction)();
}

static  void method_27140( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::PFMET*)o)->MuonFraction)());
  else   (((const ::reco::PFMET*)o)->MuonFraction)();
}

static  void method_27141( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (SpecificPFMETData)((((const ::reco::PFMET*)o)->getSpecific)());
  else   (((const ::reco::PFMET*)o)->getSpecific)();
}

static void method_newdel_7918( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::reco::PFMET >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::reco::PFMET >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::reco::PFMET >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::reco::PFMET >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::reco::PFMET >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x63( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::MET")), ::Reflex::BaseOffset< ::reco::PFMET,::reco::MET >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::RecoCandidate")), ::Reflex::BaseOffset< ::reco::PFMET,::reco::RecoCandidate >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::reco::PFMET,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::reco::PFMET,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PFMET -------------------------------
void __reco__PFMET_db_datamem(Reflex::Class*);
void __reco__PFMET_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __reco__PFMET_datamem_bld(&__reco__PFMET_db_datamem);
Reflex::GenreflexMemberBuilder __reco__PFMET_funcmem_bld(&__reco__PFMET_db_funcmem);
void __reco__PFMET_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("reco::PFMET"), typeid(::reco::PFMET), sizeof(::reco::PFMET), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddBase(type_7952, ::Reflex::BaseOffset< ::reco::PFMET, ::reco::MET >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14341, type_14343), Reflex::Literal("operator="), operator_27103, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14343), Reflex::Literal("PFMET"), constructor_27104, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PFMET"), constructor_27105, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_468, type_107, type_39102, type_39103), Reflex::Literal("PFMET"), constructor_27106, 0, "pf_data_;sumet_;fP4;fVertex", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PFMET"), destructor_27107, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7918, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x63, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__reco__PFMET_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__reco__PFMET_funcmem_bld);
}

//------Delayed data member builder for class PFMET -------------------
void __reco__PFMET_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_468, Reflex::Literal("pf_data"), OffsetOf(__shadow__::__reco__PFMET, pf_data), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class PFMET -------------------
void __reco__PFMET_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("photonEtFraction"), method_27108, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("photonEt"), method_27109, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("neutralHadronEtFraction"), method_27110, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("neutralHadronEt"), method_27111, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("electronEtFraction"), method_27112, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("electronEt"), method_27113, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("chargedHadronEtFraction"), method_27114, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("chargedHadronEt"), method_27115, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("muonEtFraction"), method_27116, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("muonEt"), method_27117, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("HFHadronEtFraction"), method_27118, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("HFHadronEt"), method_27119, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("HFEMEtFraction"), method_27120, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("HFEMEt"), method_27121, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("NeutralEMEtFraction"), method_27122, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("NeutralEMEt"), method_27123, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("NeutralHadEtFraction"), method_27124, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("NeutralHadEt"), method_27125, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("ChargedEMEtFraction"), method_27126, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("ChargedEMEt"), method_27127, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("ChargedHadEtFraction"), method_27128, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("ChargedHadEt"), method_27129, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("MuonEtFraction"), method_27130, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("MuonEt"), method_27131, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("Type6EtFraction"), method_27132, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("Type6Et"), method_27133, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("Type7EtFraction"), method_27134, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("Type7Et"), method_27135, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("NeutralEMFraction"), method_27136, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("NeutralHadFraction"), method_27137, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("ChargedEMFraction"), method_27138, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("ChargedHadFraction"), method_27139, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("MuonFraction"), method_27140, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_468), Reflex::Literal("getSpecific"), method_27141, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class vector<reco::PFMET,std::allocator<reco::PFMET> > -------------------------------
static void constructor_14352( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::PFMET>();
  else ::new(mem) ::std::vector<reco::PFMET>();
}

static void constructor_14353( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::PFMET>(*(const ::std::allocator<reco::PFMET>*)arg[0]);
  else ::new(mem) ::std::vector<reco::PFMET>(*(const ::std::allocator<reco::PFMET>*)arg[0]);
}

static void constructor_14354( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::PFMET>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<reco::PFMET>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::PFMET>(*(::std::size_t*)arg[0],
      *(const ::reco::PFMET*)arg[1]);
  else ::new(mem) ::std::vector<reco::PFMET>(*(::std::size_t*)arg[0],
      *(const ::reco::PFMET*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::PFMET>(*(::std::size_t*)arg[0],
      *(const ::reco::PFMET*)arg[1],
      *(const ::std::allocator<reco::PFMET>*)arg[2]);
  else ::new(mem) ::std::vector<reco::PFMET>(*(::std::size_t*)arg[0],
      *(const ::reco::PFMET*)arg[1],
      *(const ::std::allocator<reco::PFMET>*)arg[2]);
  }
}

static void constructor_14355( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::PFMET>(*(const ::std::vector<reco::PFMET>*)arg[0]);
  else ::new(mem) ::std::vector<reco::PFMET>(*(const ::std::vector<reco::PFMET>*)arg[0]);
}

static void destructor_14356(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<reco::PFMET>*)o)->::std::vector<reco::PFMET>::~vector)();
}
static  void operator_14357( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::PFMET>*)o)->operator=)(*(const ::std::vector<reco::PFMET>*)arg[0]);
  else   (((::std::vector<reco::PFMET>*)o)->operator=)(*(const ::std::vector<reco::PFMET>*)arg[0]);
}

static  void method_14358( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::PFMET>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::reco::PFMET*)arg[1]);
}

static  void method_14359( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::PFMET*,std::vector<reco::PFMET> >)((((::std::vector<reco::PFMET>*)o)->begin)());
  else   (((::std::vector<reco::PFMET>*)o)->begin)();
}

static  void method_14360( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::PFMET*,std::vector<reco::PFMET> >)((((const ::std::vector<reco::PFMET>*)o)->begin)());
  else   (((const ::std::vector<reco::PFMET>*)o)->begin)();
}

static  void method_14361( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::PFMET*,std::vector<reco::PFMET> >)((((::std::vector<reco::PFMET>*)o)->end)());
  else   (((::std::vector<reco::PFMET>*)o)->end)();
}

static  void method_14362( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::PFMET*,std::vector<reco::PFMET> >)((((const ::std::vector<reco::PFMET>*)o)->end)());
  else   (((const ::std::vector<reco::PFMET>*)o)->end)();
}

static  void method_14367( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::PFMET>*)o)->size)());
  else   (((const ::std::vector<reco::PFMET>*)o)->size)();
}

static  void method_14368( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::PFMET>*)o)->max_size)());
  else   (((const ::std::vector<reco::PFMET>*)o)->max_size)();
}

static  void method_14369( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<reco::PFMET>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<reco::PFMET>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::reco::PFMET*)arg[1]);
  }
}

static  void method_14370( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::PFMET>*)o)->capacity)());
  else   (((const ::std::vector<reco::PFMET>*)o)->capacity)();
}

static  void method_14371( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<reco::PFMET>*)o)->empty)());
  else   (((const ::std::vector<reco::PFMET>*)o)->empty)();
}

static  void method_14372( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::PFMET>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_14373( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::PFMET>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::PFMET>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_14374( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::PFMET>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::PFMET>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_14376( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::PFMET>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::PFMET>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14377( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::PFMET>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::PFMET>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14378( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::PFMET>*)o)->front)();
  else   (((::std::vector<reco::PFMET>*)o)->front)();
}

static  void method_14379( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::PFMET>*)o)->front)();
  else   (((const ::std::vector<reco::PFMET>*)o)->front)();
}

static  void method_14380( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::PFMET>*)o)->back)();
  else   (((::std::vector<reco::PFMET>*)o)->back)();
}

static  void method_14381( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::PFMET>*)o)->back)();
  else   (((const ::std::vector<reco::PFMET>*)o)->back)();
}

static  void method_14382( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<reco::PFMET>*)o)->data)());
  else   (((::std::vector<reco::PFMET>*)o)->data)();
}

static  void method_14383( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<reco::PFMET>*)o)->data)());
  else   (((const ::std::vector<reco::PFMET>*)o)->data)();
}

static  void method_14384( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::PFMET>*)o)->push_back)(*(const ::reco::PFMET*)arg[0]);
}

static  void method_14385( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::PFMET>*)o)->pop_back)();
}

static  void method_14386( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::PFMET*,std::vector<reco::PFMET> >)((((::std::vector<reco::PFMET>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::PFMET*,std::vector<reco::PFMET> >*)arg[0],
    *(const ::reco::PFMET*)arg[1]));
  else   (((::std::vector<reco::PFMET>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::PFMET*,std::vector<reco::PFMET> >*)arg[0],
    *(const ::reco::PFMET*)arg[1]);
}

static  void method_14387( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::PFMET>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::PFMET*,std::vector<reco::PFMET> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::reco::PFMET*)arg[2]);
}

static  void method_14388( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::PFMET*,std::vector<reco::PFMET> >)((((::std::vector<reco::PFMET>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::PFMET*,std::vector<reco::PFMET> >*)arg[0]));
  else   (((::std::vector<reco::PFMET>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::PFMET*,std::vector<reco::PFMET> >*)arg[0]);
}

static  void method_14389( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::PFMET*,std::vector<reco::PFMET> >)((((::std::vector<reco::PFMET>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::PFMET*,std::vector<reco::PFMET> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::PFMET*,std::vector<reco::PFMET> >*)arg[1]));
  else   (((::std::vector<reco::PFMET>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::PFMET*,std::vector<reco::PFMET> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::PFMET*,std::vector<reco::PFMET> >*)arg[1]);
}

static  void method_14390( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::PFMET>*)o)->swap)(*(::std::vector<reco::PFMET>*)arg[0]);
}

static  void method_14391( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::PFMET>*)o)->clear)();
}

static void method_newdel_3157( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<reco::PFMET> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<reco::PFMET> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<reco::PFMET> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<reco::PFMET> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<reco::PFMET> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x65( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::PFMET,std::allocator<reco::PFMET> >")), ::Reflex::BaseOffset< ::std::vector<reco::PFMET>,::std::_Vector_base<reco::PFMET,std::allocator<reco::PFMET> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x66( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<reco::PFMET> >::Generate();
  else ::Reflex::Proxy< ::std::vector<reco::PFMET> >::Generate();
}

//------Dictionary for class vector<reco::PFMET,std::allocator<reco::PFMET> > -------------------------------
void __std__vector_reco__PFMET__db_datamem(Reflex::Class*);
void __std__vector_reco__PFMET__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_reco__PFMET__datamem_bld(&__std__vector_reco__PFMET__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_reco__PFMET__funcmem_bld(&__std__vector_reco__PFMET__db_funcmem);
void __std__vector_reco__PFMET__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<reco::PFMET>"), typeid(::std::vector<reco::PFMET>), sizeof(::std::vector<reco::PFMET>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2616, ::Reflex::BaseOffset< ::std::vector<reco::PFMET>, ::std::_Vector_base<reco::PFMET,std::allocator<reco::PFMET> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_7918, Reflex::Literal("std::vector<reco::PFMET>::_Alloc_value_type"))
  .AddTypedef(type_2616, Reflex::Literal("std::vector<reco::PFMET>::_Base"))
  .AddTypedef(type_3428, Reflex::Literal("std::vector<reco::PFMET>::_Tp_alloc_type"))
  .AddTypedef(type_7918, Reflex::Literal("std::vector<reco::PFMET>::value_type"))
  .AddTypedef(type_14337, Reflex::Literal("std::vector<reco::PFMET>::pointer"))
  .AddTypedef(type_14339, Reflex::Literal("std::vector<reco::PFMET>::const_pointer"))
  .AddTypedef(type_14341, Reflex::Literal("std::vector<reco::PFMET>::reference"))
  .AddTypedef(type_14343, Reflex::Literal("std::vector<reco::PFMET>::const_reference"))
  .AddTypedef(type_8198, Reflex::Literal("std::vector<reco::PFMET>::iterator"))
  .AddTypedef(type_8199, Reflex::Literal("std::vector<reco::PFMET>::const_iterator"))
  .AddTypedef(type_3651, Reflex::Literal("std::vector<reco::PFMET>::const_reverse_iterator"))
  .AddTypedef(type_3652, Reflex::Literal("std::vector<reco::PFMET>::reverse_iterator"))
  .AddTypedef(type_3394, Reflex::Literal("std::vector<reco::PFMET>::size_type"))
  .AddTypedef(type_3290, Reflex::Literal("std::vector<reco::PFMET>::difference_type"))
  .AddTypedef(type_3428, Reflex::Literal("std::vector<reco::PFMET>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_14352, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31921), Reflex::Literal("vector"), constructor_14353, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3394, type_14343, type_31921), Reflex::Literal("vector"), constructor_14354, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23193), Reflex::Literal("vector"), constructor_14355, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_14356, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3157, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x65, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x66, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_reco__PFMET__funcmem_bld);
}

//------Delayed data member builder for class vector<reco::PFMET,std::allocator<reco::PFMET> > -------------------
void __std__vector_reco__PFMET__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<reco::PFMET,std::allocator<reco::PFMET> > -------------------
void __std__vector_reco__PFMET__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32841, type_23193), Reflex::Literal("operator="), operator_14357, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394, type_14343), Reflex::Literal("assign"), method_14358, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8198), Reflex::Literal("begin"), method_14359, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8199), Reflex::Literal("begin"), method_14360, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8198), Reflex::Literal("end"), method_14361, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8199), Reflex::Literal("end"), method_14362, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("size"), method_14367, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("max_size"), method_14368, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394, type_7918), Reflex::Literal("resize"), method_14369, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("capacity"), method_14370, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("empty"), method_14371, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394), Reflex::Literal("reserve"), method_14372, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14341, type_3394), Reflex::Literal("operator[]"), operator_14373, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14343, type_3394), Reflex::Literal("operator[]"), operator_14374, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14341, type_3394), Reflex::Literal("at"), method_14376, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14343, type_3394), Reflex::Literal("at"), method_14377, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14341), Reflex::Literal("front"), method_14378, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14343), Reflex::Literal("front"), method_14379, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14341), Reflex::Literal("back"), method_14380, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14343), Reflex::Literal("back"), method_14381, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14337), Reflex::Literal("data"), method_14382, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14339), Reflex::Literal("data"), method_14383, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_14343), Reflex::Literal("push_back"), method_14384, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("pop_back"), method_14385, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8198, type_8198, type_14343), Reflex::Literal("insert"), method_14386, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_8198, type_3394, type_14343), Reflex::Literal("insert"), method_14387, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8198, type_8198), Reflex::Literal("erase"), method_14388, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8198, type_8198, type_8198), Reflex::Literal("erase"), method_14389, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_32841), Reflex::Literal("swap"), method_14390, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("clear"), method_14391, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class GenMET -------------------------------
static  void operator_28017( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::GenMET*)o)->operator=)(*(const ::reco::GenMET*)arg[0]);
  else   (((::reco::GenMET*)o)->operator=)(*(const ::reco::GenMET*)arg[0]);
}

static void constructor_28018( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::GenMET(*(const ::reco::GenMET*)arg[0]);
  else ::new(mem) ::reco::GenMET(*(const ::reco::GenMET*)arg[0]);
}

static void constructor_28019( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::GenMET();
  else ::new(mem) ::reco::GenMET();
}

static void constructor_28020( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::GenMET(*(::SpecificGenMETData*)arg[0],
      *(double*)arg[1],
      *(const ::math::XYZTLorentzVector*)arg[2],
      *(const ::math::XYZPoint*)arg[3]);
  else ::new(mem) ::reco::GenMET(*(::SpecificGenMETData*)arg[0],
      *(double*)arg[1],
      *(const ::math::XYZTLorentzVector*)arg[2],
      *(const ::math::XYZPoint*)arg[3]);
}

static void destructor_28021(void*, void * o, const std::vector<void*>&, void *) {
(((::reco::GenMET*)o)->::reco::GenMET::~GenMET)();
}
static  void method_28022( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::GenMET*)o)->NeutralEMEtFraction)());
  else   (((const ::reco::GenMET*)o)->NeutralEMEtFraction)();
}

static  void method_28023( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::GenMET*)o)->NeutralEMEt)());
  else   (((const ::reco::GenMET*)o)->NeutralEMEt)();
}

static  void method_28024( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::GenMET*)o)->ChargedEMEtFraction)());
  else   (((const ::reco::GenMET*)o)->ChargedEMEtFraction)();
}

static  void method_28025( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::GenMET*)o)->ChargedEMEt)());
  else   (((const ::reco::GenMET*)o)->ChargedEMEt)();
}

static  void method_28026( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::GenMET*)o)->NeutralHadEtFraction)());
  else   (((const ::reco::GenMET*)o)->NeutralHadEtFraction)();
}

static  void method_28027( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::GenMET*)o)->NeutralHadEt)());
  else   (((const ::reco::GenMET*)o)->NeutralHadEt)();
}

static  void method_28028( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::GenMET*)o)->ChargedHadEtFraction)());
  else   (((const ::reco::GenMET*)o)->ChargedHadEtFraction)();
}

static  void method_28029( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::GenMET*)o)->ChargedHadEt)());
  else   (((const ::reco::GenMET*)o)->ChargedHadEt)();
}

static  void method_28030( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::GenMET*)o)->MuonEtFraction)());
  else   (((const ::reco::GenMET*)o)->MuonEtFraction)();
}

static  void method_28031( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::GenMET*)o)->MuonEt)());
  else   (((const ::reco::GenMET*)o)->MuonEt)();
}

static  void method_28032( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::GenMET*)o)->InvisibleEtFraction)());
  else   (((const ::reco::GenMET*)o)->InvisibleEtFraction)();
}

static  void method_28033( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::GenMET*)o)->InvisibleEt)());
  else   (((const ::reco::GenMET*)o)->InvisibleEt)();
}

static  void method_28034( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::GenMET*)o)->emEnergy)());
  else   (((const ::reco::GenMET*)o)->emEnergy)();
}

static  void method_28035( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::GenMET*)o)->hadEnergy)());
  else   (((const ::reco::GenMET*)o)->hadEnergy)();
}

static  void method_28036( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::GenMET*)o)->invisibleEnergy)());
  else   (((const ::reco::GenMET*)o)->invisibleEnergy)();
}

static  void method_28037( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::GenMET*)o)->auxiliaryEnergy)());
  else   (((const ::reco::GenMET*)o)->auxiliaryEnergy)();
}

static void method_newdel_7970( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::reco::GenMET >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::reco::GenMET >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::reco::GenMET >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::reco::GenMET >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::reco::GenMET >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x68( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::MET")), ::Reflex::BaseOffset< ::reco::GenMET,::reco::MET >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::RecoCandidate")), ::Reflex::BaseOffset< ::reco::GenMET,::reco::RecoCandidate >::Get(),::Reflex::PUBLIC), 1));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::LeafCandidate")), ::Reflex::BaseOffset< ::reco::GenMET,::reco::LeafCandidate >::Get(),::Reflex::PUBLIC), 2));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("reco::Candidate")), ::Reflex::BaseOffset< ::reco::GenMET,::reco::Candidate >::Get(),::Reflex::PUBLIC), 3));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class GenMET -------------------------------
void __reco__GenMET_db_datamem(Reflex::Class*);
void __reco__GenMET_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __reco__GenMET_datamem_bld(&__reco__GenMET_db_datamem);
Reflex::GenreflexMemberBuilder __reco__GenMET_funcmem_bld(&__reco__GenMET_db_funcmem);
void __reco__GenMET_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("reco::GenMET"), typeid(::reco::GenMET), sizeof(::reco::GenMET), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddBase(type_7952, ::Reflex::BaseOffset< ::reco::GenMET, ::reco::MET >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14406, type_14408), Reflex::Literal("operator="), operator_28017, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14408), Reflex::Literal("GenMET"), constructor_28018, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("GenMET"), constructor_28019, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2320, type_107, type_39102, type_39103), Reflex::Literal("GenMET"), constructor_28020, 0, "gen_data_;sumet_;fP4;fVertex", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~GenMET"), destructor_28021, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7970, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x68, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__reco__GenMET_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__reco__GenMET_funcmem_bld);
}

//------Delayed data member builder for class GenMET -------------------
void __reco__GenMET_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2320, Reflex::Literal("gen_data"), OffsetOf(__shadow__::__reco__GenMET, gen_data), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class GenMET -------------------
void __reco__GenMET_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("NeutralEMEtFraction"), method_28022, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("NeutralEMEt"), method_28023, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("ChargedEMEtFraction"), method_28024, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("ChargedEMEt"), method_28025, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("NeutralHadEtFraction"), method_28026, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("NeutralHadEt"), method_28027, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("ChargedHadEtFraction"), method_28028, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("ChargedHadEt"), method_28029, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("MuonEtFraction"), method_28030, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("MuonEt"), method_28031, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("InvisibleEtFraction"), method_28032, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("InvisibleEt"), method_28033, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("emEnergy"), method_28034, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("hadEnergy"), method_28035, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("invisibleEnergy"), method_28036, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("auxiliaryEnergy"), method_28037, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class vector<reco::GenMET,std::allocator<reco::GenMET> > -------------------------------
static void constructor_14417( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::GenMET>();
  else ::new(mem) ::std::vector<reco::GenMET>();
}

static void constructor_14418( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::GenMET>(*(const ::std::allocator<reco::GenMET>*)arg[0]);
  else ::new(mem) ::std::vector<reco::GenMET>(*(const ::std::allocator<reco::GenMET>*)arg[0]);
}

static void constructor_14419( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::GenMET>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<reco::GenMET>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::GenMET>(*(::std::size_t*)arg[0],
      *(const ::reco::GenMET*)arg[1]);
  else ::new(mem) ::std::vector<reco::GenMET>(*(::std::size_t*)arg[0],
      *(const ::reco::GenMET*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::GenMET>(*(::std::size_t*)arg[0],
      *(const ::reco::GenMET*)arg[1],
      *(const ::std::allocator<reco::GenMET>*)arg[2]);
  else ::new(mem) ::std::vector<reco::GenMET>(*(::std::size_t*)arg[0],
      *(const ::reco::GenMET*)arg[1],
      *(const ::std::allocator<reco::GenMET>*)arg[2]);
  }
}

static void constructor_14420( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::GenMET>(*(const ::std::vector<reco::GenMET>*)arg[0]);
  else ::new(mem) ::std::vector<reco::GenMET>(*(const ::std::vector<reco::GenMET>*)arg[0]);
}

static void destructor_14421(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<reco::GenMET>*)o)->::std::vector<reco::GenMET>::~vector)();
}
static  void operator_14422( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::GenMET>*)o)->operator=)(*(const ::std::vector<reco::GenMET>*)arg[0]);
  else   (((::std::vector<reco::GenMET>*)o)->operator=)(*(const ::std::vector<reco::GenMET>*)arg[0]);
}

static  void method_14423( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::GenMET>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::reco::GenMET*)arg[1]);
}

static  void method_14424( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::GenMET*,std::vector<reco::GenMET> >)((((::std::vector<reco::GenMET>*)o)->begin)());
  else   (((::std::vector<reco::GenMET>*)o)->begin)();
}

static  void method_14425( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::GenMET*,std::vector<reco::GenMET> >)((((const ::std::vector<reco::GenMET>*)o)->begin)());
  else   (((const ::std::vector<reco::GenMET>*)o)->begin)();
}

static  void method_14426( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::GenMET*,std::vector<reco::GenMET> >)((((::std::vector<reco::GenMET>*)o)->end)());
  else   (((::std::vector<reco::GenMET>*)o)->end)();
}

static  void method_14427( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::GenMET*,std::vector<reco::GenMET> >)((((const ::std::vector<reco::GenMET>*)o)->end)());
  else   (((const ::std::vector<reco::GenMET>*)o)->end)();
}

static  void method_14432( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::GenMET>*)o)->size)());
  else   (((const ::std::vector<reco::GenMET>*)o)->size)();
}

static  void method_14433( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::GenMET>*)o)->max_size)());
  else   (((const ::std::vector<reco::GenMET>*)o)->max_size)();
}

static  void method_14434( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<reco::GenMET>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<reco::GenMET>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::reco::GenMET*)arg[1]);
  }
}

static  void method_14435( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::GenMET>*)o)->capacity)());
  else   (((const ::std::vector<reco::GenMET>*)o)->capacity)();
}

static  void method_14436( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<reco::GenMET>*)o)->empty)());
  else   (((const ::std::vector<reco::GenMET>*)o)->empty)();
}

static  void method_14437( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::GenMET>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_14438( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::GenMET>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::GenMET>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_14439( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::GenMET>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::GenMET>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_14441( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::GenMET>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::GenMET>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14442( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::GenMET>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::GenMET>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14443( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::GenMET>*)o)->front)();
  else   (((::std::vector<reco::GenMET>*)o)->front)();
}

static  void method_14444( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::GenMET>*)o)->front)();
  else   (((const ::std::vector<reco::GenMET>*)o)->front)();
}

static  void method_14445( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::GenMET>*)o)->back)();
  else   (((::std::vector<reco::GenMET>*)o)->back)();
}

static  void method_14446( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::GenMET>*)o)->back)();
  else   (((const ::std::vector<reco::GenMET>*)o)->back)();
}

static  void method_14447( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<reco::GenMET>*)o)->data)());
  else   (((::std::vector<reco::GenMET>*)o)->data)();
}

static  void method_14448( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<reco::GenMET>*)o)->data)());
  else   (((const ::std::vector<reco::GenMET>*)o)->data)();
}

static  void method_14449( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::GenMET>*)o)->push_back)(*(const ::reco::GenMET*)arg[0]);
}

static  void method_14450( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::GenMET>*)o)->pop_back)();
}

static  void method_14451( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::GenMET*,std::vector<reco::GenMET> >)((((::std::vector<reco::GenMET>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::GenMET*,std::vector<reco::GenMET> >*)arg[0],
    *(const ::reco::GenMET*)arg[1]));
  else   (((::std::vector<reco::GenMET>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::GenMET*,std::vector<reco::GenMET> >*)arg[0],
    *(const ::reco::GenMET*)arg[1]);
}

static  void method_14452( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::GenMET>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::GenMET*,std::vector<reco::GenMET> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::reco::GenMET*)arg[2]);
}

static  void method_14453( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::GenMET*,std::vector<reco::GenMET> >)((((::std::vector<reco::GenMET>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::GenMET*,std::vector<reco::GenMET> >*)arg[0]));
  else   (((::std::vector<reco::GenMET>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::GenMET*,std::vector<reco::GenMET> >*)arg[0]);
}

static  void method_14454( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::GenMET*,std::vector<reco::GenMET> >)((((::std::vector<reco::GenMET>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::GenMET*,std::vector<reco::GenMET> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::GenMET*,std::vector<reco::GenMET> >*)arg[1]));
  else   (((::std::vector<reco::GenMET>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::GenMET*,std::vector<reco::GenMET> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::GenMET*,std::vector<reco::GenMET> >*)arg[1]);
}

static  void method_14455( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::GenMET>*)o)->swap)(*(::std::vector<reco::GenMET>*)arg[0]);
}

static  void method_14456( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::GenMET>*)o)->clear)();
}

static void method_newdel_3158( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<reco::GenMET> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<reco::GenMET> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<reco::GenMET> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<reco::GenMET> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<reco::GenMET> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x70( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::GenMET,std::allocator<reco::GenMET> >")), ::Reflex::BaseOffset< ::std::vector<reco::GenMET>,::std::_Vector_base<reco::GenMET,std::allocator<reco::GenMET> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x71( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<reco::GenMET> >::Generate();
  else ::Reflex::Proxy< ::std::vector<reco::GenMET> >::Generate();
}

//------Dictionary for class vector<reco::GenMET,std::allocator<reco::GenMET> > -------------------------------
void __std__vector_reco__GenMET__db_datamem(Reflex::Class*);
void __std__vector_reco__GenMET__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_reco__GenMET__datamem_bld(&__std__vector_reco__GenMET__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_reco__GenMET__funcmem_bld(&__std__vector_reco__GenMET__db_funcmem);
void __std__vector_reco__GenMET__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<reco::GenMET>"), typeid(::std::vector<reco::GenMET>), sizeof(::std::vector<reco::GenMET>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2614, ::Reflex::BaseOffset< ::std::vector<reco::GenMET>, ::std::_Vector_base<reco::GenMET,std::allocator<reco::GenMET> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_7970, Reflex::Literal("std::vector<reco::GenMET>::_Alloc_value_type"))
  .AddTypedef(type_2614, Reflex::Literal("std::vector<reco::GenMET>::_Base"))
  .AddTypedef(type_3429, Reflex::Literal("std::vector<reco::GenMET>::_Tp_alloc_type"))
  .AddTypedef(type_7970, Reflex::Literal("std::vector<reco::GenMET>::value_type"))
  .AddTypedef(type_14402, Reflex::Literal("std::vector<reco::GenMET>::pointer"))
  .AddTypedef(type_14404, Reflex::Literal("std::vector<reco::GenMET>::const_pointer"))
  .AddTypedef(type_14406, Reflex::Literal("std::vector<reco::GenMET>::reference"))
  .AddTypedef(type_14408, Reflex::Literal("std::vector<reco::GenMET>::const_reference"))
  .AddTypedef(type_8194, Reflex::Literal("std::vector<reco::GenMET>::iterator"))
  .AddTypedef(type_8195, Reflex::Literal("std::vector<reco::GenMET>::const_iterator"))
  .AddTypedef(type_3647, Reflex::Literal("std::vector<reco::GenMET>::const_reverse_iterator"))
  .AddTypedef(type_3648, Reflex::Literal("std::vector<reco::GenMET>::reverse_iterator"))
  .AddTypedef(type_3394, Reflex::Literal("std::vector<reco::GenMET>::size_type"))
  .AddTypedef(type_3290, Reflex::Literal("std::vector<reco::GenMET>::difference_type"))
  .AddTypedef(type_3429, Reflex::Literal("std::vector<reco::GenMET>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_14417, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31897), Reflex::Literal("vector"), constructor_14418, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3394, type_14408, type_31897), Reflex::Literal("vector"), constructor_14419, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_23215), Reflex::Literal("vector"), constructor_14420, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_14421, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3158, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x70, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x71, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_reco__GenMET__funcmem_bld);
}

//------Delayed data member builder for class vector<reco::GenMET,std::allocator<reco::GenMET> > -------------------
void __std__vector_reco__GenMET__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<reco::GenMET,std::allocator<reco::GenMET> > -------------------
void __std__vector_reco__GenMET__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32843, type_23215), Reflex::Literal("operator="), operator_14422, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394, type_14408), Reflex::Literal("assign"), method_14423, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8194), Reflex::Literal("begin"), method_14424, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8195), Reflex::Literal("begin"), method_14425, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8194), Reflex::Literal("end"), method_14426, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8195), Reflex::Literal("end"), method_14427, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("size"), method_14432, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("max_size"), method_14433, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394, type_7970), Reflex::Literal("resize"), method_14434, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("capacity"), method_14435, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("empty"), method_14436, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394), Reflex::Literal("reserve"), method_14437, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14406, type_3394), Reflex::Literal("operator[]"), operator_14438, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14408, type_3394), Reflex::Literal("operator[]"), operator_14439, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14406, type_3394), Reflex::Literal("at"), method_14441, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14408, type_3394), Reflex::Literal("at"), method_14442, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14406), Reflex::Literal("front"), method_14443, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14408), Reflex::Literal("front"), method_14444, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14406), Reflex::Literal("back"), method_14445, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14408), Reflex::Literal("back"), method_14446, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14402), Reflex::Literal("data"), method_14447, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14404), Reflex::Literal("data"), method_14448, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_14408), Reflex::Literal("push_back"), method_14449, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("pop_back"), method_14450, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8194, type_8194, type_14408), Reflex::Literal("insert"), method_14451, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_8194, type_3394, type_14408), Reflex::Literal("insert"), method_14452, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8194, type_8194), Reflex::Literal("erase"), method_14453, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8194, type_8194, type_8194), Reflex::Literal("erase"), method_14454, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_32843), Reflex::Literal("swap"), method_14455, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("clear"), method_14456, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class PtrVector<reco::MET> -------------------------------
static void constructor_20124( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<reco::MET>();
  else ::new(mem) ::edm::PtrVector<reco::MET>();
}

static void constructor_20125( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<reco::MET>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::PtrVector<reco::MET>(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_20126( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::PtrVector<reco::MET>(*(const ::edm::PtrVector<reco::MET>*)arg[0]);
  else ::new(mem) ::edm::PtrVector<reco::MET>(*(const ::edm::PtrVector<reco::MET>*)arg[0]);
}

static  void operator_20127( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ptr<reco::MET>)((((const ::edm::PtrVector<reco::MET>*)o)->operator[])(*(const unsigned long*)arg[0]));
  else   (((const ::edm::PtrVector<reco::MET>*)o)->operator[])(*(const unsigned long*)arg[0]);
}

static  void method_20128( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::PtrVectorItr<reco::MET>)((((const ::edm::PtrVector<reco::MET>*)o)->begin)());
  else   (((const ::edm::PtrVector<reco::MET>*)o)->begin)();
}

static  void method_20129( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::PtrVectorItr<reco::MET>)((((const ::edm::PtrVector<reco::MET>*)o)->end)());
  else   (((const ::edm::PtrVector<reco::MET>*)o)->end)();
}

static  void method_20130( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::PtrVector<reco::MET>*)o)->push_back)(*(const ::edm::Ptr<reco::MET>*)arg[0]);
}

static  void method_20131( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::PtrVector<reco::MET>*)o)->swap)(*(::edm::PtrVector<reco::MET>*)arg[0]);
}

static  void operator_20132( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::PtrVector<reco::MET>*)o)->operator=)(*(const ::edm::PtrVector<reco::MET>*)arg[0]);
  else   (((::edm::PtrVector<reco::MET>*)o)->operator=)(*(const ::edm::PtrVector<reco::MET>*)arg[0]);
}

static  void method_20133( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::PtrVector<reco::MET>*)o)->fillView)(*(::std::vector<const void*>*)arg[0]);
}

static  void method_20134( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::PtrVector<reco::MET>*)o)->Class_Version)());
  else   (((::edm::PtrVector<reco::MET>*)o)->Class_Version)();
}

static void destructor_20137(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::PtrVector<reco::MET>*)o)->::edm::PtrVector<reco::MET>::~PtrVector)();
}
static void method_newdel_4622( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::MET> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::MET> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::MET> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::MET> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::PtrVector<reco::MET> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x73( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::PtrVectorBase")), ::Reflex::BaseOffset< ::edm::PtrVector<reco::MET>,::edm::PtrVectorBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class PtrVector<reco::MET> -------------------------------
void __edm__PtrVector_reco__MET__db_datamem(Reflex::Class*);
void __edm__PtrVector_reco__MET__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__PtrVector_reco__MET__datamem_bld(&__edm__PtrVector_reco__MET__db_datamem);
Reflex::GenreflexMemberBuilder __edm__PtrVector_reco__MET__funcmem_bld(&__edm__PtrVector_reco__MET__db_funcmem);
void __edm__PtrVector_reco__MET__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::PtrVector<reco::MET>"), typeid(::edm::PtrVector<reco::MET>), sizeof(::edm::PtrVector<reco::MET>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::PtrVector<reco::MET>::Class_Version())
  .AddBase(type_4835, ::Reflex::BaseOffset< ::edm::PtrVector<reco::MET>, ::edm::PtrVectorBase >::Get(), ::Reflex::PUBLIC)
  .AddTypedef(type_4773, Reflex::Literal("edm::PtrVector<reco::MET>::const_iterator"))
  .AddTypedef(type_4773, Reflex::Literal("edm::PtrVector<reco::MET>::iterator"))
  .AddTypedef(type_4901, Reflex::Literal("edm::PtrVector<reco::MET>::value_type"))
  .AddTypedef(type_409, Reflex::Literal("edm::PtrVector<reco::MET>::collection_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("PtrVector"), constructor_20124, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19738), Reflex::Literal("PtrVector"), constructor_20125, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33810), Reflex::Literal("PtrVector"), constructor_20126, 0, "iOther", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~PtrVector"), destructor_20137, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4622, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x73, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__edm__PtrVector_reco__MET__funcmem_bld);
}

//------Delayed data member builder for class PtrVector<reco::MET> -------------------
void __edm__PtrVector_reco__MET__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class PtrVector<reco::MET> -------------------
void __edm__PtrVector_reco__MET__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4901, type_364c), Reflex::Literal("operator[]"), operator_20127, 0, "iIndex", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4773), Reflex::Literal("begin"), method_20128, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4773), Reflex::Literal("end"), method_20129, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_33811), Reflex::Literal("push_back"), method_20130, 0, "iPtr", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_33812), Reflex::Literal("swap"), method_20131, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33812, type_33810), Reflex::Literal("operator="), operator_20132, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_19832), Reflex::Literal("fillView"), method_20133, 0, "pointers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_192), Reflex::Literal("Class_Version"), method_20134, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefVector<std::vector<reco::PFClusterMET, std::allocator<reco::PFClusterMET> >,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET, std::allocator<reco::PFClusterMET> >, reco::PFClusterMET> > -------------------------------
static void destructor_20211(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >::~RefVector)();
}
static void constructor_20212( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >();
  else ::new(mem) ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >();
}

static void constructor_20213( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >(*(const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >(*(const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)arg[0]);
}

static void constructor_20214( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >(*(const ::edm::ProductID*)arg[0]);
}

static  void method_20215( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->push_back)(*(const ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)arg[0]);
}

static  void operator_20216( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >)((((const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_20217( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >)((((const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_20218( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->refVector)();
  else   (((const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->refVector)();
}

static  void method_20219( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->empty)());
  else   (((const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->empty)();
}

static  void method_20220( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->size)());
  else   (((const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->size)();
}

static  void method_20221( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->capacity)());
  else   (((const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->capacity)();
}

static  void method_20222( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_20223( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >)((((const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->begin)());
  else   (((const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->begin)();
}

static  void method_20224( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >)((((const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->end)());
  else   (((const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->end)();
}

static  void method_20225( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->id)());
  else   (((const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->id)();
}

static  void method_20226( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->productGetter)());
  else   (((const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->productGetter)();
}

static  void method_20227( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->isNull)());
  else   (((const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->isNull)();
}

static  void method_20228( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->isNonnull)());
  else   (((const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->isNonnull)();
}

static  void operator_20229( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->operator!)());
  else   (((const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->operator!)();
}

static  void method_20230( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->product)());
  else   (((const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->product)();
}

static  void method_20231( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->isAvailable)());
  else   (((const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->isAvailable)();
}

static  void method_20232( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->isTransient)());
  else   (((const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->isTransient)();
}

static  void method_20233( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >)((((::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)arg[0]));
  else   (((::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)arg[0]);
}

static  void method_20234( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->clear)();
}

static  void method_20235( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->swap)(*(::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)arg[0]);
}

static  void operator_20236( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)arg[0]);
  else   (((::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)arg[0]);
}

static  void method_20237( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->hasProductCache)());
  else   (((const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->hasProductCache)();
}

static  void method_20238( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_20239( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->Class_Version)());
  else   (((::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->Class_Version)();
}

static void method_newdel_4631( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefVector<std::vector<reco::PFClusterMET, std::allocator<reco::PFClusterMET> >,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET, std::allocator<reco::PFClusterMET> >, reco::PFClusterMET> > -------------------------------
void __edm__RefVector_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s__db_datamem(Reflex::Class*);
void __edm__RefVector_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s__datamem_bld(&__edm__RefVector_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s__funcmem_bld(&__edm__RefVector_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s__db_funcmem);
void __edm__RefVector_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >"), typeid(::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >), sizeof(::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >::Class_Version())
  .AddTypedef(type_3155, Reflex::Literal("edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >::collection_type"))
  .AddTypedef(type_7916, Reflex::Literal("edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >::member_type"))
  .AddTypedef(type_20093, Reflex::Literal("edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >::finder_type"))
  .AddTypedef(type_4602, Reflex::Literal("edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >::iterator"))
  .AddTypedef(type_4602, Reflex::Literal("edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >::const_iterator"))
  .AddTypedef(type_4915, Reflex::Literal("edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >::value_type"))
  .AddTypedef(type_4915c, Reflex::Literal("edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >::const_reference"))
  .AddTypedef(type_4915c, Reflex::Literal("edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >::reference"))
  .AddTypedef(type_373, Reflex::Literal("edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >::key_type"))
  .AddTypedef(type_3156, Reflex::Literal("edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >::KeyVec"))
  .AddTypedef(type_3394, Reflex::Literal("edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >::size_type"))
  .AddTypedef(type_4197, Reflex::Literal("edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >::contents_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVector"), destructor_20211, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVector"), constructor_20212, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33823), Reflex::Literal("RefVector"), constructor_20213, 0, "rh", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19738), Reflex::Literal("RefVector"), constructor_20214, 0, "iId", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4631, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVector_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVector_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s__funcmem_bld);
}

//------Delayed data member builder for class RefVector<std::vector<reco::PFClusterMET, std::allocator<reco::PFClusterMET> >,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET, std::allocator<reco::PFClusterMET> >, reco::PFClusterMET> > -------------------
void __edm__RefVector_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4197, Reflex::Literal("refVector_"), OffsetOf(__shadow__::__edm__RefVector_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_, refVector_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVector<std::vector<reco::PFClusterMET, std::allocator<reco::PFClusterMET> >,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET, std::allocator<reco::PFClusterMET> >, reco::PFClusterMET> > -------------------
void __edm__RefVector_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_33824), Reflex::Literal("push_back"), method_20215, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4915c, type_3394), Reflex::Literal("operator[]"), operator_20216, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4915c, type_3394), Reflex::Literal("at"), method_20217, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19827), Reflex::Literal("refVector"), method_20218, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("empty"), method_20219, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("size"), method_20220, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("capacity"), method_20221, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394), Reflex::Literal("reserve"), method_20222, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4602), Reflex::Literal("begin"), method_20223, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4602), Reflex::Literal("end"), method_20224, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4866), Reflex::Literal("id"), method_20225, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19828), Reflex::Literal("productGetter"), method_20226, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isNull"), method_20227, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isNonnull"), method_20228, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("operator!"), operator_20229, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33825), Reflex::Literal("product"), method_20230, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isAvailable"), method_20231, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isTransient"), method_20232, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4602, type_33826), Reflex::Literal("erase"), method_20233, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("clear"), method_20234, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_33827), Reflex::Literal("swap"), method_20235, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33827, type_33823), Reflex::Literal("operator="), operator_20236, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("hasProductCache"), method_20237, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_19738, type_19832, type_19833), Reflex::Literal("fillView"), method_20238, 0, ";pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_192), Reflex::Literal("Class_Version"), method_20239, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefVector<std::vector<reco::PFMET, std::allocator<reco::PFMET> >,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET, std::allocator<reco::PFMET> >, reco::PFMET> > -------------------------------
static void destructor_20253(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >::~RefVector)();
}
static void constructor_20254( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >();
  else ::new(mem) ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >();
}

static void constructor_20255( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >(*(const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >(*(const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)arg[0]);
}

static void constructor_20256( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >(*(const ::edm::ProductID*)arg[0]);
}

static  void method_20257( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->push_back)(*(const ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)arg[0]);
}

static  void operator_20258( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >)((((const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_20259( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >)((((const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_20260( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->refVector)();
  else   (((const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->refVector)();
}

static  void method_20261( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->empty)());
  else   (((const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->empty)();
}

static  void method_20262( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->size)());
  else   (((const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->size)();
}

static  void method_20263( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->capacity)());
  else   (((const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->capacity)();
}

static  void method_20264( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_20265( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >)((((const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->begin)());
  else   (((const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->begin)();
}

static  void method_20266( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >)((((const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->end)());
  else   (((const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->end)();
}

static  void method_20267( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->id)());
  else   (((const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->id)();
}

static  void method_20268( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->productGetter)());
  else   (((const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->productGetter)();
}

static  void method_20269( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->isNull)());
  else   (((const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->isNull)();
}

static  void method_20270( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->isNonnull)());
  else   (((const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->isNonnull)();
}

static  void operator_20271( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->operator!)());
  else   (((const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->operator!)();
}

static  void method_20272( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->product)());
  else   (((const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->product)();
}

static  void method_20273( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->isAvailable)());
  else   (((const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->isAvailable)();
}

static  void method_20274( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->isTransient)());
  else   (((const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->isTransient)();
}

static  void method_20275( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >)((((::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)arg[0]));
  else   (((::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)arg[0]);
}

static  void method_20276( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->clear)();
}

static  void method_20277( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->swap)(*(::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)arg[0]);
}

static  void operator_20278( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)arg[0]);
  else   (((::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)arg[0]);
}

static  void method_20279( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->hasProductCache)());
  else   (((const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->hasProductCache)();
}

static  void method_20280( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_20281( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->Class_Version)());
  else   (((::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->Class_Version)();
}

static void method_newdel_4636( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefVector<std::vector<reco::PFMET, std::allocator<reco::PFMET> >,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET, std::allocator<reco::PFMET> >, reco::PFMET> > -------------------------------
void __edm__RefVector_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s__db_datamem(Reflex::Class*);
void __edm__RefVector_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s__datamem_bld(&__edm__RefVector_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s__funcmem_bld(&__edm__RefVector_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s__db_funcmem);
void __edm__RefVector_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >"), typeid(::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >), sizeof(::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >::Class_Version())
  .AddTypedef(type_3157, Reflex::Literal("edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >::collection_type"))
  .AddTypedef(type_7918, Reflex::Literal("edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >::member_type"))
  .AddTypedef(type_20094, Reflex::Literal("edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >::finder_type"))
  .AddTypedef(type_4603, Reflex::Literal("edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >::iterator"))
  .AddTypedef(type_4603, Reflex::Literal("edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >::const_iterator"))
  .AddTypedef(type_4916, Reflex::Literal("edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >::value_type"))
  .AddTypedef(type_4916c, Reflex::Literal("edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >::const_reference"))
  .AddTypedef(type_4916c, Reflex::Literal("edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >::reference"))
  .AddTypedef(type_373, Reflex::Literal("edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >::key_type"))
  .AddTypedef(type_3156, Reflex::Literal("edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >::KeyVec"))
  .AddTypedef(type_3394, Reflex::Literal("edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >::size_type"))
  .AddTypedef(type_4197, Reflex::Literal("edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >::contents_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVector"), destructor_20253, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVector"), constructor_20254, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33829), Reflex::Literal("RefVector"), constructor_20255, 0, "rh", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19738), Reflex::Literal("RefVector"), constructor_20256, 0, "iId", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4636, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVector_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVector_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s__funcmem_bld);
}

//------Delayed data member builder for class RefVector<std::vector<reco::PFMET, std::allocator<reco::PFMET> >,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET, std::allocator<reco::PFMET> >, reco::PFMET> > -------------------
void __edm__RefVector_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4197, Reflex::Literal("refVector_"), OffsetOf(__shadow__::__edm__RefVector_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_, refVector_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVector<std::vector<reco::PFMET, std::allocator<reco::PFMET> >,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET, std::allocator<reco::PFMET> >, reco::PFMET> > -------------------
void __edm__RefVector_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_33830), Reflex::Literal("push_back"), method_20257, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4916c, type_3394), Reflex::Literal("operator[]"), operator_20258, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4916c, type_3394), Reflex::Literal("at"), method_20259, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19827), Reflex::Literal("refVector"), method_20260, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("empty"), method_20261, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("size"), method_20262, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("capacity"), method_20263, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394), Reflex::Literal("reserve"), method_20264, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4603), Reflex::Literal("begin"), method_20265, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4603), Reflex::Literal("end"), method_20266, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4866), Reflex::Literal("id"), method_20267, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19828), Reflex::Literal("productGetter"), method_20268, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isNull"), method_20269, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isNonnull"), method_20270, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("operator!"), operator_20271, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33831), Reflex::Literal("product"), method_20272, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isAvailable"), method_20273, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isTransient"), method_20274, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4603, type_33832), Reflex::Literal("erase"), method_20275, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("clear"), method_20276, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_33833), Reflex::Literal("swap"), method_20277, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33833, type_33829), Reflex::Literal("operator="), operator_20278, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("hasProductCache"), method_20279, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_19738, type_19832, type_19833), Reflex::Literal("fillView"), method_20280, 0, ";pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_192), Reflex::Literal("Class_Version"), method_20281, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefVector<std::vector<reco::MET, std::allocator<reco::MET> >,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET, std::allocator<reco::MET> >, reco::MET> > -------------------------------
static void destructor_20295(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >::~RefVector)();
}
static void constructor_20296( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >();
  else ::new(mem) ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >();
}

static void constructor_20297( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >(*(const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >(*(const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)arg[0]);
}

static void constructor_20298( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >(*(const ::edm::ProductID*)arg[0]);
}

static  void method_20299( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->push_back)(*(const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)arg[0]);
}

static  void operator_20300( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >)((((const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_20301( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >)((((const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_20302( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->refVector)();
  else   (((const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->refVector)();
}

static  void method_20303( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->empty)());
  else   (((const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->empty)();
}

static  void method_20304( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->size)());
  else   (((const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->size)();
}

static  void method_20305( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->capacity)());
  else   (((const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->capacity)();
}

static  void method_20306( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_20307( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >)((((const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->begin)());
  else   (((const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->begin)();
}

static  void method_20308( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >)((((const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->end)());
  else   (((const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->end)();
}

static  void method_20309( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->id)());
  else   (((const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->id)();
}

static  void method_20310( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->productGetter)());
  else   (((const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->productGetter)();
}

static  void method_20311( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->isNull)());
  else   (((const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->isNull)();
}

static  void method_20312( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->isNonnull)());
  else   (((const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->isNonnull)();
}

static  void operator_20313( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->operator!)());
  else   (((const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->operator!)();
}

static  void method_20314( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->product)());
  else   (((const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->product)();
}

static  void method_20315( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->isAvailable)());
  else   (((const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->isAvailable)();
}

static  void method_20316( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->isTransient)());
  else   (((const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->isTransient)();
}

static  void method_20317( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >)((((::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)arg[0]));
  else   (((::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)arg[0]);
}

static  void method_20318( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->clear)();
}

static  void method_20319( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->swap)(*(::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)arg[0]);
}

static  void operator_20320( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)arg[0]);
  else   (((::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)arg[0]);
}

static  void method_20321( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->hasProductCache)());
  else   (((const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->hasProductCache)();
}

static  void method_20322( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_20323( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->Class_Version)());
  else   (((::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)o)->Class_Version)();
}

static void method_newdel_4641( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefVector<std::vector<reco::MET, std::allocator<reco::MET> >,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET, std::allocator<reco::MET> >, reco::MET> > -------------------------------
void __edm__RefVector_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s__db_datamem(Reflex::Class*);
void __edm__RefVector_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s__datamem_bld(&__edm__RefVector_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s__funcmem_bld(&__edm__RefVector_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s__db_funcmem);
void __edm__RefVector_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >"), typeid(::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >), sizeof(::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >::Class_Version())
  .AddTypedef(type_3146, Reflex::Literal("edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >::collection_type"))
  .AddTypedef(type_7952, Reflex::Literal("edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >::member_type"))
  .AddTypedef(type_20092, Reflex::Literal("edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >::finder_type"))
  .AddTypedef(type_4604, Reflex::Literal("edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >::iterator"))
  .AddTypedef(type_4604, Reflex::Literal("edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >::const_iterator"))
  .AddTypedef(type_4913, Reflex::Literal("edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >::value_type"))
  .AddTypedef(type_4913c, Reflex::Literal("edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >::const_reference"))
  .AddTypedef(type_4913c, Reflex::Literal("edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >::reference"))
  .AddTypedef(type_373, Reflex::Literal("edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >::key_type"))
  .AddTypedef(type_3156, Reflex::Literal("edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >::KeyVec"))
  .AddTypedef(type_3394, Reflex::Literal("edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >::size_type"))
  .AddTypedef(type_4197, Reflex::Literal("edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >::contents_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVector"), destructor_20295, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVector"), constructor_20296, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33834), Reflex::Literal("RefVector"), constructor_20297, 0, "rh", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19738), Reflex::Literal("RefVector"), constructor_20298, 0, "iId", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4641, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVector_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVector_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s__funcmem_bld);
}

//------Delayed data member builder for class RefVector<std::vector<reco::MET, std::allocator<reco::MET> >,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET, std::allocator<reco::MET> >, reco::MET> > -------------------
void __edm__RefVector_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4197, Reflex::Literal("refVector_"), OffsetOf(__shadow__::__edm__RefVector_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_, refVector_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVector<std::vector<reco::MET, std::allocator<reco::MET> >,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET, std::allocator<reco::MET> >, reco::MET> > -------------------
void __edm__RefVector_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_13570), Reflex::Literal("push_back"), method_20299, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4913c, type_3394), Reflex::Literal("operator[]"), operator_20300, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4913c, type_3394), Reflex::Literal("at"), method_20301, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19827), Reflex::Literal("refVector"), method_20302, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("empty"), method_20303, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("size"), method_20304, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("capacity"), method_20305, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394), Reflex::Literal("reserve"), method_20306, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4604), Reflex::Literal("begin"), method_20307, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4604), Reflex::Literal("end"), method_20308, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4866), Reflex::Literal("id"), method_20309, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19828), Reflex::Literal("productGetter"), method_20310, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isNull"), method_20311, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isNonnull"), method_20312, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("operator!"), operator_20313, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33835), Reflex::Literal("product"), method_20314, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isAvailable"), method_20315, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isTransient"), method_20316, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4604, type_33836), Reflex::Literal("erase"), method_20317, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("clear"), method_20318, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_33837), Reflex::Literal("swap"), method_20319, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33837, type_33834), Reflex::Literal("operator="), operator_20320, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("hasProductCache"), method_20321, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_19738, type_19832, type_19833), Reflex::Literal("fillView"), method_20322, 0, ";pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_192), Reflex::Literal("Class_Version"), method_20323, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefVector<std::vector<reco::GenMET, std::allocator<reco::GenMET> >,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET, std::allocator<reco::GenMET> >, reco::GenMET> > -------------------------------
static void destructor_20337(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >::~RefVector)();
}
static void constructor_20338( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >();
  else ::new(mem) ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >();
}

static void constructor_20339( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >(*(const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >(*(const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)arg[0]);
}

static void constructor_20340( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >(*(const ::edm::ProductID*)arg[0]);
}

static  void method_20341( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->push_back)(*(const ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)arg[0]);
}

static  void operator_20342( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >)((((const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_20343( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >)((((const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_20344( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->refVector)();
  else   (((const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->refVector)();
}

static  void method_20345( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->empty)());
  else   (((const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->empty)();
}

static  void method_20346( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->size)());
  else   (((const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->size)();
}

static  void method_20347( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->capacity)());
  else   (((const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->capacity)();
}

static  void method_20348( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_20349( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >)((((const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->begin)());
  else   (((const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->begin)();
}

static  void method_20350( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >)((((const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->end)());
  else   (((const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->end)();
}

static  void method_20351( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->id)());
  else   (((const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->id)();
}

static  void method_20352( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->productGetter)());
  else   (((const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->productGetter)();
}

static  void method_20353( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->isNull)());
  else   (((const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->isNull)();
}

static  void method_20354( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->isNonnull)());
  else   (((const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->isNonnull)();
}

static  void operator_20355( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->operator!)());
  else   (((const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->operator!)();
}

static  void method_20356( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->product)());
  else   (((const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->product)();
}

static  void method_20357( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->isAvailable)());
  else   (((const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->isAvailable)();
}

static  void method_20358( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->isTransient)());
  else   (((const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->isTransient)();
}

static  void method_20359( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >)((((::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)arg[0]));
  else   (((::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)arg[0]);
}

static  void method_20360( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->clear)();
}

static  void method_20361( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->swap)(*(::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)arg[0]);
}

static  void operator_20362( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)arg[0]);
  else   (((::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)arg[0]);
}

static  void method_20363( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->hasProductCache)());
  else   (((const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->hasProductCache)();
}

static  void method_20364( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_20365( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->Class_Version)());
  else   (((::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->Class_Version)();
}

static void method_newdel_4646( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefVector<std::vector<reco::GenMET, std::allocator<reco::GenMET> >,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET, std::allocator<reco::GenMET> >, reco::GenMET> > -------------------------------
void __edm__RefVector_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s__db_datamem(Reflex::Class*);
void __edm__RefVector_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s__datamem_bld(&__edm__RefVector_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s__funcmem_bld(&__edm__RefVector_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s__db_funcmem);
void __edm__RefVector_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >"), typeid(::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >), sizeof(::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >::Class_Version())
  .AddTypedef(type_3158, Reflex::Literal("edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >::collection_type"))
  .AddTypedef(type_7970, Reflex::Literal("edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >::member_type"))
  .AddTypedef(type_20095, Reflex::Literal("edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >::finder_type"))
  .AddTypedef(type_4605, Reflex::Literal("edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >::iterator"))
  .AddTypedef(type_4605, Reflex::Literal("edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >::const_iterator"))
  .AddTypedef(type_4917, Reflex::Literal("edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >::value_type"))
  .AddTypedef(type_4917c, Reflex::Literal("edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >::const_reference"))
  .AddTypedef(type_4917c, Reflex::Literal("edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >::reference"))
  .AddTypedef(type_373, Reflex::Literal("edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >::key_type"))
  .AddTypedef(type_3156, Reflex::Literal("edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >::KeyVec"))
  .AddTypedef(type_3394, Reflex::Literal("edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >::size_type"))
  .AddTypedef(type_4197, Reflex::Literal("edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >::contents_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVector"), destructor_20337, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVector"), constructor_20338, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33839), Reflex::Literal("RefVector"), constructor_20339, 0, "rh", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19738), Reflex::Literal("RefVector"), constructor_20340, 0, "iId", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4646, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVector_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVector_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s__funcmem_bld);
}

//------Delayed data member builder for class RefVector<std::vector<reco::GenMET, std::allocator<reco::GenMET> >,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET, std::allocator<reco::GenMET> >, reco::GenMET> > -------------------
void __edm__RefVector_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4197, Reflex::Literal("refVector_"), OffsetOf(__shadow__::__edm__RefVector_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_, refVector_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVector<std::vector<reco::GenMET, std::allocator<reco::GenMET> >,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET, std::allocator<reco::GenMET> >, reco::GenMET> > -------------------
void __edm__RefVector_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_33840), Reflex::Literal("push_back"), method_20341, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4917c, type_3394), Reflex::Literal("operator[]"), operator_20342, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4917c, type_3394), Reflex::Literal("at"), method_20343, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19827), Reflex::Literal("refVector"), method_20344, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("empty"), method_20345, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("size"), method_20346, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("capacity"), method_20347, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394), Reflex::Literal("reserve"), method_20348, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4605), Reflex::Literal("begin"), method_20349, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4605), Reflex::Literal("end"), method_20350, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4866), Reflex::Literal("id"), method_20351, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19828), Reflex::Literal("productGetter"), method_20352, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isNull"), method_20353, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isNonnull"), method_20354, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("operator!"), operator_20355, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33841), Reflex::Literal("product"), method_20356, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isAvailable"), method_20357, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isTransient"), method_20358, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4605, type_33842), Reflex::Literal("erase"), method_20359, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("clear"), method_20360, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_33843), Reflex::Literal("swap"), method_20361, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33843, type_33839), Reflex::Literal("operator="), operator_20362, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("hasProductCache"), method_20363, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_19738, type_19832, type_19833), Reflex::Literal("fillView"), method_20364, 0, ";pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_192), Reflex::Literal("Class_Version"), method_20365, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefVector<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >, reco::CaloMET> > -------------------------------
static void destructor_20379(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >::~RefVector)();
}
static void constructor_20380( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >();
  else ::new(mem) ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >();
}

static void constructor_20381( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >(*(const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >(*(const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)arg[0]);
}

static void constructor_20382( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >(*(const ::edm::ProductID*)arg[0]);
}

static  void method_20383( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->push_back)(*(const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)arg[0]);
}

static  void operator_20384( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >)((((const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->operator[])(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_20385( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >)((((const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->at)(*(::std::size_t*)arg[0]));
  else   (((const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_20386( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->refVector)();
  else   (((const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->refVector)();
}

static  void method_20387( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->empty)());
  else   (((const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->empty)();
}

static  void method_20388( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->size)());
  else   (((const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->size)();
}

static  void method_20389( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->capacity)());
  else   (((const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->capacity)();
}

static  void method_20390( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void method_20391( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >)((((const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->begin)());
  else   (((const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->begin)();
}

static  void method_20392( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >)((((const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->end)());
  else   (((const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->end)();
}

static  void method_20393( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->id)());
  else   (((const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->id)();
}

static  void method_20394( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->productGetter)());
  else   (((const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->productGetter)();
}

static  void method_20395( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->isNull)());
  else   (((const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->isNull)();
}

static  void method_20396( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->isNonnull)());
  else   (((const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->isNonnull)();
}

static  void operator_20397( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->operator!)());
  else   (((const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->operator!)();
}

static  void method_20398( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->product)());
  else   (((const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->product)();
}

static  void method_20399( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->isAvailable)());
  else   (((const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->isAvailable)();
}

static  void method_20400( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->isTransient)());
  else   (((const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->isTransient)();
}

static  void method_20401( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::RefVectorIterator<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >)((((::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)arg[0]));
  else   (((::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->erase)(*(const ::edm::RefVectorIterator<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)arg[0]);
}

static  void method_20402( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->clear)();
}

static  void method_20403( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->swap)(*(::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)arg[0]);
}

static  void operator_20404( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)arg[0]);
  else   (((::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->operator=)(*(const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)arg[0]);
}

static  void method_20405( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->hasProductCache)());
  else   (((const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->hasProductCache)();
}

static  void method_20406( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::edm::helper_vector*)arg[2]);
}

static  void method_20407( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->Class_Version)());
  else   (((::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)o)->Class_Version)();
}

static void method_newdel_4651( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefVector<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >, reco::CaloMET> > -------------------------------
void __edm__RefVector_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s__db_datamem(Reflex::Class*);
void __edm__RefVector_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s__datamem_bld(&__edm__RefVector_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefVector_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s__funcmem_bld(&__edm__RefVector_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s__db_funcmem);
void __edm__RefVector_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >"), typeid(::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >), sizeof(::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >::Class_Version())
  .AddTypedef(type_3148, Reflex::Literal("edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >::collection_type"))
  .AddTypedef(type_8011, Reflex::Literal("edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >::member_type"))
  .AddTypedef(type_20091, Reflex::Literal("edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >::finder_type"))
  .AddTypedef(type_4606, Reflex::Literal("edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >::iterator"))
  .AddTypedef(type_4606, Reflex::Literal("edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >::const_iterator"))
  .AddTypedef(type_4914, Reflex::Literal("edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >::value_type"))
  .AddTypedef(type_4914c, Reflex::Literal("edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >::const_reference"))
  .AddTypedef(type_4914c, Reflex::Literal("edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >::reference"))
  .AddTypedef(type_373, Reflex::Literal("edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >::key_type"))
  .AddTypedef(type_3156, Reflex::Literal("edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >::KeyVec"))
  .AddTypedef(type_3394, Reflex::Literal("edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >::size_type"))
  .AddTypedef(type_4197, Reflex::Literal("edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >::contents_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefVector"), destructor_20379, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefVector"), constructor_20380, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33844), Reflex::Literal("RefVector"), constructor_20381, 0, "rh", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19738), Reflex::Literal("RefVector"), constructor_20382, 0, "iId", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4651, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefVector_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefVector_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s__funcmem_bld);
}

//------Delayed data member builder for class RefVector<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >, reco::CaloMET> > -------------------
void __edm__RefVector_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4197, Reflex::Literal("refVector_"), OffsetOf(__shadow__::__edm__RefVector_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_, refVector_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefVector<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >, reco::CaloMET> > -------------------
void __edm__RefVector_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_13700), Reflex::Literal("push_back"), method_20383, 0, "ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4914c, type_3394), Reflex::Literal("operator[]"), operator_20384, 0, "idx", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4914c, type_3394), Reflex::Literal("at"), method_20385, 0, "idx", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19827), Reflex::Literal("refVector"), method_20386, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("empty"), method_20387, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("size"), method_20388, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("capacity"), method_20389, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394), Reflex::Literal("reserve"), method_20390, 0, "n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4606), Reflex::Literal("begin"), method_20391, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4606), Reflex::Literal("end"), method_20392, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4866), Reflex::Literal("id"), method_20393, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19828), Reflex::Literal("productGetter"), method_20394, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isNull"), method_20395, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isNonnull"), method_20396, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("operator!"), operator_20397, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33845), Reflex::Literal("product"), method_20398, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isAvailable"), method_20399, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isTransient"), method_20400, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4606, type_33846), Reflex::Literal("erase"), method_20401, 0, "pos", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("clear"), method_20402, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_33847), Reflex::Literal("swap"), method_20403, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33847, type_33844), Reflex::Literal("operator="), operator_20404, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("hasProductCache"), method_20405, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_19738, type_19832, type_19833), Reflex::Literal("fillView"), method_20406, 0, ";pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_192), Reflex::Literal("Class_Version"), method_20407, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Wrapper<std::vector<BoundaryInformation, std::allocator<BoundaryInformation> > > -------------------------------
static void constructor_20622( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BoundaryInformation> >();
  else ::new(mem) ::edm::Wrapper<std::vector<BoundaryInformation> >();
}

static void constructor_20623( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BoundaryInformation> >(*(::std::auto_ptr<std::vector<BoundaryInformation> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<BoundaryInformation> >(*(::std::auto_ptr<std::vector<BoundaryInformation> >*)arg[0]);
}

static void destructor_20624(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<BoundaryInformation> >*)o)->::edm::Wrapper<std::vector<BoundaryInformation> >::~Wrapper)();
}
static  void method_20625( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<BoundaryInformation> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<BoundaryInformation> >*)o)->product)();
}

static  void operator_20626( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<BoundaryInformation> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<BoundaryInformation> >*)o)->operator->)();
}

static  void method_20627( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<BoundaryInformation> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<BoundaryInformation> >*)o)->productTypeInfo)();
}

static  void method_20628( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<BoundaryInformation> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<BoundaryInformation> >*)o)->typeInfo)();
}

static void constructor_20629( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<BoundaryInformation> >((::std::vector<BoundaryInformation>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<BoundaryInformation> >((::std::vector<BoundaryInformation>*)arg[0]);
}

static  void method_20630( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<BoundaryInformation> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<BoundaryInformation> >*)o)->getInterface)();
}

static  void method_20631( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BoundaryInformation> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_20632( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BoundaryInformation> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_20633( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<BoundaryInformation> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_20634( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<BoundaryInformation> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<BoundaryInformation> >*)o)->dynamicTypeInfo)();
}

static  void method_20635( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<BoundaryInformation> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<BoundaryInformation> >*)o)->isPresent)();
}

static  void method_20636( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<BoundaryInformation> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<BoundaryInformation> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4694( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BoundaryInformation> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BoundaryInformation> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BoundaryInformation> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BoundaryInformation> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<BoundaryInformation> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<BoundaryInformation, std::allocator<BoundaryInformation> > > -------------------------------
void __edm__Wrapper_std__vector_BoundaryInformation_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_BoundaryInformation_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_BoundaryInformation_s__datamem_bld(&__edm__Wrapper_std__vector_BoundaryInformation_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_BoundaryInformation_s__funcmem_bld(&__edm__Wrapper_std__vector_BoundaryInformation_s__db_funcmem);
void __edm__Wrapper_std__vector_BoundaryInformation_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<BoundaryInformation> >"), typeid(::edm::Wrapper<std::vector<BoundaryInformation> >), sizeof(::edm::Wrapper<std::vector<BoundaryInformation> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3139, Reflex::Literal("edm::Wrapper<std::vector<BoundaryInformation> >::value_type"))
  .AddTypedef(type_3139, Reflex::Literal("edm::Wrapper<std::vector<BoundaryInformation> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_20622, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2873), Reflex::Literal("Wrapper"), constructor_20623, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_20624, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33877), Reflex::Literal("Wrapper"), constructor_20629, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4694, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_BoundaryInformation_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_BoundaryInformation_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<BoundaryInformation, std::allocator<BoundaryInformation> > > -------------------
void __edm__Wrapper_std__vector_BoundaryInformation_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1647, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_BoundaryInformation_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3139, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_BoundaryInformation_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<BoundaryInformation, std::allocator<BoundaryInformation> > > -------------------
void __edm__Wrapper_std__vector_BoundaryInformation_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33876), Reflex::Literal("product"), method_20625, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33876), Reflex::Literal("operator->"), operator_20626, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("productTypeInfo"), method_20627, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("typeInfo"), method_20628, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33878), Reflex::Literal("getInterface"), method_20630, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_19738, type_19832, type_33879), Reflex::Literal("fillView"), method_20631, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_364, type_10395), Reflex::Literal("setPtr"), method_20632, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_19897, type_19832), Reflex::Literal("fillPtrVector"), method_20633, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo"), method_20634, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isPresent"), method_20635, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo_"), method_20636, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<BoundaryInformation> -------------------------------
static void constructor_20643( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BoundaryInformation>();
  else ::new(mem) ::edm::Wrapper<BoundaryInformation>();
}

static void constructor_20644( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BoundaryInformation>(*(::std::auto_ptr<BoundaryInformation>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<BoundaryInformation>(*(::std::auto_ptr<BoundaryInformation>*)arg[0]);
}

static void destructor_20645(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<BoundaryInformation>*)o)->::edm::Wrapper<BoundaryInformation>::~Wrapper)();
}
static  void method_20646( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<BoundaryInformation>*)o)->product)());
  else   (((const ::edm::Wrapper<BoundaryInformation>*)o)->product)();
}

static  void operator_20647( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<BoundaryInformation>*)o)->operator->)());
  else   (((const ::edm::Wrapper<BoundaryInformation>*)o)->operator->)();
}

static  void method_20648( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<BoundaryInformation>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<BoundaryInformation>*)o)->productTypeInfo)();
}

static  void method_20649( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<BoundaryInformation>*)o)->typeInfo)();
  else   (((::edm::Wrapper<BoundaryInformation>*)o)->typeInfo)();
}

static void constructor_20650( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<BoundaryInformation>((::BoundaryInformation*)arg[0]);
  else ::new(mem) ::edm::Wrapper<BoundaryInformation>((::BoundaryInformation*)arg[0]);
}

static  void method_20651( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<BoundaryInformation>*)o)->getInterface)());
  else   (((::edm::Wrapper<BoundaryInformation>*)o)->getInterface)();
}

static  void method_20652( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BoundaryInformation>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_20653( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BoundaryInformation>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_20654( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<BoundaryInformation>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_20655( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<BoundaryInformation>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<BoundaryInformation>*)o)->dynamicTypeInfo)();
}

static  void method_20656( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<BoundaryInformation>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<BoundaryInformation>*)o)->isPresent)();
}

static  void method_20657( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<BoundaryInformation>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<BoundaryInformation>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4695( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BoundaryInformation> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BoundaryInformation> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BoundaryInformation> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BoundaryInformation> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<BoundaryInformation> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<BoundaryInformation> -------------------------------
void __edm__Wrapper_BoundaryInformation__db_datamem(Reflex::Class*);
void __edm__Wrapper_BoundaryInformation__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_BoundaryInformation__datamem_bld(&__edm__Wrapper_BoundaryInformation__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_BoundaryInformation__funcmem_bld(&__edm__Wrapper_BoundaryInformation__db_funcmem);
void __edm__Wrapper_BoundaryInformation__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<BoundaryInformation>"), typeid(::edm::Wrapper<BoundaryInformation>), sizeof(::edm::Wrapper<BoundaryInformation>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2126, Reflex::Literal("edm::Wrapper<BoundaryInformation>::value_type"))
  .AddTypedef(type_2126, Reflex::Literal("edm::Wrapper<BoundaryInformation>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_20643, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2874), Reflex::Literal("Wrapper"), constructor_20644, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_20645, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13174), Reflex::Literal("Wrapper"), constructor_20650, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4695, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_BoundaryInformation__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_BoundaryInformation__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<BoundaryInformation> -------------------
void __edm__Wrapper_BoundaryInformation__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1647, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_BoundaryInformation_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2126, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_BoundaryInformation_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<BoundaryInformation> -------------------
void __edm__Wrapper_BoundaryInformation__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13176), Reflex::Literal("product"), method_20646, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13176), Reflex::Literal("operator->"), operator_20647, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("productTypeInfo"), method_20648, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("typeInfo"), method_20649, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33882), Reflex::Literal("getInterface"), method_20651, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_19738, type_19832, type_33879), Reflex::Literal("fillView"), method_20652, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_364, type_10395), Reflex::Literal("setPtr"), method_20653, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_19897, type_19832), Reflex::Literal("fillPtrVector"), method_20654, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo"), method_20655, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isPresent"), method_20656, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo_"), method_20657, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<AnomalousECALVariables> -------------------------------
static void constructor_20664( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<AnomalousECALVariables>();
  else ::new(mem) ::edm::Wrapper<AnomalousECALVariables>();
}

static void constructor_20665( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<AnomalousECALVariables>(*(::std::auto_ptr<AnomalousECALVariables>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<AnomalousECALVariables>(*(::std::auto_ptr<AnomalousECALVariables>*)arg[0]);
}

static void destructor_20666(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<AnomalousECALVariables>*)o)->::edm::Wrapper<AnomalousECALVariables>::~Wrapper)();
}
static  void method_20667( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<AnomalousECALVariables>*)o)->product)());
  else   (((const ::edm::Wrapper<AnomalousECALVariables>*)o)->product)();
}

static  void operator_20668( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<AnomalousECALVariables>*)o)->operator->)());
  else   (((const ::edm::Wrapper<AnomalousECALVariables>*)o)->operator->)();
}

static  void method_20669( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<AnomalousECALVariables>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<AnomalousECALVariables>*)o)->productTypeInfo)();
}

static  void method_20670( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<AnomalousECALVariables>*)o)->typeInfo)();
  else   (((::edm::Wrapper<AnomalousECALVariables>*)o)->typeInfo)();
}

static void constructor_20671( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<AnomalousECALVariables>((::AnomalousECALVariables*)arg[0]);
  else ::new(mem) ::edm::Wrapper<AnomalousECALVariables>((::AnomalousECALVariables*)arg[0]);
}

static  void method_20672( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<AnomalousECALVariables>*)o)->getInterface)());
  else   (((::edm::Wrapper<AnomalousECALVariables>*)o)->getInterface)();
}

static  void method_20673( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<AnomalousECALVariables>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_20674( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<AnomalousECALVariables>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_20675( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<AnomalousECALVariables>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_20676( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<AnomalousECALVariables>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<AnomalousECALVariables>*)o)->dynamicTypeInfo)();
}

static  void method_20677( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<AnomalousECALVariables>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<AnomalousECALVariables>*)o)->isPresent)();
}

static  void method_20678( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<AnomalousECALVariables>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<AnomalousECALVariables>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4696( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<AnomalousECALVariables> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<AnomalousECALVariables> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<AnomalousECALVariables> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<AnomalousECALVariables> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<AnomalousECALVariables> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<AnomalousECALVariables> -------------------------------
void __edm__Wrapper_AnomalousECALVariables__db_datamem(Reflex::Class*);
void __edm__Wrapper_AnomalousECALVariables__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_AnomalousECALVariables__datamem_bld(&__edm__Wrapper_AnomalousECALVariables__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_AnomalousECALVariables__funcmem_bld(&__edm__Wrapper_AnomalousECALVariables__db_funcmem);
void __edm__Wrapper_AnomalousECALVariables__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<AnomalousECALVariables>"), typeid(::edm::Wrapper<AnomalousECALVariables>), sizeof(::edm::Wrapper<AnomalousECALVariables>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1114, Reflex::Literal("edm::Wrapper<AnomalousECALVariables>::value_type"))
  .AddTypedef(type_1114, Reflex::Literal("edm::Wrapper<AnomalousECALVariables>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_20664, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2875), Reflex::Literal("Wrapper"), constructor_20665, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_20666, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33886), Reflex::Literal("Wrapper"), constructor_20671, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4696, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_AnomalousECALVariables__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_AnomalousECALVariables__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<AnomalousECALVariables> -------------------
void __edm__Wrapper_AnomalousECALVariables__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1647, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_AnomalousECALVariables_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1114, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_AnomalousECALVariables_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<AnomalousECALVariables> -------------------
void __edm__Wrapper_AnomalousECALVariables__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33885), Reflex::Literal("product"), method_20667, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33885), Reflex::Literal("operator->"), operator_20668, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("productTypeInfo"), method_20669, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("typeInfo"), method_20670, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33887), Reflex::Literal("getInterface"), method_20672, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_19738, type_19832, type_33879), Reflex::Literal("fillView"), method_20673, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_364, type_10395), Reflex::Literal("setPtr"), method_20674, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_19897, type_19832), Reflex::Literal("fillPtrVector"), method_20675, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo"), method_20676, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isPresent"), method_20677, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo_"), method_20678, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<PFMEtSignCovMatrix> -------------------------------
static void constructor_20685( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PFMEtSignCovMatrix>();
  else ::new(mem) ::edm::Wrapper<PFMEtSignCovMatrix>();
}

static void constructor_20686( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PFMEtSignCovMatrix>(*(::std::auto_ptr<PFMEtSignCovMatrix>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PFMEtSignCovMatrix>(*(::std::auto_ptr<PFMEtSignCovMatrix>*)arg[0]);
}

static void destructor_20687(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<PFMEtSignCovMatrix>*)o)->::edm::Wrapper<PFMEtSignCovMatrix>::~Wrapper)();
}
static  void method_20688( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PFMEtSignCovMatrix>*)o)->product)());
  else   (((const ::edm::Wrapper<PFMEtSignCovMatrix>*)o)->product)();
}

static  void operator_20689( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<PFMEtSignCovMatrix>*)o)->operator->)());
  else   (((const ::edm::Wrapper<PFMEtSignCovMatrix>*)o)->operator->)();
}

static  void method_20690( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PFMEtSignCovMatrix>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<PFMEtSignCovMatrix>*)o)->productTypeInfo)();
}

static  void method_20691( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<PFMEtSignCovMatrix>*)o)->typeInfo)();
  else   (((::edm::Wrapper<PFMEtSignCovMatrix>*)o)->typeInfo)();
}

static void constructor_20692( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<PFMEtSignCovMatrix>((::PFMEtSignCovMatrix*)arg[0]);
  else ::new(mem) ::edm::Wrapper<PFMEtSignCovMatrix>((::PFMEtSignCovMatrix*)arg[0]);
}

static  void method_20693( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<PFMEtSignCovMatrix>*)o)->getInterface)());
  else   (((::edm::Wrapper<PFMEtSignCovMatrix>*)o)->getInterface)();
}

static  void method_20694( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PFMEtSignCovMatrix>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_20695( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PFMEtSignCovMatrix>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_20696( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<PFMEtSignCovMatrix>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_20697( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PFMEtSignCovMatrix>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<PFMEtSignCovMatrix>*)o)->dynamicTypeInfo)();
}

static  void method_20698( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<PFMEtSignCovMatrix>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<PFMEtSignCovMatrix>*)o)->isPresent)();
}

static  void method_20699( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<PFMEtSignCovMatrix>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<PFMEtSignCovMatrix>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4697( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PFMEtSignCovMatrix> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PFMEtSignCovMatrix> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PFMEtSignCovMatrix> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PFMEtSignCovMatrix> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<PFMEtSignCovMatrix> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<PFMEtSignCovMatrix> -------------------------------
void __edm__Wrapper_PFMEtSignCovMatrix__db_datamem(Reflex::Class*);
void __edm__Wrapper_PFMEtSignCovMatrix__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PFMEtSignCovMatrix__datamem_bld(&__edm__Wrapper_PFMEtSignCovMatrix__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_PFMEtSignCovMatrix__funcmem_bld(&__edm__Wrapper_PFMEtSignCovMatrix__db_funcmem);
void __edm__Wrapper_PFMEtSignCovMatrix__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<PFMEtSignCovMatrix>"), typeid(::edm::Wrapper<PFMEtSignCovMatrix>), sizeof(::edm::Wrapper<PFMEtSignCovMatrix>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2233, Reflex::Literal("edm::Wrapper<PFMEtSignCovMatrix>::value_type"))
  .AddTypedef(type_2233, Reflex::Literal("edm::Wrapper<PFMEtSignCovMatrix>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_20685, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2876), Reflex::Literal("Wrapper"), constructor_20686, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_20687, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33891), Reflex::Literal("Wrapper"), constructor_20692, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4697, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_PFMEtSignCovMatrix__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_PFMEtSignCovMatrix__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<PFMEtSignCovMatrix> -------------------
void __edm__Wrapper_PFMEtSignCovMatrix__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1647, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_PFMEtSignCovMatrix_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2233, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_PFMEtSignCovMatrix_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<PFMEtSignCovMatrix> -------------------
void __edm__Wrapper_PFMEtSignCovMatrix__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33890), Reflex::Literal("product"), method_20688, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33890), Reflex::Literal("operator->"), operator_20689, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("productTypeInfo"), method_20690, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("typeInfo"), method_20691, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33892), Reflex::Literal("getInterface"), method_20693, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_19738, type_19832, type_33879), Reflex::Literal("fillView"), method_20694, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_364, type_10395), Reflex::Literal("setPtr"), method_20695, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_19897, type_19832), Reflex::Literal("fillPtrVector"), method_20696, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo"), method_20697, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isPresent"), method_20698, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo_"), method_20699, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<metsig::SigInputObj, std::allocator<metsig::SigInputObj> > > -------------------------------
static void constructor_20748( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<metsig::SigInputObj> >();
  else ::new(mem) ::edm::Wrapper<std::vector<metsig::SigInputObj> >();
}

static void constructor_20749( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<metsig::SigInputObj> >(*(::std::auto_ptr<std::vector<metsig::SigInputObj> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<metsig::SigInputObj> >(*(::std::auto_ptr<std::vector<metsig::SigInputObj> >*)arg[0]);
}

static void destructor_20750(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<metsig::SigInputObj> >*)o)->::edm::Wrapper<std::vector<metsig::SigInputObj> >::~Wrapper)();
}
static  void method_20751( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<metsig::SigInputObj> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<metsig::SigInputObj> >*)o)->product)();
}

static  void operator_20752( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<metsig::SigInputObj> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<metsig::SigInputObj> >*)o)->operator->)();
}

static  void method_20753( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<metsig::SigInputObj> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<metsig::SigInputObj> >*)o)->productTypeInfo)();
}

static  void method_20754( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<metsig::SigInputObj> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<metsig::SigInputObj> >*)o)->typeInfo)();
}

static void constructor_20755( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<metsig::SigInputObj> >((::std::vector<metsig::SigInputObj>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<metsig::SigInputObj> >((::std::vector<metsig::SigInputObj>*)arg[0]);
}

static  void method_20756( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<metsig::SigInputObj> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<metsig::SigInputObj> >*)o)->getInterface)();
}

static  void method_20757( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<metsig::SigInputObj> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_20758( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<metsig::SigInputObj> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_20759( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<metsig::SigInputObj> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_20760( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<metsig::SigInputObj> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<metsig::SigInputObj> >*)o)->dynamicTypeInfo)();
}

static  void method_20761( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<metsig::SigInputObj> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<metsig::SigInputObj> >*)o)->isPresent)();
}

static  void method_20762( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<metsig::SigInputObj> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<metsig::SigInputObj> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4700( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<metsig::SigInputObj> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<metsig::SigInputObj> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<metsig::SigInputObj> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<metsig::SigInputObj> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<metsig::SigInputObj> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<metsig::SigInputObj, std::allocator<metsig::SigInputObj> > > -------------------------------
void __edm__Wrapper_std__vector_metsig__SigInputObj_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_metsig__SigInputObj_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_metsig__SigInputObj_s__datamem_bld(&__edm__Wrapper_std__vector_metsig__SigInputObj_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_metsig__SigInputObj_s__funcmem_bld(&__edm__Wrapper_std__vector_metsig__SigInputObj_s__db_funcmem);
void __edm__Wrapper_std__vector_metsig__SigInputObj_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<metsig::SigInputObj> >"), typeid(::edm::Wrapper<std::vector<metsig::SigInputObj> >), sizeof(::edm::Wrapper<std::vector<metsig::SigInputObj> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3142, Reflex::Literal("edm::Wrapper<std::vector<metsig::SigInputObj> >::value_type"))
  .AddTypedef(type_3142, Reflex::Literal("edm::Wrapper<std::vector<metsig::SigInputObj> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_20748, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2879), Reflex::Literal("Wrapper"), constructor_20749, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_20750, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33906), Reflex::Literal("Wrapper"), constructor_20755, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4700, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_metsig__SigInputObj_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_metsig__SigInputObj_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<metsig::SigInputObj, std::allocator<metsig::SigInputObj> > > -------------------
void __edm__Wrapper_std__vector_metsig__SigInputObj_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1647, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_metsig__SigInputObj_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3142, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_metsig__SigInputObj_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<metsig::SigInputObj, std::allocator<metsig::SigInputObj> > > -------------------
void __edm__Wrapper_std__vector_metsig__SigInputObj_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33905), Reflex::Literal("product"), method_20751, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33905), Reflex::Literal("operator->"), operator_20752, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("productTypeInfo"), method_20753, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("typeInfo"), method_20754, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33907), Reflex::Literal("getInterface"), method_20756, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_19738, type_19832, type_33879), Reflex::Literal("fillView"), method_20757, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_364, type_10395), Reflex::Literal("setPtr"), method_20758, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_19897, type_19832), Reflex::Literal("fillPtrVector"), method_20759, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo"), method_20760, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isPresent"), method_20761, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo_"), method_20762, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<metsig::SigInputObj> -------------------------------
static void constructor_20769( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<metsig::SigInputObj>();
  else ::new(mem) ::edm::Wrapper<metsig::SigInputObj>();
}

static void constructor_20770( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<metsig::SigInputObj>(*(::std::auto_ptr<metsig::SigInputObj>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<metsig::SigInputObj>(*(::std::auto_ptr<metsig::SigInputObj>*)arg[0]);
}

static void destructor_20771(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<metsig::SigInputObj>*)o)->::edm::Wrapper<metsig::SigInputObj>::~Wrapper)();
}
static  void method_20772( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<metsig::SigInputObj>*)o)->product)());
  else   (((const ::edm::Wrapper<metsig::SigInputObj>*)o)->product)();
}

static  void operator_20773( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<metsig::SigInputObj>*)o)->operator->)());
  else   (((const ::edm::Wrapper<metsig::SigInputObj>*)o)->operator->)();
}

static  void method_20774( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<metsig::SigInputObj>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<metsig::SigInputObj>*)o)->productTypeInfo)();
}

static  void method_20775( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<metsig::SigInputObj>*)o)->typeInfo)();
  else   (((::edm::Wrapper<metsig::SigInputObj>*)o)->typeInfo)();
}

static void constructor_20776( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<metsig::SigInputObj>((::metsig::SigInputObj*)arg[0]);
  else ::new(mem) ::edm::Wrapper<metsig::SigInputObj>((::metsig::SigInputObj*)arg[0]);
}

static  void method_20777( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<metsig::SigInputObj>*)o)->getInterface)());
  else   (((::edm::Wrapper<metsig::SigInputObj>*)o)->getInterface)();
}

static  void method_20778( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<metsig::SigInputObj>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_20779( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<metsig::SigInputObj>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_20780( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<metsig::SigInputObj>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_20781( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<metsig::SigInputObj>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<metsig::SigInputObj>*)o)->dynamicTypeInfo)();
}

static  void method_20782( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<metsig::SigInputObj>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<metsig::SigInputObj>*)o)->isPresent)();
}

static  void method_20783( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<metsig::SigInputObj>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<metsig::SigInputObj>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4701( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<metsig::SigInputObj> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<metsig::SigInputObj> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<metsig::SigInputObj> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<metsig::SigInputObj> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<metsig::SigInputObj> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<metsig::SigInputObj> -------------------------------
void __edm__Wrapper_metsig__SigInputObj__db_datamem(Reflex::Class*);
void __edm__Wrapper_metsig__SigInputObj__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_metsig__SigInputObj__datamem_bld(&__edm__Wrapper_metsig__SigInputObj__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_metsig__SigInputObj__funcmem_bld(&__edm__Wrapper_metsig__SigInputObj__db_funcmem);
void __edm__Wrapper_metsig__SigInputObj__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<metsig::SigInputObj>"), typeid(::edm::Wrapper<metsig::SigInputObj>), sizeof(::edm::Wrapper<metsig::SigInputObj>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3824, Reflex::Literal("edm::Wrapper<metsig::SigInputObj>::value_type"))
  .AddTypedef(type_3824, Reflex::Literal("edm::Wrapper<metsig::SigInputObj>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_20769, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2880), Reflex::Literal("Wrapper"), constructor_20770, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_20771, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13369), Reflex::Literal("Wrapper"), constructor_20776, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4701, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_metsig__SigInputObj__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_metsig__SigInputObj__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<metsig::SigInputObj> -------------------
void __edm__Wrapper_metsig__SigInputObj__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1647, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_metsig__SigInputObj_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3824, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_metsig__SigInputObj_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<metsig::SigInputObj> -------------------
void __edm__Wrapper_metsig__SigInputObj__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13371), Reflex::Literal("product"), method_20772, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13371), Reflex::Literal("operator->"), operator_20773, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("productTypeInfo"), method_20774, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("typeInfo"), method_20775, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33910), Reflex::Literal("getInterface"), method_20777, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_19738, type_19832, type_33879), Reflex::Literal("fillView"), method_20778, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_364, type_10395), Reflex::Literal("setPtr"), method_20779, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_19897, type_19832), Reflex::Literal("fillPtrVector"), method_20780, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo"), method_20781, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isPresent"), method_20782, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo_"), method_20783, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<CorrMETData, std::allocator<CorrMETData> > > -------------------------------
static void constructor_20790( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<CorrMETData> >();
  else ::new(mem) ::edm::Wrapper<std::vector<CorrMETData> >();
}

static void constructor_20791( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<CorrMETData> >(*(::std::auto_ptr<std::vector<CorrMETData> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<CorrMETData> >(*(::std::auto_ptr<std::vector<CorrMETData> >*)arg[0]);
}

static void destructor_20792(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<CorrMETData> >*)o)->::edm::Wrapper<std::vector<CorrMETData> >::~Wrapper)();
}
static  void method_20793( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<CorrMETData> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<CorrMETData> >*)o)->product)();
}

static  void operator_20794( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<CorrMETData> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<CorrMETData> >*)o)->operator->)();
}

static  void method_20795( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<CorrMETData> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<CorrMETData> >*)o)->productTypeInfo)();
}

static  void method_20796( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<CorrMETData> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<CorrMETData> >*)o)->typeInfo)();
}

static void constructor_20797( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<CorrMETData> >((::std::vector<CorrMETData>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<CorrMETData> >((::std::vector<CorrMETData>*)arg[0]);
}

static  void method_20798( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<CorrMETData> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<CorrMETData> >*)o)->getInterface)();
}

static  void method_20799( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<CorrMETData> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_20800( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<CorrMETData> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_20801( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<CorrMETData> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_20802( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<CorrMETData> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<CorrMETData> >*)o)->dynamicTypeInfo)();
}

static  void method_20803( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<CorrMETData> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<CorrMETData> >*)o)->isPresent)();
}

static  void method_20804( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<CorrMETData> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<CorrMETData> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4702( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<CorrMETData> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<CorrMETData> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<CorrMETData> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<CorrMETData> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<CorrMETData> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<CorrMETData, std::allocator<CorrMETData> > > -------------------------------
void __edm__Wrapper_std__vector_CorrMETData_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_CorrMETData_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_CorrMETData_s__datamem_bld(&__edm__Wrapper_std__vector_CorrMETData_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_CorrMETData_s__funcmem_bld(&__edm__Wrapper_std__vector_CorrMETData_s__db_funcmem);
void __edm__Wrapper_std__vector_CorrMETData_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<CorrMETData> >"), typeid(::edm::Wrapper<std::vector<CorrMETData> >), sizeof(::edm::Wrapper<std::vector<CorrMETData> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3143, Reflex::Literal("edm::Wrapper<std::vector<CorrMETData> >::value_type"))
  .AddTypedef(type_3143, Reflex::Literal("edm::Wrapper<std::vector<CorrMETData> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_20790, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2881), Reflex::Literal("Wrapper"), constructor_20791, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_20792, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33914), Reflex::Literal("Wrapper"), constructor_20797, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4702, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_CorrMETData_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_CorrMETData_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<CorrMETData, std::allocator<CorrMETData> > > -------------------
void __edm__Wrapper_std__vector_CorrMETData_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1647, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_CorrMETData_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3143, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_CorrMETData_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<CorrMETData, std::allocator<CorrMETData> > > -------------------
void __edm__Wrapper_std__vector_CorrMETData_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33913), Reflex::Literal("product"), method_20793, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33913), Reflex::Literal("operator->"), operator_20794, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("productTypeInfo"), method_20795, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("typeInfo"), method_20796, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33915), Reflex::Literal("getInterface"), method_20798, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_19738, type_19832, type_33879), Reflex::Literal("fillView"), method_20799, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_364, type_10395), Reflex::Literal("setPtr"), method_20800, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_19897, type_19832), Reflex::Literal("fillPtrVector"), method_20801, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo"), method_20802, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isPresent"), method_20803, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo_"), method_20804, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<CorrMETData> -------------------------------
static void constructor_20811( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<CorrMETData>();
  else ::new(mem) ::edm::Wrapper<CorrMETData>();
}

static void constructor_20812( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<CorrMETData>(*(::std::auto_ptr<CorrMETData>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<CorrMETData>(*(::std::auto_ptr<CorrMETData>*)arg[0]);
}

static void destructor_20813(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<CorrMETData>*)o)->::edm::Wrapper<CorrMETData>::~Wrapper)();
}
static  void method_20814( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<CorrMETData>*)o)->product)());
  else   (((const ::edm::Wrapper<CorrMETData>*)o)->product)();
}

static  void operator_20815( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<CorrMETData>*)o)->operator->)());
  else   (((const ::edm::Wrapper<CorrMETData>*)o)->operator->)();
}

static  void method_20816( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<CorrMETData>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<CorrMETData>*)o)->productTypeInfo)();
}

static  void method_20817( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<CorrMETData>*)o)->typeInfo)();
  else   (((::edm::Wrapper<CorrMETData>*)o)->typeInfo)();
}

static void constructor_20818( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<CorrMETData>((::CorrMETData*)arg[0]);
  else ::new(mem) ::edm::Wrapper<CorrMETData>((::CorrMETData*)arg[0]);
}

static  void method_20819( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<CorrMETData>*)o)->getInterface)());
  else   (((::edm::Wrapper<CorrMETData>*)o)->getInterface)();
}

static  void method_20820( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<CorrMETData>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_20821( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<CorrMETData>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_20822( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<CorrMETData>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_20823( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<CorrMETData>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<CorrMETData>*)o)->dynamicTypeInfo)();
}

static  void method_20824( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<CorrMETData>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<CorrMETData>*)o)->isPresent)();
}

static  void method_20825( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<CorrMETData>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<CorrMETData>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4703( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<CorrMETData> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<CorrMETData> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<CorrMETData> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<CorrMETData> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<CorrMETData> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<CorrMETData> -------------------------------
void __edm__Wrapper_CorrMETData__db_datamem(Reflex::Class*);
void __edm__Wrapper_CorrMETData__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_CorrMETData__datamem_bld(&__edm__Wrapper_CorrMETData__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_CorrMETData__funcmem_bld(&__edm__Wrapper_CorrMETData__db_funcmem);
void __edm__Wrapper_CorrMETData__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<CorrMETData>"), typeid(::edm::Wrapper<CorrMETData>), sizeof(::edm::Wrapper<CorrMETData>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1653, Reflex::Literal("edm::Wrapper<CorrMETData>::value_type"))
  .AddTypedef(type_1653, Reflex::Literal("edm::Wrapper<CorrMETData>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_20811, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2882), Reflex::Literal("Wrapper"), constructor_20812, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_20813, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13434), Reflex::Literal("Wrapper"), constructor_20818, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4703, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_CorrMETData__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_CorrMETData__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<CorrMETData> -------------------
void __edm__Wrapper_CorrMETData__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1647, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_CorrMETData_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1653, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_CorrMETData_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<CorrMETData> -------------------
void __edm__Wrapper_CorrMETData__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13436), Reflex::Literal("product"), method_20814, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13436), Reflex::Literal("operator->"), operator_20815, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("productTypeInfo"), method_20816, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("typeInfo"), method_20817, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33918), Reflex::Literal("getInterface"), method_20819, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_19738, type_19832, type_33879), Reflex::Literal("fillView"), method_20820, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_364, type_10395), Reflex::Literal("setPtr"), method_20821, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_19897, type_19832), Reflex::Literal("fillPtrVector"), method_20822, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo"), method_20823, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isPresent"), method_20824, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo_"), method_20825, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<CommonMETData, std::allocator<CommonMETData> > > -------------------------------
static void constructor_20832( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<CommonMETData> >();
  else ::new(mem) ::edm::Wrapper<std::vector<CommonMETData> >();
}

static void constructor_20833( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<CommonMETData> >(*(::std::auto_ptr<std::vector<CommonMETData> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<CommonMETData> >(*(::std::auto_ptr<std::vector<CommonMETData> >*)arg[0]);
}

static void destructor_20834(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<CommonMETData> >*)o)->::edm::Wrapper<std::vector<CommonMETData> >::~Wrapper)();
}
static  void method_20835( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<CommonMETData> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<CommonMETData> >*)o)->product)();
}

static  void operator_20836( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<CommonMETData> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<CommonMETData> >*)o)->operator->)();
}

static  void method_20837( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<CommonMETData> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<CommonMETData> >*)o)->productTypeInfo)();
}

static  void method_20838( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<CommonMETData> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<CommonMETData> >*)o)->typeInfo)();
}

static void constructor_20839( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<CommonMETData> >((::std::vector<CommonMETData>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<CommonMETData> >((::std::vector<CommonMETData>*)arg[0]);
}

static  void method_20840( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<CommonMETData> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<CommonMETData> >*)o)->getInterface)();
}

static  void method_20841( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<CommonMETData> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_20842( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<CommonMETData> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_20843( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<CommonMETData> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_20844( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<CommonMETData> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<CommonMETData> >*)o)->dynamicTypeInfo)();
}

static  void method_20845( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<CommonMETData> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<CommonMETData> >*)o)->isPresent)();
}

static  void method_20846( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<CommonMETData> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<CommonMETData> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4704( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<CommonMETData> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<CommonMETData> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<CommonMETData> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<CommonMETData> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<CommonMETData> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<CommonMETData, std::allocator<CommonMETData> > > -------------------------------
void __edm__Wrapper_std__vector_CommonMETData_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_CommonMETData_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_CommonMETData_s__datamem_bld(&__edm__Wrapper_std__vector_CommonMETData_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_CommonMETData_s__funcmem_bld(&__edm__Wrapper_std__vector_CommonMETData_s__db_funcmem);
void __edm__Wrapper_std__vector_CommonMETData_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<CommonMETData> >"), typeid(::edm::Wrapper<std::vector<CommonMETData> >), sizeof(::edm::Wrapper<std::vector<CommonMETData> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3144, Reflex::Literal("edm::Wrapper<std::vector<CommonMETData> >::value_type"))
  .AddTypedef(type_3144, Reflex::Literal("edm::Wrapper<std::vector<CommonMETData> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_20832, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2883), Reflex::Literal("Wrapper"), constructor_20833, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_20834, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33922), Reflex::Literal("Wrapper"), constructor_20839, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4704, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_CommonMETData_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_CommonMETData_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<CommonMETData, std::allocator<CommonMETData> > > -------------------
void __edm__Wrapper_std__vector_CommonMETData_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1647, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_CommonMETData_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3144, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_CommonMETData_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<CommonMETData, std::allocator<CommonMETData> > > -------------------
void __edm__Wrapper_std__vector_CommonMETData_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33921), Reflex::Literal("product"), method_20835, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33921), Reflex::Literal("operator->"), operator_20836, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("productTypeInfo"), method_20837, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("typeInfo"), method_20838, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33923), Reflex::Literal("getInterface"), method_20840, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_19738, type_19832, type_33879), Reflex::Literal("fillView"), method_20841, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_364, type_10395), Reflex::Literal("setPtr"), method_20842, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_19897, type_19832), Reflex::Literal("fillPtrVector"), method_20843, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo"), method_20844, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isPresent"), method_20845, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo_"), method_20846, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<CommonMETData> -------------------------------
static void constructor_20853( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<CommonMETData>();
  else ::new(mem) ::edm::Wrapper<CommonMETData>();
}

static void constructor_20854( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<CommonMETData>(*(::std::auto_ptr<CommonMETData>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<CommonMETData>(*(::std::auto_ptr<CommonMETData>*)arg[0]);
}

static void destructor_20855(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<CommonMETData>*)o)->::edm::Wrapper<CommonMETData>::~Wrapper)();
}
static  void method_20856( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<CommonMETData>*)o)->product)());
  else   (((const ::edm::Wrapper<CommonMETData>*)o)->product)();
}

static  void operator_20857( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<CommonMETData>*)o)->operator->)());
  else   (((const ::edm::Wrapper<CommonMETData>*)o)->operator->)();
}

static  void method_20858( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<CommonMETData>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<CommonMETData>*)o)->productTypeInfo)();
}

static  void method_20859( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<CommonMETData>*)o)->typeInfo)();
  else   (((::edm::Wrapper<CommonMETData>*)o)->typeInfo)();
}

static void constructor_20860( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<CommonMETData>((::CommonMETData*)arg[0]);
  else ::new(mem) ::edm::Wrapper<CommonMETData>((::CommonMETData*)arg[0]);
}

static  void method_20861( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<CommonMETData>*)o)->getInterface)());
  else   (((::edm::Wrapper<CommonMETData>*)o)->getInterface)();
}

static  void method_20862( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<CommonMETData>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_20863( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<CommonMETData>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_20864( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<CommonMETData>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_20865( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<CommonMETData>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<CommonMETData>*)o)->dynamicTypeInfo)();
}

static  void method_20866( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<CommonMETData>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<CommonMETData>*)o)->isPresent)();
}

static  void method_20867( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<CommonMETData>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<CommonMETData>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4705( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<CommonMETData> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<CommonMETData> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<CommonMETData> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<CommonMETData> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<CommonMETData> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<CommonMETData> -------------------------------
void __edm__Wrapper_CommonMETData__db_datamem(Reflex::Class*);
void __edm__Wrapper_CommonMETData__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_CommonMETData__datamem_bld(&__edm__Wrapper_CommonMETData__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_CommonMETData__funcmem_bld(&__edm__Wrapper_CommonMETData__db_funcmem);
void __edm__Wrapper_CommonMETData__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<CommonMETData>"), typeid(::edm::Wrapper<CommonMETData>), sizeof(::edm::Wrapper<CommonMETData>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2300, Reflex::Literal("edm::Wrapper<CommonMETData>::value_type"))
  .AddTypedef(type_2300, Reflex::Literal("edm::Wrapper<CommonMETData>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_20853, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2884), Reflex::Literal("Wrapper"), constructor_20854, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_20855, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13499), Reflex::Literal("Wrapper"), constructor_20860, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4705, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_CommonMETData__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_CommonMETData__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<CommonMETData> -------------------
void __edm__Wrapper_CommonMETData__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1647, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_CommonMETData_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2300, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_CommonMETData_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<CommonMETData> -------------------
void __edm__Wrapper_CommonMETData__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13501), Reflex::Literal("product"), method_20856, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13501), Reflex::Literal("operator->"), operator_20857, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("productTypeInfo"), method_20858, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("typeInfo"), method_20859, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33926), Reflex::Literal("getInterface"), method_20861, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_19738, type_19832, type_33879), Reflex::Literal("fillView"), method_20862, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_364, type_10395), Reflex::Literal("setPtr"), method_20863, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_19897, type_19832), Reflex::Literal("fillPtrVector"), method_20864, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo"), method_20865, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isPresent"), method_20866, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo_"), method_20867, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<Point3DBase<float, GlobalTag>, std::allocator<Point3DBase<float, GlobalTag> > > > -------------------------------
static void constructor_20874( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<Point3DBase<float,GlobalTag> > >();
  else ::new(mem) ::edm::Wrapper<std::vector<Point3DBase<float,GlobalTag> > >();
}

static void constructor_20875( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<Point3DBase<float,GlobalTag> > >(*(::std::auto_ptr<std::vector<Point3DBase<float,GlobalTag> > >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<Point3DBase<float,GlobalTag> > >(*(::std::auto_ptr<std::vector<Point3DBase<float,GlobalTag> > >*)arg[0]);
}

static void destructor_20876(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<Point3DBase<float,GlobalTag> > >*)o)->::edm::Wrapper<std::vector<Point3DBase<float,GlobalTag> > >::~Wrapper)();
}
static  void method_20877( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<Point3DBase<float,GlobalTag> > >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<Point3DBase<float,GlobalTag> > >*)o)->product)();
}

static  void operator_20878( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<Point3DBase<float,GlobalTag> > >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<Point3DBase<float,GlobalTag> > >*)o)->operator->)();
}

static  void method_20879( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<Point3DBase<float,GlobalTag> > >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<Point3DBase<float,GlobalTag> > >*)o)->productTypeInfo)();
}

static  void method_20880( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<Point3DBase<float,GlobalTag> > >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<Point3DBase<float,GlobalTag> > >*)o)->typeInfo)();
}

static void constructor_20881( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<Point3DBase<float,GlobalTag> > >((::std::vector<Point3DBase<float,GlobalTag> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<Point3DBase<float,GlobalTag> > >((::std::vector<Point3DBase<float,GlobalTag> >*)arg[0]);
}

static  void method_20882( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<Point3DBase<float,GlobalTag> > >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<Point3DBase<float,GlobalTag> > >*)o)->getInterface)();
}

static  void method_20883( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<Point3DBase<float,GlobalTag> > >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_20884( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<Point3DBase<float,GlobalTag> > >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_20885( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<Point3DBase<float,GlobalTag> > >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_20886( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<Point3DBase<float,GlobalTag> > >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<Point3DBase<float,GlobalTag> > >*)o)->dynamicTypeInfo)();
}

static  void method_20887( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<Point3DBase<float,GlobalTag> > >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<Point3DBase<float,GlobalTag> > >*)o)->isPresent)();
}

static  void method_20888( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<Point3DBase<float,GlobalTag> > >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<Point3DBase<float,GlobalTag> > >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4706( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<Point3DBase<float,GlobalTag> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<Point3DBase<float,GlobalTag> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<Point3DBase<float,GlobalTag> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<Point3DBase<float,GlobalTag> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<Point3DBase<float,GlobalTag> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<Point3DBase<float, GlobalTag>, std::allocator<Point3DBase<float, GlobalTag> > > > -------------------------------
void __edm__Wrapper_std__vector_Point3DBase_float_GlobalTag_s_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_Point3DBase_float_GlobalTag_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_Point3DBase_float_GlobalTag_s_s__datamem_bld(&__edm__Wrapper_std__vector_Point3DBase_float_GlobalTag_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_Point3DBase_float_GlobalTag_s_s__funcmem_bld(&__edm__Wrapper_std__vector_Point3DBase_float_GlobalTag_s_s__db_funcmem);
void __edm__Wrapper_std__vector_Point3DBase_float_GlobalTag_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<Point3DBase<float,GlobalTag> > >"), typeid(::edm::Wrapper<std::vector<Point3DBase<float,GlobalTag> > >), sizeof(::edm::Wrapper<std::vector<Point3DBase<float,GlobalTag> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3149, Reflex::Literal("edm::Wrapper<std::vector<Point3DBase<float,GlobalTag> > >::value_type"))
  .AddTypedef(type_3149, Reflex::Literal("edm::Wrapper<std::vector<Point3DBase<float,GlobalTag> > >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_20874, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2885), Reflex::Literal("Wrapper"), constructor_20875, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_20876, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33930), Reflex::Literal("Wrapper"), constructor_20881, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4706, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_Point3DBase_float_GlobalTag_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_Point3DBase_float_GlobalTag_s_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<Point3DBase<float, GlobalTag>, std::allocator<Point3DBase<float, GlobalTag> > > > -------------------
void __edm__Wrapper_std__vector_Point3DBase_float_GlobalTag_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1647, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_Point3DBase_float_GlobalTag_s_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3149, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_Point3DBase_float_GlobalTag_s_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<Point3DBase<float, GlobalTag>, std::allocator<Point3DBase<float, GlobalTag> > > > -------------------
void __edm__Wrapper_std__vector_Point3DBase_float_GlobalTag_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33929), Reflex::Literal("product"), method_20877, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33929), Reflex::Literal("operator->"), operator_20878, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("productTypeInfo"), method_20879, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("typeInfo"), method_20880, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33931), Reflex::Literal("getInterface"), method_20882, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_19738, type_19832, type_33879), Reflex::Literal("fillView"), method_20883, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_364, type_10395), Reflex::Literal("setPtr"), method_20884, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_19897, type_19832), Reflex::Literal("fillPtrVector"), method_20885, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo"), method_20886, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isPresent"), method_20887, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo_"), method_20888, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class BeamHaloSummary -------------------------------
static  void operator_27541( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::BeamHaloSummary*)o)->operator=)(*(const ::reco::BeamHaloSummary*)arg[0]);
  else   (((::reco::BeamHaloSummary*)o)->operator=)(*(const ::reco::BeamHaloSummary*)arg[0]);
}

static void constructor_27542( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::BeamHaloSummary(*(const ::reco::BeamHaloSummary*)arg[0]);
  else ::new(mem) ::reco::BeamHaloSummary(*(const ::reco::BeamHaloSummary*)arg[0]);
}

static void constructor_27543( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::BeamHaloSummary();
  else ::new(mem) ::reco::BeamHaloSummary();
}

static void constructor_27544( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::BeamHaloSummary(*(::reco::CSCHaloData*)arg[0],
      *(::reco::EcalHaloData*)arg[1],
      *(::reco::HcalHaloData*)arg[2],
      *(::reco::GlobalHaloData*)arg[3]);
  else ::new(mem) ::reco::BeamHaloSummary(*(::reco::CSCHaloData*)arg[0],
      *(::reco::EcalHaloData*)arg[1],
      *(::reco::HcalHaloData*)arg[2],
      *(::reco::GlobalHaloData*)arg[3]);
}

static void destructor_27545(void*, void * o, const std::vector<void*>&, void *) {
(((::reco::BeamHaloSummary*)o)->::reco::BeamHaloSummary::~BeamHaloSummary)();
}
static  void method_27546( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::reco::BeamHaloSummary*)o)->HcalLooseHaloId)());
  else   (((const ::reco::BeamHaloSummary*)o)->HcalLooseHaloId)();
}

static  void method_27547( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::reco::BeamHaloSummary*)o)->HcalTightHaloId)());
  else   (((const ::reco::BeamHaloSummary*)o)->HcalTightHaloId)();
}

static  void method_27548( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::reco::BeamHaloSummary*)o)->EcalLooseHaloId)());
  else   (((const ::reco::BeamHaloSummary*)o)->EcalLooseHaloId)();
}

static  void method_27549( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::reco::BeamHaloSummary*)o)->EcalTightHaloId)());
  else   (((const ::reco::BeamHaloSummary*)o)->EcalTightHaloId)();
}

static  void method_27550( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::reco::BeamHaloSummary*)o)->CSCLooseHaloId)());
  else   (((const ::reco::BeamHaloSummary*)o)->CSCLooseHaloId)();
}

static  void method_27551( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::reco::BeamHaloSummary*)o)->CSCTightHaloId)());
  else   (((const ::reco::BeamHaloSummary*)o)->CSCTightHaloId)();
}

static  void method_27552( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::reco::BeamHaloSummary*)o)->GlobalLooseHaloId)());
  else   (((const ::reco::BeamHaloSummary*)o)->GlobalLooseHaloId)();
}

static  void method_27553( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::reco::BeamHaloSummary*)o)->GlobalTightHaloId)());
  else   (((const ::reco::BeamHaloSummary*)o)->GlobalTightHaloId)();
}

static  void method_27554( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::reco::BeamHaloSummary*)o)->EventSmellsLikeHalo)());
  else   (((const ::reco::BeamHaloSummary*)o)->EventSmellsLikeHalo)();
}

static  void method_27555( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::reco::BeamHaloSummary*)o)->LooseId)());
  else   (((const ::reco::BeamHaloSummary*)o)->LooseId)();
}

static  void method_27556( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::reco::BeamHaloSummary*)o)->TightId)());
  else   (((const ::reco::BeamHaloSummary*)o)->TightId)();
}

static  void method_27557( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::reco::BeamHaloSummary*)o)->ExtremeTightId)());
  else   (((const ::reco::BeamHaloSummary*)o)->ExtremeTightId)();
}

static  void method_27558( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::BeamHaloSummary*)o)->GetHcalHaloReport)();
  else   (((::reco::BeamHaloSummary*)o)->GetHcalHaloReport)();
}

static  void method_27559( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::reco::BeamHaloSummary*)o)->GetHcalHaloReport)();
  else   (((const ::reco::BeamHaloSummary*)o)->GetHcalHaloReport)();
}

static  void method_27560( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::BeamHaloSummary*)o)->GetEcalHaloReport)();
  else   (((::reco::BeamHaloSummary*)o)->GetEcalHaloReport)();
}

static  void method_27561( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::reco::BeamHaloSummary*)o)->GetEcalHaloReport)();
  else   (((const ::reco::BeamHaloSummary*)o)->GetEcalHaloReport)();
}

static  void method_27562( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::BeamHaloSummary*)o)->GetCSCHaloReport)();
  else   (((::reco::BeamHaloSummary*)o)->GetCSCHaloReport)();
}

static  void method_27563( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::reco::BeamHaloSummary*)o)->GetCSCHaloReport)();
  else   (((const ::reco::BeamHaloSummary*)o)->GetCSCHaloReport)();
}

static  void method_27564( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::BeamHaloSummary*)o)->GetGlobalHaloReport)();
  else   (((::reco::BeamHaloSummary*)o)->GetGlobalHaloReport)();
}

static  void method_27565( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::reco::BeamHaloSummary*)o)->GetGlobalHaloReport)();
  else   (((const ::reco::BeamHaloSummary*)o)->GetGlobalHaloReport)();
}

static  void method_27566( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::BeamHaloSummary*)o)->GetHcaliPhiSuspects)();
  else   (((::reco::BeamHaloSummary*)o)->GetHcaliPhiSuspects)();
}

static  void method_27567( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::reco::BeamHaloSummary*)o)->GetHcaliPhiSuspects)();
  else   (((const ::reco::BeamHaloSummary*)o)->GetHcaliPhiSuspects)();
}

static  void method_27568( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::BeamHaloSummary*)o)->GetEcaliPhiSuspects)();
  else   (((::reco::BeamHaloSummary*)o)->GetEcaliPhiSuspects)();
}

static  void method_27569( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::reco::BeamHaloSummary*)o)->GetEcaliPhiSuspects)();
  else   (((const ::reco::BeamHaloSummary*)o)->GetEcaliPhiSuspects)();
}

static  void method_27570( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::BeamHaloSummary*)o)->GetGlobaliPhiSuspects)();
  else   (((::reco::BeamHaloSummary*)o)->GetGlobaliPhiSuspects)();
}

static  void method_27571( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::reco::BeamHaloSummary*)o)->GetGlobaliPhiSuspects)();
  else   (((const ::reco::BeamHaloSummary*)o)->GetGlobaliPhiSuspects)();
}

static void method_newdel_7946( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::reco::BeamHaloSummary >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::reco::BeamHaloSummary >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::reco::BeamHaloSummary >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::reco::BeamHaloSummary >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::reco::BeamHaloSummary >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class BeamHaloSummary -------------------------------
void __reco__BeamHaloSummary_db_datamem(Reflex::Class*);
void __reco__BeamHaloSummary_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __reco__BeamHaloSummary_datamem_bld(&__reco__BeamHaloSummary_db_datamem);
Reflex::GenreflexMemberBuilder __reco__BeamHaloSummary_funcmem_bld(&__reco__BeamHaloSummary_db_funcmem);
void __reco__BeamHaloSummary_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("reco::BeamHaloSummary"), typeid(::reco::BeamHaloSummary), sizeof(::reco::BeamHaloSummary), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39360, type_39361), Reflex::Literal("operator="), operator_27541, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39361), Reflex::Literal("BeamHaloSummary"), constructor_27542, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("BeamHaloSummary"), constructor_27543, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39362, type_39324, type_39322, type_39345), Reflex::Literal("BeamHaloSummary"), constructor_27544, 0, "csc;ecal;hcal;global", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~BeamHaloSummary"), destructor_27545, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7946, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__reco__BeamHaloSummary_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__reco__BeamHaloSummary_funcmem_bld);
}

//------Delayed data member builder for class BeamHaloSummary -------------------
void __reco__BeamHaloSummary_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3163, Reflex::Literal("HcalHaloReport"), OffsetOf(__shadow__::__reco__BeamHaloSummary, HcalHaloReport), ::Reflex::PRIVATE)
  .AddDataMember(type_3163, Reflex::Literal("EcalHaloReport"), OffsetOf(__shadow__::__reco__BeamHaloSummary, EcalHaloReport), ::Reflex::PRIVATE)
  .AddDataMember(type_3163, Reflex::Literal("CSCHaloReport"), OffsetOf(__shadow__::__reco__BeamHaloSummary, CSCHaloReport), ::Reflex::PRIVATE)
  .AddDataMember(type_3163, Reflex::Literal("GlobalHaloReport"), OffsetOf(__shadow__::__reco__BeamHaloSummary, GlobalHaloReport), ::Reflex::PRIVATE)
  .AddDataMember(type_3159, Reflex::Literal("HcaliPhiSuspects"), OffsetOf(__shadow__::__reco__BeamHaloSummary, HcaliPhiSuspects), ::Reflex::PRIVATE)
  .AddDataMember(type_3159, Reflex::Literal("EcaliPhiSuspects"), OffsetOf(__shadow__::__reco__BeamHaloSummary, EcaliPhiSuspects), ::Reflex::PRIVATE)
  .AddDataMember(type_3159, Reflex::Literal("GlobaliPhiSuspects"), OffsetOf(__shadow__::__reco__BeamHaloSummary, GlobaliPhiSuspects), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class BeamHaloSummary -------------------
void __reco__BeamHaloSummary_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647c), Reflex::Literal("HcalLooseHaloId"), method_27546, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647c), Reflex::Literal("HcalTightHaloId"), method_27547, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647c), Reflex::Literal("EcalLooseHaloId"), method_27548, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647c), Reflex::Literal("EcalTightHaloId"), method_27549, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647c), Reflex::Literal("CSCLooseHaloId"), method_27550, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647c), Reflex::Literal("CSCTightHaloId"), method_27551, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647c), Reflex::Literal("GlobalLooseHaloId"), method_27552, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647c), Reflex::Literal("GlobalTightHaloId"), method_27553, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647c), Reflex::Literal("EventSmellsLikeHalo"), method_27554, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647c), Reflex::Literal("LooseId"), method_27555, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647c), Reflex::Literal("TightId"), method_27556, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647c), Reflex::Literal("ExtremeTightId"), method_27557, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32849), Reflex::Literal("GetHcalHaloReport"), method_27558, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32848), Reflex::Literal("GetHcalHaloReport"), method_27559, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32849), Reflex::Literal("GetEcalHaloReport"), method_27560, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32848), Reflex::Literal("GetEcalHaloReport"), method_27561, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32849), Reflex::Literal("GetCSCHaloReport"), method_27562, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32848), Reflex::Literal("GetCSCHaloReport"), method_27563, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32849), Reflex::Literal("GetGlobalHaloReport"), method_27564, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32848), Reflex::Literal("GetGlobalHaloReport"), method_27565, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32845), Reflex::Literal("GetHcaliPhiSuspects"), method_27566, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32844), Reflex::Literal("GetHcaliPhiSuspects"), method_27567, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32845), Reflex::Literal("GetEcaliPhiSuspects"), method_27568, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32844), Reflex::Literal("GetEcaliPhiSuspects"), method_27569, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32845), Reflex::Literal("GetGlobaliPhiSuspects"), method_27570, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32844), Reflex::Literal("GetGlobaliPhiSuspects"), method_27571, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<reco::BeamHaloSummary> -------------------------------
static void constructor_20895( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::BeamHaloSummary>();
  else ::new(mem) ::edm::Wrapper<reco::BeamHaloSummary>();
}

static void constructor_20896( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::BeamHaloSummary>(*(::std::auto_ptr<reco::BeamHaloSummary>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<reco::BeamHaloSummary>(*(::std::auto_ptr<reco::BeamHaloSummary>*)arg[0]);
}

static void destructor_20897(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<reco::BeamHaloSummary>*)o)->::edm::Wrapper<reco::BeamHaloSummary>::~Wrapper)();
}
static  void method_20898( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<reco::BeamHaloSummary>*)o)->product)());
  else   (((const ::edm::Wrapper<reco::BeamHaloSummary>*)o)->product)();
}

static  void operator_20899( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<reco::BeamHaloSummary>*)o)->operator->)());
  else   (((const ::edm::Wrapper<reco::BeamHaloSummary>*)o)->operator->)();
}

static  void method_20900( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<reco::BeamHaloSummary>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<reco::BeamHaloSummary>*)o)->productTypeInfo)();
}

static  void method_20901( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<reco::BeamHaloSummary>*)o)->typeInfo)();
  else   (((::edm::Wrapper<reco::BeamHaloSummary>*)o)->typeInfo)();
}

static void constructor_20902( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::BeamHaloSummary>((::reco::BeamHaloSummary*)arg[0]);
  else ::new(mem) ::edm::Wrapper<reco::BeamHaloSummary>((::reco::BeamHaloSummary*)arg[0]);
}

static  void method_20903( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<reco::BeamHaloSummary>*)o)->getInterface)());
  else   (((::edm::Wrapper<reco::BeamHaloSummary>*)o)->getInterface)();
}

static  void method_20904( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::BeamHaloSummary>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_20905( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::BeamHaloSummary>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_20906( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::BeamHaloSummary>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_20907( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<reco::BeamHaloSummary>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<reco::BeamHaloSummary>*)o)->dynamicTypeInfo)();
}

static  void method_20908( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<reco::BeamHaloSummary>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<reco::BeamHaloSummary>*)o)->isPresent)();
}

static  void method_20909( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<reco::BeamHaloSummary>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<reco::BeamHaloSummary>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4707( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::BeamHaloSummary> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::BeamHaloSummary> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::BeamHaloSummary> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::BeamHaloSummary> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::BeamHaloSummary> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<reco::BeamHaloSummary> -------------------------------
void __edm__Wrapper_reco__BeamHaloSummary__db_datamem(Reflex::Class*);
void __edm__Wrapper_reco__BeamHaloSummary__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_reco__BeamHaloSummary__datamem_bld(&__edm__Wrapper_reco__BeamHaloSummary__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_reco__BeamHaloSummary__funcmem_bld(&__edm__Wrapper_reco__BeamHaloSummary__db_funcmem);
void __edm__Wrapper_reco__BeamHaloSummary__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<reco::BeamHaloSummary>"), typeid(::edm::Wrapper<reco::BeamHaloSummary>), sizeof(::edm::Wrapper<reco::BeamHaloSummary>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_7946, Reflex::Literal("edm::Wrapper<reco::BeamHaloSummary>::value_type"))
  .AddTypedef(type_7946, Reflex::Literal("edm::Wrapper<reco::BeamHaloSummary>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_20895, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2886), Reflex::Literal("Wrapper"), constructor_20896, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_20897, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33935), Reflex::Literal("Wrapper"), constructor_20902, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4707, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_reco__BeamHaloSummary__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_reco__BeamHaloSummary__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<reco::BeamHaloSummary> -------------------
void __edm__Wrapper_reco__BeamHaloSummary__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1647, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_reco__BeamHaloSummary_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_7946, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_reco__BeamHaloSummary_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<reco::BeamHaloSummary> -------------------
void __edm__Wrapper_reco__BeamHaloSummary__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33934), Reflex::Literal("product"), method_20898, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33934), Reflex::Literal("operator->"), operator_20899, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("productTypeInfo"), method_20900, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("typeInfo"), method_20901, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33936), Reflex::Literal("getInterface"), method_20903, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_19738, type_19832, type_33879), Reflex::Literal("fillView"), method_20904, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_364, type_10395), Reflex::Literal("setPtr"), method_20905, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_19897, type_19832), Reflex::Literal("fillPtrVector"), method_20906, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo"), method_20907, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isPresent"), method_20908, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo_"), method_20909, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class GlobalHaloData -------------------------------
static  void operator_27401( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::GlobalHaloData*)o)->operator=)(*(const ::reco::GlobalHaloData*)arg[0]);
  else   (((::reco::GlobalHaloData*)o)->operator=)(*(const ::reco::GlobalHaloData*)arg[0]);
}

static void constructor_27402( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::GlobalHaloData(*(const ::reco::GlobalHaloData*)arg[0]);
  else ::new(mem) ::reco::GlobalHaloData(*(const ::reco::GlobalHaloData*)arg[0]);
}

static void constructor_27403( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::GlobalHaloData();
  else ::new(mem) ::reco::GlobalHaloData();
}

static void destructor_27404(void*, void * o, const std::vector<void*>&, void *) {
(((::reco::GlobalHaloData*)o)->::reco::GlobalHaloData::~GlobalHaloData)();
}
static  void method_27405( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::GlobalHaloData*)o)->METOverSumEt)());
  else   (((const ::reco::GlobalHaloData*)o)->METOverSumEt)();
}

static  void method_27406( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::GlobalHaloData*)o)->DeltaMEx)());
  else   (((const ::reco::GlobalHaloData*)o)->DeltaMEx)();
}

static  void method_27407( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::GlobalHaloData*)o)->DeltaMEy)());
  else   (((const ::reco::GlobalHaloData*)o)->DeltaMEy)();
}

static  void method_27408( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::GlobalHaloData*)o)->DeltaSumEt)());
  else   (((const ::reco::GlobalHaloData*)o)->DeltaSumEt)();
}

static  void method_27409( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (reco::CaloMET)((((const ::reco::GlobalHaloData*)o)->GetCorrectedCaloMET)(*(const ::reco::CaloMET*)arg[0]));
  else   (((const ::reco::GlobalHaloData*)o)->GetCorrectedCaloMET)(*(const ::reco::CaloMET*)arg[0]);
}

static  void method_27410( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::GlobalHaloData*)o)->GetMatchedHcalPhiWedges)();
  else   (((::reco::GlobalHaloData*)o)->GetMatchedHcalPhiWedges)();
}

static  void method_27411( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::reco::GlobalHaloData*)o)->GetMatchedHcalPhiWedges)();
  else   (((const ::reco::GlobalHaloData*)o)->GetMatchedHcalPhiWedges)();
}

static  void method_27412( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::GlobalHaloData*)o)->GetMatchedEcalPhiWedges)();
  else   (((::reco::GlobalHaloData*)o)->GetMatchedEcalPhiWedges)();
}

static  void method_27413( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::reco::GlobalHaloData*)o)->GetMatchedEcalPhiWedges)();
  else   (((const ::reco::GlobalHaloData*)o)->GetMatchedEcalPhiWedges)();
}

static  void method_27414( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::GlobalHaloData*)o)->SetMETOverSumEt)(*(float*)arg[0]);
}

static  void method_27415( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::GlobalHaloData*)o)->SetMETCorrections)(*(float*)arg[0],
    *(float*)arg[1]);
}

static void method_newdel_7935( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::reco::GlobalHaloData >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::reco::GlobalHaloData >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::reco::GlobalHaloData >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::reco::GlobalHaloData >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::reco::GlobalHaloData >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class GlobalHaloData -------------------------------
void __reco__GlobalHaloData_db_datamem(Reflex::Class*);
void __reco__GlobalHaloData_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __reco__GlobalHaloData_datamem_bld(&__reco__GlobalHaloData_db_datamem);
Reflex::GenreflexMemberBuilder __reco__GlobalHaloData_funcmem_bld(&__reco__GlobalHaloData_db_funcmem);
void __reco__GlobalHaloData_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("reco::GlobalHaloData"), typeid(::reco::GlobalHaloData), sizeof(::reco::GlobalHaloData), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39345, type_39346), Reflex::Literal("operator="), operator_27401, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39346), Reflex::Literal("GlobalHaloData"), constructor_27402, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("GlobalHaloData"), constructor_27403, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~GlobalHaloData"), destructor_27404, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7935, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__reco__GlobalHaloData_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__reco__GlobalHaloData_funcmem_bld);
}

//------Delayed data member builder for class GlobalHaloData -------------------
void __reco__GlobalHaloData_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_932, Reflex::Literal("METOverSumEt_"), OffsetOf(__shadow__::__reco__GlobalHaloData, METOverSumEt_), ::Reflex::PRIVATE)
  .AddDataMember(type_932, Reflex::Literal("dMEx_"), OffsetOf(__shadow__::__reco__GlobalHaloData, dMEx_), ::Reflex::PRIVATE)
  .AddDataMember(type_932, Reflex::Literal("dMEy_"), OffsetOf(__shadow__::__reco__GlobalHaloData, dMEy_), ::Reflex::PRIVATE)
  .AddDataMember(type_932, Reflex::Literal("dSumEt_"), OffsetOf(__shadow__::__reco__GlobalHaloData, dSumEt_), ::Reflex::PRIVATE)
  .AddDataMember(type_3150, Reflex::Literal("HcalPhiWedges"), OffsetOf(__shadow__::__reco__GlobalHaloData, HcalPhiWedges), ::Reflex::PRIVATE)
  .AddDataMember(type_3150, Reflex::Literal("EcalPhiWedges"), OffsetOf(__shadow__::__reco__GlobalHaloData, EcalPhiWedges), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class GlobalHaloData -------------------
void __reco__GlobalHaloData_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("METOverSumEt"), method_27405, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("DeltaMEx"), method_27406, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("DeltaMEy"), method_27407, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("DeltaSumEt"), method_27408, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8011, type_13765), Reflex::Literal("GetCorrectedCaloMET"), method_27409, 0, "RawMET", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32824), Reflex::Literal("GetMatchedHcalPhiWedges"), method_27410, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32823), Reflex::Literal("GetMatchedHcalPhiWedges"), method_27411, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32824), Reflex::Literal("GetMatchedEcalPhiWedges"), method_27412, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32823), Reflex::Literal("GetMatchedEcalPhiWedges"), method_27413, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_932), Reflex::Literal("SetMETOverSumEt"), method_27414, 0, "x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_932, type_932), Reflex::Literal("SetMETCorrections"), method_27415, 0, "x;y", ::Reflex::PUBLIC);
}
//------Stub functions for class Wrapper<reco::GlobalHaloData> -------------------------------
static void constructor_20916( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::GlobalHaloData>();
  else ::new(mem) ::edm::Wrapper<reco::GlobalHaloData>();
}

static void constructor_20917( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::GlobalHaloData>(*(::std::auto_ptr<reco::GlobalHaloData>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<reco::GlobalHaloData>(*(::std::auto_ptr<reco::GlobalHaloData>*)arg[0]);
}

static void destructor_20918(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<reco::GlobalHaloData>*)o)->::edm::Wrapper<reco::GlobalHaloData>::~Wrapper)();
}
static  void method_20919( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<reco::GlobalHaloData>*)o)->product)());
  else   (((const ::edm::Wrapper<reco::GlobalHaloData>*)o)->product)();
}

static  void operator_20920( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<reco::GlobalHaloData>*)o)->operator->)());
  else   (((const ::edm::Wrapper<reco::GlobalHaloData>*)o)->operator->)();
}

static  void method_20921( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<reco::GlobalHaloData>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<reco::GlobalHaloData>*)o)->productTypeInfo)();
}

static  void method_20922( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<reco::GlobalHaloData>*)o)->typeInfo)();
  else   (((::edm::Wrapper<reco::GlobalHaloData>*)o)->typeInfo)();
}

static void constructor_20923( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::GlobalHaloData>((::reco::GlobalHaloData*)arg[0]);
  else ::new(mem) ::edm::Wrapper<reco::GlobalHaloData>((::reco::GlobalHaloData*)arg[0]);
}

static  void method_20924( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<reco::GlobalHaloData>*)o)->getInterface)());
  else   (((::edm::Wrapper<reco::GlobalHaloData>*)o)->getInterface)();
}

static  void method_20925( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::GlobalHaloData>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_20926( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::GlobalHaloData>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_20927( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::GlobalHaloData>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_20928( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<reco::GlobalHaloData>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<reco::GlobalHaloData>*)o)->dynamicTypeInfo)();
}

static  void method_20929( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<reco::GlobalHaloData>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<reco::GlobalHaloData>*)o)->isPresent)();
}

static  void method_20930( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<reco::GlobalHaloData>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<reco::GlobalHaloData>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4708( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::GlobalHaloData> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::GlobalHaloData> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::GlobalHaloData> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::GlobalHaloData> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::GlobalHaloData> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<reco::GlobalHaloData> -------------------------------
void __edm__Wrapper_reco__GlobalHaloData__db_datamem(Reflex::Class*);
void __edm__Wrapper_reco__GlobalHaloData__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_reco__GlobalHaloData__datamem_bld(&__edm__Wrapper_reco__GlobalHaloData__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_reco__GlobalHaloData__funcmem_bld(&__edm__Wrapper_reco__GlobalHaloData__db_funcmem);
void __edm__Wrapper_reco__GlobalHaloData__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<reco::GlobalHaloData>"), typeid(::edm::Wrapper<reco::GlobalHaloData>), sizeof(::edm::Wrapper<reco::GlobalHaloData>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_7935, Reflex::Literal("edm::Wrapper<reco::GlobalHaloData>::value_type"))
  .AddTypedef(type_7935, Reflex::Literal("edm::Wrapper<reco::GlobalHaloData>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_20916, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2887), Reflex::Literal("Wrapper"), constructor_20917, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_20918, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33940), Reflex::Literal("Wrapper"), constructor_20923, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4708, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_reco__GlobalHaloData__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_reco__GlobalHaloData__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<reco::GlobalHaloData> -------------------
void __edm__Wrapper_reco__GlobalHaloData__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1647, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_reco__GlobalHaloData_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_7935, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_reco__GlobalHaloData_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<reco::GlobalHaloData> -------------------
void __edm__Wrapper_reco__GlobalHaloData__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33939), Reflex::Literal("product"), method_20919, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33939), Reflex::Literal("operator->"), operator_20920, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("productTypeInfo"), method_20921, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("typeInfo"), method_20922, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33941), Reflex::Literal("getInterface"), method_20924, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_19738, type_19832, type_33879), Reflex::Literal("fillView"), method_20925, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_364, type_10395), Reflex::Literal("setPtr"), method_20926, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_19897, type_19832), Reflex::Literal("fillPtrVector"), method_20927, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo"), method_20928, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isPresent"), method_20929, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo_"), method_20930, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class CSCHaloData -------------------------------
static  void operator_28054( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::CSCHaloData*)o)->operator=)(*(const ::reco::CSCHaloData*)arg[0]);
  else   (((::reco::CSCHaloData*)o)->operator=)(*(const ::reco::CSCHaloData*)arg[0]);
}

static void constructor_28055( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::CSCHaloData(*(const ::reco::CSCHaloData*)arg[0]);
  else ::new(mem) ::reco::CSCHaloData(*(const ::reco::CSCHaloData*)arg[0]);
}

static void constructor_28056( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::CSCHaloData();
  else ::new(mem) ::reco::CSCHaloData();
}

static void destructor_28057(void*, void * o, const std::vector<void*>&, void *) {
(((::reco::CSCHaloData*)o)->::reco::CSCHaloData::~CSCHaloData)();
}
static  void method_28058( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (int)((((const ::reco::CSCHaloData*)o)->NumberOfHaloTriggers)());
    else     (((const ::reco::CSCHaloData*)o)->NumberOfHaloTriggers)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (int)((((const ::reco::CSCHaloData*)o)->NumberOfHaloTriggers)(*(::reco::HaloData::Endcap*)arg[0]));
    else     (((const ::reco::CSCHaloData*)o)->NumberOfHaloTriggers)(*(::reco::HaloData::Endcap*)arg[0]);
  }
}

static  void method_28059( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (int)((((const ::reco::CSCHaloData*)o)->NHaloTriggers)());
    else     (((const ::reco::CSCHaloData*)o)->NHaloTriggers)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (int)((((const ::reco::CSCHaloData*)o)->NHaloTriggers)(*(::reco::HaloData::Endcap*)arg[0]));
    else     (((const ::reco::CSCHaloData*)o)->NHaloTriggers)(*(::reco::HaloData::Endcap*)arg[0]);
  }
}

static  void method_28060( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (int)((((const ::reco::CSCHaloData*)o)->NumberOfHaloTracks)());
    else     (((const ::reco::CSCHaloData*)o)->NumberOfHaloTracks)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (int)((((const ::reco::CSCHaloData*)o)->NumberOfHaloTracks)(*(::reco::HaloData::Endcap*)arg[0]));
    else     (((const ::reco::CSCHaloData*)o)->NumberOfHaloTracks)(*(::reco::HaloData::Endcap*)arg[0]);
  }
}

static  void method_28061( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (int)((((const ::reco::CSCHaloData*)o)->NHaloTracks)());
    else     (((const ::reco::CSCHaloData*)o)->NHaloTracks)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (int)((((const ::reco::CSCHaloData*)o)->NHaloTracks)(*(::reco::HaloData::Endcap*)arg[0]));
    else     (((const ::reco::CSCHaloData*)o)->NHaloTracks)(*(::reco::HaloData::Endcap*)arg[0]);
  }
}

static  void method_28062( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::reco::CSCHaloData*)o)->CSCHaloHLTAccept)());
  else   (((const ::reco::CSCHaloData*)o)->CSCHaloHLTAccept)();
}

static  void method_28063( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (short)((((const ::reco::CSCHaloData*)o)->NumberOfOutOfTimeTriggers)());
    else     (((const ::reco::CSCHaloData*)o)->NumberOfOutOfTimeTriggers)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (short)((((const ::reco::CSCHaloData*)o)->NumberOfOutOfTimeTriggers)(*(::reco::HaloData::Endcap*)arg[0]));
    else     (((const ::reco::CSCHaloData*)o)->NumberOfOutOfTimeTriggers)(*(::reco::HaloData::Endcap*)arg[0]);
  }
}

static  void method_28064( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (short)((((const ::reco::CSCHaloData*)o)->NOutOfTimeTriggers)());
    else     (((const ::reco::CSCHaloData*)o)->NOutOfTimeTriggers)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (short)((((const ::reco::CSCHaloData*)o)->NOutOfTimeTriggers)(*(::reco::HaloData::Endcap*)arg[0]));
    else     (((const ::reco::CSCHaloData*)o)->NOutOfTimeTriggers)(*(::reco::HaloData::Endcap*)arg[0]);
  }
}

static  void method_28065( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((const ::reco::CSCHaloData*)o)->NumberOfOutTimeHits)());
  else   (((const ::reco::CSCHaloData*)o)->NumberOfOutTimeHits)();
}

static  void method_28066( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((const ::reco::CSCHaloData*)o)->NOutOfTimeHits)());
  else   (((const ::reco::CSCHaloData*)o)->NOutOfTimeHits)();
}

static  void method_28067( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((const ::reco::CSCHaloData*)o)->NTracksSmalldT)());
  else   (((const ::reco::CSCHaloData*)o)->NTracksSmalldT)();
}

static  void method_28068( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((const ::reco::CSCHaloData*)o)->NTracksSmallBeta)());
  else   (((const ::reco::CSCHaloData*)o)->NTracksSmallBeta)();
}

static  void method_28069( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((const ::reco::CSCHaloData*)o)->NTracksSmallBetaAndSmalldT)());
  else   (((const ::reco::CSCHaloData*)o)->NTracksSmallBetaAndSmalldT)();
}

static  void method_28070( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((const ::reco::CSCHaloData*)o)->NFlatHaloSegments)());
  else   (((const ::reco::CSCHaloData*)o)->NFlatHaloSegments)();
}

static  void method_28071( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::reco::CSCHaloData*)o)->GetSegmentsInBothEndcaps)());
  else   (((const ::reco::CSCHaloData*)o)->GetSegmentsInBothEndcaps)();
}

static  void method_28072( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::CSCHaloData*)o)->GetTracks)();
  else   (((::reco::CSCHaloData*)o)->GetTracks)();
}

static  void method_28073( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::reco::CSCHaloData*)o)->GetTracks)();
  else   (((const ::reco::CSCHaloData*)o)->GetTracks)();
}

static  void method_28074( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::CSCHaloData*)o)->SetNumberOfHaloTriggers)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_28075( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::CSCHaloData*)o)->SetNOutOfTimeTriggers)(*(short*)arg[0],
    *(short*)arg[1]);
}

static  void method_28076( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::CSCHaloData*)o)->SetNOutOfTimeHits)(*(short*)arg[0]);
}

static  void method_28077( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::CSCHaloData*)o)->SetNIncomingTracks)(*(short*)arg[0],
    *(short*)arg[1],
    *(short*)arg[2]);
}

static  void method_28078( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::CSCHaloData*)o)->SetHLTBit)(*(bool*)arg[0]);
}

static  void method_28079( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::reco::CSCHaloData*)o)->GetCSCTrackImpactPositions)();
  else   (((const ::reco::CSCHaloData*)o)->GetCSCTrackImpactPositions)();
}

static  void method_28080( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::CSCHaloData*)o)->GetCSCTrackImpactPositions)();
  else   (((::reco::CSCHaloData*)o)->GetCSCTrackImpactPositions)();
}

static  void method_28081( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::CSCHaloData*)o)->SetNFlatHaloSegments)(*(short*)arg[0]);
}

static  void method_28082( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::reco::CSCHaloData*)o)->SetSegmentsBothEndcaps)(*(bool*)arg[0]);
}

static void method_newdel_7975( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::reco::CSCHaloData >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::reco::CSCHaloData >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::reco::CSCHaloData >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::reco::CSCHaloData >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::reco::CSCHaloData >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class CSCHaloData -------------------------------
void __reco__CSCHaloData_db_datamem(Reflex::Class*);
void __reco__CSCHaloData_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __reco__CSCHaloData_datamem_bld(&__reco__CSCHaloData_db_datamem);
Reflex::GenreflexMemberBuilder __reco__CSCHaloData_funcmem_bld(&__reco__CSCHaloData_db_funcmem);
void __reco__CSCHaloData_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("reco::CSCHaloData"), typeid(::reco::CSCHaloData), sizeof(::reco::CSCHaloData), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39362, type_39387), Reflex::Literal("operator="), operator_28054, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39387), Reflex::Literal("CSCHaloData"), constructor_28055, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("CSCHaloData"), constructor_28056, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~CSCHaloData"), destructor_28057, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7975, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__reco__CSCHaloData_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__reco__CSCHaloData_funcmem_bld);
}

//------Delayed data member builder for class CSCHaloData -------------------
void __reco__CSCHaloData_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4657, Reflex::Literal("TheTrackRefs"), OffsetOf(__shadow__::__reco__CSCHaloData, TheTrackRefs), ::Reflex::PRIVATE)
  .AddDataMember(type_3149, Reflex::Literal("TheGlobalPositions"), OffsetOf(__shadow__::__reco__CSCHaloData, TheGlobalPositions), ::Reflex::PRIVATE)
  .AddDataMember(type_72, Reflex::Literal("nTriggers_PlusZ"), OffsetOf(__shadow__::__reco__CSCHaloData, nTriggers_PlusZ), ::Reflex::PRIVATE)
  .AddDataMember(type_72, Reflex::Literal("nTriggers_MinusZ"), OffsetOf(__shadow__::__reco__CSCHaloData, nTriggers_MinusZ), ::Reflex::PRIVATE)
  .AddDataMember(type_1647, Reflex::Literal("HLTAccept"), OffsetOf(__shadow__::__reco__CSCHaloData, HLTAccept), ::Reflex::PRIVATE)
  .AddDataMember(type_72, Reflex::Literal("nTracks_PlusZ"), OffsetOf(__shadow__::__reco__CSCHaloData, nTracks_PlusZ), ::Reflex::PRIVATE)
  .AddDataMember(type_72, Reflex::Literal("nTracks_MinusZ"), OffsetOf(__shadow__::__reco__CSCHaloData, nTracks_MinusZ), ::Reflex::PRIVATE)
  .AddDataMember(type_192, Reflex::Literal("nOutOfTimeTriggers_PlusZ"), OffsetOf(__shadow__::__reco__CSCHaloData, nOutOfTimeTriggers_PlusZ), ::Reflex::PRIVATE)
  .AddDataMember(type_192, Reflex::Literal("nOutOfTimeTriggers_MinusZ"), OffsetOf(__shadow__::__reco__CSCHaloData, nOutOfTimeTriggers_MinusZ), ::Reflex::PRIVATE)
  .AddDataMember(type_192, Reflex::Literal("nOutOfTimeHits"), OffsetOf(__shadow__::__reco__CSCHaloData, nOutOfTimeHits), ::Reflex::PRIVATE)
  .AddDataMember(type_192, Reflex::Literal("nTracks_Small_dT"), OffsetOf(__shadow__::__reco__CSCHaloData, nTracks_Small_dT), ::Reflex::PRIVATE)
  .AddDataMember(type_192, Reflex::Literal("nTracks_Small_beta"), OffsetOf(__shadow__::__reco__CSCHaloData, nTracks_Small_beta), ::Reflex::PRIVATE)
  .AddDataMember(type_192, Reflex::Literal("nTracks_Small_dT_Small_beta"), OffsetOf(__shadow__::__reco__CSCHaloData, nTracks_Small_dT_Small_beta), ::Reflex::PRIVATE)
  .AddDataMember(type_192, Reflex::Literal("nFlatHaloSegments"), OffsetOf(__shadow__::__reco__CSCHaloData, nFlatHaloSegments), ::Reflex::PRIVATE)
  .AddDataMember(type_1647, Reflex::Literal("segments_in_both_endcaps"), OffsetOf(__shadow__::__reco__CSCHaloData, segments_in_both_endcaps), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class CSCHaloData -------------------
void __reco__CSCHaloData_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72, type_28331), Reflex::Literal("NumberOfHaloTriggers"), method_28058, 0, "z=both", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72, type_28331), Reflex::Literal("NHaloTriggers"), method_28059, 0, "z=both", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72, type_28331), Reflex::Literal("NumberOfHaloTracks"), method_28060, 0, "z=both", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72, type_28331), Reflex::Literal("NHaloTracks"), method_28061, 0, "z=both", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("CSCHaloHLTAccept"), method_28062, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_192, type_28331), Reflex::Literal("NumberOfOutOfTimeTriggers"), method_28063, 0, "z=both", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_192, type_28331), Reflex::Literal("NOutOfTimeTriggers"), method_28064, 0, "z=both", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_192), Reflex::Literal("NumberOfOutTimeHits"), method_28065, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_192), Reflex::Literal("NOutOfTimeHits"), method_28066, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_192), Reflex::Literal("NTracksSmalldT"), method_28067, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_192), Reflex::Literal("NTracksSmallBeta"), method_28068, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_192), Reflex::Literal("NTracksSmallBetaAndSmalldT"), method_28069, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_192), Reflex::Literal("NFlatHaloSegments"), method_28070, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("GetSegmentsInBothEndcaps"), method_28071, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33859), Reflex::Literal("GetTracks"), method_28072, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33855), Reflex::Literal("GetTracks"), method_28073, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_72, type_72), Reflex::Literal("SetNumberOfHaloTriggers"), method_28074, 0, "PlusZ;MinusZ", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_192, type_192), Reflex::Literal("SetNOutOfTimeTriggers"), method_28075, 0, "PlusZ;MinusZ", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_192), Reflex::Literal("SetNOutOfTimeHits"), method_28076, 0, "num", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_192, type_192, type_192), Reflex::Literal("SetNIncomingTracks"), method_28077, 0, "n_small_dT;n_small_beta;n_small_both", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_1647), Reflex::Literal("SetHLTBit"), method_28078, 0, "status", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32820), Reflex::Literal("GetCSCTrackImpactPositions"), method_28079, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32821), Reflex::Literal("GetCSCTrackImpactPositions"), method_28080, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_192), Reflex::Literal("SetNFlatHaloSegments"), method_28081, 0, "nSegments", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_1647), Reflex::Literal("SetSegmentsBothEndcaps"), method_28082, 0, "b", ::Reflex::PUBLIC);
}
//------Stub functions for class Wrapper<reco::CSCHaloData> -------------------------------
static void constructor_20937( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::CSCHaloData>();
  else ::new(mem) ::edm::Wrapper<reco::CSCHaloData>();
}

static void constructor_20938( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::CSCHaloData>(*(::std::auto_ptr<reco::CSCHaloData>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<reco::CSCHaloData>(*(::std::auto_ptr<reco::CSCHaloData>*)arg[0]);
}

static void destructor_20939(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<reco::CSCHaloData>*)o)->::edm::Wrapper<reco::CSCHaloData>::~Wrapper)();
}
static  void method_20940( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<reco::CSCHaloData>*)o)->product)());
  else   (((const ::edm::Wrapper<reco::CSCHaloData>*)o)->product)();
}

static  void operator_20941( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<reco::CSCHaloData>*)o)->operator->)());
  else   (((const ::edm::Wrapper<reco::CSCHaloData>*)o)->operator->)();
}

static  void method_20942( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<reco::CSCHaloData>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<reco::CSCHaloData>*)o)->productTypeInfo)();
}

static  void method_20943( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<reco::CSCHaloData>*)o)->typeInfo)();
  else   (((::edm::Wrapper<reco::CSCHaloData>*)o)->typeInfo)();
}

static void constructor_20944( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::CSCHaloData>((::reco::CSCHaloData*)arg[0]);
  else ::new(mem) ::edm::Wrapper<reco::CSCHaloData>((::reco::CSCHaloData*)arg[0]);
}

static  void method_20945( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<reco::CSCHaloData>*)o)->getInterface)());
  else   (((::edm::Wrapper<reco::CSCHaloData>*)o)->getInterface)();
}

static  void method_20946( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::CSCHaloData>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_20947( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::CSCHaloData>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_20948( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::CSCHaloData>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_20949( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<reco::CSCHaloData>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<reco::CSCHaloData>*)o)->dynamicTypeInfo)();
}

static  void method_20950( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<reco::CSCHaloData>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<reco::CSCHaloData>*)o)->isPresent)();
}

static  void method_20951( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<reco::CSCHaloData>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<reco::CSCHaloData>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4709( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::CSCHaloData> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::CSCHaloData> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::CSCHaloData> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::CSCHaloData> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::CSCHaloData> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<reco::CSCHaloData> -------------------------------
void __edm__Wrapper_reco__CSCHaloData__db_datamem(Reflex::Class*);
void __edm__Wrapper_reco__CSCHaloData__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_reco__CSCHaloData__datamem_bld(&__edm__Wrapper_reco__CSCHaloData__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_reco__CSCHaloData__funcmem_bld(&__edm__Wrapper_reco__CSCHaloData__db_funcmem);
void __edm__Wrapper_reco__CSCHaloData__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<reco::CSCHaloData>"), typeid(::edm::Wrapper<reco::CSCHaloData>), sizeof(::edm::Wrapper<reco::CSCHaloData>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_7975, Reflex::Literal("edm::Wrapper<reco::CSCHaloData>::value_type"))
  .AddTypedef(type_7975, Reflex::Literal("edm::Wrapper<reco::CSCHaloData>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_20937, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2888), Reflex::Literal("Wrapper"), constructor_20938, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_20939, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33945), Reflex::Literal("Wrapper"), constructor_20944, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4709, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_reco__CSCHaloData__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_reco__CSCHaloData__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<reco::CSCHaloData> -------------------
void __edm__Wrapper_reco__CSCHaloData__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1647, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_reco__CSCHaloData_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_7975, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_reco__CSCHaloData_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<reco::CSCHaloData> -------------------
void __edm__Wrapper_reco__CSCHaloData__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33944), Reflex::Literal("product"), method_20940, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33944), Reflex::Literal("operator->"), operator_20941, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("productTypeInfo"), method_20942, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("typeInfo"), method_20943, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33946), Reflex::Literal("getInterface"), method_20945, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_19738, type_19832, type_33879), Reflex::Literal("fillView"), method_20946, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_364, type_10395), Reflex::Literal("setPtr"), method_20947, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_19897, type_19832), Reflex::Literal("fillPtrVector"), method_20948, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo"), method_20949, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isPresent"), method_20950, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo_"), method_20951, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HcalHaloData -------------------------------
static  void operator_27196( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::HcalHaloData*)o)->operator=)(*(const ::reco::HcalHaloData*)arg[0]);
  else   (((::reco::HcalHaloData*)o)->operator=)(*(const ::reco::HcalHaloData*)arg[0]);
}

static void constructor_27197( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::HcalHaloData(*(const ::reco::HcalHaloData*)arg[0]);
  else ::new(mem) ::reco::HcalHaloData(*(const ::reco::HcalHaloData*)arg[0]);
}

static void constructor_27198( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::HcalHaloData();
  else ::new(mem) ::reco::HcalHaloData();
}

static void destructor_27199(void*, void * o, const std::vector<void*>&, void *) {
(((::reco::HcalHaloData*)o)->::reco::HcalHaloData::~HcalHaloData)();
}
static  void method_27200( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::reco::HcalHaloData*)o)->GetPhiWedges)();
  else   (((const ::reco::HcalHaloData*)o)->GetPhiWedges)();
}

static  void method_27201( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::HcalHaloData*)o)->GetPhiWedges)();
  else   (((::reco::HcalHaloData*)o)->GetPhiWedges)();
}

static void method_newdel_7923( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::reco::HcalHaloData >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::reco::HcalHaloData >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::reco::HcalHaloData >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::reco::HcalHaloData >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::reco::HcalHaloData >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HcalHaloData -------------------------------
void __reco__HcalHaloData_db_datamem(Reflex::Class*);
void __reco__HcalHaloData_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __reco__HcalHaloData_datamem_bld(&__reco__HcalHaloData_db_datamem);
Reflex::GenreflexMemberBuilder __reco__HcalHaloData_funcmem_bld(&__reco__HcalHaloData_db_funcmem);
void __reco__HcalHaloData_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("reco::HcalHaloData"), typeid(::reco::HcalHaloData), sizeof(::reco::HcalHaloData), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39322, type_39323), Reflex::Literal("operator="), operator_27196, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39323), Reflex::Literal("HcalHaloData"), constructor_27197, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalHaloData"), constructor_27198, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalHaloData"), destructor_27199, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7923, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__reco__HcalHaloData_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__reco__HcalHaloData_funcmem_bld);
}

//------Delayed data member builder for class HcalHaloData -------------------
void __reco__HcalHaloData_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3150, Reflex::Literal("PhiWedgeCollection"), OffsetOf(__shadow__::__reco__HcalHaloData, PhiWedgeCollection), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class HcalHaloData -------------------
void __reco__HcalHaloData_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32823), Reflex::Literal("GetPhiWedges"), method_27200, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32824), Reflex::Literal("GetPhiWedges"), method_27201, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class Wrapper<reco::HcalHaloData> -------------------------------
static void constructor_20958( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::HcalHaloData>();
  else ::new(mem) ::edm::Wrapper<reco::HcalHaloData>();
}

static void constructor_20959( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::HcalHaloData>(*(::std::auto_ptr<reco::HcalHaloData>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<reco::HcalHaloData>(*(::std::auto_ptr<reco::HcalHaloData>*)arg[0]);
}

static void destructor_20960(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<reco::HcalHaloData>*)o)->::edm::Wrapper<reco::HcalHaloData>::~Wrapper)();
}
static  void method_20961( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<reco::HcalHaloData>*)o)->product)());
  else   (((const ::edm::Wrapper<reco::HcalHaloData>*)o)->product)();
}

static  void operator_20962( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<reco::HcalHaloData>*)o)->operator->)());
  else   (((const ::edm::Wrapper<reco::HcalHaloData>*)o)->operator->)();
}

static  void method_20963( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<reco::HcalHaloData>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<reco::HcalHaloData>*)o)->productTypeInfo)();
}

static  void method_20964( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<reco::HcalHaloData>*)o)->typeInfo)();
  else   (((::edm::Wrapper<reco::HcalHaloData>*)o)->typeInfo)();
}

static void constructor_20965( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::HcalHaloData>((::reco::HcalHaloData*)arg[0]);
  else ::new(mem) ::edm::Wrapper<reco::HcalHaloData>((::reco::HcalHaloData*)arg[0]);
}

static  void method_20966( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<reco::HcalHaloData>*)o)->getInterface)());
  else   (((::edm::Wrapper<reco::HcalHaloData>*)o)->getInterface)();
}

static  void method_20967( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::HcalHaloData>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_20968( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::HcalHaloData>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_20969( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::HcalHaloData>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_20970( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<reco::HcalHaloData>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<reco::HcalHaloData>*)o)->dynamicTypeInfo)();
}

static  void method_20971( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<reco::HcalHaloData>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<reco::HcalHaloData>*)o)->isPresent)();
}

static  void method_20972( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<reco::HcalHaloData>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<reco::HcalHaloData>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4710( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::HcalHaloData> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::HcalHaloData> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::HcalHaloData> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::HcalHaloData> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::HcalHaloData> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<reco::HcalHaloData> -------------------------------
void __edm__Wrapper_reco__HcalHaloData__db_datamem(Reflex::Class*);
void __edm__Wrapper_reco__HcalHaloData__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_reco__HcalHaloData__datamem_bld(&__edm__Wrapper_reco__HcalHaloData__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_reco__HcalHaloData__funcmem_bld(&__edm__Wrapper_reco__HcalHaloData__db_funcmem);
void __edm__Wrapper_reco__HcalHaloData__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<reco::HcalHaloData>"), typeid(::edm::Wrapper<reco::HcalHaloData>), sizeof(::edm::Wrapper<reco::HcalHaloData>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_7923, Reflex::Literal("edm::Wrapper<reco::HcalHaloData>::value_type"))
  .AddTypedef(type_7923, Reflex::Literal("edm::Wrapper<reco::HcalHaloData>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_20958, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2889), Reflex::Literal("Wrapper"), constructor_20959, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_20960, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33950), Reflex::Literal("Wrapper"), constructor_20965, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4710, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_reco__HcalHaloData__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_reco__HcalHaloData__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<reco::HcalHaloData> -------------------
void __edm__Wrapper_reco__HcalHaloData__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1647, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_reco__HcalHaloData_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_7923, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_reco__HcalHaloData_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<reco::HcalHaloData> -------------------
void __edm__Wrapper_reco__HcalHaloData__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33949), Reflex::Literal("product"), method_20961, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33949), Reflex::Literal("operator->"), operator_20962, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("productTypeInfo"), method_20963, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("typeInfo"), method_20964, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33951), Reflex::Literal("getInterface"), method_20966, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_19738, type_19832, type_33879), Reflex::Literal("fillView"), method_20967, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_364, type_10395), Reflex::Literal("setPtr"), method_20968, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_19897, type_19832), Reflex::Literal("fillPtrVector"), method_20969, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo"), method_20970, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isPresent"), method_20971, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo_"), method_20972, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class EcalHaloData -------------------------------
static  void operator_27206( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::EcalHaloData*)o)->operator=)(*(const ::reco::EcalHaloData*)arg[0]);
  else   (((::reco::EcalHaloData*)o)->operator=)(*(const ::reco::EcalHaloData*)arg[0]);
}

static void constructor_27207( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::EcalHaloData(*(const ::reco::EcalHaloData*)arg[0]);
  else ::new(mem) ::reco::EcalHaloData(*(const ::reco::EcalHaloData*)arg[0]);
}

static void constructor_27208( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::EcalHaloData();
  else ::new(mem) ::reco::EcalHaloData();
}

static void destructor_27209(void*, void * o, const std::vector<void*>&, void *) {
(((::reco::EcalHaloData*)o)->::reco::EcalHaloData::~EcalHaloData)();
}
static  void method_27210( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (int)((((const ::reco::EcalHaloData*)o)->NumberOfHaloSuperClusters)());
    else     (((const ::reco::EcalHaloData*)o)->NumberOfHaloSuperClusters)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (int)((((const ::reco::EcalHaloData*)o)->NumberOfHaloSuperClusters)(*(float*)arg[0]));
    else     (((const ::reco::EcalHaloData*)o)->NumberOfHaloSuperClusters)(*(float*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (int)((((const ::reco::EcalHaloData*)o)->NumberOfHaloSuperClusters)(*(float*)arg[0],
      *(float*)arg[1]));
    else     (((const ::reco::EcalHaloData*)o)->NumberOfHaloSuperClusters)(*(float*)arg[0],
      *(float*)arg[1]);
  }
}

static  void method_27211( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::reco::EcalHaloData*)o)->GetPhiWedges)();
  else   (((const ::reco::EcalHaloData*)o)->GetPhiWedges)();
}

static  void method_27212( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::EcalHaloData*)o)->GetPhiWedges)();
  else   (((::reco::EcalHaloData*)o)->GetPhiWedges)();
}

static  void method_27213( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::EcalHaloData*)o)->GetSuperClusters)();
  else   (((::reco::EcalHaloData*)o)->GetSuperClusters)();
}

static  void method_27214( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::reco::EcalHaloData*)o)->GetSuperClusters)();
  else   (((const ::reco::EcalHaloData*)o)->GetSuperClusters)();
}

static  void method_27215( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::EcalHaloData*)o)->GetShowerShapesRoundness)();
  else   (((::reco::EcalHaloData*)o)->GetShowerShapesRoundness)();
}

static  void method_27216( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::reco::EcalHaloData*)o)->GetShowerShapesRoundness)();
  else   (((const ::reco::EcalHaloData*)o)->GetShowerShapesRoundness)();
}

static  void method_27217( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::EcalHaloData*)o)->GetShowerShapesAngle)();
  else   (((::reco::EcalHaloData*)o)->GetShowerShapesAngle)();
}

static  void method_27218( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::reco::EcalHaloData*)o)->GetShowerShapesAngle)();
  else   (((const ::reco::EcalHaloData*)o)->GetShowerShapesAngle)();
}

static void method_newdel_7925( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::reco::EcalHaloData >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::reco::EcalHaloData >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::reco::EcalHaloData >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::reco::EcalHaloData >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::reco::EcalHaloData >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class EcalHaloData -------------------------------
void __reco__EcalHaloData_db_datamem(Reflex::Class*);
void __reco__EcalHaloData_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __reco__EcalHaloData_datamem_bld(&__reco__EcalHaloData_db_datamem);
Reflex::GenreflexMemberBuilder __reco__EcalHaloData_funcmem_bld(&__reco__EcalHaloData_db_funcmem);
void __reco__EcalHaloData_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("reco::EcalHaloData"), typeid(::reco::EcalHaloData), sizeof(::reco::EcalHaloData), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39324, type_39325), Reflex::Literal("operator="), operator_27206, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39325), Reflex::Literal("EcalHaloData"), constructor_27207, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("EcalHaloData"), constructor_27208, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~EcalHaloData"), destructor_27209, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7925, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__reco__EcalHaloData_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__reco__EcalHaloData_funcmem_bld);
}

//------Delayed data member builder for class EcalHaloData -------------------
void __reco__EcalHaloData_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3150, Reflex::Literal("PhiWedgeCollection"), OffsetOf(__shadow__::__reco__EcalHaloData, PhiWedgeCollection), ::Reflex::PRIVATE)
  .AddDataMember(type_4656, Reflex::Literal("TheSuperClusterRefs"), OffsetOf(__shadow__::__reco__EcalHaloData, TheSuperClusterRefs), ::Reflex::PRIVATE)
  .AddDataMember(type_4880, Reflex::Literal("ShowerShapes_Roundness"), OffsetOf(__shadow__::__reco__EcalHaloData, ShowerShapes_Roundness), ::Reflex::PRIVATE)
  .AddDataMember(type_4880, Reflex::Literal("ShowerShapes_Angle"), OffsetOf(__shadow__::__reco__EcalHaloData, ShowerShapes_Angle), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class EcalHaloData -------------------
void __reco__EcalHaloData_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72, type_932, type_932), Reflex::Literal("NumberOfHaloSuperClusters"), method_27210, 0, "roundness=1.0e+2;angle=4.0e+0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32823), Reflex::Literal("GetPhiWedges"), method_27211, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32824), Reflex::Literal("GetPhiWedges"), method_27212, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33853), Reflex::Literal("GetSuperClusters"), method_27213, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33849), Reflex::Literal("GetSuperClusters"), method_27214, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_34343), Reflex::Literal("GetShowerShapesRoundness"), method_27215, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_34342), Reflex::Literal("GetShowerShapesRoundness"), method_27216, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_34343), Reflex::Literal("GetShowerShapesAngle"), method_27217, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_34342), Reflex::Literal("GetShowerShapesAngle"), method_27218, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<reco::EcalHaloData> -------------------------------
static void constructor_20979( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::EcalHaloData>();
  else ::new(mem) ::edm::Wrapper<reco::EcalHaloData>();
}

static void constructor_20980( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::EcalHaloData>(*(::std::auto_ptr<reco::EcalHaloData>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<reco::EcalHaloData>(*(::std::auto_ptr<reco::EcalHaloData>*)arg[0]);
}

static void destructor_20981(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<reco::EcalHaloData>*)o)->::edm::Wrapper<reco::EcalHaloData>::~Wrapper)();
}
static  void method_20982( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<reco::EcalHaloData>*)o)->product)());
  else   (((const ::edm::Wrapper<reco::EcalHaloData>*)o)->product)();
}

static  void operator_20983( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<reco::EcalHaloData>*)o)->operator->)());
  else   (((const ::edm::Wrapper<reco::EcalHaloData>*)o)->operator->)();
}

static  void method_20984( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<reco::EcalHaloData>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<reco::EcalHaloData>*)o)->productTypeInfo)();
}

static  void method_20985( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<reco::EcalHaloData>*)o)->typeInfo)();
  else   (((::edm::Wrapper<reco::EcalHaloData>*)o)->typeInfo)();
}

static void constructor_20986( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::EcalHaloData>((::reco::EcalHaloData*)arg[0]);
  else ::new(mem) ::edm::Wrapper<reco::EcalHaloData>((::reco::EcalHaloData*)arg[0]);
}

static  void method_20987( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<reco::EcalHaloData>*)o)->getInterface)());
  else   (((::edm::Wrapper<reco::EcalHaloData>*)o)->getInterface)();
}

static  void method_20988( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::EcalHaloData>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_20989( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::EcalHaloData>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_20990( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::EcalHaloData>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_20991( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<reco::EcalHaloData>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<reco::EcalHaloData>*)o)->dynamicTypeInfo)();
}

static  void method_20992( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<reco::EcalHaloData>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<reco::EcalHaloData>*)o)->isPresent)();
}

static  void method_20993( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<reco::EcalHaloData>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<reco::EcalHaloData>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4711( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::EcalHaloData> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::EcalHaloData> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::EcalHaloData> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::EcalHaloData> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::EcalHaloData> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<reco::EcalHaloData> -------------------------------
void __edm__Wrapper_reco__EcalHaloData__db_datamem(Reflex::Class*);
void __edm__Wrapper_reco__EcalHaloData__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_reco__EcalHaloData__datamem_bld(&__edm__Wrapper_reco__EcalHaloData__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_reco__EcalHaloData__funcmem_bld(&__edm__Wrapper_reco__EcalHaloData__db_funcmem);
void __edm__Wrapper_reco__EcalHaloData__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<reco::EcalHaloData>"), typeid(::edm::Wrapper<reco::EcalHaloData>), sizeof(::edm::Wrapper<reco::EcalHaloData>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_7925, Reflex::Literal("edm::Wrapper<reco::EcalHaloData>::value_type"))
  .AddTypedef(type_7925, Reflex::Literal("edm::Wrapper<reco::EcalHaloData>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_20979, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2890), Reflex::Literal("Wrapper"), constructor_20980, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_20981, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33955), Reflex::Literal("Wrapper"), constructor_20986, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4711, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_reco__EcalHaloData__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_reco__EcalHaloData__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<reco::EcalHaloData> -------------------
void __edm__Wrapper_reco__EcalHaloData__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1647, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_reco__EcalHaloData_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_7925, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_reco__EcalHaloData_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<reco::EcalHaloData> -------------------
void __edm__Wrapper_reco__EcalHaloData__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33954), Reflex::Literal("product"), method_20982, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33954), Reflex::Literal("operator->"), operator_20983, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("productTypeInfo"), method_20984, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("typeInfo"), method_20985, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33956), Reflex::Literal("getInterface"), method_20987, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_19738, type_19832, type_33879), Reflex::Literal("fillView"), method_20988, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_364, type_10395), Reflex::Literal("setPtr"), method_20989, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_19897, type_19832), Reflex::Literal("fillPtrVector"), method_20990, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo"), method_20991, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isPresent"), method_20992, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo_"), method_20993, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<reco::PhiWedge> -------------------------------
static void constructor_21000( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::PhiWedge>();
  else ::new(mem) ::edm::Wrapper<reco::PhiWedge>();
}

static void constructor_21001( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::PhiWedge>(*(::std::auto_ptr<reco::PhiWedge>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<reco::PhiWedge>(*(::std::auto_ptr<reco::PhiWedge>*)arg[0]);
}

static void destructor_21002(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<reco::PhiWedge>*)o)->::edm::Wrapper<reco::PhiWedge>::~Wrapper)();
}
static  void method_21003( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<reco::PhiWedge>*)o)->product)());
  else   (((const ::edm::Wrapper<reco::PhiWedge>*)o)->product)();
}

static  void operator_21004( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<reco::PhiWedge>*)o)->operator->)());
  else   (((const ::edm::Wrapper<reco::PhiWedge>*)o)->operator->)();
}

static  void method_21005( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<reco::PhiWedge>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<reco::PhiWedge>*)o)->productTypeInfo)();
}

static  void method_21006( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<reco::PhiWedge>*)o)->typeInfo)();
  else   (((::edm::Wrapper<reco::PhiWedge>*)o)->typeInfo)();
}

static void constructor_21007( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::PhiWedge>((::reco::PhiWedge*)arg[0]);
  else ::new(mem) ::edm::Wrapper<reco::PhiWedge>((::reco::PhiWedge*)arg[0]);
}

static  void method_21008( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<reco::PhiWedge>*)o)->getInterface)());
  else   (((::edm::Wrapper<reco::PhiWedge>*)o)->getInterface)();
}

static  void method_21009( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::PhiWedge>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_21010( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::PhiWedge>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_21011( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::PhiWedge>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_21012( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<reco::PhiWedge>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<reco::PhiWedge>*)o)->dynamicTypeInfo)();
}

static  void method_21013( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<reco::PhiWedge>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<reco::PhiWedge>*)o)->isPresent)();
}

static  void method_21014( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<reco::PhiWedge>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<reco::PhiWedge>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4712( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::PhiWedge> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::PhiWedge> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::PhiWedge> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::PhiWedge> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::PhiWedge> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<reco::PhiWedge> -------------------------------
void __edm__Wrapper_reco__PhiWedge__db_datamem(Reflex::Class*);
void __edm__Wrapper_reco__PhiWedge__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_reco__PhiWedge__datamem_bld(&__edm__Wrapper_reco__PhiWedge__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_reco__PhiWedge__funcmem_bld(&__edm__Wrapper_reco__PhiWedge__db_funcmem);
void __edm__Wrapper_reco__PhiWedge__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<reco::PhiWedge>"), typeid(::edm::Wrapper<reco::PhiWedge>), sizeof(::edm::Wrapper<reco::PhiWedge>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_7934, Reflex::Literal("edm::Wrapper<reco::PhiWedge>::value_type"))
  .AddTypedef(type_7934, Reflex::Literal("edm::Wrapper<reco::PhiWedge>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_21000, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2891), Reflex::Literal("Wrapper"), constructor_21001, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_21002, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10297), Reflex::Literal("Wrapper"), constructor_21007, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4712, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_reco__PhiWedge__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_reco__PhiWedge__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<reco::PhiWedge> -------------------
void __edm__Wrapper_reco__PhiWedge__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1647, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_reco__PhiWedge_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_7934, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_reco__PhiWedge_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<reco::PhiWedge> -------------------
void __edm__Wrapper_reco__PhiWedge__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13890), Reflex::Literal("product"), method_21003, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13890), Reflex::Literal("operator->"), operator_21004, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("productTypeInfo"), method_21005, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("typeInfo"), method_21006, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33959), Reflex::Literal("getInterface"), method_21008, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_19738, type_19832, type_33879), Reflex::Literal("fillView"), method_21009, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_364, type_10395), Reflex::Literal("setPtr"), method_21010, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_19897, type_19832), Reflex::Literal("fillPtrVector"), method_21011, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo"), method_21012, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isPresent"), method_21013, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo_"), method_21014, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<HcalNoiseSummary> -------------------------------
static void constructor_21021( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<HcalNoiseSummary>();
  else ::new(mem) ::edm::Wrapper<HcalNoiseSummary>();
}

static void constructor_21022( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<HcalNoiseSummary>(*(::std::auto_ptr<HcalNoiseSummary>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<HcalNoiseSummary>(*(::std::auto_ptr<HcalNoiseSummary>*)arg[0]);
}

static void destructor_21023(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<HcalNoiseSummary>*)o)->::edm::Wrapper<HcalNoiseSummary>::~Wrapper)();
}
static  void method_21024( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<HcalNoiseSummary>*)o)->product)());
  else   (((const ::edm::Wrapper<HcalNoiseSummary>*)o)->product)();
}

static  void operator_21025( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<HcalNoiseSummary>*)o)->operator->)());
  else   (((const ::edm::Wrapper<HcalNoiseSummary>*)o)->operator->)();
}

static  void method_21026( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<HcalNoiseSummary>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<HcalNoiseSummary>*)o)->productTypeInfo)();
}

static  void method_21027( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<HcalNoiseSummary>*)o)->typeInfo)();
  else   (((::edm::Wrapper<HcalNoiseSummary>*)o)->typeInfo)();
}

static void constructor_21028( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<HcalNoiseSummary>((::HcalNoiseSummary*)arg[0]);
  else ::new(mem) ::edm::Wrapper<HcalNoiseSummary>((::HcalNoiseSummary*)arg[0]);
}

static  void method_21029( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<HcalNoiseSummary>*)o)->getInterface)());
  else   (((::edm::Wrapper<HcalNoiseSummary>*)o)->getInterface)();
}

static  void method_21030( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<HcalNoiseSummary>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_21031( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<HcalNoiseSummary>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_21032( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<HcalNoiseSummary>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_21033( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<HcalNoiseSummary>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<HcalNoiseSummary>*)o)->dynamicTypeInfo)();
}

static  void method_21034( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<HcalNoiseSummary>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<HcalNoiseSummary>*)o)->isPresent)();
}

static  void method_21035( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<HcalNoiseSummary>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<HcalNoiseSummary>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4713( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<HcalNoiseSummary> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<HcalNoiseSummary> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<HcalNoiseSummary> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<HcalNoiseSummary> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<HcalNoiseSummary> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<HcalNoiseSummary> -------------------------------
void __edm__Wrapper_HcalNoiseSummary__db_datamem(Reflex::Class*);
void __edm__Wrapper_HcalNoiseSummary__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_HcalNoiseSummary__datamem_bld(&__edm__Wrapper_HcalNoiseSummary__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_HcalNoiseSummary__funcmem_bld(&__edm__Wrapper_HcalNoiseSummary__db_funcmem);
void __edm__Wrapper_HcalNoiseSummary__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<HcalNoiseSummary>"), typeid(::edm::Wrapper<HcalNoiseSummary>), sizeof(::edm::Wrapper<HcalNoiseSummary>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_87, Reflex::Literal("edm::Wrapper<HcalNoiseSummary>::value_type"))
  .AddTypedef(type_87, Reflex::Literal("edm::Wrapper<HcalNoiseSummary>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_21021, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2893), Reflex::Literal("Wrapper"), constructor_21022, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_21023, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33963), Reflex::Literal("Wrapper"), constructor_21028, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4713, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_HcalNoiseSummary__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_HcalNoiseSummary__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<HcalNoiseSummary> -------------------
void __edm__Wrapper_HcalNoiseSummary__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1647, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_HcalNoiseSummary_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_87, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_HcalNoiseSummary_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<HcalNoiseSummary> -------------------
void __edm__Wrapper_HcalNoiseSummary__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33962), Reflex::Literal("product"), method_21024, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33962), Reflex::Literal("operator->"), operator_21025, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("productTypeInfo"), method_21026, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("typeInfo"), method_21027, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33964), Reflex::Literal("getInterface"), method_21029, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_19738, type_19832, type_33879), Reflex::Literal("fillView"), method_21030, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_364, type_10395), Reflex::Literal("setPtr"), method_21031, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_19897, type_19832), Reflex::Literal("fillPtrVector"), method_21032, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo"), method_21033, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isPresent"), method_21034, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo_"), method_21035, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<reco::PFClusterMET, std::allocator<reco::PFClusterMET> > > -------------------------------
static void constructor_21084( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::PFClusterMET> >();
  else ::new(mem) ::edm::Wrapper<std::vector<reco::PFClusterMET> >();
}

static void constructor_21085( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::PFClusterMET> >(*(::std::auto_ptr<std::vector<reco::PFClusterMET> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<reco::PFClusterMET> >(*(::std::auto_ptr<std::vector<reco::PFClusterMET> >*)arg[0]);
}

static void destructor_21086(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<reco::PFClusterMET> >*)o)->::edm::Wrapper<std::vector<reco::PFClusterMET> >::~Wrapper)();
}
static  void method_21087( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<reco::PFClusterMET> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<reco::PFClusterMET> >*)o)->product)();
}

static  void operator_21088( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<reco::PFClusterMET> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<reco::PFClusterMET> >*)o)->operator->)();
}

static  void method_21089( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<reco::PFClusterMET> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<reco::PFClusterMET> >*)o)->productTypeInfo)();
}

static  void method_21090( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<reco::PFClusterMET> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<reco::PFClusterMET> >*)o)->typeInfo)();
}

static void constructor_21091( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::PFClusterMET> >((::std::vector<reco::PFClusterMET>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<reco::PFClusterMET> >((::std::vector<reco::PFClusterMET>*)arg[0]);
}

static  void method_21092( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<reco::PFClusterMET> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<reco::PFClusterMET> >*)o)->getInterface)();
}

static  void method_21093( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::PFClusterMET> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_21094( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::PFClusterMET> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_21095( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::PFClusterMET> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_21096( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<reco::PFClusterMET> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<reco::PFClusterMET> >*)o)->dynamicTypeInfo)();
}

static  void method_21097( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<reco::PFClusterMET> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<reco::PFClusterMET> >*)o)->isPresent)();
}

static  void method_21098( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<reco::PFClusterMET> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<reco::PFClusterMET> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4716( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::PFClusterMET> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::PFClusterMET> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::PFClusterMET> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::PFClusterMET> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::PFClusterMET> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<reco::PFClusterMET, std::allocator<reco::PFClusterMET> > > -------------------------------
void __edm__Wrapper_std__vector_reco__PFClusterMET_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_reco__PFClusterMET_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_reco__PFClusterMET_s__datamem_bld(&__edm__Wrapper_std__vector_reco__PFClusterMET_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_reco__PFClusterMET_s__funcmem_bld(&__edm__Wrapper_std__vector_reco__PFClusterMET_s__db_funcmem);
void __edm__Wrapper_std__vector_reco__PFClusterMET_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<reco::PFClusterMET> >"), typeid(::edm::Wrapper<std::vector<reco::PFClusterMET> >), sizeof(::edm::Wrapper<std::vector<reco::PFClusterMET> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3155, Reflex::Literal("edm::Wrapper<std::vector<reco::PFClusterMET> >::value_type"))
  .AddTypedef(type_3155, Reflex::Literal("edm::Wrapper<std::vector<reco::PFClusterMET> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_21084, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2898), Reflex::Literal("Wrapper"), constructor_21085, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_21086, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33977), Reflex::Literal("Wrapper"), constructor_21091, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4716, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_reco__PFClusterMET_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_reco__PFClusterMET_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<reco::PFClusterMET, std::allocator<reco::PFClusterMET> > > -------------------
void __edm__Wrapper_std__vector_reco__PFClusterMET_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1647, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_reco__PFClusterMET_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3155, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_reco__PFClusterMET_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<reco::PFClusterMET, std::allocator<reco::PFClusterMET> > > -------------------
void __edm__Wrapper_std__vector_reco__PFClusterMET_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33825), Reflex::Literal("product"), method_21087, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33825), Reflex::Literal("operator->"), operator_21088, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("productTypeInfo"), method_21089, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("typeInfo"), method_21090, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33978), Reflex::Literal("getInterface"), method_21092, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_19738, type_19832, type_33879), Reflex::Literal("fillView"), method_21093, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_364, type_10395), Reflex::Literal("setPtr"), method_21094, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_19897, type_19832), Reflex::Literal("fillPtrVector"), method_21095, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo"), method_21096, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isPresent"), method_21097, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo_"), method_21098, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<reco::PFClusterMET> -------------------------------
static void constructor_21105( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::PFClusterMET>();
  else ::new(mem) ::edm::Wrapper<reco::PFClusterMET>();
}

static void constructor_21106( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::PFClusterMET>(*(::std::auto_ptr<reco::PFClusterMET>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<reco::PFClusterMET>(*(::std::auto_ptr<reco::PFClusterMET>*)arg[0]);
}

static void destructor_21107(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<reco::PFClusterMET>*)o)->::edm::Wrapper<reco::PFClusterMET>::~Wrapper)();
}
static  void method_21108( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<reco::PFClusterMET>*)o)->product)());
  else   (((const ::edm::Wrapper<reco::PFClusterMET>*)o)->product)();
}

static  void operator_21109( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<reco::PFClusterMET>*)o)->operator->)());
  else   (((const ::edm::Wrapper<reco::PFClusterMET>*)o)->operator->)();
}

static  void method_21110( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<reco::PFClusterMET>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<reco::PFClusterMET>*)o)->productTypeInfo)();
}

static  void method_21111( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<reco::PFClusterMET>*)o)->typeInfo)();
  else   (((::edm::Wrapper<reco::PFClusterMET>*)o)->typeInfo)();
}

static void constructor_21112( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::PFClusterMET>((::reco::PFClusterMET*)arg[0]);
  else ::new(mem) ::edm::Wrapper<reco::PFClusterMET>((::reco::PFClusterMET*)arg[0]);
}

static  void method_21113( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<reco::PFClusterMET>*)o)->getInterface)());
  else   (((::edm::Wrapper<reco::PFClusterMET>*)o)->getInterface)();
}

static  void method_21114( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::PFClusterMET>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_21115( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::PFClusterMET>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_21116( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::PFClusterMET>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_21117( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<reco::PFClusterMET>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<reco::PFClusterMET>*)o)->dynamicTypeInfo)();
}

static  void method_21118( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<reco::PFClusterMET>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<reco::PFClusterMET>*)o)->isPresent)();
}

static  void method_21119( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<reco::PFClusterMET>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<reco::PFClusterMET>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4717( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::PFClusterMET> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::PFClusterMET> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::PFClusterMET> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::PFClusterMET> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::PFClusterMET> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<reco::PFClusterMET> -------------------------------
void __edm__Wrapper_reco__PFClusterMET__db_datamem(Reflex::Class*);
void __edm__Wrapper_reco__PFClusterMET__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_reco__PFClusterMET__datamem_bld(&__edm__Wrapper_reco__PFClusterMET__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_reco__PFClusterMET__funcmem_bld(&__edm__Wrapper_reco__PFClusterMET__db_funcmem);
void __edm__Wrapper_reco__PFClusterMET__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<reco::PFClusterMET>"), typeid(::edm::Wrapper<reco::PFClusterMET>), sizeof(::edm::Wrapper<reco::PFClusterMET>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_7916, Reflex::Literal("edm::Wrapper<reco::PFClusterMET>::value_type"))
  .AddTypedef(type_7916, Reflex::Literal("edm::Wrapper<reco::PFClusterMET>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_21105, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2899), Reflex::Literal("Wrapper"), constructor_21106, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_21107, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14210), Reflex::Literal("Wrapper"), constructor_21112, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4717, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_reco__PFClusterMET__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_reco__PFClusterMET__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<reco::PFClusterMET> -------------------
void __edm__Wrapper_reco__PFClusterMET__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1647, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_reco__PFClusterMET_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_7916, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_reco__PFClusterMET_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<reco::PFClusterMET> -------------------
void __edm__Wrapper_reco__PFClusterMET__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14212), Reflex::Literal("product"), method_21108, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14212), Reflex::Literal("operator->"), operator_21109, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("productTypeInfo"), method_21110, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("typeInfo"), method_21111, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33981), Reflex::Literal("getInterface"), method_21113, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_19738, type_19832, type_33879), Reflex::Literal("fillView"), method_21114, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_364, type_10395), Reflex::Literal("setPtr"), method_21115, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_19897, type_19832), Reflex::Literal("fillPtrVector"), method_21116, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo"), method_21117, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isPresent"), method_21118, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo_"), method_21119, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<reco::PFMET, std::allocator<reco::PFMET> > > -------------------------------
static void constructor_21126( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::PFMET> >();
  else ::new(mem) ::edm::Wrapper<std::vector<reco::PFMET> >();
}

static void constructor_21127( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::PFMET> >(*(::std::auto_ptr<std::vector<reco::PFMET> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<reco::PFMET> >(*(::std::auto_ptr<std::vector<reco::PFMET> >*)arg[0]);
}

static void destructor_21128(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<reco::PFMET> >*)o)->::edm::Wrapper<std::vector<reco::PFMET> >::~Wrapper)();
}
static  void method_21129( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<reco::PFMET> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<reco::PFMET> >*)o)->product)();
}

static  void operator_21130( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<reco::PFMET> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<reco::PFMET> >*)o)->operator->)();
}

static  void method_21131( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<reco::PFMET> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<reco::PFMET> >*)o)->productTypeInfo)();
}

static  void method_21132( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<reco::PFMET> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<reco::PFMET> >*)o)->typeInfo)();
}

static void constructor_21133( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::PFMET> >((::std::vector<reco::PFMET>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<reco::PFMET> >((::std::vector<reco::PFMET>*)arg[0]);
}

static  void method_21134( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<reco::PFMET> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<reco::PFMET> >*)o)->getInterface)();
}

static  void method_21135( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::PFMET> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_21136( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::PFMET> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_21137( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::PFMET> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_21138( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<reco::PFMET> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<reco::PFMET> >*)o)->dynamicTypeInfo)();
}

static  void method_21139( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<reco::PFMET> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<reco::PFMET> >*)o)->isPresent)();
}

static  void method_21140( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<reco::PFMET> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<reco::PFMET> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4718( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::PFMET> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::PFMET> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::PFMET> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::PFMET> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::PFMET> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<reco::PFMET, std::allocator<reco::PFMET> > > -------------------------------
void __edm__Wrapper_std__vector_reco__PFMET_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_reco__PFMET_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_reco__PFMET_s__datamem_bld(&__edm__Wrapper_std__vector_reco__PFMET_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_reco__PFMET_s__funcmem_bld(&__edm__Wrapper_std__vector_reco__PFMET_s__db_funcmem);
void __edm__Wrapper_std__vector_reco__PFMET_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<reco::PFMET> >"), typeid(::edm::Wrapper<std::vector<reco::PFMET> >), sizeof(::edm::Wrapper<std::vector<reco::PFMET> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3157, Reflex::Literal("edm::Wrapper<std::vector<reco::PFMET> >::value_type"))
  .AddTypedef(type_3157, Reflex::Literal("edm::Wrapper<std::vector<reco::PFMET> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_21126, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2900), Reflex::Literal("Wrapper"), constructor_21127, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_21128, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33984), Reflex::Literal("Wrapper"), constructor_21133, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4718, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_reco__PFMET_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_reco__PFMET_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<reco::PFMET, std::allocator<reco::PFMET> > > -------------------
void __edm__Wrapper_std__vector_reco__PFMET_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1647, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_reco__PFMET_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3157, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_reco__PFMET_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<reco::PFMET, std::allocator<reco::PFMET> > > -------------------
void __edm__Wrapper_std__vector_reco__PFMET_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33831), Reflex::Literal("product"), method_21129, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33831), Reflex::Literal("operator->"), operator_21130, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("productTypeInfo"), method_21131, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("typeInfo"), method_21132, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33985), Reflex::Literal("getInterface"), method_21134, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_19738, type_19832, type_33879), Reflex::Literal("fillView"), method_21135, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_364, type_10395), Reflex::Literal("setPtr"), method_21136, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_19897, type_19832), Reflex::Literal("fillPtrVector"), method_21137, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo"), method_21138, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isPresent"), method_21139, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo_"), method_21140, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<reco::PFMET> -------------------------------
static void constructor_21147( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::PFMET>();
  else ::new(mem) ::edm::Wrapper<reco::PFMET>();
}

static void constructor_21148( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::PFMET>(*(::std::auto_ptr<reco::PFMET>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<reco::PFMET>(*(::std::auto_ptr<reco::PFMET>*)arg[0]);
}

static void destructor_21149(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<reco::PFMET>*)o)->::edm::Wrapper<reco::PFMET>::~Wrapper)();
}
static  void method_21150( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<reco::PFMET>*)o)->product)());
  else   (((const ::edm::Wrapper<reco::PFMET>*)o)->product)();
}

static  void operator_21151( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<reco::PFMET>*)o)->operator->)());
  else   (((const ::edm::Wrapper<reco::PFMET>*)o)->operator->)();
}

static  void method_21152( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<reco::PFMET>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<reco::PFMET>*)o)->productTypeInfo)();
}

static  void method_21153( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<reco::PFMET>*)o)->typeInfo)();
  else   (((::edm::Wrapper<reco::PFMET>*)o)->typeInfo)();
}

static void constructor_21154( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::PFMET>((::reco::PFMET*)arg[0]);
  else ::new(mem) ::edm::Wrapper<reco::PFMET>((::reco::PFMET*)arg[0]);
}

static  void method_21155( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<reco::PFMET>*)o)->getInterface)());
  else   (((::edm::Wrapper<reco::PFMET>*)o)->getInterface)();
}

static  void method_21156( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::PFMET>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_21157( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::PFMET>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_21158( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::PFMET>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_21159( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<reco::PFMET>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<reco::PFMET>*)o)->dynamicTypeInfo)();
}

static  void method_21160( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<reco::PFMET>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<reco::PFMET>*)o)->isPresent)();
}

static  void method_21161( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<reco::PFMET>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<reco::PFMET>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4719( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::PFMET> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::PFMET> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::PFMET> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::PFMET> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::PFMET> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<reco::PFMET> -------------------------------
void __edm__Wrapper_reco__PFMET__db_datamem(Reflex::Class*);
void __edm__Wrapper_reco__PFMET__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_reco__PFMET__datamem_bld(&__edm__Wrapper_reco__PFMET__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_reco__PFMET__funcmem_bld(&__edm__Wrapper_reco__PFMET__db_funcmem);
void __edm__Wrapper_reco__PFMET__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<reco::PFMET>"), typeid(::edm::Wrapper<reco::PFMET>), sizeof(::edm::Wrapper<reco::PFMET>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_7918, Reflex::Literal("edm::Wrapper<reco::PFMET>::value_type"))
  .AddTypedef(type_7918, Reflex::Literal("edm::Wrapper<reco::PFMET>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_21147, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2901), Reflex::Literal("Wrapper"), constructor_21148, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_21149, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14337), Reflex::Literal("Wrapper"), constructor_21154, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4719, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_reco__PFMET__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_reco__PFMET__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<reco::PFMET> -------------------
void __edm__Wrapper_reco__PFMET__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1647, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_reco__PFMET_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_7918, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_reco__PFMET_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<reco::PFMET> -------------------
void __edm__Wrapper_reco__PFMET__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14339), Reflex::Literal("product"), method_21150, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14339), Reflex::Literal("operator->"), operator_21151, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("productTypeInfo"), method_21152, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("typeInfo"), method_21153, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33988), Reflex::Literal("getInterface"), method_21155, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_19738, type_19832, type_33879), Reflex::Literal("fillView"), method_21156, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_364, type_10395), Reflex::Literal("setPtr"), method_21157, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_19897, type_19832), Reflex::Literal("fillPtrVector"), method_21158, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo"), method_21159, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isPresent"), method_21160, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo_"), method_21161, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<reco::MET, std::allocator<reco::MET> > > -------------------------------
static void constructor_21168( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::MET> >();
  else ::new(mem) ::edm::Wrapper<std::vector<reco::MET> >();
}

static void constructor_21169( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::MET> >(*(::std::auto_ptr<std::vector<reco::MET> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<reco::MET> >(*(::std::auto_ptr<std::vector<reco::MET> >*)arg[0]);
}

static void destructor_21170(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<reco::MET> >*)o)->::edm::Wrapper<std::vector<reco::MET> >::~Wrapper)();
}
static  void method_21171( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<reco::MET> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<reco::MET> >*)o)->product)();
}

static  void operator_21172( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<reco::MET> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<reco::MET> >*)o)->operator->)();
}

static  void method_21173( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<reco::MET> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<reco::MET> >*)o)->productTypeInfo)();
}

static  void method_21174( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<reco::MET> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<reco::MET> >*)o)->typeInfo)();
}

static void constructor_21175( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::MET> >((::std::vector<reco::MET>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<reco::MET> >((::std::vector<reco::MET>*)arg[0]);
}

static  void method_21176( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<reco::MET> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<reco::MET> >*)o)->getInterface)();
}

static  void method_21177( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::MET> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_21178( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::MET> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_21179( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::MET> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_21180( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<reco::MET> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<reco::MET> >*)o)->dynamicTypeInfo)();
}

static  void method_21181( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<reco::MET> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<reco::MET> >*)o)->isPresent)();
}

static  void method_21182( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<reco::MET> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<reco::MET> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4720( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::MET> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::MET> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::MET> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::MET> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::MET> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<reco::MET, std::allocator<reco::MET> > > -------------------------------
void __edm__Wrapper_std__vector_reco__MET_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_reco__MET_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_reco__MET_s__datamem_bld(&__edm__Wrapper_std__vector_reco__MET_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_reco__MET_s__funcmem_bld(&__edm__Wrapper_std__vector_reco__MET_s__db_funcmem);
void __edm__Wrapper_std__vector_reco__MET_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<reco::MET> >"), typeid(::edm::Wrapper<std::vector<reco::MET> >), sizeof(::edm::Wrapper<std::vector<reco::MET> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3146, Reflex::Literal("edm::Wrapper<std::vector<reco::MET> >::value_type"))
  .AddTypedef(type_3146, Reflex::Literal("edm::Wrapper<std::vector<reco::MET> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_21168, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2906), Reflex::Literal("Wrapper"), constructor_21169, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_21170, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33991), Reflex::Literal("Wrapper"), constructor_21175, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4720, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_reco__MET_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_reco__MET_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<reco::MET, std::allocator<reco::MET> > > -------------------
void __edm__Wrapper_std__vector_reco__MET_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1647, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_reco__MET_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3146, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_reco__MET_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<reco::MET, std::allocator<reco::MET> > > -------------------
void __edm__Wrapper_std__vector_reco__MET_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33835), Reflex::Literal("product"), method_21171, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33835), Reflex::Literal("operator->"), operator_21172, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("productTypeInfo"), method_21173, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("typeInfo"), method_21174, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33992), Reflex::Literal("getInterface"), method_21176, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_19738, type_19832, type_33879), Reflex::Literal("fillView"), method_21177, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_364, type_10395), Reflex::Literal("setPtr"), method_21178, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_19897, type_19832), Reflex::Literal("fillPtrVector"), method_21179, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo"), method_21180, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isPresent"), method_21181, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo_"), method_21182, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<reco::MET> -------------------------------
static void constructor_21189( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::MET>();
  else ::new(mem) ::edm::Wrapper<reco::MET>();
}

static void constructor_21190( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::MET>(*(::std::auto_ptr<reco::MET>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<reco::MET>(*(::std::auto_ptr<reco::MET>*)arg[0]);
}

static void destructor_21191(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<reco::MET>*)o)->::edm::Wrapper<reco::MET>::~Wrapper)();
}
static  void method_21192( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<reco::MET>*)o)->product)());
  else   (((const ::edm::Wrapper<reco::MET>*)o)->product)();
}

static  void operator_21193( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<reco::MET>*)o)->operator->)());
  else   (((const ::edm::Wrapper<reco::MET>*)o)->operator->)();
}

static  void method_21194( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<reco::MET>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<reco::MET>*)o)->productTypeInfo)();
}

static  void method_21195( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<reco::MET>*)o)->typeInfo)();
  else   (((::edm::Wrapper<reco::MET>*)o)->typeInfo)();
}

static void constructor_21196( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::MET>((::reco::MET*)arg[0]);
  else ::new(mem) ::edm::Wrapper<reco::MET>((::reco::MET*)arg[0]);
}

static  void method_21197( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<reco::MET>*)o)->getInterface)());
  else   (((::edm::Wrapper<reco::MET>*)o)->getInterface)();
}

static  void method_21198( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::MET>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_21199( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::MET>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_21200( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::MET>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_21201( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<reco::MET>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<reco::MET>*)o)->dynamicTypeInfo)();
}

static  void method_21202( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<reco::MET>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<reco::MET>*)o)->isPresent)();
}

static  void method_21203( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<reco::MET>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<reco::MET>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4721( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::MET> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::MET> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::MET> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::MET> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::MET> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<reco::MET> -------------------------------
void __edm__Wrapper_reco__MET__db_datamem(Reflex::Class*);
void __edm__Wrapper_reco__MET__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_reco__MET__datamem_bld(&__edm__Wrapper_reco__MET__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_reco__MET__funcmem_bld(&__edm__Wrapper_reco__MET__db_funcmem);
void __edm__Wrapper_reco__MET__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<reco::MET>"), typeid(::edm::Wrapper<reco::MET>), sizeof(::edm::Wrapper<reco::MET>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_7952, Reflex::Literal("edm::Wrapper<reco::MET>::value_type"))
  .AddTypedef(type_7952, Reflex::Literal("edm::Wrapper<reco::MET>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_21189, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2907), Reflex::Literal("Wrapper"), constructor_21190, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_21191, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13629), Reflex::Literal("Wrapper"), constructor_21196, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4721, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_reco__MET__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_reco__MET__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<reco::MET> -------------------
void __edm__Wrapper_reco__MET__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1647, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_reco__MET_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_7952, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_reco__MET_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<reco::MET> -------------------
void __edm__Wrapper_reco__MET__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13631), Reflex::Literal("product"), method_21192, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13631), Reflex::Literal("operator->"), operator_21193, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("productTypeInfo"), method_21194, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("typeInfo"), method_21195, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33995), Reflex::Literal("getInterface"), method_21197, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_19738, type_19832, type_33879), Reflex::Literal("fillView"), method_21198, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_364, type_10395), Reflex::Literal("setPtr"), method_21199, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_19897, type_19832), Reflex::Literal("fillPtrVector"), method_21200, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo"), method_21201, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isPresent"), method_21202, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo_"), method_21203, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<reco::GenMET, std::allocator<reco::GenMET> > > -------------------------------
static void constructor_21210( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::GenMET> >();
  else ::new(mem) ::edm::Wrapper<std::vector<reco::GenMET> >();
}

static void constructor_21211( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::GenMET> >(*(::std::auto_ptr<std::vector<reco::GenMET> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<reco::GenMET> >(*(::std::auto_ptr<std::vector<reco::GenMET> >*)arg[0]);
}

static void destructor_21212(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<reco::GenMET> >*)o)->::edm::Wrapper<std::vector<reco::GenMET> >::~Wrapper)();
}
static  void method_21213( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<reco::GenMET> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<reco::GenMET> >*)o)->product)();
}

static  void operator_21214( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<reco::GenMET> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<reco::GenMET> >*)o)->operator->)();
}

static  void method_21215( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<reco::GenMET> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<reco::GenMET> >*)o)->productTypeInfo)();
}

static  void method_21216( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<reco::GenMET> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<reco::GenMET> >*)o)->typeInfo)();
}

static void constructor_21217( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::GenMET> >((::std::vector<reco::GenMET>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<reco::GenMET> >((::std::vector<reco::GenMET>*)arg[0]);
}

static  void method_21218( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<reco::GenMET> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<reco::GenMET> >*)o)->getInterface)();
}

static  void method_21219( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::GenMET> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_21220( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::GenMET> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_21221( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::GenMET> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_21222( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<reco::GenMET> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<reco::GenMET> >*)o)->dynamicTypeInfo)();
}

static  void method_21223( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<reco::GenMET> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<reco::GenMET> >*)o)->isPresent)();
}

static  void method_21224( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<reco::GenMET> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<reco::GenMET> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4722( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::GenMET> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::GenMET> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::GenMET> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::GenMET> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::GenMET> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<reco::GenMET, std::allocator<reco::GenMET> > > -------------------------------
void __edm__Wrapper_std__vector_reco__GenMET_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_reco__GenMET_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_reco__GenMET_s__datamem_bld(&__edm__Wrapper_std__vector_reco__GenMET_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_reco__GenMET_s__funcmem_bld(&__edm__Wrapper_std__vector_reco__GenMET_s__db_funcmem);
void __edm__Wrapper_std__vector_reco__GenMET_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<reco::GenMET> >"), typeid(::edm::Wrapper<std::vector<reco::GenMET> >), sizeof(::edm::Wrapper<std::vector<reco::GenMET> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3158, Reflex::Literal("edm::Wrapper<std::vector<reco::GenMET> >::value_type"))
  .AddTypedef(type_3158, Reflex::Literal("edm::Wrapper<std::vector<reco::GenMET> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_21210, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2902), Reflex::Literal("Wrapper"), constructor_21211, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_21212, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33998), Reflex::Literal("Wrapper"), constructor_21217, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4722, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_reco__GenMET_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_reco__GenMET_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<reco::GenMET, std::allocator<reco::GenMET> > > -------------------
void __edm__Wrapper_std__vector_reco__GenMET_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1647, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_reco__GenMET_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3158, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_reco__GenMET_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<reco::GenMET, std::allocator<reco::GenMET> > > -------------------
void __edm__Wrapper_std__vector_reco__GenMET_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33841), Reflex::Literal("product"), method_21213, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33841), Reflex::Literal("operator->"), operator_21214, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("productTypeInfo"), method_21215, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("typeInfo"), method_21216, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33999), Reflex::Literal("getInterface"), method_21218, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_19738, type_19832, type_33879), Reflex::Literal("fillView"), method_21219, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_364, type_10395), Reflex::Literal("setPtr"), method_21220, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_19897, type_19832), Reflex::Literal("fillPtrVector"), method_21221, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo"), method_21222, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isPresent"), method_21223, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo_"), method_21224, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<reco::GenMET> -------------------------------
static void constructor_21231( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::GenMET>();
  else ::new(mem) ::edm::Wrapper<reco::GenMET>();
}

static void constructor_21232( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::GenMET>(*(::std::auto_ptr<reco::GenMET>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<reco::GenMET>(*(::std::auto_ptr<reco::GenMET>*)arg[0]);
}

static void destructor_21233(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<reco::GenMET>*)o)->::edm::Wrapper<reco::GenMET>::~Wrapper)();
}
static  void method_21234( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<reco::GenMET>*)o)->product)());
  else   (((const ::edm::Wrapper<reco::GenMET>*)o)->product)();
}

static  void operator_21235( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<reco::GenMET>*)o)->operator->)());
  else   (((const ::edm::Wrapper<reco::GenMET>*)o)->operator->)();
}

static  void method_21236( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<reco::GenMET>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<reco::GenMET>*)o)->productTypeInfo)();
}

static  void method_21237( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<reco::GenMET>*)o)->typeInfo)();
  else   (((::edm::Wrapper<reco::GenMET>*)o)->typeInfo)();
}

static void constructor_21238( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::GenMET>((::reco::GenMET*)arg[0]);
  else ::new(mem) ::edm::Wrapper<reco::GenMET>((::reco::GenMET*)arg[0]);
}

static  void method_21239( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<reco::GenMET>*)o)->getInterface)());
  else   (((::edm::Wrapper<reco::GenMET>*)o)->getInterface)();
}

static  void method_21240( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::GenMET>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_21241( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::GenMET>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_21242( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::GenMET>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_21243( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<reco::GenMET>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<reco::GenMET>*)o)->dynamicTypeInfo)();
}

static  void method_21244( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<reco::GenMET>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<reco::GenMET>*)o)->isPresent)();
}

static  void method_21245( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<reco::GenMET>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<reco::GenMET>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4723( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::GenMET> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::GenMET> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::GenMET> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::GenMET> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::GenMET> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<reco::GenMET> -------------------------------
void __edm__Wrapper_reco__GenMET__db_datamem(Reflex::Class*);
void __edm__Wrapper_reco__GenMET__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_reco__GenMET__datamem_bld(&__edm__Wrapper_reco__GenMET__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_reco__GenMET__funcmem_bld(&__edm__Wrapper_reco__GenMET__db_funcmem);
void __edm__Wrapper_reco__GenMET__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<reco::GenMET>"), typeid(::edm::Wrapper<reco::GenMET>), sizeof(::edm::Wrapper<reco::GenMET>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_7970, Reflex::Literal("edm::Wrapper<reco::GenMET>::value_type"))
  .AddTypedef(type_7970, Reflex::Literal("edm::Wrapper<reco::GenMET>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_21231, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2903), Reflex::Literal("Wrapper"), constructor_21232, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_21233, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14402), Reflex::Literal("Wrapper"), constructor_21238, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4723, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_reco__GenMET__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_reco__GenMET__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<reco::GenMET> -------------------
void __edm__Wrapper_reco__GenMET__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1647, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_reco__GenMET_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_7970, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_reco__GenMET_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<reco::GenMET> -------------------
void __edm__Wrapper_reco__GenMET__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14404), Reflex::Literal("product"), method_21234, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14404), Reflex::Literal("operator->"), operator_21235, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("productTypeInfo"), method_21236, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("typeInfo"), method_21237, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_34002), Reflex::Literal("getInterface"), method_21239, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_19738, type_19832, type_33879), Reflex::Literal("fillView"), method_21240, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_364, type_10395), Reflex::Literal("setPtr"), method_21241, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_19897, type_19832), Reflex::Literal("fillPtrVector"), method_21242, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo"), method_21243, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isPresent"), method_21244, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo_"), method_21245, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> > > -------------------------------
static void constructor_21252( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::CaloMET> >();
  else ::new(mem) ::edm::Wrapper<std::vector<reco::CaloMET> >();
}

static void constructor_21253( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::CaloMET> >(*(::std::auto_ptr<std::vector<reco::CaloMET> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<reco::CaloMET> >(*(::std::auto_ptr<std::vector<reco::CaloMET> >*)arg[0]);
}

static void destructor_21254(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<reco::CaloMET> >*)o)->::edm::Wrapper<std::vector<reco::CaloMET> >::~Wrapper)();
}
static  void method_21255( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<reco::CaloMET> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<reco::CaloMET> >*)o)->product)();
}

static  void operator_21256( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<reco::CaloMET> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<reco::CaloMET> >*)o)->operator->)();
}

static  void method_21257( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<reco::CaloMET> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<reco::CaloMET> >*)o)->productTypeInfo)();
}

static  void method_21258( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<reco::CaloMET> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<reco::CaloMET> >*)o)->typeInfo)();
}

static void constructor_21259( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::CaloMET> >((::std::vector<reco::CaloMET>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<reco::CaloMET> >((::std::vector<reco::CaloMET>*)arg[0]);
}

static  void method_21260( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<reco::CaloMET> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<reco::CaloMET> >*)o)->getInterface)();
}

static  void method_21261( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::CaloMET> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_21262( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::CaloMET> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_21263( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::CaloMET> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_21264( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<reco::CaloMET> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<reco::CaloMET> >*)o)->dynamicTypeInfo)();
}

static  void method_21265( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<reco::CaloMET> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<reco::CaloMET> >*)o)->isPresent)();
}

static  void method_21266( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<reco::CaloMET> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<reco::CaloMET> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4724( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::CaloMET> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::CaloMET> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::CaloMET> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::CaloMET> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::CaloMET> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> > > -------------------------------
void __edm__Wrapper_std__vector_reco__CaloMET_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_reco__CaloMET_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_reco__CaloMET_s__datamem_bld(&__edm__Wrapper_std__vector_reco__CaloMET_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_reco__CaloMET_s__funcmem_bld(&__edm__Wrapper_std__vector_reco__CaloMET_s__db_funcmem);
void __edm__Wrapper_std__vector_reco__CaloMET_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<reco::CaloMET> >"), typeid(::edm::Wrapper<std::vector<reco::CaloMET> >), sizeof(::edm::Wrapper<std::vector<reco::CaloMET> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3148, Reflex::Literal("edm::Wrapper<std::vector<reco::CaloMET> >::value_type"))
  .AddTypedef(type_3148, Reflex::Literal("edm::Wrapper<std::vector<reco::CaloMET> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_21252, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2904), Reflex::Literal("Wrapper"), constructor_21253, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_21254, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34005), Reflex::Literal("Wrapper"), constructor_21259, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4724, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_reco__CaloMET_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_reco__CaloMET_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> > > -------------------
void __edm__Wrapper_std__vector_reco__CaloMET_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1647, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_reco__CaloMET_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3148, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_reco__CaloMET_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> > > -------------------
void __edm__Wrapper_std__vector_reco__CaloMET_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33845), Reflex::Literal("product"), method_21255, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33845), Reflex::Literal("operator->"), operator_21256, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("productTypeInfo"), method_21257, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("typeInfo"), method_21258, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_34006), Reflex::Literal("getInterface"), method_21260, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_19738, type_19832, type_33879), Reflex::Literal("fillView"), method_21261, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_364, type_10395), Reflex::Literal("setPtr"), method_21262, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_19897, type_19832), Reflex::Literal("fillPtrVector"), method_21263, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo"), method_21264, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isPresent"), method_21265, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo_"), method_21266, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<reco::CaloMET> -------------------------------
static void constructor_21273( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::CaloMET>();
  else ::new(mem) ::edm::Wrapper<reco::CaloMET>();
}

static void constructor_21274( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::CaloMET>(*(::std::auto_ptr<reco::CaloMET>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<reco::CaloMET>(*(::std::auto_ptr<reco::CaloMET>*)arg[0]);
}

static void destructor_21275(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<reco::CaloMET>*)o)->::edm::Wrapper<reco::CaloMET>::~Wrapper)();
}
static  void method_21276( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<reco::CaloMET>*)o)->product)());
  else   (((const ::edm::Wrapper<reco::CaloMET>*)o)->product)();
}

static  void operator_21277( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<reco::CaloMET>*)o)->operator->)());
  else   (((const ::edm::Wrapper<reco::CaloMET>*)o)->operator->)();
}

static  void method_21278( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<reco::CaloMET>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<reco::CaloMET>*)o)->productTypeInfo)();
}

static  void method_21279( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<reco::CaloMET>*)o)->typeInfo)();
  else   (((::edm::Wrapper<reco::CaloMET>*)o)->typeInfo)();
}

static void constructor_21280( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::CaloMET>((::reco::CaloMET*)arg[0]);
  else ::new(mem) ::edm::Wrapper<reco::CaloMET>((::reco::CaloMET*)arg[0]);
}

static  void method_21281( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<reco::CaloMET>*)o)->getInterface)());
  else   (((::edm::Wrapper<reco::CaloMET>*)o)->getInterface)();
}

static  void method_21282( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::CaloMET>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_21283( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::CaloMET>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_21284( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::CaloMET>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_21285( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<reco::CaloMET>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<reco::CaloMET>*)o)->dynamicTypeInfo)();
}

static  void method_21286( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<reco::CaloMET>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<reco::CaloMET>*)o)->isPresent)();
}

static  void method_21287( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<reco::CaloMET>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<reco::CaloMET>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4725( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::CaloMET> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::CaloMET> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::CaloMET> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::CaloMET> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::CaloMET> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<reco::CaloMET> -------------------------------
void __edm__Wrapper_reco__CaloMET__db_datamem(Reflex::Class*);
void __edm__Wrapper_reco__CaloMET__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_reco__CaloMET__datamem_bld(&__edm__Wrapper_reco__CaloMET__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_reco__CaloMET__funcmem_bld(&__edm__Wrapper_reco__CaloMET__db_funcmem);
void __edm__Wrapper_reco__CaloMET__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<reco::CaloMET>"), typeid(::edm::Wrapper<reco::CaloMET>), sizeof(::edm::Wrapper<reco::CaloMET>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_8011, Reflex::Literal("edm::Wrapper<reco::CaloMET>::value_type"))
  .AddTypedef(type_8011, Reflex::Literal("edm::Wrapper<reco::CaloMET>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_21273, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2905), Reflex::Literal("Wrapper"), constructor_21274, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_21275, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13759), Reflex::Literal("Wrapper"), constructor_21280, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4725, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_reco__CaloMET__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_reco__CaloMET__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<reco::CaloMET> -------------------
void __edm__Wrapper_reco__CaloMET__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1647, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_reco__CaloMET_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_8011, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_reco__CaloMET_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<reco::CaloMET> -------------------
void __edm__Wrapper_reco__CaloMET__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13761), Reflex::Literal("product"), method_21276, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13761), Reflex::Literal("operator->"), operator_21277, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("productTypeInfo"), method_21278, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("typeInfo"), method_21279, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_34009), Reflex::Literal("getInterface"), method_21281, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_19738, type_19832, type_33879), Reflex::Literal("fillView"), method_21282, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_364, type_10395), Reflex::Literal("setPtr"), method_21283, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_19897, type_19832), Reflex::Literal("fillPtrVector"), method_21284, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo"), method_21285, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isPresent"), method_21286, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo_"), method_21287, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class RefProd<std::vector<reco::PFClusterMET, std::allocator<reco::PFClusterMET> > > -------------------------------
static  void operator_21681( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefProd<std::vector<reco::PFClusterMET> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<reco::PFClusterMET> >*)arg[0]);
  else   (((::edm::RefProd<std::vector<reco::PFClusterMET> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<reco::PFClusterMET> >*)arg[0]);
}

static void constructor_21682( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::PFClusterMET> >(*(const ::edm::RefProd<std::vector<reco::PFClusterMET> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::PFClusterMET> >(*(const ::edm::RefProd<std::vector<reco::PFClusterMET> >*)arg[0]);
}

static void constructor_21683( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::PFClusterMET> >();
  else ::new(mem) ::edm::RefProd<std::vector<reco::PFClusterMET> >();
}

static void constructor_21684( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::PFClusterMET> >(*(const ::edm::Handle<std::vector<reco::PFClusterMET> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::PFClusterMET> >(*(const ::edm::Handle<std::vector<reco::PFClusterMET> >*)arg[0]);
}

static void constructor_21685( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::PFClusterMET> >(*(const ::edm::OrphanHandle<std::vector<reco::PFClusterMET> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::PFClusterMET> >(*(const ::edm::OrphanHandle<std::vector<reco::PFClusterMET> >*)arg[0]);
}

static void constructor_21686( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::PFClusterMET> >((const ::std::vector<reco::PFClusterMET>*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::PFClusterMET> >((const ::std::vector<reco::PFClusterMET>*)arg[0]);
}

static void constructor_21687( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::PFClusterMET> >(*(const ::edm::TestHandle<std::vector<reco::PFClusterMET> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::PFClusterMET> >(*(const ::edm::TestHandle<std::vector<reco::PFClusterMET> >*)arg[0]);
}

static void constructor_21688( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::PFClusterMET> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::PFClusterMET> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
}

static void destructor_21689(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefProd<std::vector<reco::PFClusterMET> >*)o)->::edm::RefProd<std::vector<reco::PFClusterMET> >::~RefProd)();
}
static  void operator_21690( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<reco::PFClusterMET> >*)o)->operator*)();
  else   (((const ::edm::RefProd<std::vector<reco::PFClusterMET> >*)o)->operator*)();
}

static  void operator_21691( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::PFClusterMET> >*)o)->operator->)());
  else   (((const ::edm::RefProd<std::vector<reco::PFClusterMET> >*)o)->operator->)();
}

static  void method_21692( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::PFClusterMET> >*)o)->get)());
  else   (((const ::edm::RefProd<std::vector<reco::PFClusterMET> >*)o)->get)();
}

static  void method_21693( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::PFClusterMET> >*)o)->product)());
  else   (((const ::edm::RefProd<std::vector<reco::PFClusterMET> >*)o)->product)();
}

static  void method_21694( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<reco::PFClusterMET> >*)o)->refCore)();
  else   (((const ::edm::RefProd<std::vector<reco::PFClusterMET> >*)o)->refCore)();
}

static  void method_21695( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::PFClusterMET> >*)o)->isNull)());
  else   (((const ::edm::RefProd<std::vector<reco::PFClusterMET> >*)o)->isNull)();
}

static  void method_21696( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::PFClusterMET> >*)o)->isNonnull)());
  else   (((const ::edm::RefProd<std::vector<reco::PFClusterMET> >*)o)->isNonnull)();
}

static  void operator_21697( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::PFClusterMET> >*)o)->operator!)());
  else   (((const ::edm::RefProd<std::vector<reco::PFClusterMET> >*)o)->operator!)();
}

static  void method_21698( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefProd<std::vector<reco::PFClusterMET> >*)o)->id)());
  else   (((const ::edm::RefProd<std::vector<reco::PFClusterMET> >*)o)->id)();
}

static  void method_21699( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::PFClusterMET> >*)o)->productGetter)());
  else   (((const ::edm::RefProd<std::vector<reco::PFClusterMET> >*)o)->productGetter)();
}

static  void method_21700( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::PFClusterMET> >*)o)->hasCache)());
  else   (((const ::edm::RefProd<std::vector<reco::PFClusterMET> >*)o)->hasCache)();
}

static  void method_21701( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::PFClusterMET> >*)o)->hasProductCache)());
  else   (((const ::edm::RefProd<std::vector<reco::PFClusterMET> >*)o)->hasProductCache)();
}

static  void method_21702( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::PFClusterMET> >*)o)->isAvailable)());
  else   (((const ::edm::RefProd<std::vector<reco::PFClusterMET> >*)o)->isAvailable)();
}

static  void method_21703( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::PFClusterMET> >*)o)->isTransient)());
  else   (((const ::edm::RefProd<std::vector<reco::PFClusterMET> >*)o)->isTransient)();
}

static  void method_21704( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefProd<std::vector<reco::PFClusterMET> >*)o)->swap)(*(::edm::RefProd<std::vector<reco::PFClusterMET> >*)arg[0]);
}

static  void method_21705( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefProd<std::vector<reco::PFClusterMET> >*)o)->Class_Version)());
  else   (((::edm::RefProd<std::vector<reco::PFClusterMET> >*)o)->Class_Version)();
}

static void method_newdel_4883( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::PFClusterMET> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::PFClusterMET> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::PFClusterMET> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::PFClusterMET> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::PFClusterMET> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefProd<std::vector<reco::PFClusterMET, std::allocator<reco::PFClusterMET> > > -------------------------------
void __edm__RefProd_std__vector_reco__PFClusterMET_s__db_datamem(Reflex::Class*);
void __edm__RefProd_std__vector_reco__PFClusterMET_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_reco__PFClusterMET_s__datamem_bld(&__edm__RefProd_std__vector_reco__PFClusterMET_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_reco__PFClusterMET_s__funcmem_bld(&__edm__RefProd_std__vector_reco__PFClusterMET_s__db_funcmem);
void __edm__RefProd_std__vector_reco__PFClusterMET_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefProd<std::vector<reco::PFClusterMET> >"), typeid(::edm::RefProd<std::vector<reco::PFClusterMET> >), sizeof(::edm::RefProd<std::vector<reco::PFClusterMET> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefProd<std::vector<reco::PFClusterMET> >::Class_Version())
  .AddTypedef(type_3155, Reflex::Literal("edm::RefProd<std::vector<reco::PFClusterMET> >::product_type"))
  .AddTypedef(type_3155, Reflex::Literal("edm::RefProd<std::vector<reco::PFClusterMET> >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_34345, type_34346), Reflex::Literal("operator="), operator_21681, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34346), Reflex::Literal("RefProd"), constructor_21682, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefProd"), constructor_21683, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34347), Reflex::Literal("RefProd"), constructor_21684, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34348), Reflex::Literal("RefProd"), constructor_21685, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33825), Reflex::Literal("RefProd"), constructor_21686, 0, "iProduct", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34349), Reflex::Literal("RefProd"), constructor_21687, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19738, type_19828), Reflex::Literal("RefProd"), constructor_21688, 0, "productID;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefProd"), destructor_21689, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4883, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefProd_std__vector_reco__PFClusterMET_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefProd_std__vector_reco__PFClusterMET_s__funcmem_bld);
}

//------Delayed data member builder for class RefProd<std::vector<reco::PFClusterMET, std::allocator<reco::PFClusterMET> > > -------------------
void __edm__RefProd_std__vector_reco__PFClusterMET_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4868, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefProd_std__vector_reco__PFClusterMET_s_, product_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefProd<std::vector<reco::PFClusterMET, std::allocator<reco::PFClusterMET> > > -------------------
void __edm__RefProd_std__vector_reco__PFClusterMET_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23182), Reflex::Literal("operator*"), operator_21690, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33825), Reflex::Literal("operator->"), operator_21691, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33825), Reflex::Literal("get"), method_21692, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33825), Reflex::Literal("product"), method_21693, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21396), Reflex::Literal("refCore"), method_21694, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isNull"), method_21695, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isNonnull"), method_21696, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("operator!"), operator_21697, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4866), Reflex::Literal("id"), method_21698, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19828), Reflex::Literal("productGetter"), method_21699, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("hasCache"), method_21700, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("hasProductCache"), method_21701, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isAvailable"), method_21702, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isTransient"), method_21703, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_34345), Reflex::Literal("swap"), method_21704, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_192), Reflex::Literal("Class_Version"), method_21705, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefProd<std::vector<reco::PFMET, std::allocator<reco::PFMET> > > -------------------------------
static  void operator_21710( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefProd<std::vector<reco::PFMET> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<reco::PFMET> >*)arg[0]);
  else   (((::edm::RefProd<std::vector<reco::PFMET> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<reco::PFMET> >*)arg[0]);
}

static void constructor_21711( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::PFMET> >(*(const ::edm::RefProd<std::vector<reco::PFMET> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::PFMET> >(*(const ::edm::RefProd<std::vector<reco::PFMET> >*)arg[0]);
}

static void constructor_21712( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::PFMET> >();
  else ::new(mem) ::edm::RefProd<std::vector<reco::PFMET> >();
}

static void constructor_21713( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::PFMET> >(*(const ::edm::Handle<std::vector<reco::PFMET> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::PFMET> >(*(const ::edm::Handle<std::vector<reco::PFMET> >*)arg[0]);
}

static void constructor_21714( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::PFMET> >(*(const ::edm::OrphanHandle<std::vector<reco::PFMET> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::PFMET> >(*(const ::edm::OrphanHandle<std::vector<reco::PFMET> >*)arg[0]);
}

static void constructor_21715( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::PFMET> >((const ::std::vector<reco::PFMET>*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::PFMET> >((const ::std::vector<reco::PFMET>*)arg[0]);
}

static void constructor_21716( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::PFMET> >(*(const ::edm::TestHandle<std::vector<reco::PFMET> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::PFMET> >(*(const ::edm::TestHandle<std::vector<reco::PFMET> >*)arg[0]);
}

static void constructor_21717( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::PFMET> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::PFMET> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
}

static void destructor_21718(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefProd<std::vector<reco::PFMET> >*)o)->::edm::RefProd<std::vector<reco::PFMET> >::~RefProd)();
}
static  void operator_21719( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<reco::PFMET> >*)o)->operator*)();
  else   (((const ::edm::RefProd<std::vector<reco::PFMET> >*)o)->operator*)();
}

static  void operator_21720( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::PFMET> >*)o)->operator->)());
  else   (((const ::edm::RefProd<std::vector<reco::PFMET> >*)o)->operator->)();
}

static  void method_21721( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::PFMET> >*)o)->get)());
  else   (((const ::edm::RefProd<std::vector<reco::PFMET> >*)o)->get)();
}

static  void method_21722( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::PFMET> >*)o)->product)());
  else   (((const ::edm::RefProd<std::vector<reco::PFMET> >*)o)->product)();
}

static  void method_21723( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<reco::PFMET> >*)o)->refCore)();
  else   (((const ::edm::RefProd<std::vector<reco::PFMET> >*)o)->refCore)();
}

static  void method_21724( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::PFMET> >*)o)->isNull)());
  else   (((const ::edm::RefProd<std::vector<reco::PFMET> >*)o)->isNull)();
}

static  void method_21725( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::PFMET> >*)o)->isNonnull)());
  else   (((const ::edm::RefProd<std::vector<reco::PFMET> >*)o)->isNonnull)();
}

static  void operator_21726( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::PFMET> >*)o)->operator!)());
  else   (((const ::edm::RefProd<std::vector<reco::PFMET> >*)o)->operator!)();
}

static  void method_21727( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefProd<std::vector<reco::PFMET> >*)o)->id)());
  else   (((const ::edm::RefProd<std::vector<reco::PFMET> >*)o)->id)();
}

static  void method_21728( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::PFMET> >*)o)->productGetter)());
  else   (((const ::edm::RefProd<std::vector<reco::PFMET> >*)o)->productGetter)();
}

static  void method_21729( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::PFMET> >*)o)->hasCache)());
  else   (((const ::edm::RefProd<std::vector<reco::PFMET> >*)o)->hasCache)();
}

static  void method_21730( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::PFMET> >*)o)->hasProductCache)());
  else   (((const ::edm::RefProd<std::vector<reco::PFMET> >*)o)->hasProductCache)();
}

static  void method_21731( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::PFMET> >*)o)->isAvailable)());
  else   (((const ::edm::RefProd<std::vector<reco::PFMET> >*)o)->isAvailable)();
}

static  void method_21732( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::PFMET> >*)o)->isTransient)());
  else   (((const ::edm::RefProd<std::vector<reco::PFMET> >*)o)->isTransient)();
}

static  void method_21733( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefProd<std::vector<reco::PFMET> >*)o)->swap)(*(::edm::RefProd<std::vector<reco::PFMET> >*)arg[0]);
}

static  void method_21734( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefProd<std::vector<reco::PFMET> >*)o)->Class_Version)());
  else   (((::edm::RefProd<std::vector<reco::PFMET> >*)o)->Class_Version)();
}

static void method_newdel_4884( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::PFMET> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::PFMET> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::PFMET> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::PFMET> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::PFMET> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefProd<std::vector<reco::PFMET, std::allocator<reco::PFMET> > > -------------------------------
void __edm__RefProd_std__vector_reco__PFMET_s__db_datamem(Reflex::Class*);
void __edm__RefProd_std__vector_reco__PFMET_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_reco__PFMET_s__datamem_bld(&__edm__RefProd_std__vector_reco__PFMET_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_reco__PFMET_s__funcmem_bld(&__edm__RefProd_std__vector_reco__PFMET_s__db_funcmem);
void __edm__RefProd_std__vector_reco__PFMET_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefProd<std::vector<reco::PFMET> >"), typeid(::edm::RefProd<std::vector<reco::PFMET> >), sizeof(::edm::RefProd<std::vector<reco::PFMET> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefProd<std::vector<reco::PFMET> >::Class_Version())
  .AddTypedef(type_3157, Reflex::Literal("edm::RefProd<std::vector<reco::PFMET> >::product_type"))
  .AddTypedef(type_3157, Reflex::Literal("edm::RefProd<std::vector<reco::PFMET> >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_34350, type_34351), Reflex::Literal("operator="), operator_21710, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34351), Reflex::Literal("RefProd"), constructor_21711, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefProd"), constructor_21712, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34352), Reflex::Literal("RefProd"), constructor_21713, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34353), Reflex::Literal("RefProd"), constructor_21714, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33831), Reflex::Literal("RefProd"), constructor_21715, 0, "iProduct", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34354), Reflex::Literal("RefProd"), constructor_21716, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19738, type_19828), Reflex::Literal("RefProd"), constructor_21717, 0, "productID;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefProd"), destructor_21718, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4884, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefProd_std__vector_reco__PFMET_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefProd_std__vector_reco__PFMET_s__funcmem_bld);
}

//------Delayed data member builder for class RefProd<std::vector<reco::PFMET, std::allocator<reco::PFMET> > > -------------------
void __edm__RefProd_std__vector_reco__PFMET_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4868, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefProd_std__vector_reco__PFMET_s_, product_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefProd<std::vector<reco::PFMET, std::allocator<reco::PFMET> > > -------------------
void __edm__RefProd_std__vector_reco__PFMET_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23193), Reflex::Literal("operator*"), operator_21719, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33831), Reflex::Literal("operator->"), operator_21720, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33831), Reflex::Literal("get"), method_21721, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33831), Reflex::Literal("product"), method_21722, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21396), Reflex::Literal("refCore"), method_21723, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isNull"), method_21724, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isNonnull"), method_21725, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("operator!"), operator_21726, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4866), Reflex::Literal("id"), method_21727, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19828), Reflex::Literal("productGetter"), method_21728, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("hasCache"), method_21729, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("hasProductCache"), method_21730, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isAvailable"), method_21731, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isTransient"), method_21732, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_34350), Reflex::Literal("swap"), method_21733, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_192), Reflex::Literal("Class_Version"), method_21734, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefProd<std::vector<reco::MET, std::allocator<reco::MET> > > -------------------------------
static  void operator_21739( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefProd<std::vector<reco::MET> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<reco::MET> >*)arg[0]);
  else   (((::edm::RefProd<std::vector<reco::MET> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<reco::MET> >*)arg[0]);
}

static void constructor_21740( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::MET> >(*(const ::edm::RefProd<std::vector<reco::MET> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::MET> >(*(const ::edm::RefProd<std::vector<reco::MET> >*)arg[0]);
}

static void constructor_21741( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::MET> >();
  else ::new(mem) ::edm::RefProd<std::vector<reco::MET> >();
}

static void constructor_21742( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::MET> >(*(const ::edm::Handle<std::vector<reco::MET> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::MET> >(*(const ::edm::Handle<std::vector<reco::MET> >*)arg[0]);
}

static void constructor_21743( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::MET> >(*(const ::edm::OrphanHandle<std::vector<reco::MET> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::MET> >(*(const ::edm::OrphanHandle<std::vector<reco::MET> >*)arg[0]);
}

static void constructor_21744( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::MET> >((const ::std::vector<reco::MET>*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::MET> >((const ::std::vector<reco::MET>*)arg[0]);
}

static void constructor_21745( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::MET> >(*(const ::edm::TestHandle<std::vector<reco::MET> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::MET> >(*(const ::edm::TestHandle<std::vector<reco::MET> >*)arg[0]);
}

static void constructor_21746( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::MET> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::MET> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
}

static void destructor_21747(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefProd<std::vector<reco::MET> >*)o)->::edm::RefProd<std::vector<reco::MET> >::~RefProd)();
}
static  void operator_21748( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<reco::MET> >*)o)->operator*)();
  else   (((const ::edm::RefProd<std::vector<reco::MET> >*)o)->operator*)();
}

static  void operator_21749( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::MET> >*)o)->operator->)());
  else   (((const ::edm::RefProd<std::vector<reco::MET> >*)o)->operator->)();
}

static  void method_21750( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::MET> >*)o)->get)());
  else   (((const ::edm::RefProd<std::vector<reco::MET> >*)o)->get)();
}

static  void method_21751( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::MET> >*)o)->product)());
  else   (((const ::edm::RefProd<std::vector<reco::MET> >*)o)->product)();
}

static  void method_21752( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<reco::MET> >*)o)->refCore)();
  else   (((const ::edm::RefProd<std::vector<reco::MET> >*)o)->refCore)();
}

static  void method_21753( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::MET> >*)o)->isNull)());
  else   (((const ::edm::RefProd<std::vector<reco::MET> >*)o)->isNull)();
}

static  void method_21754( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::MET> >*)o)->isNonnull)());
  else   (((const ::edm::RefProd<std::vector<reco::MET> >*)o)->isNonnull)();
}

static  void operator_21755( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::MET> >*)o)->operator!)());
  else   (((const ::edm::RefProd<std::vector<reco::MET> >*)o)->operator!)();
}

static  void method_21756( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefProd<std::vector<reco::MET> >*)o)->id)());
  else   (((const ::edm::RefProd<std::vector<reco::MET> >*)o)->id)();
}

static  void method_21757( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::MET> >*)o)->productGetter)());
  else   (((const ::edm::RefProd<std::vector<reco::MET> >*)o)->productGetter)();
}

static  void method_21758( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::MET> >*)o)->hasCache)());
  else   (((const ::edm::RefProd<std::vector<reco::MET> >*)o)->hasCache)();
}

static  void method_21759( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::MET> >*)o)->hasProductCache)());
  else   (((const ::edm::RefProd<std::vector<reco::MET> >*)o)->hasProductCache)();
}

static  void method_21760( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::MET> >*)o)->isAvailable)());
  else   (((const ::edm::RefProd<std::vector<reco::MET> >*)o)->isAvailable)();
}

static  void method_21761( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::MET> >*)o)->isTransient)());
  else   (((const ::edm::RefProd<std::vector<reco::MET> >*)o)->isTransient)();
}

static  void method_21762( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefProd<std::vector<reco::MET> >*)o)->swap)(*(::edm::RefProd<std::vector<reco::MET> >*)arg[0]);
}

static  void method_21763( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefProd<std::vector<reco::MET> >*)o)->Class_Version)());
  else   (((::edm::RefProd<std::vector<reco::MET> >*)o)->Class_Version)();
}

static void method_newdel_4885( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::MET> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::MET> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::MET> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::MET> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::MET> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefProd<std::vector<reco::MET, std::allocator<reco::MET> > > -------------------------------
void __edm__RefProd_std__vector_reco__MET_s__db_datamem(Reflex::Class*);
void __edm__RefProd_std__vector_reco__MET_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_reco__MET_s__datamem_bld(&__edm__RefProd_std__vector_reco__MET_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_reco__MET_s__funcmem_bld(&__edm__RefProd_std__vector_reco__MET_s__db_funcmem);
void __edm__RefProd_std__vector_reco__MET_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefProd<std::vector<reco::MET> >"), typeid(::edm::RefProd<std::vector<reco::MET> >), sizeof(::edm::RefProd<std::vector<reco::MET> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefProd<std::vector<reco::MET> >::Class_Version())
  .AddTypedef(type_3146, Reflex::Literal("edm::RefProd<std::vector<reco::MET> >::product_type"))
  .AddTypedef(type_3146, Reflex::Literal("edm::RefProd<std::vector<reco::MET> >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_34355, type_34356), Reflex::Literal("operator="), operator_21739, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34356), Reflex::Literal("RefProd"), constructor_21740, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefProd"), constructor_21741, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34357), Reflex::Literal("RefProd"), constructor_21742, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34358), Reflex::Literal("RefProd"), constructor_21743, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33835), Reflex::Literal("RefProd"), constructor_21744, 0, "iProduct", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34359), Reflex::Literal("RefProd"), constructor_21745, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19738, type_19828), Reflex::Literal("RefProd"), constructor_21746, 0, "productID;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefProd"), destructor_21747, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4885, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefProd_std__vector_reco__MET_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefProd_std__vector_reco__MET_s__funcmem_bld);
}

//------Delayed data member builder for class RefProd<std::vector<reco::MET, std::allocator<reco::MET> > > -------------------
void __edm__RefProd_std__vector_reco__MET_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4868, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefProd_std__vector_reco__MET_s_, product_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefProd<std::vector<reco::MET, std::allocator<reco::MET> > > -------------------
void __edm__RefProd_std__vector_reco__MET_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23204), Reflex::Literal("operator*"), operator_21748, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33835), Reflex::Literal("operator->"), operator_21749, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33835), Reflex::Literal("get"), method_21750, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33835), Reflex::Literal("product"), method_21751, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21396), Reflex::Literal("refCore"), method_21752, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isNull"), method_21753, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isNonnull"), method_21754, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("operator!"), operator_21755, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4866), Reflex::Literal("id"), method_21756, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19828), Reflex::Literal("productGetter"), method_21757, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("hasCache"), method_21758, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("hasProductCache"), method_21759, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isAvailable"), method_21760, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isTransient"), method_21761, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_34355), Reflex::Literal("swap"), method_21762, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_192), Reflex::Literal("Class_Version"), method_21763, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefProd<std::vector<reco::GenMET, std::allocator<reco::GenMET> > > -------------------------------
static  void operator_21768( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefProd<std::vector<reco::GenMET> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<reco::GenMET> >*)arg[0]);
  else   (((::edm::RefProd<std::vector<reco::GenMET> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<reco::GenMET> >*)arg[0]);
}

static void constructor_21769( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::GenMET> >(*(const ::edm::RefProd<std::vector<reco::GenMET> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::GenMET> >(*(const ::edm::RefProd<std::vector<reco::GenMET> >*)arg[0]);
}

static void constructor_21770( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::GenMET> >();
  else ::new(mem) ::edm::RefProd<std::vector<reco::GenMET> >();
}

static void constructor_21771( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::GenMET> >(*(const ::edm::Handle<std::vector<reco::GenMET> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::GenMET> >(*(const ::edm::Handle<std::vector<reco::GenMET> >*)arg[0]);
}

static void constructor_21772( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::GenMET> >(*(const ::edm::OrphanHandle<std::vector<reco::GenMET> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::GenMET> >(*(const ::edm::OrphanHandle<std::vector<reco::GenMET> >*)arg[0]);
}

static void constructor_21773( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::GenMET> >((const ::std::vector<reco::GenMET>*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::GenMET> >((const ::std::vector<reco::GenMET>*)arg[0]);
}

static void constructor_21774( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::GenMET> >(*(const ::edm::TestHandle<std::vector<reco::GenMET> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::GenMET> >(*(const ::edm::TestHandle<std::vector<reco::GenMET> >*)arg[0]);
}

static void constructor_21775( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::GenMET> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::GenMET> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
}

static void destructor_21776(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefProd<std::vector<reco::GenMET> >*)o)->::edm::RefProd<std::vector<reco::GenMET> >::~RefProd)();
}
static  void operator_21777( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<reco::GenMET> >*)o)->operator*)();
  else   (((const ::edm::RefProd<std::vector<reco::GenMET> >*)o)->operator*)();
}

static  void operator_21778( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::GenMET> >*)o)->operator->)());
  else   (((const ::edm::RefProd<std::vector<reco::GenMET> >*)o)->operator->)();
}

static  void method_21779( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::GenMET> >*)o)->get)());
  else   (((const ::edm::RefProd<std::vector<reco::GenMET> >*)o)->get)();
}

static  void method_21780( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::GenMET> >*)o)->product)());
  else   (((const ::edm::RefProd<std::vector<reco::GenMET> >*)o)->product)();
}

static  void method_21781( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<reco::GenMET> >*)o)->refCore)();
  else   (((const ::edm::RefProd<std::vector<reco::GenMET> >*)o)->refCore)();
}

static  void method_21782( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::GenMET> >*)o)->isNull)());
  else   (((const ::edm::RefProd<std::vector<reco::GenMET> >*)o)->isNull)();
}

static  void method_21783( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::GenMET> >*)o)->isNonnull)());
  else   (((const ::edm::RefProd<std::vector<reco::GenMET> >*)o)->isNonnull)();
}

static  void operator_21784( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::GenMET> >*)o)->operator!)());
  else   (((const ::edm::RefProd<std::vector<reco::GenMET> >*)o)->operator!)();
}

static  void method_21785( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefProd<std::vector<reco::GenMET> >*)o)->id)());
  else   (((const ::edm::RefProd<std::vector<reco::GenMET> >*)o)->id)();
}

static  void method_21786( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::GenMET> >*)o)->productGetter)());
  else   (((const ::edm::RefProd<std::vector<reco::GenMET> >*)o)->productGetter)();
}

static  void method_21787( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::GenMET> >*)o)->hasCache)());
  else   (((const ::edm::RefProd<std::vector<reco::GenMET> >*)o)->hasCache)();
}

static  void method_21788( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::GenMET> >*)o)->hasProductCache)());
  else   (((const ::edm::RefProd<std::vector<reco::GenMET> >*)o)->hasProductCache)();
}

static  void method_21789( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::GenMET> >*)o)->isAvailable)());
  else   (((const ::edm::RefProd<std::vector<reco::GenMET> >*)o)->isAvailable)();
}

static  void method_21790( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::GenMET> >*)o)->isTransient)());
  else   (((const ::edm::RefProd<std::vector<reco::GenMET> >*)o)->isTransient)();
}

static  void method_21791( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefProd<std::vector<reco::GenMET> >*)o)->swap)(*(::edm::RefProd<std::vector<reco::GenMET> >*)arg[0]);
}

static  void method_21792( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefProd<std::vector<reco::GenMET> >*)o)->Class_Version)());
  else   (((::edm::RefProd<std::vector<reco::GenMET> >*)o)->Class_Version)();
}

static void method_newdel_4886( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::GenMET> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::GenMET> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::GenMET> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::GenMET> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::GenMET> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefProd<std::vector<reco::GenMET, std::allocator<reco::GenMET> > > -------------------------------
void __edm__RefProd_std__vector_reco__GenMET_s__db_datamem(Reflex::Class*);
void __edm__RefProd_std__vector_reco__GenMET_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_reco__GenMET_s__datamem_bld(&__edm__RefProd_std__vector_reco__GenMET_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_reco__GenMET_s__funcmem_bld(&__edm__RefProd_std__vector_reco__GenMET_s__db_funcmem);
void __edm__RefProd_std__vector_reco__GenMET_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefProd<std::vector<reco::GenMET> >"), typeid(::edm::RefProd<std::vector<reco::GenMET> >), sizeof(::edm::RefProd<std::vector<reco::GenMET> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefProd<std::vector<reco::GenMET> >::Class_Version())
  .AddTypedef(type_3158, Reflex::Literal("edm::RefProd<std::vector<reco::GenMET> >::product_type"))
  .AddTypedef(type_3158, Reflex::Literal("edm::RefProd<std::vector<reco::GenMET> >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_34360, type_34361), Reflex::Literal("operator="), operator_21768, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34361), Reflex::Literal("RefProd"), constructor_21769, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefProd"), constructor_21770, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34362), Reflex::Literal("RefProd"), constructor_21771, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34363), Reflex::Literal("RefProd"), constructor_21772, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33841), Reflex::Literal("RefProd"), constructor_21773, 0, "iProduct", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34364), Reflex::Literal("RefProd"), constructor_21774, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19738, type_19828), Reflex::Literal("RefProd"), constructor_21775, 0, "productID;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefProd"), destructor_21776, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4886, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefProd_std__vector_reco__GenMET_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefProd_std__vector_reco__GenMET_s__funcmem_bld);
}

//------Delayed data member builder for class RefProd<std::vector<reco::GenMET, std::allocator<reco::GenMET> > > -------------------
void __edm__RefProd_std__vector_reco__GenMET_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4868, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefProd_std__vector_reco__GenMET_s_, product_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefProd<std::vector<reco::GenMET, std::allocator<reco::GenMET> > > -------------------
void __edm__RefProd_std__vector_reco__GenMET_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23215), Reflex::Literal("operator*"), operator_21777, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33841), Reflex::Literal("operator->"), operator_21778, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33841), Reflex::Literal("get"), method_21779, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33841), Reflex::Literal("product"), method_21780, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21396), Reflex::Literal("refCore"), method_21781, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isNull"), method_21782, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isNonnull"), method_21783, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("operator!"), operator_21784, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4866), Reflex::Literal("id"), method_21785, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19828), Reflex::Literal("productGetter"), method_21786, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("hasCache"), method_21787, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("hasProductCache"), method_21788, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isAvailable"), method_21789, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isTransient"), method_21790, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_34360), Reflex::Literal("swap"), method_21791, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_192), Reflex::Literal("Class_Version"), method_21792, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefProd<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> > > -------------------------------
static  void operator_21797( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::RefProd<std::vector<reco::CaloMET> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<reco::CaloMET> >*)arg[0]);
  else   (((::edm::RefProd<std::vector<reco::CaloMET> >*)o)->operator=)(*(const ::edm::RefProd<std::vector<reco::CaloMET> >*)arg[0]);
}

static void constructor_21798( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::CaloMET> >(*(const ::edm::RefProd<std::vector<reco::CaloMET> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::CaloMET> >(*(const ::edm::RefProd<std::vector<reco::CaloMET> >*)arg[0]);
}

static void constructor_21799( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::CaloMET> >();
  else ::new(mem) ::edm::RefProd<std::vector<reco::CaloMET> >();
}

static void constructor_21800( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::CaloMET> >(*(const ::edm::Handle<std::vector<reco::CaloMET> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::CaloMET> >(*(const ::edm::Handle<std::vector<reco::CaloMET> >*)arg[0]);
}

static void constructor_21801( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::CaloMET> >(*(const ::edm::OrphanHandle<std::vector<reco::CaloMET> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::CaloMET> >(*(const ::edm::OrphanHandle<std::vector<reco::CaloMET> >*)arg[0]);
}

static void constructor_21802( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::CaloMET> >((const ::std::vector<reco::CaloMET>*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::CaloMET> >((const ::std::vector<reco::CaloMET>*)arg[0]);
}

static void constructor_21803( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::CaloMET> >(*(const ::edm::TestHandle<std::vector<reco::CaloMET> >*)arg[0]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::CaloMET> >(*(const ::edm::TestHandle<std::vector<reco::CaloMET> >*)arg[0]);
}

static void constructor_21804( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::RefProd<std::vector<reco::CaloMET> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
  else ::new(mem) ::edm::RefProd<std::vector<reco::CaloMET> >(*(const ::edm::ProductID*)arg[0],
      (const ::edm::EDProductGetter*)arg[1]);
}

static void destructor_21805(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::RefProd<std::vector<reco::CaloMET> >*)o)->::edm::RefProd<std::vector<reco::CaloMET> >::~RefProd)();
}
static  void operator_21806( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<reco::CaloMET> >*)o)->operator*)();
  else   (((const ::edm::RefProd<std::vector<reco::CaloMET> >*)o)->operator*)();
}

static  void operator_21807( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::CaloMET> >*)o)->operator->)());
  else   (((const ::edm::RefProd<std::vector<reco::CaloMET> >*)o)->operator->)();
}

static  void method_21808( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::CaloMET> >*)o)->get)());
  else   (((const ::edm::RefProd<std::vector<reco::CaloMET> >*)o)->get)();
}

static  void method_21809( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::CaloMET> >*)o)->product)());
  else   (((const ::edm::RefProd<std::vector<reco::CaloMET> >*)o)->product)();
}

static  void method_21810( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::RefProd<std::vector<reco::CaloMET> >*)o)->refCore)();
  else   (((const ::edm::RefProd<std::vector<reco::CaloMET> >*)o)->refCore)();
}

static  void method_21811( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::CaloMET> >*)o)->isNull)());
  else   (((const ::edm::RefProd<std::vector<reco::CaloMET> >*)o)->isNull)();
}

static  void method_21812( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::CaloMET> >*)o)->isNonnull)());
  else   (((const ::edm::RefProd<std::vector<reco::CaloMET> >*)o)->isNonnull)();
}

static  void operator_21813( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::CaloMET> >*)o)->operator!)());
  else   (((const ::edm::RefProd<std::vector<reco::CaloMET> >*)o)->operator!)();
}

static  void method_21814( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::RefProd<std::vector<reco::CaloMET> >*)o)->id)());
  else   (((const ::edm::RefProd<std::vector<reco::CaloMET> >*)o)->id)();
}

static  void method_21815( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::RefProd<std::vector<reco::CaloMET> >*)o)->productGetter)());
  else   (((const ::edm::RefProd<std::vector<reco::CaloMET> >*)o)->productGetter)();
}

static  void method_21816( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::CaloMET> >*)o)->hasCache)());
  else   (((const ::edm::RefProd<std::vector<reco::CaloMET> >*)o)->hasCache)();
}

static  void method_21817( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::CaloMET> >*)o)->hasProductCache)());
  else   (((const ::edm::RefProd<std::vector<reco::CaloMET> >*)o)->hasProductCache)();
}

static  void method_21818( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::CaloMET> >*)o)->isAvailable)());
  else   (((const ::edm::RefProd<std::vector<reco::CaloMET> >*)o)->isAvailable)();
}

static  void method_21819( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::RefProd<std::vector<reco::CaloMET> >*)o)->isTransient)());
  else   (((const ::edm::RefProd<std::vector<reco::CaloMET> >*)o)->isTransient)();
}

static  void method_21820( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::RefProd<std::vector<reco::CaloMET> >*)o)->swap)(*(::edm::RefProd<std::vector<reco::CaloMET> >*)arg[0]);
}

static  void method_21821( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::RefProd<std::vector<reco::CaloMET> >*)o)->Class_Version)());
  else   (((::edm::RefProd<std::vector<reco::CaloMET> >*)o)->Class_Version)();
}

static void method_newdel_4887( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::CaloMET> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::CaloMET> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::CaloMET> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::CaloMET> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::RefProd<std::vector<reco::CaloMET> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class RefProd<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> > > -------------------------------
void __edm__RefProd_std__vector_reco__CaloMET_s__db_datamem(Reflex::Class*);
void __edm__RefProd_std__vector_reco__CaloMET_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_reco__CaloMET_s__datamem_bld(&__edm__RefProd_std__vector_reco__CaloMET_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__RefProd_std__vector_reco__CaloMET_s__funcmem_bld(&__edm__RefProd_std__vector_reco__CaloMET_s__db_funcmem);
void __edm__RefProd_std__vector_reco__CaloMET_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::RefProd<std::vector<reco::CaloMET> >"), typeid(::edm::RefProd<std::vector<reco::CaloMET> >), sizeof(::edm::RefProd<std::vector<reco::CaloMET> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::RefProd<std::vector<reco::CaloMET> >::Class_Version())
  .AddTypedef(type_3148, Reflex::Literal("edm::RefProd<std::vector<reco::CaloMET> >::product_type"))
  .AddTypedef(type_3148, Reflex::Literal("edm::RefProd<std::vector<reco::CaloMET> >::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_34365, type_34366), Reflex::Literal("operator="), operator_21797, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34366), Reflex::Literal("RefProd"), constructor_21798, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefProd"), constructor_21799, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34367), Reflex::Literal("RefProd"), constructor_21800, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34368), Reflex::Literal("RefProd"), constructor_21801, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33845), Reflex::Literal("RefProd"), constructor_21802, 0, "iProduct", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34369), Reflex::Literal("RefProd"), constructor_21803, 0, "handle", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19738, type_19828), Reflex::Literal("RefProd"), constructor_21804, 0, "productID;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefProd"), destructor_21805, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4887, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__RefProd_std__vector_reco__CaloMET_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__RefProd_std__vector_reco__CaloMET_s__funcmem_bld);
}

//------Delayed data member builder for class RefProd<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> > > -------------------
void __edm__RefProd_std__vector_reco__CaloMET_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4868, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__RefProd_std__vector_reco__CaloMET_s_, product_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefProd<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> > > -------------------
void __edm__RefProd_std__vector_reco__CaloMET_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_23226), Reflex::Literal("operator*"), operator_21806, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33845), Reflex::Literal("operator->"), operator_21807, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33845), Reflex::Literal("get"), method_21808, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33845), Reflex::Literal("product"), method_21809, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21396), Reflex::Literal("refCore"), method_21810, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isNull"), method_21811, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isNonnull"), method_21812, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("operator!"), operator_21813, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4866), Reflex::Literal("id"), method_21814, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19828), Reflex::Literal("productGetter"), method_21815, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("hasCache"), method_21816, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("hasProductCache"), method_21817, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isAvailable"), method_21818, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isTransient"), method_21819, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_34365), Reflex::Literal("swap"), method_21820, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_192), Reflex::Literal("Class_Version"), method_21821, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ptr<reco::MET> -------------------------------
static  void operator_21899( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ptr<reco::MET>*)o)->operator=)(*(const ::edm::Ptr<reco::MET>*)arg[0]);
  else   (((::edm::Ptr<reco::MET>*)o)->operator=)(*(const ::edm::Ptr<reco::MET>*)arg[0]);
}

static void constructor_21900( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::MET>(*(const ::edm::Ptr<reco::MET>*)arg[0]);
  else ::new(mem) ::edm::Ptr<reco::MET>(*(const ::edm::Ptr<reco::MET>*)arg[0]);
}

static void constructor_21901( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::MET>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ptr<reco::MET>(*(const ::edm::ProductID*)arg[0],
      *(unsigned long*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_21902( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::MET>(*(const ::edm::ProductID*)arg[0],
      (const ::reco::MET*)arg[1],
      *(unsigned long*)arg[2]);
  else ::new(mem) ::edm::Ptr<reco::MET>(*(const ::edm::ProductID*)arg[0],
      (const ::reco::MET*)arg[1],
      *(unsigned long*)arg[2]);
}

static void constructor_21903( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::MET>(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ptr<reco::MET>(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_21904( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ptr<reco::MET>();
  else ::new(mem) ::edm::Ptr<reco::MET>();
}

static void destructor_21905(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ptr<reco::MET>*)o)->::edm::Ptr<reco::MET>::~Ptr)();
}
static  void operator_21906( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<reco::MET>*)o)->operator*)();
  else   (((const ::edm::Ptr<reco::MET>*)o)->operator*)();
}

static  void operator_21907( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::MET>*)o)->operator->)());
  else   (((const ::edm::Ptr<reco::MET>*)o)->operator->)();
}

static  void method_21908( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::MET>*)o)->get)());
  else   (((const ::edm::Ptr<reco::MET>*)o)->get)();
}

static  void method_21909( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::MET>*)o)->isNull)());
  else   (((const ::edm::Ptr<reco::MET>*)o)->isNull)();
}

static  void method_21910( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::MET>*)o)->isNonnull)());
  else   (((const ::edm::Ptr<reco::MET>*)o)->isNonnull)();
}

static  void operator_21911( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::MET>*)o)->operator!)());
  else   (((const ::edm::Ptr<reco::MET>*)o)->operator!)();
}

static  void method_21912( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::MET>*)o)->isAvailable)());
  else   (((const ::edm::Ptr<reco::MET>*)o)->isAvailable)();
}

static  void method_21913( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::MET>*)o)->isTransient)());
  else   (((const ::edm::Ptr<reco::MET>*)o)->isTransient)();
}

static  void method_21914( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ptr<reco::MET>*)o)->id)());
  else   (((const ::edm::Ptr<reco::MET>*)o)->id)();
}

static  void method_21915( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::MET>*)o)->productGetter)());
  else   (((const ::edm::Ptr<reco::MET>*)o)->productGetter)();
}

static  void method_21916( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned long)((((const ::edm::Ptr<reco::MET>*)o)->key)());
  else   (((const ::edm::Ptr<reco::MET>*)o)->key)();
}

static  void method_21917( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ptr<reco::MET>*)o)->hasProductCache)());
  else   (((const ::edm::Ptr<reco::MET>*)o)->hasProductCache)();
}

static  void method_21918( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ptr<reco::MET>*)o)->refCore)();
  else   (((const ::edm::Ptr<reco::MET>*)o)->refCore)();
}

static  void method_21919( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ptr<reco::MET>*)o)->product)());
  else   (((const ::edm::Ptr<reco::MET>*)o)->product)();
}

static  void method_21920( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ptr<reco::MET>*)o)->Class_Version)());
  else   (((::edm::Ptr<reco::MET>*)o)->Class_Version)();
}

static void method_newdel_4901( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::MET> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::MET> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::MET> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::MET> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ptr<reco::MET> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ptr<reco::MET> -------------------------------
void __edm__Ptr_reco__MET__db_datamem(Reflex::Class*);
void __edm__Ptr_reco__MET__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ptr_reco__MET__datamem_bld(&__edm__Ptr_reco__MET__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ptr_reco__MET__funcmem_bld(&__edm__Ptr_reco__MET__db_funcmem);
void __edm__Ptr_reco__MET__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ptr<reco::MET>"), typeid(::edm::Ptr<reco::MET>), sizeof(::edm::Ptr<reco::MET>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ptr<reco::MET>::Class_Version())
  .AddTypedef(type_364, Reflex::Literal("edm::Ptr<reco::MET>::key_type"))
  .AddTypedef(type_7952, Reflex::Literal("edm::Ptr<reco::MET>::value_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_34388, type_33811), Reflex::Literal("operator="), operator_21899, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33811), Reflex::Literal("Ptr"), constructor_21900, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19738, type_364, type_19828), Reflex::Literal("Ptr"), constructor_21901, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19738, type_13631, type_364), Reflex::Literal("Ptr"), constructor_21902, 0, "productID;item;item_key", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19738), Reflex::Literal("Ptr"), constructor_21903, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ptr"), constructor_21904, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ptr"), destructor_21905, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4901, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ptr_reco__MET__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ptr_reco__MET__funcmem_bld);
}

//------Delayed data member builder for class Ptr<reco::MET> -------------------
void __edm__Ptr_reco__MET__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4868, Reflex::Literal("core_"), OffsetOf(__shadow__::__edm__Ptr_reco__MET_, core_), ::Reflex::PRIVATE)
  .AddDataMember(type_364, Reflex::Literal("key_"), OffsetOf(__shadow__::__edm__Ptr_reco__MET_, key_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Ptr<reco::MET> -------------------
void __edm__Ptr_reco__MET__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13635), Reflex::Literal("operator*"), operator_21906, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13631), Reflex::Literal("operator->"), operator_21907, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13631), Reflex::Literal("get"), method_21908, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isNull"), method_21909, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isNonnull"), method_21910, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("operator!"), operator_21911, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isAvailable"), method_21912, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isTransient"), method_21913, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4866), Reflex::Literal("id"), method_21914, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19828), Reflex::Literal("productGetter"), method_21915, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_364), Reflex::Literal("key"), method_21916, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("hasProductCache"), method_21917, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21396), Reflex::Literal("refCore"), method_21918, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4239), Reflex::Literal("product"), method_21919, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_192), Reflex::Literal("Class_Version"), method_21920, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ref<std::vector<reco::PFClusterMET, std::allocator<reco::PFClusterMET> >,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET, std::allocator<reco::PFClusterMET> >, reco::PFClusterMET> > -------------------------------
static  void operator_22127( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->operator=)(*(const ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)arg[0]);
  else   (((::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->operator=)(*(const ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)arg[0]);
}

static void constructor_22128( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >(*(const ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >(*(const ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)arg[0]);
}

static void constructor_22129( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >();
  else ::new(mem) ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >();
}

static void constructor_22130( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >(*(const ::edm::Handle<std::vector<reco::PFClusterMET> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >(*(const ::edm::Handle<std::vector<reco::PFClusterMET> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >(*(const ::edm::Handle<std::vector<reco::PFClusterMET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >(*(const ::edm::Handle<std::vector<reco::PFClusterMET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_22131( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >(*(const ::edm::OrphanHandle<std::vector<reco::PFClusterMET> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >(*(const ::edm::OrphanHandle<std::vector<reco::PFClusterMET> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >(*(const ::edm::OrphanHandle<std::vector<reco::PFClusterMET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >(*(const ::edm::OrphanHandle<std::vector<reco::PFClusterMET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_22132( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >(*(const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >(*(const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >(*(const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >(*(const ::edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_22133( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >((const ::std::vector<reco::PFClusterMET>*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >((const ::std::vector<reco::PFClusterMET>*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >((const ::std::vector<reco::PFClusterMET>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >((const ::std::vector<reco::PFClusterMET>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_22134( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >(*(const ::edm::TestHandle<std::vector<reco::PFClusterMET> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >(*(const ::edm::TestHandle<std::vector<reco::PFClusterMET> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >(*(const ::edm::TestHandle<std::vector<reco::PFClusterMET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >(*(const ::edm::TestHandle<std::vector<reco::PFClusterMET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_22135( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_22136( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >(*(const ::edm::ProductID*)arg[0],
      (const ::reco::PFClusterMET*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<reco::PFClusterMET>*)arg[3]);
  else ::new(mem) ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >(*(const ::edm::ProductID*)arg[0],
      (const ::reco::PFClusterMET*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<reco::PFClusterMET>*)arg[3]);
}

static void constructor_22137( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_22138( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >(*(const ::edm::RefProd<std::vector<reco::PFClusterMET> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >(*(const ::edm::RefProd<std::vector<reco::PFClusterMET> >*)arg[0],
      *(unsigned int*)arg[1]);
}

static void destructor_22139(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >::~Ref)();
}
static  void operator_22140( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->operator*)();
  else   (((const ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->operator*)();
}

static  void operator_22141( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->operator->)());
  else   (((const ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->operator->)();
}

static  void method_22142( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->get)());
  else   (((const ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->get)();
}

static  void method_22143( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->isNull)());
  else   (((const ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->isNull)();
}

static  void method_22144( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->isNonnull)());
  else   (((const ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->isNonnull)();
}

static  void operator_22145( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->operator!)());
  else   (((const ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->operator!)();
}

static  void method_22146( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->id)());
  else   (((const ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->id)();
}

static  void method_22147( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->productGetter)());
  else   (((const ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->productGetter)();
}

static  void method_22148( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->product)());
  else   (((const ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->product)();
}

static  void method_22149( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->key)());
  else   (((const ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->key)();
}

static  void method_22150( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->index)());
  else   (((const ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->index)();
}

static  void method_22151( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->hasProductCache)());
  else   (((const ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->hasProductCache)();
}

static  void method_22152( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->isAvailable)());
  else   (((const ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->isAvailable)();
}

static  void method_22153( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->isTransient)());
  else   (((const ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->isTransient)();
}

static  void method_22154( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->refCore)();
  else   (((const ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->refCore)();
}

static  void method_22155( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->Class_Version)());
  else   (((::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)o)->Class_Version)();
}

static void constructor_22156( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_4915( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ref<std::vector<reco::PFClusterMET, std::allocator<reco::PFClusterMET> >,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET, std::allocator<reco::PFClusterMET> >, reco::PFClusterMET> > -------------------------------
void __edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s__db_datamem(Reflex::Class*);
void __edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s__datamem_bld(&__edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s__funcmem_bld(&__edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s__db_funcmem);
void __edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >"), typeid(::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >), sizeof(::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >::Class_Version())
  .AddTypedef(type_7916, Reflex::Literal("edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >::T"))
  .AddTypedef(type_20093, Reflex::Literal("edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >::F"))
  .AddTypedef(type_20069, Reflex::Literal("edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >::VF"))
  .AddTypedef(type_20068, Reflex::Literal("edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >::VBF"))
  .AddTypedef(type_3155, Reflex::Literal("edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >::product_type"))
  .AddTypedef(type_7916, Reflex::Literal("edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >::value_type"))
  .AddTypedef(type_7916c, Reflex::Literal("edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >::element_type"))
  .AddTypedef(type_20093, Reflex::Literal("edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >::finder_type"))
  .AddTypedef(type_373, Reflex::Literal("edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >::argument_type"))
  .AddTypedef(type_373, Reflex::Literal("edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >::key_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_34398, type_33824), Reflex::Literal("operator="), operator_22127, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33824), Reflex::Literal("Ref"), constructor_22128, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ref"), constructor_22129, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34347, type_373, type_1647), Reflex::Literal("Ref"), constructor_22130, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34348, type_373, type_1647), Reflex::Literal("Ref"), constructor_22131, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33823, type_373, type_1647), Reflex::Literal("Ref"), constructor_22132, 0, "refvector;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33825, type_373, type_1647), Reflex::Literal("Ref"), constructor_22133, 0, "iProduct;iItemKey;iSetNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34349, type_373, type_1647), Reflex::Literal("Ref"), constructor_22134, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19738, type_373, type_19828), Reflex::Literal("Ref"), constructor_22135, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19738, type_14212, type_373, type_33825), Reflex::Literal("Ref"), constructor_22136, 0, "iProductID;;iItemKey;iProduct", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19738), Reflex::Literal("Ref"), constructor_22137, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34346, type_373), Reflex::Literal("Ref"), constructor_22138, 0, "refProd;itemKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ref"), destructor_22139, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21396, type_10352), Reflex::Literal("Ref"), constructor_22156, 0, "iRefCore;iKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4915, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s__funcmem_bld);
}

//------Delayed data member builder for class Ref<std::vector<reco::PFClusterMET, std::allocator<reco::PFClusterMET> >,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET, std::allocator<reco::PFClusterMET> >, reco::PFClusterMET> > -------------------
void __edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4931, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_, product_), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class Ref<std::vector<reco::PFClusterMET, std::allocator<reco::PFClusterMET> >,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET, std::allocator<reco::PFClusterMET> >, reco::PFClusterMET> > -------------------
void __edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14216), Reflex::Literal("operator*"), operator_22140, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14212), Reflex::Literal("operator->"), operator_22141, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14212), Reflex::Literal("get"), method_22142, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isNull"), method_22143, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isNonnull"), method_22144, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("operator!"), operator_22145, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4866), Reflex::Literal("id"), method_22146, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19828), Reflex::Literal("productGetter"), method_22147, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33825), Reflex::Literal("product"), method_22148, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_373), Reflex::Literal("key"), method_22149, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_373), Reflex::Literal("index"), method_22150, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("hasProductCache"), method_22151, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isAvailable"), method_22152, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isTransient"), method_22153, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21396), Reflex::Literal("refCore"), method_22154, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_192), Reflex::Literal("Class_Version"), method_22155, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ref<std::vector<reco::PFMET, std::allocator<reco::PFMET> >,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET, std::allocator<reco::PFMET> >, reco::PFMET> > -------------------------------
static  void operator_22169( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->operator=)(*(const ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)arg[0]);
  else   (((::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->operator=)(*(const ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)arg[0]);
}

static void constructor_22170( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >(*(const ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >(*(const ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)arg[0]);
}

static void constructor_22171( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >();
  else ::new(mem) ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >();
}

static void constructor_22172( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >(*(const ::edm::Handle<std::vector<reco::PFMET> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >(*(const ::edm::Handle<std::vector<reco::PFMET> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >(*(const ::edm::Handle<std::vector<reco::PFMET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >(*(const ::edm::Handle<std::vector<reco::PFMET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_22173( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >(*(const ::edm::OrphanHandle<std::vector<reco::PFMET> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >(*(const ::edm::OrphanHandle<std::vector<reco::PFMET> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >(*(const ::edm::OrphanHandle<std::vector<reco::PFMET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >(*(const ::edm::OrphanHandle<std::vector<reco::PFMET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_22174( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >(*(const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >(*(const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >(*(const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >(*(const ::edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_22175( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >((const ::std::vector<reco::PFMET>*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >((const ::std::vector<reco::PFMET>*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >((const ::std::vector<reco::PFMET>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >((const ::std::vector<reco::PFMET>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_22176( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >(*(const ::edm::TestHandle<std::vector<reco::PFMET> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >(*(const ::edm::TestHandle<std::vector<reco::PFMET> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >(*(const ::edm::TestHandle<std::vector<reco::PFMET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >(*(const ::edm::TestHandle<std::vector<reco::PFMET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_22177( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_22178( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >(*(const ::edm::ProductID*)arg[0],
      (const ::reco::PFMET*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<reco::PFMET>*)arg[3]);
  else ::new(mem) ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >(*(const ::edm::ProductID*)arg[0],
      (const ::reco::PFMET*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<reco::PFMET>*)arg[3]);
}

static void constructor_22179( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_22180( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >(*(const ::edm::RefProd<std::vector<reco::PFMET> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >(*(const ::edm::RefProd<std::vector<reco::PFMET> >*)arg[0],
      *(unsigned int*)arg[1]);
}

static void destructor_22181(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >::~Ref)();
}
static  void operator_22182( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->operator*)();
  else   (((const ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->operator*)();
}

static  void operator_22183( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->operator->)());
  else   (((const ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->operator->)();
}

static  void method_22184( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->get)());
  else   (((const ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->get)();
}

static  void method_22185( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->isNull)());
  else   (((const ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->isNull)();
}

static  void method_22186( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->isNonnull)());
  else   (((const ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->isNonnull)();
}

static  void operator_22187( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->operator!)());
  else   (((const ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->operator!)();
}

static  void method_22188( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->id)());
  else   (((const ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->id)();
}

static  void method_22189( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->productGetter)());
  else   (((const ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->productGetter)();
}

static  void method_22190( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->product)());
  else   (((const ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->product)();
}

static  void method_22191( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->key)());
  else   (((const ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->key)();
}

static  void method_22192( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->index)());
  else   (((const ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->index)();
}

static  void method_22193( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->hasProductCache)());
  else   (((const ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->hasProductCache)();
}

static  void method_22194( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->isAvailable)());
  else   (((const ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->isAvailable)();
}

static  void method_22195( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->isTransient)());
  else   (((const ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->isTransient)();
}

static  void method_22196( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->refCore)();
  else   (((const ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->refCore)();
}

static  void method_22197( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->Class_Version)());
  else   (((::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)o)->Class_Version)();
}

static void constructor_22198( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_4916( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ref<std::vector<reco::PFMET, std::allocator<reco::PFMET> >,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET, std::allocator<reco::PFMET> >, reco::PFMET> > -------------------------------
void __edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s__db_datamem(Reflex::Class*);
void __edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s__datamem_bld(&__edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s__funcmem_bld(&__edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s__db_funcmem);
void __edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >"), typeid(::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >), sizeof(::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >::Class_Version())
  .AddTypedef(type_7918, Reflex::Literal("edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >::T"))
  .AddTypedef(type_20094, Reflex::Literal("edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >::F"))
  .AddTypedef(type_20071, Reflex::Literal("edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >::VF"))
  .AddTypedef(type_20070, Reflex::Literal("edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >::VBF"))
  .AddTypedef(type_3157, Reflex::Literal("edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >::product_type"))
  .AddTypedef(type_7918, Reflex::Literal("edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >::value_type"))
  .AddTypedef(type_7918c, Reflex::Literal("edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >::element_type"))
  .AddTypedef(type_20094, Reflex::Literal("edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >::finder_type"))
  .AddTypedef(type_373, Reflex::Literal("edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >::argument_type"))
  .AddTypedef(type_373, Reflex::Literal("edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >::key_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_34399, type_33830), Reflex::Literal("operator="), operator_22169, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33830), Reflex::Literal("Ref"), constructor_22170, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ref"), constructor_22171, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34352, type_373, type_1647), Reflex::Literal("Ref"), constructor_22172, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34353, type_373, type_1647), Reflex::Literal("Ref"), constructor_22173, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33829, type_373, type_1647), Reflex::Literal("Ref"), constructor_22174, 0, "refvector;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33831, type_373, type_1647), Reflex::Literal("Ref"), constructor_22175, 0, "iProduct;iItemKey;iSetNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34354, type_373, type_1647), Reflex::Literal("Ref"), constructor_22176, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19738, type_373, type_19828), Reflex::Literal("Ref"), constructor_22177, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19738, type_14339, type_373, type_33831), Reflex::Literal("Ref"), constructor_22178, 0, "iProductID;;iItemKey;iProduct", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19738), Reflex::Literal("Ref"), constructor_22179, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34351, type_373), Reflex::Literal("Ref"), constructor_22180, 0, "refProd;itemKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ref"), destructor_22181, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21396, type_10352), Reflex::Literal("Ref"), constructor_22198, 0, "iRefCore;iKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4916, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s__funcmem_bld);
}

//------Delayed data member builder for class Ref<std::vector<reco::PFMET, std::allocator<reco::PFMET> >,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET, std::allocator<reco::PFMET> >, reco::PFMET> > -------------------
void __edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4931, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_, product_), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class Ref<std::vector<reco::PFMET, std::allocator<reco::PFMET> >,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET, std::allocator<reco::PFMET> >, reco::PFMET> > -------------------
void __edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14343), Reflex::Literal("operator*"), operator_22182, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14339), Reflex::Literal("operator->"), operator_22183, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14339), Reflex::Literal("get"), method_22184, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isNull"), method_22185, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isNonnull"), method_22186, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("operator!"), operator_22187, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4866), Reflex::Literal("id"), method_22188, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19828), Reflex::Literal("productGetter"), method_22189, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33831), Reflex::Literal("product"), method_22190, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_373), Reflex::Literal("key"), method_22191, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_373), Reflex::Literal("index"), method_22192, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("hasProductCache"), method_22193, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isAvailable"), method_22194, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isTransient"), method_22195, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21396), Reflex::Literal("refCore"), method_22196, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_192), Reflex::Literal("Class_Version"), method_22197, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Ref<std::vector<reco::GenMET, std::allocator<reco::GenMET> >,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET, std::allocator<reco::GenMET> >, reco::GenMET> > -------------------------------
static  void operator_22211( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->operator=)(*(const ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)arg[0]);
  else   (((::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->operator=)(*(const ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)arg[0]);
}

static void constructor_22212( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >(*(const ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >(*(const ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)arg[0]);
}

static void constructor_22213( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >();
  else ::new(mem) ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >();
}

static void constructor_22214( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >(*(const ::edm::Handle<std::vector<reco::GenMET> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >(*(const ::edm::Handle<std::vector<reco::GenMET> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >(*(const ::edm::Handle<std::vector<reco::GenMET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >(*(const ::edm::Handle<std::vector<reco::GenMET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_22215( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >(*(const ::edm::OrphanHandle<std::vector<reco::GenMET> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >(*(const ::edm::OrphanHandle<std::vector<reco::GenMET> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >(*(const ::edm::OrphanHandle<std::vector<reco::GenMET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >(*(const ::edm::OrphanHandle<std::vector<reco::GenMET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_22216( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >(*(const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >(*(const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >(*(const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >(*(const ::edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_22217( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >((const ::std::vector<reco::GenMET>*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >((const ::std::vector<reco::GenMET>*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >((const ::std::vector<reco::GenMET>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >((const ::std::vector<reco::GenMET>*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_22218( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >(*(const ::edm::TestHandle<std::vector<reco::GenMET> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >(*(const ::edm::TestHandle<std::vector<reco::GenMET> >*)arg[0],
      *(unsigned int*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >(*(const ::edm::TestHandle<std::vector<reco::GenMET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >(*(const ::edm::TestHandle<std::vector<reco::GenMET> >*)arg[0],
      *(unsigned int*)arg[1],
      *(bool*)arg[2]);
  }
}

static void constructor_22219( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
  else ::new(mem) ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >(*(const ::edm::ProductID*)arg[0],
      *(unsigned int*)arg[1],
      (const ::edm::EDProductGetter*)arg[2]);
}

static void constructor_22220( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >(*(const ::edm::ProductID*)arg[0],
      (const ::reco::GenMET*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<reco::GenMET>*)arg[3]);
  else ::new(mem) ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >(*(const ::edm::ProductID*)arg[0],
      (const ::reco::GenMET*)arg[1],
      *(unsigned int*)arg[2],
      (const ::std::vector<reco::GenMET>*)arg[3]);
}

static void constructor_22221( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >(*(const ::edm::ProductID*)arg[0]);
  else ::new(mem) ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >(*(const ::edm::ProductID*)arg[0]);
}

static void constructor_22222( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >(*(const ::edm::RefProd<std::vector<reco::GenMET> >*)arg[0],
      *(unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >(*(const ::edm::RefProd<std::vector<reco::GenMET> >*)arg[0],
      *(unsigned int*)arg[1]);
}

static void destructor_22223(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >::~Ref)();
}
static  void operator_22224( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->operator*)();
  else   (((const ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->operator*)();
}

static  void operator_22225( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->operator->)());
  else   (((const ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->operator->)();
}

static  void method_22226( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->get)());
  else   (((const ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->get)();
}

static  void method_22227( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->isNull)());
  else   (((const ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->isNull)();
}

static  void method_22228( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->isNonnull)());
  else   (((const ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->isNonnull)();
}

static  void operator_22229( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->operator!)());
  else   (((const ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->operator!)();
}

static  void method_22230( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->id)());
  else   (((const ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->id)();
}

static  void method_22231( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->productGetter)());
  else   (((const ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->productGetter)();
}

static  void method_22232( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->product)());
  else   (((const ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->product)();
}

static  void method_22233( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->key)());
  else   (((const ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->key)();
}

static  void method_22234( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->index)());
  else   (((const ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->index)();
}

static  void method_22235( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->hasProductCache)());
  else   (((const ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->hasProductCache)();
}

static  void method_22236( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->isAvailable)());
  else   (((const ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->isAvailable)();
}

static  void method_22237( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->isTransient)());
  else   (((const ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->isTransient)();
}

static  void method_22238( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->refCore)();
  else   (((const ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->refCore)();
}

static  void method_22239( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->Class_Version)());
  else   (((::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)o)->Class_Version)();
}

static void constructor_22240( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
  else ::new(mem) ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >(*(const ::edm::RefCore*)arg[0],
      *(const unsigned int*)arg[1]);
}

static void method_newdel_4917( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Ref<std::vector<reco::GenMET, std::allocator<reco::GenMET> >,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET, std::allocator<reco::GenMET> >, reco::GenMET> > -------------------------------
void __edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s__db_datamem(Reflex::Class*);
void __edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s__datamem_bld(&__edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s__funcmem_bld(&__edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s__db_funcmem);
void __edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >"), typeid(::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >), sizeof(::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >::Class_Version())
  .AddTypedef(type_7970, Reflex::Literal("edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >::T"))
  .AddTypedef(type_20095, Reflex::Literal("edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >::F"))
  .AddTypedef(type_20075, Reflex::Literal("edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >::VF"))
  .AddTypedef(type_20074, Reflex::Literal("edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >::VBF"))
  .AddTypedef(type_3158, Reflex::Literal("edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >::product_type"))
  .AddTypedef(type_7970, Reflex::Literal("edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >::value_type"))
  .AddTypedef(type_7970c, Reflex::Literal("edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >::element_type"))
  .AddTypedef(type_20095, Reflex::Literal("edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >::finder_type"))
  .AddTypedef(type_373, Reflex::Literal("edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >::argument_type"))
  .AddTypedef(type_373, Reflex::Literal("edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >::key_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_34400, type_33840), Reflex::Literal("operator="), operator_22211, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33840), Reflex::Literal("Ref"), constructor_22212, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Ref"), constructor_22213, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34362, type_373, type_1647), Reflex::Literal("Ref"), constructor_22214, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34363, type_373, type_1647), Reflex::Literal("Ref"), constructor_22215, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33839, type_373, type_1647), Reflex::Literal("Ref"), constructor_22216, 0, "refvector;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33841, type_373, type_1647), Reflex::Literal("Ref"), constructor_22217, 0, "iProduct;iItemKey;iSetNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34364, type_373, type_1647), Reflex::Literal("Ref"), constructor_22218, 0, "handle;itemKey;setNow=true", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19738, type_373, type_19828), Reflex::Literal("Ref"), constructor_22219, 0, "productID;itemKey;prodGetter", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19738, type_14404, type_373, type_33841), Reflex::Literal("Ref"), constructor_22220, 0, "iProductID;;iItemKey;iProduct", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19738), Reflex::Literal("Ref"), constructor_22221, 0, "iId", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_34361, type_373), Reflex::Literal("Ref"), constructor_22222, 0, "refProd;itemKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Ref"), destructor_22223, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21396, type_10352), Reflex::Literal("Ref"), constructor_22240, 0, "iRefCore;iKey", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4917, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s__funcmem_bld);
}

//------Delayed data member builder for class Ref<std::vector<reco::GenMET, std::allocator<reco::GenMET> >,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET, std::allocator<reco::GenMET> >, reco::GenMET> > -------------------
void __edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4931, Reflex::Literal("product_"), OffsetOf(__shadow__::__edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_, product_), ::Reflex::PRIVATE | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class Ref<std::vector<reco::GenMET, std::allocator<reco::GenMET> >,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET, std::allocator<reco::GenMET> >, reco::GenMET> > -------------------
void __edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14408), Reflex::Literal("operator*"), operator_22224, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14404), Reflex::Literal("operator->"), operator_22225, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14404), Reflex::Literal("get"), method_22226, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isNull"), method_22227, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isNonnull"), method_22228, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("operator!"), operator_22229, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4866), Reflex::Literal("id"), method_22230, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19828), Reflex::Literal("productGetter"), method_22231, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33841), Reflex::Literal("product"), method_22232, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_373), Reflex::Literal("key"), method_22233, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_373), Reflex::Literal("index"), method_22234, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("hasProductCache"), method_22235, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isAvailable"), method_22236, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isTransient"), method_22237, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21396), Reflex::Literal("refCore"), method_22238, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_192), Reflex::Literal("Class_Version"), method_22239, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class MVAMEtPFCandInfo -------------------------------
static  void operator_27528( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::MVAMEtPFCandInfo*)o)->operator=)(*(const ::reco::MVAMEtPFCandInfo*)arg[0]);
  else   (((::reco::MVAMEtPFCandInfo*)o)->operator=)(*(const ::reco::MVAMEtPFCandInfo*)arg[0]);
}

static void constructor_27529( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::MVAMEtPFCandInfo(*(const ::reco::MVAMEtPFCandInfo*)arg[0]);
  else ::new(mem) ::reco::MVAMEtPFCandInfo(*(const ::reco::MVAMEtPFCandInfo*)arg[0]);
}

static void constructor_27530( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::MVAMEtPFCandInfo();
  else ::new(mem) ::reco::MVAMEtPFCandInfo();
}

static void destructor_27531(void*, void * o, const std::vector<void*>&, void *) {
(((::reco::MVAMEtPFCandInfo*)o)->::reco::MVAMEtPFCandInfo::~MVAMEtPFCandInfo)();
}
static void method_newdel_7941( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::reco::MVAMEtPFCandInfo >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::reco::MVAMEtPFCandInfo >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::reco::MVAMEtPFCandInfo >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::reco::MVAMEtPFCandInfo >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::reco::MVAMEtPFCandInfo >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class MVAMEtPFCandInfo -------------------------------
void __reco__MVAMEtPFCandInfo_db_datamem(Reflex::Class*);
void __reco__MVAMEtPFCandInfo_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __reco__MVAMEtPFCandInfo_datamem_bld(&__reco__MVAMEtPFCandInfo_db_datamem);
Reflex::GenreflexMemberBuilder __reco__MVAMEtPFCandInfo_funcmem_bld(&__reco__MVAMEtPFCandInfo_db_funcmem);
void __reco__MVAMEtPFCandInfo_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("reco::MVAMEtPFCandInfo"), typeid(::reco::MVAMEtPFCandInfo), sizeof(::reco::MVAMEtPFCandInfo), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("ClassVersion"), "12")
  .AddEnum(Reflex::Literal("_196"), Reflex::Literal("kUndefined=0;kPileUpCharged=1;kNoPileUpCharged=2;kNeutral=3"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13243, type_13245), Reflex::Literal("operator="), operator_27528, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13245), Reflex::Literal("MVAMEtPFCandInfo"), constructor_27529, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("MVAMEtPFCandInfo"), constructor_27530, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~MVAMEtPFCandInfo"), destructor_27531, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7941, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__reco__MVAMEtPFCandInfo_datamem_bld);
}

//------Delayed data member builder for class MVAMEtPFCandInfo -------------------
void __reco__MVAMEtPFCandInfo_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7319, Reflex::Literal("p4_"), OffsetOf(__shadow__::__reco__MVAMEtPFCandInfo, p4_), ::Reflex::PUBLIC)
  .AddDataMember(type_72, Reflex::Literal("charge_"), OffsetOf(__shadow__::__reco__MVAMEtPFCandInfo, charge_), ::Reflex::PUBLIC)
  .AddDataMember(type_72, Reflex::Literal("type_"), OffsetOf(__shadow__::__reco__MVAMEtPFCandInfo, type_), ::Reflex::PUBLIC)
  .AddDataMember(type_1647, Reflex::Literal("isWithinJet_"), OffsetOf(__shadow__::__reco__MVAMEtPFCandInfo, isWithinJet_), ::Reflex::PUBLIC)
  .AddDataMember(type_1647, Reflex::Literal("passesLooseJetId_"), OffsetOf(__shadow__::__reco__MVAMEtPFCandInfo, passesLooseJetId_), ::Reflex::PUBLIC)
  .AddDataMember(type_3824, Reflex::Literal("pfMEtSignObj_"), OffsetOf(__shadow__::__reco__MVAMEtPFCandInfo, pfMEtSignObj_), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class MVAMEtPFCandInfo -------------------
void __reco__MVAMEtPFCandInfo_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class HcalNoiseRBX -------------------------------
static  void operator_28088( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::HcalNoiseRBX*)o)->operator=)(*(const ::reco::HcalNoiseRBX*)arg[0]);
  else   (((::reco::HcalNoiseRBX*)o)->operator=)(*(const ::reco::HcalNoiseRBX*)arg[0]);
}

static void constructor_28089( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::HcalNoiseRBX(*(const ::reco::HcalNoiseRBX*)arg[0]);
  else ::new(mem) ::reco::HcalNoiseRBX(*(const ::reco::HcalNoiseRBX*)arg[0]);
}

static void constructor_28090( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::HcalNoiseRBX();
  else ::new(mem) ::reco::HcalNoiseRBX();
}

static void destructor_28091(void*, void * o, const std::vector<void*>&, void *) {
(((::reco::HcalNoiseRBX*)o)->::reco::HcalNoiseRBX::~HcalNoiseRBX)();
}
static  void method_28092( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::reco::HcalNoiseRBX*)o)->idnumber)());
  else   (((const ::reco::HcalNoiseRBX*)o)->idnumber)();
}

static  void method_28093( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<reco::HcalNoiseHPD>)((((const ::reco::HcalNoiseRBX*)o)->HPDs)());
  else   (((const ::reco::HcalNoiseRBX*)o)->HPDs)();
}

static  void method_28094( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >)((((const ::reco::HcalNoiseRBX*)o)->HPDsBegin)());
  else   (((const ::reco::HcalNoiseRBX*)o)->HPDsBegin)();
}

static  void method_28095( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >)((((const ::reco::HcalNoiseRBX*)o)->HPDsEnd)());
  else   (((const ::reco::HcalNoiseRBX*)o)->HPDsEnd)();
}

static  void method_28096( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >)((((const ::reco::HcalNoiseRBX*)o)->maxHPD)());
    else     (((const ::reco::HcalNoiseRBX*)o)->maxHPD)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >)((((const ::reco::HcalNoiseRBX*)o)->maxHPD)(*(double*)arg[0]));
    else     (((const ::reco::HcalNoiseRBX*)o)->maxHPD)(*(double*)arg[0]);
  }
}

static  void method_28097( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<float>)((((const ::reco::HcalNoiseRBX*)o)->allCharge)());
  else   (((const ::reco::HcalNoiseRBX*)o)->allCharge)();
}

static  void method_28098( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::reco::HcalNoiseRBX*)o)->allChargeTotal)());
  else   (((const ::reco::HcalNoiseRBX*)o)->allChargeTotal)();
}

static  void method_28099( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (float)((((const ::reco::HcalNoiseRBX*)o)->allChargeHighest2TS)());
    else     (((const ::reco::HcalNoiseRBX*)o)->allChargeHighest2TS)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (float)((((const ::reco::HcalNoiseRBX*)o)->allChargeHighest2TS)(*(unsigned int*)arg[0]));
    else     (((const ::reco::HcalNoiseRBX*)o)->allChargeHighest2TS)(*(unsigned int*)arg[0]);
  }
}

static  void method_28100( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (float)((((const ::reco::HcalNoiseRBX*)o)->allChargeHighest3TS)());
    else     (((const ::reco::HcalNoiseRBX*)o)->allChargeHighest3TS)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (float)((((const ::reco::HcalNoiseRBX*)o)->allChargeHighest3TS)(*(unsigned int*)arg[0]));
    else     (((const ::reco::HcalNoiseRBX*)o)->allChargeHighest3TS)(*(unsigned int*)arg[0]);
  }
}

static  void method_28101( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::reco::HcalNoiseRBX*)o)->totalZeros)());
  else   (((const ::reco::HcalNoiseRBX*)o)->totalZeros)();
}

static  void method_28102( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::reco::HcalNoiseRBX*)o)->maxZeros)());
  else   (((const ::reco::HcalNoiseRBX*)o)->maxZeros)();
}

static  void method_28103( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::reco::HcalNoiseRBX*)o)->recHitEnergy)());
    else     (((const ::reco::HcalNoiseRBX*)o)->recHitEnergy)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::reco::HcalNoiseRBX*)o)->recHitEnergy)(*(double*)arg[0]));
    else     (((const ::reco::HcalNoiseRBX*)o)->recHitEnergy)(*(double*)arg[0]);
  }
}

static  void method_28104( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::reco::HcalNoiseRBX*)o)->minRecHitTime)());
    else     (((const ::reco::HcalNoiseRBX*)o)->minRecHitTime)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::reco::HcalNoiseRBX*)o)->minRecHitTime)(*(double*)arg[0]));
    else     (((const ::reco::HcalNoiseRBX*)o)->minRecHitTime)(*(double*)arg[0]);
  }
}

static  void method_28105( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (double)((((const ::reco::HcalNoiseRBX*)o)->maxRecHitTime)());
    else     (((const ::reco::HcalNoiseRBX*)o)->maxRecHitTime)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (double)((((const ::reco::HcalNoiseRBX*)o)->maxRecHitTime)(*(double*)arg[0]));
    else     (((const ::reco::HcalNoiseRBX*)o)->maxRecHitTime)(*(double*)arg[0]);
  }
}

static  void method_28106( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (int)((((const ::reco::HcalNoiseRBX*)o)->numRecHits)());
    else     (((const ::reco::HcalNoiseRBX*)o)->numRecHits)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (int)((((const ::reco::HcalNoiseRBX*)o)->numRecHits)(*(double*)arg[0]));
    else     (((const ::reco::HcalNoiseRBX*)o)->numRecHits)(*(double*)arg[0]);
  }
}

static  void method_28107( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::HcalNoiseRBX*)o)->caloTowerHadE)());
  else   (((const ::reco::HcalNoiseRBX*)o)->caloTowerHadE)();
}

static  void method_28108( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::HcalNoiseRBX*)o)->caloTowerEmE)());
  else   (((const ::reco::HcalNoiseRBX*)o)->caloTowerEmE)();
}

static  void method_28109( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::HcalNoiseRBX*)o)->caloTowerTotalE)());
  else   (((const ::reco::HcalNoiseRBX*)o)->caloTowerTotalE)();
}

static  void method_28110( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::HcalNoiseRBX*)o)->caloTowerEmFraction)());
  else   (((const ::reco::HcalNoiseRBX*)o)->caloTowerEmFraction)();
}

static void method_newdel_7976( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::reco::HcalNoiseRBX >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::reco::HcalNoiseRBX >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::reco::HcalNoiseRBX >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::reco::HcalNoiseRBX >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::reco::HcalNoiseRBX >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HcalNoiseRBX -------------------------------
void __reco__HcalNoiseRBX_db_datamem(Reflex::Class*);
void __reco__HcalNoiseRBX_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __reco__HcalNoiseRBX_datamem_bld(&__reco__HcalNoiseRBX_db_datamem);
Reflex::GenreflexMemberBuilder __reco__HcalNoiseRBX_funcmem_bld(&__reco__HcalNoiseRBX_db_funcmem);
void __reco__HcalNoiseRBX_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("reco::HcalNoiseRBX"), typeid(::reco::HcalNoiseRBX), sizeof(::reco::HcalNoiseRBX), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddTypedef(type_2729, Reflex::Literal("reco::HcalNoiseRBX::towerset_t"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14086, type_14088), Reflex::Literal("operator="), operator_28088, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14088), Reflex::Literal("HcalNoiseRBX"), constructor_28089, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HcalNoiseRBX"), constructor_28090, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HcalNoiseRBX"), destructor_28091, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_7976, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__reco__HcalNoiseRBX_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__reco__HcalNoiseRBX_funcmem_bld);
}

//------Delayed data member builder for class HcalNoiseRBX -------------------
void __reco__HcalNoiseRBX_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_72, Reflex::Literal("idnumber_"), OffsetOf(__shadow__::__reco__HcalNoiseRBX, idnumber_), ::Reflex::PRIVATE)
  .AddDataMember(type_3154, Reflex::Literal("hpds_"), OffsetOf(__shadow__::__reco__HcalNoiseRBX, hpds_), ::Reflex::PRIVATE)
  .AddDataMember(type_3165, Reflex::Literal("allCharge_"), OffsetOf(__shadow__::__reco__HcalNoiseRBX, allCharge_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class HcalNoiseRBX -------------------
void __reco__HcalNoiseRBX_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("idnumber"), method_28092, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3154c), Reflex::Literal("HPDs"), method_28093, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8190), Reflex::Literal("HPDsBegin"), method_28094, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8190), Reflex::Literal("HPDsEnd"), method_28095, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8190, type_107), Reflex::Literal("maxHPD"), method_28096, 0, "threshold=1.5e+0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3165c), Reflex::Literal("allCharge"), method_28097, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932), Reflex::Literal("allChargeTotal"), method_28098, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932, type_373), Reflex::Literal("allChargeHighest2TS"), method_28099, 0, "firstts=4", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_932, type_373), Reflex::Literal("allChargeHighest3TS"), method_28100, 0, "firstts=4", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("totalZeros"), method_28101, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("maxZeros"), method_28102, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107, type_107), Reflex::Literal("recHitEnergy"), method_28103, 0, "theshold=1.5e+0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107, type_107), Reflex::Literal("minRecHitTime"), method_28104, 0, "threshold=2.0e+1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107, type_107), Reflex::Literal("maxRecHitTime"), method_28105, 0, "threshold=2.0e+1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72, type_107), Reflex::Literal("numRecHits"), method_28106, 0, "threshold=1.5e+0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("caloTowerHadE"), method_28107, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("caloTowerEmE"), method_28108, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("caloTowerTotalE"), method_28109, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_107), Reflex::Literal("caloTowerEmFraction"), method_28110, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class MVAMEtJetInfo -------------------------------
static  void operator_28205( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::MVAMEtJetInfo*)o)->operator=)(*(const ::reco::MVAMEtJetInfo*)arg[0]);
  else   (((::reco::MVAMEtJetInfo*)o)->operator=)(*(const ::reco::MVAMEtJetInfo*)arg[0]);
}

static void constructor_28206( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::MVAMEtJetInfo(*(const ::reco::MVAMEtJetInfo*)arg[0]);
  else ::new(mem) ::reco::MVAMEtJetInfo(*(const ::reco::MVAMEtJetInfo*)arg[0]);
}

static void constructor_28207( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::MVAMEtJetInfo();
  else ::new(mem) ::reco::MVAMEtJetInfo();
}

static void destructor_28208(void*, void * o, const std::vector<void*>&, void *) {
(((::reco::MVAMEtJetInfo*)o)->::reco::MVAMEtJetInfo::~MVAMEtJetInfo)();
}
static void method_newdel_8009( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::reco::MVAMEtJetInfo >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::reco::MVAMEtJetInfo >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::reco::MVAMEtJetInfo >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::reco::MVAMEtJetInfo >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::reco::MVAMEtJetInfo >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class MVAMEtJetInfo -------------------------------
void __reco__MVAMEtJetInfo_db_datamem(Reflex::Class*);
void __reco__MVAMEtJetInfo_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __reco__MVAMEtJetInfo_datamem_bld(&__reco__MVAMEtJetInfo_db_datamem);
Reflex::GenreflexMemberBuilder __reco__MVAMEtJetInfo_funcmem_bld(&__reco__MVAMEtJetInfo_db_funcmem);
void __reco__MVAMEtJetInfo_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("reco::MVAMEtJetInfo"), typeid(::reco::MVAMEtJetInfo), sizeof(::reco::MVAMEtJetInfo), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddProperty(Reflex::Literal("ClassVersion"), "13")
  .AddEnum(Reflex::Literal("_195"), Reflex::Literal("kUndefined=0;kPileUp=1;kNoPileUp=2"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13308, type_13310), Reflex::Literal("operator="), operator_28205, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13310), Reflex::Literal("MVAMEtJetInfo"), constructor_28206, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("MVAMEtJetInfo"), constructor_28207, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~MVAMEtJetInfo"), destructor_28208, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_8009, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__reco__MVAMEtJetInfo_datamem_bld);
}

//------Delayed data member builder for class MVAMEtJetInfo -------------------
void __reco__MVAMEtJetInfo_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7319, Reflex::Literal("p4_"), OffsetOf(__shadow__::__reco__MVAMEtJetInfo, p4_), ::Reflex::PUBLIC)
  .AddDataMember(type_72, Reflex::Literal("type_"), OffsetOf(__shadow__::__reco__MVAMEtJetInfo, type_), ::Reflex::PUBLIC)
  .AddDataMember(type_1647, Reflex::Literal("passesLooseJetId_"), OffsetOf(__shadow__::__reco__MVAMEtJetInfo, passesLooseJetId_), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("neutralEnFrac_"), OffsetOf(__shadow__::__reco__MVAMEtJetInfo, neutralEnFrac_), ::Reflex::PUBLIC)
  .AddDataMember(type_107, Reflex::Literal("offsetEnCorr_"), OffsetOf(__shadow__::__reco__MVAMEtJetInfo, offsetEnCorr_), ::Reflex::PUBLIC)
  .AddDataMember(type_3824, Reflex::Literal("pfMEtSignObj_"), OffsetOf(__shadow__::__reco__MVAMEtJetInfo, pfMEtSignObj_), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class MVAMEtJetInfo -------------------
void __reco__MVAMEtJetInfo_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET, std::allocator<reco::PFClusterMET> >, reco::PFClusterMET, edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET, std::allocator<reco::PFClusterMET> >, reco::PFClusterMET> > > -------------------------------
static void constructor_34151( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >();
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >();
}

static void constructor_34152( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)arg[0]);
}

static void constructor_34153( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >(*(const ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >(*(const ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)arg[0]);
}

static  void operator_34154( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)arg[0]);
  else   (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)arg[0]);
}

static  void method_34155( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->swap)(*(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)arg[0]);
}

static void destructor_34156(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >::~Holder)();
}
static  void method_34157( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->clone)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->clone)();
}

static  void method_34158( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->getPtr)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->getPtr)();
}

static  void method_34159( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->id)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->id)();
}

static  void method_34160( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->key)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->key)();
}

static  void method_34161( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::Candidate>*)arg[0]));
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::Candidate>*)arg[0]);
}

static  void method_34162( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->getRef)();
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->getRef)();
}

static  void method_34163( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_34164( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefHolderBase>)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->holder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->holder)();
}

static  void method_34165( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::BaseVectorHolder<reco::Candidate> >)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->makeVectorHolder)();
}

static  void method_34166( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->makeVectorBaseHolder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->makeVectorBaseHolder)();
}

static  void method_34167( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->productGetter)();
}

static  void method_34168( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->hasProductCache)();
}

static  void method_34169( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->product)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->product)();
}

static  void method_34170( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->isAvailable)();
}

static  void method_34171( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->Class_Version)());
  else   (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->Class_Version)();
}

static void method_newdel_21302( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x125( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseHolder<reco::Candidate>")), ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >,::edm::reftobase::BaseHolder<reco::Candidate> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET, std::allocator<reco::PFClusterMET> >, reco::PFClusterMET, edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET, std::allocator<reco::PFClusterMET> >, reco::PFClusterMET> > > -------------------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_s__datamem_bld(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_s__funcmem_bld(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_s__db_funcmem);
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >"), typeid(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >), sizeof(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >::Class_Version())
  .AddBase(type_21290, ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >, ::edm::reftobase::BaseHolder<reco::Candidate> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Holder"), constructor_34151, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_40760), Reflex::Literal("Holder"), constructor_34152, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33824), Reflex::Literal("Holder"), constructor_34153, 0, "r", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Holder"), destructor_34156, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_21302, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x125, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_s__funcmem_bld);
}

//------Delayed data member builder for class Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET, std::allocator<reco::PFClusterMET> >, reco::PFClusterMET, edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET, std::allocator<reco::PFClusterMET> >, reco::PFClusterMET> > > -------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4915, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET, std::allocator<reco::PFClusterMET> >, reco::PFClusterMET, edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET, std::allocator<reco::PFClusterMET> >, reco::PFClusterMET> > > -------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_40761, type_40760), Reflex::Literal("operator="), operator_34154, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_40761), Reflex::Literal("swap"), method_34155, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_34376), Reflex::Literal("clone"), method_34157, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_34381), Reflex::Literal("getPtr"), method_34158, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4866), Reflex::Literal("id"), method_34159, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2197), Reflex::Literal("key"), method_34160, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647, type_40743), Reflex::Literal("isEqualTo"), method_34161, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33824), Reflex::Literal("getRef"), method_34162, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647, type_21585, type_10457), Reflex::Literal("fillRefIfMyTypeMatches"), method_34163, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2897), Reflex::Literal("holder"), method_34164, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2896), Reflex::Literal("makeVectorHolder"), method_34165, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("makeVectorBaseHolder"), method_34166, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19828), Reflex::Literal("productGetter"), method_34167, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("hasProductCache"), method_34168, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4239), Reflex::Literal("product"), method_34169, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isAvailable"), method_34170, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_192), Reflex::Literal("Class_Version"), method_34171, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET, std::allocator<reco::PFMET> >, reco::PFMET, edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET, std::allocator<reco::PFMET> >, reco::PFMET> > > -------------------------------
static void constructor_34173( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >();
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >();
}

static void constructor_34174( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)arg[0]);
}

static void constructor_34175( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >(*(const ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >(*(const ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)arg[0]);
}

static  void operator_34176( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)arg[0]);
  else   (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)arg[0]);
}

static  void method_34177( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->swap)(*(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)arg[0]);
}

static void destructor_34178(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >::~Holder)();
}
static  void method_34179( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->clone)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->clone)();
}

static  void method_34180( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->getPtr)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->getPtr)();
}

static  void method_34181( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->id)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->id)();
}

static  void method_34182( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->key)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->key)();
}

static  void method_34183( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::Candidate>*)arg[0]));
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::Candidate>*)arg[0]);
}

static  void method_34184( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->getRef)();
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->getRef)();
}

static  void method_34185( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_34186( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefHolderBase>)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->holder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->holder)();
}

static  void method_34187( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::BaseVectorHolder<reco::Candidate> >)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->makeVectorHolder)();
}

static  void method_34188( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->makeVectorBaseHolder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->makeVectorBaseHolder)();
}

static  void method_34189( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->productGetter)();
}

static  void method_34190( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->hasProductCache)();
}

static  void method_34191( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->product)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->product)();
}

static  void method_34192( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->isAvailable)();
}

static  void method_34193( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->Class_Version)());
  else   (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->Class_Version)();
}

static void method_newdel_21303( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x127( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseHolder<reco::Candidate>")), ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >,::edm::reftobase::BaseHolder<reco::Candidate> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET, std::allocator<reco::PFMET> >, reco::PFMET, edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET, std::allocator<reco::PFMET> >, reco::PFMET> > > -------------------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_s__datamem_bld(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_s__funcmem_bld(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_s__db_funcmem);
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >"), typeid(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >), sizeof(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >::Class_Version())
  .AddBase(type_21290, ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >, ::edm::reftobase::BaseHolder<reco::Candidate> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Holder"), constructor_34173, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_40762), Reflex::Literal("Holder"), constructor_34174, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33830), Reflex::Literal("Holder"), constructor_34175, 0, "r", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Holder"), destructor_34178, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_21303, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x127, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_s__funcmem_bld);
}

//------Delayed data member builder for class Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET, std::allocator<reco::PFMET> >, reco::PFMET, edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET, std::allocator<reco::PFMET> >, reco::PFMET> > > -------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4916, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET, std::allocator<reco::PFMET> >, reco::PFMET, edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET, std::allocator<reco::PFMET> >, reco::PFMET> > > -------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_40763, type_40762), Reflex::Literal("operator="), operator_34176, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_40763), Reflex::Literal("swap"), method_34177, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_34376), Reflex::Literal("clone"), method_34179, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_34381), Reflex::Literal("getPtr"), method_34180, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4866), Reflex::Literal("id"), method_34181, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2197), Reflex::Literal("key"), method_34182, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647, type_40743), Reflex::Literal("isEqualTo"), method_34183, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33830), Reflex::Literal("getRef"), method_34184, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647, type_21585, type_10457), Reflex::Literal("fillRefIfMyTypeMatches"), method_34185, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2897), Reflex::Literal("holder"), method_34186, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2896), Reflex::Literal("makeVectorHolder"), method_34187, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("makeVectorBaseHolder"), method_34188, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19828), Reflex::Literal("productGetter"), method_34189, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("hasProductCache"), method_34190, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4239), Reflex::Literal("product"), method_34191, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isAvailable"), method_34192, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_192), Reflex::Literal("Class_Version"), method_34193, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Holder<reco::Candidate,edm::Ref<std::vector<reco::MET, std::allocator<reco::MET> >, reco::MET, edm::refhelper::FindUsingAdvance<std::vector<reco::MET, std::allocator<reco::MET> >, reco::MET> > > -------------------------------
static void constructor_34195( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >();
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >();
}

static void constructor_34196( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)arg[0]);
}

static void constructor_34197( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >(*(const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >(*(const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)arg[0]);
}

static  void operator_34198( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)arg[0]);
  else   (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)arg[0]);
}

static  void method_34199( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->swap)(*(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)arg[0]);
}

static void destructor_34200(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >::~Holder)();
}
static  void method_34201( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->clone)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->clone)();
}

static  void method_34202( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->getPtr)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->getPtr)();
}

static  void method_34203( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->id)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->id)();
}

static  void method_34204( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->key)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->key)();
}

static  void method_34205( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::Candidate>*)arg[0]));
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::Candidate>*)arg[0]);
}

static  void method_34206( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->getRef)();
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->getRef)();
}

static  void method_34207( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_34208( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefHolderBase>)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->holder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->holder)();
}

static  void method_34209( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::BaseVectorHolder<reco::Candidate> >)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->makeVectorHolder)();
}

static  void method_34210( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->makeVectorBaseHolder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->makeVectorBaseHolder)();
}

static  void method_34211( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->productGetter)();
}

static  void method_34212( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->hasProductCache)();
}

static  void method_34213( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->product)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->product)();
}

static  void method_34214( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->isAvailable)();
}

static  void method_34215( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->Class_Version)());
  else   (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->Class_Version)();
}

static void method_newdel_21304( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x129( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseHolder<reco::Candidate>")), ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >,::edm::reftobase::BaseHolder<reco::Candidate> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Holder<reco::Candidate,edm::Ref<std::vector<reco::MET, std::allocator<reco::MET> >, reco::MET, edm::refhelper::FindUsingAdvance<std::vector<reco::MET, std::allocator<reco::MET> >, reco::MET> > > -------------------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s__datamem_bld(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s__funcmem_bld(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s__db_funcmem);
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >"), typeid(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >), sizeof(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >::Class_Version())
  .AddBase(type_21290, ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >, ::edm::reftobase::BaseHolder<reco::Candidate> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Holder"), constructor_34195, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_40764), Reflex::Literal("Holder"), constructor_34196, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13570), Reflex::Literal("Holder"), constructor_34197, 0, "r", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Holder"), destructor_34200, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_21304, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x129, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s__funcmem_bld);
}

//------Delayed data member builder for class Holder<reco::Candidate,edm::Ref<std::vector<reco::MET, std::allocator<reco::MET> >, reco::MET, edm::refhelper::FindUsingAdvance<std::vector<reco::MET, std::allocator<reco::MET> >, reco::MET> > > -------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4913, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Holder<reco::Candidate,edm::Ref<std::vector<reco::MET, std::allocator<reco::MET> >, reco::MET, edm::refhelper::FindUsingAdvance<std::vector<reco::MET, std::allocator<reco::MET> >, reco::MET> > > -------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_40765, type_40764), Reflex::Literal("operator="), operator_34198, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_40765), Reflex::Literal("swap"), method_34199, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_34376), Reflex::Literal("clone"), method_34201, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_34381), Reflex::Literal("getPtr"), method_34202, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4866), Reflex::Literal("id"), method_34203, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2197), Reflex::Literal("key"), method_34204, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647, type_40743), Reflex::Literal("isEqualTo"), method_34205, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13570), Reflex::Literal("getRef"), method_34206, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647, type_21585, type_10457), Reflex::Literal("fillRefIfMyTypeMatches"), method_34207, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2897), Reflex::Literal("holder"), method_34208, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2896), Reflex::Literal("makeVectorHolder"), method_34209, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("makeVectorBaseHolder"), method_34210, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19828), Reflex::Literal("productGetter"), method_34211, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("hasProductCache"), method_34212, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4239), Reflex::Literal("product"), method_34213, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isAvailable"), method_34214, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_192), Reflex::Literal("Class_Version"), method_34215, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET, std::allocator<reco::GenMET> >, reco::GenMET, edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET, std::allocator<reco::GenMET> >, reco::GenMET> > > -------------------------------
static void constructor_34217( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >();
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >();
}

static void constructor_34218( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)arg[0]);
}

static void constructor_34219( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >(*(const ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >(*(const ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)arg[0]);
}

static  void operator_34220( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)arg[0]);
  else   (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)arg[0]);
}

static  void method_34221( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->swap)(*(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)arg[0]);
}

static void destructor_34222(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >::~Holder)();
}
static  void method_34223( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->clone)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->clone)();
}

static  void method_34224( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->getPtr)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->getPtr)();
}

static  void method_34225( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->id)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->id)();
}

static  void method_34226( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->key)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->key)();
}

static  void method_34227( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::Candidate>*)arg[0]));
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::Candidate>*)arg[0]);
}

static  void method_34228( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->getRef)();
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->getRef)();
}

static  void method_34229( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_34230( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefHolderBase>)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->holder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->holder)();
}

static  void method_34231( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::BaseVectorHolder<reco::Candidate> >)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->makeVectorHolder)();
}

static  void method_34232( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->makeVectorBaseHolder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->makeVectorBaseHolder)();
}

static  void method_34233( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->productGetter)();
}

static  void method_34234( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->hasProductCache)();
}

static  void method_34235( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->product)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->product)();
}

static  void method_34236( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->isAvailable)();
}

static  void method_34237( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->Class_Version)());
  else   (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->Class_Version)();
}

static void method_newdel_21305( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x131( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseHolder<reco::Candidate>")), ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >,::edm::reftobase::BaseHolder<reco::Candidate> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET, std::allocator<reco::GenMET> >, reco::GenMET, edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET, std::allocator<reco::GenMET> >, reco::GenMET> > > -------------------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_s__datamem_bld(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_s__funcmem_bld(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_s__db_funcmem);
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >"), typeid(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >), sizeof(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >::Class_Version())
  .AddBase(type_21290, ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >, ::edm::reftobase::BaseHolder<reco::Candidate> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Holder"), constructor_34217, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_40766), Reflex::Literal("Holder"), constructor_34218, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33840), Reflex::Literal("Holder"), constructor_34219, 0, "r", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Holder"), destructor_34222, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_21305, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x131, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_s__funcmem_bld);
}

//------Delayed data member builder for class Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET, std::allocator<reco::GenMET> >, reco::GenMET, edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET, std::allocator<reco::GenMET> >, reco::GenMET> > > -------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4917, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET, std::allocator<reco::GenMET> >, reco::GenMET, edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET, std::allocator<reco::GenMET> >, reco::GenMET> > > -------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_40767, type_40766), Reflex::Literal("operator="), operator_34220, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_40767), Reflex::Literal("swap"), method_34221, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_34376), Reflex::Literal("clone"), method_34223, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_34381), Reflex::Literal("getPtr"), method_34224, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4866), Reflex::Literal("id"), method_34225, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2197), Reflex::Literal("key"), method_34226, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647, type_40743), Reflex::Literal("isEqualTo"), method_34227, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33840), Reflex::Literal("getRef"), method_34228, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647, type_21585, type_10457), Reflex::Literal("fillRefIfMyTypeMatches"), method_34229, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2897), Reflex::Literal("holder"), method_34230, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2896), Reflex::Literal("makeVectorHolder"), method_34231, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("makeVectorBaseHolder"), method_34232, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19828), Reflex::Literal("productGetter"), method_34233, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("hasProductCache"), method_34234, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4239), Reflex::Literal("product"), method_34235, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isAvailable"), method_34236, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_192), Reflex::Literal("Class_Version"), method_34237, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >, reco::CaloMET, edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >, reco::CaloMET> > > -------------------------------
static void constructor_34239( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >();
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >();
}

static void constructor_34240( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)arg[0]);
}

static void constructor_34241( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >(*(const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)arg[0]);
  else ::new(mem) ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >(*(const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)arg[0]);
}

static  void operator_34242( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)arg[0]);
  else   (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->operator=)(*(const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)arg[0]);
}

static  void method_34243( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->swap)(*(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)arg[0]);
}

static void destructor_34244(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >::~Holder)();
}
static  void method_34245( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->clone)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->clone)();
}

static  void method_34246( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->getPtr)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->getPtr)();
}

static  void method_34247( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->id)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->id)();
}

static  void method_34248( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->key)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->key)();
}

static  void method_34249( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::Candidate>*)arg[0]));
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->isEqualTo)(*(const ::edm::reftobase::BaseHolder<reco::Candidate>*)arg[0]);
}

static  void method_34250( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->getRef)();
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->getRef)();
}

static  void method_34251( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_34252( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefHolderBase>)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->holder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->holder)();
}

static  void method_34253( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::BaseVectorHolder<reco::Candidate> >)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->makeVectorHolder)();
}

static  void method_34254( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->makeVectorBaseHolder)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->makeVectorBaseHolder)();
}

static  void method_34255( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->productGetter)();
}

static  void method_34256( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->hasProductCache)();
}

static  void method_34257( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->product)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->product)();
}

static  void method_34258( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->isAvailable)();
}

static  void method_34259( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->Class_Version)());
  else   (((::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->Class_Version)();
}

static void method_newdel_21306( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x133( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::BaseHolder<reco::Candidate>")), ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >,::edm::reftobase::BaseHolder<reco::Candidate> >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >, reco::CaloMET, edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >, reco::CaloMET> > > -------------------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s__datamem_bld(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s__funcmem_bld(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s__db_funcmem);
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >"), typeid(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >), sizeof(::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >::Class_Version())
  .AddBase(type_21290, ::Reflex::BaseOffset< ::edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >, ::edm::reftobase::BaseHolder<reco::Candidate> >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Holder"), constructor_34239, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_40768), Reflex::Literal("Holder"), constructor_34240, 0, "other", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13700), Reflex::Literal("Holder"), constructor_34241, 0, "r", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Holder"), destructor_34244, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_21306, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x133, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s__funcmem_bld);
}

//------Delayed data member builder for class Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >, reco::CaloMET, edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >, reco::CaloMET> > > -------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4914, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >, reco::CaloMET, edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >, reco::CaloMET> > > -------------------
void __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_40769, type_40768), Reflex::Literal("operator="), operator_34242, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_40769), Reflex::Literal("swap"), method_34243, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_34376), Reflex::Literal("clone"), method_34245, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_34381), Reflex::Literal("getPtr"), method_34246, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4866), Reflex::Literal("id"), method_34247, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2197), Reflex::Literal("key"), method_34248, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647, type_40743), Reflex::Literal("isEqualTo"), method_34249, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13700), Reflex::Literal("getRef"), method_34250, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647, type_21585, type_10457), Reflex::Literal("fillRefIfMyTypeMatches"), method_34251, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2897), Reflex::Literal("holder"), method_34252, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2896), Reflex::Literal("makeVectorHolder"), method_34253, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("makeVectorBaseHolder"), method_34254, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19828), Reflex::Literal("productGetter"), method_34255, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("hasProductCache"), method_34256, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4239), Reflex::Literal("product"), method_34257, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isAvailable"), method_34258, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_192), Reflex::Literal("Class_Version"), method_34259, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class vector<reco::MVAMEtPFCandInfo,std::allocator<reco::MVAMEtPFCandInfo> > -------------------------------
static void constructor_13254( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::MVAMEtPFCandInfo>();
  else ::new(mem) ::std::vector<reco::MVAMEtPFCandInfo>();
}

static void constructor_13255( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::MVAMEtPFCandInfo>(*(const ::std::allocator<reco::MVAMEtPFCandInfo>*)arg[0]);
  else ::new(mem) ::std::vector<reco::MVAMEtPFCandInfo>(*(const ::std::allocator<reco::MVAMEtPFCandInfo>*)arg[0]);
}

static void constructor_13256( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::MVAMEtPFCandInfo>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<reco::MVAMEtPFCandInfo>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::MVAMEtPFCandInfo>(*(::std::size_t*)arg[0],
      *(const ::reco::MVAMEtPFCandInfo*)arg[1]);
  else ::new(mem) ::std::vector<reco::MVAMEtPFCandInfo>(*(::std::size_t*)arg[0],
      *(const ::reco::MVAMEtPFCandInfo*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::MVAMEtPFCandInfo>(*(::std::size_t*)arg[0],
      *(const ::reco::MVAMEtPFCandInfo*)arg[1],
      *(const ::std::allocator<reco::MVAMEtPFCandInfo>*)arg[2]);
  else ::new(mem) ::std::vector<reco::MVAMEtPFCandInfo>(*(::std::size_t*)arg[0],
      *(const ::reco::MVAMEtPFCandInfo*)arg[1],
      *(const ::std::allocator<reco::MVAMEtPFCandInfo>*)arg[2]);
  }
}

static void constructor_13257( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::MVAMEtPFCandInfo>(*(const ::std::vector<reco::MVAMEtPFCandInfo>*)arg[0]);
  else ::new(mem) ::std::vector<reco::MVAMEtPFCandInfo>(*(const ::std::vector<reco::MVAMEtPFCandInfo>*)arg[0]);
}

static void destructor_13258(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<reco::MVAMEtPFCandInfo>*)o)->::std::vector<reco::MVAMEtPFCandInfo>::~vector)();
}
static  void operator_13259( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::MVAMEtPFCandInfo>*)o)->operator=)(*(const ::std::vector<reco::MVAMEtPFCandInfo>*)arg[0]);
  else   (((::std::vector<reco::MVAMEtPFCandInfo>*)o)->operator=)(*(const ::std::vector<reco::MVAMEtPFCandInfo>*)arg[0]);
}

static  void method_13260( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::MVAMEtPFCandInfo>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::reco::MVAMEtPFCandInfo*)arg[1]);
}

static  void method_13261( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::MVAMEtPFCandInfo*,std::vector<reco::MVAMEtPFCandInfo> >)((((::std::vector<reco::MVAMEtPFCandInfo>*)o)->begin)());
  else   (((::std::vector<reco::MVAMEtPFCandInfo>*)o)->begin)();
}

static  void method_13262( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::MVAMEtPFCandInfo*,std::vector<reco::MVAMEtPFCandInfo> >)((((const ::std::vector<reco::MVAMEtPFCandInfo>*)o)->begin)());
  else   (((const ::std::vector<reco::MVAMEtPFCandInfo>*)o)->begin)();
}

static  void method_13263( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::MVAMEtPFCandInfo*,std::vector<reco::MVAMEtPFCandInfo> >)((((::std::vector<reco::MVAMEtPFCandInfo>*)o)->end)());
  else   (((::std::vector<reco::MVAMEtPFCandInfo>*)o)->end)();
}

static  void method_13264( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::MVAMEtPFCandInfo*,std::vector<reco::MVAMEtPFCandInfo> >)((((const ::std::vector<reco::MVAMEtPFCandInfo>*)o)->end)());
  else   (((const ::std::vector<reco::MVAMEtPFCandInfo>*)o)->end)();
}

static  void method_13269( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::MVAMEtPFCandInfo>*)o)->size)());
  else   (((const ::std::vector<reco::MVAMEtPFCandInfo>*)o)->size)();
}

static  void method_13270( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::MVAMEtPFCandInfo>*)o)->max_size)());
  else   (((const ::std::vector<reco::MVAMEtPFCandInfo>*)o)->max_size)();
}

static  void method_13271( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<reco::MVAMEtPFCandInfo>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<reco::MVAMEtPFCandInfo>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::reco::MVAMEtPFCandInfo*)arg[1]);
  }
}

static  void method_13272( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::MVAMEtPFCandInfo>*)o)->capacity)());
  else   (((const ::std::vector<reco::MVAMEtPFCandInfo>*)o)->capacity)();
}

static  void method_13273( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<reco::MVAMEtPFCandInfo>*)o)->empty)());
  else   (((const ::std::vector<reco::MVAMEtPFCandInfo>*)o)->empty)();
}

static  void method_13274( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::MVAMEtPFCandInfo>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_13275( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::MVAMEtPFCandInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::MVAMEtPFCandInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_13276( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::MVAMEtPFCandInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::MVAMEtPFCandInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_13278( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::MVAMEtPFCandInfo>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::MVAMEtPFCandInfo>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13279( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::MVAMEtPFCandInfo>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::MVAMEtPFCandInfo>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13280( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::MVAMEtPFCandInfo>*)o)->front)();
  else   (((::std::vector<reco::MVAMEtPFCandInfo>*)o)->front)();
}

static  void method_13281( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::MVAMEtPFCandInfo>*)o)->front)();
  else   (((const ::std::vector<reco::MVAMEtPFCandInfo>*)o)->front)();
}

static  void method_13282( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::MVAMEtPFCandInfo>*)o)->back)();
  else   (((::std::vector<reco::MVAMEtPFCandInfo>*)o)->back)();
}

static  void method_13283( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::MVAMEtPFCandInfo>*)o)->back)();
  else   (((const ::std::vector<reco::MVAMEtPFCandInfo>*)o)->back)();
}

static  void method_13284( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<reco::MVAMEtPFCandInfo>*)o)->data)());
  else   (((::std::vector<reco::MVAMEtPFCandInfo>*)o)->data)();
}

static  void method_13285( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<reco::MVAMEtPFCandInfo>*)o)->data)());
  else   (((const ::std::vector<reco::MVAMEtPFCandInfo>*)o)->data)();
}

static  void method_13286( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::MVAMEtPFCandInfo>*)o)->push_back)(*(const ::reco::MVAMEtPFCandInfo*)arg[0]);
}

static  void method_13287( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::MVAMEtPFCandInfo>*)o)->pop_back)();
}

static  void method_13288( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::MVAMEtPFCandInfo*,std::vector<reco::MVAMEtPFCandInfo> >)((((::std::vector<reco::MVAMEtPFCandInfo>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::MVAMEtPFCandInfo*,std::vector<reco::MVAMEtPFCandInfo> >*)arg[0],
    *(const ::reco::MVAMEtPFCandInfo*)arg[1]));
  else   (((::std::vector<reco::MVAMEtPFCandInfo>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::MVAMEtPFCandInfo*,std::vector<reco::MVAMEtPFCandInfo> >*)arg[0],
    *(const ::reco::MVAMEtPFCandInfo*)arg[1]);
}

static  void method_13289( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::MVAMEtPFCandInfo>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::MVAMEtPFCandInfo*,std::vector<reco::MVAMEtPFCandInfo> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::reco::MVAMEtPFCandInfo*)arg[2]);
}

static  void method_13290( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::MVAMEtPFCandInfo*,std::vector<reco::MVAMEtPFCandInfo> >)((((::std::vector<reco::MVAMEtPFCandInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::MVAMEtPFCandInfo*,std::vector<reco::MVAMEtPFCandInfo> >*)arg[0]));
  else   (((::std::vector<reco::MVAMEtPFCandInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::MVAMEtPFCandInfo*,std::vector<reco::MVAMEtPFCandInfo> >*)arg[0]);
}

static  void method_13291( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::MVAMEtPFCandInfo*,std::vector<reco::MVAMEtPFCandInfo> >)((((::std::vector<reco::MVAMEtPFCandInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::MVAMEtPFCandInfo*,std::vector<reco::MVAMEtPFCandInfo> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::MVAMEtPFCandInfo*,std::vector<reco::MVAMEtPFCandInfo> >*)arg[1]));
  else   (((::std::vector<reco::MVAMEtPFCandInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::MVAMEtPFCandInfo*,std::vector<reco::MVAMEtPFCandInfo> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::MVAMEtPFCandInfo*,std::vector<reco::MVAMEtPFCandInfo> >*)arg[1]);
}

static  void method_13292( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::MVAMEtPFCandInfo>*)o)->swap)(*(::std::vector<reco::MVAMEtPFCandInfo>*)arg[0]);
}

static  void method_13293( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::MVAMEtPFCandInfo>*)o)->clear)();
}

static void method_newdel_3140( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<reco::MVAMEtPFCandInfo> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<reco::MVAMEtPFCandInfo> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<reco::MVAMEtPFCandInfo> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<reco::MVAMEtPFCandInfo> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<reco::MVAMEtPFCandInfo> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x135( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::MVAMEtPFCandInfo,std::allocator<reco::MVAMEtPFCandInfo> >")), ::Reflex::BaseOffset< ::std::vector<reco::MVAMEtPFCandInfo>,::std::_Vector_base<reco::MVAMEtPFCandInfo,std::allocator<reco::MVAMEtPFCandInfo> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x136( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<reco::MVAMEtPFCandInfo> >::Generate();
  else ::Reflex::Proxy< ::std::vector<reco::MVAMEtPFCandInfo> >::Generate();
}

//------Dictionary for class vector<reco::MVAMEtPFCandInfo,std::allocator<reco::MVAMEtPFCandInfo> > -------------------------------
void __std__vector_reco__MVAMEtPFCandInfo__db_datamem(Reflex::Class*);
void __std__vector_reco__MVAMEtPFCandInfo__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_reco__MVAMEtPFCandInfo__datamem_bld(&__std__vector_reco__MVAMEtPFCandInfo__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_reco__MVAMEtPFCandInfo__funcmem_bld(&__std__vector_reco__MVAMEtPFCandInfo__db_funcmem);
void __std__vector_reco__MVAMEtPFCandInfo__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<reco::MVAMEtPFCandInfo>"), typeid(::std::vector<reco::MVAMEtPFCandInfo>), sizeof(::std::vector<reco::MVAMEtPFCandInfo>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2589, ::Reflex::BaseOffset< ::std::vector<reco::MVAMEtPFCandInfo>, ::std::_Vector_base<reco::MVAMEtPFCandInfo,std::allocator<reco::MVAMEtPFCandInfo> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_7941, Reflex::Literal("std::vector<reco::MVAMEtPFCandInfo>::_Alloc_value_type"))
  .AddTypedef(type_2589, Reflex::Literal("std::vector<reco::MVAMEtPFCandInfo>::_Base"))
  .AddTypedef(type_3410, Reflex::Literal("std::vector<reco::MVAMEtPFCandInfo>::_Tp_alloc_type"))
  .AddTypedef(type_7941, Reflex::Literal("std::vector<reco::MVAMEtPFCandInfo>::value_type"))
  .AddTypedef(type_13239, Reflex::Literal("std::vector<reco::MVAMEtPFCandInfo>::pointer"))
  .AddTypedef(type_13241, Reflex::Literal("std::vector<reco::MVAMEtPFCandInfo>::const_pointer"))
  .AddTypedef(type_13243, Reflex::Literal("std::vector<reco::MVAMEtPFCandInfo>::reference"))
  .AddTypedef(type_13245, Reflex::Literal("std::vector<reco::MVAMEtPFCandInfo>::const_reference"))
  .AddTypedef(type_8148, Reflex::Literal("std::vector<reco::MVAMEtPFCandInfo>::iterator"))
  .AddTypedef(type_8149, Reflex::Literal("std::vector<reco::MVAMEtPFCandInfo>::const_iterator"))
  .AddTypedef(type_3595, Reflex::Literal("std::vector<reco::MVAMEtPFCandInfo>::const_reverse_iterator"))
  .AddTypedef(type_3596, Reflex::Literal("std::vector<reco::MVAMEtPFCandInfo>::reverse_iterator"))
  .AddTypedef(type_3394, Reflex::Literal("std::vector<reco::MVAMEtPFCandInfo>::size_type"))
  .AddTypedef(type_3290, Reflex::Literal("std::vector<reco::MVAMEtPFCandInfo>::difference_type"))
  .AddTypedef(type_3410, Reflex::Literal("std::vector<reco::MVAMEtPFCandInfo>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_13254, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31597), Reflex::Literal("vector"), constructor_13255, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3394, type_13245, type_31597), Reflex::Literal("vector"), constructor_13256, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32795), Reflex::Literal("vector"), constructor_13257, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_13258, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3140, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x135, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x136, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_reco__MVAMEtPFCandInfo__funcmem_bld);
}

//------Delayed data member builder for class vector<reco::MVAMEtPFCandInfo,std::allocator<reco::MVAMEtPFCandInfo> > -------------------
void __std__vector_reco__MVAMEtPFCandInfo__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<reco::MVAMEtPFCandInfo,std::allocator<reco::MVAMEtPFCandInfo> > -------------------
void __std__vector_reco__MVAMEtPFCandInfo__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32796, type_32795), Reflex::Literal("operator="), operator_13259, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394, type_13245), Reflex::Literal("assign"), method_13260, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8148), Reflex::Literal("begin"), method_13261, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8149), Reflex::Literal("begin"), method_13262, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8148), Reflex::Literal("end"), method_13263, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8149), Reflex::Literal("end"), method_13264, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("size"), method_13269, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("max_size"), method_13270, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394, type_7941), Reflex::Literal("resize"), method_13271, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("capacity"), method_13272, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("empty"), method_13273, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394), Reflex::Literal("reserve"), method_13274, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13243, type_3394), Reflex::Literal("operator[]"), operator_13275, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13245, type_3394), Reflex::Literal("operator[]"), operator_13276, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13243, type_3394), Reflex::Literal("at"), method_13278, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13245, type_3394), Reflex::Literal("at"), method_13279, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13243), Reflex::Literal("front"), method_13280, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13245), Reflex::Literal("front"), method_13281, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13243), Reflex::Literal("back"), method_13282, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13245), Reflex::Literal("back"), method_13283, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13239), Reflex::Literal("data"), method_13284, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13241), Reflex::Literal("data"), method_13285, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_13245), Reflex::Literal("push_back"), method_13286, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("pop_back"), method_13287, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8148, type_8148, type_13245), Reflex::Literal("insert"), method_13288, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_8148, type_3394, type_13245), Reflex::Literal("insert"), method_13289, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8148, type_8148), Reflex::Literal("erase"), method_13290, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8148, type_8148, type_8148), Reflex::Literal("erase"), method_13291, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_32796), Reflex::Literal("swap"), method_13292, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("clear"), method_13293, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<reco::HcalNoiseRBX,std::allocator<reco::HcalNoiseRBX> > -------------------------------
static void constructor_14097( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::HcalNoiseRBX>();
  else ::new(mem) ::std::vector<reco::HcalNoiseRBX>();
}

static void constructor_14098( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::HcalNoiseRBX>(*(const ::std::allocator<reco::HcalNoiseRBX>*)arg[0]);
  else ::new(mem) ::std::vector<reco::HcalNoiseRBX>(*(const ::std::allocator<reco::HcalNoiseRBX>*)arg[0]);
}

static void constructor_14099( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::HcalNoiseRBX>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<reco::HcalNoiseRBX>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::HcalNoiseRBX>(*(::std::size_t*)arg[0],
      *(const ::reco::HcalNoiseRBX*)arg[1]);
  else ::new(mem) ::std::vector<reco::HcalNoiseRBX>(*(::std::size_t*)arg[0],
      *(const ::reco::HcalNoiseRBX*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::HcalNoiseRBX>(*(::std::size_t*)arg[0],
      *(const ::reco::HcalNoiseRBX*)arg[1],
      *(const ::std::allocator<reco::HcalNoiseRBX>*)arg[2]);
  else ::new(mem) ::std::vector<reco::HcalNoiseRBX>(*(::std::size_t*)arg[0],
      *(const ::reco::HcalNoiseRBX*)arg[1],
      *(const ::std::allocator<reco::HcalNoiseRBX>*)arg[2]);
  }
}

static void constructor_14100( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::HcalNoiseRBX>(*(const ::std::vector<reco::HcalNoiseRBX>*)arg[0]);
  else ::new(mem) ::std::vector<reco::HcalNoiseRBX>(*(const ::std::vector<reco::HcalNoiseRBX>*)arg[0]);
}

static void destructor_14101(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<reco::HcalNoiseRBX>*)o)->::std::vector<reco::HcalNoiseRBX>::~vector)();
}
static  void operator_14102( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::HcalNoiseRBX>*)o)->operator=)(*(const ::std::vector<reco::HcalNoiseRBX>*)arg[0]);
  else   (((::std::vector<reco::HcalNoiseRBX>*)o)->operator=)(*(const ::std::vector<reco::HcalNoiseRBX>*)arg[0]);
}

static  void method_14103( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::HcalNoiseRBX>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::reco::HcalNoiseRBX*)arg[1]);
}

static  void method_14104( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::HcalNoiseRBX*,std::vector<reco::HcalNoiseRBX> >)((((::std::vector<reco::HcalNoiseRBX>*)o)->begin)());
  else   (((::std::vector<reco::HcalNoiseRBX>*)o)->begin)();
}

static  void method_14105( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::HcalNoiseRBX*,std::vector<reco::HcalNoiseRBX> >)((((const ::std::vector<reco::HcalNoiseRBX>*)o)->begin)());
  else   (((const ::std::vector<reco::HcalNoiseRBX>*)o)->begin)();
}

static  void method_14106( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::HcalNoiseRBX*,std::vector<reco::HcalNoiseRBX> >)((((::std::vector<reco::HcalNoiseRBX>*)o)->end)());
  else   (((::std::vector<reco::HcalNoiseRBX>*)o)->end)();
}

static  void method_14107( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::HcalNoiseRBX*,std::vector<reco::HcalNoiseRBX> >)((((const ::std::vector<reco::HcalNoiseRBX>*)o)->end)());
  else   (((const ::std::vector<reco::HcalNoiseRBX>*)o)->end)();
}

static  void method_14112( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::HcalNoiseRBX>*)o)->size)());
  else   (((const ::std::vector<reco::HcalNoiseRBX>*)o)->size)();
}

static  void method_14113( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::HcalNoiseRBX>*)o)->max_size)());
  else   (((const ::std::vector<reco::HcalNoiseRBX>*)o)->max_size)();
}

static  void method_14114( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<reco::HcalNoiseRBX>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<reco::HcalNoiseRBX>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::reco::HcalNoiseRBX*)arg[1]);
  }
}

static  void method_14115( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::HcalNoiseRBX>*)o)->capacity)());
  else   (((const ::std::vector<reco::HcalNoiseRBX>*)o)->capacity)();
}

static  void method_14116( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<reco::HcalNoiseRBX>*)o)->empty)());
  else   (((const ::std::vector<reco::HcalNoiseRBX>*)o)->empty)();
}

static  void method_14117( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::HcalNoiseRBX>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_14118( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::HcalNoiseRBX>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::HcalNoiseRBX>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_14119( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::HcalNoiseRBX>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::HcalNoiseRBX>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_14121( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::HcalNoiseRBX>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::HcalNoiseRBX>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14122( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::HcalNoiseRBX>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::HcalNoiseRBX>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14123( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::HcalNoiseRBX>*)o)->front)();
  else   (((::std::vector<reco::HcalNoiseRBX>*)o)->front)();
}

static  void method_14124( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::HcalNoiseRBX>*)o)->front)();
  else   (((const ::std::vector<reco::HcalNoiseRBX>*)o)->front)();
}

static  void method_14125( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::HcalNoiseRBX>*)o)->back)();
  else   (((::std::vector<reco::HcalNoiseRBX>*)o)->back)();
}

static  void method_14126( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::HcalNoiseRBX>*)o)->back)();
  else   (((const ::std::vector<reco::HcalNoiseRBX>*)o)->back)();
}

static  void method_14127( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<reco::HcalNoiseRBX>*)o)->data)());
  else   (((::std::vector<reco::HcalNoiseRBX>*)o)->data)();
}

static  void method_14128( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<reco::HcalNoiseRBX>*)o)->data)());
  else   (((const ::std::vector<reco::HcalNoiseRBX>*)o)->data)();
}

static  void method_14129( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::HcalNoiseRBX>*)o)->push_back)(*(const ::reco::HcalNoiseRBX*)arg[0]);
}

static  void method_14130( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::HcalNoiseRBX>*)o)->pop_back)();
}

static  void method_14131( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::HcalNoiseRBX*,std::vector<reco::HcalNoiseRBX> >)((((::std::vector<reco::HcalNoiseRBX>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::HcalNoiseRBX*,std::vector<reco::HcalNoiseRBX> >*)arg[0],
    *(const ::reco::HcalNoiseRBX*)arg[1]));
  else   (((::std::vector<reco::HcalNoiseRBX>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::HcalNoiseRBX*,std::vector<reco::HcalNoiseRBX> >*)arg[0],
    *(const ::reco::HcalNoiseRBX*)arg[1]);
}

static  void method_14132( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::HcalNoiseRBX>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::HcalNoiseRBX*,std::vector<reco::HcalNoiseRBX> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::reco::HcalNoiseRBX*)arg[2]);
}

static  void method_14133( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::HcalNoiseRBX*,std::vector<reco::HcalNoiseRBX> >)((((::std::vector<reco::HcalNoiseRBX>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::HcalNoiseRBX*,std::vector<reco::HcalNoiseRBX> >*)arg[0]));
  else   (((::std::vector<reco::HcalNoiseRBX>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::HcalNoiseRBX*,std::vector<reco::HcalNoiseRBX> >*)arg[0]);
}

static  void method_14134( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::HcalNoiseRBX*,std::vector<reco::HcalNoiseRBX> >)((((::std::vector<reco::HcalNoiseRBX>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::HcalNoiseRBX*,std::vector<reco::HcalNoiseRBX> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::HcalNoiseRBX*,std::vector<reco::HcalNoiseRBX> >*)arg[1]));
  else   (((::std::vector<reco::HcalNoiseRBX>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::HcalNoiseRBX*,std::vector<reco::HcalNoiseRBX> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::HcalNoiseRBX*,std::vector<reco::HcalNoiseRBX> >*)arg[1]);
}

static  void method_14135( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::HcalNoiseRBX>*)o)->swap)(*(::std::vector<reco::HcalNoiseRBX>*)arg[0]);
}

static  void method_14136( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::HcalNoiseRBX>*)o)->clear)();
}

static void method_newdel_3153( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<reco::HcalNoiseRBX> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<reco::HcalNoiseRBX> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<reco::HcalNoiseRBX> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<reco::HcalNoiseRBX> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<reco::HcalNoiseRBX> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x138( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::HcalNoiseRBX,std::allocator<reco::HcalNoiseRBX> >")), ::Reflex::BaseOffset< ::std::vector<reco::HcalNoiseRBX>,::std::_Vector_base<reco::HcalNoiseRBX,std::allocator<reco::HcalNoiseRBX> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x139( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<reco::HcalNoiseRBX> >::Generate();
  else ::Reflex::Proxy< ::std::vector<reco::HcalNoiseRBX> >::Generate();
}

//------Dictionary for class vector<reco::HcalNoiseRBX,std::allocator<reco::HcalNoiseRBX> > -------------------------------
void __std__vector_reco__HcalNoiseRBX__db_datamem(Reflex::Class*);
void __std__vector_reco__HcalNoiseRBX__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_reco__HcalNoiseRBX__datamem_bld(&__std__vector_reco__HcalNoiseRBX__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_reco__HcalNoiseRBX__funcmem_bld(&__std__vector_reco__HcalNoiseRBX__db_funcmem);
void __std__vector_reco__HcalNoiseRBX__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<reco::HcalNoiseRBX>"), typeid(::std::vector<reco::HcalNoiseRBX>), sizeof(::std::vector<reco::HcalNoiseRBX>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2597, ::Reflex::BaseOffset< ::std::vector<reco::HcalNoiseRBX>, ::std::_Vector_base<reco::HcalNoiseRBX,std::allocator<reco::HcalNoiseRBX> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_7976, Reflex::Literal("std::vector<reco::HcalNoiseRBX>::_Alloc_value_type"))
  .AddTypedef(type_2597, Reflex::Literal("std::vector<reco::HcalNoiseRBX>::_Base"))
  .AddTypedef(type_3424, Reflex::Literal("std::vector<reco::HcalNoiseRBX>::_Tp_alloc_type"))
  .AddTypedef(type_7976, Reflex::Literal("std::vector<reco::HcalNoiseRBX>::value_type"))
  .AddTypedef(type_14082, Reflex::Literal("std::vector<reco::HcalNoiseRBX>::pointer"))
  .AddTypedef(type_14084, Reflex::Literal("std::vector<reco::HcalNoiseRBX>::const_pointer"))
  .AddTypedef(type_14086, Reflex::Literal("std::vector<reco::HcalNoiseRBX>::reference"))
  .AddTypedef(type_14088, Reflex::Literal("std::vector<reco::HcalNoiseRBX>::const_reference"))
  .AddTypedef(type_8166, Reflex::Literal("std::vector<reco::HcalNoiseRBX>::iterator"))
  .AddTypedef(type_8167, Reflex::Literal("std::vector<reco::HcalNoiseRBX>::const_iterator"))
  .AddTypedef(type_3611, Reflex::Literal("std::vector<reco::HcalNoiseRBX>::const_reverse_iterator"))
  .AddTypedef(type_3612, Reflex::Literal("std::vector<reco::HcalNoiseRBX>::reverse_iterator"))
  .AddTypedef(type_3394, Reflex::Literal("std::vector<reco::HcalNoiseRBX>::size_type"))
  .AddTypedef(type_3290, Reflex::Literal("std::vector<reco::HcalNoiseRBX>::difference_type"))
  .AddTypedef(type_3424, Reflex::Literal("std::vector<reco::HcalNoiseRBX>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_14097, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31693), Reflex::Literal("vector"), constructor_14098, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3394, type_14088, type_31693), Reflex::Literal("vector"), constructor_14099, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32832), Reflex::Literal("vector"), constructor_14100, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_14101, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3153, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x138, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x139, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_reco__HcalNoiseRBX__funcmem_bld);
}

//------Delayed data member builder for class vector<reco::HcalNoiseRBX,std::allocator<reco::HcalNoiseRBX> > -------------------
void __std__vector_reco__HcalNoiseRBX__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<reco::HcalNoiseRBX,std::allocator<reco::HcalNoiseRBX> > -------------------
void __std__vector_reco__HcalNoiseRBX__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32833, type_32832), Reflex::Literal("operator="), operator_14102, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394, type_14088), Reflex::Literal("assign"), method_14103, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8166), Reflex::Literal("begin"), method_14104, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8167), Reflex::Literal("begin"), method_14105, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8166), Reflex::Literal("end"), method_14106, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8167), Reflex::Literal("end"), method_14107, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("size"), method_14112, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("max_size"), method_14113, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394, type_7976), Reflex::Literal("resize"), method_14114, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("capacity"), method_14115, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("empty"), method_14116, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394), Reflex::Literal("reserve"), method_14117, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14086, type_3394), Reflex::Literal("operator[]"), operator_14118, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14088, type_3394), Reflex::Literal("operator[]"), operator_14119, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14086, type_3394), Reflex::Literal("at"), method_14121, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14088, type_3394), Reflex::Literal("at"), method_14122, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14086), Reflex::Literal("front"), method_14123, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14088), Reflex::Literal("front"), method_14124, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14086), Reflex::Literal("back"), method_14125, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14088), Reflex::Literal("back"), method_14126, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14082), Reflex::Literal("data"), method_14127, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14084), Reflex::Literal("data"), method_14128, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_14088), Reflex::Literal("push_back"), method_14129, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("pop_back"), method_14130, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8166, type_8166, type_14088), Reflex::Literal("insert"), method_14131, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_8166, type_3394, type_14088), Reflex::Literal("insert"), method_14132, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8166, type_8166), Reflex::Literal("erase"), method_14133, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8166, type_8166, type_8166), Reflex::Literal("erase"), method_14134, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_32833), Reflex::Literal("swap"), method_14135, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("clear"), method_14136, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<reco::MVAMEtJetInfo,std::allocator<reco::MVAMEtJetInfo> > -------------------------------
static void constructor_13319( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::MVAMEtJetInfo>();
  else ::new(mem) ::std::vector<reco::MVAMEtJetInfo>();
}

static void constructor_13320( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::MVAMEtJetInfo>(*(const ::std::allocator<reco::MVAMEtJetInfo>*)arg[0]);
  else ::new(mem) ::std::vector<reco::MVAMEtJetInfo>(*(const ::std::allocator<reco::MVAMEtJetInfo>*)arg[0]);
}

static void constructor_13321( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::MVAMEtJetInfo>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<reco::MVAMEtJetInfo>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::MVAMEtJetInfo>(*(::std::size_t*)arg[0],
      *(const ::reco::MVAMEtJetInfo*)arg[1]);
  else ::new(mem) ::std::vector<reco::MVAMEtJetInfo>(*(::std::size_t*)arg[0],
      *(const ::reco::MVAMEtJetInfo*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::MVAMEtJetInfo>(*(::std::size_t*)arg[0],
      *(const ::reco::MVAMEtJetInfo*)arg[1],
      *(const ::std::allocator<reco::MVAMEtJetInfo>*)arg[2]);
  else ::new(mem) ::std::vector<reco::MVAMEtJetInfo>(*(::std::size_t*)arg[0],
      *(const ::reco::MVAMEtJetInfo*)arg[1],
      *(const ::std::allocator<reco::MVAMEtJetInfo>*)arg[2]);
  }
}

static void constructor_13322( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::MVAMEtJetInfo>(*(const ::std::vector<reco::MVAMEtJetInfo>*)arg[0]);
  else ::new(mem) ::std::vector<reco::MVAMEtJetInfo>(*(const ::std::vector<reco::MVAMEtJetInfo>*)arg[0]);
}

static void destructor_13323(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<reco::MVAMEtJetInfo>*)o)->::std::vector<reco::MVAMEtJetInfo>::~vector)();
}
static  void operator_13324( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::MVAMEtJetInfo>*)o)->operator=)(*(const ::std::vector<reco::MVAMEtJetInfo>*)arg[0]);
  else   (((::std::vector<reco::MVAMEtJetInfo>*)o)->operator=)(*(const ::std::vector<reco::MVAMEtJetInfo>*)arg[0]);
}

static  void method_13325( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::MVAMEtJetInfo>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::reco::MVAMEtJetInfo*)arg[1]);
}

static  void method_13326( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::MVAMEtJetInfo*,std::vector<reco::MVAMEtJetInfo> >)((((::std::vector<reco::MVAMEtJetInfo>*)o)->begin)());
  else   (((::std::vector<reco::MVAMEtJetInfo>*)o)->begin)();
}

static  void method_13327( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::MVAMEtJetInfo*,std::vector<reco::MVAMEtJetInfo> >)((((const ::std::vector<reco::MVAMEtJetInfo>*)o)->begin)());
  else   (((const ::std::vector<reco::MVAMEtJetInfo>*)o)->begin)();
}

static  void method_13328( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::MVAMEtJetInfo*,std::vector<reco::MVAMEtJetInfo> >)((((::std::vector<reco::MVAMEtJetInfo>*)o)->end)());
  else   (((::std::vector<reco::MVAMEtJetInfo>*)o)->end)();
}

static  void method_13329( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::MVAMEtJetInfo*,std::vector<reco::MVAMEtJetInfo> >)((((const ::std::vector<reco::MVAMEtJetInfo>*)o)->end)());
  else   (((const ::std::vector<reco::MVAMEtJetInfo>*)o)->end)();
}

static  void method_13334( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::MVAMEtJetInfo>*)o)->size)());
  else   (((const ::std::vector<reco::MVAMEtJetInfo>*)o)->size)();
}

static  void method_13335( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::MVAMEtJetInfo>*)o)->max_size)());
  else   (((const ::std::vector<reco::MVAMEtJetInfo>*)o)->max_size)();
}

static  void method_13336( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<reco::MVAMEtJetInfo>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<reco::MVAMEtJetInfo>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::reco::MVAMEtJetInfo*)arg[1]);
  }
}

static  void method_13337( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::MVAMEtJetInfo>*)o)->capacity)());
  else   (((const ::std::vector<reco::MVAMEtJetInfo>*)o)->capacity)();
}

static  void method_13338( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<reco::MVAMEtJetInfo>*)o)->empty)());
  else   (((const ::std::vector<reco::MVAMEtJetInfo>*)o)->empty)();
}

static  void method_13339( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::MVAMEtJetInfo>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_13340( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::MVAMEtJetInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::MVAMEtJetInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_13341( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::MVAMEtJetInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::MVAMEtJetInfo>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_13343( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::MVAMEtJetInfo>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::MVAMEtJetInfo>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13344( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::MVAMEtJetInfo>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::MVAMEtJetInfo>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_13345( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::MVAMEtJetInfo>*)o)->front)();
  else   (((::std::vector<reco::MVAMEtJetInfo>*)o)->front)();
}

static  void method_13346( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::MVAMEtJetInfo>*)o)->front)();
  else   (((const ::std::vector<reco::MVAMEtJetInfo>*)o)->front)();
}

static  void method_13347( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::MVAMEtJetInfo>*)o)->back)();
  else   (((::std::vector<reco::MVAMEtJetInfo>*)o)->back)();
}

static  void method_13348( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::MVAMEtJetInfo>*)o)->back)();
  else   (((const ::std::vector<reco::MVAMEtJetInfo>*)o)->back)();
}

static  void method_13349( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<reco::MVAMEtJetInfo>*)o)->data)());
  else   (((::std::vector<reco::MVAMEtJetInfo>*)o)->data)();
}

static  void method_13350( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<reco::MVAMEtJetInfo>*)o)->data)());
  else   (((const ::std::vector<reco::MVAMEtJetInfo>*)o)->data)();
}

static  void method_13351( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::MVAMEtJetInfo>*)o)->push_back)(*(const ::reco::MVAMEtJetInfo*)arg[0]);
}

static  void method_13352( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::MVAMEtJetInfo>*)o)->pop_back)();
}

static  void method_13353( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::MVAMEtJetInfo*,std::vector<reco::MVAMEtJetInfo> >)((((::std::vector<reco::MVAMEtJetInfo>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::MVAMEtJetInfo*,std::vector<reco::MVAMEtJetInfo> >*)arg[0],
    *(const ::reco::MVAMEtJetInfo*)arg[1]));
  else   (((::std::vector<reco::MVAMEtJetInfo>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::MVAMEtJetInfo*,std::vector<reco::MVAMEtJetInfo> >*)arg[0],
    *(const ::reco::MVAMEtJetInfo*)arg[1]);
}

static  void method_13354( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::MVAMEtJetInfo>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::MVAMEtJetInfo*,std::vector<reco::MVAMEtJetInfo> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::reco::MVAMEtJetInfo*)arg[2]);
}

static  void method_13355( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::MVAMEtJetInfo*,std::vector<reco::MVAMEtJetInfo> >)((((::std::vector<reco::MVAMEtJetInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::MVAMEtJetInfo*,std::vector<reco::MVAMEtJetInfo> >*)arg[0]));
  else   (((::std::vector<reco::MVAMEtJetInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::MVAMEtJetInfo*,std::vector<reco::MVAMEtJetInfo> >*)arg[0]);
}

static  void method_13356( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::MVAMEtJetInfo*,std::vector<reco::MVAMEtJetInfo> >)((((::std::vector<reco::MVAMEtJetInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::MVAMEtJetInfo*,std::vector<reco::MVAMEtJetInfo> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::MVAMEtJetInfo*,std::vector<reco::MVAMEtJetInfo> >*)arg[1]));
  else   (((::std::vector<reco::MVAMEtJetInfo>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::MVAMEtJetInfo*,std::vector<reco::MVAMEtJetInfo> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::MVAMEtJetInfo*,std::vector<reco::MVAMEtJetInfo> >*)arg[1]);
}

static  void method_13357( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::MVAMEtJetInfo>*)o)->swap)(*(::std::vector<reco::MVAMEtJetInfo>*)arg[0]);
}

static  void method_13358( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::MVAMEtJetInfo>*)o)->clear)();
}

static void method_newdel_3141( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<reco::MVAMEtJetInfo> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<reco::MVAMEtJetInfo> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<reco::MVAMEtJetInfo> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<reco::MVAMEtJetInfo> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<reco::MVAMEtJetInfo> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x141( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::MVAMEtJetInfo,std::allocator<reco::MVAMEtJetInfo> >")), ::Reflex::BaseOffset< ::std::vector<reco::MVAMEtJetInfo>,::std::_Vector_base<reco::MVAMEtJetInfo,std::allocator<reco::MVAMEtJetInfo> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x142( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<reco::MVAMEtJetInfo> >::Generate();
  else ::Reflex::Proxy< ::std::vector<reco::MVAMEtJetInfo> >::Generate();
}

//------Dictionary for class vector<reco::MVAMEtJetInfo,std::allocator<reco::MVAMEtJetInfo> > -------------------------------
void __std__vector_reco__MVAMEtJetInfo__db_datamem(Reflex::Class*);
void __std__vector_reco__MVAMEtJetInfo__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_reco__MVAMEtJetInfo__datamem_bld(&__std__vector_reco__MVAMEtJetInfo__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_reco__MVAMEtJetInfo__funcmem_bld(&__std__vector_reco__MVAMEtJetInfo__db_funcmem);
void __std__vector_reco__MVAMEtJetInfo__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<reco::MVAMEtJetInfo>"), typeid(::std::vector<reco::MVAMEtJetInfo>), sizeof(::std::vector<reco::MVAMEtJetInfo>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2590, ::Reflex::BaseOffset< ::std::vector<reco::MVAMEtJetInfo>, ::std::_Vector_base<reco::MVAMEtJetInfo,std::allocator<reco::MVAMEtJetInfo> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_8009, Reflex::Literal("std::vector<reco::MVAMEtJetInfo>::_Alloc_value_type"))
  .AddTypedef(type_2590, Reflex::Literal("std::vector<reco::MVAMEtJetInfo>::_Base"))
  .AddTypedef(type_3411, Reflex::Literal("std::vector<reco::MVAMEtJetInfo>::_Tp_alloc_type"))
  .AddTypedef(type_8009, Reflex::Literal("std::vector<reco::MVAMEtJetInfo>::value_type"))
  .AddTypedef(type_13304, Reflex::Literal("std::vector<reco::MVAMEtJetInfo>::pointer"))
  .AddTypedef(type_13306, Reflex::Literal("std::vector<reco::MVAMEtJetInfo>::const_pointer"))
  .AddTypedef(type_13308, Reflex::Literal("std::vector<reco::MVAMEtJetInfo>::reference"))
  .AddTypedef(type_13310, Reflex::Literal("std::vector<reco::MVAMEtJetInfo>::const_reference"))
  .AddTypedef(type_8150, Reflex::Literal("std::vector<reco::MVAMEtJetInfo>::iterator"))
  .AddTypedef(type_8151, Reflex::Literal("std::vector<reco::MVAMEtJetInfo>::const_iterator"))
  .AddTypedef(type_3597, Reflex::Literal("std::vector<reco::MVAMEtJetInfo>::const_reverse_iterator"))
  .AddTypedef(type_3598, Reflex::Literal("std::vector<reco::MVAMEtJetInfo>::reverse_iterator"))
  .AddTypedef(type_3394, Reflex::Literal("std::vector<reco::MVAMEtJetInfo>::size_type"))
  .AddTypedef(type_3290, Reflex::Literal("std::vector<reco::MVAMEtJetInfo>::difference_type"))
  .AddTypedef(type_3411, Reflex::Literal("std::vector<reco::MVAMEtJetInfo>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_13319, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_31609), Reflex::Literal("vector"), constructor_13320, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3394, type_13310, type_31609), Reflex::Literal("vector"), constructor_13321, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_32798), Reflex::Literal("vector"), constructor_13322, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_13323, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3141, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x141, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x142, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_reco__MVAMEtJetInfo__funcmem_bld);
}

//------Delayed data member builder for class vector<reco::MVAMEtJetInfo,std::allocator<reco::MVAMEtJetInfo> > -------------------
void __std__vector_reco__MVAMEtJetInfo__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<reco::MVAMEtJetInfo,std::allocator<reco::MVAMEtJetInfo> > -------------------
void __std__vector_reco__MVAMEtJetInfo__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_32799, type_32798), Reflex::Literal("operator="), operator_13324, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394, type_13310), Reflex::Literal("assign"), method_13325, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8150), Reflex::Literal("begin"), method_13326, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8151), Reflex::Literal("begin"), method_13327, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8150), Reflex::Literal("end"), method_13328, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8151), Reflex::Literal("end"), method_13329, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("size"), method_13334, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("max_size"), method_13335, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394, type_8009), Reflex::Literal("resize"), method_13336, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3394), Reflex::Literal("capacity"), method_13337, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("empty"), method_13338, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_3394), Reflex::Literal("reserve"), method_13339, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13308, type_3394), Reflex::Literal("operator[]"), operator_13340, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13310, type_3394), Reflex::Literal("operator[]"), operator_13341, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13308, type_3394), Reflex::Literal("at"), method_13343, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13310, type_3394), Reflex::Literal("at"), method_13344, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13308), Reflex::Literal("front"), method_13345, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13310), Reflex::Literal("front"), method_13346, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13308), Reflex::Literal("back"), method_13347, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13310), Reflex::Literal("back"), method_13348, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13304), Reflex::Literal("data"), method_13349, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13306), Reflex::Literal("data"), method_13350, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_13310), Reflex::Literal("push_back"), method_13351, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("pop_back"), method_13352, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8150, type_8150, type_13310), Reflex::Literal("insert"), method_13353, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_8150, type_3394, type_13310), Reflex::Literal("insert"), method_13354, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8150, type_8150), Reflex::Literal("erase"), method_13355, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8150, type_8150, type_8150), Reflex::Literal("erase"), method_13356, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_32799), Reflex::Literal("swap"), method_13357, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409), Reflex::Literal("clear"), method_13358, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class __normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge, std::allocator<reco::PhiWedge> > > -------------------------------
static void destructor_28450(void*, void * o, const std::vector<void*>&, void *) {
(((::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >*)o)->::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >::~__normal_iterator)();
}
static  void operator_28451( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >*)arg[0]);
}

static void constructor_28452( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >(*(const ::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >(*(const ::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >*)arg[0]);
}

static void constructor_28453( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >();
  else ::new(mem) ::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >();
}

static void constructor_28454( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >(*(::reco::PhiWedge* const*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >(*(::reco::PhiWedge* const*)arg[0]);
}

static  void operator_28455( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >*)o)->operator*)();
  else   (((const ::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >*)o)->operator*)();
}

static  void operator_28456( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >*)o)->operator->)());
  else   (((const ::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >*)o)->operator->)();
}

static  void operator_28457( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >*)o)->operator++)();
  else   (((::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >*)o)->operator++)();
}

static  void operator_28458( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >)((((::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >*)o)->operator++)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_28459( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >*)o)->operator--)();
  else   (((::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >*)o)->operator--)();
}

static  void operator_28460( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >)((((::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >*)o)->operator--)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_28461( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((const ::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_28462( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_28463( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >)((((const ::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_28464( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_28465( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >)((((const ::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void method_28466( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >*)o)->base)();
  else   (((const ::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >*)o)->base)();
}

static void method_newdel_8161( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge, std::allocator<reco::PhiWedge> > > -------------------------------
void ____gnu_cxx____normal_iterator_reco__PhiWedgep_std__vector_reco__PhiWedge_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____normal_iterator_reco__PhiWedgep_std__vector_reco__PhiWedge_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_reco__PhiWedgep_std__vector_reco__PhiWedge_s__datamem_bld(&____gnu_cxx____normal_iterator_reco__PhiWedgep_std__vector_reco__PhiWedge_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_reco__PhiWedgep_std__vector_reco__PhiWedge_s__funcmem_bld(&____gnu_cxx____normal_iterator_reco__PhiWedgep_std__vector_reco__PhiWedge_s__db_funcmem);
void ____gnu_cxx____normal_iterator_reco__PhiWedgep_std__vector_reco__PhiWedge_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >"), typeid(::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >), sizeof(::__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2661, Reflex::Literal("__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >::__traits_type"))
  .AddTypedef(type_10297, Reflex::Literal("__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >::iterator_type"))
  .AddTypedef(type_2725, Reflex::Literal("__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >::iterator_category"))
  .AddTypedef(type_7934, Reflex::Literal("__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >::value_type"))
  .AddTypedef(type_3290, Reflex::Literal("__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >::difference_type"))
  .AddTypedef(type_10299, Reflex::Literal("__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >::reference"))
  .AddTypedef(type_10297, Reflex::Literal("__gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> >::pointer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__normal_iterator"), destructor_28450, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39461, type_39462), Reflex::Literal("operator="), operator_28451, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39462), Reflex::Literal("__normal_iterator"), constructor_28452, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__normal_iterator"), constructor_28453, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39463), Reflex::Literal("__normal_iterator"), constructor_28454, 0, "__i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_8161, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&____gnu_cxx____normal_iterator_reco__PhiWedgep_std__vector_reco__PhiWedge_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____normal_iterator_reco__PhiWedgep_std__vector_reco__PhiWedge_s__funcmem_bld);
}

//------Delayed data member builder for class __normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge, std::allocator<reco::PhiWedge> > > -------------------
void ____gnu_cxx____normal_iterator_reco__PhiWedgep_std__vector_reco__PhiWedge_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_10297, Reflex::Literal("_M_current"), OffsetOf(__shadow__::____gnu_cxx____normal_iterator_reco__PhiWedgep_std__vector_reco__PhiWedge_s_, _M_current), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class __normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge, std::allocator<reco::PhiWedge> > > -------------------
void ____gnu_cxx____normal_iterator_reco__PhiWedgep_std__vector_reco__PhiWedge_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10299), Reflex::Literal("operator*"), operator_28455, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10297), Reflex::Literal("operator->"), operator_28456, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39461), Reflex::Literal("operator++"), operator_28457, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8161, type_72), Reflex::Literal("operator++"), operator_28458, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39461), Reflex::Literal("operator--"), operator_28459, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8161, type_72), Reflex::Literal("operator--"), operator_28460, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10299, type_39111), Reflex::Literal("operator[]"), operator_28461, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39461, type_39111), Reflex::Literal("operator+="), operator_28462, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8161, type_39111), Reflex::Literal("operator+"), operator_28463, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39461, type_39111), Reflex::Literal("operator-="), operator_28464, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8161, type_39111), Reflex::Literal("operator-"), operator_28465, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39463), Reflex::Literal("base"), method_28466, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class __normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD, std::allocator<reco::HcalNoiseHPD> > > -------------------------------
static void destructor_28600(void*, void * o, const std::vector<void*>&, void *) {
(((::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >*)o)->::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >::~__normal_iterator)();
}
static  void operator_28601( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >*)arg[0]);
}

static void constructor_28602( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >(*(const ::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >(*(const ::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >*)arg[0]);
}

static void constructor_28603( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >();
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >();
}

static void constructor_28604( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >(*(const ::reco::HcalNoiseHPD* const*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >(*(const ::reco::HcalNoiseHPD* const*)arg[0]);
}

static  void operator_28605( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >*)o)->operator*)();
  else   (((const ::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >*)o)->operator*)();
}

static  void operator_28606( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >*)o)->operator->)());
  else   (((const ::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >*)o)->operator->)();
}

static  void operator_28607( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >*)o)->operator++)();
  else   (((::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >*)o)->operator++)();
}

static  void operator_28608( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >)((((::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >*)o)->operator++)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_28609( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >*)o)->operator--)();
  else   (((::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >*)o)->operator--)();
}

static  void operator_28610( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >)((((::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >*)o)->operator--)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_28611( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((const ::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_28612( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_28613( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >)((((const ::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_28614( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_28615( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >)((((const ::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void method_28616( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >*)o)->base)();
  else   (((const ::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >*)o)->base)();
}

static void method_newdel_8190( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD, std::allocator<reco::HcalNoiseHPD> > > -------------------------------
void ____gnu_cxx____normal_iterator_constsreco__HcalNoiseHPDp_std__vector_reco__HcalNoiseHPD_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____normal_iterator_constsreco__HcalNoiseHPDp_std__vector_reco__HcalNoiseHPD_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constsreco__HcalNoiseHPDp_std__vector_reco__HcalNoiseHPD_s__datamem_bld(&____gnu_cxx____normal_iterator_constsreco__HcalNoiseHPDp_std__vector_reco__HcalNoiseHPD_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constsreco__HcalNoiseHPDp_std__vector_reco__HcalNoiseHPD_s__funcmem_bld(&____gnu_cxx____normal_iterator_constsreco__HcalNoiseHPDp_std__vector_reco__HcalNoiseHPD_s__db_funcmem);
void ____gnu_cxx____normal_iterator_constsreco__HcalNoiseHPDp_std__vector_reco__HcalNoiseHPD_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >"), typeid(::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >), sizeof(::__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2667, Reflex::Literal("__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >::__traits_type"))
  .AddTypedef(type_10361, Reflex::Literal("__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >::iterator_type"))
  .AddTypedef(type_2725, Reflex::Literal("__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >::iterator_category"))
  .AddTypedef(type_8033, Reflex::Literal("__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >::value_type"))
  .AddTypedef(type_3290, Reflex::Literal("__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >::difference_type"))
  .AddTypedef(type_10363, Reflex::Literal("__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >::reference"))
  .AddTypedef(type_10361, Reflex::Literal("__gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> >::pointer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__normal_iterator"), destructor_28600, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39476, type_39477), Reflex::Literal("operator="), operator_28601, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39477), Reflex::Literal("__normal_iterator"), constructor_28602, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__normal_iterator"), constructor_28603, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_39478), Reflex::Literal("__normal_iterator"), constructor_28604, 0, "__i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_8190, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&____gnu_cxx____normal_iterator_constsreco__HcalNoiseHPDp_std__vector_reco__HcalNoiseHPD_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____normal_iterator_constsreco__HcalNoiseHPDp_std__vector_reco__HcalNoiseHPD_s__funcmem_bld);
}

//------Delayed data member builder for class __normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD, std::allocator<reco::HcalNoiseHPD> > > -------------------
void ____gnu_cxx____normal_iterator_constsreco__HcalNoiseHPDp_std__vector_reco__HcalNoiseHPD_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_10361, Reflex::Literal("_M_current"), OffsetOf(__shadow__::____gnu_cxx____normal_iterator_constsreco__HcalNoiseHPDp_std__vector_reco__HcalNoiseHPD_s_, _M_current), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class __normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD, std::allocator<reco::HcalNoiseHPD> > > -------------------
void ____gnu_cxx____normal_iterator_constsreco__HcalNoiseHPDp_std__vector_reco__HcalNoiseHPD_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10363), Reflex::Literal("operator*"), operator_28605, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10361), Reflex::Literal("operator->"), operator_28606, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39476), Reflex::Literal("operator++"), operator_28607, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8190, type_72), Reflex::Literal("operator++"), operator_28608, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39476), Reflex::Literal("operator--"), operator_28609, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8190, type_72), Reflex::Literal("operator--"), operator_28610, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10363, type_39111), Reflex::Literal("operator[]"), operator_28611, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39476, type_39111), Reflex::Literal("operator+="), operator_28612, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8190, type_39111), Reflex::Literal("operator+"), operator_28613, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39476, type_39111), Reflex::Literal("operator-="), operator_28614, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8190, type_39111), Reflex::Literal("operator-"), operator_28615, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_39478), Reflex::Literal("base"), method_28616, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<reco::MVAMEtPFCandInfo, std::allocator<reco::MVAMEtPFCandInfo> > > -------------------------------
static void constructor_20706( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::MVAMEtPFCandInfo> >();
  else ::new(mem) ::edm::Wrapper<std::vector<reco::MVAMEtPFCandInfo> >();
}

static void constructor_20707( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::MVAMEtPFCandInfo> >(*(::std::auto_ptr<std::vector<reco::MVAMEtPFCandInfo> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<reco::MVAMEtPFCandInfo> >(*(::std::auto_ptr<std::vector<reco::MVAMEtPFCandInfo> >*)arg[0]);
}

static void destructor_20708(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<reco::MVAMEtPFCandInfo> >*)o)->::edm::Wrapper<std::vector<reco::MVAMEtPFCandInfo> >::~Wrapper)();
}
static  void method_20709( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<reco::MVAMEtPFCandInfo> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<reco::MVAMEtPFCandInfo> >*)o)->product)();
}

static  void operator_20710( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<reco::MVAMEtPFCandInfo> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<reco::MVAMEtPFCandInfo> >*)o)->operator->)();
}

static  void method_20711( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<reco::MVAMEtPFCandInfo> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<reco::MVAMEtPFCandInfo> >*)o)->productTypeInfo)();
}

static  void method_20712( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<reco::MVAMEtPFCandInfo> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<reco::MVAMEtPFCandInfo> >*)o)->typeInfo)();
}

static void constructor_20713( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::MVAMEtPFCandInfo> >((::std::vector<reco::MVAMEtPFCandInfo>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<reco::MVAMEtPFCandInfo> >((::std::vector<reco::MVAMEtPFCandInfo>*)arg[0]);
}

static  void method_20714( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<reco::MVAMEtPFCandInfo> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<reco::MVAMEtPFCandInfo> >*)o)->getInterface)();
}

static  void method_20715( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::MVAMEtPFCandInfo> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_20716( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::MVAMEtPFCandInfo> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_20717( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::MVAMEtPFCandInfo> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_20718( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<reco::MVAMEtPFCandInfo> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<reco::MVAMEtPFCandInfo> >*)o)->dynamicTypeInfo)();
}

static  void method_20719( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<reco::MVAMEtPFCandInfo> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<reco::MVAMEtPFCandInfo> >*)o)->isPresent)();
}

static  void method_20720( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<reco::MVAMEtPFCandInfo> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<reco::MVAMEtPFCandInfo> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4698( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::MVAMEtPFCandInfo> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::MVAMEtPFCandInfo> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::MVAMEtPFCandInfo> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::MVAMEtPFCandInfo> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::MVAMEtPFCandInfo> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<reco::MVAMEtPFCandInfo, std::allocator<reco::MVAMEtPFCandInfo> > > -------------------------------
void __edm__Wrapper_std__vector_reco__MVAMEtPFCandInfo_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_reco__MVAMEtPFCandInfo_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_reco__MVAMEtPFCandInfo_s__datamem_bld(&__edm__Wrapper_std__vector_reco__MVAMEtPFCandInfo_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_reco__MVAMEtPFCandInfo_s__funcmem_bld(&__edm__Wrapper_std__vector_reco__MVAMEtPFCandInfo_s__db_funcmem);
void __edm__Wrapper_std__vector_reco__MVAMEtPFCandInfo_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<reco::MVAMEtPFCandInfo> >"), typeid(::edm::Wrapper<std::vector<reco::MVAMEtPFCandInfo> >), sizeof(::edm::Wrapper<std::vector<reco::MVAMEtPFCandInfo> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<reco::MVAMEtPFCandInfoCollection>")
  .AddTypedef(type_3140, Reflex::Literal("edm::Wrapper<std::vector<reco::MVAMEtPFCandInfo> >::value_type"))
  .AddTypedef(type_3140, Reflex::Literal("edm::Wrapper<std::vector<reco::MVAMEtPFCandInfo> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_20706, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2877), Reflex::Literal("Wrapper"), constructor_20707, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_20708, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33896), Reflex::Literal("Wrapper"), constructor_20713, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4698, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_reco__MVAMEtPFCandInfo_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_reco__MVAMEtPFCandInfo_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<reco::MVAMEtPFCandInfo, std::allocator<reco::MVAMEtPFCandInfo> > > -------------------
void __edm__Wrapper_std__vector_reco__MVAMEtPFCandInfo_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1647, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_reco__MVAMEtPFCandInfo_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3140, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_reco__MVAMEtPFCandInfo_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<reco::MVAMEtPFCandInfo, std::allocator<reco::MVAMEtPFCandInfo> > > -------------------
void __edm__Wrapper_std__vector_reco__MVAMEtPFCandInfo_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33895), Reflex::Literal("product"), method_20709, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33895), Reflex::Literal("operator->"), operator_20710, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("productTypeInfo"), method_20711, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("typeInfo"), method_20712, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33897), Reflex::Literal("getInterface"), method_20714, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_19738, type_19832, type_33879), Reflex::Literal("fillView"), method_20715, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_364, type_10395), Reflex::Literal("setPtr"), method_20716, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_19897, type_19832), Reflex::Literal("fillPtrVector"), method_20717, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo"), method_20718, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isPresent"), method_20719, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo_"), method_20720, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<reco::MVAMEtJetInfo, std::allocator<reco::MVAMEtJetInfo> > > -------------------------------
static void constructor_20727( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::MVAMEtJetInfo> >();
  else ::new(mem) ::edm::Wrapper<std::vector<reco::MVAMEtJetInfo> >();
}

static void constructor_20728( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::MVAMEtJetInfo> >(*(::std::auto_ptr<std::vector<reco::MVAMEtJetInfo> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<reco::MVAMEtJetInfo> >(*(::std::auto_ptr<std::vector<reco::MVAMEtJetInfo> >*)arg[0]);
}

static void destructor_20729(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<reco::MVAMEtJetInfo> >*)o)->::edm::Wrapper<std::vector<reco::MVAMEtJetInfo> >::~Wrapper)();
}
static  void method_20730( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<reco::MVAMEtJetInfo> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<reco::MVAMEtJetInfo> >*)o)->product)();
}

static  void operator_20731( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<reco::MVAMEtJetInfo> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<reco::MVAMEtJetInfo> >*)o)->operator->)();
}

static  void method_20732( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<reco::MVAMEtJetInfo> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<reco::MVAMEtJetInfo> >*)o)->productTypeInfo)();
}

static  void method_20733( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<reco::MVAMEtJetInfo> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<reco::MVAMEtJetInfo> >*)o)->typeInfo)();
}

static void constructor_20734( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::MVAMEtJetInfo> >((::std::vector<reco::MVAMEtJetInfo>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<reco::MVAMEtJetInfo> >((::std::vector<reco::MVAMEtJetInfo>*)arg[0]);
}

static  void method_20735( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<reco::MVAMEtJetInfo> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<reco::MVAMEtJetInfo> >*)o)->getInterface)();
}

static  void method_20736( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::MVAMEtJetInfo> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_20737( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::MVAMEtJetInfo> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_20738( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::MVAMEtJetInfo> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_20739( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<reco::MVAMEtJetInfo> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<reco::MVAMEtJetInfo> >*)o)->dynamicTypeInfo)();
}

static  void method_20740( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<reco::MVAMEtJetInfo> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<reco::MVAMEtJetInfo> >*)o)->isPresent)();
}

static  void method_20741( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<reco::MVAMEtJetInfo> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<reco::MVAMEtJetInfo> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4699( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::MVAMEtJetInfo> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::MVAMEtJetInfo> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::MVAMEtJetInfo> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::MVAMEtJetInfo> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::MVAMEtJetInfo> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<reco::MVAMEtJetInfo, std::allocator<reco::MVAMEtJetInfo> > > -------------------------------
void __edm__Wrapper_std__vector_reco__MVAMEtJetInfo_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_reco__MVAMEtJetInfo_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_reco__MVAMEtJetInfo_s__datamem_bld(&__edm__Wrapper_std__vector_reco__MVAMEtJetInfo_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_reco__MVAMEtJetInfo_s__funcmem_bld(&__edm__Wrapper_std__vector_reco__MVAMEtJetInfo_s__db_funcmem);
void __edm__Wrapper_std__vector_reco__MVAMEtJetInfo_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<reco::MVAMEtJetInfo> >"), typeid(::edm::Wrapper<std::vector<reco::MVAMEtJetInfo> >), sizeof(::edm::Wrapper<std::vector<reco::MVAMEtJetInfo> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<reco::MVAMEtJetInfoCollection>")
  .AddTypedef(type_3141, Reflex::Literal("edm::Wrapper<std::vector<reco::MVAMEtJetInfo> >::value_type"))
  .AddTypedef(type_3141, Reflex::Literal("edm::Wrapper<std::vector<reco::MVAMEtJetInfo> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_20727, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2878), Reflex::Literal("Wrapper"), constructor_20728, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_20729, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33901), Reflex::Literal("Wrapper"), constructor_20734, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4699, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_reco__MVAMEtJetInfo_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_reco__MVAMEtJetInfo_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<reco::MVAMEtJetInfo, std::allocator<reco::MVAMEtJetInfo> > > -------------------
void __edm__Wrapper_std__vector_reco__MVAMEtJetInfo_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1647, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_reco__MVAMEtJetInfo_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3141, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_reco__MVAMEtJetInfo_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<reco::MVAMEtJetInfo, std::allocator<reco::MVAMEtJetInfo> > > -------------------
void __edm__Wrapper_std__vector_reco__MVAMEtJetInfo_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33900), Reflex::Literal("product"), method_20730, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33900), Reflex::Literal("operator->"), operator_20731, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("productTypeInfo"), method_20732, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("typeInfo"), method_20733, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33902), Reflex::Literal("getInterface"), method_20735, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_19738, type_19832, type_33879), Reflex::Literal("fillView"), method_20736, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_364, type_10395), Reflex::Literal("setPtr"), method_20737, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_19897, type_19832), Reflex::Literal("fillPtrVector"), method_20738, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo"), method_20739, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isPresent"), method_20740, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo_"), method_20741, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<reco::HcalNoiseRBX, std::allocator<reco::HcalNoiseRBX> > > -------------------------------
static void constructor_21042( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::HcalNoiseRBX> >();
  else ::new(mem) ::edm::Wrapper<std::vector<reco::HcalNoiseRBX> >();
}

static void constructor_21043( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::HcalNoiseRBX> >(*(::std::auto_ptr<std::vector<reco::HcalNoiseRBX> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<reco::HcalNoiseRBX> >(*(::std::auto_ptr<std::vector<reco::HcalNoiseRBX> >*)arg[0]);
}

static void destructor_21044(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<reco::HcalNoiseRBX> >*)o)->::edm::Wrapper<std::vector<reco::HcalNoiseRBX> >::~Wrapper)();
}
static  void method_21045( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<reco::HcalNoiseRBX> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<reco::HcalNoiseRBX> >*)o)->product)();
}

static  void operator_21046( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<reco::HcalNoiseRBX> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<reco::HcalNoiseRBX> >*)o)->operator->)();
}

static  void method_21047( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<reco::HcalNoiseRBX> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<reco::HcalNoiseRBX> >*)o)->productTypeInfo)();
}

static  void method_21048( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<reco::HcalNoiseRBX> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<reco::HcalNoiseRBX> >*)o)->typeInfo)();
}

static void constructor_21049( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::HcalNoiseRBX> >((::std::vector<reco::HcalNoiseRBX>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<reco::HcalNoiseRBX> >((::std::vector<reco::HcalNoiseRBX>*)arg[0]);
}

static  void method_21050( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<reco::HcalNoiseRBX> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<reco::HcalNoiseRBX> >*)o)->getInterface)();
}

static  void method_21051( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::HcalNoiseRBX> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_21052( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::HcalNoiseRBX> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_21053( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::HcalNoiseRBX> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_21054( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<reco::HcalNoiseRBX> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<reco::HcalNoiseRBX> >*)o)->dynamicTypeInfo)();
}

static  void method_21055( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<reco::HcalNoiseRBX> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<reco::HcalNoiseRBX> >*)o)->isPresent)();
}

static  void method_21056( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<reco::HcalNoiseRBX> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<reco::HcalNoiseRBX> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4714( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::HcalNoiseRBX> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::HcalNoiseRBX> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::HcalNoiseRBX> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::HcalNoiseRBX> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::HcalNoiseRBX> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<reco::HcalNoiseRBX, std::allocator<reco::HcalNoiseRBX> > > -------------------------------
void __edm__Wrapper_std__vector_reco__HcalNoiseRBX_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_reco__HcalNoiseRBX_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_reco__HcalNoiseRBX_s__datamem_bld(&__edm__Wrapper_std__vector_reco__HcalNoiseRBX_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_reco__HcalNoiseRBX_s__funcmem_bld(&__edm__Wrapper_std__vector_reco__HcalNoiseRBX_s__db_funcmem);
void __edm__Wrapper_std__vector_reco__HcalNoiseRBX_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<reco::HcalNoiseRBX> >"), typeid(::edm::Wrapper<std::vector<reco::HcalNoiseRBX> >), sizeof(::edm::Wrapper<std::vector<reco::HcalNoiseRBX> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<reco::HcalNoiseRBXCollection>")
  .AddTypedef(type_3153, Reflex::Literal("edm::Wrapper<std::vector<reco::HcalNoiseRBX> >::value_type"))
  .AddTypedef(type_3153, Reflex::Literal("edm::Wrapper<std::vector<reco::HcalNoiseRBX> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_21042, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2894), Reflex::Literal("Wrapper"), constructor_21043, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_21044, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33968), Reflex::Literal("Wrapper"), constructor_21049, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4714, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_reco__HcalNoiseRBX_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_reco__HcalNoiseRBX_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<reco::HcalNoiseRBX, std::allocator<reco::HcalNoiseRBX> > > -------------------
void __edm__Wrapper_std__vector_reco__HcalNoiseRBX_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1647, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_reco__HcalNoiseRBX_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3153, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_reco__HcalNoiseRBX_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<reco::HcalNoiseRBX, std::allocator<reco::HcalNoiseRBX> > > -------------------
void __edm__Wrapper_std__vector_reco__HcalNoiseRBX_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33967), Reflex::Literal("product"), method_21045, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33967), Reflex::Literal("operator->"), operator_21046, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("productTypeInfo"), method_21047, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("typeInfo"), method_21048, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33969), Reflex::Literal("getInterface"), method_21050, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_19738, type_19832, type_33879), Reflex::Literal("fillView"), method_21051, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_364, type_10395), Reflex::Literal("setPtr"), method_21052, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_19897, type_19832), Reflex::Literal("fillPtrVector"), method_21053, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo"), method_21054, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isPresent"), method_21055, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo_"), method_21056, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<reco::HcalNoiseHPD, std::allocator<reco::HcalNoiseHPD> > > -------------------------------
static void constructor_21063( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::HcalNoiseHPD> >();
  else ::new(mem) ::edm::Wrapper<std::vector<reco::HcalNoiseHPD> >();
}

static void constructor_21064( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::HcalNoiseHPD> >(*(::std::auto_ptr<std::vector<reco::HcalNoiseHPD> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<reco::HcalNoiseHPD> >(*(::std::auto_ptr<std::vector<reco::HcalNoiseHPD> >*)arg[0]);
}

static void destructor_21065(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<reco::HcalNoiseHPD> >*)o)->::edm::Wrapper<std::vector<reco::HcalNoiseHPD> >::~Wrapper)();
}
static  void method_21066( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<reco::HcalNoiseHPD> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<reco::HcalNoiseHPD> >*)o)->product)();
}

static  void operator_21067( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<reco::HcalNoiseHPD> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<reco::HcalNoiseHPD> >*)o)->operator->)();
}

static  void method_21068( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<reco::HcalNoiseHPD> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<reco::HcalNoiseHPD> >*)o)->productTypeInfo)();
}

static  void method_21069( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<reco::HcalNoiseHPD> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<reco::HcalNoiseHPD> >*)o)->typeInfo)();
}

static void constructor_21070( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::HcalNoiseHPD> >((::std::vector<reco::HcalNoiseHPD>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<reco::HcalNoiseHPD> >((::std::vector<reco::HcalNoiseHPD>*)arg[0]);
}

static  void method_21071( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<reco::HcalNoiseHPD> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<reco::HcalNoiseHPD> >*)o)->getInterface)();
}

static  void method_21072( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::HcalNoiseHPD> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_21073( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::HcalNoiseHPD> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_21074( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::HcalNoiseHPD> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_21075( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<reco::HcalNoiseHPD> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<reco::HcalNoiseHPD> >*)o)->dynamicTypeInfo)();
}

static  void method_21076( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<reco::HcalNoiseHPD> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<reco::HcalNoiseHPD> >*)o)->isPresent)();
}

static  void method_21077( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<reco::HcalNoiseHPD> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<reco::HcalNoiseHPD> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4715( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::HcalNoiseHPD> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::HcalNoiseHPD> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::HcalNoiseHPD> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::HcalNoiseHPD> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::HcalNoiseHPD> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<reco::HcalNoiseHPD, std::allocator<reco::HcalNoiseHPD> > > -------------------------------
void __edm__Wrapper_std__vector_reco__HcalNoiseHPD_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_reco__HcalNoiseHPD_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_reco__HcalNoiseHPD_s__datamem_bld(&__edm__Wrapper_std__vector_reco__HcalNoiseHPD_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_reco__HcalNoiseHPD_s__funcmem_bld(&__edm__Wrapper_std__vector_reco__HcalNoiseHPD_s__db_funcmem);
void __edm__Wrapper_std__vector_reco__HcalNoiseHPD_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<reco::HcalNoiseHPD> >"), typeid(::edm::Wrapper<std::vector<reco::HcalNoiseHPD> >), sizeof(::edm::Wrapper<std::vector<reco::HcalNoiseHPD> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<reco::HcalNoiseHPDCollection>")
  .AddTypedef(type_3154, Reflex::Literal("edm::Wrapper<std::vector<reco::HcalNoiseHPD> >::value_type"))
  .AddTypedef(type_3154, Reflex::Literal("edm::Wrapper<std::vector<reco::HcalNoiseHPD> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_21063, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2895), Reflex::Literal("Wrapper"), constructor_21064, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_21065, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33973), Reflex::Literal("Wrapper"), constructor_21070, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4715, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_reco__HcalNoiseHPD_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_reco__HcalNoiseHPD_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<reco::HcalNoiseHPD, std::allocator<reco::HcalNoiseHPD> > > -------------------
void __edm__Wrapper_std__vector_reco__HcalNoiseHPD_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1647, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_reco__HcalNoiseHPD_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3154, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_reco__HcalNoiseHPD_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<reco::HcalNoiseHPD, std::allocator<reco::HcalNoiseHPD> > > -------------------
void __edm__Wrapper_std__vector_reco__HcalNoiseHPD_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33972), Reflex::Literal("product"), method_21066, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33972), Reflex::Literal("operator->"), operator_21067, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("productTypeInfo"), method_21068, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("typeInfo"), method_21069, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33974), Reflex::Literal("getInterface"), method_21071, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_19738, type_19832, type_33879), Reflex::Literal("fillView"), method_21072, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_364, type_10395), Reflex::Literal("setPtr"), method_21073, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_4589, type_19897, type_19832), Reflex::Literal("fillPtrVector"), method_21074, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo"), method_21075, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isPresent"), method_21076, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4589), Reflex::Literal("dynamicTypeInfo_"), method_21077, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class RefHolder<edm::Ref<std::vector<reco::PFClusterMET, std::allocator<reco::PFClusterMET> >, reco::PFClusterMET, edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET, std::allocator<reco::PFClusterMET> >, reco::PFClusterMET> > > -------------------------------
static  void operator_34038( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->operator=)(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)arg[0]);
  else   (((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->operator=)(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)arg[0]);
}

static void constructor_34039( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)arg[0]);
}

static void constructor_34040( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >();
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >();
}

static void constructor_34041( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >(*(const ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >(*(const ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)arg[0]);
}

static  void method_34042( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->swap)(*(::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)arg[0]);
}

static void destructor_34043(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >::~RefHolder)();
}
static  void method_34044( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->clone)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->clone)();
}

static  void method_34045( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->id)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->id)();
}

static  void method_34046( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->key)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->key)();
}

static  void method_34047( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]));
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]);
}

static  void method_34048( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_34049( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->getRef)();
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->getRef)();
}

static  void method_34050( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->setRef)(*(const ::edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> >*)arg[0]);
}

static  void method_34051( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->makeVectorHolder)();
}

static  void method_34052( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->productGetter)();
}

static  void method_34053( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->hasProductCache)();
}

static  void method_34054( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->product)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->product)();
}

static  void method_34055( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->isAvailable)();
}

static  void method_34056( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->Class_Version)());
  else   (((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >*)o)->Class_Version)();
}

static void method_newdel_21293( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x150( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolderBase")), ::Reflex::BaseOffset< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >,::edm::reftobase::RefHolderBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RefHolder<edm::Ref<std::vector<reco::PFClusterMET, std::allocator<reco::PFClusterMET> >, reco::PFClusterMET, edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET, std::allocator<reco::PFClusterMET> >, reco::PFClusterMET> > > -------------------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_s__datamem_bld(&__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_s__funcmem_bld(&__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_s__db_funcmem);
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >"), typeid(::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >), sizeof(::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::reftobase::RefHolder<reco::PFClusterMETRef>")
  .AddBase(type_12173, ::Reflex::BaseOffset< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > >, ::edm::reftobase::RefHolderBase >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_40746, type_40747), Reflex::Literal("operator="), operator_34038, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_40747), Reflex::Literal("RefHolder"), constructor_34039, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefHolder"), constructor_34040, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33824), Reflex::Literal("RefHolder"), constructor_34041, 0, "ref", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefHolder"), destructor_34043, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_21293, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x150, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_s__funcmem_bld);
}

//------Delayed data member builder for class RefHolder<edm::Ref<std::vector<reco::PFClusterMET, std::allocator<reco::PFClusterMET> >, reco::PFClusterMET, edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET, std::allocator<reco::PFClusterMET> >, reco::PFClusterMET> > > -------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4915, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefHolder<edm::Ref<std::vector<reco::PFClusterMET, std::allocator<reco::PFClusterMET> >, reco::PFClusterMET, edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET, std::allocator<reco::PFClusterMET> >, reco::PFClusterMET> > > -------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_40746), Reflex::Literal("swap"), method_34042, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21583), Reflex::Literal("clone"), method_34044, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4866), Reflex::Literal("id"), method_34045, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2197), Reflex::Literal("key"), method_34046, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647, type_40258), Reflex::Literal("isEqualTo"), method_34047, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647, type_21585, type_10457), Reflex::Literal("fillRefIfMyTypeMatches"), method_34048, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33824), Reflex::Literal("getRef"), method_34049, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_33824), Reflex::Literal("setRef"), method_34050, 0, "r", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("makeVectorHolder"), method_34051, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19828), Reflex::Literal("productGetter"), method_34052, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("hasProductCache"), method_34053, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4239), Reflex::Literal("product"), method_34054, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isAvailable"), method_34055, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_192), Reflex::Literal("Class_Version"), method_34056, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefHolder<edm::Ref<std::vector<reco::PFMET, std::allocator<reco::PFMET> >, reco::PFMET, edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET, std::allocator<reco::PFMET> >, reco::PFMET> > > -------------------------------
static  void operator_34059( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->operator=)(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)arg[0]);
  else   (((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->operator=)(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)arg[0]);
}

static void constructor_34060( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)arg[0]);
}

static void constructor_34061( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >();
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >();
}

static void constructor_34062( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >(*(const ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >(*(const ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)arg[0]);
}

static  void method_34063( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->swap)(*(::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)arg[0]);
}

static void destructor_34064(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >::~RefHolder)();
}
static  void method_34065( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->clone)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->clone)();
}

static  void method_34066( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->id)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->id)();
}

static  void method_34067( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->key)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->key)();
}

static  void method_34068( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]));
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]);
}

static  void method_34069( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_34070( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->getRef)();
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->getRef)();
}

static  void method_34071( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->setRef)(*(const ::edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> >*)arg[0]);
}

static  void method_34072( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->makeVectorHolder)();
}

static  void method_34073( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->productGetter)();
}

static  void method_34074( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->hasProductCache)();
}

static  void method_34075( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->product)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->product)();
}

static  void method_34076( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->isAvailable)();
}

static  void method_34077( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->Class_Version)());
  else   (((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >*)o)->Class_Version)();
}

static void method_newdel_21294( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x152( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolderBase")), ::Reflex::BaseOffset< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >,::edm::reftobase::RefHolderBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RefHolder<edm::Ref<std::vector<reco::PFMET, std::allocator<reco::PFMET> >, reco::PFMET, edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET, std::allocator<reco::PFMET> >, reco::PFMET> > > -------------------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_s__datamem_bld(&__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_s__funcmem_bld(&__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_s__db_funcmem);
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >"), typeid(::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >), sizeof(::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::reftobase::RefHolder<reco::PFMETRef>")
  .AddBase(type_12173, ::Reflex::BaseOffset< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > >, ::edm::reftobase::RefHolderBase >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_40748, type_40749), Reflex::Literal("operator="), operator_34059, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_40749), Reflex::Literal("RefHolder"), constructor_34060, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefHolder"), constructor_34061, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33830), Reflex::Literal("RefHolder"), constructor_34062, 0, "ref", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefHolder"), destructor_34064, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_21294, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x152, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_s__funcmem_bld);
}

//------Delayed data member builder for class RefHolder<edm::Ref<std::vector<reco::PFMET, std::allocator<reco::PFMET> >, reco::PFMET, edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET, std::allocator<reco::PFMET> >, reco::PFMET> > > -------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4916, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefHolder<edm::Ref<std::vector<reco::PFMET, std::allocator<reco::PFMET> >, reco::PFMET, edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET, std::allocator<reco::PFMET> >, reco::PFMET> > > -------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_40748), Reflex::Literal("swap"), method_34063, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21583), Reflex::Literal("clone"), method_34065, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4866), Reflex::Literal("id"), method_34066, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2197), Reflex::Literal("key"), method_34067, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647, type_40258), Reflex::Literal("isEqualTo"), method_34068, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647, type_21585, type_10457), Reflex::Literal("fillRefIfMyTypeMatches"), method_34069, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33830), Reflex::Literal("getRef"), method_34070, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_33830), Reflex::Literal("setRef"), method_34071, 0, "r", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("makeVectorHolder"), method_34072, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19828), Reflex::Literal("productGetter"), method_34073, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("hasProductCache"), method_34074, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4239), Reflex::Literal("product"), method_34075, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isAvailable"), method_34076, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_192), Reflex::Literal("Class_Version"), method_34077, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefHolder<edm::Ref<std::vector<reco::GenMET, std::allocator<reco::GenMET> >, reco::GenMET, edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET, std::allocator<reco::GenMET> >, reco::GenMET> > > -------------------------------
static  void operator_34080( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->operator=)(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)arg[0]);
  else   (((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->operator=)(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)arg[0]);
}

static void constructor_34081( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)arg[0]);
}

static void constructor_34082( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >();
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >();
}

static void constructor_34083( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >(*(const ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >(*(const ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)arg[0]);
}

static  void method_34084( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->swap)(*(::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)arg[0]);
}

static void destructor_34085(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >::~RefHolder)();
}
static  void method_34086( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->clone)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->clone)();
}

static  void method_34087( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->id)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->id)();
}

static  void method_34088( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->key)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->key)();
}

static  void method_34089( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]));
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]);
}

static  void method_34090( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_34091( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->getRef)();
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->getRef)();
}

static  void method_34092( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->setRef)(*(const ::edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> >*)arg[0]);
}

static  void method_34093( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->makeVectorHolder)();
}

static  void method_34094( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->productGetter)();
}

static  void method_34095( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->hasProductCache)();
}

static  void method_34096( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->product)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->product)();
}

static  void method_34097( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->isAvailable)();
}

static  void method_34098( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->Class_Version)());
  else   (((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >*)o)->Class_Version)();
}

static void method_newdel_21295( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x154( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolderBase")), ::Reflex::BaseOffset< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >,::edm::reftobase::RefHolderBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RefHolder<edm::Ref<std::vector<reco::GenMET, std::allocator<reco::GenMET> >, reco::GenMET, edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET, std::allocator<reco::GenMET> >, reco::GenMET> > > -------------------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_s__datamem_bld(&__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_s__funcmem_bld(&__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_s__db_funcmem);
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >"), typeid(::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >), sizeof(::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::reftobase::RefHolder<reco::GenMETRef>")
  .AddBase(type_12173, ::Reflex::BaseOffset< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > >, ::edm::reftobase::RefHolderBase >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_40750, type_40751), Reflex::Literal("operator="), operator_34080, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_40751), Reflex::Literal("RefHolder"), constructor_34081, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefHolder"), constructor_34082, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_33840), Reflex::Literal("RefHolder"), constructor_34083, 0, "ref", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefHolder"), destructor_34085, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_21295, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x154, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_s__funcmem_bld);
}

//------Delayed data member builder for class RefHolder<edm::Ref<std::vector<reco::GenMET, std::allocator<reco::GenMET> >, reco::GenMET, edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET, std::allocator<reco::GenMET> >, reco::GenMET> > > -------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4917, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefHolder<edm::Ref<std::vector<reco::GenMET, std::allocator<reco::GenMET> >, reco::GenMET, edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET, std::allocator<reco::GenMET> >, reco::GenMET> > > -------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_40750), Reflex::Literal("swap"), method_34084, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21583), Reflex::Literal("clone"), method_34086, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4866), Reflex::Literal("id"), method_34087, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2197), Reflex::Literal("key"), method_34088, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647, type_40258), Reflex::Literal("isEqualTo"), method_34089, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647, type_21585, type_10457), Reflex::Literal("fillRefIfMyTypeMatches"), method_34090, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_33840), Reflex::Literal("getRef"), method_34091, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_33840), Reflex::Literal("setRef"), method_34092, 0, "r", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("makeVectorHolder"), method_34093, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19828), Reflex::Literal("productGetter"), method_34094, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("hasProductCache"), method_34095, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4239), Reflex::Literal("product"), method_34096, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isAvailable"), method_34097, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_192), Reflex::Literal("Class_Version"), method_34098, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefHolder<edm::Ref<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >, reco::CaloMET, edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >, reco::CaloMET> > > -------------------------------
static  void operator_34101( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->operator=)(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)arg[0]);
  else   (((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->operator=)(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)arg[0]);
}

static void constructor_34102( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)arg[0]);
}

static void constructor_34103( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >();
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >();
}

static void constructor_34104( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >(*(const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >(*(const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)arg[0]);
}

static  void method_34105( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->swap)(*(::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)arg[0]);
}

static void destructor_34106(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >::~RefHolder)();
}
static  void method_34107( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->clone)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->clone)();
}

static  void method_34108( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->id)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->id)();
}

static  void method_34109( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->key)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->key)();
}

static  void method_34110( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]));
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]);
}

static  void method_34111( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_34112( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->getRef)();
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->getRef)();
}

static  void method_34113( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->setRef)(*(const ::edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >*)arg[0]);
}

static  void method_34114( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->makeVectorHolder)();
}

static  void method_34115( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->productGetter)();
}

static  void method_34116( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->hasProductCache)();
}

static  void method_34117( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->product)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->product)();
}

static  void method_34118( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->isAvailable)();
}

static  void method_34119( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->Class_Version)());
  else   (((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >*)o)->Class_Version)();
}

static void method_newdel_21296( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x156( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolderBase")), ::Reflex::BaseOffset< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >,::edm::reftobase::RefHolderBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RefHolder<edm::Ref<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >, reco::CaloMET, edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >, reco::CaloMET> > > -------------------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s__datamem_bld(&__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s__funcmem_bld(&__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s__db_funcmem);
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >"), typeid(::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >), sizeof(::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::reftobase::RefHolder<reco::CaloMETRef>")
  .AddBase(type_12173, ::Reflex::BaseOffset< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >, ::edm::reftobase::RefHolderBase >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_40752, type_40753), Reflex::Literal("operator="), operator_34101, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_40753), Reflex::Literal("RefHolder"), constructor_34102, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefHolder"), constructor_34103, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13700), Reflex::Literal("RefHolder"), constructor_34104, 0, "ref", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefHolder"), destructor_34106, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_21296, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x156, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s__funcmem_bld);
}

//------Delayed data member builder for class RefHolder<edm::Ref<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >, reco::CaloMET, edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >, reco::CaloMET> > > -------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4914, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefHolder<edm::Ref<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >, reco::CaloMET, edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET, std::allocator<reco::CaloMET> >, reco::CaloMET> > > -------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_40752), Reflex::Literal("swap"), method_34105, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21583), Reflex::Literal("clone"), method_34107, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4866), Reflex::Literal("id"), method_34108, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2197), Reflex::Literal("key"), method_34109, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647, type_40258), Reflex::Literal("isEqualTo"), method_34110, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647, type_21585, type_10457), Reflex::Literal("fillRefIfMyTypeMatches"), method_34111, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13700), Reflex::Literal("getRef"), method_34112, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_13700), Reflex::Literal("setRef"), method_34113, 0, "r", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("makeVectorHolder"), method_34114, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19828), Reflex::Literal("productGetter"), method_34115, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("hasProductCache"), method_34116, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4239), Reflex::Literal("product"), method_34117, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isAvailable"), method_34118, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_192), Reflex::Literal("Class_Version"), method_34119, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
//------Stub functions for class RefHolder<edm::Ref<std::vector<reco::MET, std::allocator<reco::MET> >, reco::MET, edm::refhelper::FindUsingAdvance<std::vector<reco::MET, std::allocator<reco::MET> >, reco::MET> > > -------------------------------
static  void operator_34122( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->operator=)(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)arg[0]);
  else   (((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->operator=)(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)arg[0]);
}

static void constructor_34123( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >(*(const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)arg[0]);
}

static void constructor_34124( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >();
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >();
}

static void constructor_34125( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >(*(const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)arg[0]);
  else ::new(mem) ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >(*(const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)arg[0]);
}

static  void method_34126( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->swap)(*(::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)arg[0]);
}

static void destructor_34127(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >::~RefHolder)();
}
static  void method_34128( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->clone)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->clone)();
}

static  void method_34129( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::ProductID)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->id)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->id)();
}

static  void method_34130( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->key)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->key)();
}

static  void method_34131( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]));
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->isEqualTo)(*(const ::edm::reftobase::RefHolderBase*)arg[0]);
}

static  void method_34132( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]));
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->fillRefIfMyTypeMatches)(*(::edm::reftobase::RefHolderBase*)arg[0],
    *(::std::basic_string<char>*)arg[1]);
}

static  void method_34133( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->getRef)();
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->getRef)();
}

static  void method_34134( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->setRef)(*(const ::edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >*)arg[0]);
}

static  void method_34135( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::auto_ptr<edm::reftobase::RefVectorHolderBase>)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->makeVectorHolder)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->makeVectorHolder)();
}

static  void method_34136( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->productGetter)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->productGetter)();
}

static  void method_34137( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->hasProductCache)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->hasProductCache)();
}

static  void method_34138( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->product)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->product)();
}

static  void method_34139( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->isAvailable)());
  else   (((const ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->isAvailable)();
}

static  void method_34140( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (short)((((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->Class_Version)());
  else   (((::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >*)o)->Class_Version)();
}

static void method_newdel_21297( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x158( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::reftobase::RefHolderBase")), ::Reflex::BaseOffset< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >,::edm::reftobase::RefHolderBase >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class RefHolder<edm::Ref<std::vector<reco::MET, std::allocator<reco::MET> >, reco::MET, edm::refhelper::FindUsingAdvance<std::vector<reco::MET, std::allocator<reco::MET> >, reco::MET> > > -------------------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s__db_datamem(Reflex::Class*);
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s__datamem_bld(&__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s__funcmem_bld(&__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s__db_funcmem);
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >"), typeid(::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >), sizeof(::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >::Class_Version())
  .AddProperty(Reflex::Literal("o_name"), "edm::reftobase::RefHolder<reco::METRef>")
  .AddBase(type_12173, ::Reflex::BaseOffset< ::edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >, ::edm::reftobase::RefHolderBase >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_40754, type_40755), Reflex::Literal("operator="), operator_34122, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_40755), Reflex::Literal("RefHolder"), constructor_34123, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("RefHolder"), constructor_34124, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13570), Reflex::Literal("RefHolder"), constructor_34125, 0, "ref", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~RefHolder"), destructor_34127, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_21297, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x158, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s__funcmem_bld);
}

//------Delayed data member builder for class RefHolder<edm::Ref<std::vector<reco::MET, std::allocator<reco::MET> >, reco::MET, edm::refhelper::FindUsingAdvance<std::vector<reco::MET, std::allocator<reco::MET> >, reco::MET> > > -------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4913, Reflex::Literal("ref_"), OffsetOf(__shadow__::__edm__reftobase__RefHolder_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s_, ref_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class RefHolder<edm::Ref<std::vector<reco::MET, std::allocator<reco::MET> >, reco::MET, edm::refhelper::FindUsingAdvance<std::vector<reco::MET, std::allocator<reco::MET> >, reco::MET> > > -------------------
void __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_40754), Reflex::Literal("swap"), method_34126, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21583), Reflex::Literal("clone"), method_34128, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4866), Reflex::Literal("id"), method_34129, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2197), Reflex::Literal("key"), method_34130, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647, type_40258), Reflex::Literal("isEqualTo"), method_34131, 0, "rhs", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647, type_21585, type_10457), Reflex::Literal("fillRefIfMyTypeMatches"), method_34132, 0, "fillme;msg", ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_13570), Reflex::Literal("getRef"), method_34133, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_409, type_13570), Reflex::Literal("setRef"), method_34134, 0, "r", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2892), Reflex::Literal("makeVectorHolder"), method_34135, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19828), Reflex::Literal("productGetter"), method_34136, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("hasProductCache"), method_34137, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4239), Reflex::Literal("product"), method_34138, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1647), Reflex::Literal("isAvailable"), method_34139, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_192), Reflex::Literal("Class_Version"), method_34140, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __HcalNoiseSummary_dict(); 
      __SpecificPFMETData_dict(); 
      __SpecificCaloMETData_dict(); 
      __AnomalousECALVariables_dict(); 
      __CorrMETData_dict(); 
      __BoundaryInformation_dict(); 
      __PFMEtSignCovMatrix_dict(); 
      __CommonMETData_dict(); 
      __SpecificGenMETData_dict(); 
      __std__vector_BoundaryInformation__dict(); 
      __metsig__SigInputObj_dict(); 
      __std__vector_metsig__SigInputObj__dict(); 
      __std__vector_CorrMETData__dict(); 
      __std__vector_CommonMETData__dict(); 
      __reco__MET_dict(); 
      __edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s__dict(); 
      __std__vector_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s__dict(); 
      __std__vector_reco__MET__dict(); 
      __reco__CaloMET_dict(); 
      __edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s__dict(); 
      __std__vector_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s__dict(); 
      __std__vector_reco__CaloMET__dict(); 
      __std__vector_Point3DBase_float_GlobalTag_s__dict(); 
      __reco__PhiWedge_dict(); 
      __std__vector_reco__PhiWedge__dict(); 
      __std__vector_SpecificPFMETData__dict(); 
      __std__vector_SpecificCaloMETData__dict(); 
      __reco__HcalNoiseHPD_dict(); 
      __std__vector_reco__HcalNoiseHPD__dict(); 
      __reco__PFClusterMET_dict(); 
      __std__vector_reco__PFClusterMET__dict(); 
      __reco__PFMET_dict(); 
      __std__vector_reco__PFMET__dict(); 
      __reco__GenMET_dict(); 
      __std__vector_reco__GenMET__dict(); 
      __edm__PtrVector_reco__MET__dict(); 
      __edm__RefVector_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s__dict(); 
      __edm__RefVector_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s__dict(); 
      __edm__RefVector_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s__dict(); 
      __edm__RefVector_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s__dict(); 
      __edm__RefVector_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s__dict(); 
      __edm__Wrapper_std__vector_BoundaryInformation_s__dict(); 
      __edm__Wrapper_BoundaryInformation__dict(); 
      __edm__Wrapper_AnomalousECALVariables__dict(); 
      __edm__Wrapper_PFMEtSignCovMatrix__dict(); 
      __edm__Wrapper_std__vector_metsig__SigInputObj_s__dict(); 
      __edm__Wrapper_metsig__SigInputObj__dict(); 
      __edm__Wrapper_std__vector_CorrMETData_s__dict(); 
      __edm__Wrapper_CorrMETData__dict(); 
      __edm__Wrapper_std__vector_CommonMETData_s__dict(); 
      __edm__Wrapper_CommonMETData__dict(); 
      __edm__Wrapper_std__vector_Point3DBase_float_GlobalTag_s_s__dict(); 
      __reco__BeamHaloSummary_dict(); 
      __edm__Wrapper_reco__BeamHaloSummary__dict(); 
      __reco__GlobalHaloData_dict(); 
      __edm__Wrapper_reco__GlobalHaloData__dict(); 
      __reco__CSCHaloData_dict(); 
      __edm__Wrapper_reco__CSCHaloData__dict(); 
      __reco__HcalHaloData_dict(); 
      __edm__Wrapper_reco__HcalHaloData__dict(); 
      __reco__EcalHaloData_dict(); 
      __edm__Wrapper_reco__EcalHaloData__dict(); 
      __edm__Wrapper_reco__PhiWedge__dict(); 
      __edm__Wrapper_HcalNoiseSummary__dict(); 
      __edm__Wrapper_std__vector_reco__PFClusterMET_s__dict(); 
      __edm__Wrapper_reco__PFClusterMET__dict(); 
      __edm__Wrapper_std__vector_reco__PFMET_s__dict(); 
      __edm__Wrapper_reco__PFMET__dict(); 
      __edm__Wrapper_std__vector_reco__MET_s__dict(); 
      __edm__Wrapper_reco__MET__dict(); 
      __edm__Wrapper_std__vector_reco__GenMET_s__dict(); 
      __edm__Wrapper_reco__GenMET__dict(); 
      __edm__Wrapper_std__vector_reco__CaloMET_s__dict(); 
      __edm__Wrapper_reco__CaloMET__dict(); 
      __edm__RefProd_std__vector_reco__PFClusterMET_s__dict(); 
      __edm__RefProd_std__vector_reco__PFMET_s__dict(); 
      __edm__RefProd_std__vector_reco__MET_s__dict(); 
      __edm__RefProd_std__vector_reco__GenMET_s__dict(); 
      __edm__RefProd_std__vector_reco__CaloMET_s__dict(); 
      __edm__Ptr_reco__MET__dict(); 
      __edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s__dict(); 
      __edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s__dict(); 
      __edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s__dict(); 
      __reco__MVAMEtPFCandInfo_dict(); 
      __reco__HcalNoiseRBX_dict(); 
      __reco__MVAMEtJetInfo_dict(); 
      __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_s__dict(); 
      __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_s__dict(); 
      __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s__dict(); 
      __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_s__dict(); 
      __edm__reftobase__Holder_reco__Candidate_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s__dict(); 
      __std__vector_reco__MVAMEtPFCandInfo__dict(); 
      __std__vector_reco__HcalNoiseRBX__dict(); 
      __std__vector_reco__MVAMEtJetInfo__dict(); 
      ____gnu_cxx____normal_iterator_reco__PhiWedgep_std__vector_reco__PhiWedge_s__dict(); 
      ____gnu_cxx____normal_iterator_constsreco__HcalNoiseHPDp_std__vector_reco__HcalNoiseHPD_s__dict(); 
      __edm__Wrapper_std__vector_reco__MVAMEtPFCandInfo_s__dict(); 
      __edm__Wrapper_std__vector_reco__MVAMEtJetInfo_s__dict(); 
      __edm__Wrapper_std__vector_reco__HcalNoiseRBX_s__dict(); 
      __edm__Wrapper_std__vector_reco__HcalNoiseHPD_s__dict(); 
      __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__PFClusterMET__reco__PFClusterMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFClusterMET__reco__PFClusterMET_s_s__dict(); 
      __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__PFMET__reco__PFMET_edm__refhelper__FindUsingAdvance_std__vector_reco__PFMET__reco__PFMET_s_s__dict(); 
      __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__GenMET__reco__GenMET_edm__refhelper__FindUsingAdvance_std__vector_reco__GenMET__reco__GenMET_s_s__dict(); 
      __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__CaloMET__reco__CaloMET_edm__refhelper__FindUsingAdvance_std__vector_reco__CaloMET__reco__CaloMET_s_s__dict(); 
      __edm__reftobase__RefHolder_edm__Ref_std__vector_reco__MET__reco__MET_edm__refhelper__FindUsingAdvance_std__vector_reco__MET__reco__MET_s_s__dict(); 
    }
    ~Dictionaries() {
      type_87.Unload(); // class HcalNoiseSummary 
      type_468.Unload(); // class SpecificPFMETData 
      type_930.Unload(); // class SpecificCaloMETData 
      type_1114.Unload(); // class AnomalousECALVariables 
      type_1653.Unload(); // class CorrMETData 
      type_2126.Unload(); // class BoundaryInformation 
      type_2233.Unload(); // class PFMEtSignCovMatrix 
      type_2300.Unload(); // class CommonMETData 
      type_2320.Unload(); // class SpecificGenMETData 
      type_3139.Unload(); // class std::vector<BoundaryInformation> 
      type_3824.Unload(); // class metsig::SigInputObj 
      type_3142.Unload(); // class std::vector<metsig::SigInputObj> 
      type_3143.Unload(); // class std::vector<CorrMETData> 
      type_3144.Unload(); // class std::vector<CommonMETData> 
      type_7952.Unload(); // class reco::MET 
      type_4913.Unload(); // class edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > 
      type_3145.Unload(); // class std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > 
      type_3146.Unload(); // class std::vector<reco::MET> 
      type_8011.Unload(); // class reco::CaloMET 
      type_4914.Unload(); // class edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > 
      type_3147.Unload(); // class std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > 
      type_3148.Unload(); // class std::vector<reco::CaloMET> 
      type_3149.Unload(); // class std::vector<Point3DBase<float,GlobalTag> > 
      type_7934.Unload(); // class reco::PhiWedge 
      type_3150.Unload(); // class std::vector<reco::PhiWedge> 
      type_3151.Unload(); // class std::vector<SpecificPFMETData> 
      type_3152.Unload(); // class std::vector<SpecificCaloMETData> 
      type_8033.Unload(); // class reco::HcalNoiseHPD 
      type_3154.Unload(); // class std::vector<reco::HcalNoiseHPD> 
      type_7916.Unload(); // class reco::PFClusterMET 
      type_3155.Unload(); // class std::vector<reco::PFClusterMET> 
      type_7918.Unload(); // class reco::PFMET 
      type_3157.Unload(); // class std::vector<reco::PFMET> 
      type_7970.Unload(); // class reco::GenMET 
      type_3158.Unload(); // class std::vector<reco::GenMET> 
      type_4622.Unload(); // class edm::PtrVector<reco::MET> 
      type_4631.Unload(); // class edm::RefVector<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > 
      type_4636.Unload(); // class edm::RefVector<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > 
      type_4641.Unload(); // class edm::RefVector<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > 
      type_4646.Unload(); // class edm::RefVector<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > 
      type_4651.Unload(); // class edm::RefVector<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > 
      type_4694.Unload(); // class edm::Wrapper<std::vector<BoundaryInformation> > 
      type_4695.Unload(); // class edm::Wrapper<BoundaryInformation> 
      type_4696.Unload(); // class edm::Wrapper<AnomalousECALVariables> 
      type_4697.Unload(); // class edm::Wrapper<PFMEtSignCovMatrix> 
      type_4700.Unload(); // class edm::Wrapper<std::vector<metsig::SigInputObj> > 
      type_4701.Unload(); // class edm::Wrapper<metsig::SigInputObj> 
      type_4702.Unload(); // class edm::Wrapper<std::vector<CorrMETData> > 
      type_4703.Unload(); // class edm::Wrapper<CorrMETData> 
      type_4704.Unload(); // class edm::Wrapper<std::vector<CommonMETData> > 
      type_4705.Unload(); // class edm::Wrapper<CommonMETData> 
      type_4706.Unload(); // class edm::Wrapper<std::vector<Point3DBase<float,GlobalTag> > > 
      type_7946.Unload(); // class reco::BeamHaloSummary 
      type_4707.Unload(); // class edm::Wrapper<reco::BeamHaloSummary> 
      type_7935.Unload(); // class reco::GlobalHaloData 
      type_4708.Unload(); // class edm::Wrapper<reco::GlobalHaloData> 
      type_7975.Unload(); // class reco::CSCHaloData 
      type_4709.Unload(); // class edm::Wrapper<reco::CSCHaloData> 
      type_7923.Unload(); // class reco::HcalHaloData 
      type_4710.Unload(); // class edm::Wrapper<reco::HcalHaloData> 
      type_7925.Unload(); // class reco::EcalHaloData 
      type_4711.Unload(); // class edm::Wrapper<reco::EcalHaloData> 
      type_4712.Unload(); // class edm::Wrapper<reco::PhiWedge> 
      type_4713.Unload(); // class edm::Wrapper<HcalNoiseSummary> 
      type_4716.Unload(); // class edm::Wrapper<std::vector<reco::PFClusterMET> > 
      type_4717.Unload(); // class edm::Wrapper<reco::PFClusterMET> 
      type_4718.Unload(); // class edm::Wrapper<std::vector<reco::PFMET> > 
      type_4719.Unload(); // class edm::Wrapper<reco::PFMET> 
      type_4720.Unload(); // class edm::Wrapper<std::vector<reco::MET> > 
      type_4721.Unload(); // class edm::Wrapper<reco::MET> 
      type_4722.Unload(); // class edm::Wrapper<std::vector<reco::GenMET> > 
      type_4723.Unload(); // class edm::Wrapper<reco::GenMET> 
      type_4724.Unload(); // class edm::Wrapper<std::vector<reco::CaloMET> > 
      type_4725.Unload(); // class edm::Wrapper<reco::CaloMET> 
      type_4883.Unload(); // class edm::RefProd<std::vector<reco::PFClusterMET> > 
      type_4884.Unload(); // class edm::RefProd<std::vector<reco::PFMET> > 
      type_4885.Unload(); // class edm::RefProd<std::vector<reco::MET> > 
      type_4886.Unload(); // class edm::RefProd<std::vector<reco::GenMET> > 
      type_4887.Unload(); // class edm::RefProd<std::vector<reco::CaloMET> > 
      type_4901.Unload(); // class edm::Ptr<reco::MET> 
      type_4915.Unload(); // class edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > 
      type_4916.Unload(); // class edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > 
      type_4917.Unload(); // class edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > 
      type_7941.Unload(); // class reco::MVAMEtPFCandInfo 
      type_7976.Unload(); // class reco::HcalNoiseRBX 
      type_8009.Unload(); // class reco::MVAMEtJetInfo 
      type_21302.Unload(); // class edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > > 
      type_21303.Unload(); // class edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > > 
      type_21304.Unload(); // class edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > 
      type_21305.Unload(); // class edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > > 
      type_21306.Unload(); // class edm::reftobase::Holder<reco::Candidate,edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > 
      type_3140.Unload(); // class std::vector<reco::MVAMEtPFCandInfo> 
      type_3153.Unload(); // class std::vector<reco::HcalNoiseRBX> 
      type_3141.Unload(); // class std::vector<reco::MVAMEtJetInfo> 
      type_8161.Unload(); // class __gnu_cxx::__normal_iterator<reco::PhiWedge*,std::vector<reco::PhiWedge> > 
      type_8190.Unload(); // class __gnu_cxx::__normal_iterator<const reco::HcalNoiseHPD*,std::vector<reco::HcalNoiseHPD> > 
      type_4698.Unload(); // class edm::Wrapper<std::vector<reco::MVAMEtPFCandInfo> > 
      type_4699.Unload(); // class edm::Wrapper<std::vector<reco::MVAMEtJetInfo> > 
      type_4714.Unload(); // class edm::Wrapper<std::vector<reco::HcalNoiseRBX> > 
      type_4715.Unload(); // class edm::Wrapper<std::vector<reco::HcalNoiseHPD> > 
      type_21293.Unload(); // class edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFClusterMET>,reco::PFClusterMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFClusterMET>,reco::PFClusterMET> > > 
      type_21294.Unload(); // class edm::reftobase::RefHolder<edm::Ref<std::vector<reco::PFMET>,reco::PFMET,edm::refhelper::FindUsingAdvance<std::vector<reco::PFMET>,reco::PFMET> > > 
      type_21295.Unload(); // class edm::reftobase::RefHolder<edm::Ref<std::vector<reco::GenMET>,reco::GenMET,edm::refhelper::FindUsingAdvance<std::vector<reco::GenMET>,reco::GenMET> > > 
      type_21296.Unload(); // class edm::reftobase::RefHolder<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > > 
      type_21297.Unload(); // class edm::reftobase::RefHolder<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > > 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
