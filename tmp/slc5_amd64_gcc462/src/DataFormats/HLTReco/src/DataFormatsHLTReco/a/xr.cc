// Generated at Fri Feb 28 12:36:09 2014. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gccxml/20110825/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gccxml/20110825/bin/gccxml_cc1plus"
  GCCXML_CPP="/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gccxml/20110825/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='2' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='1' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.6.2"' -D__UINT64_C(c)='c ## UL' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__GNUC_MINOR__='6' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -iwrapper"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gccxml/20110825/share/gccxml-0.9/GCC/4.6" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../include/c++/4.6.2" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../include/c++/4.6.2/x86_64-unknown-linux-gnu" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../include/c++/4.6.2/backward" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/include" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/include-fixed" -isystem"/usr/local/include" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gccxml/20110825/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.6.2
Copyright (C) 2011 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "/afs/hep.wisc.edu/user/stephane/sync_setup/src/DataFormats/HLTReco/src/classes.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("trigger") );
  ::Reflex::NamespaceBuilder nsb2( Reflex::Literal("edm") );
  ::Reflex::NamespaceBuilder nsb3( Reflex::Literal("reco") );
  ::Reflex::NamespaceBuilder nsb4( Reflex::Literal("__gnu_cxx") );
  ::Reflex::Type type_71 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_11 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_253 = ::Reflex::TypeBuilder(Reflex::Literal("char"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_1166 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_1374 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_788 = ::Reflex::TypeBuilder(Reflex::Literal("float"));
  ::Reflex::Type type_108 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_301 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_292 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_211 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned short"));
  ::Reflex::Type type_4302 = ::Reflex::TypeBuilder(Reflex::Literal("edm::InputTag"));
  ::Reflex::Type type_431 = ::Reflex::TypeBuilder(Reflex::Literal("std::type_info"));
  ::Reflex::Type type_5534 = ::Reflex::TypeBuilder(Reflex::Literal("reco::Particle"));
  ::Reflex::Type type_4529 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ProductID"));
  ::Reflex::Type type_4572 = ::Reflex::TypeBuilder(Reflex::Literal("edm::EventTime"));
  ::Reflex::Type type_4535 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ModuleTime"));
  ::Reflex::Type type_2706 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<int>"));
  ::Reflex::Type type_1073 = ::Reflex::TypeBuilder(Reflex::Literal("HLTPerformanceInfo"));
  ::Reflex::Type type_4494 = ::Reflex::TypeBuilder(Reflex::Literal("edm::HLTPathStatus"));
  ::Reflex::Type type_3621 = ::Reflex::TypeBuilder(Reflex::Literal("trigger::TriggerEvent"));
  ::Reflex::Type type_3617 = ::Reflex::TypeBuilder(Reflex::Literal("trigger::TriggerObject"));
  ::Reflex::Type type_2201 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_4498 = ::Reflex::TypeBuilder(Reflex::Literal("edm::DoNotRecordParents"));
  ::Reflex::Type type_5236 = ::Reflex::TypeBuilder(Reflex::Literal("HLTPerformanceInfo::Path"));
  ::Reflex::Type type_2694 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const void*>"));
  ::Reflex::Type type_2696 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned int>"));
  ::Reflex::Type type_3619 = ::Reflex::TypeBuilder(Reflex::Literal("trigger::HLTPrescaleTable"));
  ::Reflex::Type type_2695 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long>"));
  ::Reflex::Type type_5237 = ::Reflex::TypeBuilder(Reflex::Literal("HLTPerformanceInfo::Module"));
  ::Reflex::Type type_2705 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::InputTag>"));
  ::Reflex::Type type_2704 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned short>"));
  ::Reflex::Type type_2768 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::ModuleTime>"));
  ::Reflex::Type type_3810 = ::Reflex::TypeBuilder(Reflex::Literal("boost::static_assert_test<1>"));
  ::Reflex::Type type_4402 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<edm::EventTime>"));
  ::Reflex::Type type_3600 = ::Reflex::TypeBuilder(Reflex::Literal("trigger::TriggerEventWithRefs"));
  ::Reflex::Type type_2460 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<edm::EventTime>"));
  ::Reflex::Type type_3604 = ::Reflex::EnumTypeBuilder(Reflex::Literal("trigger::TriggerObjectType"));
  ::Reflex::Type type_3626 = ::Reflex::TypeBuilder(Reflex::Literal("trigger::TriggerRefsCollections"));
  ::Reflex::Type type_3108 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<edm::ModuleTime>"));
  ::Reflex::Type type_2305 = ::Reflex::TypeBuilder(Reflex::Literal("std::random_access_iterator_tag"));
  ::Reflex::Type type_4401 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<HLTPerformanceInfo>"));
  ::Reflex::Type type_2459 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<HLTPerformanceInfo>"));
  ::Reflex::Type type_5549 = ::Reflex::TypeBuilder(Reflex::Literal("reco::HLTResult<8,unsigned short>"));
  ::Reflex::Type type_5547 = ::Reflex::TypeBuilder(Reflex::Literal("reco::HLTResult<24,unsigned short>"));
  ::Reflex::Type type_5548 = ::Reflex::TypeBuilder(Reflex::Literal("reco::HLTResult<16,unsigned short>"));
  ::Reflex::Type type_2702 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<trigger::TriggerObject>"));
  ::Reflex::Type type_2361 = ::Reflex::TypeBuilder(Reflex::Literal("std::less<std::basic_string<char> >"));
  ::Reflex::Type type_4396 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<trigger::TriggerEvent>"));
  ::Reflex::Type type_3614 = ::Reflex::TypeBuilder(Reflex::Literal("trigger::TriggerFilterObjectWithRefs"));
  ::Reflex::Type type_2454 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<trigger::TriggerEvent>"));
  ::Reflex::Type type_2698 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<HLTPerformanceInfo::Path>"));
  ::Reflex::Type type_2700 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::basic_string<char> >"));
  ::Reflex::Type type_4415 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<edm::EventTime>"));
  ::Reflex::Type type_3027 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<trigger::TriggerObject>"));
  ::Reflex::Type type_2699 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<HLTPerformanceInfo::Module>"));
  ::Reflex::Type type_2697 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<trigger::TriggerObjectType>"));
  ::Reflex::Type type_4394 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<trigger::HLTPrescaleTable>"));
  ::Reflex::Type type_3019 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<HLTPerformanceInfo::Path>"));
  ::Reflex::Type type_2636 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<unsigned short,unsigned short>"));
  ::Reflex::Type type_2452 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<trigger::HLTPrescaleTable>"));
  ::Reflex::Type type_4414 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<HLTPerformanceInfo>"));
  ::Reflex::Type type_3018 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<trigger::TriggerObjectType>"));
  ::Reflex::Type type_3020 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<HLTPerformanceInfo::Module>"));
  ::Reflex::Type type_11011 = ::Reflex::TypeBuilder(Reflex::Literal("trigger::TriggerEvent::TriggerFilterObject"));
  ::Reflex::Type type_24415 = ::Reflex::TypeBuilder(Reflex::Literal("reco::hlt::wordConstants<8,unsigned short>"));
  ::Reflex::Type type_4395 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<trigger::TriggerEventWithRefs>"));
  ::Reflex::Type type_2453 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<trigger::TriggerEventWithRefs>"));
  ::Reflex::Type type_4409 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<trigger::TriggerEvent>"));
  ::Reflex::Type type_24413 = ::Reflex::TypeBuilder(Reflex::Literal("reco::hlt::wordConstants<24,unsigned short>"));
  ::Reflex::Type type_24414 = ::Reflex::TypeBuilder(Reflex::Literal("reco::hlt::wordConstants<16,unsigned short>"));
  ::Reflex::Type type_4407 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<trigger::HLTPrescaleTable>"));
  ::Reflex::Type type_4405 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<reco::HLTResult<8,unsigned short> >"));
  ::Reflex::Type type_2463 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<reco::HLTResult<8,unsigned short> >"));
  ::Reflex::Type type_4403 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<reco::HLTResult<24,unsigned short> >"));
  ::Reflex::Type type_4404 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<reco::HLTResult<16,unsigned short> >"));
  ::Reflex::Type type_2461 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<reco::HLTResult<24,unsigned short> >"));
  ::Reflex::Type type_2462 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<reco::HLTResult<16,unsigned short> >"));
  ::Reflex::Type type_4397 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<trigger::TriggerFilterObjectWithRefs>"));
  ::Reflex::Type type_4398 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<trigger::TriggerObject> >"));
  ::Reflex::Type type_10884 = ::Reflex::TypeBuilder(Reflex::Literal("trigger::TriggerEventWithRefs::TriggerFilterObject"));
  ::Reflex::Type type_2455 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<trigger::TriggerFilterObjectWithRefs>"));
  ::Reflex::Type type_2456 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<trigger::TriggerObject> >"));
  ::Reflex::Type type_4408 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<trigger::TriggerEventWithRefs>"));
  ::Reflex::Type type_2211 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator_traits<const HLTPerformanceInfo::Path*>"));
  ::Reflex::Type type_3737 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_2703 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<trigger::TriggerEvent::TriggerFilterObject>"));
  ::Reflex::Type type_2210 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator_traits<const trigger::TriggerObjectType*>"));
  ::Reflex::Type type_2272 = ::Reflex::TypeBuilder(Reflex::Literal("std::iterator_traits<const HLTPerformanceInfo::Module*>"));
  ::Reflex::Type type_4418 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<reco::HLTResult<8,unsigned short> >"));
  ::Reflex::Type type_3029 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<trigger::TriggerEvent::TriggerFilterObject>"));
  ::Reflex::Type type_4416 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<reco::HLTResult<24,unsigned short> >"));
  ::Reflex::Type type_4417 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<reco::HLTResult<16,unsigned short> >"));
  ::Reflex::Type type_4410 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<trigger::TriggerFilterObjectWithRefs>"));
  ::Reflex::Type type_4411 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<trigger::TriggerObject> >"));
  ::Reflex::Type type_2916 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,std::vector<unsigned int> >"));
  ::Reflex::Type type_2701 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>"));
  ::Reflex::Type type_3025 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<trigger::TriggerEventWithRefs::TriggerFilterObject>"));
  ::Reflex::Type type_2193 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<edm::ModuleTime,std::allocator<edm::ModuleTime> >"));
  ::Reflex::Type type_2632 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<const std::basic_string<char>,std::vector<unsigned int> >"));
  ::Reflex::Type type_5809 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<edm::ModuleTime*,std::vector<edm::ModuleTime> >"));
  ::Reflex::Type type_5773 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const unsigned long*,std::vector<unsigned long> >"));
  ::Reflex::Type type_2135 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<trigger::TriggerObject,std::allocator<trigger::TriggerObject> >"));
  ::Reflex::Type type_5810 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const edm::ModuleTime*,std::vector<edm::ModuleTime> >"));
  ::Reflex::Type type_3016 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<std::pair<const std::basic_string<char>,std::vector<unsigned int> > >"));
  ::Reflex::Type type_2191 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HLTPerformanceInfo::Path,std::allocator<HLTPerformanceInfo::Path> >"));
  ::Reflex::Type type_2130 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<trigger::TriggerObjectType,std::allocator<trigger::TriggerObjectType> >"));
  ::Reflex::Type type_2190 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HLTPerformanceInfo::Module,std::allocator<HLTPerformanceInfo::Module> >"));
  ::Reflex::Type type_5695 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<trigger::TriggerObject*,std::vector<trigger::TriggerObject> >"));
  ::Reflex::Type type_2859 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<unsigned int> > >"));
  ::Reflex::Type type_5805 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >"));
  ::Reflex::Type type_5696 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const trigger::TriggerObject*,std::vector<trigger::TriggerObject> >"));
  ::Reflex::Type type_5807 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >"));
  ::Reflex::Type type_5688 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >"));
  ::Reflex::Type type_2482 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::vector<unsigned int> > >"));
  ::Reflex::Type type_5689 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >"));
  ::Reflex::Type type_3363 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<edm::ModuleTime*,std::vector<edm::ModuleTime> > >"));
  ::Reflex::Type type_5406 = ::Reflex::TypeBuilder(Reflex::Literal("ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>"));
  ::Reflex::Type type_5687 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >"));
  ::Reflex::Type type_5806 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >"));
  ::Reflex::Type type_3362 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const edm::ModuleTime*,std::vector<edm::ModuleTime> > >"));
  ::Reflex::Type type_2635 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<unsigned int> > >,bool>"));
  ::Reflex::Type type_4587 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> >"));
  ::Reflex::Type type_3233 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<trigger::TriggerObject*,std::vector<trigger::TriggerObject> > >"));
  ::Reflex::Type type_3227 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<unsigned int> > > >"));
  ::Reflex::Type type_3359 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> > >"));
  ::Reflex::Type type_4590 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> >"));
  ::Reflex::Type type_4580 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<reco::PFJet>,reco::PFJet,edm::refhelper::FindUsingAdvance<std::vector<reco::PFJet>,reco::PFJet> >"));
  ::Reflex::Type type_3232 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const trigger::TriggerObject*,std::vector<trigger::TriggerObject> > >"));
  ::Reflex::Type type_2136 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<trigger::TriggerEvent::TriggerFilterObject,std::allocator<trigger::TriggerEvent::TriggerFilterObject> >"));
  ::Reflex::Type type_3223 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> > >"));
  ::Reflex::Type type_3357 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> > >"));
  ::Reflex::Type type_3226 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::vector<unsigned int> > > >"));
  ::Reflex::Type type_3358 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> > >"));
  ::Reflex::Type type_2723 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::Ref<std::vector<reco::MET>,reco::MET,edm::refhelper::FindUsingAdvance<std::vector<reco::MET>,reco::MET> > >"));
  ::Reflex::Type type_4589 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<reco::CaloJet>,reco::CaloJet,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloJet>,reco::CaloJet> >"));
  ::Reflex::Type type_4586 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> >"));
  ::Reflex::Type type_3222 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> > >"));
  ::Reflex::Type type_3356 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> > >"));
  ::Reflex::Type type_5697 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<trigger::TriggerEvent::TriggerFilterObject*,std::vector<trigger::TriggerEvent::TriggerFilterObject> >"));
  ::Reflex::Type type_4593 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> >"));
  ::Reflex::Type type_2708 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::Ref<std::vector<reco::PFJet>,reco::PFJet,edm::refhelper::FindUsingAdvance<std::vector<reco::PFJet>,reco::PFJet> > >"));
  ::Reflex::Type type_2707 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >"));
  ::Reflex::Type type_3040 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >"));
  ::Reflex::Type type_5698 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const trigger::TriggerEvent::TriggerFilterObject*,std::vector<trigger::TriggerEvent::TriggerFilterObject> >"));
  ::Reflex::Type type_2132 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<trigger::TriggerEventWithRefs::TriggerFilterObject,std::allocator<trigger::TriggerEventWithRefs::TriggerFilterObject> >"));
  ::Reflex::Type type_2727 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::Ref<std::vector<reco::CaloJet>,reco::CaloJet,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloJet>,reco::CaloJet> > >"));
  ::Reflex::Type type_2721 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::Ref<std::vector<reco::CaloMET>,reco::CaloMET,edm::refhelper::FindUsingAdvance<std::vector<reco::CaloMET>,reco::CaloMET> > >"));
  ::Reflex::Type type_2730 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >"));
  ::Reflex::Type type_5690 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<trigger::TriggerEventWithRefs::TriggerFilterObject*,std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject> >"));
  ::Reflex::Type type_4581 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<l1extra::L1HFRings>,l1extra::L1HFRings,edm::refhelper::FindUsingAdvance<std::vector<l1extra::L1HFRings>,l1extra::L1HFRings> >"));
  ::Reflex::Type type_3057 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >"));
  ::Reflex::Type type_5691 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const trigger::TriggerEventWithRefs::TriggerFilterObject*,std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject> >"));
  ::Reflex::Type type_3231 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<trigger::TriggerEvent::TriggerFilterObject*,std::vector<trigger::TriggerEvent::TriggerFilterObject> > >"));
  ::Reflex::Type type_4585 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<l1extra::L1EmParticle>,l1extra::L1EmParticle,edm::refhelper::FindUsingAdvance<std::vector<l1extra::L1EmParticle>,l1extra::L1EmParticle> >"));
  ::Reflex::Type type_2710 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::Ref<std::vector<l1extra::L1HFRings>,l1extra::L1HFRings,edm::refhelper::FindUsingAdvance<std::vector<l1extra::L1HFRings>,l1extra::L1HFRings> > >"));
  ::Reflex::Type type_3230 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const trigger::TriggerEvent::TriggerFilterObject*,std::vector<trigger::TriggerEvent::TriggerFilterObject> > >"));
  ::Reflex::Type type_4583 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<l1extra::L1JetParticle>,l1extra::L1JetParticle,edm::refhelper::FindUsingAdvance<std::vector<l1extra::L1JetParticle>,l1extra::L1JetParticle> >"));
  ::Reflex::Type type_4594 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> >"));
  ::Reflex::Type type_4584 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<l1extra::L1MuonParticle>,l1extra::L1MuonParticle,edm::refhelper::FindUsingAdvance<std::vector<l1extra::L1MuonParticle>,l1extra::L1MuonParticle> >"));
  ::Reflex::Type type_3229 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<trigger::TriggerEventWithRefs::TriggerFilterObject*,std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject> > >"));
  ::Reflex::Type type_4588 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<reco::CompositeCandidate>,reco::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::CompositeCandidate>,reco::CompositeCandidate> >"));
  ::Reflex::Type type_2718 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::Ref<std::vector<l1extra::L1EmParticle>,l1extra::L1EmParticle,edm::refhelper::FindUsingAdvance<std::vector<l1extra::L1EmParticle>,l1extra::L1EmParticle> > >"));
  ::Reflex::Type type_4582 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<l1extra::L1EtMissParticle>,l1extra::L1EtMissParticle,edm::refhelper::FindUsingAdvance<std::vector<l1extra::L1EtMissParticle>,l1extra::L1EtMissParticle> >"));
  ::Reflex::Type type_2714 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::Ref<std::vector<l1extra::L1JetParticle>,l1extra::L1JetParticle,edm::refhelper::FindUsingAdvance<std::vector<l1extra::L1JetParticle>,l1extra::L1JetParticle> > >"));
  ::Reflex::Type type_3228 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const trigger::TriggerEventWithRefs::TriggerFilterObject*,std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject> > >"));
  ::Reflex::Type type_4592 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> >"));
  ::Reflex::Type type_2731 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >"));
  ::Reflex::Type type_2716 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::Ref<std::vector<l1extra::L1MuonParticle>,l1extra::L1MuonParticle,edm::refhelper::FindUsingAdvance<std::vector<l1extra::L1MuonParticle>,l1extra::L1MuonParticle> > >"));
  ::Reflex::Type type_3059 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >"));
  ::Reflex::Type type_2725 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::Ref<std::vector<reco::CompositeCandidate>,reco::CompositeCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::CompositeCandidate>,reco::CompositeCandidate> > >"));
  ::Reflex::Type type_2712 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::Ref<std::vector<l1extra::L1EtMissParticle>,l1extra::L1EtMissParticle,edm::refhelper::FindUsingAdvance<std::vector<l1extra::L1EtMissParticle>,l1extra::L1EtMissParticle> > >"));
  ::Reflex::Type type_2729 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >"));
  ::Reflex::Type type_3055 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >"));
  ::Reflex::Type type_2634 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<unsigned int> > >,std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<unsigned int> > > >"));
  ::Reflex::Type type_4591 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Ref<std::vector<reco::IsolatedPixelTrackCandidate>,reco::IsolatedPixelTrackCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::IsolatedPixelTrackCandidate>,reco::IsolatedPixelTrackCandidate> >"));
  ::Reflex::Type type_2633 = ::Reflex::TypeBuilder(Reflex::Literal("std::pair<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::vector<unsigned int> > >,std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::vector<unsigned int> > > >"));
  ::Reflex::Type type_2720 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::Ref<std::vector<reco::IsolatedPixelTrackCandidate>,reco::IsolatedPixelTrackCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::IsolatedPixelTrackCandidate>,reco::IsolatedPixelTrackCandidate> > >"));
  ::Reflex::Type type_2138 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> >,std::allocator<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > > >"));
  ::Reflex::Type type_5701 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> >*,std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > > >"));
  ::Reflex::Type type_5702 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> >*,std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > > >"));
  ::Reflex::Type type_2151 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> >,std::allocator<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > > >"));
  ::Reflex::Type type_3239 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> >*,std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > > > >"));
  ::Reflex::Type type_5728 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> >*,std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > > >"));
  ::Reflex::Type type_3238 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> >*,std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > > > >"));
  ::Reflex::Type type_5729 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> >*,std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > > >"));
  ::Reflex::Type type_2407 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Rb_tree<std::basic_string<char>,std::pair<const std::basic_string<char>,std::vector<unsigned int> >,std::_Select1st<std::pair<const std::basic_string<char>,std::vector<unsigned int> > >,std::less<std::basic_string<char> >,std::allocator<std::pair<const std::basic_string<char>,std::vector<unsigned int> > > >"));
  ::Reflex::Type type_3265 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> >*,std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > > > >"));
  ::Reflex::Type type_3264 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> >*,std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > > > >"));
  ::Reflex::Type type_2152 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> >,std::allocator<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > > >"));
  ::Reflex::Type type_5730 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> >*,std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > > >"));
  ::Reflex::Type type_5731 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> >*,std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > > >"));
  ::Reflex::Type type_2150 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> >,std::allocator<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > > >"));
  ::Reflex::Type type_5726 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> >*,std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > > >"));
  ::Reflex::Type type_3267 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> >*,std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > > > >"));
  ::Reflex::Type type_5727 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> >*,std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > > >"));
  ::Reflex::Type type_3266 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> >*,std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > > > >"));
  ::Reflex::Type type_3263 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> >*,std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > > > >"));
  ::Reflex::Type type_3262 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> >*,std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > > > >"));
  ::Reflex::Type type_3623 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("trigger::TriggerObjectCollection"), type_2702);
  ::Reflex::Type type_10649 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<trigger::TriggerObjectType>::const_iterator"), type_5687);
  ::Reflex::Type type_10710 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<HLTPerformanceInfo::Path>::const_iterator"), type_5689);
  ::Reflex::Type type_10771 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::vector<HLTPerformanceInfo::Module>::const_iterator"), type_5806);
  ::Reflex::Type type_3516 = ::Reflex::ReferenceBuilder(type_1073);
  ::Reflex::Type type_1073c = ::Reflex::ConstBuilder(type_1073);
  ::Reflex::Type type_3518 = ::Reflex::ReferenceBuilder(type_1073c);
  ::Reflex::Type type_5236c = ::Reflex::ConstBuilder(type_5236);
  ::Reflex::Type type_7399 = ::Reflex::ReferenceBuilder(type_5236c);
  ::Reflex::Type type_5237c = ::Reflex::ConstBuilder(type_5237);
  ::Reflex::Type type_8050 = ::Reflex::ReferenceBuilder(type_5237c);
  ::Reflex::Type type_253c = ::Reflex::ConstBuilder(type_253);
  ::Reflex::Type type_3421 = ::Reflex::PointerBuilder(type_253c);
  ::Reflex::Type type_1813 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("size_t"), type_292);
  ::Reflex::Type type_1813c = ::Reflex::ConstBuilder(type_1813);
  ::Reflex::Type type_10642 = ::Reflex::PointerBuilder(type_3604);
  ::Reflex::Type type_3604c = ::Reflex::ConstBuilder(type_3604);
  ::Reflex::Type type_7386 = ::Reflex::PointerBuilder(type_3604c);
  ::Reflex::Type type_10645 = ::Reflex::ReferenceBuilder(type_3604);
  ::Reflex::Type type_7388 = ::Reflex::ReferenceBuilder(type_3604c);
  ::Reflex::Type type_3004 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_292);
  ::Reflex::Type type_2891 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_11);
  ::Reflex::Type type_3018c = ::Reflex::ConstBuilder(type_3018);
  ::Reflex::Type type_28852 = ::Reflex::ReferenceBuilder(type_3018c);
  ::Reflex::Type type_2697c = ::Reflex::ConstBuilder(type_2697);
  ::Reflex::Type type_30235 = ::Reflex::ReferenceBuilder(type_2697c);
  ::Reflex::Type type_30236 = ::Reflex::ReferenceBuilder(type_2697);
  ::Reflex::Type type_2202 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::string"), type_2201);
  ::Reflex::Type type_8039 = ::Reflex::ReferenceBuilder(type_5236);
  ::Reflex::Type type_2202c = ::Reflex::ConstBuilder(type_2202);
  ::Reflex::Type type_4494c = ::Reflex::ConstBuilder(type_4494);
  ::Reflex::Type type_35434 = ::Reflex::ReferenceBuilder(type_4494c);
  ::Reflex::Type type_8037 = ::Reflex::PointerBuilder(type_5236);
  ::Reflex::Type type_7397 = ::Reflex::PointerBuilder(type_5236c);
  ::Reflex::Type type_3019c = ::Reflex::ConstBuilder(type_3019);
  ::Reflex::Type type_29583 = ::Reflex::ReferenceBuilder(type_3019c);
  ::Reflex::Type type_2698c = ::Reflex::ConstBuilder(type_2698);
  ::Reflex::Type type_30237 = ::Reflex::ReferenceBuilder(type_2698c);
  ::Reflex::Type type_30238 = ::Reflex::ReferenceBuilder(type_2698);
  ::Reflex::Type type_8061 = ::Reflex::ReferenceBuilder(type_5237);
  ::Reflex::Type type_108c = ::Reflex::ConstBuilder(type_108);
  ::Reflex::Type type_8059 = ::Reflex::PointerBuilder(type_5237);
  ::Reflex::Type type_8048 = ::Reflex::PointerBuilder(type_5237c);
  ::Reflex::Type type_3020c = ::Reflex::ConstBuilder(type_3020);
  ::Reflex::Type type_29571 = ::Reflex::ReferenceBuilder(type_3020c);
  ::Reflex::Type type_2699c = ::Reflex::ConstBuilder(type_2699);
  ::Reflex::Type type_30239 = ::Reflex::ReferenceBuilder(type_2699c);
  ::Reflex::Type type_30240 = ::Reflex::ReferenceBuilder(type_2699);
  ::Reflex::Type type_30891 = ::Reflex::ReferenceBuilder(type_3600);
  ::Reflex::Type type_3600c = ::Reflex::ConstBuilder(type_3600);
  ::Reflex::Type type_30892 = ::Reflex::ReferenceBuilder(type_3600c);
  ::Reflex::Type type_14768 = ::Reflex::ReferenceBuilder(type_2202c);
  ::Reflex::Type type_1534 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("uint16_t"), type_211);
  ::Reflex::Type type_3599 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("trigger::size_type"), type_1534);
  ::Reflex::Type type_4302c = ::Reflex::ConstBuilder(type_4302);
  ::Reflex::Type type_11148 = ::Reflex::ReferenceBuilder(type_4302c);
  ::Reflex::Type type_3614c = ::Reflex::ConstBuilder(type_3614);
  ::Reflex::Type type_30893 = ::Reflex::ReferenceBuilder(type_3614c);
  ::Reflex::Type type_3611 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("trigger::Vids"), type_2706);
  ::Reflex::Type type_14641 = ::Reflex::ReferenceBuilder(type_3611);
  ::Reflex::Type type_3622 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("trigger::VRphoton"), type_2731);
  ::Reflex::Type type_14655 = ::Reflex::ReferenceBuilder(type_3622);
  ::Reflex::Type type_3601 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("trigger::VRelectron"), type_2730);
  ::Reflex::Type type_14654 = ::Reflex::ReferenceBuilder(type_3601);
  ::Reflex::Type type_3615 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("trigger::VRmuon"), type_2729);
  ::Reflex::Type type_14653 = ::Reflex::ReferenceBuilder(type_3615);
  ::Reflex::Type type_3603 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("trigger::VRjet"), type_2727);
  ::Reflex::Type type_14652 = ::Reflex::ReferenceBuilder(type_3603);
  ::Reflex::Type type_3616 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("trigger::VRcomposite"), type_2725);
  ::Reflex::Type type_14651 = ::Reflex::ReferenceBuilder(type_3616);
  ::Reflex::Type type_3625 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("trigger::VRbasemet"), type_2723);
  ::Reflex::Type type_14650 = ::Reflex::ReferenceBuilder(type_3625);
  ::Reflex::Type type_3610 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("trigger::VRcalomet"), type_2721);
  ::Reflex::Type type_14649 = ::Reflex::ReferenceBuilder(type_3610);
  ::Reflex::Type type_3602 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("trigger::VRpixtrack"), type_2720);
  ::Reflex::Type type_14648 = ::Reflex::ReferenceBuilder(type_3602);
  ::Reflex::Type type_3606 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("trigger::VRl1em"), type_2718);
  ::Reflex::Type type_14647 = ::Reflex::ReferenceBuilder(type_3606);
  ::Reflex::Type type_3608 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("trigger::VRl1muon"), type_2716);
  ::Reflex::Type type_14646 = ::Reflex::ReferenceBuilder(type_3608);
  ::Reflex::Type type_3620 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("trigger::VRl1jet"), type_2714);
  ::Reflex::Type type_14645 = ::Reflex::ReferenceBuilder(type_3620);
  ::Reflex::Type type_3605 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("trigger::VRl1etmiss"), type_2712);
  ::Reflex::Type type_14644 = ::Reflex::ReferenceBuilder(type_3605);
  ::Reflex::Type type_3609 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("trigger::VRl1hfrings"), type_2710);
  ::Reflex::Type type_14643 = ::Reflex::ReferenceBuilder(type_3609);
  ::Reflex::Type type_3624 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("trigger::VRpfjet"), type_2708);
  ::Reflex::Type type_14642 = ::Reflex::ReferenceBuilder(type_3624);
  ::Reflex::Type type_3607 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("trigger::VRpftau"), type_2707);
  ::Reflex::Type type_14640 = ::Reflex::ReferenceBuilder(type_3607);
  ::Reflex::Type type_10893 = ::Reflex::ReferenceBuilder(type_10884);
  ::Reflex::Type type_10884c = ::Reflex::ConstBuilder(type_10884);
  ::Reflex::Type type_10895 = ::Reflex::ReferenceBuilder(type_10884c);
  ::Reflex::Type type_10889 = ::Reflex::PointerBuilder(type_10884);
  ::Reflex::Type type_10891 = ::Reflex::PointerBuilder(type_10884c);
  ::Reflex::Type type_3025c = ::Reflex::ConstBuilder(type_3025);
  ::Reflex::Type type_28875 = ::Reflex::ReferenceBuilder(type_3025c);
  ::Reflex::Type type_2701c = ::Reflex::ConstBuilder(type_2701);
  ::Reflex::Type type_30263 = ::Reflex::ReferenceBuilder(type_2701c);
  ::Reflex::Type type_30264 = ::Reflex::ReferenceBuilder(type_2701);
  ::Reflex::Type type_3618 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("trigger::Keys"), type_2704);
  ::Reflex::Type type_30897 = ::Reflex::ReferenceBuilder(type_3621);
  ::Reflex::Type type_3621c = ::Reflex::ConstBuilder(type_3621);
  ::Reflex::Type type_30898 = ::Reflex::ReferenceBuilder(type_3621c);
  ::Reflex::Type type_3623c = ::Reflex::ConstBuilder(type_3623);
  ::Reflex::Type type_30899 = ::Reflex::ReferenceBuilder(type_3623c);
  ::Reflex::Type type_2705c = ::Reflex::ConstBuilder(type_2705);
  ::Reflex::Type type_30282 = ::Reflex::ReferenceBuilder(type_2705c);
  ::Reflex::Type type_3618c = ::Reflex::ConstBuilder(type_3618);
  ::Reflex::Type type_30900 = ::Reflex::ReferenceBuilder(type_3618c);
  ::Reflex::Type type_2700c = ::Reflex::ConstBuilder(type_2700);
  ::Reflex::Type type_9766 = ::Reflex::ReferenceBuilder(type_2700c);
  ::Reflex::Type type_3611c = ::Reflex::ConstBuilder(type_3611);
  ::Reflex::Type type_30901 = ::Reflex::ReferenceBuilder(type_3611c);
  ::Reflex::Type type_11020 = ::Reflex::ReferenceBuilder(type_11011);
  ::Reflex::Type type_11011c = ::Reflex::ConstBuilder(type_11011);
  ::Reflex::Type type_11022 = ::Reflex::ReferenceBuilder(type_11011c);
  ::Reflex::Type type_11016 = ::Reflex::PointerBuilder(type_11011);
  ::Reflex::Type type_11018 = ::Reflex::PointerBuilder(type_11011c);
  ::Reflex::Type type_3029c = ::Reflex::ConstBuilder(type_3029);
  ::Reflex::Type type_28923 = ::Reflex::ReferenceBuilder(type_3029c);
  ::Reflex::Type type_2703c = ::Reflex::ConstBuilder(type_2703);
  ::Reflex::Type type_30277 = ::Reflex::ReferenceBuilder(type_2703c);
  ::Reflex::Type type_30278 = ::Reflex::ReferenceBuilder(type_2703);
  ::Reflex::Type type_7462 = ::Reflex::PointerBuilder(type_4590);
  ::Reflex::Type type_4590c = ::Reflex::ConstBuilder(type_4590);
  ::Reflex::Type type_7451 = ::Reflex::PointerBuilder(type_4590c);
  ::Reflex::Type type_7464 = ::Reflex::ReferenceBuilder(type_4590);
  ::Reflex::Type type_7453 = ::Reflex::ReferenceBuilder(type_4590c);
  ::Reflex::Type type_3040c = ::Reflex::ConstBuilder(type_3040);
  ::Reflex::Type type_28947 = ::Reflex::ReferenceBuilder(type_3040c);
  ::Reflex::Type type_2707c = ::Reflex::ConstBuilder(type_2707);
  ::Reflex::Type type_30285 = ::Reflex::ReferenceBuilder(type_2707c);
  ::Reflex::Type type_14624 = ::Reflex::ReferenceBuilder(type_2707);
  ::Reflex::Type type_7726 = ::Reflex::PointerBuilder(type_4592);
  ::Reflex::Type type_4592c = ::Reflex::ConstBuilder(type_4592);
  ::Reflex::Type type_7715 = ::Reflex::PointerBuilder(type_4592c);
  ::Reflex::Type type_7728 = ::Reflex::ReferenceBuilder(type_4592);
  ::Reflex::Type type_7717 = ::Reflex::ReferenceBuilder(type_4592c);
  ::Reflex::Type type_3055c = ::Reflex::ConstBuilder(type_3055);
  ::Reflex::Type type_29091 = ::Reflex::ReferenceBuilder(type_3055c);
  ::Reflex::Type type_2729c = ::Reflex::ConstBuilder(type_2729);
  ::Reflex::Type type_30317 = ::Reflex::ReferenceBuilder(type_2729c);
  ::Reflex::Type type_14637 = ::Reflex::ReferenceBuilder(type_2729);
  ::Reflex::Type type_7748 = ::Reflex::PointerBuilder(type_4593);
  ::Reflex::Type type_4593c = ::Reflex::ConstBuilder(type_4593);
  ::Reflex::Type type_7737 = ::Reflex::PointerBuilder(type_4593c);
  ::Reflex::Type type_7750 = ::Reflex::ReferenceBuilder(type_4593);
  ::Reflex::Type type_7739 = ::Reflex::ReferenceBuilder(type_4593c);
  ::Reflex::Type type_3057c = ::Reflex::ConstBuilder(type_3057);
  ::Reflex::Type type_29103 = ::Reflex::ReferenceBuilder(type_3057c);
  ::Reflex::Type type_2730c = ::Reflex::ConstBuilder(type_2730);
  ::Reflex::Type type_30318 = ::Reflex::ReferenceBuilder(type_2730c);
  ::Reflex::Type type_14638 = ::Reflex::ReferenceBuilder(type_2730);
  ::Reflex::Type type_7770 = ::Reflex::PointerBuilder(type_4594);
  ::Reflex::Type type_4594c = ::Reflex::ConstBuilder(type_4594);
  ::Reflex::Type type_7759 = ::Reflex::PointerBuilder(type_4594c);
  ::Reflex::Type type_7772 = ::Reflex::ReferenceBuilder(type_4594);
  ::Reflex::Type type_7761 = ::Reflex::ReferenceBuilder(type_4594c);
  ::Reflex::Type type_3059c = ::Reflex::ConstBuilder(type_3059);
  ::Reflex::Type type_29115 = ::Reflex::ReferenceBuilder(type_3059c);
  ::Reflex::Type type_2731c = ::Reflex::ConstBuilder(type_2731);
  ::Reflex::Type type_30319 = ::Reflex::ReferenceBuilder(type_2731c);
  ::Reflex::Type type_14639 = ::Reflex::ReferenceBuilder(type_2731);
  ::Reflex::Type type_14375 = ::Reflex::ReferenceBuilder(type_4535);
  ::Reflex::Type type_4535c = ::Reflex::ConstBuilder(type_4535);
  ::Reflex::Type type_14377 = ::Reflex::ReferenceBuilder(type_4535c);
  ::Reflex::Type type_14371 = ::Reflex::PointerBuilder(type_4535);
  ::Reflex::Type type_14373 = ::Reflex::PointerBuilder(type_4535c);
  ::Reflex::Type type_3108c = ::Reflex::ConstBuilder(type_3108);
  ::Reflex::Type type_29607 = ::Reflex::ReferenceBuilder(type_3108c);
  ::Reflex::Type type_2768c = ::Reflex::ConstBuilder(type_2768);
  ::Reflex::Type type_30384 = ::Reflex::ReferenceBuilder(type_2768c);
  ::Reflex::Type type_30385 = ::Reflex::ReferenceBuilder(type_2768);
  ::Reflex::Type type_8827 = ::Reflex::PointerBuilder(type_2632);
  ::Reflex::Type type_2632c = ::Reflex::ConstBuilder(type_2632);
  ::Reflex::Type type_8829 = ::Reflex::PointerBuilder(type_2632c);
  ::Reflex::Type type_8831 = ::Reflex::ReferenceBuilder(type_2632);
  ::Reflex::Type type_8833 = ::Reflex::ReferenceBuilder(type_2632c);
  ::Reflex::Type type_2361c = ::Reflex::ConstBuilder(type_2361);
  ::Reflex::Type type_29951 = ::Reflex::ReferenceBuilder(type_2361c);
  ::Reflex::Type type_3016c = ::Reflex::ConstBuilder(type_3016);
  ::Reflex::Type type_30015 = ::Reflex::ReferenceBuilder(type_3016c);
  ::Reflex::Type type_2916c = ::Reflex::ConstBuilder(type_2916);
  ::Reflex::Type type_9765 = ::Reflex::ReferenceBuilder(type_2916c);
  ::Reflex::Type type_30503 = ::Reflex::ReferenceBuilder(type_2916);
  ::Reflex::Type type_30234 = ::Reflex::ReferenceBuilder(type_2696);
  ::Reflex::Type type_2201c = ::Reflex::ConstBuilder(type_2201);
  ::Reflex::Type type_7804 = ::Reflex::ReferenceBuilder(type_2201c);
  ::Reflex::Type type_2696c = ::Reflex::ConstBuilder(type_2696);
  ::Reflex::Type type_30213 = ::Reflex::ReferenceBuilder(type_2696c);
  ::Reflex::Type type_17988 = ::Reflex::ReferenceBuilder(type_3614);
  ::Reflex::Type type_30283 = ::Reflex::ReferenceBuilder(type_2705);
  ::Reflex::Type type_7442 = ::Reflex::ReferenceBuilder(type_3617);
  ::Reflex::Type type_3617c = ::Reflex::ConstBuilder(type_3617);
  ::Reflex::Type type_7431 = ::Reflex::ReferenceBuilder(type_3617c);
  ::Reflex::Type type_5413 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("math::XYZPointD"), type_5406);
  ::Reflex::Type type_5407 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("math::XYZPoint"), type_5413);
  ::Reflex::Type type_5407c = ::Reflex::ConstBuilder(type_5407);
  ::Reflex::Type type_30894 = ::Reflex::ReferenceBuilder(type_5407c);
  ::Reflex::Type type_30895 = ::Reflex::ReferenceBuilder(type_3619);
  ::Reflex::Type type_3619c = ::Reflex::ConstBuilder(type_3619);
  ::Reflex::Type type_30896 = ::Reflex::ReferenceBuilder(type_3619c);
  ::Reflex::Type type_17989 = ::Reflex::ReferenceBuilder(type_3626);
  ::Reflex::Type type_3626c = ::Reflex::ConstBuilder(type_3626);
  ::Reflex::Type type_30902 = ::Reflex::ReferenceBuilder(type_3626c);
  ::Reflex::Type type_5536 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::RecoEcalCandidateRef"), type_4594);
  ::Reflex::Type type_5536c = ::Reflex::ConstBuilder(type_5536);
  ::Reflex::Type type_30903 = ::Reflex::ReferenceBuilder(type_5536c);
  ::Reflex::Type type_5560 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::ElectronRef"), type_4593);
  ::Reflex::Type type_5560c = ::Reflex::ConstBuilder(type_5560);
  ::Reflex::Type type_30904 = ::Reflex::ReferenceBuilder(type_5560c);
  ::Reflex::Type type_5493 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::RecoChargedCandidateRef"), type_4592);
  ::Reflex::Type type_5493c = ::Reflex::ConstBuilder(type_5493);
  ::Reflex::Type type_30905 = ::Reflex::ReferenceBuilder(type_5493c);
  ::Reflex::Type type_5539 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::CaloJetRef"), type_4589);
  ::Reflex::Type type_5539c = ::Reflex::ConstBuilder(type_5539);
  ::Reflex::Type type_30906 = ::Reflex::ReferenceBuilder(type_5539c);
  ::Reflex::Type type_5527 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::CompositeCandidateRef"), type_4588);
  ::Reflex::Type type_5527c = ::Reflex::ConstBuilder(type_5527);
  ::Reflex::Type type_30907 = ::Reflex::ReferenceBuilder(type_5527c);
  ::Reflex::Type type_5551 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::METRef"), type_4587);
  ::Reflex::Type type_5551c = ::Reflex::ConstBuilder(type_5551);
  ::Reflex::Type type_30908 = ::Reflex::ReferenceBuilder(type_5551c);
  ::Reflex::Type type_5497 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::CaloMETRef"), type_4586);
  ::Reflex::Type type_5497c = ::Reflex::ConstBuilder(type_5497);
  ::Reflex::Type type_30909 = ::Reflex::ReferenceBuilder(type_5497c);
  ::Reflex::Type type_5503 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::IsolatedPixelTrackCandidateRef"), type_4591);
  ::Reflex::Type type_5503c = ::Reflex::ConstBuilder(type_5503);
  ::Reflex::Type type_30910 = ::Reflex::ReferenceBuilder(type_5503c);
  ::Reflex::Type type_4765 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("l1extra::L1EmParticleRef"), type_4585);
  ::Reflex::Type type_4765c = ::Reflex::ConstBuilder(type_4765);
  ::Reflex::Type type_30911 = ::Reflex::ReferenceBuilder(type_4765c);
  ::Reflex::Type type_4768 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("l1extra::L1MuonParticleRef"), type_4584);
  ::Reflex::Type type_4768c = ::Reflex::ConstBuilder(type_4768);
  ::Reflex::Type type_30912 = ::Reflex::ReferenceBuilder(type_4768c);
  ::Reflex::Type type_4771 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("l1extra::L1JetParticleRef"), type_4583);
  ::Reflex::Type type_4771c = ::Reflex::ConstBuilder(type_4771);
  ::Reflex::Type type_30913 = ::Reflex::ReferenceBuilder(type_4771c);
  ::Reflex::Type type_4776 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("l1extra::L1EtMissParticleRef"), type_4582);
  ::Reflex::Type type_4776c = ::Reflex::ConstBuilder(type_4776);
  ::Reflex::Type type_30914 = ::Reflex::ReferenceBuilder(type_4776c);
  ::Reflex::Type type_4769 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("l1extra::L1HFRingsRef"), type_4581);
  ::Reflex::Type type_4769c = ::Reflex::ConstBuilder(type_4769);
  ::Reflex::Type type_30915 = ::Reflex::ReferenceBuilder(type_4769c);
  ::Reflex::Type type_5553 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::PFJetRef"), type_4580);
  ::Reflex::Type type_5553c = ::Reflex::ConstBuilder(type_5553);
  ::Reflex::Type type_30916 = ::Reflex::ReferenceBuilder(type_5553c);
  ::Reflex::Type type_5479 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::PFTauRef"), type_4590);
  ::Reflex::Type type_5479c = ::Reflex::ConstBuilder(type_5479);
  ::Reflex::Type type_30917 = ::Reflex::ReferenceBuilder(type_5479c);
  ::Reflex::Type type_3622c = ::Reflex::ConstBuilder(type_3622);
  ::Reflex::Type type_30918 = ::Reflex::ReferenceBuilder(type_3622c);
  ::Reflex::Type type_3601c = ::Reflex::ConstBuilder(type_3601);
  ::Reflex::Type type_30919 = ::Reflex::ReferenceBuilder(type_3601c);
  ::Reflex::Type type_3615c = ::Reflex::ConstBuilder(type_3615);
  ::Reflex::Type type_30920 = ::Reflex::ReferenceBuilder(type_3615c);
  ::Reflex::Type type_3603c = ::Reflex::ConstBuilder(type_3603);
  ::Reflex::Type type_30921 = ::Reflex::ReferenceBuilder(type_3603c);
  ::Reflex::Type type_3616c = ::Reflex::ConstBuilder(type_3616);
  ::Reflex::Type type_30922 = ::Reflex::ReferenceBuilder(type_3616c);
  ::Reflex::Type type_3625c = ::Reflex::ConstBuilder(type_3625);
  ::Reflex::Type type_30923 = ::Reflex::ReferenceBuilder(type_3625c);
  ::Reflex::Type type_3610c = ::Reflex::ConstBuilder(type_3610);
  ::Reflex::Type type_30924 = ::Reflex::ReferenceBuilder(type_3610c);
  ::Reflex::Type type_3602c = ::Reflex::ConstBuilder(type_3602);
  ::Reflex::Type type_30925 = ::Reflex::ReferenceBuilder(type_3602c);
  ::Reflex::Type type_3606c = ::Reflex::ConstBuilder(type_3606);
  ::Reflex::Type type_30926 = ::Reflex::ReferenceBuilder(type_3606c);
  ::Reflex::Type type_3608c = ::Reflex::ConstBuilder(type_3608);
  ::Reflex::Type type_30927 = ::Reflex::ReferenceBuilder(type_3608c);
  ::Reflex::Type type_3620c = ::Reflex::ConstBuilder(type_3620);
  ::Reflex::Type type_30928 = ::Reflex::ReferenceBuilder(type_3620c);
  ::Reflex::Type type_3605c = ::Reflex::ConstBuilder(type_3605);
  ::Reflex::Type type_30929 = ::Reflex::ReferenceBuilder(type_3605c);
  ::Reflex::Type type_3609c = ::Reflex::ConstBuilder(type_3609);
  ::Reflex::Type type_30930 = ::Reflex::ReferenceBuilder(type_3609c);
  ::Reflex::Type type_3624c = ::Reflex::ConstBuilder(type_3624);
  ::Reflex::Type type_30931 = ::Reflex::ReferenceBuilder(type_3624c);
  ::Reflex::Type type_3607c = ::Reflex::ConstBuilder(type_3607);
  ::Reflex::Type type_30932 = ::Reflex::ReferenceBuilder(type_3607c);
  ::Reflex::Type type_35343 = ::Reflex::PointerBuilder(type_3619c);
  ::Reflex::Type type_431c = ::Reflex::ConstBuilder(type_431);
  ::Reflex::Type type_5473 = ::Reflex::ReferenceBuilder(type_431c);
  ::Reflex::Type type_35344 = ::Reflex::PointerBuilder(type_3619);
  ::Reflex::Type type_4407c = ::Reflex::ConstBuilder(type_4407);
  ::Reflex::Type type_35345 = ::Reflex::PointerBuilder(type_4407c);
  ::Reflex::Type type_4529c = ::Reflex::ConstBuilder(type_4529);
  ::Reflex::Type type_21974 = ::Reflex::ReferenceBuilder(type_4529c);
  ::Reflex::Type type_23583 = ::Reflex::ReferenceBuilder(type_2694);
  ::Reflex::Type type_31062 = ::Reflex::ReferenceBuilder(type_3737);
  ::Reflex::Type type_1166c = ::Reflex::ConstBuilder(type_1166);
  ::Reflex::Type type_3575 = ::Reflex::PointerBuilder(type_1166c);
  ::Reflex::Type type_7999 = ::Reflex::ReferenceBuilder(type_3575);
  ::Reflex::Type type_2695c = ::Reflex::ConstBuilder(type_2695);
  ::Reflex::Type type_23585 = ::Reflex::ReferenceBuilder(type_2695c);
  ::Reflex::Type type_35348 = ::Reflex::PointerBuilder(type_3600c);
  ::Reflex::Type type_35349 = ::Reflex::PointerBuilder(type_3600);
  ::Reflex::Type type_4408c = ::Reflex::ConstBuilder(type_4408);
  ::Reflex::Type type_35350 = ::Reflex::PointerBuilder(type_4408c);
  ::Reflex::Type type_35353 = ::Reflex::PointerBuilder(type_3621c);
  ::Reflex::Type type_35354 = ::Reflex::PointerBuilder(type_3621);
  ::Reflex::Type type_4409c = ::Reflex::ConstBuilder(type_4409);
  ::Reflex::Type type_35355 = ::Reflex::PointerBuilder(type_4409c);
  ::Reflex::Type type_35358 = ::Reflex::PointerBuilder(type_3614c);
  ::Reflex::Type type_35359 = ::Reflex::PointerBuilder(type_3614);
  ::Reflex::Type type_4410c = ::Reflex::ConstBuilder(type_4410);
  ::Reflex::Type type_35360 = ::Reflex::PointerBuilder(type_4410c);
  ::Reflex::Type type_3514 = ::Reflex::PointerBuilder(type_1073c);
  ::Reflex::Type type_3512 = ::Reflex::PointerBuilder(type_1073);
  ::Reflex::Type type_4414c = ::Reflex::ConstBuilder(type_4414);
  ::Reflex::Type type_35378 = ::Reflex::PointerBuilder(type_4414c);
  ::Reflex::Type type_35504 = ::Reflex::ReferenceBuilder(type_4572);
  ::Reflex::Type type_4572c = ::Reflex::ConstBuilder(type_4572);
  ::Reflex::Type type_35505 = ::Reflex::ReferenceBuilder(type_4572c);
  ::Reflex::Type type_35381 = ::Reflex::PointerBuilder(type_4572c);
  ::Reflex::Type type_35382 = ::Reflex::PointerBuilder(type_4572);
  ::Reflex::Type type_4415c = ::Reflex::ConstBuilder(type_4415);
  ::Reflex::Type type_35383 = ::Reflex::PointerBuilder(type_4415c);
  ::Reflex::Type type_36346 = ::Reflex::ArrayBuilder(type_211, 12);
  ::Reflex::Type type_36347 = ::Reflex::ReferenceBuilder(type_5547);
  ::Reflex::Type type_5547c = ::Reflex::ConstBuilder(type_5547);
  ::Reflex::Type type_36348 = ::Reflex::ReferenceBuilder(type_5547c);
  ::Reflex::Type type_3458 = ::Reflex::PointerBuilder(type_211);
  ::Reflex::Type type_35386 = ::Reflex::PointerBuilder(type_5547c);
  ::Reflex::Type type_35387 = ::Reflex::PointerBuilder(type_5547);
  ::Reflex::Type type_4416c = ::Reflex::ConstBuilder(type_4416);
  ::Reflex::Type type_35388 = ::Reflex::PointerBuilder(type_4416c);
  ::Reflex::Type type_36349 = ::Reflex::ArrayBuilder(type_211, 8);
  ::Reflex::Type type_36350 = ::Reflex::ReferenceBuilder(type_5548);
  ::Reflex::Type type_5548c = ::Reflex::ConstBuilder(type_5548);
  ::Reflex::Type type_36351 = ::Reflex::ReferenceBuilder(type_5548c);
  ::Reflex::Type type_35391 = ::Reflex::PointerBuilder(type_5548c);
  ::Reflex::Type type_35392 = ::Reflex::PointerBuilder(type_5548);
  ::Reflex::Type type_4417c = ::Reflex::ConstBuilder(type_4417);
  ::Reflex::Type type_35393 = ::Reflex::PointerBuilder(type_4417c);
  ::Reflex::Type type_36352 = ::Reflex::ArrayBuilder(type_211, 4);
  ::Reflex::Type type_36353 = ::Reflex::ReferenceBuilder(type_5549);
  ::Reflex::Type type_5549c = ::Reflex::ConstBuilder(type_5549);
  ::Reflex::Type type_36354 = ::Reflex::ReferenceBuilder(type_5549c);
  ::Reflex::Type type_35396 = ::Reflex::PointerBuilder(type_5549c);
  ::Reflex::Type type_35397 = ::Reflex::PointerBuilder(type_5549);
  ::Reflex::Type type_4418c = ::Reflex::ConstBuilder(type_4418);
  ::Reflex::Type type_35398 = ::Reflex::PointerBuilder(type_4418c);
  ::Reflex::Type type_7440 = ::Reflex::PointerBuilder(type_3617);
  ::Reflex::Type type_7429 = ::Reflex::PointerBuilder(type_3617c);
  ::Reflex::Type type_3027c = ::Reflex::ConstBuilder(type_3027);
  ::Reflex::Type type_28911 = ::Reflex::ReferenceBuilder(type_3027c);
  ::Reflex::Type type_2702c = ::Reflex::ConstBuilder(type_2702);
  ::Reflex::Type type_30265 = ::Reflex::ReferenceBuilder(type_2702c);
  ::Reflex::Type type_30266 = ::Reflex::ReferenceBuilder(type_2702);
  ::Reflex::Type type_36544 = ::Reflex::ReferenceBuilder(type_5687);
  ::Reflex::Type type_5687c = ::Reflex::ConstBuilder(type_5687);
  ::Reflex::Type type_36545 = ::Reflex::ReferenceBuilder(type_5687c);
  ::Reflex::Type type_7386c = ::Reflex::ConstBuilder(type_7386);
  ::Reflex::Type type_36546 = ::Reflex::ReferenceBuilder(type_7386c);
  ::Reflex::Type type_2891c = ::Reflex::ConstBuilder(type_2891);
  ::Reflex::Type type_36547 = ::Reflex::ReferenceBuilder(type_2891c);
  ::Reflex::Type type_36548 = ::Reflex::ReferenceBuilder(type_5689);
  ::Reflex::Type type_5689c = ::Reflex::ConstBuilder(type_5689);
  ::Reflex::Type type_36549 = ::Reflex::ReferenceBuilder(type_5689c);
  ::Reflex::Type type_7397c = ::Reflex::ConstBuilder(type_7397);
  ::Reflex::Type type_36550 = ::Reflex::ReferenceBuilder(type_7397c);
  ::Reflex::Type type_36709 = ::Reflex::ReferenceBuilder(type_5806);
  ::Reflex::Type type_5806c = ::Reflex::ConstBuilder(type_5806);
  ::Reflex::Type type_27615 = ::Reflex::ReferenceBuilder(type_5806c);
  ::Reflex::Type type_8048c = ::Reflex::ConstBuilder(type_8048);
  ::Reflex::Type type_36710 = ::Reflex::ReferenceBuilder(type_8048c);
  ::Reflex::Type type_35363 = ::Reflex::PointerBuilder(type_2702c);
  ::Reflex::Type type_35364 = ::Reflex::PointerBuilder(type_2702);
  ::Reflex::Type type_4411c = ::Reflex::ConstBuilder(type_4411);
  ::Reflex::Type type_35365 = ::Reflex::PointerBuilder(type_4411c);
  ::Reflex::Type type_4398f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<trigger::TriggerObjectCollection>"), type_4398);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __HLTPerformanceInfo
#undef __HLTPerformanceInfo
#endif
class __HLTPerformanceInfo {
  public:
  __HLTPerformanceInfo();
  ::std::vector<HLTPerformanceInfo::Path> paths_;
  ::std::vector<HLTPerformanceInfo::Module> modules_;
};
#ifdef __std__vector_trigger__TriggerObjectType_
#undef __std__vector_trigger__TriggerObjectType_
#endif
class __std__vector_trigger__TriggerObjectType_ : protected ::std::_Vector_base<trigger::TriggerObjectType,std::allocator<trigger::TriggerObjectType> > {
  public:
  __std__vector_trigger__TriggerObjectType_();
};
#ifdef __HLTPerformanceInfo__Path
#undef __HLTPerformanceInfo__Path
#endif
class __HLTPerformanceInfo__Path {
  public:
  __HLTPerformanceInfo__Path();
  ::std::string name_;
  ::std::vector<unsigned long> moduleView_;
  ::edm::HLTPathStatus status_;
};
#ifdef __std__vector_HLTPerformanceInfo__Path_
#undef __std__vector_HLTPerformanceInfo__Path_
#endif
class __std__vector_HLTPerformanceInfo__Path_ : protected ::std::_Vector_base<HLTPerformanceInfo::Path,std::allocator<HLTPerformanceInfo::Path> > {
  public:
  __std__vector_HLTPerformanceInfo__Path_();
};
#ifdef __HLTPerformanceInfo__Module
#undef __HLTPerformanceInfo__Module
#endif
class __HLTPerformanceInfo__Module {
  public:
  __HLTPerformanceInfo__Module();
  ::std::string name_;
  double dt_;
  double dtCPU_;
  ::edm::HLTPathStatus status_;
};
#ifdef __std__vector_HLTPerformanceInfo__Module_
#undef __std__vector_HLTPerformanceInfo__Module_
#endif
class __std__vector_HLTPerformanceInfo__Module_ : protected ::std::_Vector_base<HLTPerformanceInfo::Module,std::allocator<HLTPerformanceInfo::Module> > {
  public:
  __std__vector_HLTPerformanceInfo__Module_();
};
#ifdef __trigger__TriggerEventWithRefs
#undef __trigger__TriggerEventWithRefs
#endif
class __trigger__TriggerEventWithRefs : public ::trigger::TriggerRefsCollections, public ::edm::DoNotRecordParents {
  public:
  __trigger__TriggerEventWithRefs();
  ::std::string usedProcessName_;
  ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject> filterObjects_;
};
#ifdef __trigger__TriggerEventWithRefs__TriggerFilterObject
#undef __trigger__TriggerEventWithRefs__TriggerFilterObject
#endif
class __trigger__TriggerEventWithRefs__TriggerFilterObject {
  public:
  __trigger__TriggerEventWithRefs__TriggerFilterObject();
  ::std::string filterTag_;
  ::trigger::size_type photons_;
  ::trigger::size_type electrons_;
  ::trigger::size_type muons_;
  ::trigger::size_type jets_;
  ::trigger::size_type composites_;
  ::trigger::size_type basemets_;
  ::trigger::size_type calomets_;
  ::trigger::size_type pixtracks_;
  ::trigger::size_type l1em_;
  ::trigger::size_type l1muon_;
  ::trigger::size_type l1jet_;
  ::trigger::size_type l1etmiss_;
  ::trigger::size_type l1hfrings_;
  ::trigger::size_type pfjets_;
  ::trigger::size_type pftaus_;
};
#ifdef __std__vector_trigger__TriggerEventWithRefs__TriggerFilterObject_
#undef __std__vector_trigger__TriggerEventWithRefs__TriggerFilterObject_
#endif
class __std__vector_trigger__TriggerEventWithRefs__TriggerFilterObject_ : protected ::std::_Vector_base<trigger::TriggerEventWithRefs::TriggerFilterObject,std::allocator<trigger::TriggerEventWithRefs::TriggerFilterObject> > {
  public:
  __std__vector_trigger__TriggerEventWithRefs__TriggerFilterObject_();
};
#ifdef __trigger__TriggerEvent
#undef __trigger__TriggerEvent
#endif
class __trigger__TriggerEvent : public ::edm::DoNotRecordParents {
  public:
  __trigger__TriggerEvent();
  ::std::string usedProcessName_;
  ::std::vector<std::basic_string<char> > collectionTags_;
  ::trigger::Keys collectionKeys_;
  ::trigger::TriggerObjectCollection triggerObjects_;
  ::std::vector<trigger::TriggerEvent::TriggerFilterObject> triggerFilters_;
};
#ifdef __trigger__TriggerEvent__TriggerFilterObject
#undef __trigger__TriggerEvent__TriggerFilterObject
#endif
class __trigger__TriggerEvent__TriggerFilterObject {
  public:
  __trigger__TriggerEvent__TriggerFilterObject();
  ::std::string filterTag_;
  ::trigger::Vids filterIds_;
  ::trigger::Keys filterKeys_;
};
#ifdef __std__vector_trigger__TriggerEvent__TriggerFilterObject_
#undef __std__vector_trigger__TriggerEvent__TriggerFilterObject_
#endif
class __std__vector_trigger__TriggerEvent__TriggerFilterObject_ : protected ::std::_Vector_base<trigger::TriggerEvent::TriggerFilterObject,std::allocator<trigger::TriggerEvent::TriggerFilterObject> > {
  public:
  __std__vector_trigger__TriggerEvent__TriggerFilterObject_();
};
#ifdef __std__vector_edm__Ref_std__vector_reco__PFTau__reco__PFTau_edm__refhelper__FindUsingAdvance_std__vector_reco__PFTau__reco__PFTau_s_s_
#undef __std__vector_edm__Ref_std__vector_reco__PFTau__reco__PFTau_edm__refhelper__FindUsingAdvance_std__vector_reco__PFTau__reco__PFTau_s_s_
#endif
class __std__vector_edm__Ref_std__vector_reco__PFTau__reco__PFTau_edm__refhelper__FindUsingAdvance_std__vector_reco__PFTau__reco__PFTau_s_s_ : protected ::std::_Vector_base<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> >,std::allocator<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > > > {
  public:
  __std__vector_edm__Ref_std__vector_reco__PFTau__reco__PFTau_edm__refhelper__FindUsingAdvance_std__vector_reco__PFTau__reco__PFTau_s_s_();
};
#ifdef __std__vector_edm__Ref_std__vector_reco__RecoChargedCandidate__reco__RecoChargedCandidate_edm__refhelper__FindUsingAdvance_std__vector_reco__RecoChargedCandidate__reco__RecoChargedCandidate_s_s_
#undef __std__vector_edm__Ref_std__vector_reco__RecoChargedCandidate__reco__RecoChargedCandidate_edm__refhelper__FindUsingAdvance_std__vector_reco__RecoChargedCandidate__reco__RecoChargedCandidate_s_s_
#endif
class __std__vector_edm__Ref_std__vector_reco__RecoChargedCandidate__reco__RecoChargedCandidate_edm__refhelper__FindUsingAdvance_std__vector_reco__RecoChargedCandidate__reco__RecoChargedCandidate_s_s_ : protected ::std::_Vector_base<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> >,std::allocator<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > > > {
  public:
  __std__vector_edm__Ref_std__vector_reco__RecoChargedCandidate__reco__RecoChargedCandidate_edm__refhelper__FindUsingAdvance_std__vector_reco__RecoChargedCandidate__reco__RecoChargedCandidate_s_s_();
};
#ifdef __std__vector_edm__Ref_std__vector_reco__Electron__reco__Electron_edm__refhelper__FindUsingAdvance_std__vector_reco__Electron__reco__Electron_s_s_
#undef __std__vector_edm__Ref_std__vector_reco__Electron__reco__Electron_edm__refhelper__FindUsingAdvance_std__vector_reco__Electron__reco__Electron_s_s_
#endif
class __std__vector_edm__Ref_std__vector_reco__Electron__reco__Electron_edm__refhelper__FindUsingAdvance_std__vector_reco__Electron__reco__Electron_s_s_ : protected ::std::_Vector_base<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> >,std::allocator<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > > > {
  public:
  __std__vector_edm__Ref_std__vector_reco__Electron__reco__Electron_edm__refhelper__FindUsingAdvance_std__vector_reco__Electron__reco__Electron_s_s_();
};
#ifdef __std__vector_edm__Ref_std__vector_reco__RecoEcalCandidate__reco__RecoEcalCandidate_edm__refhelper__FindUsingAdvance_std__vector_reco__RecoEcalCandidate__reco__RecoEcalCandidate_s_s_
#undef __std__vector_edm__Ref_std__vector_reco__RecoEcalCandidate__reco__RecoEcalCandidate_edm__refhelper__FindUsingAdvance_std__vector_reco__RecoEcalCandidate__reco__RecoEcalCandidate_s_s_
#endif
class __std__vector_edm__Ref_std__vector_reco__RecoEcalCandidate__reco__RecoEcalCandidate_edm__refhelper__FindUsingAdvance_std__vector_reco__RecoEcalCandidate__reco__RecoEcalCandidate_s_s_ : protected ::std::_Vector_base<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> >,std::allocator<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > > > {
  public:
  __std__vector_edm__Ref_std__vector_reco__RecoEcalCandidate__reco__RecoEcalCandidate_edm__refhelper__FindUsingAdvance_std__vector_reco__RecoEcalCandidate__reco__RecoEcalCandidate_s_s_();
};
#ifdef __edm__ModuleTime
#undef __edm__ModuleTime
#endif
class __edm__ModuleTime {
  public:
  __edm__ModuleTime();
  ::std::string name_;
  double time_;
};
#ifdef __std__vector_edm__ModuleTime_
#undef __std__vector_edm__ModuleTime_
#endif
class __std__vector_edm__ModuleTime_ : protected ::std::_Vector_base<edm::ModuleTime,std::allocator<edm::ModuleTime> > {
  public:
  __std__vector_edm__ModuleTime_();
};
#ifdef __std__map_std__basic_string_char__std__vector_unsignedsint_s_
#undef __std__map_std__basic_string_char__std__vector_unsignedsint_s_
#endif
class __std__map_std__basic_string_char__std__vector_unsignedsint_s_ {
  public:
  __std__map_std__basic_string_char__std__vector_unsignedsint_s_();
  ::std::_Rb_tree<std::basic_string<char>,std::pair<const std::basic_string<char>,std::vector<unsigned int> >,std::_Select1st<std::pair<const std::basic_string<char>,std::vector<unsigned int> > >,std::less<std::basic_string<char> >,std::allocator<std::pair<const std::basic_string<char>,std::vector<unsigned int> > > > _M_t;
};
#ifdef __trigger__TriggerFilterObjectWithRefs
#undef __trigger__TriggerFilterObjectWithRefs
#endif
class __trigger__TriggerFilterObjectWithRefs : public ::trigger::TriggerRefsCollections {
  public:
  __trigger__TriggerFilterObjectWithRefs();
  int path_;
  int module_;
  ::std::vector<std::basic_string<char> > collectionTags_;
};
#ifdef __trigger__TriggerObject
#undef __trigger__TriggerObject
#endif
class __trigger__TriggerObject {
  public:
  __trigger__TriggerObject();
  int id_;
  float pt_;
  float eta_;
  float phi_;
  float mass_;
};
#ifdef __trigger__HLTPrescaleTable
#undef __trigger__HLTPrescaleTable
#endif
class __trigger__HLTPrescaleTable {
  public:
  __trigger__HLTPrescaleTable();
  unsigned int set_;
  ::std::vector<std::basic_string<char> > labels_;
  ::std::map<std::basic_string<char>,std::vector<unsigned int> > table_;
};
#ifdef __trigger__TriggerRefsCollections
#undef __trigger__TriggerRefsCollections
#endif
class __trigger__TriggerRefsCollections {
  public:
  __trigger__TriggerRefsCollections();
  ::trigger::Vids photonIds_;
  ::trigger::VRphoton photonRefs_;
  ::trigger::Vids electronIds_;
  ::trigger::VRelectron electronRefs_;
  ::trigger::Vids muonIds_;
  ::trigger::VRmuon muonRefs_;
  ::trigger::Vids jetIds_;
  ::trigger::VRjet jetRefs_;
  ::trigger::Vids compositeIds_;
  ::trigger::VRcomposite compositeRefs_;
  ::trigger::Vids basemetIds_;
  ::trigger::VRbasemet basemetRefs_;
  ::trigger::Vids calometIds_;
  ::trigger::VRcalomet calometRefs_;
  ::trigger::Vids pixtrackIds_;
  ::trigger::VRpixtrack pixtrackRefs_;
  ::trigger::Vids l1emIds_;
  ::trigger::VRl1em l1emRefs_;
  ::trigger::Vids l1muonIds_;
  ::trigger::VRl1muon l1muonRefs_;
  ::trigger::Vids l1jetIds_;
  ::trigger::VRl1jet l1jetRefs_;
  ::trigger::Vids l1etmissIds_;
  ::trigger::VRl1etmiss l1etmissRefs_;
  ::trigger::Vids l1hfringsIds_;
  ::trigger::VRl1hfrings l1hfringsRefs_;
  ::trigger::Vids pfjetIds_;
  ::trigger::VRpfjet pfjetRefs_;
  ::trigger::Vids pftauIds_;
  ::trigger::VRpftau pftauRefs_;
};
#ifdef __edm__Wrapper_trigger__HLTPrescaleTable_
#undef __edm__Wrapper_trigger__HLTPrescaleTable_
#endif
class __edm__Wrapper_trigger__HLTPrescaleTable_ {
  public:
  __edm__Wrapper_trigger__HLTPrescaleTable_();
  bool present;
  ::trigger::HLTPrescaleTable obj;
};
#ifdef __edm__Wrapper_trigger__TriggerEventWithRefs_
#undef __edm__Wrapper_trigger__TriggerEventWithRefs_
#endif
class __edm__Wrapper_trigger__TriggerEventWithRefs_ {
  public:
  __edm__Wrapper_trigger__TriggerEventWithRefs_();
  bool present;
  ::trigger::TriggerEventWithRefs obj;
};
#ifdef __edm__Wrapper_trigger__TriggerEvent_
#undef __edm__Wrapper_trigger__TriggerEvent_
#endif
class __edm__Wrapper_trigger__TriggerEvent_ {
  public:
  __edm__Wrapper_trigger__TriggerEvent_();
  bool present;
  ::trigger::TriggerEvent obj;
};
#ifdef __edm__Wrapper_trigger__TriggerFilterObjectWithRefs_
#undef __edm__Wrapper_trigger__TriggerFilterObjectWithRefs_
#endif
class __edm__Wrapper_trigger__TriggerFilterObjectWithRefs_ {
  public:
  __edm__Wrapper_trigger__TriggerFilterObjectWithRefs_();
  bool present;
  ::trigger::TriggerFilterObjectWithRefs obj;
};
#ifdef __edm__Wrapper_HLTPerformanceInfo_
#undef __edm__Wrapper_HLTPerformanceInfo_
#endif
class __edm__Wrapper_HLTPerformanceInfo_ {
  public:
  __edm__Wrapper_HLTPerformanceInfo_();
  bool present;
  ::HLTPerformanceInfo obj;
};
#ifdef __edm__EventTime
#undef __edm__EventTime
#endif
class __edm__EventTime {
  public:
  __edm__EventTime();
  ::std::vector<edm::ModuleTime> moduleSet;
  double tot_time_;
};
#ifdef __edm__Wrapper_edm__EventTime_
#undef __edm__Wrapper_edm__EventTime_
#endif
class __edm__Wrapper_edm__EventTime_ {
  public:
  __edm__Wrapper_edm__EventTime_();
  bool present;
  ::edm::EventTime obj;
};
#ifdef __reco__HLTResult_24_unsignedsshort_
#undef __reco__HLTResult_24_unsignedsshort_
#endif
class __reco__HLTResult_24_unsignedsshort_ {
  public:
  __reco__HLTResult_24_unsignedsshort_();
#ifdef __reco__HLTResult_24_unsignedsshort_____63
#undef __reco__HLTResult_24_unsignedsshort_____63
#endif
  enum __reco__HLTResult_24_unsignedsshort_____63 {};
  unsigned short words_[12];
};
#ifdef __edm__Wrapper_reco__HLTResult_24_unsignedsshort_s_
#undef __edm__Wrapper_reco__HLTResult_24_unsignedsshort_s_
#endif
class __edm__Wrapper_reco__HLTResult_24_unsignedsshort_s_ {
  public:
  __edm__Wrapper_reco__HLTResult_24_unsignedsshort_s_();
  bool present;
  ::reco::HLTResult<24,unsigned short> obj;
};
#ifdef __reco__HLTResult_16_unsignedsshort_
#undef __reco__HLTResult_16_unsignedsshort_
#endif
class __reco__HLTResult_16_unsignedsshort_ {
  public:
  __reco__HLTResult_16_unsignedsshort_();
#ifdef __reco__HLTResult_16_unsignedsshort_____63
#undef __reco__HLTResult_16_unsignedsshort_____63
#endif
  enum __reco__HLTResult_16_unsignedsshort_____63 {};
  unsigned short words_[8];
};
#ifdef __edm__Wrapper_reco__HLTResult_16_unsignedsshort_s_
#undef __edm__Wrapper_reco__HLTResult_16_unsignedsshort_s_
#endif
class __edm__Wrapper_reco__HLTResult_16_unsignedsshort_s_ {
  public:
  __edm__Wrapper_reco__HLTResult_16_unsignedsshort_s_();
  bool present;
  ::reco::HLTResult<16,unsigned short> obj;
};
#ifdef __reco__HLTResult_8_unsignedsshort_
#undef __reco__HLTResult_8_unsignedsshort_
#endif
class __reco__HLTResult_8_unsignedsshort_ {
  public:
  __reco__HLTResult_8_unsignedsshort_();
#ifdef __reco__HLTResult_8_unsignedsshort_____63
#undef __reco__HLTResult_8_unsignedsshort_____63
#endif
  enum __reco__HLTResult_8_unsignedsshort_____63 {};
  unsigned short words_[4];
};
#ifdef __edm__Wrapper_reco__HLTResult_8_unsignedsshort_s_
#undef __edm__Wrapper_reco__HLTResult_8_unsignedsshort_s_
#endif
class __edm__Wrapper_reco__HLTResult_8_unsignedsshort_s_ {
  public:
  __edm__Wrapper_reco__HLTResult_8_unsignedsshort_s_();
  bool present;
  ::reco::HLTResult<8,unsigned short> obj;
};
#ifdef __std__vector_trigger__TriggerObject_
#undef __std__vector_trigger__TriggerObject_
#endif
class __std__vector_trigger__TriggerObject_ : protected ::std::_Vector_base<trigger::TriggerObject,std::allocator<trigger::TriggerObject> > {
  public:
  __std__vector_trigger__TriggerObject_();
};
#ifdef ____gnu_cxx____normal_iterator_conststrigger__TriggerObjectTypep_std__vector_trigger__TriggerObjectType_s_
#undef ____gnu_cxx____normal_iterator_conststrigger__TriggerObjectTypep_std__vector_trigger__TriggerObjectType_s_
#endif
class ____gnu_cxx____normal_iterator_conststrigger__TriggerObjectTypep_std__vector_trigger__TriggerObjectType_s_ {
  public:
  ____gnu_cxx____normal_iterator_conststrigger__TriggerObjectTypep_std__vector_trigger__TriggerObjectType_s_();
  void* _M_current;
};
#ifdef ____gnu_cxx____normal_iterator_constsHLTPerformanceInfo__Pathp_std__vector_HLTPerformanceInfo__Path_s_
#undef ____gnu_cxx____normal_iterator_constsHLTPerformanceInfo__Pathp_std__vector_HLTPerformanceInfo__Path_s_
#endif
class ____gnu_cxx____normal_iterator_constsHLTPerformanceInfo__Pathp_std__vector_HLTPerformanceInfo__Path_s_ {
  public:
  ____gnu_cxx____normal_iterator_constsHLTPerformanceInfo__Pathp_std__vector_HLTPerformanceInfo__Path_s_();
  void* _M_current;
};
#ifdef ____gnu_cxx____normal_iterator_constsHLTPerformanceInfo__Modulep_std__vector_HLTPerformanceInfo__Module_s_
#undef ____gnu_cxx____normal_iterator_constsHLTPerformanceInfo__Modulep_std__vector_HLTPerformanceInfo__Module_s_
#endif
class ____gnu_cxx____normal_iterator_constsHLTPerformanceInfo__Modulep_std__vector_HLTPerformanceInfo__Module_s_ {
  public:
  ____gnu_cxx____normal_iterator_constsHLTPerformanceInfo__Modulep_std__vector_HLTPerformanceInfo__Module_s_();
  void* _M_current;
};
#ifdef __edm__Wrapper_std__vector_trigger__TriggerObject_s_
#undef __edm__Wrapper_std__vector_trigger__TriggerObject_s_
#endif
class __edm__Wrapper_std__vector_trigger__TriggerObject_s_ {
  public:
  __edm__Wrapper_std__vector_trigger__TriggerObject_s_();
  bool present;
  ::std::vector<trigger::TriggerObject> obj;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class HLTPerformanceInfo -------------------------------
static void destructor_5241(void*, void * o, const std::vector<void*>&, void *) {
(((::HLTPerformanceInfo*)o)->::HLTPerformanceInfo::~HLTPerformanceInfo)();
}
static  void operator_5242( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HLTPerformanceInfo*)o)->operator=)(*(const ::HLTPerformanceInfo*)arg[0]);
  else   (((::HLTPerformanceInfo*)o)->operator=)(*(const ::HLTPerformanceInfo*)arg[0]);
}

static void constructor_5243( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HLTPerformanceInfo(*(const ::HLTPerformanceInfo*)arg[0]);
  else ::new(mem) ::HLTPerformanceInfo(*(const ::HLTPerformanceInfo*)arg[0]);
}

static void constructor_5244( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HLTPerformanceInfo();
  else ::new(mem) ::HLTPerformanceInfo();
}

static  void method_5245( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HLTPerformanceInfo*)o)->addPath)(*(const ::HLTPerformanceInfo::Path*)arg[0]);
}

static  void method_5246( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HLTPerformanceInfo*)o)->addModule)(*(const ::HLTPerformanceInfo::Module*)arg[0]);
}

static  void method_5247( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HLTPerformanceInfo*)o)->addModuleToPath)((const char*)arg[0],
    (const char*)arg[1]);
}

static  void method_5248( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HLTPerformanceInfo*)o)->addModuleToPath)(*(const ::size_t*)arg[0],
    *(const ::size_t*)arg[1]);
}

static  void method_5249( void*, void* o, const std::vector<void*>&, void*)
{
  (((::HLTPerformanceInfo*)o)->clear)();
}

static  void method_5250( void*, void* o, const std::vector<void*>&, void*)
{
  (((::HLTPerformanceInfo*)o)->clearModules)();
}

static  void method_5251( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::HLTPerformanceInfo*)o)->getModuleOnPath)(*(::size_t*)arg[0],
    *(::size_t*)arg[1]);
  else   (((const ::HLTPerformanceInfo*)o)->getModuleOnPath)(*(::size_t*)arg[0],
    *(::size_t*)arg[1]);
}

static  void method_5252( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::HLTPerformanceInfo*)o)->getModule)(*(::size_t*)arg[0]);
  else   (((const ::HLTPerformanceInfo*)o)->getModule)(*(::size_t*)arg[0]);
}

static  void method_5253( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::HLTPerformanceInfo*)o)->getPath)(*(::size_t*)arg[0]);
  else   (((const ::HLTPerformanceInfo*)o)->getPath)(*(::size_t*)arg[0]);
}

static  void method_5254( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >)((((::HLTPerformanceInfo*)o)->findModule)((const char*)arg[0]));
  else   (((::HLTPerformanceInfo*)o)->findModule)((const char*)arg[0]);
}

static  void method_5255( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >)((((::HLTPerformanceInfo*)o)->findPath)((const char*)arg[0]));
  else   (((::HLTPerformanceInfo*)o)->findPath)((const char*)arg[0]);
}

static  void method_5256( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::HLTPerformanceInfo*)o)->moduleIndexInPath)((const char*)arg[0],
    (const char*)arg[1]));
  else   (((::HLTPerformanceInfo*)o)->moduleIndexInPath)((const char*)arg[0],
    (const char*)arg[1]);
}

static  void method_5257( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::HLTPerformanceInfo*)o)->numberOfPaths)());
  else   (((const ::HLTPerformanceInfo*)o)->numberOfPaths)();
}

static  void method_5258( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::HLTPerformanceInfo*)o)->numberOfModules)());
  else   (((const ::HLTPerformanceInfo*)o)->numberOfModules)();
}

static  void method_5259( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >)((((::HLTPerformanceInfo*)o)->beginPaths)());
  else   (((::HLTPerformanceInfo*)o)->beginPaths)();
}

static  void method_5260( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >)((((::HLTPerformanceInfo*)o)->endPaths)());
  else   (((::HLTPerformanceInfo*)o)->endPaths)();
}

static  void method_5261( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >)((((const ::HLTPerformanceInfo*)o)->beginModules)());
  else   (((const ::HLTPerformanceInfo*)o)->beginModules)();
}

static  void method_5262( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >)((((const ::HLTPerformanceInfo*)o)->endModules)());
  else   (((const ::HLTPerformanceInfo*)o)->endModules)();
}

static  void method_5263( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HLTPerformanceInfo*)o)->totalTime)());
  else   (((const ::HLTPerformanceInfo*)o)->totalTime)();
}

static  void method_5264( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HLTPerformanceInfo*)o)->totalCPUTime)());
  else   (((const ::HLTPerformanceInfo*)o)->totalCPUTime)();
}

static  void method_5265( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HLTPerformanceInfo*)o)->longestModuleTime)());
  else   (((const ::HLTPerformanceInfo*)o)->longestModuleTime)();
}

static  void method_5266( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HLTPerformanceInfo*)o)->longestModuleCPUTime)());
  else   (((const ::HLTPerformanceInfo*)o)->longestModuleCPUTime)();
}

static  void method_5267( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HLTPerformanceInfo*)o)->longestModuleTimeName)());
  else   (((const ::HLTPerformanceInfo*)o)->longestModuleTimeName)();
}

static  void method_5268( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::HLTPerformanceInfo*)o)->longestModuleCPUTimeName)());
  else   (((const ::HLTPerformanceInfo*)o)->longestModuleCPUTimeName)();
}

static  void method_5269( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((::HLTPerformanceInfo*)o)->totalPathTime)(*(const ::size_t*)arg[0]));
  else   (((::HLTPerformanceInfo*)o)->totalPathTime)(*(const ::size_t*)arg[0]);
}

static  void method_5270( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((::HLTPerformanceInfo*)o)->totalPathCPUTime)(*(const ::size_t*)arg[0]));
  else   (((::HLTPerformanceInfo*)o)->totalPathCPUTime)(*(const ::size_t*)arg[0]);
}

static  void method_5271( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HLTPerformanceInfo*)o)->setStatusOfModulesFromPath)((const char*)arg[0]);
}

static  void method_5272( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::HLTPerformanceInfo*)o)->uniqueModule)((const char*)arg[0]));
  else   (((const ::HLTPerformanceInfo*)o)->uniqueModule)((const char*)arg[0]);
}

static void method_newdel_1073( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HLTPerformanceInfo >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HLTPerformanceInfo >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HLTPerformanceInfo >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HLTPerformanceInfo >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HLTPerformanceInfo >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HLTPerformanceInfo -------------------------------
void __HLTPerformanceInfo_db_datamem(Reflex::Class*);
void __HLTPerformanceInfo_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HLTPerformanceInfo_datamem_bld(&__HLTPerformanceInfo_db_datamem);
Reflex::GenreflexMemberBuilder __HLTPerformanceInfo_funcmem_bld(&__HLTPerformanceInfo_db_funcmem);
void __HLTPerformanceInfo_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HLTPerformanceInfo"), typeid(::HLTPerformanceInfo), sizeof(::HLTPerformanceInfo), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddTypedef(type_2698, Reflex::Literal("HLTPerformanceInfo::PathList"))
  .AddTypedef(type_2699, Reflex::Literal("HLTPerformanceInfo::Modules"))
  .AddTypedef(type_2695, Reflex::Literal("HLTPerformanceInfo::ModulesInPath"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HLTPerformanceInfo"), destructor_5241, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3516, type_3518), Reflex::Literal("operator="), operator_5242, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3518), Reflex::Literal("HLTPerformanceInfo"), constructor_5243, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HLTPerformanceInfo"), constructor_5244, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1073, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HLTPerformanceInfo_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HLTPerformanceInfo_funcmem_bld);
}

//------Delayed data member builder for class HLTPerformanceInfo -------------------
void __HLTPerformanceInfo_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2698, Reflex::Literal("paths_"), OffsetOf(__shadow__::__HLTPerformanceInfo, paths_), ::Reflex::PRIVATE)
  .AddDataMember(type_2699, Reflex::Literal("modules_"), OffsetOf(__shadow__::__HLTPerformanceInfo, modules_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class HLTPerformanceInfo -------------------
void __HLTPerformanceInfo_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_7399), Reflex::Literal("addPath"), method_5245, 0, "p", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_8050), Reflex::Literal("addModule"), method_5246, 0, "m", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3421, type_3421), Reflex::Literal("addModuleToPath"), method_5247, 0, "mod;path", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_1813c, type_1813c), Reflex::Literal("addModuleToPath"), method_5248, 0, "mod;path", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166), Reflex::Literal("clear"), method_5249, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166), Reflex::Literal("clearModules"), method_5250, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8050, type_1813, type_1813), Reflex::Literal("getModuleOnPath"), method_5251, 0, "m;p", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8050, type_1813), Reflex::Literal("getModule"), method_5252, 0, "m", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7399, type_1813), Reflex::Literal("getPath"), method_5253, 0, "p", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5807, type_3421), Reflex::Literal("findModule"), method_5254, 0, "moduleInstanceName", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5805, type_3421), Reflex::Literal("findPath"), method_5255, 0, "pathName", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71, type_3421, type_3421), Reflex::Literal("moduleIndexInPath"), method_5256, 0, "mod;path", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1813), Reflex::Literal("numberOfPaths"), method_5257, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1813), Reflex::Literal("numberOfModules"), method_5258, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5805), Reflex::Literal("beginPaths"), method_5259, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5805), Reflex::Literal("endPaths"), method_5260, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5806), Reflex::Literal("beginModules"), method_5261, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5806), Reflex::Literal("endModules"), method_5262, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_108), Reflex::Literal("totalTime"), method_5263, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_108), Reflex::Literal("totalCPUTime"), method_5264, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_108), Reflex::Literal("longestModuleTime"), method_5265, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_108), Reflex::Literal("longestModuleCPUTime"), method_5266, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3421), Reflex::Literal("longestModuleTimeName"), method_5267, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3421), Reflex::Literal("longestModuleCPUTimeName"), method_5268, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_108, type_1813c), Reflex::Literal("totalPathTime"), method_5269, 0, "path", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_108, type_1813c), Reflex::Literal("totalPathCPUTime"), method_5270, 0, "path", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3421), Reflex::Literal("setStatusOfModulesFromPath"), method_5271, 0, "pathName", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1374, type_3421), Reflex::Literal("uniqueModule"), method_5272, 0, "mod", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class vector<trigger::TriggerObjectType,std::allocator<trigger::TriggerObjectType> > -------------------------------
static void constructor_10655( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<trigger::TriggerObjectType>();
  else ::new(mem) ::std::vector<trigger::TriggerObjectType>();
}

static void constructor_10656( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<trigger::TriggerObjectType>(*(const ::std::allocator<trigger::TriggerObjectType>*)arg[0]);
  else ::new(mem) ::std::vector<trigger::TriggerObjectType>(*(const ::std::allocator<trigger::TriggerObjectType>*)arg[0]);
}

static void constructor_10657( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<trigger::TriggerObjectType>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<trigger::TriggerObjectType>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<trigger::TriggerObjectType>(*(::std::size_t*)arg[0],
      *(const ::trigger::TriggerObjectType*)arg[1]);
  else ::new(mem) ::std::vector<trigger::TriggerObjectType>(*(::std::size_t*)arg[0],
      *(const ::trigger::TriggerObjectType*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<trigger::TriggerObjectType>(*(::std::size_t*)arg[0],
      *(const ::trigger::TriggerObjectType*)arg[1],
      *(const ::std::allocator<trigger::TriggerObjectType>*)arg[2]);
  else ::new(mem) ::std::vector<trigger::TriggerObjectType>(*(::std::size_t*)arg[0],
      *(const ::trigger::TriggerObjectType*)arg[1],
      *(const ::std::allocator<trigger::TriggerObjectType>*)arg[2]);
  }
}

static void constructor_10658( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<trigger::TriggerObjectType>(*(const ::std::vector<trigger::TriggerObjectType>*)arg[0]);
  else ::new(mem) ::std::vector<trigger::TriggerObjectType>(*(const ::std::vector<trigger::TriggerObjectType>*)arg[0]);
}

static void destructor_10659(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<trigger::TriggerObjectType>*)o)->::std::vector<trigger::TriggerObjectType>::~vector)();
}
static  void operator_10660( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<trigger::TriggerObjectType>*)o)->operator=)(*(const ::std::vector<trigger::TriggerObjectType>*)arg[0]);
  else   (((::std::vector<trigger::TriggerObjectType>*)o)->operator=)(*(const ::std::vector<trigger::TriggerObjectType>*)arg[0]);
}

static  void method_10661( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<trigger::TriggerObjectType>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::trigger::TriggerObjectType*)arg[1]);
}

static  void method_10662( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >)((((::std::vector<trigger::TriggerObjectType>*)o)->begin)());
  else   (((::std::vector<trigger::TriggerObjectType>*)o)->begin)();
}

static  void method_10663( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >)((((const ::std::vector<trigger::TriggerObjectType>*)o)->begin)());
  else   (((const ::std::vector<trigger::TriggerObjectType>*)o)->begin)();
}

static  void method_10664( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >)((((::std::vector<trigger::TriggerObjectType>*)o)->end)());
  else   (((::std::vector<trigger::TriggerObjectType>*)o)->end)();
}

static  void method_10665( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >)((((const ::std::vector<trigger::TriggerObjectType>*)o)->end)());
  else   (((const ::std::vector<trigger::TriggerObjectType>*)o)->end)();
}

static  void method_10670( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<trigger::TriggerObjectType>*)o)->size)());
  else   (((const ::std::vector<trigger::TriggerObjectType>*)o)->size)();
}

static  void method_10671( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<trigger::TriggerObjectType>*)o)->max_size)());
  else   (((const ::std::vector<trigger::TriggerObjectType>*)o)->max_size)();
}

static  void method_10672( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<trigger::TriggerObjectType>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<trigger::TriggerObjectType>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::trigger::TriggerObjectType*)arg[1]);
  }
}

static  void method_10673( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<trigger::TriggerObjectType>*)o)->capacity)());
  else   (((const ::std::vector<trigger::TriggerObjectType>*)o)->capacity)();
}

static  void method_10674( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<trigger::TriggerObjectType>*)o)->empty)());
  else   (((const ::std::vector<trigger::TriggerObjectType>*)o)->empty)();
}

static  void method_10675( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<trigger::TriggerObjectType>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_10676( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<trigger::TriggerObjectType>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<trigger::TriggerObjectType>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_10677( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<trigger::TriggerObjectType>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<trigger::TriggerObjectType>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_10679( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<trigger::TriggerObjectType>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<trigger::TriggerObjectType>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10680( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<trigger::TriggerObjectType>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<trigger::TriggerObjectType>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10681( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<trigger::TriggerObjectType>*)o)->front)();
  else   (((::std::vector<trigger::TriggerObjectType>*)o)->front)();
}

static  void method_10682( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<trigger::TriggerObjectType>*)o)->front)();
  else   (((const ::std::vector<trigger::TriggerObjectType>*)o)->front)();
}

static  void method_10683( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<trigger::TriggerObjectType>*)o)->back)();
  else   (((::std::vector<trigger::TriggerObjectType>*)o)->back)();
}

static  void method_10684( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<trigger::TriggerObjectType>*)o)->back)();
  else   (((const ::std::vector<trigger::TriggerObjectType>*)o)->back)();
}

static  void method_10685( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<trigger::TriggerObjectType>*)o)->data)());
  else   (((::std::vector<trigger::TriggerObjectType>*)o)->data)();
}

static  void method_10686( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<trigger::TriggerObjectType>*)o)->data)());
  else   (((const ::std::vector<trigger::TriggerObjectType>*)o)->data)();
}

static  void method_10687( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<trigger::TriggerObjectType>*)o)->push_back)(*(const ::trigger::TriggerObjectType*)arg[0]);
}

static  void method_10688( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<trigger::TriggerObjectType>*)o)->pop_back)();
}

static  void method_10689( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >)((((::std::vector<trigger::TriggerObjectType>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >*)arg[0],
    *(const ::trigger::TriggerObjectType*)arg[1]));
  else   (((::std::vector<trigger::TriggerObjectType>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >*)arg[0],
    *(const ::trigger::TriggerObjectType*)arg[1]);
}

static  void method_10690( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<trigger::TriggerObjectType>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::trigger::TriggerObjectType*)arg[2]);
}

static  void method_10691( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >)((((::std::vector<trigger::TriggerObjectType>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >*)arg[0]));
  else   (((::std::vector<trigger::TriggerObjectType>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >*)arg[0]);
}

static  void method_10692( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >)((((::std::vector<trigger::TriggerObjectType>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >*)arg[1]));
  else   (((::std::vector<trigger::TriggerObjectType>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >*)arg[1]);
}

static  void method_10693( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<trigger::TriggerObjectType>*)o)->swap)(*(::std::vector<trigger::TriggerObjectType>*)arg[0]);
}

static  void method_10694( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<trigger::TriggerObjectType>*)o)->clear)();
}

static void method_newdel_2697( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<trigger::TriggerObjectType> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<trigger::TriggerObjectType> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<trigger::TriggerObjectType> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<trigger::TriggerObjectType> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<trigger::TriggerObjectType> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x2( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<trigger::TriggerObjectType,std::allocator<trigger::TriggerObjectType> >")), ::Reflex::BaseOffset< ::std::vector<trigger::TriggerObjectType>,::std::_Vector_base<trigger::TriggerObjectType,std::allocator<trigger::TriggerObjectType> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x3( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<trigger::TriggerObjectType> >::Generate();
  else ::Reflex::Proxy< ::std::vector<trigger::TriggerObjectType> >::Generate();
}

//------Dictionary for class vector<trigger::TriggerObjectType,std::allocator<trigger::TriggerObjectType> > -------------------------------
void __std__vector_trigger__TriggerObjectType__db_datamem(Reflex::Class*);
void __std__vector_trigger__TriggerObjectType__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_trigger__TriggerObjectType__datamem_bld(&__std__vector_trigger__TriggerObjectType__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_trigger__TriggerObjectType__funcmem_bld(&__std__vector_trigger__TriggerObjectType__db_funcmem);
void __std__vector_trigger__TriggerObjectType__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<trigger::TriggerObjectType>"), typeid(::std::vector<trigger::TriggerObjectType>), sizeof(::std::vector<trigger::TriggerObjectType>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2130, ::Reflex::BaseOffset< ::std::vector<trigger::TriggerObjectType>, ::std::_Vector_base<trigger::TriggerObjectType,std::allocator<trigger::TriggerObjectType> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3604, Reflex::Literal("std::vector<trigger::TriggerObjectType>::_Alloc_value_type"))
  .AddTypedef(type_2130, Reflex::Literal("std::vector<trigger::TriggerObjectType>::_Base"))
  .AddTypedef(type_3018, Reflex::Literal("std::vector<trigger::TriggerObjectType>::_Tp_alloc_type"))
  .AddTypedef(type_3604, Reflex::Literal("std::vector<trigger::TriggerObjectType>::value_type"))
  .AddTypedef(type_10642, Reflex::Literal("std::vector<trigger::TriggerObjectType>::pointer"))
  .AddTypedef(type_7386, Reflex::Literal("std::vector<trigger::TriggerObjectType>::const_pointer"))
  .AddTypedef(type_10645, Reflex::Literal("std::vector<trigger::TriggerObjectType>::reference"))
  .AddTypedef(type_7388, Reflex::Literal("std::vector<trigger::TriggerObjectType>::const_reference"))
  .AddTypedef(type_5688, Reflex::Literal("std::vector<trigger::TriggerObjectType>::iterator"))
  .AddTypedef(type_5687, Reflex::Literal("std::vector<trigger::TriggerObjectType>::const_iterator"))
  .AddTypedef(type_3222, Reflex::Literal("std::vector<trigger::TriggerObjectType>::const_reverse_iterator"))
  .AddTypedef(type_3223, Reflex::Literal("std::vector<trigger::TriggerObjectType>::reverse_iterator"))
  .AddTypedef(type_3004, Reflex::Literal("std::vector<trigger::TriggerObjectType>::size_type"))
  .AddTypedef(type_2891, Reflex::Literal("std::vector<trigger::TriggerObjectType>::difference_type"))
  .AddTypedef(type_3018, Reflex::Literal("std::vector<trigger::TriggerObjectType>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_10655, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28852), Reflex::Literal("vector"), constructor_10656, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3004, type_7388, type_28852), Reflex::Literal("vector"), constructor_10657, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30235), Reflex::Literal("vector"), constructor_10658, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_10659, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2697, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x2, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x3, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_trigger__TriggerObjectType__funcmem_bld);
}

//------Delayed data member builder for class vector<trigger::TriggerObjectType,std::allocator<trigger::TriggerObjectType> > -------------------
void __std__vector_trigger__TriggerObjectType__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<trigger::TriggerObjectType,std::allocator<trigger::TriggerObjectType> > -------------------
void __std__vector_trigger__TriggerObjectType__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30236, type_30235), Reflex::Literal("operator="), operator_10660, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3004, type_7388), Reflex::Literal("assign"), method_10661, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5688), Reflex::Literal("begin"), method_10662, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5687), Reflex::Literal("begin"), method_10663, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5688), Reflex::Literal("end"), method_10664, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5687), Reflex::Literal("end"), method_10665, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3004), Reflex::Literal("size"), method_10670, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3004), Reflex::Literal("max_size"), method_10671, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3004, type_3604), Reflex::Literal("resize"), method_10672, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3004), Reflex::Literal("capacity"), method_10673, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1374), Reflex::Literal("empty"), method_10674, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3004), Reflex::Literal("reserve"), method_10675, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10645, type_3004), Reflex::Literal("operator[]"), operator_10676, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7388, type_3004), Reflex::Literal("operator[]"), operator_10677, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10645, type_3004), Reflex::Literal("at"), method_10679, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7388, type_3004), Reflex::Literal("at"), method_10680, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10645), Reflex::Literal("front"), method_10681, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7388), Reflex::Literal("front"), method_10682, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10645), Reflex::Literal("back"), method_10683, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7388), Reflex::Literal("back"), method_10684, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10642), Reflex::Literal("data"), method_10685, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7386), Reflex::Literal("data"), method_10686, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_7388), Reflex::Literal("push_back"), method_10687, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166), Reflex::Literal("pop_back"), method_10688, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5688, type_5688, type_7388), Reflex::Literal("insert"), method_10689, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_5688, type_3004, type_7388), Reflex::Literal("insert"), method_10690, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5688, type_5688), Reflex::Literal("erase"), method_10691, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5688, type_5688, type_5688), Reflex::Literal("erase"), method_10692, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_30236), Reflex::Literal("swap"), method_10693, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166), Reflex::Literal("clear"), method_10694, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class Path -------------------------------
static void destructor_23850(void*, void * o, const std::vector<void*>&, void *) {
(((::HLTPerformanceInfo::Path*)o)->::HLTPerformanceInfo::Path::~Path)();
}
static  void operator_23851( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HLTPerformanceInfo::Path*)o)->operator=)(*(const ::HLTPerformanceInfo::Path*)arg[0]);
  else   (((::HLTPerformanceInfo::Path*)o)->operator=)(*(const ::HLTPerformanceInfo::Path*)arg[0]);
}

static void constructor_23852( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HLTPerformanceInfo::Path(*(const ::HLTPerformanceInfo::Path*)arg[0]);
  else ::new(mem) ::HLTPerformanceInfo::Path(*(const ::HLTPerformanceInfo::Path*)arg[0]);
}

static void constructor_23853( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::HLTPerformanceInfo::Path();
  else ::new(mem) ::HLTPerformanceInfo::Path();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HLTPerformanceInfo::Path(*(const ::std::string*)arg[0]);
  else ::new(mem) ::HLTPerformanceInfo::Path(*(const ::std::string*)arg[0]);
  }
}

static  void method_23854( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::HLTPerformanceInfo::Path*)o)->name)());
  else   (((const ::HLTPerformanceInfo::Path*)o)->name)();
}

static  void method_23855( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HLTPerformanceInfo::Path*)o)->setStatus)(*(const ::edm::HLTPathStatus*)arg[0]);
}

static  void method_23856( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::HLTPathStatus)((((const ::HLTPerformanceInfo::Path*)o)->status)());
  else   (((const ::HLTPerformanceInfo::Path*)o)->status)();
}

static  void method_23857( void*, void* o, const std::vector<void*>&, void*)
{
  (((::HLTPerformanceInfo::Path*)o)->clear)();
}

static  void operator_23858( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HLTPerformanceInfo::Path*)o)->operator==)((const char*)arg[0]));
  else   (((::HLTPerformanceInfo::Path*)o)->operator==)((const char*)arg[0]);
}

static  void operator_23859( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::HLTPerformanceInfo::Path*)o)->operator[])(*(::size_t*)arg[0]));
  else   (((const ::HLTPerformanceInfo::Path*)o)->operator[])(*(::size_t*)arg[0]);
}

static  void method_23860( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HLTPerformanceInfo::Path*)o)->addModuleRef)(*(::size_t*)arg[0]);
}

static  void method_23861( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const unsigned long*,std::vector<unsigned long> >)((((::HLTPerformanceInfo::Path*)o)->begin)());
  else   (((::HLTPerformanceInfo::Path*)o)->begin)();
}

static  void method_23862( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const unsigned long*,std::vector<unsigned long> >)((((::HLTPerformanceInfo::Path*)o)->end)());
  else   (((::HLTPerformanceInfo::Path*)o)->end)();
}

static  void method_23863( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::HLTPerformanceInfo::Path*)o)->getModuleIndex)(*(::size_t*)arg[0]));
  else   (((const ::HLTPerformanceInfo::Path*)o)->getModuleIndex)(*(::size_t*)arg[0]);
}

static  void method_23864( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (size_t)((((const ::HLTPerformanceInfo::Path*)o)->numberOfModules)());
  else   (((const ::HLTPerformanceInfo::Path*)o)->numberOfModules)();
}

static void constructor_x4( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HLTPerformanceInfo::Path();
  else ::new(mem) ::HLTPerformanceInfo::Path();
}

static void method_newdel_5236( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HLTPerformanceInfo::Path >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HLTPerformanceInfo::Path >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HLTPerformanceInfo::Path >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HLTPerformanceInfo::Path >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HLTPerformanceInfo::Path >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Path -------------------------------
void __HLTPerformanceInfo__Path_db_datamem(Reflex::Class*);
void __HLTPerformanceInfo__Path_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HLTPerformanceInfo__Path_datamem_bld(&__HLTPerformanceInfo__Path_db_datamem);
Reflex::GenreflexMemberBuilder __HLTPerformanceInfo__Path_funcmem_bld(&__HLTPerformanceInfo__Path_db_funcmem);
void __HLTPerformanceInfo__Path_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HLTPerformanceInfo::Path"), typeid(::HLTPerformanceInfo::Path), sizeof(::HLTPerformanceInfo::Path), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Path"), destructor_23850, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8039, type_7399), Reflex::Literal("operator="), operator_23851, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7399), Reflex::Literal("Path"), constructor_23852, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2202c), Reflex::Literal("Path"), constructor_23853, 0, "n=\"unknown\"", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Path"), constructor_x4, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5236, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HLTPerformanceInfo__Path_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HLTPerformanceInfo__Path_funcmem_bld);
}

//------Delayed data member builder for class Path -------------------
void __HLTPerformanceInfo__Path_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2202, Reflex::Literal("name_"), OffsetOf(__shadow__::__HLTPerformanceInfo__Path, name_), ::Reflex::PRIVATE)
  .AddDataMember(type_2695, Reflex::Literal("moduleView_"), OffsetOf(__shadow__::__HLTPerformanceInfo__Path, moduleView_), ::Reflex::PRIVATE)
  .AddDataMember(type_4494, Reflex::Literal("status_"), OffsetOf(__shadow__::__HLTPerformanceInfo__Path, status_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Path -------------------
void __HLTPerformanceInfo__Path_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2202), Reflex::Literal("name"), method_23854, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_35434), Reflex::Literal("setStatus"), method_23855, 0, "result", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4494), Reflex::Literal("status"), method_23856, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166), Reflex::Literal("clear"), method_23857, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1374, type_3421), Reflex::Literal("operator=="), operator_23858, 0, "tname", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1813c, type_1813), Reflex::Literal("operator[]"), operator_23859, 0, "m", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_1813), Reflex::Literal("addModuleRef"), method_23860, 0, "m", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5773), Reflex::Literal("begin"), method_23861, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5773), Reflex::Literal("end"), method_23862, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1813, type_1813), Reflex::Literal("getModuleIndex"), method_23863, 0, "j", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1813), Reflex::Literal("numberOfModules"), method_23864, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class vector<HLTPerformanceInfo::Path,std::allocator<HLTPerformanceInfo::Path> > -------------------------------
static void constructor_10716( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HLTPerformanceInfo::Path>();
  else ::new(mem) ::std::vector<HLTPerformanceInfo::Path>();
}

static void constructor_10717( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HLTPerformanceInfo::Path>(*(const ::std::allocator<HLTPerformanceInfo::Path>*)arg[0]);
  else ::new(mem) ::std::vector<HLTPerformanceInfo::Path>(*(const ::std::allocator<HLTPerformanceInfo::Path>*)arg[0]);
}

static void constructor_10718( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HLTPerformanceInfo::Path>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<HLTPerformanceInfo::Path>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HLTPerformanceInfo::Path>(*(::std::size_t*)arg[0],
      *(const ::HLTPerformanceInfo::Path*)arg[1]);
  else ::new(mem) ::std::vector<HLTPerformanceInfo::Path>(*(::std::size_t*)arg[0],
      *(const ::HLTPerformanceInfo::Path*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HLTPerformanceInfo::Path>(*(::std::size_t*)arg[0],
      *(const ::HLTPerformanceInfo::Path*)arg[1],
      *(const ::std::allocator<HLTPerformanceInfo::Path>*)arg[2]);
  else ::new(mem) ::std::vector<HLTPerformanceInfo::Path>(*(::std::size_t*)arg[0],
      *(const ::HLTPerformanceInfo::Path*)arg[1],
      *(const ::std::allocator<HLTPerformanceInfo::Path>*)arg[2]);
  }
}

static void constructor_10719( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HLTPerformanceInfo::Path>(*(const ::std::vector<HLTPerformanceInfo::Path>*)arg[0]);
  else ::new(mem) ::std::vector<HLTPerformanceInfo::Path>(*(const ::std::vector<HLTPerformanceInfo::Path>*)arg[0]);
}

static void destructor_10720(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<HLTPerformanceInfo::Path>*)o)->::std::vector<HLTPerformanceInfo::Path>::~vector)();
}
static  void operator_10721( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HLTPerformanceInfo::Path>*)o)->operator=)(*(const ::std::vector<HLTPerformanceInfo::Path>*)arg[0]);
  else   (((::std::vector<HLTPerformanceInfo::Path>*)o)->operator=)(*(const ::std::vector<HLTPerformanceInfo::Path>*)arg[0]);
}

static  void method_10722( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HLTPerformanceInfo::Path>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::HLTPerformanceInfo::Path*)arg[1]);
}

static  void method_10723( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >)((((::std::vector<HLTPerformanceInfo::Path>*)o)->begin)());
  else   (((::std::vector<HLTPerformanceInfo::Path>*)o)->begin)();
}

static  void method_10724( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >)((((const ::std::vector<HLTPerformanceInfo::Path>*)o)->begin)());
  else   (((const ::std::vector<HLTPerformanceInfo::Path>*)o)->begin)();
}

static  void method_10725( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >)((((::std::vector<HLTPerformanceInfo::Path>*)o)->end)());
  else   (((::std::vector<HLTPerformanceInfo::Path>*)o)->end)();
}

static  void method_10726( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >)((((const ::std::vector<HLTPerformanceInfo::Path>*)o)->end)());
  else   (((const ::std::vector<HLTPerformanceInfo::Path>*)o)->end)();
}

static  void method_10731( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HLTPerformanceInfo::Path>*)o)->size)());
  else   (((const ::std::vector<HLTPerformanceInfo::Path>*)o)->size)();
}

static  void method_10732( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HLTPerformanceInfo::Path>*)o)->max_size)());
  else   (((const ::std::vector<HLTPerformanceInfo::Path>*)o)->max_size)();
}

static  void method_10733( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<HLTPerformanceInfo::Path>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<HLTPerformanceInfo::Path>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::HLTPerformanceInfo::Path*)arg[1]);
  }
}

static  void method_10734( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HLTPerformanceInfo::Path>*)o)->capacity)());
  else   (((const ::std::vector<HLTPerformanceInfo::Path>*)o)->capacity)();
}

static  void method_10735( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<HLTPerformanceInfo::Path>*)o)->empty)());
  else   (((const ::std::vector<HLTPerformanceInfo::Path>*)o)->empty)();
}

static  void method_10736( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HLTPerformanceInfo::Path>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_10737( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HLTPerformanceInfo::Path>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HLTPerformanceInfo::Path>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_10738( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HLTPerformanceInfo::Path>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HLTPerformanceInfo::Path>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_10740( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HLTPerformanceInfo::Path>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HLTPerformanceInfo::Path>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10741( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HLTPerformanceInfo::Path>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HLTPerformanceInfo::Path>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10742( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HLTPerformanceInfo::Path>*)o)->front)();
  else   (((::std::vector<HLTPerformanceInfo::Path>*)o)->front)();
}

static  void method_10743( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HLTPerformanceInfo::Path>*)o)->front)();
  else   (((const ::std::vector<HLTPerformanceInfo::Path>*)o)->front)();
}

static  void method_10744( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HLTPerformanceInfo::Path>*)o)->back)();
  else   (((::std::vector<HLTPerformanceInfo::Path>*)o)->back)();
}

static  void method_10745( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HLTPerformanceInfo::Path>*)o)->back)();
  else   (((const ::std::vector<HLTPerformanceInfo::Path>*)o)->back)();
}

static  void method_10746( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<HLTPerformanceInfo::Path>*)o)->data)());
  else   (((::std::vector<HLTPerformanceInfo::Path>*)o)->data)();
}

static  void method_10747( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<HLTPerformanceInfo::Path>*)o)->data)());
  else   (((const ::std::vector<HLTPerformanceInfo::Path>*)o)->data)();
}

static  void method_10748( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HLTPerformanceInfo::Path>*)o)->push_back)(*(const ::HLTPerformanceInfo::Path*)arg[0]);
}

static  void method_10749( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HLTPerformanceInfo::Path>*)o)->pop_back)();
}

static  void method_10750( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >)((((::std::vector<HLTPerformanceInfo::Path>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >*)arg[0],
    *(const ::HLTPerformanceInfo::Path*)arg[1]));
  else   (((::std::vector<HLTPerformanceInfo::Path>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >*)arg[0],
    *(const ::HLTPerformanceInfo::Path*)arg[1]);
}

static  void method_10751( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HLTPerformanceInfo::Path>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::HLTPerformanceInfo::Path*)arg[2]);
}

static  void method_10752( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >)((((::std::vector<HLTPerformanceInfo::Path>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >*)arg[0]));
  else   (((::std::vector<HLTPerformanceInfo::Path>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >*)arg[0]);
}

static  void method_10753( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >)((((::std::vector<HLTPerformanceInfo::Path>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >*)arg[1]));
  else   (((::std::vector<HLTPerformanceInfo::Path>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >*)arg[1]);
}

static  void method_10754( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HLTPerformanceInfo::Path>*)o)->swap)(*(::std::vector<HLTPerformanceInfo::Path>*)arg[0]);
}

static  void method_10755( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HLTPerformanceInfo::Path>*)o)->clear)();
}

static void method_newdel_2698( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<HLTPerformanceInfo::Path> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<HLTPerformanceInfo::Path> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<HLTPerformanceInfo::Path> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<HLTPerformanceInfo::Path> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<HLTPerformanceInfo::Path> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x7( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HLTPerformanceInfo::Path,std::allocator<HLTPerformanceInfo::Path> >")), ::Reflex::BaseOffset< ::std::vector<HLTPerformanceInfo::Path>,::std::_Vector_base<HLTPerformanceInfo::Path,std::allocator<HLTPerformanceInfo::Path> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x8( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<HLTPerformanceInfo::Path> >::Generate();
  else ::Reflex::Proxy< ::std::vector<HLTPerformanceInfo::Path> >::Generate();
}

//------Dictionary for class vector<HLTPerformanceInfo::Path,std::allocator<HLTPerformanceInfo::Path> > -------------------------------
void __std__vector_HLTPerformanceInfo__Path__db_datamem(Reflex::Class*);
void __std__vector_HLTPerformanceInfo__Path__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_HLTPerformanceInfo__Path__datamem_bld(&__std__vector_HLTPerformanceInfo__Path__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_HLTPerformanceInfo__Path__funcmem_bld(&__std__vector_HLTPerformanceInfo__Path__db_funcmem);
void __std__vector_HLTPerformanceInfo__Path__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<HLTPerformanceInfo::Path>"), typeid(::std::vector<HLTPerformanceInfo::Path>), sizeof(::std::vector<HLTPerformanceInfo::Path>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2191, ::Reflex::BaseOffset< ::std::vector<HLTPerformanceInfo::Path>, ::std::_Vector_base<HLTPerformanceInfo::Path,std::allocator<HLTPerformanceInfo::Path> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_5236, Reflex::Literal("std::vector<HLTPerformanceInfo::Path>::_Alloc_value_type"))
  .AddTypedef(type_2191, Reflex::Literal("std::vector<HLTPerformanceInfo::Path>::_Base"))
  .AddTypedef(type_3019, Reflex::Literal("std::vector<HLTPerformanceInfo::Path>::_Tp_alloc_type"))
  .AddTypedef(type_5236, Reflex::Literal("std::vector<HLTPerformanceInfo::Path>::value_type"))
  .AddTypedef(type_8037, Reflex::Literal("std::vector<HLTPerformanceInfo::Path>::pointer"))
  .AddTypedef(type_7397, Reflex::Literal("std::vector<HLTPerformanceInfo::Path>::const_pointer"))
  .AddTypedef(type_8039, Reflex::Literal("std::vector<HLTPerformanceInfo::Path>::reference"))
  .AddTypedef(type_7399, Reflex::Literal("std::vector<HLTPerformanceInfo::Path>::const_reference"))
  .AddTypedef(type_5805, Reflex::Literal("std::vector<HLTPerformanceInfo::Path>::iterator"))
  .AddTypedef(type_5689, Reflex::Literal("std::vector<HLTPerformanceInfo::Path>::const_iterator"))
  .AddTypedef(type_3358, Reflex::Literal("std::vector<HLTPerformanceInfo::Path>::const_reverse_iterator"))
  .AddTypedef(type_3359, Reflex::Literal("std::vector<HLTPerformanceInfo::Path>::reverse_iterator"))
  .AddTypedef(type_3004, Reflex::Literal("std::vector<HLTPerformanceInfo::Path>::size_type"))
  .AddTypedef(type_2891, Reflex::Literal("std::vector<HLTPerformanceInfo::Path>::difference_type"))
  .AddTypedef(type_3019, Reflex::Literal("std::vector<HLTPerformanceInfo::Path>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_10716, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29583), Reflex::Literal("vector"), constructor_10717, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3004, type_7399, type_29583), Reflex::Literal("vector"), constructor_10718, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30237), Reflex::Literal("vector"), constructor_10719, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_10720, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2698, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x7, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x8, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_HLTPerformanceInfo__Path__funcmem_bld);
}

//------Delayed data member builder for class vector<HLTPerformanceInfo::Path,std::allocator<HLTPerformanceInfo::Path> > -------------------
void __std__vector_HLTPerformanceInfo__Path__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<HLTPerformanceInfo::Path,std::allocator<HLTPerformanceInfo::Path> > -------------------
void __std__vector_HLTPerformanceInfo__Path__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30238, type_30237), Reflex::Literal("operator="), operator_10721, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3004, type_7399), Reflex::Literal("assign"), method_10722, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5805), Reflex::Literal("begin"), method_10723, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5689), Reflex::Literal("begin"), method_10724, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5805), Reflex::Literal("end"), method_10725, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5689), Reflex::Literal("end"), method_10726, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3004), Reflex::Literal("size"), method_10731, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3004), Reflex::Literal("max_size"), method_10732, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3004, type_5236), Reflex::Literal("resize"), method_10733, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3004), Reflex::Literal("capacity"), method_10734, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1374), Reflex::Literal("empty"), method_10735, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3004), Reflex::Literal("reserve"), method_10736, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8039, type_3004), Reflex::Literal("operator[]"), operator_10737, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7399, type_3004), Reflex::Literal("operator[]"), operator_10738, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8039, type_3004), Reflex::Literal("at"), method_10740, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7399, type_3004), Reflex::Literal("at"), method_10741, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8039), Reflex::Literal("front"), method_10742, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7399), Reflex::Literal("front"), method_10743, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8039), Reflex::Literal("back"), method_10744, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7399), Reflex::Literal("back"), method_10745, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8037), Reflex::Literal("data"), method_10746, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7397), Reflex::Literal("data"), method_10747, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_7399), Reflex::Literal("push_back"), method_10748, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166), Reflex::Literal("pop_back"), method_10749, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5805, type_5805, type_7399), Reflex::Literal("insert"), method_10750, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_5805, type_3004, type_7399), Reflex::Literal("insert"), method_10751, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5805, type_5805), Reflex::Literal("erase"), method_10752, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5805, type_5805, type_5805), Reflex::Literal("erase"), method_10753, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_30238), Reflex::Literal("swap"), method_10754, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166), Reflex::Literal("clear"), method_10755, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class Module -------------------------------
static void destructor_23869(void*, void * o, const std::vector<void*>&, void *) {
(((::HLTPerformanceInfo::Module*)o)->::HLTPerformanceInfo::Module::~Module)();
}
static  void operator_23870( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::HLTPerformanceInfo::Module*)o)->operator=)(*(const ::HLTPerformanceInfo::Module*)arg[0]);
  else   (((::HLTPerformanceInfo::Module*)o)->operator=)(*(const ::HLTPerformanceInfo::Module*)arg[0]);
}

static void constructor_23871( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HLTPerformanceInfo::Module(*(const ::HLTPerformanceInfo::Module*)arg[0]);
  else ::new(mem) ::HLTPerformanceInfo::Module(*(const ::HLTPerformanceInfo::Module*)arg[0]);
}

static void constructor_23872( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::HLTPerformanceInfo::Module();
  else ::new(mem) ::HLTPerformanceInfo::Module();
}

static void constructor_23873( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 3 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::HLTPerformanceInfo::Module((const char*)arg[0],
      *(const double*)arg[1],
      *(const double*)arg[2]);
  else ::new(mem) ::HLTPerformanceInfo::Module((const char*)arg[0],
      *(const double*)arg[1],
      *(const double*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::HLTPerformanceInfo::Module((const char*)arg[0],
      *(const double*)arg[1],
      *(const double*)arg[2],
      *(::edm::HLTPathStatus*)arg[3]);
  else ::new(mem) ::HLTPerformanceInfo::Module((const char*)arg[0],
      *(const double*)arg[1],
      *(const double*)arg[2],
      *(::edm::HLTPathStatus*)arg[3]);
  }
}

static  void method_23874( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::HLTPerformanceInfo::Module*)o)->name)());
  else   (((const ::HLTPerformanceInfo::Module*)o)->name)();
}

static  void method_23875( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HLTPerformanceInfo::Module*)o)->time)());
  else   (((const ::HLTPerformanceInfo::Module*)o)->time)();
}

static  void method_23876( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::HLTPerformanceInfo::Module*)o)->cputime)());
  else   (((const ::HLTPerformanceInfo::Module*)o)->cputime)();
}

static  void method_23877( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (edm::HLTPathStatus)((((const ::HLTPerformanceInfo::Module*)o)->status)());
  else   (((const ::HLTPerformanceInfo::Module*)o)->status)();
}

static  void operator_23878( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((::HLTPerformanceInfo::Module*)o)->operator==)((const char*)arg[0]));
  else   (((::HLTPerformanceInfo::Module*)o)->operator==)((const char*)arg[0]);
}

static  void method_23879( void*, void* o, const std::vector<void*>&, void*)
{
  (((::HLTPerformanceInfo::Module*)o)->clear)();
}

static  void method_23880( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HLTPerformanceInfo::Module*)o)->setTime)(*(double*)arg[0]);
}

static  void method_23881( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HLTPerformanceInfo::Module*)o)->setCPUTime)(*(double*)arg[0]);
}

static  void method_23882( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::HLTPerformanceInfo::Module*)o)->setStatus)(*(::edm::HLTPathStatus*)arg[0]);
}

static void method_newdel_5237( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::HLTPerformanceInfo::Module >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::HLTPerformanceInfo::Module >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::HLTPerformanceInfo::Module >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::HLTPerformanceInfo::Module >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::HLTPerformanceInfo::Module >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Module -------------------------------
void __HLTPerformanceInfo__Module_db_datamem(Reflex::Class*);
void __HLTPerformanceInfo__Module_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __HLTPerformanceInfo__Module_datamem_bld(&__HLTPerformanceInfo__Module_db_datamem);
Reflex::GenreflexMemberBuilder __HLTPerformanceInfo__Module_funcmem_bld(&__HLTPerformanceInfo__Module_db_funcmem);
void __HLTPerformanceInfo__Module_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("HLTPerformanceInfo::Module"), typeid(::HLTPerformanceInfo::Module), sizeof(::HLTPerformanceInfo::Module), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Module"), destructor_23869, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8061, type_8050), Reflex::Literal("operator="), operator_23870, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_8050), Reflex::Literal("Module"), constructor_23871, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Module"), constructor_23872, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3421, type_108c, type_108c, type_4494), Reflex::Literal("Module"), constructor_23873, 0, "n;dt;dtCPU;stat=Ready", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5237, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__HLTPerformanceInfo__Module_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__HLTPerformanceInfo__Module_funcmem_bld);
}

//------Delayed data member builder for class Module -------------------
void __HLTPerformanceInfo__Module_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2202, Reflex::Literal("name_"), OffsetOf(__shadow__::__HLTPerformanceInfo__Module, name_), ::Reflex::PRIVATE)
  .AddDataMember(type_108, Reflex::Literal("dt_"), OffsetOf(__shadow__::__HLTPerformanceInfo__Module, dt_), ::Reflex::PRIVATE)
  .AddDataMember(type_108, Reflex::Literal("dtCPU_"), OffsetOf(__shadow__::__HLTPerformanceInfo__Module, dtCPU_), ::Reflex::PRIVATE)
  .AddDataMember(type_4494, Reflex::Literal("status_"), OffsetOf(__shadow__::__HLTPerformanceInfo__Module, status_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Module -------------------
void __HLTPerformanceInfo__Module_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2202), Reflex::Literal("name"), method_23874, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_108), Reflex::Literal("time"), method_23875, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_108), Reflex::Literal("cputime"), method_23876, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4494), Reflex::Literal("status"), method_23877, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1374, type_3421), Reflex::Literal("operator=="), operator_23878, 0, "tname", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166), Reflex::Literal("clear"), method_23879, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_108), Reflex::Literal("setTime"), method_23880, 0, "t", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_108), Reflex::Literal("setCPUTime"), method_23881, 0, "t", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_4494), Reflex::Literal("setStatus"), method_23882, 0, "status", ::Reflex::PUBLIC);
}
//------Stub functions for class vector<HLTPerformanceInfo::Module,std::allocator<HLTPerformanceInfo::Module> > -------------------------------
static void constructor_10777( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HLTPerformanceInfo::Module>();
  else ::new(mem) ::std::vector<HLTPerformanceInfo::Module>();
}

static void constructor_10778( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HLTPerformanceInfo::Module>(*(const ::std::allocator<HLTPerformanceInfo::Module>*)arg[0]);
  else ::new(mem) ::std::vector<HLTPerformanceInfo::Module>(*(const ::std::allocator<HLTPerformanceInfo::Module>*)arg[0]);
}

static void constructor_10779( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HLTPerformanceInfo::Module>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<HLTPerformanceInfo::Module>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HLTPerformanceInfo::Module>(*(::std::size_t*)arg[0],
      *(const ::HLTPerformanceInfo::Module*)arg[1]);
  else ::new(mem) ::std::vector<HLTPerformanceInfo::Module>(*(::std::size_t*)arg[0],
      *(const ::HLTPerformanceInfo::Module*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HLTPerformanceInfo::Module>(*(::std::size_t*)arg[0],
      *(const ::HLTPerformanceInfo::Module*)arg[1],
      *(const ::std::allocator<HLTPerformanceInfo::Module>*)arg[2]);
  else ::new(mem) ::std::vector<HLTPerformanceInfo::Module>(*(::std::size_t*)arg[0],
      *(const ::HLTPerformanceInfo::Module*)arg[1],
      *(const ::std::allocator<HLTPerformanceInfo::Module>*)arg[2]);
  }
}

static void constructor_10780( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<HLTPerformanceInfo::Module>(*(const ::std::vector<HLTPerformanceInfo::Module>*)arg[0]);
  else ::new(mem) ::std::vector<HLTPerformanceInfo::Module>(*(const ::std::vector<HLTPerformanceInfo::Module>*)arg[0]);
}

static void destructor_10781(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<HLTPerformanceInfo::Module>*)o)->::std::vector<HLTPerformanceInfo::Module>::~vector)();
}
static  void operator_10782( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HLTPerformanceInfo::Module>*)o)->operator=)(*(const ::std::vector<HLTPerformanceInfo::Module>*)arg[0]);
  else   (((::std::vector<HLTPerformanceInfo::Module>*)o)->operator=)(*(const ::std::vector<HLTPerformanceInfo::Module>*)arg[0]);
}

static  void method_10783( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HLTPerformanceInfo::Module>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::HLTPerformanceInfo::Module*)arg[1]);
}

static  void method_10784( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >)((((::std::vector<HLTPerformanceInfo::Module>*)o)->begin)());
  else   (((::std::vector<HLTPerformanceInfo::Module>*)o)->begin)();
}

static  void method_10785( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >)((((const ::std::vector<HLTPerformanceInfo::Module>*)o)->begin)());
  else   (((const ::std::vector<HLTPerformanceInfo::Module>*)o)->begin)();
}

static  void method_10786( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >)((((::std::vector<HLTPerformanceInfo::Module>*)o)->end)());
  else   (((::std::vector<HLTPerformanceInfo::Module>*)o)->end)();
}

static  void method_10787( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >)((((const ::std::vector<HLTPerformanceInfo::Module>*)o)->end)());
  else   (((const ::std::vector<HLTPerformanceInfo::Module>*)o)->end)();
}

static  void method_10792( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HLTPerformanceInfo::Module>*)o)->size)());
  else   (((const ::std::vector<HLTPerformanceInfo::Module>*)o)->size)();
}

static  void method_10793( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HLTPerformanceInfo::Module>*)o)->max_size)());
  else   (((const ::std::vector<HLTPerformanceInfo::Module>*)o)->max_size)();
}

static  void method_10794( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<HLTPerformanceInfo::Module>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<HLTPerformanceInfo::Module>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::HLTPerformanceInfo::Module*)arg[1]);
  }
}

static  void method_10795( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<HLTPerformanceInfo::Module>*)o)->capacity)());
  else   (((const ::std::vector<HLTPerformanceInfo::Module>*)o)->capacity)();
}

static  void method_10796( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<HLTPerformanceInfo::Module>*)o)->empty)());
  else   (((const ::std::vector<HLTPerformanceInfo::Module>*)o)->empty)();
}

static  void method_10797( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HLTPerformanceInfo::Module>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_10798( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HLTPerformanceInfo::Module>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HLTPerformanceInfo::Module>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_10799( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HLTPerformanceInfo::Module>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HLTPerformanceInfo::Module>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_10801( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HLTPerformanceInfo::Module>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<HLTPerformanceInfo::Module>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10802( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HLTPerformanceInfo::Module>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<HLTPerformanceInfo::Module>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10803( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HLTPerformanceInfo::Module>*)o)->front)();
  else   (((::std::vector<HLTPerformanceInfo::Module>*)o)->front)();
}

static  void method_10804( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HLTPerformanceInfo::Module>*)o)->front)();
  else   (((const ::std::vector<HLTPerformanceInfo::Module>*)o)->front)();
}

static  void method_10805( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<HLTPerformanceInfo::Module>*)o)->back)();
  else   (((::std::vector<HLTPerformanceInfo::Module>*)o)->back)();
}

static  void method_10806( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<HLTPerformanceInfo::Module>*)o)->back)();
  else   (((const ::std::vector<HLTPerformanceInfo::Module>*)o)->back)();
}

static  void method_10807( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<HLTPerformanceInfo::Module>*)o)->data)());
  else   (((::std::vector<HLTPerformanceInfo::Module>*)o)->data)();
}

static  void method_10808( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<HLTPerformanceInfo::Module>*)o)->data)());
  else   (((const ::std::vector<HLTPerformanceInfo::Module>*)o)->data)();
}

static  void method_10809( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HLTPerformanceInfo::Module>*)o)->push_back)(*(const ::HLTPerformanceInfo::Module*)arg[0]);
}

static  void method_10810( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HLTPerformanceInfo::Module>*)o)->pop_back)();
}

static  void method_10811( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >)((((::std::vector<HLTPerformanceInfo::Module>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >*)arg[0],
    *(const ::HLTPerformanceInfo::Module*)arg[1]));
  else   (((::std::vector<HLTPerformanceInfo::Module>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >*)arg[0],
    *(const ::HLTPerformanceInfo::Module*)arg[1]);
}

static  void method_10812( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HLTPerformanceInfo::Module>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::HLTPerformanceInfo::Module*)arg[2]);
}

static  void method_10813( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >)((((::std::vector<HLTPerformanceInfo::Module>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >*)arg[0]));
  else   (((::std::vector<HLTPerformanceInfo::Module>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >*)arg[0]);
}

static  void method_10814( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >)((((::std::vector<HLTPerformanceInfo::Module>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >*)arg[1]));
  else   (((::std::vector<HLTPerformanceInfo::Module>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >*)arg[1]);
}

static  void method_10815( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<HLTPerformanceInfo::Module>*)o)->swap)(*(::std::vector<HLTPerformanceInfo::Module>*)arg[0]);
}

static  void method_10816( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<HLTPerformanceInfo::Module>*)o)->clear)();
}

static void method_newdel_2699( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<HLTPerformanceInfo::Module> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<HLTPerformanceInfo::Module> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<HLTPerformanceInfo::Module> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<HLTPerformanceInfo::Module> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<HLTPerformanceInfo::Module> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x11( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<HLTPerformanceInfo::Module,std::allocator<HLTPerformanceInfo::Module> >")), ::Reflex::BaseOffset< ::std::vector<HLTPerformanceInfo::Module>,::std::_Vector_base<HLTPerformanceInfo::Module,std::allocator<HLTPerformanceInfo::Module> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x12( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<HLTPerformanceInfo::Module> >::Generate();
  else ::Reflex::Proxy< ::std::vector<HLTPerformanceInfo::Module> >::Generate();
}

//------Dictionary for class vector<HLTPerformanceInfo::Module,std::allocator<HLTPerformanceInfo::Module> > -------------------------------
void __std__vector_HLTPerformanceInfo__Module__db_datamem(Reflex::Class*);
void __std__vector_HLTPerformanceInfo__Module__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_HLTPerformanceInfo__Module__datamem_bld(&__std__vector_HLTPerformanceInfo__Module__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_HLTPerformanceInfo__Module__funcmem_bld(&__std__vector_HLTPerformanceInfo__Module__db_funcmem);
void __std__vector_HLTPerformanceInfo__Module__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<HLTPerformanceInfo::Module>"), typeid(::std::vector<HLTPerformanceInfo::Module>), sizeof(::std::vector<HLTPerformanceInfo::Module>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2190, ::Reflex::BaseOffset< ::std::vector<HLTPerformanceInfo::Module>, ::std::_Vector_base<HLTPerformanceInfo::Module,std::allocator<HLTPerformanceInfo::Module> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_5237, Reflex::Literal("std::vector<HLTPerformanceInfo::Module>::_Alloc_value_type"))
  .AddTypedef(type_2190, Reflex::Literal("std::vector<HLTPerformanceInfo::Module>::_Base"))
  .AddTypedef(type_3020, Reflex::Literal("std::vector<HLTPerformanceInfo::Module>::_Tp_alloc_type"))
  .AddTypedef(type_5237, Reflex::Literal("std::vector<HLTPerformanceInfo::Module>::value_type"))
  .AddTypedef(type_8059, Reflex::Literal("std::vector<HLTPerformanceInfo::Module>::pointer"))
  .AddTypedef(type_8048, Reflex::Literal("std::vector<HLTPerformanceInfo::Module>::const_pointer"))
  .AddTypedef(type_8061, Reflex::Literal("std::vector<HLTPerformanceInfo::Module>::reference"))
  .AddTypedef(type_8050, Reflex::Literal("std::vector<HLTPerformanceInfo::Module>::const_reference"))
  .AddTypedef(type_5807, Reflex::Literal("std::vector<HLTPerformanceInfo::Module>::iterator"))
  .AddTypedef(type_5806, Reflex::Literal("std::vector<HLTPerformanceInfo::Module>::const_iterator"))
  .AddTypedef(type_3356, Reflex::Literal("std::vector<HLTPerformanceInfo::Module>::const_reverse_iterator"))
  .AddTypedef(type_3357, Reflex::Literal("std::vector<HLTPerformanceInfo::Module>::reverse_iterator"))
  .AddTypedef(type_3004, Reflex::Literal("std::vector<HLTPerformanceInfo::Module>::size_type"))
  .AddTypedef(type_2891, Reflex::Literal("std::vector<HLTPerformanceInfo::Module>::difference_type"))
  .AddTypedef(type_3020, Reflex::Literal("std::vector<HLTPerformanceInfo::Module>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_10777, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29571), Reflex::Literal("vector"), constructor_10778, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3004, type_8050, type_29571), Reflex::Literal("vector"), constructor_10779, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30239), Reflex::Literal("vector"), constructor_10780, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_10781, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2699, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x11, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x12, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_HLTPerformanceInfo__Module__funcmem_bld);
}

//------Delayed data member builder for class vector<HLTPerformanceInfo::Module,std::allocator<HLTPerformanceInfo::Module> > -------------------
void __std__vector_HLTPerformanceInfo__Module__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<HLTPerformanceInfo::Module,std::allocator<HLTPerformanceInfo::Module> > -------------------
void __std__vector_HLTPerformanceInfo__Module__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30240, type_30239), Reflex::Literal("operator="), operator_10782, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3004, type_8050), Reflex::Literal("assign"), method_10783, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5807), Reflex::Literal("begin"), method_10784, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5806), Reflex::Literal("begin"), method_10785, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5807), Reflex::Literal("end"), method_10786, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5806), Reflex::Literal("end"), method_10787, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3004), Reflex::Literal("size"), method_10792, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3004), Reflex::Literal("max_size"), method_10793, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3004, type_5237), Reflex::Literal("resize"), method_10794, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3004), Reflex::Literal("capacity"), method_10795, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1374), Reflex::Literal("empty"), method_10796, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3004), Reflex::Literal("reserve"), method_10797, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8061, type_3004), Reflex::Literal("operator[]"), operator_10798, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8050, type_3004), Reflex::Literal("operator[]"), operator_10799, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8061, type_3004), Reflex::Literal("at"), method_10801, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8050, type_3004), Reflex::Literal("at"), method_10802, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8061), Reflex::Literal("front"), method_10803, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8050), Reflex::Literal("front"), method_10804, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8061), Reflex::Literal("back"), method_10805, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8050), Reflex::Literal("back"), method_10806, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8059), Reflex::Literal("data"), method_10807, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8048), Reflex::Literal("data"), method_10808, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_8050), Reflex::Literal("push_back"), method_10809, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166), Reflex::Literal("pop_back"), method_10810, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5807, type_5807, type_8050), Reflex::Literal("insert"), method_10811, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_5807, type_3004, type_8050), Reflex::Literal("insert"), method_10812, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5807, type_5807), Reflex::Literal("erase"), method_10813, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5807, type_5807, type_5807), Reflex::Literal("erase"), method_10814, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_30240), Reflex::Literal("swap"), method_10815, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166), Reflex::Literal("clear"), method_10816, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class TriggerEventWithRefs -------------------------------
static void destructor_17933(void*, void * o, const std::vector<void*>&, void *) {
(((::trigger::TriggerEventWithRefs*)o)->::trigger::TriggerEventWithRefs::~TriggerEventWithRefs)();
}
static  void operator_17934( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::trigger::TriggerEventWithRefs*)o)->operator=)(*(const ::trigger::TriggerEventWithRefs*)arg[0]);
  else   (((::trigger::TriggerEventWithRefs*)o)->operator=)(*(const ::trigger::TriggerEventWithRefs*)arg[0]);
}

static void constructor_17935( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::trigger::TriggerEventWithRefs(*(const ::trigger::TriggerEventWithRefs*)arg[0]);
  else ::new(mem) ::trigger::TriggerEventWithRefs(*(const ::trigger::TriggerEventWithRefs*)arg[0]);
}

static void constructor_17936( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::trigger::TriggerEventWithRefs();
  else ::new(mem) ::trigger::TriggerEventWithRefs();
}

static void constructor_17937( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::trigger::TriggerEventWithRefs(*(const ::std::string*)arg[0],
      *(::trigger::size_type*)arg[1]);
  else ::new(mem) ::trigger::TriggerEventWithRefs(*(const ::std::string*)arg[0],
      *(::trigger::size_type*)arg[1]);
}

static  void method_17938( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::trigger::TriggerEventWithRefs*)o)->addFilterObject)(*(const ::edm::InputTag*)arg[0],
    *(const ::trigger::TriggerFilterObjectWithRefs*)arg[1]);
}

static  void method_17939( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::trigger::TriggerEventWithRefs*)o)->usedProcessName)();
  else   (((const ::trigger::TriggerEventWithRefs*)o)->usedProcessName)();
}

static  void method_17940( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (trigger::size_type)((((const ::trigger::TriggerEventWithRefs*)o)->size)());
  else   (((const ::trigger::TriggerEventWithRefs*)o)->size)();
}

static  void method_17941( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::InputTag)((((const ::trigger::TriggerEventWithRefs*)o)->filterTag)(*(::trigger::size_type*)arg[0]));
  else   (((const ::trigger::TriggerEventWithRefs*)o)->filterTag)(*(::trigger::size_type*)arg[0]);
}

static  void method_17942( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (trigger::size_type)((((const ::trigger::TriggerEventWithRefs*)o)->filterIndex)(*(const ::edm::InputTag*)arg[0]));
  else   (((const ::trigger::TriggerEventWithRefs*)o)->filterIndex)(*(const ::edm::InputTag*)arg[0]);
}

static  void method_17943( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<unsigned short,unsigned short>)((((const ::trigger::TriggerEventWithRefs*)o)->photonSlice)(*(::trigger::size_type*)arg[0]));
  else   (((const ::trigger::TriggerEventWithRefs*)o)->photonSlice)(*(::trigger::size_type*)arg[0]);
}

static  void method_17944( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<unsigned short,unsigned short>)((((const ::trigger::TriggerEventWithRefs*)o)->electronSlice)(*(::trigger::size_type*)arg[0]));
  else   (((const ::trigger::TriggerEventWithRefs*)o)->electronSlice)(*(::trigger::size_type*)arg[0]);
}

static  void method_17945( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<unsigned short,unsigned short>)((((const ::trigger::TriggerEventWithRefs*)o)->muonSlice)(*(::trigger::size_type*)arg[0]));
  else   (((const ::trigger::TriggerEventWithRefs*)o)->muonSlice)(*(::trigger::size_type*)arg[0]);
}

static  void method_17946( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<unsigned short,unsigned short>)((((const ::trigger::TriggerEventWithRefs*)o)->jetSlice)(*(::trigger::size_type*)arg[0]));
  else   (((const ::trigger::TriggerEventWithRefs*)o)->jetSlice)(*(::trigger::size_type*)arg[0]);
}

static  void method_17947( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<unsigned short,unsigned short>)((((const ::trigger::TriggerEventWithRefs*)o)->compositeSlice)(*(::trigger::size_type*)arg[0]));
  else   (((const ::trigger::TriggerEventWithRefs*)o)->compositeSlice)(*(::trigger::size_type*)arg[0]);
}

static  void method_17948( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<unsigned short,unsigned short>)((((const ::trigger::TriggerEventWithRefs*)o)->basemetSlice)(*(::trigger::size_type*)arg[0]));
  else   (((const ::trigger::TriggerEventWithRefs*)o)->basemetSlice)(*(::trigger::size_type*)arg[0]);
}

static  void method_17949( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<unsigned short,unsigned short>)((((const ::trigger::TriggerEventWithRefs*)o)->calometSlice)(*(::trigger::size_type*)arg[0]));
  else   (((const ::trigger::TriggerEventWithRefs*)o)->calometSlice)(*(::trigger::size_type*)arg[0]);
}

static  void method_17950( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<unsigned short,unsigned short>)((((const ::trigger::TriggerEventWithRefs*)o)->pixtrackSlice)(*(::trigger::size_type*)arg[0]));
  else   (((const ::trigger::TriggerEventWithRefs*)o)->pixtrackSlice)(*(::trigger::size_type*)arg[0]);
}

static  void method_17951( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<unsigned short,unsigned short>)((((const ::trigger::TriggerEventWithRefs*)o)->l1emSlice)(*(::trigger::size_type*)arg[0]));
  else   (((const ::trigger::TriggerEventWithRefs*)o)->l1emSlice)(*(::trigger::size_type*)arg[0]);
}

static  void method_17952( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<unsigned short,unsigned short>)((((const ::trigger::TriggerEventWithRefs*)o)->l1muonSlice)(*(::trigger::size_type*)arg[0]));
  else   (((const ::trigger::TriggerEventWithRefs*)o)->l1muonSlice)(*(::trigger::size_type*)arg[0]);
}

static  void method_17953( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<unsigned short,unsigned short>)((((const ::trigger::TriggerEventWithRefs*)o)->l1jetSlice)(*(::trigger::size_type*)arg[0]));
  else   (((const ::trigger::TriggerEventWithRefs*)o)->l1jetSlice)(*(::trigger::size_type*)arg[0]);
}

static  void method_17954( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<unsigned short,unsigned short>)((((const ::trigger::TriggerEventWithRefs*)o)->l1etmissSlice)(*(::trigger::size_type*)arg[0]));
  else   (((const ::trigger::TriggerEventWithRefs*)o)->l1etmissSlice)(*(::trigger::size_type*)arg[0]);
}

static  void method_17955( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<unsigned short,unsigned short>)((((const ::trigger::TriggerEventWithRefs*)o)->l1hfringsSlice)(*(::trigger::size_type*)arg[0]));
  else   (((const ::trigger::TriggerEventWithRefs*)o)->l1hfringsSlice)(*(::trigger::size_type*)arg[0]);
}

static  void method_17956( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<unsigned short,unsigned short>)((((const ::trigger::TriggerEventWithRefs*)o)->pfjetSlice)(*(::trigger::size_type*)arg[0]));
  else   (((const ::trigger::TriggerEventWithRefs*)o)->pfjetSlice)(*(::trigger::size_type*)arg[0]);
}

static  void method_17957( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<unsigned short,unsigned short>)((((const ::trigger::TriggerEventWithRefs*)o)->pftauSlice)(*(::trigger::size_type*)arg[0]));
  else   (((const ::trigger::TriggerEventWithRefs*)o)->pftauSlice)(*(::trigger::size_type*)arg[0]);
}

static  void method_17958( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerEventWithRefs*)o)->getObjects)(*(::trigger::size_type*)arg[0],
    *(::trigger::Vids*)arg[1],
    *(::trigger::VRphoton*)arg[2]);
}

static  void method_17959( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerEventWithRefs*)o)->getObjects)(*(::trigger::size_type*)arg[0],
    *(int*)arg[1],
    *(::trigger::VRphoton*)arg[2]);
}

static  void method_17960( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerEventWithRefs*)o)->getObjects)(*(::trigger::size_type*)arg[0],
    *(::trigger::Vids*)arg[1],
    *(::trigger::VRelectron*)arg[2]);
}

static  void method_17961( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerEventWithRefs*)o)->getObjects)(*(::trigger::size_type*)arg[0],
    *(int*)arg[1],
    *(::trigger::VRelectron*)arg[2]);
}

static  void method_17962( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerEventWithRefs*)o)->getObjects)(*(::trigger::size_type*)arg[0],
    *(::trigger::Vids*)arg[1],
    *(::trigger::VRmuon*)arg[2]);
}

static  void method_17963( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerEventWithRefs*)o)->getObjects)(*(::trigger::size_type*)arg[0],
    *(int*)arg[1],
    *(::trigger::VRmuon*)arg[2]);
}

static  void method_17964( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerEventWithRefs*)o)->getObjects)(*(::trigger::size_type*)arg[0],
    *(::trigger::Vids*)arg[1],
    *(::trigger::VRjet*)arg[2]);
}

static  void method_17965( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerEventWithRefs*)o)->getObjects)(*(::trigger::size_type*)arg[0],
    *(int*)arg[1],
    *(::trigger::VRjet*)arg[2]);
}

static  void method_17966( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerEventWithRefs*)o)->getObjects)(*(::trigger::size_type*)arg[0],
    *(::trigger::Vids*)arg[1],
    *(::trigger::VRcomposite*)arg[2]);
}

static  void method_17967( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerEventWithRefs*)o)->getObjects)(*(::trigger::size_type*)arg[0],
    *(int*)arg[1],
    *(::trigger::VRcomposite*)arg[2]);
}

static  void method_17968( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerEventWithRefs*)o)->getObjects)(*(::trigger::size_type*)arg[0],
    *(::trigger::Vids*)arg[1],
    *(::trigger::VRbasemet*)arg[2]);
}

static  void method_17969( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerEventWithRefs*)o)->getObjects)(*(::trigger::size_type*)arg[0],
    *(int*)arg[1],
    *(::trigger::VRbasemet*)arg[2]);
}

static  void method_17970( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerEventWithRefs*)o)->getObjects)(*(::trigger::size_type*)arg[0],
    *(::trigger::Vids*)arg[1],
    *(::trigger::VRcalomet*)arg[2]);
}

static  void method_17971( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerEventWithRefs*)o)->getObjects)(*(::trigger::size_type*)arg[0],
    *(int*)arg[1],
    *(::trigger::VRcalomet*)arg[2]);
}

static  void method_17972( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerEventWithRefs*)o)->getObjects)(*(::trigger::size_type*)arg[0],
    *(::trigger::Vids*)arg[1],
    *(::trigger::VRpixtrack*)arg[2]);
}

static  void method_17973( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerEventWithRefs*)o)->getObjects)(*(::trigger::size_type*)arg[0],
    *(int*)arg[1],
    *(::trigger::VRpixtrack*)arg[2]);
}

static  void method_17974( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerEventWithRefs*)o)->getObjects)(*(::trigger::size_type*)arg[0],
    *(::trigger::Vids*)arg[1],
    *(::trigger::VRl1em*)arg[2]);
}

static  void method_17975( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerEventWithRefs*)o)->getObjects)(*(::trigger::size_type*)arg[0],
    *(int*)arg[1],
    *(::trigger::VRl1em*)arg[2]);
}

static  void method_17976( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerEventWithRefs*)o)->getObjects)(*(::trigger::size_type*)arg[0],
    *(::trigger::Vids*)arg[1],
    *(::trigger::VRl1muon*)arg[2]);
}

static  void method_17977( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerEventWithRefs*)o)->getObjects)(*(::trigger::size_type*)arg[0],
    *(int*)arg[1],
    *(::trigger::VRl1muon*)arg[2]);
}

static  void method_17978( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerEventWithRefs*)o)->getObjects)(*(::trigger::size_type*)arg[0],
    *(::trigger::Vids*)arg[1],
    *(::trigger::VRl1jet*)arg[2]);
}

static  void method_17979( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerEventWithRefs*)o)->getObjects)(*(::trigger::size_type*)arg[0],
    *(int*)arg[1],
    *(::trigger::VRl1jet*)arg[2]);
}

static  void method_17980( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerEventWithRefs*)o)->getObjects)(*(::trigger::size_type*)arg[0],
    *(::trigger::Vids*)arg[1],
    *(::trigger::VRl1etmiss*)arg[2]);
}

static  void method_17981( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerEventWithRefs*)o)->getObjects)(*(::trigger::size_type*)arg[0],
    *(int*)arg[1],
    *(::trigger::VRl1etmiss*)arg[2]);
}

static  void method_17982( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerEventWithRefs*)o)->getObjects)(*(::trigger::size_type*)arg[0],
    *(::trigger::Vids*)arg[1],
    *(::trigger::VRl1hfrings*)arg[2]);
}

static  void method_17983( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerEventWithRefs*)o)->getObjects)(*(::trigger::size_type*)arg[0],
    *(int*)arg[1],
    *(::trigger::VRl1hfrings*)arg[2]);
}

static  void method_17984( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerEventWithRefs*)o)->getObjects)(*(::trigger::size_type*)arg[0],
    *(::trigger::Vids*)arg[1],
    *(::trigger::VRpfjet*)arg[2]);
}

static  void method_17985( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerEventWithRefs*)o)->getObjects)(*(::trigger::size_type*)arg[0],
    *(int*)arg[1],
    *(::trigger::VRpfjet*)arg[2]);
}

static  void method_17986( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerEventWithRefs*)o)->getObjects)(*(::trigger::size_type*)arg[0],
    *(::trigger::Vids*)arg[1],
    *(::trigger::VRpftau*)arg[2]);
}

static  void method_17987( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerEventWithRefs*)o)->getObjects)(*(::trigger::size_type*)arg[0],
    *(int*)arg[1],
    *(::trigger::VRpftau*)arg[2]);
}

static void method_newdel_3600( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::trigger::TriggerEventWithRefs >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::trigger::TriggerEventWithRefs >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::trigger::TriggerEventWithRefs >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::trigger::TriggerEventWithRefs >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::trigger::TriggerEventWithRefs >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x14( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("trigger::TriggerRefsCollections")), ::Reflex::BaseOffset< ::trigger::TriggerEventWithRefs,::trigger::TriggerRefsCollections >::Get(),::Reflex::PUBLIC), 0));
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::DoNotRecordParents")), ::Reflex::BaseOffset< ::trigger::TriggerEventWithRefs,::edm::DoNotRecordParents >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TriggerEventWithRefs -------------------------------
void __trigger__TriggerEventWithRefs_db_datamem(Reflex::Class*);
void __trigger__TriggerEventWithRefs_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __trigger__TriggerEventWithRefs_datamem_bld(&__trigger__TriggerEventWithRefs_db_datamem);
Reflex::GenreflexMemberBuilder __trigger__TriggerEventWithRefs_funcmem_bld(&__trigger__TriggerEventWithRefs_db_funcmem);
void __trigger__TriggerEventWithRefs_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("trigger::TriggerEventWithRefs"), typeid(::trigger::TriggerEventWithRefs), sizeof(::trigger::TriggerEventWithRefs), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddBase(type_3626, ::Reflex::BaseOffset< ::trigger::TriggerEventWithRefs, ::trigger::TriggerRefsCollections >::Get(), ::Reflex::PUBLIC)
  .AddBase(type_4498, ::Reflex::BaseOffset< ::trigger::TriggerEventWithRefs, ::edm::DoNotRecordParents >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TriggerEventWithRefs"), destructor_17933, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30891, type_30892), Reflex::Literal("operator="), operator_17934, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30892), Reflex::Literal("TriggerEventWithRefs"), constructor_17935, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TriggerEventWithRefs"), constructor_17936, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14768, type_3599), Reflex::Literal("TriggerEventWithRefs"), constructor_17937, 0, "usedProcessName;n", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3600, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x14, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__trigger__TriggerEventWithRefs_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__trigger__TriggerEventWithRefs_funcmem_bld);
}

//------Delayed data member builder for class TriggerEventWithRefs -------------------
void __trigger__TriggerEventWithRefs_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2202, Reflex::Literal("usedProcessName_"), OffsetOf(__shadow__::__trigger__TriggerEventWithRefs, usedProcessName_), ::Reflex::PRIVATE)
  .AddDataMember(type_2701, Reflex::Literal("filterObjects_"), OffsetOf(__shadow__::__trigger__TriggerEventWithRefs, filterObjects_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TriggerEventWithRefs -------------------
void __trigger__TriggerEventWithRefs_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_11148, type_30893), Reflex::Literal("addFilterObject"), method_17938, 0, "filterTag;tfowr", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14768), Reflex::Literal("usedProcessName"), method_17939, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3599), Reflex::Literal("size"), method_17940, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4302c, type_3599), Reflex::Literal("filterTag"), method_17941, 0, "filterIndex", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3599, type_11148), Reflex::Literal("filterIndex"), method_17942, 0, "filterTag", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2636, type_3599), Reflex::Literal("photonSlice"), method_17943, 0, "filter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2636, type_3599), Reflex::Literal("electronSlice"), method_17944, 0, "filter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2636, type_3599), Reflex::Literal("muonSlice"), method_17945, 0, "filter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2636, type_3599), Reflex::Literal("jetSlice"), method_17946, 0, "filter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2636, type_3599), Reflex::Literal("compositeSlice"), method_17947, 0, "filter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2636, type_3599), Reflex::Literal("basemetSlice"), method_17948, 0, "filter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2636, type_3599), Reflex::Literal("calometSlice"), method_17949, 0, "filter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2636, type_3599), Reflex::Literal("pixtrackSlice"), method_17950, 0, "filter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2636, type_3599), Reflex::Literal("l1emSlice"), method_17951, 0, "filter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2636, type_3599), Reflex::Literal("l1muonSlice"), method_17952, 0, "filter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2636, type_3599), Reflex::Literal("l1jetSlice"), method_17953, 0, "filter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2636, type_3599), Reflex::Literal("l1etmissSlice"), method_17954, 0, "filter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2636, type_3599), Reflex::Literal("l1hfringsSlice"), method_17955, 0, "filter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2636, type_3599), Reflex::Literal("pfjetSlice"), method_17956, 0, "filter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2636, type_3599), Reflex::Literal("pftauSlice"), method_17957, 0, "filter", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3599, type_14641, type_14655), Reflex::Literal("getObjects"), method_17958, 0, "filter;ids;photons", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3599, type_71, type_14655), Reflex::Literal("getObjects"), method_17959, 0, "filter;id;photons", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3599, type_14641, type_14654), Reflex::Literal("getObjects"), method_17960, 0, "filter;ids;electrons", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3599, type_71, type_14654), Reflex::Literal("getObjects"), method_17961, 0, "filter;id;electrons", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3599, type_14641, type_14653), Reflex::Literal("getObjects"), method_17962, 0, "filter;ids;muons", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3599, type_71, type_14653), Reflex::Literal("getObjects"), method_17963, 0, "filter;id;muons", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3599, type_14641, type_14652), Reflex::Literal("getObjects"), method_17964, 0, "filter;ids;jets", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3599, type_71, type_14652), Reflex::Literal("getObjects"), method_17965, 0, "filter;id;jets", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3599, type_14641, type_14651), Reflex::Literal("getObjects"), method_17966, 0, "filter;ids;composites", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3599, type_71, type_14651), Reflex::Literal("getObjects"), method_17967, 0, "filter;id;composites", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3599, type_14641, type_14650), Reflex::Literal("getObjects"), method_17968, 0, "filter;ids;basemets", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3599, type_71, type_14650), Reflex::Literal("getObjects"), method_17969, 0, "filter;id;basemets", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3599, type_14641, type_14649), Reflex::Literal("getObjects"), method_17970, 0, "filter;ids;calomets", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3599, type_71, type_14649), Reflex::Literal("getObjects"), method_17971, 0, "filter;id;calomets", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3599, type_14641, type_14648), Reflex::Literal("getObjects"), method_17972, 0, "filter;ids;pixtracks", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3599, type_71, type_14648), Reflex::Literal("getObjects"), method_17973, 0, "filter;id;pixtracks", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3599, type_14641, type_14647), Reflex::Literal("getObjects"), method_17974, 0, "filter;ids;l1em", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3599, type_71, type_14647), Reflex::Literal("getObjects"), method_17975, 0, "filter;id;l1em", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3599, type_14641, type_14646), Reflex::Literal("getObjects"), method_17976, 0, "filter;ids;l1muon", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3599, type_71, type_14646), Reflex::Literal("getObjects"), method_17977, 0, "filter;id;l1muon", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3599, type_14641, type_14645), Reflex::Literal("getObjects"), method_17978, 0, "filter;ids;l1jet", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3599, type_71, type_14645), Reflex::Literal("getObjects"), method_17979, 0, "filter;id;l1jet", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3599, type_14641, type_14644), Reflex::Literal("getObjects"), method_17980, 0, "filter;ids;l1etmiss", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3599, type_71, type_14644), Reflex::Literal("getObjects"), method_17981, 0, "filter;id;l1etmiss", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3599, type_14641, type_14643), Reflex::Literal("getObjects"), method_17982, 0, "filter;ids;l1hfrings", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3599, type_71, type_14643), Reflex::Literal("getObjects"), method_17983, 0, "filter;id;l1hfrings", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3599, type_14641, type_14642), Reflex::Literal("getObjects"), method_17984, 0, "filter;ids;pfjets", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3599, type_71, type_14642), Reflex::Literal("getObjects"), method_17985, 0, "filter;id;pfjets", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3599, type_14641, type_14640), Reflex::Literal("getObjects"), method_17986, 0, "filter;ids;pftaus", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3599, type_71, type_14640), Reflex::Literal("getObjects"), method_17987, 0, "filter;id;pftaus", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class TriggerFilterObject -------------------------------
static void destructor_30257(void*, void * o, const std::vector<void*>&, void *) {
(((::trigger::TriggerEventWithRefs::TriggerFilterObject*)o)->::trigger::TriggerEventWithRefs::TriggerFilterObject::~TriggerFilterObject)();
}
static  void operator_30258( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::trigger::TriggerEventWithRefs::TriggerFilterObject*)o)->operator=)(*(const ::trigger::TriggerEventWithRefs::TriggerFilterObject*)arg[0]);
  else   (((::trigger::TriggerEventWithRefs::TriggerFilterObject*)o)->operator=)(*(const ::trigger::TriggerEventWithRefs::TriggerFilterObject*)arg[0]);
}

static void constructor_30259( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::trigger::TriggerEventWithRefs::TriggerFilterObject(*(const ::trigger::TriggerEventWithRefs::TriggerFilterObject*)arg[0]);
  else ::new(mem) ::trigger::TriggerEventWithRefs::TriggerFilterObject(*(const ::trigger::TriggerEventWithRefs::TriggerFilterObject*)arg[0]);
}

static void constructor_30260( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::trigger::TriggerEventWithRefs::TriggerFilterObject();
  else ::new(mem) ::trigger::TriggerEventWithRefs::TriggerFilterObject();
}

static void constructor_30261( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::trigger::TriggerEventWithRefs::TriggerFilterObject(*(const ::edm::InputTag*)arg[0],
      *(::trigger::size_type*)arg[1],
      *(::trigger::size_type*)arg[2],
      *(::trigger::size_type*)arg[3],
      *(::trigger::size_type*)arg[4],
      *(::trigger::size_type*)arg[5],
      *(::trigger::size_type*)arg[6],
      *(::trigger::size_type*)arg[7],
      *(::trigger::size_type*)arg[8],
      *(::trigger::size_type*)arg[9],
      *(::trigger::size_type*)arg[10],
      *(::trigger::size_type*)arg[11],
      *(::trigger::size_type*)arg[12],
      *(::trigger::size_type*)arg[13],
      *(::trigger::size_type*)arg[14],
      *(::trigger::size_type*)arg[15]);
  else ::new(mem) ::trigger::TriggerEventWithRefs::TriggerFilterObject(*(const ::edm::InputTag*)arg[0],
      *(::trigger::size_type*)arg[1],
      *(::trigger::size_type*)arg[2],
      *(::trigger::size_type*)arg[3],
      *(::trigger::size_type*)arg[4],
      *(::trigger::size_type*)arg[5],
      *(::trigger::size_type*)arg[6],
      *(::trigger::size_type*)arg[7],
      *(::trigger::size_type*)arg[8],
      *(::trigger::size_type*)arg[9],
      *(::trigger::size_type*)arg[10],
      *(::trigger::size_type*)arg[11],
      *(::trigger::size_type*)arg[12],
      *(::trigger::size_type*)arg[13],
      *(::trigger::size_type*)arg[14],
      *(::trigger::size_type*)arg[15]);
}

static void method_newdel_10884( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::trigger::TriggerEventWithRefs::TriggerFilterObject >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::trigger::TriggerEventWithRefs::TriggerFilterObject >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::trigger::TriggerEventWithRefs::TriggerFilterObject >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::trigger::TriggerEventWithRefs::TriggerFilterObject >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::trigger::TriggerEventWithRefs::TriggerFilterObject >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class TriggerFilterObject -------------------------------
void __trigger__TriggerEventWithRefs__TriggerFilterObject_db_datamem(Reflex::Class*);
void __trigger__TriggerEventWithRefs__TriggerFilterObject_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __trigger__TriggerEventWithRefs__TriggerFilterObject_datamem_bld(&__trigger__TriggerEventWithRefs__TriggerFilterObject_db_datamem);
Reflex::GenreflexMemberBuilder __trigger__TriggerEventWithRefs__TriggerFilterObject_funcmem_bld(&__trigger__TriggerEventWithRefs__TriggerFilterObject_db_funcmem);
void __trigger__TriggerEventWithRefs__TriggerFilterObject_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("trigger::TriggerEventWithRefs::TriggerFilterObject"), typeid(::trigger::TriggerEventWithRefs::TriggerFilterObject), sizeof(::trigger::TriggerEventWithRefs::TriggerFilterObject), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "12")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TriggerFilterObject"), destructor_30257, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10893, type_10895), Reflex::Literal("operator="), operator_30258, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10895), Reflex::Literal("TriggerFilterObject"), constructor_30259, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TriggerFilterObject"), constructor_30260, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11148, type_3599, type_3599, type_3599, type_3599, type_3599, type_3599, type_3599, type_3599, type_3599, type_3599, type_3599, type_3599, type_3599, type_3599, type_3599), Reflex::Literal("TriggerFilterObject"), constructor_30261, 0, "filterTag;np;ne;nm;nj;nc;nB;nC;nt;l1em;l1muon;l1jet;l1etmiss;l1hfrings;pfjets;pftaus", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_10884, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__trigger__TriggerEventWithRefs__TriggerFilterObject_datamem_bld);
}

//------Delayed data member builder for class TriggerFilterObject -------------------
void __trigger__TriggerEventWithRefs__TriggerFilterObject_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2202, Reflex::Literal("filterTag_"), OffsetOf(__shadow__::__trigger__TriggerEventWithRefs__TriggerFilterObject, filterTag_), ::Reflex::PUBLIC)
  .AddDataMember(type_3599, Reflex::Literal("photons_"), OffsetOf(__shadow__::__trigger__TriggerEventWithRefs__TriggerFilterObject, photons_), ::Reflex::PUBLIC)
  .AddDataMember(type_3599, Reflex::Literal("electrons_"), OffsetOf(__shadow__::__trigger__TriggerEventWithRefs__TriggerFilterObject, electrons_), ::Reflex::PUBLIC)
  .AddDataMember(type_3599, Reflex::Literal("muons_"), OffsetOf(__shadow__::__trigger__TriggerEventWithRefs__TriggerFilterObject, muons_), ::Reflex::PUBLIC)
  .AddDataMember(type_3599, Reflex::Literal("jets_"), OffsetOf(__shadow__::__trigger__TriggerEventWithRefs__TriggerFilterObject, jets_), ::Reflex::PUBLIC)
  .AddDataMember(type_3599, Reflex::Literal("composites_"), OffsetOf(__shadow__::__trigger__TriggerEventWithRefs__TriggerFilterObject, composites_), ::Reflex::PUBLIC)
  .AddDataMember(type_3599, Reflex::Literal("basemets_"), OffsetOf(__shadow__::__trigger__TriggerEventWithRefs__TriggerFilterObject, basemets_), ::Reflex::PUBLIC)
  .AddDataMember(type_3599, Reflex::Literal("calomets_"), OffsetOf(__shadow__::__trigger__TriggerEventWithRefs__TriggerFilterObject, calomets_), ::Reflex::PUBLIC)
  .AddDataMember(type_3599, Reflex::Literal("pixtracks_"), OffsetOf(__shadow__::__trigger__TriggerEventWithRefs__TriggerFilterObject, pixtracks_), ::Reflex::PUBLIC)
  .AddDataMember(type_3599, Reflex::Literal("l1em_"), OffsetOf(__shadow__::__trigger__TriggerEventWithRefs__TriggerFilterObject, l1em_), ::Reflex::PUBLIC)
  .AddDataMember(type_3599, Reflex::Literal("l1muon_"), OffsetOf(__shadow__::__trigger__TriggerEventWithRefs__TriggerFilterObject, l1muon_), ::Reflex::PUBLIC)
  .AddDataMember(type_3599, Reflex::Literal("l1jet_"), OffsetOf(__shadow__::__trigger__TriggerEventWithRefs__TriggerFilterObject, l1jet_), ::Reflex::PUBLIC)
  .AddDataMember(type_3599, Reflex::Literal("l1etmiss_"), OffsetOf(__shadow__::__trigger__TriggerEventWithRefs__TriggerFilterObject, l1etmiss_), ::Reflex::PUBLIC)
  .AddDataMember(type_3599, Reflex::Literal("l1hfrings_"), OffsetOf(__shadow__::__trigger__TriggerEventWithRefs__TriggerFilterObject, l1hfrings_), ::Reflex::PUBLIC)
  .AddDataMember(type_3599, Reflex::Literal("pfjets_"), OffsetOf(__shadow__::__trigger__TriggerEventWithRefs__TriggerFilterObject, pfjets_), ::Reflex::PUBLIC)
  .AddDataMember(type_3599, Reflex::Literal("pftaus_"), OffsetOf(__shadow__::__trigger__TriggerEventWithRefs__TriggerFilterObject, pftaus_), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class TriggerFilterObject -------------------
void __trigger__TriggerEventWithRefs__TriggerFilterObject_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<trigger::TriggerEventWithRefs::TriggerFilterObject,std::allocator<trigger::TriggerEventWithRefs::TriggerFilterObject> > -------------------------------
static void constructor_10904( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>();
  else ::new(mem) ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>();
}

static void constructor_10905( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>(*(const ::std::allocator<trigger::TriggerEventWithRefs::TriggerFilterObject>*)arg[0]);
  else ::new(mem) ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>(*(const ::std::allocator<trigger::TriggerEventWithRefs::TriggerFilterObject>*)arg[0]);
}

static void constructor_10906( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>(*(::std::size_t*)arg[0],
      *(const ::trigger::TriggerEventWithRefs::TriggerFilterObject*)arg[1]);
  else ::new(mem) ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>(*(::std::size_t*)arg[0],
      *(const ::trigger::TriggerEventWithRefs::TriggerFilterObject*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>(*(::std::size_t*)arg[0],
      *(const ::trigger::TriggerEventWithRefs::TriggerFilterObject*)arg[1],
      *(const ::std::allocator<trigger::TriggerEventWithRefs::TriggerFilterObject>*)arg[2]);
  else ::new(mem) ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>(*(::std::size_t*)arg[0],
      *(const ::trigger::TriggerEventWithRefs::TriggerFilterObject*)arg[1],
      *(const ::std::allocator<trigger::TriggerEventWithRefs::TriggerFilterObject>*)arg[2]);
  }
}

static void constructor_10907( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>(*(const ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)arg[0]);
  else ::new(mem) ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>(*(const ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)arg[0]);
}

static void destructor_10908(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>::~vector)();
}
static  void operator_10909( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->operator=)(*(const ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)arg[0]);
  else   (((::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->operator=)(*(const ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)arg[0]);
}

static  void method_10910( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::trigger::TriggerEventWithRefs::TriggerFilterObject*)arg[1]);
}

static  void method_10911( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<trigger::TriggerEventWithRefs::TriggerFilterObject*,std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject> >)((((::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->begin)());
  else   (((::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->begin)();
}

static  void method_10912( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const trigger::TriggerEventWithRefs::TriggerFilterObject*,std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject> >)((((const ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->begin)());
  else   (((const ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->begin)();
}

static  void method_10913( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<trigger::TriggerEventWithRefs::TriggerFilterObject*,std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject> >)((((::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->end)());
  else   (((::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->end)();
}

static  void method_10914( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const trigger::TriggerEventWithRefs::TriggerFilterObject*,std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject> >)((((const ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->end)());
  else   (((const ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->end)();
}

static  void method_10919( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->size)());
  else   (((const ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->size)();
}

static  void method_10920( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->max_size)());
  else   (((const ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->max_size)();
}

static  void method_10921( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::trigger::TriggerEventWithRefs::TriggerFilterObject*)arg[1]);
  }
}

static  void method_10922( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->capacity)());
  else   (((const ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->capacity)();
}

static  void method_10923( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->empty)());
  else   (((const ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->empty)();
}

static  void method_10924( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_10925( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_10926( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_10928( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10929( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10930( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->front)();
  else   (((::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->front)();
}

static  void method_10931( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->front)();
  else   (((const ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->front)();
}

static  void method_10932( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->back)();
  else   (((::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->back)();
}

static  void method_10933( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->back)();
  else   (((const ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->back)();
}

static  void method_10934( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->data)());
  else   (((::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->data)();
}

static  void method_10935( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->data)());
  else   (((const ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->data)();
}

static  void method_10936( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->push_back)(*(const ::trigger::TriggerEventWithRefs::TriggerFilterObject*)arg[0]);
}

static  void method_10937( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->pop_back)();
}

static  void method_10938( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<trigger::TriggerEventWithRefs::TriggerFilterObject*,std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject> >)((((::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<trigger::TriggerEventWithRefs::TriggerFilterObject*,std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject> >*)arg[0],
    *(const ::trigger::TriggerEventWithRefs::TriggerFilterObject*)arg[1]));
  else   (((::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<trigger::TriggerEventWithRefs::TriggerFilterObject*,std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject> >*)arg[0],
    *(const ::trigger::TriggerEventWithRefs::TriggerFilterObject*)arg[1]);
}

static  void method_10939( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<trigger::TriggerEventWithRefs::TriggerFilterObject*,std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::trigger::TriggerEventWithRefs::TriggerFilterObject*)arg[2]);
}

static  void method_10940( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<trigger::TriggerEventWithRefs::TriggerFilterObject*,std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject> >)((((::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<trigger::TriggerEventWithRefs::TriggerFilterObject*,std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject> >*)arg[0]));
  else   (((::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<trigger::TriggerEventWithRefs::TriggerFilterObject*,std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject> >*)arg[0]);
}

static  void method_10941( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<trigger::TriggerEventWithRefs::TriggerFilterObject*,std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject> >)((((::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<trigger::TriggerEventWithRefs::TriggerFilterObject*,std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<trigger::TriggerEventWithRefs::TriggerFilterObject*,std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject> >*)arg[1]));
  else   (((::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<trigger::TriggerEventWithRefs::TriggerFilterObject*,std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<trigger::TriggerEventWithRefs::TriggerFilterObject*,std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject> >*)arg[1]);
}

static  void method_10942( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->swap)(*(::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)arg[0]);
}

static  void method_10943( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>*)o)->clear)();
}

static void method_newdel_2701( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x17( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<trigger::TriggerEventWithRefs::TriggerFilterObject,std::allocator<trigger::TriggerEventWithRefs::TriggerFilterObject> >")), ::Reflex::BaseOffset< ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>,::std::_Vector_base<trigger::TriggerEventWithRefs::TriggerFilterObject,std::allocator<trigger::TriggerEventWithRefs::TriggerFilterObject> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x18( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject> >::Generate();
  else ::Reflex::Proxy< ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject> >::Generate();
}

//------Dictionary for class vector<trigger::TriggerEventWithRefs::TriggerFilterObject,std::allocator<trigger::TriggerEventWithRefs::TriggerFilterObject> > -------------------------------
void __std__vector_trigger__TriggerEventWithRefs__TriggerFilterObject__db_datamem(Reflex::Class*);
void __std__vector_trigger__TriggerEventWithRefs__TriggerFilterObject__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_trigger__TriggerEventWithRefs__TriggerFilterObject__datamem_bld(&__std__vector_trigger__TriggerEventWithRefs__TriggerFilterObject__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_trigger__TriggerEventWithRefs__TriggerFilterObject__funcmem_bld(&__std__vector_trigger__TriggerEventWithRefs__TriggerFilterObject__db_funcmem);
void __std__vector_trigger__TriggerEventWithRefs__TriggerFilterObject__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>"), typeid(::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>), sizeof(::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2132, ::Reflex::BaseOffset< ::std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>, ::std::_Vector_base<trigger::TriggerEventWithRefs::TriggerFilterObject,std::allocator<trigger::TriggerEventWithRefs::TriggerFilterObject> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_10884, Reflex::Literal("std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>::_Alloc_value_type"))
  .AddTypedef(type_2132, Reflex::Literal("std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>::_Base"))
  .AddTypedef(type_3025, Reflex::Literal("std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>::_Tp_alloc_type"))
  .AddTypedef(type_10884, Reflex::Literal("std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>::value_type"))
  .AddTypedef(type_10889, Reflex::Literal("std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>::pointer"))
  .AddTypedef(type_10891, Reflex::Literal("std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>::const_pointer"))
  .AddTypedef(type_10893, Reflex::Literal("std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>::reference"))
  .AddTypedef(type_10895, Reflex::Literal("std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>::const_reference"))
  .AddTypedef(type_5690, Reflex::Literal("std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>::iterator"))
  .AddTypedef(type_5691, Reflex::Literal("std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>::const_iterator"))
  .AddTypedef(type_3228, Reflex::Literal("std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>::const_reverse_iterator"))
  .AddTypedef(type_3229, Reflex::Literal("std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>::reverse_iterator"))
  .AddTypedef(type_3004, Reflex::Literal("std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>::size_type"))
  .AddTypedef(type_2891, Reflex::Literal("std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>::difference_type"))
  .AddTypedef(type_3025, Reflex::Literal("std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_10904, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28875), Reflex::Literal("vector"), constructor_10905, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3004, type_10895, type_28875), Reflex::Literal("vector"), constructor_10906, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30263), Reflex::Literal("vector"), constructor_10907, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_10908, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2701, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x17, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x18, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_trigger__TriggerEventWithRefs__TriggerFilterObject__funcmem_bld);
}

//------Delayed data member builder for class vector<trigger::TriggerEventWithRefs::TriggerFilterObject,std::allocator<trigger::TriggerEventWithRefs::TriggerFilterObject> > -------------------
void __std__vector_trigger__TriggerEventWithRefs__TriggerFilterObject__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<trigger::TriggerEventWithRefs::TriggerFilterObject,std::allocator<trigger::TriggerEventWithRefs::TriggerFilterObject> > -------------------
void __std__vector_trigger__TriggerEventWithRefs__TriggerFilterObject__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30264, type_30263), Reflex::Literal("operator="), operator_10909, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3004, type_10895), Reflex::Literal("assign"), method_10910, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5690), Reflex::Literal("begin"), method_10911, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5691), Reflex::Literal("begin"), method_10912, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5690), Reflex::Literal("end"), method_10913, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5691), Reflex::Literal("end"), method_10914, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3004), Reflex::Literal("size"), method_10919, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3004), Reflex::Literal("max_size"), method_10920, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3004, type_10884), Reflex::Literal("resize"), method_10921, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3004), Reflex::Literal("capacity"), method_10922, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1374), Reflex::Literal("empty"), method_10923, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3004), Reflex::Literal("reserve"), method_10924, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10893, type_3004), Reflex::Literal("operator[]"), operator_10925, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10895, type_3004), Reflex::Literal("operator[]"), operator_10926, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10893, type_3004), Reflex::Literal("at"), method_10928, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10895, type_3004), Reflex::Literal("at"), method_10929, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10893), Reflex::Literal("front"), method_10930, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10895), Reflex::Literal("front"), method_10931, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10893), Reflex::Literal("back"), method_10932, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10895), Reflex::Literal("back"), method_10933, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10889), Reflex::Literal("data"), method_10934, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10891), Reflex::Literal("data"), method_10935, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_10895), Reflex::Literal("push_back"), method_10936, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166), Reflex::Literal("pop_back"), method_10937, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5690, type_5690, type_10895), Reflex::Literal("insert"), method_10938, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_5690, type_3004, type_10895), Reflex::Literal("insert"), method_10939, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5690, type_5690), Reflex::Literal("erase"), method_10940, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5690, type_5690, type_5690), Reflex::Literal("erase"), method_10941, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_30264), Reflex::Literal("swap"), method_10942, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166), Reflex::Literal("clear"), method_10943, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class TriggerEvent -------------------------------
static void destructor_18051(void*, void * o, const std::vector<void*>&, void *) {
(((::trigger::TriggerEvent*)o)->::trigger::TriggerEvent::~TriggerEvent)();
}
static  void operator_18052( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::trigger::TriggerEvent*)o)->operator=)(*(const ::trigger::TriggerEvent*)arg[0]);
  else   (((::trigger::TriggerEvent*)o)->operator=)(*(const ::trigger::TriggerEvent*)arg[0]);
}

static void constructor_18053( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::trigger::TriggerEvent(*(const ::trigger::TriggerEvent*)arg[0]);
  else ::new(mem) ::trigger::TriggerEvent(*(const ::trigger::TriggerEvent*)arg[0]);
}

static void constructor_18054( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::trigger::TriggerEvent();
  else ::new(mem) ::trigger::TriggerEvent();
}

static void constructor_18055( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::trigger::TriggerEvent(*(const ::std::string*)arg[0],
      *(::trigger::size_type*)arg[1],
      *(::trigger::size_type*)arg[2],
      *(::trigger::size_type*)arg[3]);
  else ::new(mem) ::trigger::TriggerEvent(*(const ::std::string*)arg[0],
      *(::trigger::size_type*)arg[1],
      *(::trigger::size_type*)arg[2],
      *(::trigger::size_type*)arg[3]);
}

static  void method_18056( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::trigger::TriggerEvent*)o)->addObjects)(*(const ::trigger::TriggerObjectCollection*)arg[0]);
}

static  void method_18057( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::trigger::TriggerEvent*)o)->addCollections)(*(const ::std::vector<edm::InputTag>*)arg[0],
    *(const ::trigger::Keys*)arg[1]);
}

static  void method_18058( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::trigger::TriggerEvent*)o)->addCollections)(*(const ::std::vector<std::basic_string<char> >*)arg[0],
    *(const ::trigger::Keys*)arg[1]);
}

static  void method_18059( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::trigger::TriggerEvent*)o)->addFilter)(*(const ::edm::InputTag*)arg[0],
    *(const ::trigger::Vids*)arg[1],
    *(const ::trigger::Keys*)arg[2]);
}

static  void method_18060( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::trigger::TriggerEvent*)o)->usedProcessName)();
  else   (((const ::trigger::TriggerEvent*)o)->usedProcessName)();
}

static  void method_18061( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::trigger::TriggerEvent*)o)->collectionTags)();
  else   (((const ::trigger::TriggerEvent*)o)->collectionTags)();
}

static  void method_18062( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::trigger::TriggerEvent*)o)->collectionKeys)();
  else   (((const ::trigger::TriggerEvent*)o)->collectionKeys)();
}

static  void method_18063( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::trigger::TriggerEvent*)o)->getObjects)();
  else   (((const ::trigger::TriggerEvent*)o)->getObjects)();
}

static  void method_18064( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::InputTag)((((const ::trigger::TriggerEvent*)o)->collectionTag)(*(::trigger::size_type*)arg[0]));
  else   (((const ::trigger::TriggerEvent*)o)->collectionTag)(*(::trigger::size_type*)arg[0]);
}

static  void method_18065( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::trigger::TriggerEvent*)o)->collectionTagEncoded)(*(::trigger::size_type*)arg[0]);
  else   (((const ::trigger::TriggerEvent*)o)->collectionTagEncoded)(*(::trigger::size_type*)arg[0]);
}

static  void method_18066( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (trigger::size_type)((((const ::trigger::TriggerEvent*)o)->collectionKey)(*(::trigger::size_type*)arg[0]));
  else   (((const ::trigger::TriggerEvent*)o)->collectionKey)(*(::trigger::size_type*)arg[0]);
}

static  void method_18067( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (edm::InputTag)((((const ::trigger::TriggerEvent*)o)->filterTag)(*(::trigger::size_type*)arg[0]));
  else   (((const ::trigger::TriggerEvent*)o)->filterTag)(*(::trigger::size_type*)arg[0]);
}

static  void method_18068( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::trigger::TriggerEvent*)o)->filterTagEncoded)(*(::trigger::size_type*)arg[0]);
  else   (((const ::trigger::TriggerEvent*)o)->filterTagEncoded)(*(::trigger::size_type*)arg[0]);
}

static  void method_18069( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::trigger::TriggerEvent*)o)->filterLabel)(*(::trigger::size_type*)arg[0]));
  else   (((const ::trigger::TriggerEvent*)o)->filterLabel)(*(::trigger::size_type*)arg[0]);
}

static  void method_18070( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::trigger::TriggerEvent*)o)->filterIds)(*(::trigger::size_type*)arg[0]);
  else   (((const ::trigger::TriggerEvent*)o)->filterIds)(*(::trigger::size_type*)arg[0]);
}

static  void method_18071( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::trigger::TriggerEvent*)o)->filterKeys)(*(::trigger::size_type*)arg[0]);
  else   (((const ::trigger::TriggerEvent*)o)->filterKeys)(*(::trigger::size_type*)arg[0]);
}

static  void method_18072( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (trigger::size_type)((((const ::trigger::TriggerEvent*)o)->collectionIndex)(*(const ::edm::InputTag*)arg[0]));
  else   (((const ::trigger::TriggerEvent*)o)->collectionIndex)(*(const ::edm::InputTag*)arg[0]);
}

static  void method_18073( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (trigger::size_type)((((const ::trigger::TriggerEvent*)o)->filterIndex)(*(const ::edm::InputTag*)arg[0]));
  else   (((const ::trigger::TriggerEvent*)o)->filterIndex)(*(const ::edm::InputTag*)arg[0]);
}

static  void method_18074( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (trigger::size_type)((((const ::trigger::TriggerEvent*)o)->sizeCollections)());
  else   (((const ::trigger::TriggerEvent*)o)->sizeCollections)();
}

static  void method_18075( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (trigger::size_type)((((const ::trigger::TriggerEvent*)o)->sizeObjects)());
  else   (((const ::trigger::TriggerEvent*)o)->sizeObjects)();
}

static  void method_18076( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (trigger::size_type)((((const ::trigger::TriggerEvent*)o)->sizeFilters)());
  else   (((const ::trigger::TriggerEvent*)o)->sizeFilters)();
}

static void method_newdel_3621( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::trigger::TriggerEvent >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::trigger::TriggerEvent >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::trigger::TriggerEvent >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::trigger::TriggerEvent >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::trigger::TriggerEvent >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x20( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("edm::DoNotRecordParents")), ::Reflex::BaseOffset< ::trigger::TriggerEvent,::edm::DoNotRecordParents >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TriggerEvent -------------------------------
void __trigger__TriggerEvent_db_datamem(Reflex::Class*);
void __trigger__TriggerEvent_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __trigger__TriggerEvent_datamem_bld(&__trigger__TriggerEvent_db_datamem);
Reflex::GenreflexMemberBuilder __trigger__TriggerEvent_funcmem_bld(&__trigger__TriggerEvent_db_funcmem);
void __trigger__TriggerEvent_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("trigger::TriggerEvent"), typeid(::trigger::TriggerEvent), sizeof(::trigger::TriggerEvent), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddBase(type_4498, ::Reflex::BaseOffset< ::trigger::TriggerEvent, ::edm::DoNotRecordParents >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TriggerEvent"), destructor_18051, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30897, type_30898), Reflex::Literal("operator="), operator_18052, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30898), Reflex::Literal("TriggerEvent"), constructor_18053, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TriggerEvent"), constructor_18054, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14768, type_3599, type_3599, type_3599), Reflex::Literal("TriggerEvent"), constructor_18055, 0, "usedProcessName;nc;no;nf", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3621, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x20, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__trigger__TriggerEvent_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__trigger__TriggerEvent_funcmem_bld);
}

//------Delayed data member builder for class TriggerEvent -------------------
void __trigger__TriggerEvent_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2202, Reflex::Literal("usedProcessName_"), OffsetOf(__shadow__::__trigger__TriggerEvent, usedProcessName_), ::Reflex::PRIVATE)
  .AddDataMember(type_2700, Reflex::Literal("collectionTags_"), OffsetOf(__shadow__::__trigger__TriggerEvent, collectionTags_), ::Reflex::PRIVATE)
  .AddDataMember(type_3618, Reflex::Literal("collectionKeys_"), OffsetOf(__shadow__::__trigger__TriggerEvent, collectionKeys_), ::Reflex::PRIVATE)
  .AddDataMember(type_3623, Reflex::Literal("triggerObjects_"), OffsetOf(__shadow__::__trigger__TriggerEvent, triggerObjects_), ::Reflex::PRIVATE)
  .AddDataMember(type_2703, Reflex::Literal("triggerFilters_"), OffsetOf(__shadow__::__trigger__TriggerEvent, triggerFilters_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TriggerEvent -------------------
void __trigger__TriggerEvent_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_30899), Reflex::Literal("addObjects"), method_18056, 0, "triggerObjects", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_30282, type_30900), Reflex::Literal("addCollections"), method_18057, 0, "collectionTags;collectionKeys", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_9766, type_30900), Reflex::Literal("addCollections"), method_18058, 0, "collectionTags;collectionKeys", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_11148, type_30901, type_30900), Reflex::Literal("addFilter"), method_18059, 0, "filterTag;filterIds;filterKeys", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14768), Reflex::Literal("usedProcessName"), method_18060, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9766), Reflex::Literal("collectionTags"), method_18061, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30900), Reflex::Literal("collectionKeys"), method_18062, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30899), Reflex::Literal("getObjects"), method_18063, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4302c, type_3599), Reflex::Literal("collectionTag"), method_18064, 0, "index", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14768, type_3599), Reflex::Literal("collectionTagEncoded"), method_18065, 0, "index", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3599, type_3599), Reflex::Literal("collectionKey"), method_18066, 0, "index", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4302c, type_3599), Reflex::Literal("filterTag"), method_18067, 0, "index", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14768, type_3599), Reflex::Literal("filterTagEncoded"), method_18068, 0, "index", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2202, type_3599), Reflex::Literal("filterLabel"), method_18069, 0, "index", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30901, type_3599), Reflex::Literal("filterIds"), method_18070, 0, "index", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30900, type_3599), Reflex::Literal("filterKeys"), method_18071, 0, "index", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3599, type_11148), Reflex::Literal("collectionIndex"), method_18072, 0, "collectionTag", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3599, type_11148), Reflex::Literal("filterIndex"), method_18073, 0, "filterTag", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3599), Reflex::Literal("sizeCollections"), method_18074, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3599), Reflex::Literal("sizeObjects"), method_18075, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3599), Reflex::Literal("sizeFilters"), method_18076, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class TriggerFilterObject -------------------------------
static void destructor_30270(void*, void * o, const std::vector<void*>&, void *) {
(((::trigger::TriggerEvent::TriggerFilterObject*)o)->::trigger::TriggerEvent::TriggerFilterObject::~TriggerFilterObject)();
}
static  void operator_30271( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::trigger::TriggerEvent::TriggerFilterObject*)o)->operator=)(*(const ::trigger::TriggerEvent::TriggerFilterObject*)arg[0]);
  else   (((::trigger::TriggerEvent::TriggerFilterObject*)o)->operator=)(*(const ::trigger::TriggerEvent::TriggerFilterObject*)arg[0]);
}

static void constructor_30272( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::trigger::TriggerEvent::TriggerFilterObject(*(const ::trigger::TriggerEvent::TriggerFilterObject*)arg[0]);
  else ::new(mem) ::trigger::TriggerEvent::TriggerFilterObject(*(const ::trigger::TriggerEvent::TriggerFilterObject*)arg[0]);
}

static void constructor_30273( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::trigger::TriggerEvent::TriggerFilterObject();
  else ::new(mem) ::trigger::TriggerEvent::TriggerFilterObject();
}

static void constructor_30274( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::trigger::TriggerEvent::TriggerFilterObject(*(const ::edm::InputTag*)arg[0]);
  else ::new(mem) ::trigger::TriggerEvent::TriggerFilterObject(*(const ::edm::InputTag*)arg[0]);
}

static void constructor_30275( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::trigger::TriggerEvent::TriggerFilterObject(*(const ::edm::InputTag*)arg[0],
      *(const ::trigger::Vids*)arg[1],
      *(const ::trigger::Keys*)arg[2]);
  else ::new(mem) ::trigger::TriggerEvent::TriggerFilterObject(*(const ::edm::InputTag*)arg[0],
      *(const ::trigger::Vids*)arg[1],
      *(const ::trigger::Keys*)arg[2]);
}

static void method_newdel_11011( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::trigger::TriggerEvent::TriggerFilterObject >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::trigger::TriggerEvent::TriggerFilterObject >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::trigger::TriggerEvent::TriggerFilterObject >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::trigger::TriggerEvent::TriggerFilterObject >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::trigger::TriggerEvent::TriggerFilterObject >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class TriggerFilterObject -------------------------------
void __trigger__TriggerEvent__TriggerFilterObject_db_datamem(Reflex::Class*);
void __trigger__TriggerEvent__TriggerFilterObject_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __trigger__TriggerEvent__TriggerFilterObject_datamem_bld(&__trigger__TriggerEvent__TriggerFilterObject_db_datamem);
Reflex::GenreflexMemberBuilder __trigger__TriggerEvent__TriggerFilterObject_funcmem_bld(&__trigger__TriggerEvent__TriggerFilterObject_db_funcmem);
void __trigger__TriggerEvent__TriggerFilterObject_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("trigger::TriggerEvent::TriggerFilterObject"), typeid(::trigger::TriggerEvent::TriggerFilterObject), sizeof(::trigger::TriggerEvent::TriggerFilterObject), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TriggerFilterObject"), destructor_30270, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11020, type_11022), Reflex::Literal("operator="), operator_30271, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11022), Reflex::Literal("TriggerFilterObject"), constructor_30272, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TriggerFilterObject"), constructor_30273, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11148), Reflex::Literal("TriggerFilterObject"), constructor_30274, 0, "filterTag", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_11148, type_30901, type_30900), Reflex::Literal("TriggerFilterObject"), constructor_30275, 0, "filterTag;filterIds;filterKeys", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_11011, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__trigger__TriggerEvent__TriggerFilterObject_datamem_bld);
}

//------Delayed data member builder for class TriggerFilterObject -------------------
void __trigger__TriggerEvent__TriggerFilterObject_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2202, Reflex::Literal("filterTag_"), OffsetOf(__shadow__::__trigger__TriggerEvent__TriggerFilterObject, filterTag_), ::Reflex::PUBLIC)
  .AddDataMember(type_3611, Reflex::Literal("filterIds_"), OffsetOf(__shadow__::__trigger__TriggerEvent__TriggerFilterObject, filterIds_), ::Reflex::PUBLIC)
  .AddDataMember(type_3618, Reflex::Literal("filterKeys_"), OffsetOf(__shadow__::__trigger__TriggerEvent__TriggerFilterObject, filterKeys_), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class TriggerFilterObject -------------------
void __trigger__TriggerEvent__TriggerFilterObject_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<trigger::TriggerEvent::TriggerFilterObject,std::allocator<trigger::TriggerEvent::TriggerFilterObject> > -------------------------------
static void constructor_11031( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<trigger::TriggerEvent::TriggerFilterObject>();
  else ::new(mem) ::std::vector<trigger::TriggerEvent::TriggerFilterObject>();
}

static void constructor_11032( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<trigger::TriggerEvent::TriggerFilterObject>(*(const ::std::allocator<trigger::TriggerEvent::TriggerFilterObject>*)arg[0]);
  else ::new(mem) ::std::vector<trigger::TriggerEvent::TriggerFilterObject>(*(const ::std::allocator<trigger::TriggerEvent::TriggerFilterObject>*)arg[0]);
}

static void constructor_11033( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<trigger::TriggerEvent::TriggerFilterObject>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<trigger::TriggerEvent::TriggerFilterObject>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<trigger::TriggerEvent::TriggerFilterObject>(*(::std::size_t*)arg[0],
      *(const ::trigger::TriggerEvent::TriggerFilterObject*)arg[1]);
  else ::new(mem) ::std::vector<trigger::TriggerEvent::TriggerFilterObject>(*(::std::size_t*)arg[0],
      *(const ::trigger::TriggerEvent::TriggerFilterObject*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<trigger::TriggerEvent::TriggerFilterObject>(*(::std::size_t*)arg[0],
      *(const ::trigger::TriggerEvent::TriggerFilterObject*)arg[1],
      *(const ::std::allocator<trigger::TriggerEvent::TriggerFilterObject>*)arg[2]);
  else ::new(mem) ::std::vector<trigger::TriggerEvent::TriggerFilterObject>(*(::std::size_t*)arg[0],
      *(const ::trigger::TriggerEvent::TriggerFilterObject*)arg[1],
      *(const ::std::allocator<trigger::TriggerEvent::TriggerFilterObject>*)arg[2]);
  }
}

static void constructor_11034( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<trigger::TriggerEvent::TriggerFilterObject>(*(const ::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)arg[0]);
  else ::new(mem) ::std::vector<trigger::TriggerEvent::TriggerFilterObject>(*(const ::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)arg[0]);
}

static void destructor_11035(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->::std::vector<trigger::TriggerEvent::TriggerFilterObject>::~vector)();
}
static  void operator_11036( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->operator=)(*(const ::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)arg[0]);
  else   (((::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->operator=)(*(const ::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)arg[0]);
}

static  void method_11037( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::trigger::TriggerEvent::TriggerFilterObject*)arg[1]);
}

static  void method_11038( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<trigger::TriggerEvent::TriggerFilterObject*,std::vector<trigger::TriggerEvent::TriggerFilterObject> >)((((::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->begin)());
  else   (((::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->begin)();
}

static  void method_11039( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const trigger::TriggerEvent::TriggerFilterObject*,std::vector<trigger::TriggerEvent::TriggerFilterObject> >)((((const ::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->begin)());
  else   (((const ::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->begin)();
}

static  void method_11040( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<trigger::TriggerEvent::TriggerFilterObject*,std::vector<trigger::TriggerEvent::TriggerFilterObject> >)((((::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->end)());
  else   (((::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->end)();
}

static  void method_11041( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const trigger::TriggerEvent::TriggerFilterObject*,std::vector<trigger::TriggerEvent::TriggerFilterObject> >)((((const ::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->end)());
  else   (((const ::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->end)();
}

static  void method_11046( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->size)());
  else   (((const ::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->size)();
}

static  void method_11047( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->max_size)());
  else   (((const ::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->max_size)();
}

static  void method_11048( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::trigger::TriggerEvent::TriggerFilterObject*)arg[1]);
  }
}

static  void method_11049( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->capacity)());
  else   (((const ::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->capacity)();
}

static  void method_11050( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->empty)());
  else   (((const ::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->empty)();
}

static  void method_11051( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_11052( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_11053( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_11055( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_11056( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_11057( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->front)();
  else   (((::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->front)();
}

static  void method_11058( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->front)();
  else   (((const ::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->front)();
}

static  void method_11059( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->back)();
  else   (((::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->back)();
}

static  void method_11060( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->back)();
  else   (((const ::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->back)();
}

static  void method_11061( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->data)());
  else   (((::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->data)();
}

static  void method_11062( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->data)());
  else   (((const ::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->data)();
}

static  void method_11063( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->push_back)(*(const ::trigger::TriggerEvent::TriggerFilterObject*)arg[0]);
}

static  void method_11064( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->pop_back)();
}

static  void method_11065( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<trigger::TriggerEvent::TriggerFilterObject*,std::vector<trigger::TriggerEvent::TriggerFilterObject> >)((((::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<trigger::TriggerEvent::TriggerFilterObject*,std::vector<trigger::TriggerEvent::TriggerFilterObject> >*)arg[0],
    *(const ::trigger::TriggerEvent::TriggerFilterObject*)arg[1]));
  else   (((::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<trigger::TriggerEvent::TriggerFilterObject*,std::vector<trigger::TriggerEvent::TriggerFilterObject> >*)arg[0],
    *(const ::trigger::TriggerEvent::TriggerFilterObject*)arg[1]);
}

static  void method_11066( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<trigger::TriggerEvent::TriggerFilterObject*,std::vector<trigger::TriggerEvent::TriggerFilterObject> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::trigger::TriggerEvent::TriggerFilterObject*)arg[2]);
}

static  void method_11067( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<trigger::TriggerEvent::TriggerFilterObject*,std::vector<trigger::TriggerEvent::TriggerFilterObject> >)((((::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<trigger::TriggerEvent::TriggerFilterObject*,std::vector<trigger::TriggerEvent::TriggerFilterObject> >*)arg[0]));
  else   (((::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<trigger::TriggerEvent::TriggerFilterObject*,std::vector<trigger::TriggerEvent::TriggerFilterObject> >*)arg[0]);
}

static  void method_11068( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<trigger::TriggerEvent::TriggerFilterObject*,std::vector<trigger::TriggerEvent::TriggerFilterObject> >)((((::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<trigger::TriggerEvent::TriggerFilterObject*,std::vector<trigger::TriggerEvent::TriggerFilterObject> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<trigger::TriggerEvent::TriggerFilterObject*,std::vector<trigger::TriggerEvent::TriggerFilterObject> >*)arg[1]));
  else   (((::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<trigger::TriggerEvent::TriggerFilterObject*,std::vector<trigger::TriggerEvent::TriggerFilterObject> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<trigger::TriggerEvent::TriggerFilterObject*,std::vector<trigger::TriggerEvent::TriggerFilterObject> >*)arg[1]);
}

static  void method_11069( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->swap)(*(::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)arg[0]);
}

static  void method_11070( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<trigger::TriggerEvent::TriggerFilterObject>*)o)->clear)();
}

static void method_newdel_2703( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<trigger::TriggerEvent::TriggerFilterObject> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<trigger::TriggerEvent::TriggerFilterObject> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<trigger::TriggerEvent::TriggerFilterObject> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<trigger::TriggerEvent::TriggerFilterObject> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<trigger::TriggerEvent::TriggerFilterObject> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x23( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<trigger::TriggerEvent::TriggerFilterObject,std::allocator<trigger::TriggerEvent::TriggerFilterObject> >")), ::Reflex::BaseOffset< ::std::vector<trigger::TriggerEvent::TriggerFilterObject>,::std::_Vector_base<trigger::TriggerEvent::TriggerFilterObject,std::allocator<trigger::TriggerEvent::TriggerFilterObject> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x24( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<trigger::TriggerEvent::TriggerFilterObject> >::Generate();
  else ::Reflex::Proxy< ::std::vector<trigger::TriggerEvent::TriggerFilterObject> >::Generate();
}

//------Dictionary for class vector<trigger::TriggerEvent::TriggerFilterObject,std::allocator<trigger::TriggerEvent::TriggerFilterObject> > -------------------------------
void __std__vector_trigger__TriggerEvent__TriggerFilterObject__db_datamem(Reflex::Class*);
void __std__vector_trigger__TriggerEvent__TriggerFilterObject__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_trigger__TriggerEvent__TriggerFilterObject__datamem_bld(&__std__vector_trigger__TriggerEvent__TriggerFilterObject__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_trigger__TriggerEvent__TriggerFilterObject__funcmem_bld(&__std__vector_trigger__TriggerEvent__TriggerFilterObject__db_funcmem);
void __std__vector_trigger__TriggerEvent__TriggerFilterObject__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<trigger::TriggerEvent::TriggerFilterObject>"), typeid(::std::vector<trigger::TriggerEvent::TriggerFilterObject>), sizeof(::std::vector<trigger::TriggerEvent::TriggerFilterObject>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2136, ::Reflex::BaseOffset< ::std::vector<trigger::TriggerEvent::TriggerFilterObject>, ::std::_Vector_base<trigger::TriggerEvent::TriggerFilterObject,std::allocator<trigger::TriggerEvent::TriggerFilterObject> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_11011, Reflex::Literal("std::vector<trigger::TriggerEvent::TriggerFilterObject>::_Alloc_value_type"))
  .AddTypedef(type_2136, Reflex::Literal("std::vector<trigger::TriggerEvent::TriggerFilterObject>::_Base"))
  .AddTypedef(type_3029, Reflex::Literal("std::vector<trigger::TriggerEvent::TriggerFilterObject>::_Tp_alloc_type"))
  .AddTypedef(type_11011, Reflex::Literal("std::vector<trigger::TriggerEvent::TriggerFilterObject>::value_type"))
  .AddTypedef(type_11016, Reflex::Literal("std::vector<trigger::TriggerEvent::TriggerFilterObject>::pointer"))
  .AddTypedef(type_11018, Reflex::Literal("std::vector<trigger::TriggerEvent::TriggerFilterObject>::const_pointer"))
  .AddTypedef(type_11020, Reflex::Literal("std::vector<trigger::TriggerEvent::TriggerFilterObject>::reference"))
  .AddTypedef(type_11022, Reflex::Literal("std::vector<trigger::TriggerEvent::TriggerFilterObject>::const_reference"))
  .AddTypedef(type_5697, Reflex::Literal("std::vector<trigger::TriggerEvent::TriggerFilterObject>::iterator"))
  .AddTypedef(type_5698, Reflex::Literal("std::vector<trigger::TriggerEvent::TriggerFilterObject>::const_iterator"))
  .AddTypedef(type_3230, Reflex::Literal("std::vector<trigger::TriggerEvent::TriggerFilterObject>::const_reverse_iterator"))
  .AddTypedef(type_3231, Reflex::Literal("std::vector<trigger::TriggerEvent::TriggerFilterObject>::reverse_iterator"))
  .AddTypedef(type_3004, Reflex::Literal("std::vector<trigger::TriggerEvent::TriggerFilterObject>::size_type"))
  .AddTypedef(type_2891, Reflex::Literal("std::vector<trigger::TriggerEvent::TriggerFilterObject>::difference_type"))
  .AddTypedef(type_3029, Reflex::Literal("std::vector<trigger::TriggerEvent::TriggerFilterObject>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_11031, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28923), Reflex::Literal("vector"), constructor_11032, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3004, type_11022, type_28923), Reflex::Literal("vector"), constructor_11033, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30277), Reflex::Literal("vector"), constructor_11034, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_11035, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2703, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x23, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x24, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_trigger__TriggerEvent__TriggerFilterObject__funcmem_bld);
}

//------Delayed data member builder for class vector<trigger::TriggerEvent::TriggerFilterObject,std::allocator<trigger::TriggerEvent::TriggerFilterObject> > -------------------
void __std__vector_trigger__TriggerEvent__TriggerFilterObject__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<trigger::TriggerEvent::TriggerFilterObject,std::allocator<trigger::TriggerEvent::TriggerFilterObject> > -------------------
void __std__vector_trigger__TriggerEvent__TriggerFilterObject__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30278, type_30277), Reflex::Literal("operator="), operator_11036, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3004, type_11022), Reflex::Literal("assign"), method_11037, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5697), Reflex::Literal("begin"), method_11038, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5698), Reflex::Literal("begin"), method_11039, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5697), Reflex::Literal("end"), method_11040, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5698), Reflex::Literal("end"), method_11041, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3004), Reflex::Literal("size"), method_11046, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3004), Reflex::Literal("max_size"), method_11047, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3004, type_11011), Reflex::Literal("resize"), method_11048, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3004), Reflex::Literal("capacity"), method_11049, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1374), Reflex::Literal("empty"), method_11050, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3004), Reflex::Literal("reserve"), method_11051, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11020, type_3004), Reflex::Literal("operator[]"), operator_11052, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11022, type_3004), Reflex::Literal("operator[]"), operator_11053, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11020, type_3004), Reflex::Literal("at"), method_11055, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11022, type_3004), Reflex::Literal("at"), method_11056, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11020), Reflex::Literal("front"), method_11057, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11022), Reflex::Literal("front"), method_11058, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11020), Reflex::Literal("back"), method_11059, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11022), Reflex::Literal("back"), method_11060, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11016), Reflex::Literal("data"), method_11061, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_11018), Reflex::Literal("data"), method_11062, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_11022), Reflex::Literal("push_back"), method_11063, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166), Reflex::Literal("pop_back"), method_11064, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5697, type_5697, type_11022), Reflex::Literal("insert"), method_11065, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_5697, type_3004, type_11022), Reflex::Literal("insert"), method_11066, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5697, type_5697), Reflex::Literal("erase"), method_11067, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5697, type_5697, type_5697), Reflex::Literal("erase"), method_11068, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_30278), Reflex::Literal("swap"), method_11069, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166), Reflex::Literal("clear"), method_11070, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<edm::Ref<std::vector<reco::PFTau, std::allocator<reco::PFTau> >, reco::PFTau, edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau, std::allocator<reco::PFTau> >, reco::PFTau> >,std::allocator<edm::Ref<std::vector<reco::PFTau, std::allocator<reco::PFTau> >, reco::PFTau, edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau, std::allocator<reco::PFTau> >, reco::PFTau> > > > -------------------------------
static void constructor_11279( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >();
  else ::new(mem) ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >();
}

static void constructor_11280( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >(*(const ::std::allocator<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)arg[0]);
  else ::new(mem) ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >(*(const ::std::allocator<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)arg[0]);
}

static void constructor_11281( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >(*(::std::size_t*)arg[0],
      *(const ::edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> >*)arg[1]);
  else ::new(mem) ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >(*(::std::size_t*)arg[0],
      *(const ::edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> >*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >(*(::std::size_t*)arg[0],
      *(const ::edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> >*)arg[1],
      *(const ::std::allocator<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)arg[2]);
  else ::new(mem) ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >(*(::std::size_t*)arg[0],
      *(const ::edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> >*)arg[1],
      *(const ::std::allocator<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)arg[2]);
  }
}

static void constructor_11282( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >(*(const ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)arg[0]);
  else ::new(mem) ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >(*(const ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)arg[0]);
}

static void destructor_11283(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >::~vector)();
}
static  void operator_11284( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->operator=)(*(const ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)arg[0]);
  else   (((::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->operator=)(*(const ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)arg[0]);
}

static  void method_11285( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> >*)arg[1]);
}

static  void method_11286( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> >*,std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > > >)((((::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->begin)());
  else   (((::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->begin)();
}

static  void method_11287( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> >*,std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > > >)((((const ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->begin)());
  else   (((const ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->begin)();
}

static  void method_11288( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> >*,std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > > >)((((::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->end)());
  else   (((::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->end)();
}

static  void method_11289( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> >*,std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > > >)((((const ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->end)());
  else   (((const ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->end)();
}

static  void method_11294( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->size)());
  else   (((const ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->size)();
}

static  void method_11295( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->max_size)());
  else   (((const ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->max_size)();
}

static  void method_11296( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> >*)arg[1]);
  }
}

static  void method_11297( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->capacity)());
  else   (((const ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->capacity)();
}

static  void method_11298( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->empty)());
  else   (((const ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->empty)();
}

static  void method_11299( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_11300( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_11301( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_11303( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_11304( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_11305( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->front)();
  else   (((::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->front)();
}

static  void method_11306( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->front)();
  else   (((const ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->front)();
}

static  void method_11307( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->back)();
  else   (((::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->back)();
}

static  void method_11308( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->back)();
  else   (((const ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->back)();
}

static  void method_11309( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->data)());
  else   (((::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->data)();
}

static  void method_11310( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->data)());
  else   (((const ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->data)();
}

static  void method_11311( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->push_back)(*(const ::edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> >*)arg[0]);
}

static  void method_11312( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->pop_back)();
}

static  void method_11313( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> >*,std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > > >)((((::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> >*,std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > > >*)arg[0],
    *(const ::edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> >*)arg[1]));
  else   (((::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> >*,std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > > >*)arg[0],
    *(const ::edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> >*)arg[1]);
}

static  void method_11314( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> >*,std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> >*)arg[2]);
}

static  void method_11315( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> >*,std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > > >)((((::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> >*,std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > > >*)arg[0]));
  else   (((::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> >*,std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > > >*)arg[0]);
}

static  void method_11316( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> >*,std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > > >)((((::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> >*,std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> >*,std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > > >*)arg[1]));
  else   (((::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> >*,std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> >*,std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > > >*)arg[1]);
}

static  void method_11317( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->swap)(*(::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)arg[0]);
}

static  void method_11318( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >*)o)->clear)();
}

static void method_newdel_2707( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x26( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> >,std::allocator<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > > >")), ::Reflex::BaseOffset< ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >,::std::_Vector_base<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> >,std::allocator<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x27( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > > >::Generate();
  else ::Reflex::Proxy< ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > > >::Generate();
}

//------Dictionary for class vector<edm::Ref<std::vector<reco::PFTau, std::allocator<reco::PFTau> >, reco::PFTau, edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau, std::allocator<reco::PFTau> >, reco::PFTau> >,std::allocator<edm::Ref<std::vector<reco::PFTau, std::allocator<reco::PFTau> >, reco::PFTau, edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau, std::allocator<reco::PFTau> >, reco::PFTau> > > > -------------------------------
void __std__vector_edm__Ref_std__vector_reco__PFTau__reco__PFTau_edm__refhelper__FindUsingAdvance_std__vector_reco__PFTau__reco__PFTau_s_s__db_datamem(Reflex::Class*);
void __std__vector_edm__Ref_std__vector_reco__PFTau__reco__PFTau_edm__refhelper__FindUsingAdvance_std__vector_reco__PFTau__reco__PFTau_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_edm__Ref_std__vector_reco__PFTau__reco__PFTau_edm__refhelper__FindUsingAdvance_std__vector_reco__PFTau__reco__PFTau_s_s__datamem_bld(&__std__vector_edm__Ref_std__vector_reco__PFTau__reco__PFTau_edm__refhelper__FindUsingAdvance_std__vector_reco__PFTau__reco__PFTau_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_edm__Ref_std__vector_reco__PFTau__reco__PFTau_edm__refhelper__FindUsingAdvance_std__vector_reco__PFTau__reco__PFTau_s_s__funcmem_bld(&__std__vector_edm__Ref_std__vector_reco__PFTau__reco__PFTau_edm__refhelper__FindUsingAdvance_std__vector_reco__PFTau__reco__PFTau_s_s__db_funcmem);
void __std__vector_edm__Ref_std__vector_reco__PFTau__reco__PFTau_edm__refhelper__FindUsingAdvance_std__vector_reco__PFTau__reco__PFTau_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >"), typeid(::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >), sizeof(::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2138, ::Reflex::BaseOffset< ::std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >, ::std::_Vector_base<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> >,std::allocator<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_4590, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >::_Alloc_value_type"))
  .AddTypedef(type_2138, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >::_Base"))
  .AddTypedef(type_3040, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >::_Tp_alloc_type"))
  .AddTypedef(type_4590, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >::value_type"))
  .AddTypedef(type_7462, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >::pointer"))
  .AddTypedef(type_7451, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >::const_pointer"))
  .AddTypedef(type_7464, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >::reference"))
  .AddTypedef(type_7453, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >::const_reference"))
  .AddTypedef(type_5701, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >::iterator"))
  .AddTypedef(type_5702, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >::const_iterator"))
  .AddTypedef(type_3238, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >::const_reverse_iterator"))
  .AddTypedef(type_3239, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >::reverse_iterator"))
  .AddTypedef(type_3004, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >::size_type"))
  .AddTypedef(type_2891, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >::difference_type"))
  .AddTypedef(type_3040, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_11279, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28947), Reflex::Literal("vector"), constructor_11280, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3004, type_7453, type_28947), Reflex::Literal("vector"), constructor_11281, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30285), Reflex::Literal("vector"), constructor_11282, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_11283, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2707, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x26, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x27, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_edm__Ref_std__vector_reco__PFTau__reco__PFTau_edm__refhelper__FindUsingAdvance_std__vector_reco__PFTau__reco__PFTau_s_s__funcmem_bld);
}

//------Delayed data member builder for class vector<edm::Ref<std::vector<reco::PFTau, std::allocator<reco::PFTau> >, reco::PFTau, edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau, std::allocator<reco::PFTau> >, reco::PFTau> >,std::allocator<edm::Ref<std::vector<reco::PFTau, std::allocator<reco::PFTau> >, reco::PFTau, edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau, std::allocator<reco::PFTau> >, reco::PFTau> > > > -------------------
void __std__vector_edm__Ref_std__vector_reco__PFTau__reco__PFTau_edm__refhelper__FindUsingAdvance_std__vector_reco__PFTau__reco__PFTau_s_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<edm::Ref<std::vector<reco::PFTau, std::allocator<reco::PFTau> >, reco::PFTau, edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau, std::allocator<reco::PFTau> >, reco::PFTau> >,std::allocator<edm::Ref<std::vector<reco::PFTau, std::allocator<reco::PFTau> >, reco::PFTau, edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau, std::allocator<reco::PFTau> >, reco::PFTau> > > > -------------------
void __std__vector_edm__Ref_std__vector_reco__PFTau__reco__PFTau_edm__refhelper__FindUsingAdvance_std__vector_reco__PFTau__reco__PFTau_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14624, type_30285), Reflex::Literal("operator="), operator_11284, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3004, type_7453), Reflex::Literal("assign"), method_11285, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5701), Reflex::Literal("begin"), method_11286, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5702), Reflex::Literal("begin"), method_11287, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5701), Reflex::Literal("end"), method_11288, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5702), Reflex::Literal("end"), method_11289, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3004), Reflex::Literal("size"), method_11294, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3004), Reflex::Literal("max_size"), method_11295, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3004, type_4590), Reflex::Literal("resize"), method_11296, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3004), Reflex::Literal("capacity"), method_11297, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1374), Reflex::Literal("empty"), method_11298, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3004), Reflex::Literal("reserve"), method_11299, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7464, type_3004), Reflex::Literal("operator[]"), operator_11300, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7453, type_3004), Reflex::Literal("operator[]"), operator_11301, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7464, type_3004), Reflex::Literal("at"), method_11303, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7453, type_3004), Reflex::Literal("at"), method_11304, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7464), Reflex::Literal("front"), method_11305, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7453), Reflex::Literal("front"), method_11306, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7464), Reflex::Literal("back"), method_11307, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7453), Reflex::Literal("back"), method_11308, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7462), Reflex::Literal("data"), method_11309, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7451), Reflex::Literal("data"), method_11310, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_7453), Reflex::Literal("push_back"), method_11311, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166), Reflex::Literal("pop_back"), method_11312, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5701, type_5701, type_7453), Reflex::Literal("insert"), method_11313, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_5701, type_3004, type_7453), Reflex::Literal("insert"), method_11314, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5701, type_5701), Reflex::Literal("erase"), method_11315, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5701, type_5701, type_5701), Reflex::Literal("erase"), method_11316, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_14624), Reflex::Literal("swap"), method_11317, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166), Reflex::Literal("clear"), method_11318, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<edm::Ref<std::vector<reco::RecoChargedCandidate, std::allocator<reco::RecoChargedCandidate> >, reco::RecoChargedCandidate, edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate, std::allocator<reco::RecoChargedCandidate> >, reco::RecoChargedCandidate> >,std::allocator<edm::Ref<std::vector<reco::RecoChargedCandidate, std::allocator<reco::RecoChargedCandidate> >, reco::RecoChargedCandidate, edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate, std::allocator<reco::RecoChargedCandidate> >, reco::RecoChargedCandidate> > > > -------------------------------
static void constructor_12661( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >();
  else ::new(mem) ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >();
}

static void constructor_12662( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >(*(const ::std::allocator<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)arg[0]);
  else ::new(mem) ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >(*(const ::std::allocator<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)arg[0]);
}

static void constructor_12663( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >(*(::std::size_t*)arg[0],
      *(const ::edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> >*)arg[1]);
  else ::new(mem) ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >(*(::std::size_t*)arg[0],
      *(const ::edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> >*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >(*(::std::size_t*)arg[0],
      *(const ::edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> >*)arg[1],
      *(const ::std::allocator<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)arg[2]);
  else ::new(mem) ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >(*(::std::size_t*)arg[0],
      *(const ::edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> >*)arg[1],
      *(const ::std::allocator<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)arg[2]);
  }
}

static void constructor_12664( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >(*(const ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)arg[0]);
  else ::new(mem) ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >(*(const ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)arg[0]);
}

static void destructor_12665(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >::~vector)();
}
static  void operator_12666( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->operator=)(*(const ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)arg[0]);
  else   (((::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->operator=)(*(const ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)arg[0]);
}

static  void method_12667( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> >*)arg[1]);
}

static  void method_12668( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> >*,std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > > >)((((::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->begin)());
  else   (((::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->begin)();
}

static  void method_12669( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> >*,std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > > >)((((const ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->begin)());
  else   (((const ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->begin)();
}

static  void method_12670( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> >*,std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > > >)((((::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->end)());
  else   (((::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->end)();
}

static  void method_12671( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> >*,std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > > >)((((const ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->end)());
  else   (((const ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->end)();
}

static  void method_12676( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->size)());
  else   (((const ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->size)();
}

static  void method_12677( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->max_size)());
  else   (((const ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->max_size)();
}

static  void method_12678( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> >*)arg[1]);
  }
}

static  void method_12679( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->capacity)());
  else   (((const ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->capacity)();
}

static  void method_12680( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->empty)());
  else   (((const ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->empty)();
}

static  void method_12681( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_12682( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_12683( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_12685( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_12686( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_12687( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->front)();
  else   (((::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->front)();
}

static  void method_12688( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->front)();
  else   (((const ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->front)();
}

static  void method_12689( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->back)();
  else   (((::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->back)();
}

static  void method_12690( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->back)();
  else   (((const ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->back)();
}

static  void method_12691( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->data)());
  else   (((::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->data)();
}

static  void method_12692( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->data)());
  else   (((const ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->data)();
}

static  void method_12693( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->push_back)(*(const ::edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> >*)arg[0]);
}

static  void method_12694( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->pop_back)();
}

static  void method_12695( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> >*,std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > > >)((((::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> >*,std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > > >*)arg[0],
    *(const ::edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> >*)arg[1]));
  else   (((::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> >*,std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > > >*)arg[0],
    *(const ::edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> >*)arg[1]);
}

static  void method_12696( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> >*,std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> >*)arg[2]);
}

static  void method_12697( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> >*,std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > > >)((((::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> >*,std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > > >*)arg[0]));
  else   (((::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> >*,std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > > >*)arg[0]);
}

static  void method_12698( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> >*,std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > > >)((((::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> >*,std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> >*,std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > > >*)arg[1]));
  else   (((::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> >*,std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> >*,std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > > >*)arg[1]);
}

static  void method_12699( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->swap)(*(::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)arg[0]);
}

static  void method_12700( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >*)o)->clear)();
}

static void method_newdel_2729( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x29( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> >,std::allocator<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > > >")), ::Reflex::BaseOffset< ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >,::std::_Vector_base<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> >,std::allocator<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x30( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > > >::Generate();
  else ::Reflex::Proxy< ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > > >::Generate();
}

//------Dictionary for class vector<edm::Ref<std::vector<reco::RecoChargedCandidate, std::allocator<reco::RecoChargedCandidate> >, reco::RecoChargedCandidate, edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate, std::allocator<reco::RecoChargedCandidate> >, reco::RecoChargedCandidate> >,std::allocator<edm::Ref<std::vector<reco::RecoChargedCandidate, std::allocator<reco::RecoChargedCandidate> >, reco::RecoChargedCandidate, edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate, std::allocator<reco::RecoChargedCandidate> >, reco::RecoChargedCandidate> > > > -------------------------------
void __std__vector_edm__Ref_std__vector_reco__RecoChargedCandidate__reco__RecoChargedCandidate_edm__refhelper__FindUsingAdvance_std__vector_reco__RecoChargedCandidate__reco__RecoChargedCandidate_s_s__db_datamem(Reflex::Class*);
void __std__vector_edm__Ref_std__vector_reco__RecoChargedCandidate__reco__RecoChargedCandidate_edm__refhelper__FindUsingAdvance_std__vector_reco__RecoChargedCandidate__reco__RecoChargedCandidate_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_edm__Ref_std__vector_reco__RecoChargedCandidate__reco__RecoChargedCandidate_edm__refhelper__FindUsingAdvance_std__vector_reco__RecoChargedCandidate__reco__RecoChargedCandidate_s_s__datamem_bld(&__std__vector_edm__Ref_std__vector_reco__RecoChargedCandidate__reco__RecoChargedCandidate_edm__refhelper__FindUsingAdvance_std__vector_reco__RecoChargedCandidate__reco__RecoChargedCandidate_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_edm__Ref_std__vector_reco__RecoChargedCandidate__reco__RecoChargedCandidate_edm__refhelper__FindUsingAdvance_std__vector_reco__RecoChargedCandidate__reco__RecoChargedCandidate_s_s__funcmem_bld(&__std__vector_edm__Ref_std__vector_reco__RecoChargedCandidate__reco__RecoChargedCandidate_edm__refhelper__FindUsingAdvance_std__vector_reco__RecoChargedCandidate__reco__RecoChargedCandidate_s_s__db_funcmem);
void __std__vector_edm__Ref_std__vector_reco__RecoChargedCandidate__reco__RecoChargedCandidate_edm__refhelper__FindUsingAdvance_std__vector_reco__RecoChargedCandidate__reco__RecoChargedCandidate_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >"), typeid(::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >), sizeof(::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2150, ::Reflex::BaseOffset< ::std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >, ::std::_Vector_base<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> >,std::allocator<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_4592, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >::_Alloc_value_type"))
  .AddTypedef(type_2150, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >::_Base"))
  .AddTypedef(type_3055, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >::_Tp_alloc_type"))
  .AddTypedef(type_4592, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >::value_type"))
  .AddTypedef(type_7726, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >::pointer"))
  .AddTypedef(type_7715, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >::const_pointer"))
  .AddTypedef(type_7728, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >::reference"))
  .AddTypedef(type_7717, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >::const_reference"))
  .AddTypedef(type_5726, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >::iterator"))
  .AddTypedef(type_5727, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >::const_iterator"))
  .AddTypedef(type_3262, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >::const_reverse_iterator"))
  .AddTypedef(type_3263, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >::reverse_iterator"))
  .AddTypedef(type_3004, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >::size_type"))
  .AddTypedef(type_2891, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >::difference_type"))
  .AddTypedef(type_3055, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_12661, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29091), Reflex::Literal("vector"), constructor_12662, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3004, type_7717, type_29091), Reflex::Literal("vector"), constructor_12663, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30317), Reflex::Literal("vector"), constructor_12664, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_12665, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2729, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x29, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x30, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_edm__Ref_std__vector_reco__RecoChargedCandidate__reco__RecoChargedCandidate_edm__refhelper__FindUsingAdvance_std__vector_reco__RecoChargedCandidate__reco__RecoChargedCandidate_s_s__funcmem_bld);
}

//------Delayed data member builder for class vector<edm::Ref<std::vector<reco::RecoChargedCandidate, std::allocator<reco::RecoChargedCandidate> >, reco::RecoChargedCandidate, edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate, std::allocator<reco::RecoChargedCandidate> >, reco::RecoChargedCandidate> >,std::allocator<edm::Ref<std::vector<reco::RecoChargedCandidate, std::allocator<reco::RecoChargedCandidate> >, reco::RecoChargedCandidate, edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate, std::allocator<reco::RecoChargedCandidate> >, reco::RecoChargedCandidate> > > > -------------------
void __std__vector_edm__Ref_std__vector_reco__RecoChargedCandidate__reco__RecoChargedCandidate_edm__refhelper__FindUsingAdvance_std__vector_reco__RecoChargedCandidate__reco__RecoChargedCandidate_s_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<edm::Ref<std::vector<reco::RecoChargedCandidate, std::allocator<reco::RecoChargedCandidate> >, reco::RecoChargedCandidate, edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate, std::allocator<reco::RecoChargedCandidate> >, reco::RecoChargedCandidate> >,std::allocator<edm::Ref<std::vector<reco::RecoChargedCandidate, std::allocator<reco::RecoChargedCandidate> >, reco::RecoChargedCandidate, edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate, std::allocator<reco::RecoChargedCandidate> >, reco::RecoChargedCandidate> > > > -------------------
void __std__vector_edm__Ref_std__vector_reco__RecoChargedCandidate__reco__RecoChargedCandidate_edm__refhelper__FindUsingAdvance_std__vector_reco__RecoChargedCandidate__reco__RecoChargedCandidate_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14637, type_30317), Reflex::Literal("operator="), operator_12666, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3004, type_7717), Reflex::Literal("assign"), method_12667, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5726), Reflex::Literal("begin"), method_12668, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5727), Reflex::Literal("begin"), method_12669, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5726), Reflex::Literal("end"), method_12670, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5727), Reflex::Literal("end"), method_12671, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3004), Reflex::Literal("size"), method_12676, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3004), Reflex::Literal("max_size"), method_12677, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3004, type_4592), Reflex::Literal("resize"), method_12678, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3004), Reflex::Literal("capacity"), method_12679, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1374), Reflex::Literal("empty"), method_12680, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3004), Reflex::Literal("reserve"), method_12681, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7728, type_3004), Reflex::Literal("operator[]"), operator_12682, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7717, type_3004), Reflex::Literal("operator[]"), operator_12683, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7728, type_3004), Reflex::Literal("at"), method_12685, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7717, type_3004), Reflex::Literal("at"), method_12686, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7728), Reflex::Literal("front"), method_12687, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7717), Reflex::Literal("front"), method_12688, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7728), Reflex::Literal("back"), method_12689, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7717), Reflex::Literal("back"), method_12690, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7726), Reflex::Literal("data"), method_12691, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7715), Reflex::Literal("data"), method_12692, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_7717), Reflex::Literal("push_back"), method_12693, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166), Reflex::Literal("pop_back"), method_12694, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5726, type_5726, type_7717), Reflex::Literal("insert"), method_12695, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_5726, type_3004, type_7717), Reflex::Literal("insert"), method_12696, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5726, type_5726), Reflex::Literal("erase"), method_12697, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5726, type_5726, type_5726), Reflex::Literal("erase"), method_12698, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_14637), Reflex::Literal("swap"), method_12699, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166), Reflex::Literal("clear"), method_12700, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<edm::Ref<std::vector<reco::Electron, std::allocator<reco::Electron> >, reco::Electron, edm::refhelper::FindUsingAdvance<std::vector<reco::Electron, std::allocator<reco::Electron> >, reco::Electron> >,std::allocator<edm::Ref<std::vector<reco::Electron, std::allocator<reco::Electron> >, reco::Electron, edm::refhelper::FindUsingAdvance<std::vector<reco::Electron, std::allocator<reco::Electron> >, reco::Electron> > > > -------------------------------
static void constructor_12722( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >();
  else ::new(mem) ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >();
}

static void constructor_12723( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >(*(const ::std::allocator<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)arg[0]);
  else ::new(mem) ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >(*(const ::std::allocator<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)arg[0]);
}

static void constructor_12724( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >(*(::std::size_t*)arg[0],
      *(const ::edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> >*)arg[1]);
  else ::new(mem) ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >(*(::std::size_t*)arg[0],
      *(const ::edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> >*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >(*(::std::size_t*)arg[0],
      *(const ::edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> >*)arg[1],
      *(const ::std::allocator<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)arg[2]);
  else ::new(mem) ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >(*(::std::size_t*)arg[0],
      *(const ::edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> >*)arg[1],
      *(const ::std::allocator<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)arg[2]);
  }
}

static void constructor_12725( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >(*(const ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)arg[0]);
  else ::new(mem) ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >(*(const ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)arg[0]);
}

static void destructor_12726(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >::~vector)();
}
static  void operator_12727( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->operator=)(*(const ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)arg[0]);
  else   (((::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->operator=)(*(const ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)arg[0]);
}

static  void method_12728( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> >*)arg[1]);
}

static  void method_12729( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> >*,std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > > >)((((::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->begin)());
  else   (((::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->begin)();
}

static  void method_12730( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> >*,std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > > >)((((const ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->begin)());
  else   (((const ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->begin)();
}

static  void method_12731( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> >*,std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > > >)((((::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->end)());
  else   (((::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->end)();
}

static  void method_12732( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> >*,std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > > >)((((const ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->end)());
  else   (((const ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->end)();
}

static  void method_12737( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->size)());
  else   (((const ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->size)();
}

static  void method_12738( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->max_size)());
  else   (((const ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->max_size)();
}

static  void method_12739( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> >*)arg[1]);
  }
}

static  void method_12740( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->capacity)());
  else   (((const ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->capacity)();
}

static  void method_12741( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->empty)());
  else   (((const ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->empty)();
}

static  void method_12742( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_12743( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_12744( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_12746( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_12747( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_12748( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->front)();
  else   (((::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->front)();
}

static  void method_12749( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->front)();
  else   (((const ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->front)();
}

static  void method_12750( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->back)();
  else   (((::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->back)();
}

static  void method_12751( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->back)();
  else   (((const ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->back)();
}

static  void method_12752( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->data)());
  else   (((::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->data)();
}

static  void method_12753( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->data)());
  else   (((const ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->data)();
}

static  void method_12754( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->push_back)(*(const ::edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> >*)arg[0]);
}

static  void method_12755( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->pop_back)();
}

static  void method_12756( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> >*,std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > > >)((((::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> >*,std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > > >*)arg[0],
    *(const ::edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> >*)arg[1]));
  else   (((::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> >*,std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > > >*)arg[0],
    *(const ::edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> >*)arg[1]);
}

static  void method_12757( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> >*,std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> >*)arg[2]);
}

static  void method_12758( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> >*,std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > > >)((((::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> >*,std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > > >*)arg[0]));
  else   (((::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> >*,std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > > >*)arg[0]);
}

static  void method_12759( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> >*,std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > > >)((((::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> >*,std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> >*,std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > > >*)arg[1]));
  else   (((::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> >*,std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> >*,std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > > >*)arg[1]);
}

static  void method_12760( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->swap)(*(::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)arg[0]);
}

static  void method_12761( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >*)o)->clear)();
}

static void method_newdel_2730( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x32( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> >,std::allocator<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > > >")), ::Reflex::BaseOffset< ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >,::std::_Vector_base<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> >,std::allocator<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x33( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > > >::Generate();
  else ::Reflex::Proxy< ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > > >::Generate();
}

//------Dictionary for class vector<edm::Ref<std::vector<reco::Electron, std::allocator<reco::Electron> >, reco::Electron, edm::refhelper::FindUsingAdvance<std::vector<reco::Electron, std::allocator<reco::Electron> >, reco::Electron> >,std::allocator<edm::Ref<std::vector<reco::Electron, std::allocator<reco::Electron> >, reco::Electron, edm::refhelper::FindUsingAdvance<std::vector<reco::Electron, std::allocator<reco::Electron> >, reco::Electron> > > > -------------------------------
void __std__vector_edm__Ref_std__vector_reco__Electron__reco__Electron_edm__refhelper__FindUsingAdvance_std__vector_reco__Electron__reco__Electron_s_s__db_datamem(Reflex::Class*);
void __std__vector_edm__Ref_std__vector_reco__Electron__reco__Electron_edm__refhelper__FindUsingAdvance_std__vector_reco__Electron__reco__Electron_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_edm__Ref_std__vector_reco__Electron__reco__Electron_edm__refhelper__FindUsingAdvance_std__vector_reco__Electron__reco__Electron_s_s__datamem_bld(&__std__vector_edm__Ref_std__vector_reco__Electron__reco__Electron_edm__refhelper__FindUsingAdvance_std__vector_reco__Electron__reco__Electron_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_edm__Ref_std__vector_reco__Electron__reco__Electron_edm__refhelper__FindUsingAdvance_std__vector_reco__Electron__reco__Electron_s_s__funcmem_bld(&__std__vector_edm__Ref_std__vector_reco__Electron__reco__Electron_edm__refhelper__FindUsingAdvance_std__vector_reco__Electron__reco__Electron_s_s__db_funcmem);
void __std__vector_edm__Ref_std__vector_reco__Electron__reco__Electron_edm__refhelper__FindUsingAdvance_std__vector_reco__Electron__reco__Electron_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >"), typeid(::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >), sizeof(::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2151, ::Reflex::BaseOffset< ::std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >, ::std::_Vector_base<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> >,std::allocator<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_4593, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >::_Alloc_value_type"))
  .AddTypedef(type_2151, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >::_Base"))
  .AddTypedef(type_3057, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >::_Tp_alloc_type"))
  .AddTypedef(type_4593, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >::value_type"))
  .AddTypedef(type_7748, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >::pointer"))
  .AddTypedef(type_7737, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >::const_pointer"))
  .AddTypedef(type_7750, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >::reference"))
  .AddTypedef(type_7739, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >::const_reference"))
  .AddTypedef(type_5728, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >::iterator"))
  .AddTypedef(type_5729, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >::const_iterator"))
  .AddTypedef(type_3264, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >::const_reverse_iterator"))
  .AddTypedef(type_3265, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >::reverse_iterator"))
  .AddTypedef(type_3004, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >::size_type"))
  .AddTypedef(type_2891, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >::difference_type"))
  .AddTypedef(type_3057, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_12722, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29103), Reflex::Literal("vector"), constructor_12723, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3004, type_7739, type_29103), Reflex::Literal("vector"), constructor_12724, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30318), Reflex::Literal("vector"), constructor_12725, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_12726, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2730, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x32, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x33, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_edm__Ref_std__vector_reco__Electron__reco__Electron_edm__refhelper__FindUsingAdvance_std__vector_reco__Electron__reco__Electron_s_s__funcmem_bld);
}

//------Delayed data member builder for class vector<edm::Ref<std::vector<reco::Electron, std::allocator<reco::Electron> >, reco::Electron, edm::refhelper::FindUsingAdvance<std::vector<reco::Electron, std::allocator<reco::Electron> >, reco::Electron> >,std::allocator<edm::Ref<std::vector<reco::Electron, std::allocator<reco::Electron> >, reco::Electron, edm::refhelper::FindUsingAdvance<std::vector<reco::Electron, std::allocator<reco::Electron> >, reco::Electron> > > > -------------------
void __std__vector_edm__Ref_std__vector_reco__Electron__reco__Electron_edm__refhelper__FindUsingAdvance_std__vector_reco__Electron__reco__Electron_s_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<edm::Ref<std::vector<reco::Electron, std::allocator<reco::Electron> >, reco::Electron, edm::refhelper::FindUsingAdvance<std::vector<reco::Electron, std::allocator<reco::Electron> >, reco::Electron> >,std::allocator<edm::Ref<std::vector<reco::Electron, std::allocator<reco::Electron> >, reco::Electron, edm::refhelper::FindUsingAdvance<std::vector<reco::Electron, std::allocator<reco::Electron> >, reco::Electron> > > > -------------------
void __std__vector_edm__Ref_std__vector_reco__Electron__reco__Electron_edm__refhelper__FindUsingAdvance_std__vector_reco__Electron__reco__Electron_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14638, type_30318), Reflex::Literal("operator="), operator_12727, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3004, type_7739), Reflex::Literal("assign"), method_12728, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5728), Reflex::Literal("begin"), method_12729, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5729), Reflex::Literal("begin"), method_12730, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5728), Reflex::Literal("end"), method_12731, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5729), Reflex::Literal("end"), method_12732, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3004), Reflex::Literal("size"), method_12737, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3004), Reflex::Literal("max_size"), method_12738, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3004, type_4593), Reflex::Literal("resize"), method_12739, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3004), Reflex::Literal("capacity"), method_12740, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1374), Reflex::Literal("empty"), method_12741, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3004), Reflex::Literal("reserve"), method_12742, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7750, type_3004), Reflex::Literal("operator[]"), operator_12743, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7739, type_3004), Reflex::Literal("operator[]"), operator_12744, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7750, type_3004), Reflex::Literal("at"), method_12746, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7739, type_3004), Reflex::Literal("at"), method_12747, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7750), Reflex::Literal("front"), method_12748, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7739), Reflex::Literal("front"), method_12749, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7750), Reflex::Literal("back"), method_12750, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7739), Reflex::Literal("back"), method_12751, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7748), Reflex::Literal("data"), method_12752, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7737), Reflex::Literal("data"), method_12753, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_7739), Reflex::Literal("push_back"), method_12754, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166), Reflex::Literal("pop_back"), method_12755, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5728, type_5728, type_7739), Reflex::Literal("insert"), method_12756, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_5728, type_3004, type_7739), Reflex::Literal("insert"), method_12757, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5728, type_5728), Reflex::Literal("erase"), method_12758, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5728, type_5728, type_5728), Reflex::Literal("erase"), method_12759, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_14638), Reflex::Literal("swap"), method_12760, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166), Reflex::Literal("clear"), method_12761, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<edm::Ref<std::vector<reco::RecoEcalCandidate, std::allocator<reco::RecoEcalCandidate> >, reco::RecoEcalCandidate, edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate, std::allocator<reco::RecoEcalCandidate> >, reco::RecoEcalCandidate> >,std::allocator<edm::Ref<std::vector<reco::RecoEcalCandidate, std::allocator<reco::RecoEcalCandidate> >, reco::RecoEcalCandidate, edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate, std::allocator<reco::RecoEcalCandidate> >, reco::RecoEcalCandidate> > > > -------------------------------
static void constructor_12783( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >();
  else ::new(mem) ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >();
}

static void constructor_12784( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >(*(const ::std::allocator<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)arg[0]);
  else ::new(mem) ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >(*(const ::std::allocator<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)arg[0]);
}

static void constructor_12785( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >(*(::std::size_t*)arg[0],
      *(const ::edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> >*)arg[1]);
  else ::new(mem) ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >(*(::std::size_t*)arg[0],
      *(const ::edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> >*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >(*(::std::size_t*)arg[0],
      *(const ::edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> >*)arg[1],
      *(const ::std::allocator<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)arg[2]);
  else ::new(mem) ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >(*(::std::size_t*)arg[0],
      *(const ::edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> >*)arg[1],
      *(const ::std::allocator<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)arg[2]);
  }
}

static void constructor_12786( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >(*(const ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)arg[0]);
  else ::new(mem) ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >(*(const ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)arg[0]);
}

static void destructor_12787(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >::~vector)();
}
static  void operator_12788( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->operator=)(*(const ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)arg[0]);
  else   (((::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->operator=)(*(const ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)arg[0]);
}

static  void method_12789( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> >*)arg[1]);
}

static  void method_12790( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> >*,std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > > >)((((::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->begin)());
  else   (((::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->begin)();
}

static  void method_12791( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> >*,std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > > >)((((const ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->begin)());
  else   (((const ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->begin)();
}

static  void method_12792( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> >*,std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > > >)((((::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->end)());
  else   (((::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->end)();
}

static  void method_12793( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> >*,std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > > >)((((const ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->end)());
  else   (((const ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->end)();
}

static  void method_12798( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->size)());
  else   (((const ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->size)();
}

static  void method_12799( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->max_size)());
  else   (((const ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->max_size)();
}

static  void method_12800( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->resize)(*(::std::size_t*)arg[0],
      *(::edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> >*)arg[1]);
  }
}

static  void method_12801( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->capacity)());
  else   (((const ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->capacity)();
}

static  void method_12802( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->empty)());
  else   (((const ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->empty)();
}

static  void method_12803( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_12804( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_12805( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_12807( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_12808( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_12809( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->front)();
  else   (((::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->front)();
}

static  void method_12810( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->front)();
  else   (((const ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->front)();
}

static  void method_12811( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->back)();
  else   (((::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->back)();
}

static  void method_12812( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->back)();
  else   (((const ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->back)();
}

static  void method_12813( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->data)());
  else   (((::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->data)();
}

static  void method_12814( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->data)());
  else   (((const ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->data)();
}

static  void method_12815( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->push_back)(*(const ::edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> >*)arg[0]);
}

static  void method_12816( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->pop_back)();
}

static  void method_12817( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> >*,std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > > >)((((::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> >*,std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > > >*)arg[0],
    *(const ::edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> >*)arg[1]));
  else   (((::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> >*,std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > > >*)arg[0],
    *(const ::edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> >*)arg[1]);
}

static  void method_12818( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> >*,std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > > >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> >*)arg[2]);
}

static  void method_12819( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> >*,std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > > >)((((::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> >*,std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > > >*)arg[0]));
  else   (((::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> >*,std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > > >*)arg[0]);
}

static  void method_12820( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> >*,std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > > >)((((::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> >*,std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> >*,std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > > >*)arg[1]));
  else   (((::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> >*,std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > > >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> >*,std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > > >*)arg[1]);
}

static  void method_12821( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->swap)(*(::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)arg[0]);
}

static  void method_12822( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >*)o)->clear)();
}

static void method_newdel_2731( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x35( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> >,std::allocator<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > > >")), ::Reflex::BaseOffset< ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >,::std::_Vector_base<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> >,std::allocator<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > > > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x36( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > > >::Generate();
  else ::Reflex::Proxy< ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > > >::Generate();
}

//------Dictionary for class vector<edm::Ref<std::vector<reco::RecoEcalCandidate, std::allocator<reco::RecoEcalCandidate> >, reco::RecoEcalCandidate, edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate, std::allocator<reco::RecoEcalCandidate> >, reco::RecoEcalCandidate> >,std::allocator<edm::Ref<std::vector<reco::RecoEcalCandidate, std::allocator<reco::RecoEcalCandidate> >, reco::RecoEcalCandidate, edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate, std::allocator<reco::RecoEcalCandidate> >, reco::RecoEcalCandidate> > > > -------------------------------
void __std__vector_edm__Ref_std__vector_reco__RecoEcalCandidate__reco__RecoEcalCandidate_edm__refhelper__FindUsingAdvance_std__vector_reco__RecoEcalCandidate__reco__RecoEcalCandidate_s_s__db_datamem(Reflex::Class*);
void __std__vector_edm__Ref_std__vector_reco__RecoEcalCandidate__reco__RecoEcalCandidate_edm__refhelper__FindUsingAdvance_std__vector_reco__RecoEcalCandidate__reco__RecoEcalCandidate_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_edm__Ref_std__vector_reco__RecoEcalCandidate__reco__RecoEcalCandidate_edm__refhelper__FindUsingAdvance_std__vector_reco__RecoEcalCandidate__reco__RecoEcalCandidate_s_s__datamem_bld(&__std__vector_edm__Ref_std__vector_reco__RecoEcalCandidate__reco__RecoEcalCandidate_edm__refhelper__FindUsingAdvance_std__vector_reco__RecoEcalCandidate__reco__RecoEcalCandidate_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_edm__Ref_std__vector_reco__RecoEcalCandidate__reco__RecoEcalCandidate_edm__refhelper__FindUsingAdvance_std__vector_reco__RecoEcalCandidate__reco__RecoEcalCandidate_s_s__funcmem_bld(&__std__vector_edm__Ref_std__vector_reco__RecoEcalCandidate__reco__RecoEcalCandidate_edm__refhelper__FindUsingAdvance_std__vector_reco__RecoEcalCandidate__reco__RecoEcalCandidate_s_s__db_funcmem);
void __std__vector_edm__Ref_std__vector_reco__RecoEcalCandidate__reco__RecoEcalCandidate_edm__refhelper__FindUsingAdvance_std__vector_reco__RecoEcalCandidate__reco__RecoEcalCandidate_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >"), typeid(::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >), sizeof(::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2152, ::Reflex::BaseOffset< ::std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >, ::std::_Vector_base<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> >,std::allocator<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > > > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_4594, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >::_Alloc_value_type"))
  .AddTypedef(type_2152, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >::_Base"))
  .AddTypedef(type_3059, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >::_Tp_alloc_type"))
  .AddTypedef(type_4594, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >::value_type"))
  .AddTypedef(type_7770, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >::pointer"))
  .AddTypedef(type_7759, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >::const_pointer"))
  .AddTypedef(type_7772, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >::reference"))
  .AddTypedef(type_7761, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >::const_reference"))
  .AddTypedef(type_5730, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >::iterator"))
  .AddTypedef(type_5731, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >::const_iterator"))
  .AddTypedef(type_3266, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >::const_reverse_iterator"))
  .AddTypedef(type_3267, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >::reverse_iterator"))
  .AddTypedef(type_3004, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >::size_type"))
  .AddTypedef(type_2891, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >::difference_type"))
  .AddTypedef(type_3059, Reflex::Literal("std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > >::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_12783, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29115), Reflex::Literal("vector"), constructor_12784, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3004, type_7761, type_29115), Reflex::Literal("vector"), constructor_12785, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30319), Reflex::Literal("vector"), constructor_12786, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_12787, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2731, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x35, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x36, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_edm__Ref_std__vector_reco__RecoEcalCandidate__reco__RecoEcalCandidate_edm__refhelper__FindUsingAdvance_std__vector_reco__RecoEcalCandidate__reco__RecoEcalCandidate_s_s__funcmem_bld);
}

//------Delayed data member builder for class vector<edm::Ref<std::vector<reco::RecoEcalCandidate, std::allocator<reco::RecoEcalCandidate> >, reco::RecoEcalCandidate, edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate, std::allocator<reco::RecoEcalCandidate> >, reco::RecoEcalCandidate> >,std::allocator<edm::Ref<std::vector<reco::RecoEcalCandidate, std::allocator<reco::RecoEcalCandidate> >, reco::RecoEcalCandidate, edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate, std::allocator<reco::RecoEcalCandidate> >, reco::RecoEcalCandidate> > > > -------------------
void __std__vector_edm__Ref_std__vector_reco__RecoEcalCandidate__reco__RecoEcalCandidate_edm__refhelper__FindUsingAdvance_std__vector_reco__RecoEcalCandidate__reco__RecoEcalCandidate_s_s__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<edm::Ref<std::vector<reco::RecoEcalCandidate, std::allocator<reco::RecoEcalCandidate> >, reco::RecoEcalCandidate, edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate, std::allocator<reco::RecoEcalCandidate> >, reco::RecoEcalCandidate> >,std::allocator<edm::Ref<std::vector<reco::RecoEcalCandidate, std::allocator<reco::RecoEcalCandidate> >, reco::RecoEcalCandidate, edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate, std::allocator<reco::RecoEcalCandidate> >, reco::RecoEcalCandidate> > > > -------------------
void __std__vector_edm__Ref_std__vector_reco__RecoEcalCandidate__reco__RecoEcalCandidate_edm__refhelper__FindUsingAdvance_std__vector_reco__RecoEcalCandidate__reco__RecoEcalCandidate_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14639, type_30319), Reflex::Literal("operator="), operator_12788, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3004, type_7761), Reflex::Literal("assign"), method_12789, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5730), Reflex::Literal("begin"), method_12790, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5731), Reflex::Literal("begin"), method_12791, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5730), Reflex::Literal("end"), method_12792, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5731), Reflex::Literal("end"), method_12793, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3004), Reflex::Literal("size"), method_12798, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3004), Reflex::Literal("max_size"), method_12799, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3004, type_4594), Reflex::Literal("resize"), method_12800, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3004), Reflex::Literal("capacity"), method_12801, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1374), Reflex::Literal("empty"), method_12802, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3004), Reflex::Literal("reserve"), method_12803, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7772, type_3004), Reflex::Literal("operator[]"), operator_12804, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7761, type_3004), Reflex::Literal("operator[]"), operator_12805, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7772, type_3004), Reflex::Literal("at"), method_12807, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7761, type_3004), Reflex::Literal("at"), method_12808, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7772), Reflex::Literal("front"), method_12809, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7761), Reflex::Literal("front"), method_12810, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7772), Reflex::Literal("back"), method_12811, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7761), Reflex::Literal("back"), method_12812, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7770), Reflex::Literal("data"), method_12813, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7759), Reflex::Literal("data"), method_12814, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_7761), Reflex::Literal("push_back"), method_12815, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166), Reflex::Literal("pop_back"), method_12816, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5730, type_5730, type_7761), Reflex::Literal("insert"), method_12817, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_5730, type_3004, type_7761), Reflex::Literal("insert"), method_12818, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5730, type_5730), Reflex::Literal("erase"), method_12819, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5730, type_5730, type_5730), Reflex::Literal("erase"), method_12820, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_14639), Reflex::Literal("swap"), method_12821, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166), Reflex::Literal("clear"), method_12822, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class ModuleTime -------------------------------
static  void operator_22162( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::ModuleTime*)o)->operator=)(*(const ::edm::ModuleTime*)arg[0]);
  else   (((::edm::ModuleTime*)o)->operator=)(*(const ::edm::ModuleTime*)arg[0]);
}

static void constructor_22163( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::ModuleTime(*(const ::edm::ModuleTime*)arg[0]);
  else ::new(mem) ::edm::ModuleTime(*(const ::edm::ModuleTime*)arg[0]);
}

static void constructor_22164( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::ModuleTime();
  else ::new(mem) ::edm::ModuleTime();
}

static void constructor_22165( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::ModuleTime(*(::std::string*)arg[0],
      *(double*)arg[1]);
  else ::new(mem) ::edm::ModuleTime(*(::std::string*)arg[0],
      *(double*)arg[1]);
}

static void destructor_22166(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::ModuleTime*)o)->::edm::ModuleTime::~ModuleTime)();
}
static  void method_22167( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::edm::ModuleTime*)o)->name)());
  else   (((const ::edm::ModuleTime*)o)->name)();
}

static  void method_22168( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::edm::ModuleTime*)o)->time)());
  else   (((const ::edm::ModuleTime*)o)->time)();
}

static void method_newdel_4535( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::ModuleTime >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::ModuleTime >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::ModuleTime >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::ModuleTime >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::ModuleTime >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class ModuleTime -------------------------------
void __edm__ModuleTime_db_datamem(Reflex::Class*);
void __edm__ModuleTime_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__ModuleTime_datamem_bld(&__edm__ModuleTime_db_datamem);
Reflex::GenreflexMemberBuilder __edm__ModuleTime_funcmem_bld(&__edm__ModuleTime_db_funcmem);
void __edm__ModuleTime_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::ModuleTime"), typeid(::edm::ModuleTime), sizeof(::edm::ModuleTime), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14375, type_14377), Reflex::Literal("operator="), operator_22162, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_14377), Reflex::Literal("ModuleTime"), constructor_22163, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("ModuleTime"), constructor_22164, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2202, type_108), Reflex::Literal("ModuleTime"), constructor_22165, 0, "Name;Time", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ModuleTime"), destructor_22166, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4535, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__ModuleTime_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__ModuleTime_funcmem_bld);
}

//------Delayed data member builder for class ModuleTime -------------------
void __edm__ModuleTime_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2202, Reflex::Literal("name_"), OffsetOf(__shadow__::__edm__ModuleTime, name_), ::Reflex::PRIVATE)
  .AddDataMember(type_108, Reflex::Literal("time_"), OffsetOf(__shadow__::__edm__ModuleTime, time_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class ModuleTime -------------------
void __edm__ModuleTime_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2202), Reflex::Literal("name"), method_22167, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_108), Reflex::Literal("time"), method_22168, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class vector<edm::ModuleTime,std::allocator<edm::ModuleTime> > -------------------------------
static void constructor_14386( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::ModuleTime>();
  else ::new(mem) ::std::vector<edm::ModuleTime>();
}

static void constructor_14387( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::ModuleTime>(*(const ::std::allocator<edm::ModuleTime>*)arg[0]);
  else ::new(mem) ::std::vector<edm::ModuleTime>(*(const ::std::allocator<edm::ModuleTime>*)arg[0]);
}

static void constructor_14388( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::ModuleTime>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<edm::ModuleTime>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::ModuleTime>(*(::std::size_t*)arg[0],
      *(const ::edm::ModuleTime*)arg[1]);
  else ::new(mem) ::std::vector<edm::ModuleTime>(*(::std::size_t*)arg[0],
      *(const ::edm::ModuleTime*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::ModuleTime>(*(::std::size_t*)arg[0],
      *(const ::edm::ModuleTime*)arg[1],
      *(const ::std::allocator<edm::ModuleTime>*)arg[2]);
  else ::new(mem) ::std::vector<edm::ModuleTime>(*(::std::size_t*)arg[0],
      *(const ::edm::ModuleTime*)arg[1],
      *(const ::std::allocator<edm::ModuleTime>*)arg[2]);
  }
}

static void constructor_14389( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<edm::ModuleTime>(*(const ::std::vector<edm::ModuleTime>*)arg[0]);
  else ::new(mem) ::std::vector<edm::ModuleTime>(*(const ::std::vector<edm::ModuleTime>*)arg[0]);
}

static void destructor_14390(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<edm::ModuleTime>*)o)->::std::vector<edm::ModuleTime>::~vector)();
}
static  void operator_14391( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::ModuleTime>*)o)->operator=)(*(const ::std::vector<edm::ModuleTime>*)arg[0]);
  else   (((::std::vector<edm::ModuleTime>*)o)->operator=)(*(const ::std::vector<edm::ModuleTime>*)arg[0]);
}

static  void method_14392( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::ModuleTime>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::edm::ModuleTime*)arg[1]);
}

static  void method_14393( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::ModuleTime*,std::vector<edm::ModuleTime> >)((((::std::vector<edm::ModuleTime>*)o)->begin)());
  else   (((::std::vector<edm::ModuleTime>*)o)->begin)();
}

static  void method_14394( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::ModuleTime*,std::vector<edm::ModuleTime> >)((((const ::std::vector<edm::ModuleTime>*)o)->begin)());
  else   (((const ::std::vector<edm::ModuleTime>*)o)->begin)();
}

static  void method_14395( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::ModuleTime*,std::vector<edm::ModuleTime> >)((((::std::vector<edm::ModuleTime>*)o)->end)());
  else   (((::std::vector<edm::ModuleTime>*)o)->end)();
}

static  void method_14396( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const edm::ModuleTime*,std::vector<edm::ModuleTime> >)((((const ::std::vector<edm::ModuleTime>*)o)->end)());
  else   (((const ::std::vector<edm::ModuleTime>*)o)->end)();
}

static  void method_14401( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::ModuleTime>*)o)->size)());
  else   (((const ::std::vector<edm::ModuleTime>*)o)->size)();
}

static  void method_14402( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::ModuleTime>*)o)->max_size)());
  else   (((const ::std::vector<edm::ModuleTime>*)o)->max_size)();
}

static  void method_14403( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<edm::ModuleTime>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<edm::ModuleTime>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::edm::ModuleTime*)arg[1]);
  }
}

static  void method_14404( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<edm::ModuleTime>*)o)->capacity)());
  else   (((const ::std::vector<edm::ModuleTime>*)o)->capacity)();
}

static  void method_14405( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<edm::ModuleTime>*)o)->empty)());
  else   (((const ::std::vector<edm::ModuleTime>*)o)->empty)();
}

static  void method_14406( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::ModuleTime>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_14407( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::ModuleTime>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<edm::ModuleTime>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_14408( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::ModuleTime>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<edm::ModuleTime>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_14410( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::ModuleTime>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<edm::ModuleTime>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14411( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::ModuleTime>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<edm::ModuleTime>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_14412( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::ModuleTime>*)o)->front)();
  else   (((::std::vector<edm::ModuleTime>*)o)->front)();
}

static  void method_14413( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::ModuleTime>*)o)->front)();
  else   (((const ::std::vector<edm::ModuleTime>*)o)->front)();
}

static  void method_14414( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<edm::ModuleTime>*)o)->back)();
  else   (((::std::vector<edm::ModuleTime>*)o)->back)();
}

static  void method_14415( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<edm::ModuleTime>*)o)->back)();
  else   (((const ::std::vector<edm::ModuleTime>*)o)->back)();
}

static  void method_14416( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<edm::ModuleTime>*)o)->data)());
  else   (((::std::vector<edm::ModuleTime>*)o)->data)();
}

static  void method_14417( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<edm::ModuleTime>*)o)->data)());
  else   (((const ::std::vector<edm::ModuleTime>*)o)->data)();
}

static  void method_14418( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::ModuleTime>*)o)->push_back)(*(const ::edm::ModuleTime*)arg[0]);
}

static  void method_14419( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<edm::ModuleTime>*)o)->pop_back)();
}

static  void method_14420( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::ModuleTime*,std::vector<edm::ModuleTime> >)((((::std::vector<edm::ModuleTime>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::ModuleTime*,std::vector<edm::ModuleTime> >*)arg[0],
    *(const ::edm::ModuleTime*)arg[1]));
  else   (((::std::vector<edm::ModuleTime>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::ModuleTime*,std::vector<edm::ModuleTime> >*)arg[0],
    *(const ::edm::ModuleTime*)arg[1]);
}

static  void method_14421( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::ModuleTime>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<edm::ModuleTime*,std::vector<edm::ModuleTime> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::edm::ModuleTime*)arg[2]);
}

static  void method_14422( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::ModuleTime*,std::vector<edm::ModuleTime> >)((((::std::vector<edm::ModuleTime>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::ModuleTime*,std::vector<edm::ModuleTime> >*)arg[0]));
  else   (((::std::vector<edm::ModuleTime>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::ModuleTime*,std::vector<edm::ModuleTime> >*)arg[0]);
}

static  void method_14423( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<edm::ModuleTime*,std::vector<edm::ModuleTime> >)((((::std::vector<edm::ModuleTime>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::ModuleTime*,std::vector<edm::ModuleTime> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<edm::ModuleTime*,std::vector<edm::ModuleTime> >*)arg[1]));
  else   (((::std::vector<edm::ModuleTime>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<edm::ModuleTime*,std::vector<edm::ModuleTime> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<edm::ModuleTime*,std::vector<edm::ModuleTime> >*)arg[1]);
}

static  void method_14424( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<edm::ModuleTime>*)o)->swap)(*(::std::vector<edm::ModuleTime>*)arg[0]);
}

static  void method_14425( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<edm::ModuleTime>*)o)->clear)();
}

static void method_newdel_2768( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<edm::ModuleTime> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<edm::ModuleTime> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<edm::ModuleTime> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<edm::ModuleTime> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<edm::ModuleTime> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x39( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<edm::ModuleTime,std::allocator<edm::ModuleTime> >")), ::Reflex::BaseOffset< ::std::vector<edm::ModuleTime>,::std::_Vector_base<edm::ModuleTime,std::allocator<edm::ModuleTime> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x40( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<edm::ModuleTime> >::Generate();
  else ::Reflex::Proxy< ::std::vector<edm::ModuleTime> >::Generate();
}

//------Dictionary for class vector<edm::ModuleTime,std::allocator<edm::ModuleTime> > -------------------------------
void __std__vector_edm__ModuleTime__db_datamem(Reflex::Class*);
void __std__vector_edm__ModuleTime__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_edm__ModuleTime__datamem_bld(&__std__vector_edm__ModuleTime__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_edm__ModuleTime__funcmem_bld(&__std__vector_edm__ModuleTime__db_funcmem);
void __std__vector_edm__ModuleTime__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<edm::ModuleTime>"), typeid(::std::vector<edm::ModuleTime>), sizeof(::std::vector<edm::ModuleTime>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2193, ::Reflex::BaseOffset< ::std::vector<edm::ModuleTime>, ::std::_Vector_base<edm::ModuleTime,std::allocator<edm::ModuleTime> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_4535, Reflex::Literal("std::vector<edm::ModuleTime>::_Alloc_value_type"))
  .AddTypedef(type_2193, Reflex::Literal("std::vector<edm::ModuleTime>::_Base"))
  .AddTypedef(type_3108, Reflex::Literal("std::vector<edm::ModuleTime>::_Tp_alloc_type"))
  .AddTypedef(type_4535, Reflex::Literal("std::vector<edm::ModuleTime>::value_type"))
  .AddTypedef(type_14371, Reflex::Literal("std::vector<edm::ModuleTime>::pointer"))
  .AddTypedef(type_14373, Reflex::Literal("std::vector<edm::ModuleTime>::const_pointer"))
  .AddTypedef(type_14375, Reflex::Literal("std::vector<edm::ModuleTime>::reference"))
  .AddTypedef(type_14377, Reflex::Literal("std::vector<edm::ModuleTime>::const_reference"))
  .AddTypedef(type_5809, Reflex::Literal("std::vector<edm::ModuleTime>::iterator"))
  .AddTypedef(type_5810, Reflex::Literal("std::vector<edm::ModuleTime>::const_iterator"))
  .AddTypedef(type_3362, Reflex::Literal("std::vector<edm::ModuleTime>::const_reverse_iterator"))
  .AddTypedef(type_3363, Reflex::Literal("std::vector<edm::ModuleTime>::reverse_iterator"))
  .AddTypedef(type_3004, Reflex::Literal("std::vector<edm::ModuleTime>::size_type"))
  .AddTypedef(type_2891, Reflex::Literal("std::vector<edm::ModuleTime>::difference_type"))
  .AddTypedef(type_3108, Reflex::Literal("std::vector<edm::ModuleTime>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_14386, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29607), Reflex::Literal("vector"), constructor_14387, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3004, type_14377, type_29607), Reflex::Literal("vector"), constructor_14388, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30384), Reflex::Literal("vector"), constructor_14389, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_14390, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2768, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x39, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x40, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_edm__ModuleTime__funcmem_bld);
}

//------Delayed data member builder for class vector<edm::ModuleTime,std::allocator<edm::ModuleTime> > -------------------
void __std__vector_edm__ModuleTime__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<edm::ModuleTime,std::allocator<edm::ModuleTime> > -------------------
void __std__vector_edm__ModuleTime__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30385, type_30384), Reflex::Literal("operator="), operator_14391, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3004, type_14377), Reflex::Literal("assign"), method_14392, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5809), Reflex::Literal("begin"), method_14393, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5810), Reflex::Literal("begin"), method_14394, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5809), Reflex::Literal("end"), method_14395, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5810), Reflex::Literal("end"), method_14396, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3004), Reflex::Literal("size"), method_14401, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3004), Reflex::Literal("max_size"), method_14402, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3004, type_4535), Reflex::Literal("resize"), method_14403, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3004), Reflex::Literal("capacity"), method_14404, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1374), Reflex::Literal("empty"), method_14405, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3004), Reflex::Literal("reserve"), method_14406, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14375, type_3004), Reflex::Literal("operator[]"), operator_14407, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14377, type_3004), Reflex::Literal("operator[]"), operator_14408, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14375, type_3004), Reflex::Literal("at"), method_14410, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14377, type_3004), Reflex::Literal("at"), method_14411, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14375), Reflex::Literal("front"), method_14412, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14377), Reflex::Literal("front"), method_14413, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14375), Reflex::Literal("back"), method_14414, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14377), Reflex::Literal("back"), method_14415, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14371), Reflex::Literal("data"), method_14416, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14373), Reflex::Literal("data"), method_14417, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_14377), Reflex::Literal("push_back"), method_14418, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166), Reflex::Literal("pop_back"), method_14419, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5809, type_5809, type_14377), Reflex::Literal("insert"), method_14420, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_5809, type_3004, type_14377), Reflex::Literal("insert"), method_14421, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5809, type_5809), Reflex::Literal("erase"), method_14422, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5809, type_5809, type_5809), Reflex::Literal("erase"), method_14423, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_30385), Reflex::Literal("swap"), method_14424, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166), Reflex::Literal("clear"), method_14425, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::vector<unsigned int, std::allocator<unsigned int> >,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<unsigned int, std::allocator<unsigned int> > > > > -------------------------------
static void destructor_14889(void*, void * o, const std::vector<void*>&, void *) {
(((::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->::std::map<std::basic_string<char>,std::vector<unsigned int> >::~map)();
}
static void constructor_14890( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,std::vector<unsigned int> >();
  else ::new(mem) ::std::map<std::basic_string<char>,std::vector<unsigned int> >();
}

static void constructor_14891( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,std::vector<unsigned int> >(*(const ::std::less<std::basic_string<char> >*)arg[0]);
  else ::new(mem) ::std::map<std::basic_string<char>,std::vector<unsigned int> >(*(const ::std::less<std::basic_string<char> >*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,std::vector<unsigned int> >(*(const ::std::less<std::basic_string<char> >*)arg[0],
      *(const ::std::allocator<std::pair<const std::basic_string<char>,std::vector<unsigned int> > >*)arg[1]);
  else ::new(mem) ::std::map<std::basic_string<char>,std::vector<unsigned int> >(*(const ::std::less<std::basic_string<char> >*)arg[0],
      *(const ::std::allocator<std::pair<const std::basic_string<char>,std::vector<unsigned int> > >*)arg[1]);
  }
}

static void constructor_14892( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::map<std::basic_string<char>,std::vector<unsigned int> >(*(const ::std::map<std::basic_string<char>,std::vector<unsigned int> >*)arg[0]);
  else ::new(mem) ::std::map<std::basic_string<char>,std::vector<unsigned int> >(*(const ::std::map<std::basic_string<char>,std::vector<unsigned int> >*)arg[0]);
}

static  void operator_14893( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->operator=)(*(const ::std::map<std::basic_string<char>,std::vector<unsigned int> >*)arg[0]);
  else   (((::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->operator=)(*(const ::std::map<std::basic_string<char>,std::vector<unsigned int> >*)arg[0]);
}

static  void method_14894( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::allocator<std::pair<const std::basic_string<char>,std::vector<unsigned int> > >)((((const ::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->get_allocator)());
  else   (((const ::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->get_allocator)();
}

static  void method_14895( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<unsigned int> > >)((((::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->begin)());
  else   (((::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->begin)();
}

static  void method_14896( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::vector<unsigned int> > >)((((const ::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->begin)());
  else   (((const ::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->begin)();
}

static  void method_14897( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<unsigned int> > >)((((::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->end)());
  else   (((::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->end)();
}

static  void method_14898( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::vector<unsigned int> > >)((((const ::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->end)());
  else   (((const ::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->end)();
}

static  void method_14903( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->empty)());
  else   (((const ::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->empty)();
}

static  void method_14904( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->size)());
  else   (((const ::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->size)();
}

static  void method_14905( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->max_size)());
  else   (((const ::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->max_size)();
}

static  void operator_14906( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->operator[])(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->operator[])(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_14907( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_14908( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
  else   (((const ::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->at)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_14909( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<unsigned int> > >,bool>)((((::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->insert)(*(const ::std::pair<const std::basic_string<char>,std::vector<unsigned int> >*)arg[0]));
  else   (((::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->insert)(*(const ::std::pair<const std::basic_string<char>,std::vector<unsigned int> >*)arg[0]);
}

static  void method_14910( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<unsigned int> > >)((((::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<unsigned int> > >*)arg[0],
    *(const ::std::pair<const std::basic_string<char>,std::vector<unsigned int> >*)arg[1]));
  else   (((::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->insert)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<unsigned int> > >*)arg[0],
    *(const ::std::pair<const std::basic_string<char>,std::vector<unsigned int> >*)arg[1]);
}

static  void method_14911( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<unsigned int> > >*)arg[0]);
}

static  void method_14912( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->erase)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->erase)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_14913( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->erase)(*(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<unsigned int> > >*)arg[0],
    *(::std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<unsigned int> > >*)arg[1]);
}

static  void method_14914( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->swap)(*(::std::map<std::basic_string<char>,std::vector<unsigned int> >*)arg[0]);
}

static  void method_14915( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->clear)();
}

static  void method_14916( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::less<std::basic_string<char> >)((((const ::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->key_comp)());
  else   (((const ::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->key_comp)();
}

static  void method_14918( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<unsigned int> > >)((((::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->find)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->find)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_14919( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::vector<unsigned int> > >)((((const ::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->find)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->find)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_14920( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->count)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->count)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_14921( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<unsigned int> > >)((((::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_14922( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::vector<unsigned int> > >)((((const ::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->lower_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_14923( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<unsigned int> > >)((((::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_14924( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::vector<unsigned int> > >)((((const ::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->upper_bound)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_14925( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<unsigned int> > >,std::_Rb_tree_iterator<std::pair<const std::basic_string<char>,std::vector<unsigned int> > > >)((((::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]);
}

static  void method_14926( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::pair<std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::vector<unsigned int> > >,std::_Rb_tree_const_iterator<std::pair<const std::basic_string<char>,std::vector<unsigned int> > > >)((((const ::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]));
  else   (((const ::std::map<std::basic_string<char>,std::vector<unsigned int> >*)o)->equal_range)(*(const ::std::basic_string<char>*)arg[0]);
}

static void method_newdel_2916( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,std::vector<unsigned int> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,std::vector<unsigned int> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,std::vector<unsigned int> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,std::vector<unsigned int> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::map<std::basic_string<char>,std::vector<unsigned int> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x42( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::map<std::basic_string<char>,std::vector<unsigned int> > >::Generate();
  else ::Reflex::Proxy< ::std::map<std::basic_string<char>,std::vector<unsigned int> > >::Generate();
}

//------Dictionary for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::vector<unsigned int, std::allocator<unsigned int> >,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<unsigned int, std::allocator<unsigned int> > > > > -------------------------------
void __std__map_std__basic_string_char__std__vector_unsignedsint_s__db_datamem(Reflex::Class*);
void __std__map_std__basic_string_char__std__vector_unsignedsint_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__map_std__basic_string_char__std__vector_unsignedsint_s__datamem_bld(&__std__map_std__basic_string_char__std__vector_unsignedsint_s__db_datamem);
Reflex::GenreflexMemberBuilder __std__map_std__basic_string_char__std__vector_unsignedsint_s__funcmem_bld(&__std__map_std__basic_string_char__std__vector_unsignedsint_s__db_funcmem);
void __std__map_std__basic_string_char__std__vector_unsignedsint_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::map<std::basic_string<char>,std::vector<unsigned int> >"), typeid(::std::map<std::basic_string<char>,std::vector<unsigned int> >), sizeof(::std::map<std::basic_string<char>,std::vector<unsigned int> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2201, Reflex::Literal("std::map<std::basic_string<char>,std::vector<unsigned int> >::key_type"))
  .AddTypedef(type_2696, Reflex::Literal("std::map<std::basic_string<char>,std::vector<unsigned int> >::mapped_type"))
  .AddTypedef(type_2632, Reflex::Literal("std::map<std::basic_string<char>,std::vector<unsigned int> >::value_type"))
  .AddTypedef(type_2361, Reflex::Literal("std::map<std::basic_string<char>,std::vector<unsigned int> >::key_compare"))
  .AddTypedef(type_3016, Reflex::Literal("std::map<std::basic_string<char>,std::vector<unsigned int> >::allocator_type"))
  .AddTypedef(type_2632, Reflex::Literal("std::map<std::basic_string<char>,std::vector<unsigned int> >::_Alloc_value_type"))
  .AddTypedef(type_3016, Reflex::Literal("std::map<std::basic_string<char>,std::vector<unsigned int> >::_Pair_alloc_type"))
  .AddTypedef(type_2407, Reflex::Literal("std::map<std::basic_string<char>,std::vector<unsigned int> >::_Rep_type"))
  .AddTypedef(type_8827, Reflex::Literal("std::map<std::basic_string<char>,std::vector<unsigned int> >::pointer"))
  .AddTypedef(type_8829, Reflex::Literal("std::map<std::basic_string<char>,std::vector<unsigned int> >::const_pointer"))
  .AddTypedef(type_8831, Reflex::Literal("std::map<std::basic_string<char>,std::vector<unsigned int> >::reference"))
  .AddTypedef(type_8833, Reflex::Literal("std::map<std::basic_string<char>,std::vector<unsigned int> >::const_reference"))
  .AddTypedef(type_2859, Reflex::Literal("std::map<std::basic_string<char>,std::vector<unsigned int> >::iterator"))
  .AddTypedef(type_2482, Reflex::Literal("std::map<std::basic_string<char>,std::vector<unsigned int> >::const_iterator"))
  .AddTypedef(type_3004, Reflex::Literal("std::map<std::basic_string<char>,std::vector<unsigned int> >::size_type"))
  .AddTypedef(type_2891, Reflex::Literal("std::map<std::basic_string<char>,std::vector<unsigned int> >::difference_type"))
  .AddTypedef(type_3227, Reflex::Literal("std::map<std::basic_string<char>,std::vector<unsigned int> >::reverse_iterator"))
  .AddTypedef(type_3226, Reflex::Literal("std::map<std::basic_string<char>,std::vector<unsigned int> >::const_reverse_iterator"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~map"), destructor_14889, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("map"), constructor_14890, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_29951, type_30015), Reflex::Literal("map"), constructor_14891, 0, "__comp;__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_9765), Reflex::Literal("map"), constructor_14892, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2916, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x42, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__std__map_std__basic_string_char__std__vector_unsignedsint_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__std__map_std__basic_string_char__std__vector_unsignedsint_s__funcmem_bld);
}

//------Delayed data member builder for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::vector<unsigned int, std::allocator<unsigned int> >,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<unsigned int, std::allocator<unsigned int> > > > > -------------------
void __std__map_std__basic_string_char__std__vector_unsignedsint_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2407, Reflex::Literal("_M_t"), OffsetOf(__shadow__::__std__map_std__basic_string_char__std__vector_unsignedsint_s_, _M_t), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class map<std::basic_string<char, std::char_traits<char>, std::allocator<char> >,std::vector<unsigned int, std::allocator<unsigned int> >,std::less<std::basic_string<char, std::char_traits<char>, std::allocator<char> > >,std::allocator<std::pair<const std::basic_string<char, std::char_traits<char>, std::allocator<char> >, std::vector<unsigned int, std::allocator<unsigned int> > > > > -------------------
void __std__map_std__basic_string_char__std__vector_unsignedsint_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30503, type_9765), Reflex::Literal("operator="), operator_14893, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3016), Reflex::Literal("get_allocator"), method_14894, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2859), Reflex::Literal("begin"), method_14895, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2482), Reflex::Literal("begin"), method_14896, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2859), Reflex::Literal("end"), method_14897, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2482), Reflex::Literal("end"), method_14898, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1374), Reflex::Literal("empty"), method_14903, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3004), Reflex::Literal("size"), method_14904, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3004), Reflex::Literal("max_size"), method_14905, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30234, type_7804), Reflex::Literal("operator[]"), operator_14906, 0, "__k", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30234, type_7804), Reflex::Literal("at"), method_14907, 0, "__k", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30213, type_7804), Reflex::Literal("at"), method_14908, 0, "__k", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2635, type_8833), Reflex::Literal("insert"), method_14909, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2859, type_2859, type_8833), Reflex::Literal("insert"), method_14910, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_2859), Reflex::Literal("erase"), method_14911, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3004, type_7804), Reflex::Literal("erase"), method_14912, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_2859, type_2859), Reflex::Literal("erase"), method_14913, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_30503), Reflex::Literal("swap"), method_14914, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166), Reflex::Literal("clear"), method_14915, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2361), Reflex::Literal("key_comp"), method_14916, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2859, type_7804), Reflex::Literal("find"), method_14918, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2482, type_7804), Reflex::Literal("find"), method_14919, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3004, type_7804), Reflex::Literal("count"), method_14920, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2859, type_7804), Reflex::Literal("lower_bound"), method_14921, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2482, type_7804), Reflex::Literal("lower_bound"), method_14922, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2859, type_7804), Reflex::Literal("upper_bound"), method_14923, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2482, type_7804), Reflex::Literal("upper_bound"), method_14924, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2634, type_7804), Reflex::Literal("equal_range"), method_14925, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2633, type_7804), Reflex::Literal("equal_range"), method_14926, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class TriggerFilterObjectWithRefs -------------------------------
static void destructor_17993(void*, void * o, const std::vector<void*>&, void *) {
(((::trigger::TriggerFilterObjectWithRefs*)o)->::trigger::TriggerFilterObjectWithRefs::~TriggerFilterObjectWithRefs)();
}
static  void operator_17994( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::trigger::TriggerFilterObjectWithRefs*)o)->operator=)(*(const ::trigger::TriggerFilterObjectWithRefs*)arg[0]);
  else   (((::trigger::TriggerFilterObjectWithRefs*)o)->operator=)(*(const ::trigger::TriggerFilterObjectWithRefs*)arg[0]);
}

static void constructor_17995( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::trigger::TriggerFilterObjectWithRefs(*(const ::trigger::TriggerFilterObjectWithRefs*)arg[0]);
  else ::new(mem) ::trigger::TriggerFilterObjectWithRefs(*(const ::trigger::TriggerFilterObjectWithRefs*)arg[0]);
}

static void constructor_17996( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::trigger::TriggerFilterObjectWithRefs();
  else ::new(mem) ::trigger::TriggerFilterObjectWithRefs();
}

static void constructor_17997( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::trigger::TriggerFilterObjectWithRefs(*(int*)arg[0],
      *(int*)arg[1]);
  else ::new(mem) ::trigger::TriggerFilterObjectWithRefs(*(int*)arg[0],
      *(int*)arg[1]);
}

static  void method_17998( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::trigger::TriggerFilterObjectWithRefs*)o)->path)());
  else   (((const ::trigger::TriggerFilterObjectWithRefs*)o)->path)();
}

static  void method_17999( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::trigger::TriggerFilterObjectWithRefs*)o)->module)());
  else   (((const ::trigger::TriggerFilterObjectWithRefs*)o)->module)();
}

static  void method_18000( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::trigger::TriggerFilterObjectWithRefs*)o)->addCollectionTag)(*(const ::edm::InputTag*)arg[0]);
}

static  void method_18001( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerFilterObjectWithRefs*)o)->getCollectionTags)(*(::std::vector<edm::InputTag>*)arg[0]);
}

static  void method_18002( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::trigger::TriggerFilterObjectWithRefs*)o)->getCollectionTagsAsStrings)();
  else   (((const ::trigger::TriggerFilterObjectWithRefs*)o)->getCollectionTagsAsStrings)();
}

static  void method_18003( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::trigger::TriggerFilterObjectWithRefs*)o)->swap)(*(::trigger::TriggerFilterObjectWithRefs*)arg[0]);
}

static void method_newdel_3614( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::trigger::TriggerFilterObjectWithRefs >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::trigger::TriggerFilterObjectWithRefs >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::trigger::TriggerFilterObjectWithRefs >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::trigger::TriggerFilterObjectWithRefs >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::trigger::TriggerFilterObjectWithRefs >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x44( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("trigger::TriggerRefsCollections")), ::Reflex::BaseOffset< ::trigger::TriggerFilterObjectWithRefs,::trigger::TriggerRefsCollections >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class TriggerFilterObjectWithRefs -------------------------------
void __trigger__TriggerFilterObjectWithRefs_db_datamem(Reflex::Class*);
void __trigger__TriggerFilterObjectWithRefs_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __trigger__TriggerFilterObjectWithRefs_datamem_bld(&__trigger__TriggerFilterObjectWithRefs_db_datamem);
Reflex::GenreflexMemberBuilder __trigger__TriggerFilterObjectWithRefs_funcmem_bld(&__trigger__TriggerFilterObjectWithRefs_db_funcmem);
void __trigger__TriggerFilterObjectWithRefs_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("trigger::TriggerFilterObjectWithRefs"), typeid(::trigger::TriggerFilterObjectWithRefs), sizeof(::trigger::TriggerFilterObjectWithRefs), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddBase(type_3626, ::Reflex::BaseOffset< ::trigger::TriggerFilterObjectWithRefs, ::trigger::TriggerRefsCollections >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TriggerFilterObjectWithRefs"), destructor_17993, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17988, type_30893), Reflex::Literal("operator="), operator_17994, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30893), Reflex::Literal("TriggerFilterObjectWithRefs"), constructor_17995, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TriggerFilterObjectWithRefs"), constructor_17996, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71, type_71), Reflex::Literal("TriggerFilterObjectWithRefs"), constructor_17997, 0, "path;module", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3614, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x44, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__trigger__TriggerFilterObjectWithRefs_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__trigger__TriggerFilterObjectWithRefs_funcmem_bld);
}

//------Delayed data member builder for class TriggerFilterObjectWithRefs -------------------
void __trigger__TriggerFilterObjectWithRefs_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_71, Reflex::Literal("path_"), OffsetOf(__shadow__::__trigger__TriggerFilterObjectWithRefs, path_), ::Reflex::PRIVATE)
  .AddDataMember(type_71, Reflex::Literal("module_"), OffsetOf(__shadow__::__trigger__TriggerFilterObjectWithRefs, module_), ::Reflex::PRIVATE)
  .AddDataMember(type_2700, Reflex::Literal("collectionTags_"), OffsetOf(__shadow__::__trigger__TriggerFilterObjectWithRefs, collectionTags_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TriggerFilterObjectWithRefs -------------------
void __trigger__TriggerFilterObjectWithRefs_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71), Reflex::Literal("path"), method_17998, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71), Reflex::Literal("module"), method_17999, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_11148), Reflex::Literal("addCollectionTag"), method_18000, 0, "collectionTag", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_30283), Reflex::Literal("getCollectionTags"), method_18001, 0, "collectionTags", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9766), Reflex::Literal("getCollectionTagsAsStrings"), method_18002, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_17988), Reflex::Literal("swap"), method_18003, 0, "other", ::Reflex::PUBLIC);
}
//------Stub functions for class TriggerObject -------------------------------
static void destructor_18009(void*, void * o, const std::vector<void*>&, void *) {
(((::trigger::TriggerObject*)o)->::trigger::TriggerObject::~TriggerObject)();
}
static  void operator_18010( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::trigger::TriggerObject*)o)->operator=)(*(const ::trigger::TriggerObject*)arg[0]);
  else   (((::trigger::TriggerObject*)o)->operator=)(*(const ::trigger::TriggerObject*)arg[0]);
}

static void constructor_18011( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::trigger::TriggerObject(*(const ::trigger::TriggerObject*)arg[0]);
  else ::new(mem) ::trigger::TriggerObject(*(const ::trigger::TriggerObject*)arg[0]);
}

static void constructor_18012( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::trigger::TriggerObject();
  else ::new(mem) ::trigger::TriggerObject();
}

static void constructor_18013( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::trigger::TriggerObject(*(int*)arg[0],
      *(float*)arg[1],
      *(float*)arg[2],
      *(float*)arg[3],
      *(float*)arg[4]);
  else ::new(mem) ::trigger::TriggerObject(*(int*)arg[0],
      *(float*)arg[1],
      *(float*)arg[2],
      *(float*)arg[3],
      *(float*)arg[4]);
}

static  void method_18014( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::trigger::TriggerObject*)o)->setId)(*(int*)arg[0]);
}

static  void method_18015( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::trigger::TriggerObject*)o)->setPt)(*(float*)arg[0]);
}

static  void method_18016( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::trigger::TriggerObject*)o)->setEta)(*(float*)arg[0]);
}

static  void method_18017( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::trigger::TriggerObject*)o)->setPhi)(*(float*)arg[0]);
}

static  void method_18018( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::trigger::TriggerObject*)o)->setMass)(*(float*)arg[0]);
}

static  void method_18019( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::trigger::TriggerObject*)o)->id)());
  else   (((const ::trigger::TriggerObject*)o)->id)();
}

static  void method_18020( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::trigger::TriggerObject*)o)->pt)());
  else   (((const ::trigger::TriggerObject*)o)->pt)();
}

static  void method_18021( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::trigger::TriggerObject*)o)->eta)());
  else   (((const ::trigger::TriggerObject*)o)->eta)();
}

static  void method_18022( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::trigger::TriggerObject*)o)->phi)());
  else   (((const ::trigger::TriggerObject*)o)->phi)();
}

static  void method_18023( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::trigger::TriggerObject*)o)->mass)());
  else   (((const ::trigger::TriggerObject*)o)->mass)();
}

static  void method_18024( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::trigger::TriggerObject*)o)->px)());
  else   (((const ::trigger::TriggerObject*)o)->px)();
}

static  void method_18025( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::trigger::TriggerObject*)o)->py)());
  else   (((const ::trigger::TriggerObject*)o)->py)();
}

static  void method_18026( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::trigger::TriggerObject*)o)->pz)());
  else   (((const ::trigger::TriggerObject*)o)->pz)();
}

static  void method_18027( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::trigger::TriggerObject*)o)->p)());
  else   (((const ::trigger::TriggerObject*)o)->p)();
}

static  void method_18028( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::trigger::TriggerObject*)o)->energy)());
  else   (((const ::trigger::TriggerObject*)o)->energy)();
}

static  void method_18029( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (float)((((const ::trigger::TriggerObject*)o)->et)());
  else   (((const ::trigger::TriggerObject*)o)->et)();
}

static  void method_18030( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 0 ) {
    if (retaddr) new (retaddr) (reco::Particle)((((const ::trigger::TriggerObject*)o)->particle)());
    else     (((const ::trigger::TriggerObject*)o)->particle)();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) new (retaddr) (reco::Particle)((((const ::trigger::TriggerObject*)o)->particle)(*(int*)arg[0]));
    else     (((const ::trigger::TriggerObject*)o)->particle)(*(int*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) new (retaddr) (reco::Particle)((((const ::trigger::TriggerObject*)o)->particle)(*(int*)arg[0],
      *(const ::math::XYZPoint*)arg[1]));
    else     (((const ::trigger::TriggerObject*)o)->particle)(*(int*)arg[0],
      *(const ::math::XYZPoint*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) new (retaddr) (reco::Particle)((((const ::trigger::TriggerObject*)o)->particle)(*(int*)arg[0],
      *(const ::math::XYZPoint*)arg[1],
      *(int*)arg[2]));
    else     (((const ::trigger::TriggerObject*)o)->particle)(*(int*)arg[0],
      *(const ::math::XYZPoint*)arg[1],
      *(int*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) new (retaddr) (reco::Particle)((((const ::trigger::TriggerObject*)o)->particle)(*(int*)arg[0],
      *(const ::math::XYZPoint*)arg[1],
      *(int*)arg[2],
      *(bool*)arg[3]));
    else     (((const ::trigger::TriggerObject*)o)->particle)(*(int*)arg[0],
      *(const ::math::XYZPoint*)arg[1],
      *(int*)arg[2],
      *(bool*)arg[3]);
  }
}

static void method_newdel_3617( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::trigger::TriggerObject >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::trigger::TriggerObject >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::trigger::TriggerObject >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::trigger::TriggerObject >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::trigger::TriggerObject >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class TriggerObject -------------------------------
void __trigger__TriggerObject_db_datamem(Reflex::Class*);
void __trigger__TriggerObject_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __trigger__TriggerObject_datamem_bld(&__trigger__TriggerObject_db_datamem);
Reflex::GenreflexMemberBuilder __trigger__TriggerObject_funcmem_bld(&__trigger__TriggerObject_db_funcmem);
void __trigger__TriggerObject_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("trigger::TriggerObject"), typeid(::trigger::TriggerObject), sizeof(::trigger::TriggerObject), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TriggerObject"), destructor_18009, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7442, type_7431), Reflex::Literal("operator="), operator_18010, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7431), Reflex::Literal("TriggerObject"), constructor_18011, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TriggerObject"), constructor_18012, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_71, type_788, type_788, type_788, type_788), Reflex::Literal("TriggerObject"), constructor_18013, 0, "id;pt;eta;phi;mass", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3617, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__trigger__TriggerObject_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__trigger__TriggerObject_funcmem_bld);
}

//------Delayed data member builder for class TriggerObject -------------------
void __trigger__TriggerObject_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_71, Reflex::Literal("id_"), OffsetOf(__shadow__::__trigger__TriggerObject, id_), ::Reflex::PRIVATE)
  .AddDataMember(type_788, Reflex::Literal("pt_"), OffsetOf(__shadow__::__trigger__TriggerObject, pt_), ::Reflex::PRIVATE)
  .AddDataMember(type_788, Reflex::Literal("eta_"), OffsetOf(__shadow__::__trigger__TriggerObject, eta_), ::Reflex::PRIVATE)
  .AddDataMember(type_788, Reflex::Literal("phi_"), OffsetOf(__shadow__::__trigger__TriggerObject, phi_), ::Reflex::PRIVATE)
  .AddDataMember(type_788, Reflex::Literal("mass_"), OffsetOf(__shadow__::__trigger__TriggerObject, mass_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TriggerObject -------------------
void __trigger__TriggerObject_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71), Reflex::Literal("setId"), method_18014, 0, "id", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_788), Reflex::Literal("setPt"), method_18015, 0, "pt", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_788), Reflex::Literal("setEta"), method_18016, 0, "eta", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_788), Reflex::Literal("setPhi"), method_18017, 0, "phi", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_788), Reflex::Literal("setMass"), method_18018, 0, "mass", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_71), Reflex::Literal("id"), method_18019, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_788), Reflex::Literal("pt"), method_18020, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_788), Reflex::Literal("eta"), method_18021, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_788), Reflex::Literal("phi"), method_18022, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_788), Reflex::Literal("mass"), method_18023, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_788), Reflex::Literal("px"), method_18024, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_788), Reflex::Literal("py"), method_18025, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_788), Reflex::Literal("pz"), method_18026, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_788), Reflex::Literal("p"), method_18027, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_788), Reflex::Literal("energy"), method_18028, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_788), Reflex::Literal("et"), method_18029, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5534, type_71, type_30894, type_71, type_1374), Reflex::Literal("particle"), method_18030, 0, "q=0;vertex=ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>, ROOT::Math::DefaultCoordinateSystemTag>(((const double&)((const double*)(&0.0))), ((const double&)((const double*)(&0.0))), ((const double&)((const double*)(&0.0))));status=0;integerCharge=true", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HLTPrescaleTable -------------------------------
static void destructor_18034(void*, void * o, const std::vector<void*>&, void *) {
(((::trigger::HLTPrescaleTable*)o)->::trigger::HLTPrescaleTable::~HLTPrescaleTable)();
}
static  void operator_18035( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::trigger::HLTPrescaleTable*)o)->operator=)(*(const ::trigger::HLTPrescaleTable*)arg[0]);
  else   (((::trigger::HLTPrescaleTable*)o)->operator=)(*(const ::trigger::HLTPrescaleTable*)arg[0]);
}

static void constructor_18036( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::trigger::HLTPrescaleTable(*(const ::trigger::HLTPrescaleTable*)arg[0]);
  else ::new(mem) ::trigger::HLTPrescaleTable(*(const ::trigger::HLTPrescaleTable*)arg[0]);
}

static  void method_18037( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::trigger::HLTPrescaleTable*)o)->size)());
  else   (((const ::trigger::HLTPrescaleTable*)o)->size)();
}

static  void method_18038( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::trigger::HLTPrescaleTable*)o)->prescale)(*(const ::std::string*)arg[0]));
  else   (((const ::trigger::HLTPrescaleTable*)o)->prescale)(*(const ::std::string*)arg[0]);
}

static  void method_18039( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::trigger::HLTPrescaleTable*)o)->prescale)(*(unsigned int*)arg[0],
    *(const ::std::string*)arg[1]));
  else   (((const ::trigger::HLTPrescaleTable*)o)->prescale)(*(unsigned int*)arg[0],
    *(const ::std::string*)arg[1]);
}

static void constructor_18040( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::trigger::HLTPrescaleTable();
  else ::new(mem) ::trigger::HLTPrescaleTable();
}

static void constructor_18041( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::trigger::HLTPrescaleTable(*(unsigned int*)arg[0],
      *(const ::std::vector<std::basic_string<char> >*)arg[1],
      *(const ::std::map<std::basic_string<char>,std::vector<unsigned int> >*)arg[2]);
  else ::new(mem) ::trigger::HLTPrescaleTable(*(unsigned int*)arg[0],
      *(const ::std::vector<std::basic_string<char> >*)arg[1],
      *(const ::std::map<std::basic_string<char>,std::vector<unsigned int> >*)arg[2]);
}

static  void method_18042( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::trigger::HLTPrescaleTable*)o)->isProductEqual)(*(const ::trigger::HLTPrescaleTable*)arg[0]));
  else   (((const ::trigger::HLTPrescaleTable*)o)->isProductEqual)(*(const ::trigger::HLTPrescaleTable*)arg[0]);
}

static  void method_18043( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::trigger::HLTPrescaleTable*)o)->set)());
  else   (((const ::trigger::HLTPrescaleTable*)o)->set)();
}

static  void method_18044( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::trigger::HLTPrescaleTable*)o)->labels)();
  else   (((const ::trigger::HLTPrescaleTable*)o)->labels)();
}

static  void method_18045( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::trigger::HLTPrescaleTable*)o)->table)();
  else   (((const ::trigger::HLTPrescaleTable*)o)->table)();
}

static void method_newdel_3619( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::trigger::HLTPrescaleTable >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::trigger::HLTPrescaleTable >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::trigger::HLTPrescaleTable >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::trigger::HLTPrescaleTable >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::trigger::HLTPrescaleTable >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HLTPrescaleTable -------------------------------
void __trigger__HLTPrescaleTable_db_datamem(Reflex::Class*);
void __trigger__HLTPrescaleTable_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __trigger__HLTPrescaleTable_datamem_bld(&__trigger__HLTPrescaleTable_db_datamem);
Reflex::GenreflexMemberBuilder __trigger__HLTPrescaleTable_funcmem_bld(&__trigger__HLTPrescaleTable_db_funcmem);
void __trigger__HLTPrescaleTable_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("trigger::HLTPrescaleTable"), typeid(::trigger::HLTPrescaleTable), sizeof(::trigger::HLTPrescaleTable), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HLTPrescaleTable"), destructor_18034, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30895, type_30896), Reflex::Literal("operator="), operator_18035, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30896), Reflex::Literal("HLTPrescaleTable"), constructor_18036, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HLTPrescaleTable"), constructor_18040, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_301, type_9766, type_9765), Reflex::Literal("HLTPrescaleTable"), constructor_18041, 0, "set;labels;table", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3619, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__trigger__HLTPrescaleTable_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__trigger__HLTPrescaleTable_funcmem_bld);
}

//------Delayed data member builder for class HLTPrescaleTable -------------------
void __trigger__HLTPrescaleTable_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_301, Reflex::Literal("set_"), OffsetOf(__shadow__::__trigger__HLTPrescaleTable, set_), ::Reflex::PRIVATE)
  .AddDataMember(type_2700, Reflex::Literal("labels_"), OffsetOf(__shadow__::__trigger__HLTPrescaleTable, labels_), ::Reflex::PRIVATE)
  .AddDataMember(type_2916, Reflex::Literal("table_"), OffsetOf(__shadow__::__trigger__HLTPrescaleTable, table_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class HLTPrescaleTable -------------------
void __trigger__HLTPrescaleTable_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_301), Reflex::Literal("size"), method_18037, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_301, type_14768), Reflex::Literal("prescale"), method_18038, 0, "trigger", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_301, type_301, type_14768), Reflex::Literal("prescale"), method_18039, 0, "set;trigger", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1374, type_30896), Reflex::Literal("isProductEqual"), method_18042, 0, "that", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_301), Reflex::Literal("set"), method_18043, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9766), Reflex::Literal("labels"), method_18044, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_9765), Reflex::Literal("table"), method_18045, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class TriggerRefsCollections -------------------------------
static void destructor_18107(void*, void * o, const std::vector<void*>&, void *) {
(((::trigger::TriggerRefsCollections*)o)->::trigger::TriggerRefsCollections::~TriggerRefsCollections)();
}
static  void operator_18108( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::trigger::TriggerRefsCollections*)o)->operator=)(*(const ::trigger::TriggerRefsCollections*)arg[0]);
  else   (((::trigger::TriggerRefsCollections*)o)->operator=)(*(const ::trigger::TriggerRefsCollections*)arg[0]);
}

static void constructor_18109( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::trigger::TriggerRefsCollections(*(const ::trigger::TriggerRefsCollections*)arg[0]);
  else ::new(mem) ::trigger::TriggerRefsCollections(*(const ::trigger::TriggerRefsCollections*)arg[0]);
}

static void constructor_18110( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::trigger::TriggerRefsCollections();
  else ::new(mem) ::trigger::TriggerRefsCollections();
}

static  void method_18111( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::trigger::TriggerRefsCollections*)o)->swap)(*(::trigger::TriggerRefsCollections*)arg[0]);
}

static  void method_18112( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::trigger::TriggerRefsCollections*)o)->addObject)(*(int*)arg[0],
    *(const ::reco::RecoEcalCandidateRef*)arg[1]);
}

static  void method_18113( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::trigger::TriggerRefsCollections*)o)->addObject)(*(int*)arg[0],
    *(const ::reco::ElectronRef*)arg[1]);
}

static  void method_18114( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::trigger::TriggerRefsCollections*)o)->addObject)(*(int*)arg[0],
    *(const ::reco::RecoChargedCandidateRef*)arg[1]);
}

static  void method_18115( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::trigger::TriggerRefsCollections*)o)->addObject)(*(int*)arg[0],
    *(const ::reco::CaloJetRef*)arg[1]);
}

static  void method_18116( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::trigger::TriggerRefsCollections*)o)->addObject)(*(int*)arg[0],
    *(const ::reco::CompositeCandidateRef*)arg[1]);
}

static  void method_18117( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::trigger::TriggerRefsCollections*)o)->addObject)(*(int*)arg[0],
    *(const ::reco::METRef*)arg[1]);
}

static  void method_18118( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::trigger::TriggerRefsCollections*)o)->addObject)(*(int*)arg[0],
    *(const ::reco::CaloMETRef*)arg[1]);
}

static  void method_18119( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::trigger::TriggerRefsCollections*)o)->addObject)(*(int*)arg[0],
    *(const ::reco::IsolatedPixelTrackCandidateRef*)arg[1]);
}

static  void method_18120( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::trigger::TriggerRefsCollections*)o)->addObject)(*(int*)arg[0],
    *(const ::l1extra::L1EmParticleRef*)arg[1]);
}

static  void method_18121( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::trigger::TriggerRefsCollections*)o)->addObject)(*(int*)arg[0],
    *(const ::l1extra::L1MuonParticleRef*)arg[1]);
}

static  void method_18122( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::trigger::TriggerRefsCollections*)o)->addObject)(*(int*)arg[0],
    *(const ::l1extra::L1JetParticleRef*)arg[1]);
}

static  void method_18123( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::trigger::TriggerRefsCollections*)o)->addObject)(*(int*)arg[0],
    *(const ::l1extra::L1EtMissParticleRef*)arg[1]);
}

static  void method_18124( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::trigger::TriggerRefsCollections*)o)->addObject)(*(int*)arg[0],
    *(const ::l1extra::L1HFRingsRef*)arg[1]);
}

static  void method_18125( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::trigger::TriggerRefsCollections*)o)->addObject)(*(int*)arg[0],
    *(const ::reco::PFJetRef*)arg[1]);
}

static  void method_18126( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::trigger::TriggerRefsCollections*)o)->addObject)(*(int*)arg[0],
    *(const ::reco::PFTauRef*)arg[1]);
}

static  void method_18127( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (trigger::size_type)((((::trigger::TriggerRefsCollections*)o)->addObjects)(*(const ::trigger::Vids*)arg[0],
    *(const ::trigger::VRphoton*)arg[1]));
  else   (((::trigger::TriggerRefsCollections*)o)->addObjects)(*(const ::trigger::Vids*)arg[0],
    *(const ::trigger::VRphoton*)arg[1]);
}

static  void method_18128( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (trigger::size_type)((((::trigger::TriggerRefsCollections*)o)->addObjects)(*(const ::trigger::Vids*)arg[0],
    *(const ::trigger::VRelectron*)arg[1]));
  else   (((::trigger::TriggerRefsCollections*)o)->addObjects)(*(const ::trigger::Vids*)arg[0],
    *(const ::trigger::VRelectron*)arg[1]);
}

static  void method_18129( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (trigger::size_type)((((::trigger::TriggerRefsCollections*)o)->addObjects)(*(const ::trigger::Vids*)arg[0],
    *(const ::trigger::VRmuon*)arg[1]));
  else   (((::trigger::TriggerRefsCollections*)o)->addObjects)(*(const ::trigger::Vids*)arg[0],
    *(const ::trigger::VRmuon*)arg[1]);
}

static  void method_18130( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (trigger::size_type)((((::trigger::TriggerRefsCollections*)o)->addObjects)(*(const ::trigger::Vids*)arg[0],
    *(const ::trigger::VRjet*)arg[1]));
  else   (((::trigger::TriggerRefsCollections*)o)->addObjects)(*(const ::trigger::Vids*)arg[0],
    *(const ::trigger::VRjet*)arg[1]);
}

static  void method_18131( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (trigger::size_type)((((::trigger::TriggerRefsCollections*)o)->addObjects)(*(const ::trigger::Vids*)arg[0],
    *(const ::trigger::VRcomposite*)arg[1]));
  else   (((::trigger::TriggerRefsCollections*)o)->addObjects)(*(const ::trigger::Vids*)arg[0],
    *(const ::trigger::VRcomposite*)arg[1]);
}

static  void method_18132( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (trigger::size_type)((((::trigger::TriggerRefsCollections*)o)->addObjects)(*(const ::trigger::Vids*)arg[0],
    *(const ::trigger::VRbasemet*)arg[1]));
  else   (((::trigger::TriggerRefsCollections*)o)->addObjects)(*(const ::trigger::Vids*)arg[0],
    *(const ::trigger::VRbasemet*)arg[1]);
}

static  void method_18133( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (trigger::size_type)((((::trigger::TriggerRefsCollections*)o)->addObjects)(*(const ::trigger::Vids*)arg[0],
    *(const ::trigger::VRcalomet*)arg[1]));
  else   (((::trigger::TriggerRefsCollections*)o)->addObjects)(*(const ::trigger::Vids*)arg[0],
    *(const ::trigger::VRcalomet*)arg[1]);
}

static  void method_18134( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (trigger::size_type)((((::trigger::TriggerRefsCollections*)o)->addObjects)(*(const ::trigger::Vids*)arg[0],
    *(const ::trigger::VRpixtrack*)arg[1]));
  else   (((::trigger::TriggerRefsCollections*)o)->addObjects)(*(const ::trigger::Vids*)arg[0],
    *(const ::trigger::VRpixtrack*)arg[1]);
}

static  void method_18135( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (trigger::size_type)((((::trigger::TriggerRefsCollections*)o)->addObjects)(*(const ::trigger::Vids*)arg[0],
    *(const ::trigger::VRl1em*)arg[1]));
  else   (((::trigger::TriggerRefsCollections*)o)->addObjects)(*(const ::trigger::Vids*)arg[0],
    *(const ::trigger::VRl1em*)arg[1]);
}

static  void method_18136( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (trigger::size_type)((((::trigger::TriggerRefsCollections*)o)->addObjects)(*(const ::trigger::Vids*)arg[0],
    *(const ::trigger::VRl1muon*)arg[1]));
  else   (((::trigger::TriggerRefsCollections*)o)->addObjects)(*(const ::trigger::Vids*)arg[0],
    *(const ::trigger::VRl1muon*)arg[1]);
}

static  void method_18137( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (trigger::size_type)((((::trigger::TriggerRefsCollections*)o)->addObjects)(*(const ::trigger::Vids*)arg[0],
    *(const ::trigger::VRl1jet*)arg[1]));
  else   (((::trigger::TriggerRefsCollections*)o)->addObjects)(*(const ::trigger::Vids*)arg[0],
    *(const ::trigger::VRl1jet*)arg[1]);
}

static  void method_18138( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (trigger::size_type)((((::trigger::TriggerRefsCollections*)o)->addObjects)(*(const ::trigger::Vids*)arg[0],
    *(const ::trigger::VRl1etmiss*)arg[1]));
  else   (((::trigger::TriggerRefsCollections*)o)->addObjects)(*(const ::trigger::Vids*)arg[0],
    *(const ::trigger::VRl1etmiss*)arg[1]);
}

static  void method_18139( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (trigger::size_type)((((::trigger::TriggerRefsCollections*)o)->addObjects)(*(const ::trigger::Vids*)arg[0],
    *(const ::trigger::VRl1hfrings*)arg[1]));
  else   (((::trigger::TriggerRefsCollections*)o)->addObjects)(*(const ::trigger::Vids*)arg[0],
    *(const ::trigger::VRl1hfrings*)arg[1]);
}

static  void method_18140( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (trigger::size_type)((((::trigger::TriggerRefsCollections*)o)->addObjects)(*(const ::trigger::Vids*)arg[0],
    *(const ::trigger::VRpfjet*)arg[1]));
  else   (((::trigger::TriggerRefsCollections*)o)->addObjects)(*(const ::trigger::Vids*)arg[0],
    *(const ::trigger::VRpfjet*)arg[1]);
}

static  void method_18141( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (trigger::size_type)((((::trigger::TriggerRefsCollections*)o)->addObjects)(*(const ::trigger::Vids*)arg[0],
    *(const ::trigger::VRpftau*)arg[1]));
  else   (((::trigger::TriggerRefsCollections*)o)->addObjects)(*(const ::trigger::Vids*)arg[0],
    *(const ::trigger::VRpftau*)arg[1]);
}

static  void method_18142( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(::trigger::Vids*)arg[0],
    *(::trigger::VRphoton*)arg[1]);
}

static  void method_18143( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(::trigger::Vids*)arg[0],
    *(::trigger::VRphoton*)arg[1],
    *(::trigger::size_type*)arg[2],
    *(::trigger::size_type*)arg[3]);
}

static  void method_18144( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(int*)arg[0],
    *(::trigger::VRphoton*)arg[1]);
}

static  void method_18145( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(int*)arg[0],
    *(::trigger::VRphoton*)arg[1],
    *(::trigger::size_type*)arg[2],
    *(::trigger::size_type*)arg[3]);
}

static  void method_18146( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(::trigger::Vids*)arg[0],
    *(::trigger::VRelectron*)arg[1]);
}

static  void method_18147( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(::trigger::Vids*)arg[0],
    *(::trigger::VRelectron*)arg[1],
    *(::trigger::size_type*)arg[2],
    *(::trigger::size_type*)arg[3]);
}

static  void method_18148( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(int*)arg[0],
    *(::trigger::VRelectron*)arg[1]);
}

static  void method_18149( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(int*)arg[0],
    *(::trigger::VRelectron*)arg[1],
    *(::trigger::size_type*)arg[2],
    *(::trigger::size_type*)arg[3]);
}

static  void method_18150( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(::trigger::Vids*)arg[0],
    *(::trigger::VRmuon*)arg[1]);
}

static  void method_18151( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(::trigger::Vids*)arg[0],
    *(::trigger::VRmuon*)arg[1],
    *(::trigger::size_type*)arg[2],
    *(::trigger::size_type*)arg[3]);
}

static  void method_18152( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(int*)arg[0],
    *(::trigger::VRmuon*)arg[1]);
}

static  void method_18153( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(int*)arg[0],
    *(::trigger::VRmuon*)arg[1],
    *(::trigger::size_type*)arg[2],
    *(::trigger::size_type*)arg[3]);
}

static  void method_18154( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(::trigger::Vids*)arg[0],
    *(::trigger::VRjet*)arg[1]);
}

static  void method_18155( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(::trigger::Vids*)arg[0],
    *(::trigger::VRjet*)arg[1],
    *(::trigger::size_type*)arg[2],
    *(::trigger::size_type*)arg[3]);
}

static  void method_18156( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(int*)arg[0],
    *(::trigger::VRjet*)arg[1]);
}

static  void method_18157( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(int*)arg[0],
    *(::trigger::VRjet*)arg[1],
    *(::trigger::size_type*)arg[2],
    *(::trigger::size_type*)arg[3]);
}

static  void method_18158( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(::trigger::Vids*)arg[0],
    *(::trigger::VRcomposite*)arg[1]);
}

static  void method_18159( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(::trigger::Vids*)arg[0],
    *(::trigger::VRcomposite*)arg[1],
    *(::trigger::size_type*)arg[2],
    *(::trigger::size_type*)arg[3]);
}

static  void method_18160( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(int*)arg[0],
    *(::trigger::VRcomposite*)arg[1]);
}

static  void method_18161( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(int*)arg[0],
    *(::trigger::VRcomposite*)arg[1],
    *(::trigger::size_type*)arg[2],
    *(::trigger::size_type*)arg[3]);
}

static  void method_18162( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(::trigger::Vids*)arg[0],
    *(::trigger::VRbasemet*)arg[1]);
}

static  void method_18163( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(::trigger::Vids*)arg[0],
    *(::trigger::VRbasemet*)arg[1],
    *(::trigger::size_type*)arg[2],
    *(::trigger::size_type*)arg[3]);
}

static  void method_18164( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(int*)arg[0],
    *(::trigger::VRbasemet*)arg[1]);
}

static  void method_18165( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(int*)arg[0],
    *(::trigger::VRbasemet*)arg[1],
    *(::trigger::size_type*)arg[2],
    *(::trigger::size_type*)arg[3]);
}

static  void method_18166( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(::trigger::Vids*)arg[0],
    *(::trigger::VRcalomet*)arg[1]);
}

static  void method_18167( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(::trigger::Vids*)arg[0],
    *(::trigger::VRcalomet*)arg[1],
    *(::trigger::size_type*)arg[2],
    *(::trigger::size_type*)arg[3]);
}

static  void method_18168( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(int*)arg[0],
    *(::trigger::VRcalomet*)arg[1]);
}

static  void method_18169( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(int*)arg[0],
    *(::trigger::VRcalomet*)arg[1],
    *(::trigger::size_type*)arg[2],
    *(::trigger::size_type*)arg[3]);
}

static  void method_18170( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(::trigger::Vids*)arg[0],
    *(::trigger::VRpixtrack*)arg[1]);
}

static  void method_18171( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(::trigger::Vids*)arg[0],
    *(::trigger::VRpixtrack*)arg[1],
    *(::trigger::size_type*)arg[2],
    *(::trigger::size_type*)arg[3]);
}

static  void method_18172( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(int*)arg[0],
    *(::trigger::VRpixtrack*)arg[1]);
}

static  void method_18173( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(int*)arg[0],
    *(::trigger::VRpixtrack*)arg[1],
    *(::trigger::size_type*)arg[2],
    *(::trigger::size_type*)arg[3]);
}

static  void method_18174( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(::trigger::Vids*)arg[0],
    *(::trigger::VRl1em*)arg[1]);
}

static  void method_18175( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(::trigger::Vids*)arg[0],
    *(::trigger::VRl1em*)arg[1],
    *(::trigger::size_type*)arg[2],
    *(::trigger::size_type*)arg[3]);
}

static  void method_18176( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(int*)arg[0],
    *(::trigger::VRl1em*)arg[1]);
}

static  void method_18177( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(int*)arg[0],
    *(::trigger::VRl1em*)arg[1],
    *(::trigger::size_type*)arg[2],
    *(::trigger::size_type*)arg[3]);
}

static  void method_18178( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(::trigger::Vids*)arg[0],
    *(::trigger::VRl1muon*)arg[1]);
}

static  void method_18179( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(::trigger::Vids*)arg[0],
    *(::trigger::VRl1muon*)arg[1],
    *(::trigger::size_type*)arg[2],
    *(::trigger::size_type*)arg[3]);
}

static  void method_18180( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(int*)arg[0],
    *(::trigger::VRl1muon*)arg[1]);
}

static  void method_18181( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(int*)arg[0],
    *(::trigger::VRl1muon*)arg[1],
    *(::trigger::size_type*)arg[2],
    *(::trigger::size_type*)arg[3]);
}

static  void method_18182( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(::trigger::Vids*)arg[0],
    *(::trigger::VRl1jet*)arg[1]);
}

static  void method_18183( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(::trigger::Vids*)arg[0],
    *(::trigger::VRl1jet*)arg[1],
    *(::trigger::size_type*)arg[2],
    *(::trigger::size_type*)arg[3]);
}

static  void method_18184( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(int*)arg[0],
    *(::trigger::VRl1jet*)arg[1]);
}

static  void method_18185( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(int*)arg[0],
    *(::trigger::VRl1jet*)arg[1],
    *(::trigger::size_type*)arg[2],
    *(::trigger::size_type*)arg[3]);
}

static  void method_18186( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(::trigger::Vids*)arg[0],
    *(::trigger::VRl1etmiss*)arg[1]);
}

static  void method_18187( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(::trigger::Vids*)arg[0],
    *(::trigger::VRl1etmiss*)arg[1],
    *(::trigger::size_type*)arg[2],
    *(::trigger::size_type*)arg[3]);
}

static  void method_18188( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(int*)arg[0],
    *(::trigger::VRl1etmiss*)arg[1]);
}

static  void method_18189( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(int*)arg[0],
    *(::trigger::VRl1etmiss*)arg[1],
    *(::trigger::size_type*)arg[2],
    *(::trigger::size_type*)arg[3]);
}

static  void method_18190( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(::trigger::Vids*)arg[0],
    *(::trigger::VRl1hfrings*)arg[1]);
}

static  void method_18191( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(::trigger::Vids*)arg[0],
    *(::trigger::VRl1hfrings*)arg[1],
    *(::trigger::size_type*)arg[2],
    *(::trigger::size_type*)arg[3]);
}

static  void method_18192( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(int*)arg[0],
    *(::trigger::VRl1hfrings*)arg[1]);
}

static  void method_18193( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(int*)arg[0],
    *(::trigger::VRl1hfrings*)arg[1],
    *(::trigger::size_type*)arg[2],
    *(::trigger::size_type*)arg[3]);
}

static  void method_18194( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(::trigger::Vids*)arg[0],
    *(::trigger::VRpfjet*)arg[1]);
}

static  void method_18195( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(::trigger::Vids*)arg[0],
    *(::trigger::VRpfjet*)arg[1],
    *(::trigger::size_type*)arg[2],
    *(::trigger::size_type*)arg[3]);
}

static  void method_18196( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(int*)arg[0],
    *(::trigger::VRpfjet*)arg[1]);
}

static  void method_18197( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(int*)arg[0],
    *(::trigger::VRpfjet*)arg[1],
    *(::trigger::size_type*)arg[2],
    *(::trigger::size_type*)arg[3]);
}

static  void method_18198( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(::trigger::Vids*)arg[0],
    *(::trigger::VRpftau*)arg[1]);
}

static  void method_18199( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(::trigger::Vids*)arg[0],
    *(::trigger::VRpftau*)arg[1],
    *(::trigger::size_type*)arg[2],
    *(::trigger::size_type*)arg[3]);
}

static  void method_18200( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(int*)arg[0],
    *(::trigger::VRpftau*)arg[1]);
}

static  void method_18201( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::trigger::TriggerRefsCollections*)o)->getObjects)(*(int*)arg[0],
    *(::trigger::VRpftau*)arg[1],
    *(::trigger::size_type*)arg[2],
    *(::trigger::size_type*)arg[3]);
}

static  void method_18202( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (trigger::size_type)((((const ::trigger::TriggerRefsCollections*)o)->photonSize)());
  else   (((const ::trigger::TriggerRefsCollections*)o)->photonSize)();
}

static  void method_18203( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::trigger::TriggerRefsCollections*)o)->photonIds)();
  else   (((const ::trigger::TriggerRefsCollections*)o)->photonIds)();
}

static  void method_18204( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::trigger::TriggerRefsCollections*)o)->photonRefs)();
  else   (((const ::trigger::TriggerRefsCollections*)o)->photonRefs)();
}

static  void method_18205( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (trigger::size_type)((((const ::trigger::TriggerRefsCollections*)o)->electronSize)());
  else   (((const ::trigger::TriggerRefsCollections*)o)->electronSize)();
}

static  void method_18206( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::trigger::TriggerRefsCollections*)o)->electronIds)();
  else   (((const ::trigger::TriggerRefsCollections*)o)->electronIds)();
}

static  void method_18207( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::trigger::TriggerRefsCollections*)o)->electronRefs)();
  else   (((const ::trigger::TriggerRefsCollections*)o)->electronRefs)();
}

static  void method_18208( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (trigger::size_type)((((const ::trigger::TriggerRefsCollections*)o)->muonSize)());
  else   (((const ::trigger::TriggerRefsCollections*)o)->muonSize)();
}

static  void method_18209( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::trigger::TriggerRefsCollections*)o)->muonIds)();
  else   (((const ::trigger::TriggerRefsCollections*)o)->muonIds)();
}

static  void method_18210( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::trigger::TriggerRefsCollections*)o)->muonRefs)();
  else   (((const ::trigger::TriggerRefsCollections*)o)->muonRefs)();
}

static  void method_18211( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (trigger::size_type)((((const ::trigger::TriggerRefsCollections*)o)->jetSize)());
  else   (((const ::trigger::TriggerRefsCollections*)o)->jetSize)();
}

static  void method_18212( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::trigger::TriggerRefsCollections*)o)->jetIds)();
  else   (((const ::trigger::TriggerRefsCollections*)o)->jetIds)();
}

static  void method_18213( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::trigger::TriggerRefsCollections*)o)->jetRefs)();
  else   (((const ::trigger::TriggerRefsCollections*)o)->jetRefs)();
}

static  void method_18214( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (trigger::size_type)((((const ::trigger::TriggerRefsCollections*)o)->compositeSize)());
  else   (((const ::trigger::TriggerRefsCollections*)o)->compositeSize)();
}

static  void method_18215( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::trigger::TriggerRefsCollections*)o)->compositeIds)();
  else   (((const ::trigger::TriggerRefsCollections*)o)->compositeIds)();
}

static  void method_18216( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::trigger::TriggerRefsCollections*)o)->compositeRefs)();
  else   (((const ::trigger::TriggerRefsCollections*)o)->compositeRefs)();
}

static  void method_18217( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (trigger::size_type)((((const ::trigger::TriggerRefsCollections*)o)->basemetSize)());
  else   (((const ::trigger::TriggerRefsCollections*)o)->basemetSize)();
}

static  void method_18218( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::trigger::TriggerRefsCollections*)o)->basemetIds)();
  else   (((const ::trigger::TriggerRefsCollections*)o)->basemetIds)();
}

static  void method_18219( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::trigger::TriggerRefsCollections*)o)->basemetRefs)();
  else   (((const ::trigger::TriggerRefsCollections*)o)->basemetRefs)();
}

static  void method_18220( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (trigger::size_type)((((const ::trigger::TriggerRefsCollections*)o)->calometSize)());
  else   (((const ::trigger::TriggerRefsCollections*)o)->calometSize)();
}

static  void method_18221( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::trigger::TriggerRefsCollections*)o)->calometIds)();
  else   (((const ::trigger::TriggerRefsCollections*)o)->calometIds)();
}

static  void method_18222( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::trigger::TriggerRefsCollections*)o)->calometRefs)();
  else   (((const ::trigger::TriggerRefsCollections*)o)->calometRefs)();
}

static  void method_18223( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (trigger::size_type)((((const ::trigger::TriggerRefsCollections*)o)->pixtrackSize)());
  else   (((const ::trigger::TriggerRefsCollections*)o)->pixtrackSize)();
}

static  void method_18224( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::trigger::TriggerRefsCollections*)o)->pixtrackIds)();
  else   (((const ::trigger::TriggerRefsCollections*)o)->pixtrackIds)();
}

static  void method_18225( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::trigger::TriggerRefsCollections*)o)->pixtrackRefs)();
  else   (((const ::trigger::TriggerRefsCollections*)o)->pixtrackRefs)();
}

static  void method_18226( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (trigger::size_type)((((const ::trigger::TriggerRefsCollections*)o)->l1emSize)());
  else   (((const ::trigger::TriggerRefsCollections*)o)->l1emSize)();
}

static  void method_18227( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::trigger::TriggerRefsCollections*)o)->l1emIds)();
  else   (((const ::trigger::TriggerRefsCollections*)o)->l1emIds)();
}

static  void method_18228( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::trigger::TriggerRefsCollections*)o)->l1emRefs)();
  else   (((const ::trigger::TriggerRefsCollections*)o)->l1emRefs)();
}

static  void method_18229( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (trigger::size_type)((((const ::trigger::TriggerRefsCollections*)o)->l1muonSize)());
  else   (((const ::trigger::TriggerRefsCollections*)o)->l1muonSize)();
}

static  void method_18230( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::trigger::TriggerRefsCollections*)o)->l1muonIds)();
  else   (((const ::trigger::TriggerRefsCollections*)o)->l1muonIds)();
}

static  void method_18231( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::trigger::TriggerRefsCollections*)o)->l1muonRefs)();
  else   (((const ::trigger::TriggerRefsCollections*)o)->l1muonRefs)();
}

static  void method_18232( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (trigger::size_type)((((const ::trigger::TriggerRefsCollections*)o)->l1jetSize)());
  else   (((const ::trigger::TriggerRefsCollections*)o)->l1jetSize)();
}

static  void method_18233( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::trigger::TriggerRefsCollections*)o)->l1jetIds)();
  else   (((const ::trigger::TriggerRefsCollections*)o)->l1jetIds)();
}

static  void method_18234( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::trigger::TriggerRefsCollections*)o)->l1jetRefs)();
  else   (((const ::trigger::TriggerRefsCollections*)o)->l1jetRefs)();
}

static  void method_18235( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (trigger::size_type)((((const ::trigger::TriggerRefsCollections*)o)->l1etmissSize)());
  else   (((const ::trigger::TriggerRefsCollections*)o)->l1etmissSize)();
}

static  void method_18236( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::trigger::TriggerRefsCollections*)o)->l1etmissIds)();
  else   (((const ::trigger::TriggerRefsCollections*)o)->l1etmissIds)();
}

static  void method_18237( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::trigger::TriggerRefsCollections*)o)->l1etmissRefs)();
  else   (((const ::trigger::TriggerRefsCollections*)o)->l1etmissRefs)();
}

static  void method_18238( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (trigger::size_type)((((const ::trigger::TriggerRefsCollections*)o)->l1hfringsSize)());
  else   (((const ::trigger::TriggerRefsCollections*)o)->l1hfringsSize)();
}

static  void method_18239( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::trigger::TriggerRefsCollections*)o)->l1hfringsIds)();
  else   (((const ::trigger::TriggerRefsCollections*)o)->l1hfringsIds)();
}

static  void method_18240( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::trigger::TriggerRefsCollections*)o)->l1hfringsRefs)();
  else   (((const ::trigger::TriggerRefsCollections*)o)->l1hfringsRefs)();
}

static  void method_18241( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (trigger::size_type)((((const ::trigger::TriggerRefsCollections*)o)->pfjetSize)());
  else   (((const ::trigger::TriggerRefsCollections*)o)->pfjetSize)();
}

static  void method_18242( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::trigger::TriggerRefsCollections*)o)->pfjetIds)();
  else   (((const ::trigger::TriggerRefsCollections*)o)->pfjetIds)();
}

static  void method_18243( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::trigger::TriggerRefsCollections*)o)->pfjetRefs)();
  else   (((const ::trigger::TriggerRefsCollections*)o)->pfjetRefs)();
}

static  void method_18244( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (trigger::size_type)((((const ::trigger::TriggerRefsCollections*)o)->pftauSize)());
  else   (((const ::trigger::TriggerRefsCollections*)o)->pftauSize)();
}

static  void method_18245( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::trigger::TriggerRefsCollections*)o)->pftauIds)();
  else   (((const ::trigger::TriggerRefsCollections*)o)->pftauIds)();
}

static  void method_18246( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::trigger::TriggerRefsCollections*)o)->pftauRefs)();
  else   (((const ::trigger::TriggerRefsCollections*)o)->pftauRefs)();
}

static void method_newdel_3626( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::trigger::TriggerRefsCollections >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::trigger::TriggerRefsCollections >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::trigger::TriggerRefsCollections >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::trigger::TriggerRefsCollections >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::trigger::TriggerRefsCollections >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class TriggerRefsCollections -------------------------------
void __trigger__TriggerRefsCollections_db_datamem(Reflex::Class*);
void __trigger__TriggerRefsCollections_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __trigger__TriggerRefsCollections_datamem_bld(&__trigger__TriggerRefsCollections_db_datamem);
Reflex::GenreflexMemberBuilder __trigger__TriggerRefsCollections_funcmem_bld(&__trigger__TriggerRefsCollections_db_funcmem);
void __trigger__TriggerRefsCollections_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("trigger::TriggerRefsCollections"), typeid(::trigger::TriggerRefsCollections), sizeof(::trigger::TriggerRefsCollections), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "12")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TriggerRefsCollections"), destructor_18107, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_17989, type_30902), Reflex::Literal("operator="), operator_18108, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30902), Reflex::Literal("TriggerRefsCollections"), constructor_18109, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TriggerRefsCollections"), constructor_18110, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3626, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__trigger__TriggerRefsCollections_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__trigger__TriggerRefsCollections_funcmem_bld);
}

//------Delayed data member builder for class TriggerRefsCollections -------------------
void __trigger__TriggerRefsCollections_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3611, Reflex::Literal("photonIds_"), OffsetOf(__shadow__::__trigger__TriggerRefsCollections, photonIds_), ::Reflex::PRIVATE)
  .AddDataMember(type_3622, Reflex::Literal("photonRefs_"), OffsetOf(__shadow__::__trigger__TriggerRefsCollections, photonRefs_), ::Reflex::PRIVATE)
  .AddDataMember(type_3611, Reflex::Literal("electronIds_"), OffsetOf(__shadow__::__trigger__TriggerRefsCollections, electronIds_), ::Reflex::PRIVATE)
  .AddDataMember(type_3601, Reflex::Literal("electronRefs_"), OffsetOf(__shadow__::__trigger__TriggerRefsCollections, electronRefs_), ::Reflex::PRIVATE)
  .AddDataMember(type_3611, Reflex::Literal("muonIds_"), OffsetOf(__shadow__::__trigger__TriggerRefsCollections, muonIds_), ::Reflex::PRIVATE)
  .AddDataMember(type_3615, Reflex::Literal("muonRefs_"), OffsetOf(__shadow__::__trigger__TriggerRefsCollections, muonRefs_), ::Reflex::PRIVATE)
  .AddDataMember(type_3611, Reflex::Literal("jetIds_"), OffsetOf(__shadow__::__trigger__TriggerRefsCollections, jetIds_), ::Reflex::PRIVATE)
  .AddDataMember(type_3603, Reflex::Literal("jetRefs_"), OffsetOf(__shadow__::__trigger__TriggerRefsCollections, jetRefs_), ::Reflex::PRIVATE)
  .AddDataMember(type_3611, Reflex::Literal("compositeIds_"), OffsetOf(__shadow__::__trigger__TriggerRefsCollections, compositeIds_), ::Reflex::PRIVATE)
  .AddDataMember(type_3616, Reflex::Literal("compositeRefs_"), OffsetOf(__shadow__::__trigger__TriggerRefsCollections, compositeRefs_), ::Reflex::PRIVATE)
  .AddDataMember(type_3611, Reflex::Literal("basemetIds_"), OffsetOf(__shadow__::__trigger__TriggerRefsCollections, basemetIds_), ::Reflex::PRIVATE)
  .AddDataMember(type_3625, Reflex::Literal("basemetRefs_"), OffsetOf(__shadow__::__trigger__TriggerRefsCollections, basemetRefs_), ::Reflex::PRIVATE)
  .AddDataMember(type_3611, Reflex::Literal("calometIds_"), OffsetOf(__shadow__::__trigger__TriggerRefsCollections, calometIds_), ::Reflex::PRIVATE)
  .AddDataMember(type_3610, Reflex::Literal("calometRefs_"), OffsetOf(__shadow__::__trigger__TriggerRefsCollections, calometRefs_), ::Reflex::PRIVATE)
  .AddDataMember(type_3611, Reflex::Literal("pixtrackIds_"), OffsetOf(__shadow__::__trigger__TriggerRefsCollections, pixtrackIds_), ::Reflex::PRIVATE)
  .AddDataMember(type_3602, Reflex::Literal("pixtrackRefs_"), OffsetOf(__shadow__::__trigger__TriggerRefsCollections, pixtrackRefs_), ::Reflex::PRIVATE)
  .AddDataMember(type_3611, Reflex::Literal("l1emIds_"), OffsetOf(__shadow__::__trigger__TriggerRefsCollections, l1emIds_), ::Reflex::PRIVATE)
  .AddDataMember(type_3606, Reflex::Literal("l1emRefs_"), OffsetOf(__shadow__::__trigger__TriggerRefsCollections, l1emRefs_), ::Reflex::PRIVATE)
  .AddDataMember(type_3611, Reflex::Literal("l1muonIds_"), OffsetOf(__shadow__::__trigger__TriggerRefsCollections, l1muonIds_), ::Reflex::PRIVATE)
  .AddDataMember(type_3608, Reflex::Literal("l1muonRefs_"), OffsetOf(__shadow__::__trigger__TriggerRefsCollections, l1muonRefs_), ::Reflex::PRIVATE)
  .AddDataMember(type_3611, Reflex::Literal("l1jetIds_"), OffsetOf(__shadow__::__trigger__TriggerRefsCollections, l1jetIds_), ::Reflex::PRIVATE)
  .AddDataMember(type_3620, Reflex::Literal("l1jetRefs_"), OffsetOf(__shadow__::__trigger__TriggerRefsCollections, l1jetRefs_), ::Reflex::PRIVATE)
  .AddDataMember(type_3611, Reflex::Literal("l1etmissIds_"), OffsetOf(__shadow__::__trigger__TriggerRefsCollections, l1etmissIds_), ::Reflex::PRIVATE)
  .AddDataMember(type_3605, Reflex::Literal("l1etmissRefs_"), OffsetOf(__shadow__::__trigger__TriggerRefsCollections, l1etmissRefs_), ::Reflex::PRIVATE)
  .AddDataMember(type_3611, Reflex::Literal("l1hfringsIds_"), OffsetOf(__shadow__::__trigger__TriggerRefsCollections, l1hfringsIds_), ::Reflex::PRIVATE)
  .AddDataMember(type_3609, Reflex::Literal("l1hfringsRefs_"), OffsetOf(__shadow__::__trigger__TriggerRefsCollections, l1hfringsRefs_), ::Reflex::PRIVATE)
  .AddDataMember(type_3611, Reflex::Literal("pfjetIds_"), OffsetOf(__shadow__::__trigger__TriggerRefsCollections, pfjetIds_), ::Reflex::PRIVATE)
  .AddDataMember(type_3624, Reflex::Literal("pfjetRefs_"), OffsetOf(__shadow__::__trigger__TriggerRefsCollections, pfjetRefs_), ::Reflex::PRIVATE)
  .AddDataMember(type_3611, Reflex::Literal("pftauIds_"), OffsetOf(__shadow__::__trigger__TriggerRefsCollections, pftauIds_), ::Reflex::PRIVATE)
  .AddDataMember(type_3607, Reflex::Literal("pftauRefs_"), OffsetOf(__shadow__::__trigger__TriggerRefsCollections, pftauRefs_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class TriggerRefsCollections -------------------
void __trigger__TriggerRefsCollections_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_17989), Reflex::Literal("swap"), method_18111, 0, "other", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_30903), Reflex::Literal("addObject"), method_18112, 0, "id;ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_30904), Reflex::Literal("addObject"), method_18113, 0, "id;ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_30905), Reflex::Literal("addObject"), method_18114, 0, "id;ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_30906), Reflex::Literal("addObject"), method_18115, 0, "id;ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_30907), Reflex::Literal("addObject"), method_18116, 0, "id;ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_30908), Reflex::Literal("addObject"), method_18117, 0, "id;ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_30909), Reflex::Literal("addObject"), method_18118, 0, "id;ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_30910), Reflex::Literal("addObject"), method_18119, 0, "id;ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_30911), Reflex::Literal("addObject"), method_18120, 0, "id;ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_30912), Reflex::Literal("addObject"), method_18121, 0, "id;ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_30913), Reflex::Literal("addObject"), method_18122, 0, "id;ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_30914), Reflex::Literal("addObject"), method_18123, 0, "id;ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_30915), Reflex::Literal("addObject"), method_18124, 0, "id;ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_30916), Reflex::Literal("addObject"), method_18125, 0, "id;ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_30917), Reflex::Literal("addObject"), method_18126, 0, "id;ref", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3599, type_30901, type_30918), Reflex::Literal("addObjects"), method_18127, 0, "ids;refs", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3599, type_30901, type_30919), Reflex::Literal("addObjects"), method_18128, 0, "ids;refs", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3599, type_30901, type_30920), Reflex::Literal("addObjects"), method_18129, 0, "ids;refs", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3599, type_30901, type_30921), Reflex::Literal("addObjects"), method_18130, 0, "ids;refs", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3599, type_30901, type_30922), Reflex::Literal("addObjects"), method_18131, 0, "ids;refs", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3599, type_30901, type_30923), Reflex::Literal("addObjects"), method_18132, 0, "ids;refs", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3599, type_30901, type_30924), Reflex::Literal("addObjects"), method_18133, 0, "ids;refs", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3599, type_30901, type_30925), Reflex::Literal("addObjects"), method_18134, 0, "ids;refs", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3599, type_30901, type_30926), Reflex::Literal("addObjects"), method_18135, 0, "ids;refs", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3599, type_30901, type_30927), Reflex::Literal("addObjects"), method_18136, 0, "ids;refs", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3599, type_30901, type_30928), Reflex::Literal("addObjects"), method_18137, 0, "ids;refs", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3599, type_30901, type_30929), Reflex::Literal("addObjects"), method_18138, 0, "ids;refs", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3599, type_30901, type_30930), Reflex::Literal("addObjects"), method_18139, 0, "ids;refs", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3599, type_30901, type_30931), Reflex::Literal("addObjects"), method_18140, 0, "ids;refs", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3599, type_30901, type_30932), Reflex::Literal("addObjects"), method_18141, 0, "ids;refs", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_14641, type_14655), Reflex::Literal("getObjects"), method_18142, 0, "ids;refs", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_14641, type_14655, type_3599, type_3599), Reflex::Literal("getObjects"), method_18143, 0, "ids;refs;begin;end", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_14655), Reflex::Literal("getObjects"), method_18144, 0, "id;refs", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_14655, type_3599, type_3599), Reflex::Literal("getObjects"), method_18145, 0, "id;refs;begin;end", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_14641, type_14654), Reflex::Literal("getObjects"), method_18146, 0, "ids;refs", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_14641, type_14654, type_3599, type_3599), Reflex::Literal("getObjects"), method_18147, 0, "ids;refs;begin;end", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_14654), Reflex::Literal("getObjects"), method_18148, 0, "id;refs", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_14654, type_3599, type_3599), Reflex::Literal("getObjects"), method_18149, 0, "id;refs;begin;end", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_14641, type_14653), Reflex::Literal("getObjects"), method_18150, 0, "ids;refs", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_14641, type_14653, type_3599, type_3599), Reflex::Literal("getObjects"), method_18151, 0, "ids;refs;begin;end", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_14653), Reflex::Literal("getObjects"), method_18152, 0, "id;refs", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_14653, type_3599, type_3599), Reflex::Literal("getObjects"), method_18153, 0, "id;refs;begin;end", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_14641, type_14652), Reflex::Literal("getObjects"), method_18154, 0, "ids;refs", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_14641, type_14652, type_3599, type_3599), Reflex::Literal("getObjects"), method_18155, 0, "ids;refs;begin;end", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_14652), Reflex::Literal("getObjects"), method_18156, 0, "id;refs", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_14652, type_3599, type_3599), Reflex::Literal("getObjects"), method_18157, 0, "id;refs;begin;end", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_14641, type_14651), Reflex::Literal("getObjects"), method_18158, 0, "ids;refs", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_14641, type_14651, type_3599, type_3599), Reflex::Literal("getObjects"), method_18159, 0, "ids;refs;begin;end", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_14651), Reflex::Literal("getObjects"), method_18160, 0, "id;refs", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_14651, type_3599, type_3599), Reflex::Literal("getObjects"), method_18161, 0, "id;refs;begin;end", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_14641, type_14650), Reflex::Literal("getObjects"), method_18162, 0, "ids;refs", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_14641, type_14650, type_3599, type_3599), Reflex::Literal("getObjects"), method_18163, 0, "ids;refs;begin;end", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_14650), Reflex::Literal("getObjects"), method_18164, 0, "id;refs", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_14650, type_3599, type_3599), Reflex::Literal("getObjects"), method_18165, 0, "id;refs;begin;end", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_14641, type_14649), Reflex::Literal("getObjects"), method_18166, 0, "ids;refs", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_14641, type_14649, type_3599, type_3599), Reflex::Literal("getObjects"), method_18167, 0, "ids;refs;begin;end", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_14649), Reflex::Literal("getObjects"), method_18168, 0, "id;refs", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_14649, type_3599, type_3599), Reflex::Literal("getObjects"), method_18169, 0, "id;refs;begin;end", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_14641, type_14648), Reflex::Literal("getObjects"), method_18170, 0, "ids;refs", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_14641, type_14648, type_3599, type_3599), Reflex::Literal("getObjects"), method_18171, 0, "ids;refs;begin;end", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_14648), Reflex::Literal("getObjects"), method_18172, 0, "id;refs", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_14648, type_3599, type_3599), Reflex::Literal("getObjects"), method_18173, 0, "id;refs;begin;end", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_14641, type_14647), Reflex::Literal("getObjects"), method_18174, 0, "ids;refs", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_14641, type_14647, type_3599, type_3599), Reflex::Literal("getObjects"), method_18175, 0, "ids;refs;begin;end", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_14647), Reflex::Literal("getObjects"), method_18176, 0, "id;refs", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_14647, type_3599, type_3599), Reflex::Literal("getObjects"), method_18177, 0, "id;refs;begin;end", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_14641, type_14646), Reflex::Literal("getObjects"), method_18178, 0, "ids;refs", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_14641, type_14646, type_3599, type_3599), Reflex::Literal("getObjects"), method_18179, 0, "ids;refs;begin;end", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_14646), Reflex::Literal("getObjects"), method_18180, 0, "id;refs", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_14646, type_3599, type_3599), Reflex::Literal("getObjects"), method_18181, 0, "id;refs;begin;end", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_14641, type_14645), Reflex::Literal("getObjects"), method_18182, 0, "ids;refs", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_14641, type_14645, type_3599, type_3599), Reflex::Literal("getObjects"), method_18183, 0, "ids;refs;begin;end", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_14645), Reflex::Literal("getObjects"), method_18184, 0, "id;refs", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_14645, type_3599, type_3599), Reflex::Literal("getObjects"), method_18185, 0, "id;refs;begin;end", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_14641, type_14644), Reflex::Literal("getObjects"), method_18186, 0, "ids;refs", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_14641, type_14644, type_3599, type_3599), Reflex::Literal("getObjects"), method_18187, 0, "ids;refs;begin;end", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_14644), Reflex::Literal("getObjects"), method_18188, 0, "id;refs", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_14644, type_3599, type_3599), Reflex::Literal("getObjects"), method_18189, 0, "id;refs;begin;end", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_14641, type_14643), Reflex::Literal("getObjects"), method_18190, 0, "ids;refs", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_14641, type_14643, type_3599, type_3599), Reflex::Literal("getObjects"), method_18191, 0, "ids;refs;begin;end", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_14643), Reflex::Literal("getObjects"), method_18192, 0, "id;refs", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_14643, type_3599, type_3599), Reflex::Literal("getObjects"), method_18193, 0, "id;refs;begin;end", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_14641, type_14642), Reflex::Literal("getObjects"), method_18194, 0, "ids;refs", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_14641, type_14642, type_3599, type_3599), Reflex::Literal("getObjects"), method_18195, 0, "ids;refs;begin;end", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_14642), Reflex::Literal("getObjects"), method_18196, 0, "id;refs", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_14642, type_3599, type_3599), Reflex::Literal("getObjects"), method_18197, 0, "id;refs;begin;end", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_14641, type_14640), Reflex::Literal("getObjects"), method_18198, 0, "ids;refs", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_14641, type_14640, type_3599, type_3599), Reflex::Literal("getObjects"), method_18199, 0, "ids;refs;begin;end", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_14640), Reflex::Literal("getObjects"), method_18200, 0, "id;refs", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_71, type_14640, type_3599, type_3599), Reflex::Literal("getObjects"), method_18201, 0, "id;refs;begin;end", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3599), Reflex::Literal("photonSize"), method_18202, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30901), Reflex::Literal("photonIds"), method_18203, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30918), Reflex::Literal("photonRefs"), method_18204, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3599), Reflex::Literal("electronSize"), method_18205, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30901), Reflex::Literal("electronIds"), method_18206, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30919), Reflex::Literal("electronRefs"), method_18207, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3599), Reflex::Literal("muonSize"), method_18208, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30901), Reflex::Literal("muonIds"), method_18209, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30920), Reflex::Literal("muonRefs"), method_18210, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3599), Reflex::Literal("jetSize"), method_18211, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30901), Reflex::Literal("jetIds"), method_18212, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30921), Reflex::Literal("jetRefs"), method_18213, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3599), Reflex::Literal("compositeSize"), method_18214, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30901), Reflex::Literal("compositeIds"), method_18215, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30922), Reflex::Literal("compositeRefs"), method_18216, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3599), Reflex::Literal("basemetSize"), method_18217, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30901), Reflex::Literal("basemetIds"), method_18218, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30923), Reflex::Literal("basemetRefs"), method_18219, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3599), Reflex::Literal("calometSize"), method_18220, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30901), Reflex::Literal("calometIds"), method_18221, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30924), Reflex::Literal("calometRefs"), method_18222, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3599), Reflex::Literal("pixtrackSize"), method_18223, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30901), Reflex::Literal("pixtrackIds"), method_18224, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30925), Reflex::Literal("pixtrackRefs"), method_18225, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3599), Reflex::Literal("l1emSize"), method_18226, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30901), Reflex::Literal("l1emIds"), method_18227, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30926), Reflex::Literal("l1emRefs"), method_18228, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3599), Reflex::Literal("l1muonSize"), method_18229, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30901), Reflex::Literal("l1muonIds"), method_18230, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30927), Reflex::Literal("l1muonRefs"), method_18231, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3599), Reflex::Literal("l1jetSize"), method_18232, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30901), Reflex::Literal("l1jetIds"), method_18233, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30928), Reflex::Literal("l1jetRefs"), method_18234, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3599), Reflex::Literal("l1etmissSize"), method_18235, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30901), Reflex::Literal("l1etmissIds"), method_18236, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30929), Reflex::Literal("l1etmissRefs"), method_18237, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3599), Reflex::Literal("l1hfringsSize"), method_18238, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30901), Reflex::Literal("l1hfringsIds"), method_18239, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30930), Reflex::Literal("l1hfringsRefs"), method_18240, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3599), Reflex::Literal("pfjetSize"), method_18241, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30901), Reflex::Literal("pfjetIds"), method_18242, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30931), Reflex::Literal("pfjetRefs"), method_18243, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3599), Reflex::Literal("pftauSize"), method_18244, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30901), Reflex::Literal("pftauIds"), method_18245, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30932), Reflex::Literal("pftauRefs"), method_18246, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<trigger::HLTPrescaleTable> -------------------------------
static void constructor_21679( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<trigger::HLTPrescaleTable>();
  else ::new(mem) ::edm::Wrapper<trigger::HLTPrescaleTable>();
}

static void constructor_21680( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<trigger::HLTPrescaleTable>(*(::std::auto_ptr<trigger::HLTPrescaleTable>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<trigger::HLTPrescaleTable>(*(::std::auto_ptr<trigger::HLTPrescaleTable>*)arg[0]);
}

static void destructor_21681(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<trigger::HLTPrescaleTable>*)o)->::edm::Wrapper<trigger::HLTPrescaleTable>::~Wrapper)();
}
static  void method_21682( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<trigger::HLTPrescaleTable>*)o)->product)());
  else   (((const ::edm::Wrapper<trigger::HLTPrescaleTable>*)o)->product)();
}

static  void operator_21683( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<trigger::HLTPrescaleTable>*)o)->operator->)());
  else   (((const ::edm::Wrapper<trigger::HLTPrescaleTable>*)o)->operator->)();
}

static  void method_21684( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<trigger::HLTPrescaleTable>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<trigger::HLTPrescaleTable>*)o)->productTypeInfo)();
}

static  void method_21685( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<trigger::HLTPrescaleTable>*)o)->typeInfo)();
  else   (((::edm::Wrapper<trigger::HLTPrescaleTable>*)o)->typeInfo)();
}

static void constructor_21686( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<trigger::HLTPrescaleTable>((::trigger::HLTPrescaleTable*)arg[0]);
  else ::new(mem) ::edm::Wrapper<trigger::HLTPrescaleTable>((::trigger::HLTPrescaleTable*)arg[0]);
}

static  void method_21687( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<trigger::HLTPrescaleTable>*)o)->getInterface)());
  else   (((::edm::Wrapper<trigger::HLTPrescaleTable>*)o)->getInterface)();
}

static  void method_21688( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<trigger::HLTPrescaleTable>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_21689( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<trigger::HLTPrescaleTable>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_21690( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<trigger::HLTPrescaleTable>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_21691( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<trigger::HLTPrescaleTable>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<trigger::HLTPrescaleTable>*)o)->dynamicTypeInfo)();
}

static  void method_21692( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<trigger::HLTPrescaleTable>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<trigger::HLTPrescaleTable>*)o)->isPresent)();
}

static  void method_21693( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<trigger::HLTPrescaleTable>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<trigger::HLTPrescaleTable>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4394( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<trigger::HLTPrescaleTable> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<trigger::HLTPrescaleTable> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<trigger::HLTPrescaleTable> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<trigger::HLTPrescaleTable> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<trigger::HLTPrescaleTable> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<trigger::HLTPrescaleTable> -------------------------------
void __edm__Wrapper_trigger__HLTPrescaleTable__db_datamem(Reflex::Class*);
void __edm__Wrapper_trigger__HLTPrescaleTable__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_trigger__HLTPrescaleTable__datamem_bld(&__edm__Wrapper_trigger__HLTPrescaleTable__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_trigger__HLTPrescaleTable__funcmem_bld(&__edm__Wrapper_trigger__HLTPrescaleTable__db_funcmem);
void __edm__Wrapper_trigger__HLTPrescaleTable__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<trigger::HLTPrescaleTable>"), typeid(::edm::Wrapper<trigger::HLTPrescaleTable>), sizeof(::edm::Wrapper<trigger::HLTPrescaleTable>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3619, Reflex::Literal("edm::Wrapper<trigger::HLTPrescaleTable>::value_type"))
  .AddTypedef(type_3619, Reflex::Literal("edm::Wrapper<trigger::HLTPrescaleTable>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_21679, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2452), Reflex::Literal("Wrapper"), constructor_21680, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_21681, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35344), Reflex::Literal("Wrapper"), constructor_21686, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4394, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_trigger__HLTPrescaleTable__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_trigger__HLTPrescaleTable__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<trigger::HLTPrescaleTable> -------------------
void __edm__Wrapper_trigger__HLTPrescaleTable__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1374, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_trigger__HLTPrescaleTable_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3619, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_trigger__HLTPrescaleTable_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<trigger::HLTPrescaleTable> -------------------
void __edm__Wrapper_trigger__HLTPrescaleTable__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35343), Reflex::Literal("product"), method_21682, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35343), Reflex::Literal("operator->"), operator_21683, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5473), Reflex::Literal("productTypeInfo"), method_21684, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5473), Reflex::Literal("typeInfo"), method_21685, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35345), Reflex::Literal("getInterface"), method_21687, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_21974, type_23583, type_31062), Reflex::Literal("fillView"), method_21688, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_5473, type_292, type_7999), Reflex::Literal("setPtr"), method_21689, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_5473, type_23585, type_23583), Reflex::Literal("fillPtrVector"), method_21690, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5473), Reflex::Literal("dynamicTypeInfo"), method_21691, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1374), Reflex::Literal("isPresent"), method_21692, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5473), Reflex::Literal("dynamicTypeInfo_"), method_21693, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<trigger::TriggerEventWithRefs> -------------------------------
static void constructor_21700( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<trigger::TriggerEventWithRefs>();
  else ::new(mem) ::edm::Wrapper<trigger::TriggerEventWithRefs>();
}

static void constructor_21701( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<trigger::TriggerEventWithRefs>(*(::std::auto_ptr<trigger::TriggerEventWithRefs>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<trigger::TriggerEventWithRefs>(*(::std::auto_ptr<trigger::TriggerEventWithRefs>*)arg[0]);
}

static void destructor_21702(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<trigger::TriggerEventWithRefs>*)o)->::edm::Wrapper<trigger::TriggerEventWithRefs>::~Wrapper)();
}
static  void method_21703( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<trigger::TriggerEventWithRefs>*)o)->product)());
  else   (((const ::edm::Wrapper<trigger::TriggerEventWithRefs>*)o)->product)();
}

static  void operator_21704( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<trigger::TriggerEventWithRefs>*)o)->operator->)());
  else   (((const ::edm::Wrapper<trigger::TriggerEventWithRefs>*)o)->operator->)();
}

static  void method_21705( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<trigger::TriggerEventWithRefs>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<trigger::TriggerEventWithRefs>*)o)->productTypeInfo)();
}

static  void method_21706( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<trigger::TriggerEventWithRefs>*)o)->typeInfo)();
  else   (((::edm::Wrapper<trigger::TriggerEventWithRefs>*)o)->typeInfo)();
}

static void constructor_21707( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<trigger::TriggerEventWithRefs>((::trigger::TriggerEventWithRefs*)arg[0]);
  else ::new(mem) ::edm::Wrapper<trigger::TriggerEventWithRefs>((::trigger::TriggerEventWithRefs*)arg[0]);
}

static  void method_21708( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<trigger::TriggerEventWithRefs>*)o)->getInterface)());
  else   (((::edm::Wrapper<trigger::TriggerEventWithRefs>*)o)->getInterface)();
}

static  void method_21709( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<trigger::TriggerEventWithRefs>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_21710( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<trigger::TriggerEventWithRefs>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_21711( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<trigger::TriggerEventWithRefs>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_21712( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<trigger::TriggerEventWithRefs>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<trigger::TriggerEventWithRefs>*)o)->dynamicTypeInfo)();
}

static  void method_21713( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<trigger::TriggerEventWithRefs>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<trigger::TriggerEventWithRefs>*)o)->isPresent)();
}

static  void method_21714( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<trigger::TriggerEventWithRefs>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<trigger::TriggerEventWithRefs>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4395( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<trigger::TriggerEventWithRefs> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<trigger::TriggerEventWithRefs> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<trigger::TriggerEventWithRefs> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<trigger::TriggerEventWithRefs> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<trigger::TriggerEventWithRefs> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<trigger::TriggerEventWithRefs> -------------------------------
void __edm__Wrapper_trigger__TriggerEventWithRefs__db_datamem(Reflex::Class*);
void __edm__Wrapper_trigger__TriggerEventWithRefs__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_trigger__TriggerEventWithRefs__datamem_bld(&__edm__Wrapper_trigger__TriggerEventWithRefs__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_trigger__TriggerEventWithRefs__funcmem_bld(&__edm__Wrapper_trigger__TriggerEventWithRefs__db_funcmem);
void __edm__Wrapper_trigger__TriggerEventWithRefs__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<trigger::TriggerEventWithRefs>"), typeid(::edm::Wrapper<trigger::TriggerEventWithRefs>), sizeof(::edm::Wrapper<trigger::TriggerEventWithRefs>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("splitLevel"), "0")
  .AddTypedef(type_3600, Reflex::Literal("edm::Wrapper<trigger::TriggerEventWithRefs>::value_type"))
  .AddTypedef(type_3600, Reflex::Literal("edm::Wrapper<trigger::TriggerEventWithRefs>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_21700, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2453), Reflex::Literal("Wrapper"), constructor_21701, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_21702, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35349), Reflex::Literal("Wrapper"), constructor_21707, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4395, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_trigger__TriggerEventWithRefs__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_trigger__TriggerEventWithRefs__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<trigger::TriggerEventWithRefs> -------------------
void __edm__Wrapper_trigger__TriggerEventWithRefs__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1374, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_trigger__TriggerEventWithRefs_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3600, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_trigger__TriggerEventWithRefs_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<trigger::TriggerEventWithRefs> -------------------
void __edm__Wrapper_trigger__TriggerEventWithRefs__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35348), Reflex::Literal("product"), method_21703, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35348), Reflex::Literal("operator->"), operator_21704, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5473), Reflex::Literal("productTypeInfo"), method_21705, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5473), Reflex::Literal("typeInfo"), method_21706, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35350), Reflex::Literal("getInterface"), method_21708, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_21974, type_23583, type_31062), Reflex::Literal("fillView"), method_21709, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_5473, type_292, type_7999), Reflex::Literal("setPtr"), method_21710, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_5473, type_23585, type_23583), Reflex::Literal("fillPtrVector"), method_21711, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5473), Reflex::Literal("dynamicTypeInfo"), method_21712, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1374), Reflex::Literal("isPresent"), method_21713, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5473), Reflex::Literal("dynamicTypeInfo_"), method_21714, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<trigger::TriggerEvent> -------------------------------
static void constructor_21721( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<trigger::TriggerEvent>();
  else ::new(mem) ::edm::Wrapper<trigger::TriggerEvent>();
}

static void constructor_21722( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<trigger::TriggerEvent>(*(::std::auto_ptr<trigger::TriggerEvent>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<trigger::TriggerEvent>(*(::std::auto_ptr<trigger::TriggerEvent>*)arg[0]);
}

static void destructor_21723(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<trigger::TriggerEvent>*)o)->::edm::Wrapper<trigger::TriggerEvent>::~Wrapper)();
}
static  void method_21724( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<trigger::TriggerEvent>*)o)->product)());
  else   (((const ::edm::Wrapper<trigger::TriggerEvent>*)o)->product)();
}

static  void operator_21725( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<trigger::TriggerEvent>*)o)->operator->)());
  else   (((const ::edm::Wrapper<trigger::TriggerEvent>*)o)->operator->)();
}

static  void method_21726( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<trigger::TriggerEvent>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<trigger::TriggerEvent>*)o)->productTypeInfo)();
}

static  void method_21727( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<trigger::TriggerEvent>*)o)->typeInfo)();
  else   (((::edm::Wrapper<trigger::TriggerEvent>*)o)->typeInfo)();
}

static void constructor_21728( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<trigger::TriggerEvent>((::trigger::TriggerEvent*)arg[0]);
  else ::new(mem) ::edm::Wrapper<trigger::TriggerEvent>((::trigger::TriggerEvent*)arg[0]);
}

static  void method_21729( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<trigger::TriggerEvent>*)o)->getInterface)());
  else   (((::edm::Wrapper<trigger::TriggerEvent>*)o)->getInterface)();
}

static  void method_21730( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<trigger::TriggerEvent>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_21731( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<trigger::TriggerEvent>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_21732( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<trigger::TriggerEvent>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_21733( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<trigger::TriggerEvent>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<trigger::TriggerEvent>*)o)->dynamicTypeInfo)();
}

static  void method_21734( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<trigger::TriggerEvent>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<trigger::TriggerEvent>*)o)->isPresent)();
}

static  void method_21735( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<trigger::TriggerEvent>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<trigger::TriggerEvent>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4396( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<trigger::TriggerEvent> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<trigger::TriggerEvent> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<trigger::TriggerEvent> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<trigger::TriggerEvent> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<trigger::TriggerEvent> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<trigger::TriggerEvent> -------------------------------
void __edm__Wrapper_trigger__TriggerEvent__db_datamem(Reflex::Class*);
void __edm__Wrapper_trigger__TriggerEvent__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_trigger__TriggerEvent__datamem_bld(&__edm__Wrapper_trigger__TriggerEvent__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_trigger__TriggerEvent__funcmem_bld(&__edm__Wrapper_trigger__TriggerEvent__db_funcmem);
void __edm__Wrapper_trigger__TriggerEvent__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<trigger::TriggerEvent>"), typeid(::edm::Wrapper<trigger::TriggerEvent>), sizeof(::edm::Wrapper<trigger::TriggerEvent>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("splitLevel"), "0")
  .AddTypedef(type_3621, Reflex::Literal("edm::Wrapper<trigger::TriggerEvent>::value_type"))
  .AddTypedef(type_3621, Reflex::Literal("edm::Wrapper<trigger::TriggerEvent>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_21721, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2454), Reflex::Literal("Wrapper"), constructor_21722, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_21723, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35354), Reflex::Literal("Wrapper"), constructor_21728, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4396, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_trigger__TriggerEvent__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_trigger__TriggerEvent__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<trigger::TriggerEvent> -------------------
void __edm__Wrapper_trigger__TriggerEvent__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1374, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_trigger__TriggerEvent_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3621, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_trigger__TriggerEvent_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<trigger::TriggerEvent> -------------------
void __edm__Wrapper_trigger__TriggerEvent__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35353), Reflex::Literal("product"), method_21724, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35353), Reflex::Literal("operator->"), operator_21725, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5473), Reflex::Literal("productTypeInfo"), method_21726, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5473), Reflex::Literal("typeInfo"), method_21727, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35355), Reflex::Literal("getInterface"), method_21729, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_21974, type_23583, type_31062), Reflex::Literal("fillView"), method_21730, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_5473, type_292, type_7999), Reflex::Literal("setPtr"), method_21731, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_5473, type_23585, type_23583), Reflex::Literal("fillPtrVector"), method_21732, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5473), Reflex::Literal("dynamicTypeInfo"), method_21733, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1374), Reflex::Literal("isPresent"), method_21734, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5473), Reflex::Literal("dynamicTypeInfo_"), method_21735, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<trigger::TriggerFilterObjectWithRefs> -------------------------------
static void constructor_21742( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<trigger::TriggerFilterObjectWithRefs>();
  else ::new(mem) ::edm::Wrapper<trigger::TriggerFilterObjectWithRefs>();
}

static void constructor_21743( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<trigger::TriggerFilterObjectWithRefs>(*(::std::auto_ptr<trigger::TriggerFilterObjectWithRefs>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<trigger::TriggerFilterObjectWithRefs>(*(::std::auto_ptr<trigger::TriggerFilterObjectWithRefs>*)arg[0]);
}

static void destructor_21744(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<trigger::TriggerFilterObjectWithRefs>*)o)->::edm::Wrapper<trigger::TriggerFilterObjectWithRefs>::~Wrapper)();
}
static  void method_21745( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<trigger::TriggerFilterObjectWithRefs>*)o)->product)());
  else   (((const ::edm::Wrapper<trigger::TriggerFilterObjectWithRefs>*)o)->product)();
}

static  void operator_21746( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<trigger::TriggerFilterObjectWithRefs>*)o)->operator->)());
  else   (((const ::edm::Wrapper<trigger::TriggerFilterObjectWithRefs>*)o)->operator->)();
}

static  void method_21747( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<trigger::TriggerFilterObjectWithRefs>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<trigger::TriggerFilterObjectWithRefs>*)o)->productTypeInfo)();
}

static  void method_21748( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<trigger::TriggerFilterObjectWithRefs>*)o)->typeInfo)();
  else   (((::edm::Wrapper<trigger::TriggerFilterObjectWithRefs>*)o)->typeInfo)();
}

static void constructor_21749( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<trigger::TriggerFilterObjectWithRefs>((::trigger::TriggerFilterObjectWithRefs*)arg[0]);
  else ::new(mem) ::edm::Wrapper<trigger::TriggerFilterObjectWithRefs>((::trigger::TriggerFilterObjectWithRefs*)arg[0]);
}

static  void method_21750( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<trigger::TriggerFilterObjectWithRefs>*)o)->getInterface)());
  else   (((::edm::Wrapper<trigger::TriggerFilterObjectWithRefs>*)o)->getInterface)();
}

static  void method_21751( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<trigger::TriggerFilterObjectWithRefs>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_21752( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<trigger::TriggerFilterObjectWithRefs>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_21753( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<trigger::TriggerFilterObjectWithRefs>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_21754( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<trigger::TriggerFilterObjectWithRefs>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<trigger::TriggerFilterObjectWithRefs>*)o)->dynamicTypeInfo)();
}

static  void method_21755( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<trigger::TriggerFilterObjectWithRefs>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<trigger::TriggerFilterObjectWithRefs>*)o)->isPresent)();
}

static  void method_21756( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<trigger::TriggerFilterObjectWithRefs>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<trigger::TriggerFilterObjectWithRefs>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4397( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<trigger::TriggerFilterObjectWithRefs> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<trigger::TriggerFilterObjectWithRefs> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<trigger::TriggerFilterObjectWithRefs> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<trigger::TriggerFilterObjectWithRefs> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<trigger::TriggerFilterObjectWithRefs> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<trigger::TriggerFilterObjectWithRefs> -------------------------------
void __edm__Wrapper_trigger__TriggerFilterObjectWithRefs__db_datamem(Reflex::Class*);
void __edm__Wrapper_trigger__TriggerFilterObjectWithRefs__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_trigger__TriggerFilterObjectWithRefs__datamem_bld(&__edm__Wrapper_trigger__TriggerFilterObjectWithRefs__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_trigger__TriggerFilterObjectWithRefs__funcmem_bld(&__edm__Wrapper_trigger__TriggerFilterObjectWithRefs__db_funcmem);
void __edm__Wrapper_trigger__TriggerFilterObjectWithRefs__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<trigger::TriggerFilterObjectWithRefs>"), typeid(::edm::Wrapper<trigger::TriggerFilterObjectWithRefs>), sizeof(::edm::Wrapper<trigger::TriggerFilterObjectWithRefs>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("splitLevel"), "0")
  .AddTypedef(type_3614, Reflex::Literal("edm::Wrapper<trigger::TriggerFilterObjectWithRefs>::value_type"))
  .AddTypedef(type_3614, Reflex::Literal("edm::Wrapper<trigger::TriggerFilterObjectWithRefs>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_21742, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2455), Reflex::Literal("Wrapper"), constructor_21743, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_21744, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35359), Reflex::Literal("Wrapper"), constructor_21749, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4397, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_trigger__TriggerFilterObjectWithRefs__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_trigger__TriggerFilterObjectWithRefs__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<trigger::TriggerFilterObjectWithRefs> -------------------
void __edm__Wrapper_trigger__TriggerFilterObjectWithRefs__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1374, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_trigger__TriggerFilterObjectWithRefs_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_3614, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_trigger__TriggerFilterObjectWithRefs_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<trigger::TriggerFilterObjectWithRefs> -------------------
void __edm__Wrapper_trigger__TriggerFilterObjectWithRefs__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35358), Reflex::Literal("product"), method_21745, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35358), Reflex::Literal("operator->"), operator_21746, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5473), Reflex::Literal("productTypeInfo"), method_21747, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5473), Reflex::Literal("typeInfo"), method_21748, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35360), Reflex::Literal("getInterface"), method_21750, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_21974, type_23583, type_31062), Reflex::Literal("fillView"), method_21751, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_5473, type_292, type_7999), Reflex::Literal("setPtr"), method_21752, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_5473, type_23585, type_23583), Reflex::Literal("fillPtrVector"), method_21753, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5473), Reflex::Literal("dynamicTypeInfo"), method_21754, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1374), Reflex::Literal("isPresent"), method_21755, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5473), Reflex::Literal("dynamicTypeInfo_"), method_21756, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<HLTPerformanceInfo> -------------------------------
static void constructor_21826( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<HLTPerformanceInfo>();
  else ::new(mem) ::edm::Wrapper<HLTPerformanceInfo>();
}

static void constructor_21827( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<HLTPerformanceInfo>(*(::std::auto_ptr<HLTPerformanceInfo>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<HLTPerformanceInfo>(*(::std::auto_ptr<HLTPerformanceInfo>*)arg[0]);
}

static void destructor_21828(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<HLTPerformanceInfo>*)o)->::edm::Wrapper<HLTPerformanceInfo>::~Wrapper)();
}
static  void method_21829( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<HLTPerformanceInfo>*)o)->product)());
  else   (((const ::edm::Wrapper<HLTPerformanceInfo>*)o)->product)();
}

static  void operator_21830( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<HLTPerformanceInfo>*)o)->operator->)());
  else   (((const ::edm::Wrapper<HLTPerformanceInfo>*)o)->operator->)();
}

static  void method_21831( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<HLTPerformanceInfo>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<HLTPerformanceInfo>*)o)->productTypeInfo)();
}

static  void method_21832( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<HLTPerformanceInfo>*)o)->typeInfo)();
  else   (((::edm::Wrapper<HLTPerformanceInfo>*)o)->typeInfo)();
}

static void constructor_21833( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<HLTPerformanceInfo>((::HLTPerformanceInfo*)arg[0]);
  else ::new(mem) ::edm::Wrapper<HLTPerformanceInfo>((::HLTPerformanceInfo*)arg[0]);
}

static  void method_21834( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<HLTPerformanceInfo>*)o)->getInterface)());
  else   (((::edm::Wrapper<HLTPerformanceInfo>*)o)->getInterface)();
}

static  void method_21835( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<HLTPerformanceInfo>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_21836( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<HLTPerformanceInfo>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_21837( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<HLTPerformanceInfo>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_21838( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<HLTPerformanceInfo>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<HLTPerformanceInfo>*)o)->dynamicTypeInfo)();
}

static  void method_21839( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<HLTPerformanceInfo>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<HLTPerformanceInfo>*)o)->isPresent)();
}

static  void method_21840( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<HLTPerformanceInfo>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<HLTPerformanceInfo>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4401( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<HLTPerformanceInfo> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<HLTPerformanceInfo> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<HLTPerformanceInfo> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<HLTPerformanceInfo> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<HLTPerformanceInfo> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<HLTPerformanceInfo> -------------------------------
void __edm__Wrapper_HLTPerformanceInfo__db_datamem(Reflex::Class*);
void __edm__Wrapper_HLTPerformanceInfo__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_HLTPerformanceInfo__datamem_bld(&__edm__Wrapper_HLTPerformanceInfo__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_HLTPerformanceInfo__funcmem_bld(&__edm__Wrapper_HLTPerformanceInfo__db_funcmem);
void __edm__Wrapper_HLTPerformanceInfo__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<HLTPerformanceInfo>"), typeid(::edm::Wrapper<HLTPerformanceInfo>), sizeof(::edm::Wrapper<HLTPerformanceInfo>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("splitLevel"), "0")
  .AddTypedef(type_1073, Reflex::Literal("edm::Wrapper<HLTPerformanceInfo>::value_type"))
  .AddTypedef(type_1073, Reflex::Literal("edm::Wrapper<HLTPerformanceInfo>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_21826, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2459), Reflex::Literal("Wrapper"), constructor_21827, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_21828, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3512), Reflex::Literal("Wrapper"), constructor_21833, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4401, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_HLTPerformanceInfo__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_HLTPerformanceInfo__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<HLTPerformanceInfo> -------------------
void __edm__Wrapper_HLTPerformanceInfo__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1374, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_HLTPerformanceInfo_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1073, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_HLTPerformanceInfo_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<HLTPerformanceInfo> -------------------
void __edm__Wrapper_HLTPerformanceInfo__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3514), Reflex::Literal("product"), method_21829, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3514), Reflex::Literal("operator->"), operator_21830, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5473), Reflex::Literal("productTypeInfo"), method_21831, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5473), Reflex::Literal("typeInfo"), method_21832, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35378), Reflex::Literal("getInterface"), method_21834, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_21974, type_23583, type_31062), Reflex::Literal("fillView"), method_21835, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_5473, type_292, type_7999), Reflex::Literal("setPtr"), method_21836, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_5473, type_23585, type_23583), Reflex::Literal("fillPtrVector"), method_21837, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5473), Reflex::Literal("dynamicTypeInfo"), method_21838, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1374), Reflex::Literal("isPresent"), method_21839, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5473), Reflex::Literal("dynamicTypeInfo_"), method_21840, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class EventTime -------------------------------
static  void operator_22315( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::EventTime*)o)->operator=)(*(const ::edm::EventTime*)arg[0]);
  else   (((::edm::EventTime*)o)->operator=)(*(const ::edm::EventTime*)arg[0]);
}

static void constructor_22316( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::EventTime(*(const ::edm::EventTime*)arg[0]);
  else ::new(mem) ::edm::EventTime(*(const ::edm::EventTime*)arg[0]);
}

static void constructor_22317( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::EventTime();
  else ::new(mem) ::edm::EventTime();
}

static void destructor_22318(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::EventTime*)o)->::edm::EventTime::~EventTime)();
}
static  void method_22319( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::edm::EventTime*)o)->size)());
  else   (((const ::edm::EventTime*)o)->size)();
}

static  void method_22320( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::EventTime*)o)->moduleTime)(*(unsigned int*)arg[0]);
  else   (((::edm::EventTime*)o)->moduleTime)(*(unsigned int*)arg[0]);
}

static  void method_22321( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::edm::EventTime*)o)->tot_time)());
  else   (((const ::edm::EventTime*)o)->tot_time)();
}

static  void method_22322( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::edm::EventTime*)o)->name)(*(unsigned int*)arg[0]));
  else   (((const ::edm::EventTime*)o)->name)(*(unsigned int*)arg[0]);
}

static  void method_22323( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::edm::EventTime*)o)->time)(*(unsigned int*)arg[0]));
  else   (((const ::edm::EventTime*)o)->time)(*(unsigned int*)arg[0]);
}

static  void method_22324( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::edm::EventTime*)o)->addModuleTime)(*(const ::edm::ModuleTime*)arg[0]);
}

static  void method_22325( void*, void* o, const std::vector<void*>&, void*)
{
  (((::edm::EventTime*)o)->reset)();
}

static void method_newdel_4572( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::EventTime >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::EventTime >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::EventTime >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::EventTime >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::EventTime >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class EventTime -------------------------------
void __edm__EventTime_db_datamem(Reflex::Class*);
void __edm__EventTime_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__EventTime_datamem_bld(&__edm__EventTime_db_datamem);
Reflex::GenreflexMemberBuilder __edm__EventTime_funcmem_bld(&__edm__EventTime_db_funcmem);
void __edm__EventTime_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::EventTime"), typeid(::edm::EventTime), sizeof(::edm::EventTime), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35504, type_35505), Reflex::Literal("operator="), operator_22315, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35505), Reflex::Literal("EventTime"), constructor_22316, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("EventTime"), constructor_22317, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~EventTime"), destructor_22318, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4572, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__EventTime_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__EventTime_funcmem_bld);
}

//------Delayed data member builder for class EventTime -------------------
void __edm__EventTime_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2768, Reflex::Literal("moduleSet"), OffsetOf(__shadow__::__edm__EventTime, moduleSet), ::Reflex::PRIVATE)
  .AddDataMember(type_108, Reflex::Literal("tot_time_"), OffsetOf(__shadow__::__edm__EventTime, tot_time_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class EventTime -------------------
void __edm__EventTime_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_301), Reflex::Literal("size"), method_22319, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_14377, type_301), Reflex::Literal("moduleTime"), method_22320, 0, "i", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_108), Reflex::Literal("tot_time"), method_22321, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2202, type_301), Reflex::Literal("name"), method_22322, 0, "i", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_108, type_301), Reflex::Literal("time"), method_22323, 0, "i", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_14377), Reflex::Literal("addModuleTime"), method_22324, 0, "m", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166), Reflex::Literal("reset"), method_22325, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class Wrapper<edm::EventTime> -------------------------------
static void constructor_21847( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::EventTime>();
  else ::new(mem) ::edm::Wrapper<edm::EventTime>();
}

static void constructor_21848( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::EventTime>(*(::std::auto_ptr<edm::EventTime>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::EventTime>(*(::std::auto_ptr<edm::EventTime>*)arg[0]);
}

static void destructor_21849(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<edm::EventTime>*)o)->::edm::Wrapper<edm::EventTime>::~Wrapper)();
}
static  void method_21850( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::EventTime>*)o)->product)());
  else   (((const ::edm::Wrapper<edm::EventTime>*)o)->product)();
}

static  void operator_21851( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<edm::EventTime>*)o)->operator->)());
  else   (((const ::edm::Wrapper<edm::EventTime>*)o)->operator->)();
}

static  void method_21852( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::EventTime>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<edm::EventTime>*)o)->productTypeInfo)();
}

static  void method_21853( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<edm::EventTime>*)o)->typeInfo)();
  else   (((::edm::Wrapper<edm::EventTime>*)o)->typeInfo)();
}

static void constructor_21854( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<edm::EventTime>((::edm::EventTime*)arg[0]);
  else ::new(mem) ::edm::Wrapper<edm::EventTime>((::edm::EventTime*)arg[0]);
}

static  void method_21855( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<edm::EventTime>*)o)->getInterface)());
  else   (((::edm::Wrapper<edm::EventTime>*)o)->getInterface)();
}

static  void method_21856( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::EventTime>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_21857( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::EventTime>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_21858( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<edm::EventTime>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_21859( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::EventTime>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<edm::EventTime>*)o)->dynamicTypeInfo)();
}

static  void method_21860( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<edm::EventTime>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<edm::EventTime>*)o)->isPresent)();
}

static  void method_21861( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<edm::EventTime>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<edm::EventTime>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4402( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::EventTime> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::EventTime> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::EventTime> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::EventTime> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<edm::EventTime> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<edm::EventTime> -------------------------------
void __edm__Wrapper_edm__EventTime__db_datamem(Reflex::Class*);
void __edm__Wrapper_edm__EventTime__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__EventTime__datamem_bld(&__edm__Wrapper_edm__EventTime__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_edm__EventTime__funcmem_bld(&__edm__Wrapper_edm__EventTime__db_funcmem);
void __edm__Wrapper_edm__EventTime__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<edm::EventTime>"), typeid(::edm::Wrapper<edm::EventTime>), sizeof(::edm::Wrapper<edm::EventTime>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("splitLevel"), "0")
  .AddTypedef(type_4572, Reflex::Literal("edm::Wrapper<edm::EventTime>::value_type"))
  .AddTypedef(type_4572, Reflex::Literal("edm::Wrapper<edm::EventTime>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_21847, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2460), Reflex::Literal("Wrapper"), constructor_21848, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_21849, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35382), Reflex::Literal("Wrapper"), constructor_21854, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4402, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_edm__EventTime__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_edm__EventTime__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<edm::EventTime> -------------------
void __edm__Wrapper_edm__EventTime__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1374, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_edm__EventTime_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_4572, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_edm__EventTime_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<edm::EventTime> -------------------
void __edm__Wrapper_edm__EventTime__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35381), Reflex::Literal("product"), method_21850, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35381), Reflex::Literal("operator->"), operator_21851, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5473), Reflex::Literal("productTypeInfo"), method_21852, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5473), Reflex::Literal("typeInfo"), method_21853, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35383), Reflex::Literal("getInterface"), method_21855, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_21974, type_23583, type_31062), Reflex::Literal("fillView"), method_21856, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_5473, type_292, type_7999), Reflex::Literal("setPtr"), method_21857, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_5473, type_23585, type_23583), Reflex::Literal("fillPtrVector"), method_21858, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5473), Reflex::Literal("dynamicTypeInfo"), method_21859, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1374), Reflex::Literal("isPresent"), method_21860, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5473), Reflex::Literal("dynamicTypeInfo_"), method_21861, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HLTResult<24,short unsigned int> -------------------------------
static void destructor_24584(void*, void * o, const std::vector<void*>&, void *) {
(((::reco::HLTResult<24,unsigned short>*)o)->::reco::HLTResult<24,unsigned short>::~HLTResult)();
}
static  void operator_24585( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::HLTResult<24,unsigned short>*)o)->operator=)(*(const ::reco::HLTResult<24,unsigned short>*)arg[0]);
  else   (((::reco::HLTResult<24,unsigned short>*)o)->operator=)(*(const ::reco::HLTResult<24,unsigned short>*)arg[0]);
}

static void constructor_24586( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::HLTResult<24,unsigned short>(*(const ::reco::HLTResult<24,unsigned short>*)arg[0]);
  else ::new(mem) ::reco::HLTResult<24,unsigned short>(*(const ::reco::HLTResult<24,unsigned short>*)arg[0]);
}

static void constructor_24587( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::HLTResult<24,unsigned short>();
  else ::new(mem) ::reco::HLTResult<24,unsigned short>();
}

static void constructor_24588( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::HLTResult<24,unsigned short>((unsigned short*)arg[0]);
  else ::new(mem) ::reco::HLTResult<24,unsigned short>((unsigned short*)arg[0]);
}

static void method_newdel_5547( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::reco::HLTResult<24,unsigned short> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::reco::HLTResult<24,unsigned short> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::reco::HLTResult<24,unsigned short> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::reco::HLTResult<24,unsigned short> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::reco::HLTResult<24,unsigned short> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HLTResult<24,short unsigned int> -------------------------------
void __reco__HLTResult_24_unsignedsshort__db_datamem(Reflex::Class*);
void __reco__HLTResult_24_unsignedsshort__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __reco__HLTResult_24_unsignedsshort__datamem_bld(&__reco__HLTResult_24_unsignedsshort__db_datamem);
Reflex::GenreflexMemberBuilder __reco__HLTResult_24_unsignedsshort__funcmem_bld(&__reco__HLTResult_24_unsignedsshort__db_funcmem);
void __reco__HLTResult_24_unsignedsshort__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("reco::HLTResult<24,unsigned short>"), typeid(::reco::HLTResult<24,unsigned short>), sizeof(::reco::HLTResult<24,unsigned short>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3810, Reflex::Literal("reco::HLTResult<24,unsigned short>::boost_static_assert_typedef_40"))
  .AddTypedef(type_24413, Reflex::Literal("reco::HLTResult<24,unsigned short>::wordConstants"))
  .AddEnum(Reflex::Literal("_63"), Reflex::Literal("wordSize=2;size=12"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PRIVATE | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HLTResult"), destructor_24584, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_36347, type_36348), Reflex::Literal("operator="), operator_24585, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_36348), Reflex::Literal("HLTResult"), constructor_24586, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HLTResult"), constructor_24587, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3458), Reflex::Literal("HLTResult"), constructor_24588, 0, "w", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5547, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__reco__HLTResult_24_unsignedsshort__datamem_bld);
}

//------Delayed data member builder for class HLTResult<24,short unsigned int> -------------------
void __reco__HLTResult_24_unsignedsshort__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_36346, Reflex::Literal("words_"), OffsetOf(__shadow__::__reco__HLTResult_24_unsignedsshort_, words_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class HLTResult<24,short unsigned int> -------------------
void __reco__HLTResult_24_unsignedsshort__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class Wrapper<reco::HLTResult<24, short unsigned int> > -------------------------------
static void constructor_21868( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::HLTResult<24,unsigned short> >();
  else ::new(mem) ::edm::Wrapper<reco::HLTResult<24,unsigned short> >();
}

static void constructor_21869( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::HLTResult<24,unsigned short> >(*(::std::auto_ptr<reco::HLTResult<24,unsigned short> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<reco::HLTResult<24,unsigned short> >(*(::std::auto_ptr<reco::HLTResult<24,unsigned short> >*)arg[0]);
}

static void destructor_21870(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<reco::HLTResult<24,unsigned short> >*)o)->::edm::Wrapper<reco::HLTResult<24,unsigned short> >::~Wrapper)();
}
static  void method_21871( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<reco::HLTResult<24,unsigned short> >*)o)->product)());
  else   (((const ::edm::Wrapper<reco::HLTResult<24,unsigned short> >*)o)->product)();
}

static  void operator_21872( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<reco::HLTResult<24,unsigned short> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<reco::HLTResult<24,unsigned short> >*)o)->operator->)();
}

static  void method_21873( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<reco::HLTResult<24,unsigned short> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<reco::HLTResult<24,unsigned short> >*)o)->productTypeInfo)();
}

static  void method_21874( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<reco::HLTResult<24,unsigned short> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<reco::HLTResult<24,unsigned short> >*)o)->typeInfo)();
}

static void constructor_21875( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::HLTResult<24,unsigned short> >((::reco::HLTResult<24,unsigned short>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<reco::HLTResult<24,unsigned short> >((::reco::HLTResult<24,unsigned short>*)arg[0]);
}

static  void method_21876( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<reco::HLTResult<24,unsigned short> >*)o)->getInterface)());
  else   (((::edm::Wrapper<reco::HLTResult<24,unsigned short> >*)o)->getInterface)();
}

static  void method_21877( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::HLTResult<24,unsigned short> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_21878( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::HLTResult<24,unsigned short> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_21879( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::HLTResult<24,unsigned short> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_21880( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<reco::HLTResult<24,unsigned short> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<reco::HLTResult<24,unsigned short> >*)o)->dynamicTypeInfo)();
}

static  void method_21881( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<reco::HLTResult<24,unsigned short> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<reco::HLTResult<24,unsigned short> >*)o)->isPresent)();
}

static  void method_21882( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<reco::HLTResult<24,unsigned short> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<reco::HLTResult<24,unsigned short> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4403( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::HLTResult<24,unsigned short> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::HLTResult<24,unsigned short> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::HLTResult<24,unsigned short> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::HLTResult<24,unsigned short> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::HLTResult<24,unsigned short> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<reco::HLTResult<24, short unsigned int> > -------------------------------
void __edm__Wrapper_reco__HLTResult_24_unsignedsshort_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_reco__HLTResult_24_unsignedsshort_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_reco__HLTResult_24_unsignedsshort_s__datamem_bld(&__edm__Wrapper_reco__HLTResult_24_unsignedsshort_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_reco__HLTResult_24_unsignedsshort_s__funcmem_bld(&__edm__Wrapper_reco__HLTResult_24_unsignedsshort_s__db_funcmem);
void __edm__Wrapper_reco__HLTResult_24_unsignedsshort_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<reco::HLTResult<24,unsigned short> >"), typeid(::edm::Wrapper<reco::HLTResult<24,unsigned short> >), sizeof(::edm::Wrapper<reco::HLTResult<24,unsigned short> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("splitLevel"), "0")
  .AddTypedef(type_5547, Reflex::Literal("edm::Wrapper<reco::HLTResult<24,unsigned short> >::value_type"))
  .AddTypedef(type_5547, Reflex::Literal("edm::Wrapper<reco::HLTResult<24,unsigned short> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_21868, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2461), Reflex::Literal("Wrapper"), constructor_21869, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_21870, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35387), Reflex::Literal("Wrapper"), constructor_21875, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4403, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_reco__HLTResult_24_unsignedsshort_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_reco__HLTResult_24_unsignedsshort_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<reco::HLTResult<24, short unsigned int> > -------------------
void __edm__Wrapper_reco__HLTResult_24_unsignedsshort_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1374, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_reco__HLTResult_24_unsignedsshort_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_5547, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_reco__HLTResult_24_unsignedsshort_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<reco::HLTResult<24, short unsigned int> > -------------------
void __edm__Wrapper_reco__HLTResult_24_unsignedsshort_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35386), Reflex::Literal("product"), method_21871, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35386), Reflex::Literal("operator->"), operator_21872, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5473), Reflex::Literal("productTypeInfo"), method_21873, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5473), Reflex::Literal("typeInfo"), method_21874, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35388), Reflex::Literal("getInterface"), method_21876, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_21974, type_23583, type_31062), Reflex::Literal("fillView"), method_21877, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_5473, type_292, type_7999), Reflex::Literal("setPtr"), method_21878, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_5473, type_23585, type_23583), Reflex::Literal("fillPtrVector"), method_21879, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5473), Reflex::Literal("dynamicTypeInfo"), method_21880, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1374), Reflex::Literal("isPresent"), method_21881, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5473), Reflex::Literal("dynamicTypeInfo_"), method_21882, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HLTResult<16,short unsigned int> -------------------------------
static void destructor_24593(void*, void * o, const std::vector<void*>&, void *) {
(((::reco::HLTResult<16,unsigned short>*)o)->::reco::HLTResult<16,unsigned short>::~HLTResult)();
}
static  void operator_24594( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::HLTResult<16,unsigned short>*)o)->operator=)(*(const ::reco::HLTResult<16,unsigned short>*)arg[0]);
  else   (((::reco::HLTResult<16,unsigned short>*)o)->operator=)(*(const ::reco::HLTResult<16,unsigned short>*)arg[0]);
}

static void constructor_24595( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::HLTResult<16,unsigned short>(*(const ::reco::HLTResult<16,unsigned short>*)arg[0]);
  else ::new(mem) ::reco::HLTResult<16,unsigned short>(*(const ::reco::HLTResult<16,unsigned short>*)arg[0]);
}

static void constructor_24596( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::HLTResult<16,unsigned short>();
  else ::new(mem) ::reco::HLTResult<16,unsigned short>();
}

static void constructor_24597( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::HLTResult<16,unsigned short>((unsigned short*)arg[0]);
  else ::new(mem) ::reco::HLTResult<16,unsigned short>((unsigned short*)arg[0]);
}

static void method_newdel_5548( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::reco::HLTResult<16,unsigned short> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::reco::HLTResult<16,unsigned short> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::reco::HLTResult<16,unsigned short> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::reco::HLTResult<16,unsigned short> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::reco::HLTResult<16,unsigned short> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HLTResult<16,short unsigned int> -------------------------------
void __reco__HLTResult_16_unsignedsshort__db_datamem(Reflex::Class*);
void __reco__HLTResult_16_unsignedsshort__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __reco__HLTResult_16_unsignedsshort__datamem_bld(&__reco__HLTResult_16_unsignedsshort__db_datamem);
Reflex::GenreflexMemberBuilder __reco__HLTResult_16_unsignedsshort__funcmem_bld(&__reco__HLTResult_16_unsignedsshort__db_funcmem);
void __reco__HLTResult_16_unsignedsshort__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("reco::HLTResult<16,unsigned short>"), typeid(::reco::HLTResult<16,unsigned short>), sizeof(::reco::HLTResult<16,unsigned short>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3810, Reflex::Literal("reco::HLTResult<16,unsigned short>::boost_static_assert_typedef_40"))
  .AddTypedef(type_24414, Reflex::Literal("reco::HLTResult<16,unsigned short>::wordConstants"))
  .AddEnum(Reflex::Literal("_63"), Reflex::Literal("wordSize=2;size=8"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PRIVATE | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HLTResult"), destructor_24593, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_36350, type_36351), Reflex::Literal("operator="), operator_24594, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_36351), Reflex::Literal("HLTResult"), constructor_24595, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HLTResult"), constructor_24596, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3458), Reflex::Literal("HLTResult"), constructor_24597, 0, "w", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5548, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__reco__HLTResult_16_unsignedsshort__datamem_bld);
}

//------Delayed data member builder for class HLTResult<16,short unsigned int> -------------------
void __reco__HLTResult_16_unsignedsshort__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_36349, Reflex::Literal("words_"), OffsetOf(__shadow__::__reco__HLTResult_16_unsignedsshort_, words_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class HLTResult<16,short unsigned int> -------------------
void __reco__HLTResult_16_unsignedsshort__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class Wrapper<reco::HLTResult<16, short unsigned int> > -------------------------------
static void constructor_21889( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::HLTResult<16,unsigned short> >();
  else ::new(mem) ::edm::Wrapper<reco::HLTResult<16,unsigned short> >();
}

static void constructor_21890( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::HLTResult<16,unsigned short> >(*(::std::auto_ptr<reco::HLTResult<16,unsigned short> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<reco::HLTResult<16,unsigned short> >(*(::std::auto_ptr<reco::HLTResult<16,unsigned short> >*)arg[0]);
}

static void destructor_21891(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<reco::HLTResult<16,unsigned short> >*)o)->::edm::Wrapper<reco::HLTResult<16,unsigned short> >::~Wrapper)();
}
static  void method_21892( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<reco::HLTResult<16,unsigned short> >*)o)->product)());
  else   (((const ::edm::Wrapper<reco::HLTResult<16,unsigned short> >*)o)->product)();
}

static  void operator_21893( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<reco::HLTResult<16,unsigned short> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<reco::HLTResult<16,unsigned short> >*)o)->operator->)();
}

static  void method_21894( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<reco::HLTResult<16,unsigned short> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<reco::HLTResult<16,unsigned short> >*)o)->productTypeInfo)();
}

static  void method_21895( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<reco::HLTResult<16,unsigned short> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<reco::HLTResult<16,unsigned short> >*)o)->typeInfo)();
}

static void constructor_21896( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::HLTResult<16,unsigned short> >((::reco::HLTResult<16,unsigned short>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<reco::HLTResult<16,unsigned short> >((::reco::HLTResult<16,unsigned short>*)arg[0]);
}

static  void method_21897( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<reco::HLTResult<16,unsigned short> >*)o)->getInterface)());
  else   (((::edm::Wrapper<reco::HLTResult<16,unsigned short> >*)o)->getInterface)();
}

static  void method_21898( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::HLTResult<16,unsigned short> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_21899( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::HLTResult<16,unsigned short> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_21900( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::HLTResult<16,unsigned short> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_21901( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<reco::HLTResult<16,unsigned short> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<reco::HLTResult<16,unsigned short> >*)o)->dynamicTypeInfo)();
}

static  void method_21902( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<reco::HLTResult<16,unsigned short> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<reco::HLTResult<16,unsigned short> >*)o)->isPresent)();
}

static  void method_21903( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<reco::HLTResult<16,unsigned short> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<reco::HLTResult<16,unsigned short> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4404( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::HLTResult<16,unsigned short> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::HLTResult<16,unsigned short> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::HLTResult<16,unsigned short> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::HLTResult<16,unsigned short> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::HLTResult<16,unsigned short> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<reco::HLTResult<16, short unsigned int> > -------------------------------
void __edm__Wrapper_reco__HLTResult_16_unsignedsshort_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_reco__HLTResult_16_unsignedsshort_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_reco__HLTResult_16_unsignedsshort_s__datamem_bld(&__edm__Wrapper_reco__HLTResult_16_unsignedsshort_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_reco__HLTResult_16_unsignedsshort_s__funcmem_bld(&__edm__Wrapper_reco__HLTResult_16_unsignedsshort_s__db_funcmem);
void __edm__Wrapper_reco__HLTResult_16_unsignedsshort_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<reco::HLTResult<16,unsigned short> >"), typeid(::edm::Wrapper<reco::HLTResult<16,unsigned short> >), sizeof(::edm::Wrapper<reco::HLTResult<16,unsigned short> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("splitLevel"), "0")
  .AddTypedef(type_5548, Reflex::Literal("edm::Wrapper<reco::HLTResult<16,unsigned short> >::value_type"))
  .AddTypedef(type_5548, Reflex::Literal("edm::Wrapper<reco::HLTResult<16,unsigned short> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_21889, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2462), Reflex::Literal("Wrapper"), constructor_21890, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_21891, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35392), Reflex::Literal("Wrapper"), constructor_21896, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4404, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_reco__HLTResult_16_unsignedsshort_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_reco__HLTResult_16_unsignedsshort_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<reco::HLTResult<16, short unsigned int> > -------------------
void __edm__Wrapper_reco__HLTResult_16_unsignedsshort_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1374, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_reco__HLTResult_16_unsignedsshort_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_5548, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_reco__HLTResult_16_unsignedsshort_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<reco::HLTResult<16, short unsigned int> > -------------------
void __edm__Wrapper_reco__HLTResult_16_unsignedsshort_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35391), Reflex::Literal("product"), method_21892, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35391), Reflex::Literal("operator->"), operator_21893, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5473), Reflex::Literal("productTypeInfo"), method_21894, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5473), Reflex::Literal("typeInfo"), method_21895, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35393), Reflex::Literal("getInterface"), method_21897, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_21974, type_23583, type_31062), Reflex::Literal("fillView"), method_21898, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_5473, type_292, type_7999), Reflex::Literal("setPtr"), method_21899, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_5473, type_23585, type_23583), Reflex::Literal("fillPtrVector"), method_21900, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5473), Reflex::Literal("dynamicTypeInfo"), method_21901, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1374), Reflex::Literal("isPresent"), method_21902, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5473), Reflex::Literal("dynamicTypeInfo_"), method_21903, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class HLTResult<8,short unsigned int> -------------------------------
static void destructor_24602(void*, void * o, const std::vector<void*>&, void *) {
(((::reco::HLTResult<8,unsigned short>*)o)->::reco::HLTResult<8,unsigned short>::~HLTResult)();
}
static  void operator_24603( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::HLTResult<8,unsigned short>*)o)->operator=)(*(const ::reco::HLTResult<8,unsigned short>*)arg[0]);
  else   (((::reco::HLTResult<8,unsigned short>*)o)->operator=)(*(const ::reco::HLTResult<8,unsigned short>*)arg[0]);
}

static void constructor_24604( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::HLTResult<8,unsigned short>(*(const ::reco::HLTResult<8,unsigned short>*)arg[0]);
  else ::new(mem) ::reco::HLTResult<8,unsigned short>(*(const ::reco::HLTResult<8,unsigned short>*)arg[0]);
}

static void constructor_24605( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::HLTResult<8,unsigned short>();
  else ::new(mem) ::reco::HLTResult<8,unsigned short>();
}

static void constructor_24606( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::HLTResult<8,unsigned short>((unsigned short*)arg[0]);
  else ::new(mem) ::reco::HLTResult<8,unsigned short>((unsigned short*)arg[0]);
}

static void method_newdel_5549( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::reco::HLTResult<8,unsigned short> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::reco::HLTResult<8,unsigned short> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::reco::HLTResult<8,unsigned short> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::reco::HLTResult<8,unsigned short> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::reco::HLTResult<8,unsigned short> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HLTResult<8,short unsigned int> -------------------------------
void __reco__HLTResult_8_unsignedsshort__db_datamem(Reflex::Class*);
void __reco__HLTResult_8_unsignedsshort__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __reco__HLTResult_8_unsignedsshort__datamem_bld(&__reco__HLTResult_8_unsignedsshort__db_datamem);
Reflex::GenreflexMemberBuilder __reco__HLTResult_8_unsignedsshort__funcmem_bld(&__reco__HLTResult_8_unsignedsshort__db_funcmem);
void __reco__HLTResult_8_unsignedsshort__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("reco::HLTResult<8,unsigned short>"), typeid(::reco::HLTResult<8,unsigned short>), sizeof(::reco::HLTResult<8,unsigned short>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_3810, Reflex::Literal("reco::HLTResult<8,unsigned short>::boost_static_assert_typedef_40"))
  .AddTypedef(type_24415, Reflex::Literal("reco::HLTResult<8,unsigned short>::wordConstants"))
  .AddEnum(Reflex::Literal("_63"), Reflex::Literal("wordSize=2;size=4"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PRIVATE | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HLTResult"), destructor_24602, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_36353, type_36354), Reflex::Literal("operator="), operator_24603, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_36354), Reflex::Literal("HLTResult"), constructor_24604, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HLTResult"), constructor_24605, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3458), Reflex::Literal("HLTResult"), constructor_24606, 0, "w", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5549, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__reco__HLTResult_8_unsignedsshort__datamem_bld);
}

//------Delayed data member builder for class HLTResult<8,short unsigned int> -------------------
void __reco__HLTResult_8_unsignedsshort__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_36352, Reflex::Literal("words_"), OffsetOf(__shadow__::__reco__HLTResult_8_unsignedsshort_, words_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class HLTResult<8,short unsigned int> -------------------
void __reco__HLTResult_8_unsignedsshort__db_funcmem(Reflex::Class*) {

}
//------Stub functions for class Wrapper<reco::HLTResult<8, short unsigned int> > -------------------------------
static void constructor_21910( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::HLTResult<8,unsigned short> >();
  else ::new(mem) ::edm::Wrapper<reco::HLTResult<8,unsigned short> >();
}

static void constructor_21911( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::HLTResult<8,unsigned short> >(*(::std::auto_ptr<reco::HLTResult<8,unsigned short> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<reco::HLTResult<8,unsigned short> >(*(::std::auto_ptr<reco::HLTResult<8,unsigned short> >*)arg[0]);
}

static void destructor_21912(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<reco::HLTResult<8,unsigned short> >*)o)->::edm::Wrapper<reco::HLTResult<8,unsigned short> >::~Wrapper)();
}
static  void method_21913( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<reco::HLTResult<8,unsigned short> >*)o)->product)());
  else   (((const ::edm::Wrapper<reco::HLTResult<8,unsigned short> >*)o)->product)();
}

static  void operator_21914( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<reco::HLTResult<8,unsigned short> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<reco::HLTResult<8,unsigned short> >*)o)->operator->)();
}

static  void method_21915( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<reco::HLTResult<8,unsigned short> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<reco::HLTResult<8,unsigned short> >*)o)->productTypeInfo)();
}

static  void method_21916( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<reco::HLTResult<8,unsigned short> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<reco::HLTResult<8,unsigned short> >*)o)->typeInfo)();
}

static void constructor_21917( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::HLTResult<8,unsigned short> >((::reco::HLTResult<8,unsigned short>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<reco::HLTResult<8,unsigned short> >((::reco::HLTResult<8,unsigned short>*)arg[0]);
}

static  void method_21918( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<reco::HLTResult<8,unsigned short> >*)o)->getInterface)());
  else   (((::edm::Wrapper<reco::HLTResult<8,unsigned short> >*)o)->getInterface)();
}

static  void method_21919( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::HLTResult<8,unsigned short> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_21920( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::HLTResult<8,unsigned short> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_21921( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::HLTResult<8,unsigned short> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_21922( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<reco::HLTResult<8,unsigned short> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<reco::HLTResult<8,unsigned short> >*)o)->dynamicTypeInfo)();
}

static  void method_21923( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<reco::HLTResult<8,unsigned short> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<reco::HLTResult<8,unsigned short> >*)o)->isPresent)();
}

static  void method_21924( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<reco::HLTResult<8,unsigned short> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<reco::HLTResult<8,unsigned short> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4405( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::HLTResult<8,unsigned short> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::HLTResult<8,unsigned short> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::HLTResult<8,unsigned short> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::HLTResult<8,unsigned short> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::HLTResult<8,unsigned short> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<reco::HLTResult<8, short unsigned int> > -------------------------------
void __edm__Wrapper_reco__HLTResult_8_unsignedsshort_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_reco__HLTResult_8_unsignedsshort_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_reco__HLTResult_8_unsignedsshort_s__datamem_bld(&__edm__Wrapper_reco__HLTResult_8_unsignedsshort_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_reco__HLTResult_8_unsignedsshort_s__funcmem_bld(&__edm__Wrapper_reco__HLTResult_8_unsignedsshort_s__db_funcmem);
void __edm__Wrapper_reco__HLTResult_8_unsignedsshort_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<reco::HLTResult<8,unsigned short> >"), typeid(::edm::Wrapper<reco::HLTResult<8,unsigned short> >), sizeof(::edm::Wrapper<reco::HLTResult<8,unsigned short> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("splitLevel"), "0")
  .AddTypedef(type_5549, Reflex::Literal("edm::Wrapper<reco::HLTResult<8,unsigned short> >::value_type"))
  .AddTypedef(type_5549, Reflex::Literal("edm::Wrapper<reco::HLTResult<8,unsigned short> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_21910, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2463), Reflex::Literal("Wrapper"), constructor_21911, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_21912, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35397), Reflex::Literal("Wrapper"), constructor_21917, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4405, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_reco__HLTResult_8_unsignedsshort_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_reco__HLTResult_8_unsignedsshort_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<reco::HLTResult<8, short unsigned int> > -------------------
void __edm__Wrapper_reco__HLTResult_8_unsignedsshort_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1374, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_reco__HLTResult_8_unsignedsshort_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_5549, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_reco__HLTResult_8_unsignedsshort_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<reco::HLTResult<8, short unsigned int> > -------------------
void __edm__Wrapper_reco__HLTResult_8_unsignedsshort_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35396), Reflex::Literal("product"), method_21913, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35396), Reflex::Literal("operator->"), operator_21914, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5473), Reflex::Literal("productTypeInfo"), method_21915, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5473), Reflex::Literal("typeInfo"), method_21916, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35398), Reflex::Literal("getInterface"), method_21918, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_21974, type_23583, type_31062), Reflex::Literal("fillView"), method_21919, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_5473, type_292, type_7999), Reflex::Literal("setPtr"), method_21920, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_5473, type_23585, type_23583), Reflex::Literal("fillPtrVector"), method_21921, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5473), Reflex::Literal("dynamicTypeInfo"), method_21922, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1374), Reflex::Literal("isPresent"), method_21923, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5473), Reflex::Literal("dynamicTypeInfo_"), method_21924, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class vector<trigger::TriggerObject,std::allocator<trigger::TriggerObject> > -------------------------------
static void constructor_10965( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<trigger::TriggerObject>();
  else ::new(mem) ::std::vector<trigger::TriggerObject>();
}

static void constructor_10966( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<trigger::TriggerObject>(*(const ::std::allocator<trigger::TriggerObject>*)arg[0]);
  else ::new(mem) ::std::vector<trigger::TriggerObject>(*(const ::std::allocator<trigger::TriggerObject>*)arg[0]);
}

static void constructor_10967( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<trigger::TriggerObject>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<trigger::TriggerObject>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<trigger::TriggerObject>(*(::std::size_t*)arg[0],
      *(const ::trigger::TriggerObject*)arg[1]);
  else ::new(mem) ::std::vector<trigger::TriggerObject>(*(::std::size_t*)arg[0],
      *(const ::trigger::TriggerObject*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<trigger::TriggerObject>(*(::std::size_t*)arg[0],
      *(const ::trigger::TriggerObject*)arg[1],
      *(const ::std::allocator<trigger::TriggerObject>*)arg[2]);
  else ::new(mem) ::std::vector<trigger::TriggerObject>(*(::std::size_t*)arg[0],
      *(const ::trigger::TriggerObject*)arg[1],
      *(const ::std::allocator<trigger::TriggerObject>*)arg[2]);
  }
}

static void constructor_10968( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<trigger::TriggerObject>(*(const ::std::vector<trigger::TriggerObject>*)arg[0]);
  else ::new(mem) ::std::vector<trigger::TriggerObject>(*(const ::std::vector<trigger::TriggerObject>*)arg[0]);
}

static void destructor_10969(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<trigger::TriggerObject>*)o)->::std::vector<trigger::TriggerObject>::~vector)();
}
static  void operator_10970( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<trigger::TriggerObject>*)o)->operator=)(*(const ::std::vector<trigger::TriggerObject>*)arg[0]);
  else   (((::std::vector<trigger::TriggerObject>*)o)->operator=)(*(const ::std::vector<trigger::TriggerObject>*)arg[0]);
}

static  void method_10971( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<trigger::TriggerObject>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::trigger::TriggerObject*)arg[1]);
}

static  void method_10972( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<trigger::TriggerObject*,std::vector<trigger::TriggerObject> >)((((::std::vector<trigger::TriggerObject>*)o)->begin)());
  else   (((::std::vector<trigger::TriggerObject>*)o)->begin)();
}

static  void method_10973( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const trigger::TriggerObject*,std::vector<trigger::TriggerObject> >)((((const ::std::vector<trigger::TriggerObject>*)o)->begin)());
  else   (((const ::std::vector<trigger::TriggerObject>*)o)->begin)();
}

static  void method_10974( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<trigger::TriggerObject*,std::vector<trigger::TriggerObject> >)((((::std::vector<trigger::TriggerObject>*)o)->end)());
  else   (((::std::vector<trigger::TriggerObject>*)o)->end)();
}

static  void method_10975( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const trigger::TriggerObject*,std::vector<trigger::TriggerObject> >)((((const ::std::vector<trigger::TriggerObject>*)o)->end)());
  else   (((const ::std::vector<trigger::TriggerObject>*)o)->end)();
}

static  void method_10980( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<trigger::TriggerObject>*)o)->size)());
  else   (((const ::std::vector<trigger::TriggerObject>*)o)->size)();
}

static  void method_10981( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<trigger::TriggerObject>*)o)->max_size)());
  else   (((const ::std::vector<trigger::TriggerObject>*)o)->max_size)();
}

static  void method_10982( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<trigger::TriggerObject>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<trigger::TriggerObject>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::trigger::TriggerObject*)arg[1]);
  }
}

static  void method_10983( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<trigger::TriggerObject>*)o)->capacity)());
  else   (((const ::std::vector<trigger::TriggerObject>*)o)->capacity)();
}

static  void method_10984( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<trigger::TriggerObject>*)o)->empty)());
  else   (((const ::std::vector<trigger::TriggerObject>*)o)->empty)();
}

static  void method_10985( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<trigger::TriggerObject>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_10986( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<trigger::TriggerObject>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<trigger::TriggerObject>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_10987( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<trigger::TriggerObject>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<trigger::TriggerObject>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_10989( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<trigger::TriggerObject>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<trigger::TriggerObject>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10990( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<trigger::TriggerObject>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<trigger::TriggerObject>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10991( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<trigger::TriggerObject>*)o)->front)();
  else   (((::std::vector<trigger::TriggerObject>*)o)->front)();
}

static  void method_10992( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<trigger::TriggerObject>*)o)->front)();
  else   (((const ::std::vector<trigger::TriggerObject>*)o)->front)();
}

static  void method_10993( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<trigger::TriggerObject>*)o)->back)();
  else   (((::std::vector<trigger::TriggerObject>*)o)->back)();
}

static  void method_10994( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<trigger::TriggerObject>*)o)->back)();
  else   (((const ::std::vector<trigger::TriggerObject>*)o)->back)();
}

static  void method_10995( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<trigger::TriggerObject>*)o)->data)());
  else   (((::std::vector<trigger::TriggerObject>*)o)->data)();
}

static  void method_10996( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<trigger::TriggerObject>*)o)->data)());
  else   (((const ::std::vector<trigger::TriggerObject>*)o)->data)();
}

static  void method_10997( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<trigger::TriggerObject>*)o)->push_back)(*(const ::trigger::TriggerObject*)arg[0]);
}

static  void method_10998( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<trigger::TriggerObject>*)o)->pop_back)();
}

static  void method_10999( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<trigger::TriggerObject*,std::vector<trigger::TriggerObject> >)((((::std::vector<trigger::TriggerObject>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<trigger::TriggerObject*,std::vector<trigger::TriggerObject> >*)arg[0],
    *(const ::trigger::TriggerObject*)arg[1]));
  else   (((::std::vector<trigger::TriggerObject>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<trigger::TriggerObject*,std::vector<trigger::TriggerObject> >*)arg[0],
    *(const ::trigger::TriggerObject*)arg[1]);
}

static  void method_11000( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<trigger::TriggerObject>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<trigger::TriggerObject*,std::vector<trigger::TriggerObject> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::trigger::TriggerObject*)arg[2]);
}

static  void method_11001( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<trigger::TriggerObject*,std::vector<trigger::TriggerObject> >)((((::std::vector<trigger::TriggerObject>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<trigger::TriggerObject*,std::vector<trigger::TriggerObject> >*)arg[0]));
  else   (((::std::vector<trigger::TriggerObject>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<trigger::TriggerObject*,std::vector<trigger::TriggerObject> >*)arg[0]);
}

static  void method_11002( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<trigger::TriggerObject*,std::vector<trigger::TriggerObject> >)((((::std::vector<trigger::TriggerObject>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<trigger::TriggerObject*,std::vector<trigger::TriggerObject> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<trigger::TriggerObject*,std::vector<trigger::TriggerObject> >*)arg[1]));
  else   (((::std::vector<trigger::TriggerObject>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<trigger::TriggerObject*,std::vector<trigger::TriggerObject> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<trigger::TriggerObject*,std::vector<trigger::TriggerObject> >*)arg[1]);
}

static  void method_11003( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<trigger::TriggerObject>*)o)->swap)(*(::std::vector<trigger::TriggerObject>*)arg[0]);
}

static  void method_11004( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<trigger::TriggerObject>*)o)->clear)();
}

static void method_newdel_2702( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<trigger::TriggerObject> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<trigger::TriggerObject> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<trigger::TriggerObject> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<trigger::TriggerObject> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<trigger::TriggerObject> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x62( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<trigger::TriggerObject,std::allocator<trigger::TriggerObject> >")), ::Reflex::BaseOffset< ::std::vector<trigger::TriggerObject>,::std::_Vector_base<trigger::TriggerObject,std::allocator<trigger::TriggerObject> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x63( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<trigger::TriggerObject> >::Generate();
  else ::Reflex::Proxy< ::std::vector<trigger::TriggerObject> >::Generate();
}

//------Dictionary for class vector<trigger::TriggerObject,std::allocator<trigger::TriggerObject> > -------------------------------
void __std__vector_trigger__TriggerObject__db_datamem(Reflex::Class*);
void __std__vector_trigger__TriggerObject__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_trigger__TriggerObject__datamem_bld(&__std__vector_trigger__TriggerObject__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_trigger__TriggerObject__funcmem_bld(&__std__vector_trigger__TriggerObject__db_funcmem);
void __std__vector_trigger__TriggerObject__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<trigger::TriggerObject>"), typeid(::std::vector<trigger::TriggerObject>), sizeof(::std::vector<trigger::TriggerObject>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2135, ::Reflex::BaseOffset< ::std::vector<trigger::TriggerObject>, ::std::_Vector_base<trigger::TriggerObject,std::allocator<trigger::TriggerObject> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_3617, Reflex::Literal("std::vector<trigger::TriggerObject>::_Alloc_value_type"))
  .AddTypedef(type_2135, Reflex::Literal("std::vector<trigger::TriggerObject>::_Base"))
  .AddTypedef(type_3027, Reflex::Literal("std::vector<trigger::TriggerObject>::_Tp_alloc_type"))
  .AddTypedef(type_3617, Reflex::Literal("std::vector<trigger::TriggerObject>::value_type"))
  .AddTypedef(type_7440, Reflex::Literal("std::vector<trigger::TriggerObject>::pointer"))
  .AddTypedef(type_7429, Reflex::Literal("std::vector<trigger::TriggerObject>::const_pointer"))
  .AddTypedef(type_7442, Reflex::Literal("std::vector<trigger::TriggerObject>::reference"))
  .AddTypedef(type_7431, Reflex::Literal("std::vector<trigger::TriggerObject>::const_reference"))
  .AddTypedef(type_5695, Reflex::Literal("std::vector<trigger::TriggerObject>::iterator"))
  .AddTypedef(type_5696, Reflex::Literal("std::vector<trigger::TriggerObject>::const_iterator"))
  .AddTypedef(type_3232, Reflex::Literal("std::vector<trigger::TriggerObject>::const_reverse_iterator"))
  .AddTypedef(type_3233, Reflex::Literal("std::vector<trigger::TriggerObject>::reverse_iterator"))
  .AddTypedef(type_3004, Reflex::Literal("std::vector<trigger::TriggerObject>::size_type"))
  .AddTypedef(type_2891, Reflex::Literal("std::vector<trigger::TriggerObject>::difference_type"))
  .AddTypedef(type_3027, Reflex::Literal("std::vector<trigger::TriggerObject>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_10965, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28911), Reflex::Literal("vector"), constructor_10966, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3004, type_7431, type_28911), Reflex::Literal("vector"), constructor_10967, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30265), Reflex::Literal("vector"), constructor_10968, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_10969, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2702, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x62, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x63, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_trigger__TriggerObject__funcmem_bld);
}

//------Delayed data member builder for class vector<trigger::TriggerObject,std::allocator<trigger::TriggerObject> > -------------------
void __std__vector_trigger__TriggerObject__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<trigger::TriggerObject,std::allocator<trigger::TriggerObject> > -------------------
void __std__vector_trigger__TriggerObject__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30266, type_30265), Reflex::Literal("operator="), operator_10970, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3004, type_7431), Reflex::Literal("assign"), method_10971, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5695), Reflex::Literal("begin"), method_10972, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5696), Reflex::Literal("begin"), method_10973, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5695), Reflex::Literal("end"), method_10974, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5696), Reflex::Literal("end"), method_10975, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3004), Reflex::Literal("size"), method_10980, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3004), Reflex::Literal("max_size"), method_10981, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3004, type_3617), Reflex::Literal("resize"), method_10982, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3004), Reflex::Literal("capacity"), method_10983, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1374), Reflex::Literal("empty"), method_10984, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_3004), Reflex::Literal("reserve"), method_10985, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7442, type_3004), Reflex::Literal("operator[]"), operator_10986, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7431, type_3004), Reflex::Literal("operator[]"), operator_10987, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7442, type_3004), Reflex::Literal("at"), method_10989, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7431, type_3004), Reflex::Literal("at"), method_10990, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7442), Reflex::Literal("front"), method_10991, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7431), Reflex::Literal("front"), method_10992, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7442), Reflex::Literal("back"), method_10993, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7431), Reflex::Literal("back"), method_10994, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7440), Reflex::Literal("data"), method_10995, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7429), Reflex::Literal("data"), method_10996, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_7431), Reflex::Literal("push_back"), method_10997, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166), Reflex::Literal("pop_back"), method_10998, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5695, type_5695, type_7431), Reflex::Literal("insert"), method_10999, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_5695, type_3004, type_7431), Reflex::Literal("insert"), method_11000, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5695, type_5695), Reflex::Literal("erase"), method_11001, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5695, type_5695, type_5695), Reflex::Literal("erase"), method_11002, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_30266), Reflex::Literal("swap"), method_11003, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166), Reflex::Literal("clear"), method_11004, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class __normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType, std::allocator<trigger::TriggerObjectType> > > -------------------------------
static void destructor_26135(void*, void * o, const std::vector<void*>&, void *) {
(((::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >*)o)->::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >::~__normal_iterator)();
}
static  void operator_26136( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >*)arg[0]);
}

static void constructor_26137( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >(*(const ::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >(*(const ::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >*)arg[0]);
}

static void constructor_26138( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >();
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >();
}

static void constructor_26139( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >(*(const ::trigger::TriggerObjectType* const*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >(*(const ::trigger::TriggerObjectType* const*)arg[0]);
}

static  void operator_26140( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >*)o)->operator*)();
  else   (((const ::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >*)o)->operator*)();
}

static  void operator_26141( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >*)o)->operator->)());
  else   (((const ::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >*)o)->operator->)();
}

static  void operator_26142( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >*)o)->operator++)();
  else   (((::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >*)o)->operator++)();
}

static  void operator_26143( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >)((((::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >*)o)->operator++)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_26144( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >*)o)->operator--)();
  else   (((::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >*)o)->operator--)();
}

static  void operator_26145( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >)((((::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >*)o)->operator--)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_26146( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((const ::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_26147( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_26148( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >)((((const ::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_26149( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_26150( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >)((((const ::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void method_26151( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >*)o)->base)();
  else   (((const ::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >*)o)->base)();
}

static void method_newdel_5687( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType, std::allocator<trigger::TriggerObjectType> > > -------------------------------
void ____gnu_cxx____normal_iterator_conststrigger__TriggerObjectTypep_std__vector_trigger__TriggerObjectType_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____normal_iterator_conststrigger__TriggerObjectTypep_std__vector_trigger__TriggerObjectType_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_conststrigger__TriggerObjectTypep_std__vector_trigger__TriggerObjectType_s__datamem_bld(&____gnu_cxx____normal_iterator_conststrigger__TriggerObjectTypep_std__vector_trigger__TriggerObjectType_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_conststrigger__TriggerObjectTypep_std__vector_trigger__TriggerObjectType_s__funcmem_bld(&____gnu_cxx____normal_iterator_conststrigger__TriggerObjectTypep_std__vector_trigger__TriggerObjectType_s__db_funcmem);
void ____gnu_cxx____normal_iterator_conststrigger__TriggerObjectTypep_std__vector_trigger__TriggerObjectType_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >"), typeid(::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >), sizeof(::__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2210, Reflex::Literal("__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >::__traits_type"))
  .AddTypedef(type_7386, Reflex::Literal("__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >::iterator_type"))
  .AddTypedef(type_2305, Reflex::Literal("__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >::iterator_category"))
  .AddTypedef(type_3604, Reflex::Literal("__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >::value_type"))
  .AddTypedef(type_2891, Reflex::Literal("__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >::difference_type"))
  .AddTypedef(type_7388, Reflex::Literal("__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >::reference"))
  .AddTypedef(type_7386, Reflex::Literal("__gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> >::pointer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__normal_iterator"), destructor_26135, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_36544, type_36545), Reflex::Literal("operator="), operator_26136, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_36545), Reflex::Literal("__normal_iterator"), constructor_26137, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__normal_iterator"), constructor_26138, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_36546), Reflex::Literal("__normal_iterator"), constructor_26139, 0, "__i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5687, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&____gnu_cxx____normal_iterator_conststrigger__TriggerObjectTypep_std__vector_trigger__TriggerObjectType_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____normal_iterator_conststrigger__TriggerObjectTypep_std__vector_trigger__TriggerObjectType_s__funcmem_bld);
}

//------Delayed data member builder for class __normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType, std::allocator<trigger::TriggerObjectType> > > -------------------
void ____gnu_cxx____normal_iterator_conststrigger__TriggerObjectTypep_std__vector_trigger__TriggerObjectType_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7386, Reflex::Literal("_M_current"), OffsetOf(__shadow__::____gnu_cxx____normal_iterator_conststrigger__TriggerObjectTypep_std__vector_trigger__TriggerObjectType_s_, _M_current), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class __normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType, std::allocator<trigger::TriggerObjectType> > > -------------------
void ____gnu_cxx____normal_iterator_conststrigger__TriggerObjectTypep_std__vector_trigger__TriggerObjectType_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7388), Reflex::Literal("operator*"), operator_26140, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7386), Reflex::Literal("operator->"), operator_26141, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_36544), Reflex::Literal("operator++"), operator_26142, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5687, type_71), Reflex::Literal("operator++"), operator_26143, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_36544), Reflex::Literal("operator--"), operator_26144, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5687, type_71), Reflex::Literal("operator--"), operator_26145, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7388, type_36547), Reflex::Literal("operator[]"), operator_26146, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_36544, type_36547), Reflex::Literal("operator+="), operator_26147, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5687, type_36547), Reflex::Literal("operator+"), operator_26148, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_36544, type_36547), Reflex::Literal("operator-="), operator_26149, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5687, type_36547), Reflex::Literal("operator-"), operator_26150, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_36546), Reflex::Literal("base"), method_26151, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class __normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path, std::allocator<HLTPerformanceInfo::Path> > > -------------------------------
static void destructor_26160(void*, void * o, const std::vector<void*>&, void *) {
(((::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >*)o)->::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >::~__normal_iterator)();
}
static  void operator_26161( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >*)arg[0]);
}

static void constructor_26162( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >(*(const ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >(*(const ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >*)arg[0]);
}

static void constructor_26163( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >();
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >();
}

static void constructor_26164( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >(*(const ::HLTPerformanceInfo::Path* const*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >(*(const ::HLTPerformanceInfo::Path* const*)arg[0]);
}

static  void operator_26165( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >*)o)->operator*)();
  else   (((const ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >*)o)->operator*)();
}

static  void operator_26166( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >*)o)->operator->)());
  else   (((const ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >*)o)->operator->)();
}

static  void operator_26167( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >*)o)->operator++)();
  else   (((::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >*)o)->operator++)();
}

static  void operator_26168( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >)((((::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >*)o)->operator++)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_26169( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >*)o)->operator--)();
  else   (((::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >*)o)->operator--)();
}

static  void operator_26170( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >)((((::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >*)o)->operator--)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_26171( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((const ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_26172( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_26173( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >)((((const ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_26174( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_26175( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >)((((const ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void method_26176( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >*)o)->base)();
  else   (((const ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >*)o)->base)();
}

static void method_newdel_5689( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path, std::allocator<HLTPerformanceInfo::Path> > > -------------------------------
void ____gnu_cxx____normal_iterator_constsHLTPerformanceInfo__Pathp_std__vector_HLTPerformanceInfo__Path_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____normal_iterator_constsHLTPerformanceInfo__Pathp_std__vector_HLTPerformanceInfo__Path_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constsHLTPerformanceInfo__Pathp_std__vector_HLTPerformanceInfo__Path_s__datamem_bld(&____gnu_cxx____normal_iterator_constsHLTPerformanceInfo__Pathp_std__vector_HLTPerformanceInfo__Path_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constsHLTPerformanceInfo__Pathp_std__vector_HLTPerformanceInfo__Path_s__funcmem_bld(&____gnu_cxx____normal_iterator_constsHLTPerformanceInfo__Pathp_std__vector_HLTPerformanceInfo__Path_s__db_funcmem);
void ____gnu_cxx____normal_iterator_constsHLTPerformanceInfo__Pathp_std__vector_HLTPerformanceInfo__Path_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >"), typeid(::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >), sizeof(::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2211, Reflex::Literal("__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >::__traits_type"))
  .AddTypedef(type_7397, Reflex::Literal("__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >::iterator_type"))
  .AddTypedef(type_2305, Reflex::Literal("__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >::iterator_category"))
  .AddTypedef(type_5236, Reflex::Literal("__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >::value_type"))
  .AddTypedef(type_2891, Reflex::Literal("__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >::difference_type"))
  .AddTypedef(type_7399, Reflex::Literal("__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >::reference"))
  .AddTypedef(type_7397, Reflex::Literal("__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> >::pointer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__normal_iterator"), destructor_26160, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_36548, type_36549), Reflex::Literal("operator="), operator_26161, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_36549), Reflex::Literal("__normal_iterator"), constructor_26162, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__normal_iterator"), constructor_26163, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_36550), Reflex::Literal("__normal_iterator"), constructor_26164, 0, "__i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5689, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&____gnu_cxx____normal_iterator_constsHLTPerformanceInfo__Pathp_std__vector_HLTPerformanceInfo__Path_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____normal_iterator_constsHLTPerformanceInfo__Pathp_std__vector_HLTPerformanceInfo__Path_s__funcmem_bld);
}

//------Delayed data member builder for class __normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path, std::allocator<HLTPerformanceInfo::Path> > > -------------------
void ____gnu_cxx____normal_iterator_constsHLTPerformanceInfo__Pathp_std__vector_HLTPerformanceInfo__Path_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_7397, Reflex::Literal("_M_current"), OffsetOf(__shadow__::____gnu_cxx____normal_iterator_constsHLTPerformanceInfo__Pathp_std__vector_HLTPerformanceInfo__Path_s_, _M_current), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class __normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path, std::allocator<HLTPerformanceInfo::Path> > > -------------------
void ____gnu_cxx____normal_iterator_constsHLTPerformanceInfo__Pathp_std__vector_HLTPerformanceInfo__Path_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7399), Reflex::Literal("operator*"), operator_26165, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7397), Reflex::Literal("operator->"), operator_26166, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_36548), Reflex::Literal("operator++"), operator_26167, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5689, type_71), Reflex::Literal("operator++"), operator_26168, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_36548), Reflex::Literal("operator--"), operator_26169, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5689, type_71), Reflex::Literal("operator--"), operator_26170, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7399, type_36547), Reflex::Literal("operator[]"), operator_26171, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_36548, type_36547), Reflex::Literal("operator+="), operator_26172, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5689, type_36547), Reflex::Literal("operator+"), operator_26173, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_36548, type_36547), Reflex::Literal("operator-="), operator_26174, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5689, type_36547), Reflex::Literal("operator-"), operator_26175, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_36550), Reflex::Literal("base"), method_26176, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class __normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module, std::allocator<HLTPerformanceInfo::Module> > > -------------------------------
static void destructor_27535(void*, void * o, const std::vector<void*>&, void *) {
(((::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >*)o)->::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >::~__normal_iterator)();
}
static  void operator_27536( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >*)o)->operator=)(*(const ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >*)arg[0]);
}

static void constructor_27537( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >(*(const ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >(*(const ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >*)arg[0]);
}

static void constructor_27538( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >();
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >();
}

static void constructor_27539( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >(*(const ::HLTPerformanceInfo::Module* const*)arg[0]);
  else ::new(mem) ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >(*(const ::HLTPerformanceInfo::Module* const*)arg[0]);
}

static  void operator_27540( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >*)o)->operator*)();
  else   (((const ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >*)o)->operator*)();
}

static  void operator_27541( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >*)o)->operator->)());
  else   (((const ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >*)o)->operator->)();
}

static  void operator_27542( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >*)o)->operator++)();
  else   (((::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >*)o)->operator++)();
}

static  void operator_27543( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >)((((::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >*)o)->operator++)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >*)o)->operator++)(*(int*)arg[0]);
}

static  void operator_27544( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >*)o)->operator--)();
  else   (((::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >*)o)->operator--)();
}

static  void operator_27545( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >)((((::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >*)o)->operator--)(*(int*)arg[0]));
  else   (((::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >*)o)->operator--)(*(int*)arg[0]);
}

static  void operator_27546( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((const ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >*)o)->operator[])(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_27547( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >*)o)->operator+=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_27548( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >)((((const ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >*)o)->operator+)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_27549( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
  else   (((::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >*)o)->operator-=)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void operator_27550( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >)((((const ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]));
  else   (((const ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >*)o)->operator-)(*(const ::std::ptrdiff_t*)arg[0]);
}

static  void method_27551( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >*)o)->base)();
  else   (((const ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >*)o)->base)();
}

static void method_newdel_5806( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class __normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module, std::allocator<HLTPerformanceInfo::Module> > > -------------------------------
void ____gnu_cxx____normal_iterator_constsHLTPerformanceInfo__Modulep_std__vector_HLTPerformanceInfo__Module_s__db_datamem(Reflex::Class*);
void ____gnu_cxx____normal_iterator_constsHLTPerformanceInfo__Modulep_std__vector_HLTPerformanceInfo__Module_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constsHLTPerformanceInfo__Modulep_std__vector_HLTPerformanceInfo__Module_s__datamem_bld(&____gnu_cxx____normal_iterator_constsHLTPerformanceInfo__Modulep_std__vector_HLTPerformanceInfo__Module_s__db_datamem);
Reflex::GenreflexMemberBuilder ____gnu_cxx____normal_iterator_constsHLTPerformanceInfo__Modulep_std__vector_HLTPerformanceInfo__Module_s__funcmem_bld(&____gnu_cxx____normal_iterator_constsHLTPerformanceInfo__Modulep_std__vector_HLTPerformanceInfo__Module_s__db_funcmem);
void ____gnu_cxx____normal_iterator_constsHLTPerformanceInfo__Modulep_std__vector_HLTPerformanceInfo__Module_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >"), typeid(::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >), sizeof(::__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_2272, Reflex::Literal("__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >::__traits_type"))
  .AddTypedef(type_8048, Reflex::Literal("__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >::iterator_type"))
  .AddTypedef(type_2305, Reflex::Literal("__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >::iterator_category"))
  .AddTypedef(type_5237, Reflex::Literal("__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >::value_type"))
  .AddTypedef(type_2891, Reflex::Literal("__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >::difference_type"))
  .AddTypedef(type_8050, Reflex::Literal("__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >::reference"))
  .AddTypedef(type_8048, Reflex::Literal("__gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> >::pointer"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~__normal_iterator"), destructor_27535, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_36709, type_27615), Reflex::Literal("operator="), operator_27536, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27615), Reflex::Literal("__normal_iterator"), constructor_27537, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("__normal_iterator"), constructor_27538, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_36710), Reflex::Literal("__normal_iterator"), constructor_27539, 0, "__i", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5806, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&____gnu_cxx____normal_iterator_constsHLTPerformanceInfo__Modulep_std__vector_HLTPerformanceInfo__Module_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&____gnu_cxx____normal_iterator_constsHLTPerformanceInfo__Modulep_std__vector_HLTPerformanceInfo__Module_s__funcmem_bld);
}

//------Delayed data member builder for class __normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module, std::allocator<HLTPerformanceInfo::Module> > > -------------------
void ____gnu_cxx____normal_iterator_constsHLTPerformanceInfo__Modulep_std__vector_HLTPerformanceInfo__Module_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_8048, Reflex::Literal("_M_current"), OffsetOf(__shadow__::____gnu_cxx____normal_iterator_constsHLTPerformanceInfo__Modulep_std__vector_HLTPerformanceInfo__Module_s_, _M_current), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class __normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module, std::allocator<HLTPerformanceInfo::Module> > > -------------------
void ____gnu_cxx____normal_iterator_constsHLTPerformanceInfo__Modulep_std__vector_HLTPerformanceInfo__Module_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8050), Reflex::Literal("operator*"), operator_27540, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8048), Reflex::Literal("operator->"), operator_27541, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_36709), Reflex::Literal("operator++"), operator_27542, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5806, type_71), Reflex::Literal("operator++"), operator_27543, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_36709), Reflex::Literal("operator--"), operator_27544, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5806, type_71), Reflex::Literal("operator--"), operator_27545, 0, "", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_8050, type_36547), Reflex::Literal("operator[]"), operator_27546, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_36709, type_36547), Reflex::Literal("operator+="), operator_27547, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5806, type_36547), Reflex::Literal("operator+"), operator_27548, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_36709, type_36547), Reflex::Literal("operator-="), operator_27549, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5806, type_36547), Reflex::Literal("operator-"), operator_27550, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_36710), Reflex::Literal("base"), method_27551, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<trigger::TriggerObject, std::allocator<trigger::TriggerObject> > > -------------------------------
static void constructor_21763( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<trigger::TriggerObject> >();
  else ::new(mem) ::edm::Wrapper<std::vector<trigger::TriggerObject> >();
}

static void constructor_21764( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<trigger::TriggerObject> >(*(::std::auto_ptr<std::vector<trigger::TriggerObject> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<trigger::TriggerObject> >(*(::std::auto_ptr<std::vector<trigger::TriggerObject> >*)arg[0]);
}

static void destructor_21765(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<trigger::TriggerObject> >*)o)->::edm::Wrapper<std::vector<trigger::TriggerObject> >::~Wrapper)();
}
static  void method_21766( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<trigger::TriggerObject> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<trigger::TriggerObject> >*)o)->product)();
}

static  void operator_21767( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<trigger::TriggerObject> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<trigger::TriggerObject> >*)o)->operator->)();
}

static  void method_21768( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<trigger::TriggerObject> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<trigger::TriggerObject> >*)o)->productTypeInfo)();
}

static  void method_21769( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<trigger::TriggerObject> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<trigger::TriggerObject> >*)o)->typeInfo)();
}

static void constructor_21770( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<trigger::TriggerObject> >((::std::vector<trigger::TriggerObject>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<trigger::TriggerObject> >((::std::vector<trigger::TriggerObject>*)arg[0]);
}

static  void method_21771( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<trigger::TriggerObject> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<trigger::TriggerObject> >*)o)->getInterface)();
}

static  void method_21772( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<trigger::TriggerObject> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_21773( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<trigger::TriggerObject> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_21774( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<trigger::TriggerObject> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_21775( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<trigger::TriggerObject> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<trigger::TriggerObject> >*)o)->dynamicTypeInfo)();
}

static  void method_21776( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<trigger::TriggerObject> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<trigger::TriggerObject> >*)o)->isPresent)();
}

static  void method_21777( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<trigger::TriggerObject> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<trigger::TriggerObject> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4398( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<trigger::TriggerObject> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<trigger::TriggerObject> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<trigger::TriggerObject> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<trigger::TriggerObject> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<trigger::TriggerObject> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<trigger::TriggerObject, std::allocator<trigger::TriggerObject> > > -------------------------------
void __edm__Wrapper_std__vector_trigger__TriggerObject_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_trigger__TriggerObject_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_trigger__TriggerObject_s__datamem_bld(&__edm__Wrapper_std__vector_trigger__TriggerObject_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_trigger__TriggerObject_s__funcmem_bld(&__edm__Wrapper_std__vector_trigger__TriggerObject_s__db_funcmem);
void __edm__Wrapper_std__vector_trigger__TriggerObject_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<trigger::TriggerObject> >"), typeid(::edm::Wrapper<std::vector<trigger::TriggerObject> >), sizeof(::edm::Wrapper<std::vector<trigger::TriggerObject> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("splitLevel"), "0")
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<trigger::TriggerObjectCollection>")
  .AddTypedef(type_2702, Reflex::Literal("edm::Wrapper<std::vector<trigger::TriggerObject> >::value_type"))
  .AddTypedef(type_2702, Reflex::Literal("edm::Wrapper<std::vector<trigger::TriggerObject> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_21763, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2456), Reflex::Literal("Wrapper"), constructor_21764, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_21765, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_35364), Reflex::Literal("Wrapper"), constructor_21770, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4398, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_trigger__TriggerObject_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_trigger__TriggerObject_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<trigger::TriggerObject, std::allocator<trigger::TriggerObject> > > -------------------
void __edm__Wrapper_std__vector_trigger__TriggerObject_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1374, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_trigger__TriggerObject_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2702, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_trigger__TriggerObject_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<trigger::TriggerObject, std::allocator<trigger::TriggerObject> > > -------------------
void __edm__Wrapper_std__vector_trigger__TriggerObject_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35363), Reflex::Literal("product"), method_21766, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35363), Reflex::Literal("operator->"), operator_21767, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5473), Reflex::Literal("productTypeInfo"), method_21768, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5473), Reflex::Literal("typeInfo"), method_21769, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_35365), Reflex::Literal("getInterface"), method_21771, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_21974, type_23583, type_31062), Reflex::Literal("fillView"), method_21772, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_5473, type_292, type_7999), Reflex::Literal("setPtr"), method_21773, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1166, type_5473, type_23585, type_23583), Reflex::Literal("fillPtrVector"), method_21774, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5473), Reflex::Literal("dynamicTypeInfo"), method_21775, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1374), Reflex::Literal("isPresent"), method_21776, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5473), Reflex::Literal("dynamicTypeInfo_"), method_21777, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __HLTPerformanceInfo_dict(); 
      __std__vector_trigger__TriggerObjectType__dict(); 
      __HLTPerformanceInfo__Path_dict(); 
      __std__vector_HLTPerformanceInfo__Path__dict(); 
      __HLTPerformanceInfo__Module_dict(); 
      __std__vector_HLTPerformanceInfo__Module__dict(); 
      __trigger__TriggerEventWithRefs_dict(); 
      __trigger__TriggerEventWithRefs__TriggerFilterObject_dict(); 
      __std__vector_trigger__TriggerEventWithRefs__TriggerFilterObject__dict(); 
      __trigger__TriggerEvent_dict(); 
      __trigger__TriggerEvent__TriggerFilterObject_dict(); 
      __std__vector_trigger__TriggerEvent__TriggerFilterObject__dict(); 
      __std__vector_edm__Ref_std__vector_reco__PFTau__reco__PFTau_edm__refhelper__FindUsingAdvance_std__vector_reco__PFTau__reco__PFTau_s_s__dict(); 
      __std__vector_edm__Ref_std__vector_reco__RecoChargedCandidate__reco__RecoChargedCandidate_edm__refhelper__FindUsingAdvance_std__vector_reco__RecoChargedCandidate__reco__RecoChargedCandidate_s_s__dict(); 
      __std__vector_edm__Ref_std__vector_reco__Electron__reco__Electron_edm__refhelper__FindUsingAdvance_std__vector_reco__Electron__reco__Electron_s_s__dict(); 
      __std__vector_edm__Ref_std__vector_reco__RecoEcalCandidate__reco__RecoEcalCandidate_edm__refhelper__FindUsingAdvance_std__vector_reco__RecoEcalCandidate__reco__RecoEcalCandidate_s_s__dict(); 
      __edm__ModuleTime_dict(); 
      __std__vector_edm__ModuleTime__dict(); 
      __std__map_std__basic_string_char__std__vector_unsignedsint_s__dict(); 
      __trigger__TriggerFilterObjectWithRefs_dict(); 
      __trigger__TriggerObject_dict(); 
      __trigger__HLTPrescaleTable_dict(); 
      __trigger__TriggerRefsCollections_dict(); 
      __edm__Wrapper_trigger__HLTPrescaleTable__dict(); 
      __edm__Wrapper_trigger__TriggerEventWithRefs__dict(); 
      __edm__Wrapper_trigger__TriggerEvent__dict(); 
      __edm__Wrapper_trigger__TriggerFilterObjectWithRefs__dict(); 
      __edm__Wrapper_HLTPerformanceInfo__dict(); 
      __edm__EventTime_dict(); 
      __edm__Wrapper_edm__EventTime__dict(); 
      __reco__HLTResult_24_unsignedsshort__dict(); 
      __edm__Wrapper_reco__HLTResult_24_unsignedsshort_s__dict(); 
      __reco__HLTResult_16_unsignedsshort__dict(); 
      __edm__Wrapper_reco__HLTResult_16_unsignedsshort_s__dict(); 
      __reco__HLTResult_8_unsignedsshort__dict(); 
      __edm__Wrapper_reco__HLTResult_8_unsignedsshort_s__dict(); 
      __std__vector_trigger__TriggerObject__dict(); 
      ____gnu_cxx____normal_iterator_conststrigger__TriggerObjectTypep_std__vector_trigger__TriggerObjectType_s__dict(); 
      ____gnu_cxx____normal_iterator_constsHLTPerformanceInfo__Pathp_std__vector_HLTPerformanceInfo__Path_s__dict(); 
      ____gnu_cxx____normal_iterator_constsHLTPerformanceInfo__Modulep_std__vector_HLTPerformanceInfo__Module_s__dict(); 
      __edm__Wrapper_std__vector_trigger__TriggerObject_s__dict(); 
      ::Reflex::EnumBuilder(Reflex::Literal("trigger::TriggerObjectType"),typeid(::trigger::TriggerObjectType), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
        .AddItem(Reflex::Literal("TriggerL1Mu"),-81)
        .AddItem(Reflex::Literal("TriggerL1NoIsoEG"),-82)
        .AddItem(Reflex::Literal("TriggerL1IsoEG"),-83)
        .AddItem(Reflex::Literal("TriggerL1CenJet"),-84)
        .AddItem(Reflex::Literal("TriggerL1ForJet"),-85)
        .AddItem(Reflex::Literal("TriggerL1TauJet"),-86)
        .AddItem(Reflex::Literal("TriggerL1ETM"),-87)
        .AddItem(Reflex::Literal("TriggerL1ETT"),-88)
        .AddItem(Reflex::Literal("TriggerL1HTT"),-89)
        .AddItem(Reflex::Literal("TriggerL1HTM"),-90)
        .AddItem(Reflex::Literal("TriggerL1JetCounts"),-91)
        .AddItem(Reflex::Literal("TriggerL1HfBitCounts"),-92)
        .AddItem(Reflex::Literal("TriggerL1HfRingEtSums"),-93)
        .AddItem(Reflex::Literal("TriggerL1TechTrig"),-94)
        .AddItem(Reflex::Literal("TriggerL1Castor"),-95)
        .AddItem(Reflex::Literal("TriggerL1BPTX"),-96)
        .AddItem(Reflex::Literal("TriggerL1GtExternal"),-97)
        .AddItem(Reflex::Literal("TriggerPhoton"),81)
        .AddItem(Reflex::Literal("TriggerElectron"),82)
        .AddItem(Reflex::Literal("TriggerMuon"),83)
        .AddItem(Reflex::Literal("TriggerTau"),84)
        .AddItem(Reflex::Literal("TriggerJet"),85)
        .AddItem(Reflex::Literal("TriggerBJet"),86)
        .AddItem(Reflex::Literal("TriggerMET"),87)
        .AddItem(Reflex::Literal("TriggerTET"),88)
        .AddItem(Reflex::Literal("TriggerTHT"),89)
        .AddItem(Reflex::Literal("TriggerMHT"),90)
        .AddItem(Reflex::Literal("TriggerTrack"),91)
        .AddItem(Reflex::Literal("TriggerCluster"),92)
        .AddItem(Reflex::Literal("TriggerMETSig"),93)
        .AddItem(Reflex::Literal("TriggerELongit"),94)
        .AddItem(Reflex::Literal("TriggerMHTSig"),95)
        .AddItem(Reflex::Literal("TriggerHLongit"),96);
    }
    ~Dictionaries() {
      type_1073.Unload(); // class HLTPerformanceInfo 
      type_2697.Unload(); // class std::vector<trigger::TriggerObjectType> 
      type_5236.Unload(); // class HLTPerformanceInfo::Path 
      type_2698.Unload(); // class std::vector<HLTPerformanceInfo::Path> 
      type_5237.Unload(); // class HLTPerformanceInfo::Module 
      type_2699.Unload(); // class std::vector<HLTPerformanceInfo::Module> 
      type_3600.Unload(); // class trigger::TriggerEventWithRefs 
      type_10884.Unload(); // class trigger::TriggerEventWithRefs::TriggerFilterObject 
      type_2701.Unload(); // class std::vector<trigger::TriggerEventWithRefs::TriggerFilterObject> 
      type_3621.Unload(); // class trigger::TriggerEvent 
      type_11011.Unload(); // class trigger::TriggerEvent::TriggerFilterObject 
      type_2703.Unload(); // class std::vector<trigger::TriggerEvent::TriggerFilterObject> 
      type_2707.Unload(); // class std::vector<edm::Ref<std::vector<reco::PFTau>,reco::PFTau,edm::refhelper::FindUsingAdvance<std::vector<reco::PFTau>,reco::PFTau> > > 
      type_2729.Unload(); // class std::vector<edm::Ref<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoChargedCandidate>,reco::RecoChargedCandidate> > > 
      type_2730.Unload(); // class std::vector<edm::Ref<std::vector<reco::Electron>,reco::Electron,edm::refhelper::FindUsingAdvance<std::vector<reco::Electron>,reco::Electron> > > 
      type_2731.Unload(); // class std::vector<edm::Ref<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate,edm::refhelper::FindUsingAdvance<std::vector<reco::RecoEcalCandidate>,reco::RecoEcalCandidate> > > 
      type_4535.Unload(); // class edm::ModuleTime 
      type_2768.Unload(); // class std::vector<edm::ModuleTime> 
      type_2916.Unload(); // class std::map<std::basic_string<char>,std::vector<unsigned int> > 
      type_3614.Unload(); // class trigger::TriggerFilterObjectWithRefs 
      type_3617.Unload(); // class trigger::TriggerObject 
      type_3619.Unload(); // class trigger::HLTPrescaleTable 
      type_3626.Unload(); // class trigger::TriggerRefsCollections 
      type_4394.Unload(); // class edm::Wrapper<trigger::HLTPrescaleTable> 
      type_4395.Unload(); // class edm::Wrapper<trigger::TriggerEventWithRefs> 
      type_4396.Unload(); // class edm::Wrapper<trigger::TriggerEvent> 
      type_4397.Unload(); // class edm::Wrapper<trigger::TriggerFilterObjectWithRefs> 
      type_4401.Unload(); // class edm::Wrapper<HLTPerformanceInfo> 
      type_4572.Unload(); // class edm::EventTime 
      type_4402.Unload(); // class edm::Wrapper<edm::EventTime> 
      type_5547.Unload(); // class reco::HLTResult<24,unsigned short> 
      type_4403.Unload(); // class edm::Wrapper<reco::HLTResult<24,unsigned short> > 
      type_5548.Unload(); // class reco::HLTResult<16,unsigned short> 
      type_4404.Unload(); // class edm::Wrapper<reco::HLTResult<16,unsigned short> > 
      type_5549.Unload(); // class reco::HLTResult<8,unsigned short> 
      type_4405.Unload(); // class edm::Wrapper<reco::HLTResult<8,unsigned short> > 
      type_2702.Unload(); // class std::vector<trigger::TriggerObject> 
      type_5687.Unload(); // class __gnu_cxx::__normal_iterator<const trigger::TriggerObjectType*,std::vector<trigger::TriggerObjectType> > 
      type_5689.Unload(); // class __gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Path*,std::vector<HLTPerformanceInfo::Path> > 
      type_5806.Unload(); // class __gnu_cxx::__normal_iterator<const HLTPerformanceInfo::Module*,std::vector<HLTPerformanceInfo::Module> > 
      type_4398.Unload(); // class edm::Wrapper<std::vector<trigger::TriggerObject> > 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
