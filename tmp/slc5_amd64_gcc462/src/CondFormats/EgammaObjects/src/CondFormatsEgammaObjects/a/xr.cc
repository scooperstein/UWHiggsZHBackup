// Generated at Fri Feb 28 12:36:00 2014. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gccxml/20110825/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gccxml/20110825/bin/gccxml_cc1plus"
  GCCXML_CPP="/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gccxml/20110825/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='2' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='1' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.6.2"' -D__UINT64_C(c)='c ## UL' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__GNUC_MINOR__='6' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -iwrapper"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gccxml/20110825/share/gccxml-0.9/GCC/4.6" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../include/c++/4.6.2" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../include/c++/4.6.2/x86_64-unknown-linux-gnu" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../include/c++/4.6.2/backward" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/include" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/include-fixed" -isystem"/usr/local/include" -isystem"/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/cvmfs/cms.cern.ch/slc5_amd64_gcc462/external/gccxml/20110825/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.6.2
Copyright (C) 2011 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "/afs/hep.wisc.edu/user/stephane/sync_setup/src/CondFormats/EgammaObjects/src/classes.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::Type type_38 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_96 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_94 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_595 = ::Reflex::TypeBuilder(Reflex::Literal("float"));
  ::Reflex::Type type_2237 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_25 = ::Reflex::TypeBuilder(Reflex::Literal("GBRTree"));
  ::Reflex::Type type_515 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_795 = ::Reflex::TypeBuilder(Reflex::Literal("GBRTree2D"));
  ::Reflex::Type type_1648 = ::Reflex::TypeBuilder(Reflex::Literal("GBRForest"));
  ::Reflex::Type type_543 = ::Reflex::TypeBuilder(Reflex::Literal("GBRForest2D"));
  ::Reflex::Type type_63 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_2922 = ::Reflex::TypeBuilder(Reflex::Literal("TMVA::MethodBDT"));
  ::Reflex::Type type_1780 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<int>"));
  ::Reflex::Type type_1781 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<float>"));
  ::Reflex::Type type_2920 = ::Reflex::TypeBuilder(Reflex::Literal("TMVA::DecisionTree"));
  ::Reflex::Type type_1782 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<GBRTree>"));
  ::Reflex::Type type_1778 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<GBRTree2D>"));
  ::Reflex::Type type_1805 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_1898 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<GBRTree>"));
  ::Reflex::Type type_1894 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<GBRTree2D>"));
  ::Reflex::Type type_1783 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned char>"));
  ::Reflex::Type type_1779 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned short>"));
  ::Reflex::Type type_342 = ::Reflex::TypeBuilder(Reflex::Literal("ElectronLikelihoodCalibration"));
  ::Reflex::Type type_526 = ::Reflex::TypeBuilder(Reflex::Literal("ElectronLikelihoodCategoryData"));
  ::Reflex::Type type_2443 = ::Reflex::TypeBuilder(Reflex::Literal("ElectronLikelihoodCalibration::Entry"));
  ::Reflex::Type type_1777 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<ElectronLikelihoodCalibration::Entry>"));
  ::Reflex::Type type_6898 = ::Reflex::TypeBuilder(Reflex::Literal("PhysicsTools::Calibration::Histogram<float,float>"));
  ::Reflex::Type type_2014 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<GBRTree,std::allocator<GBRTree> >"));
  ::Reflex::Type type_1893 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<ElectronLikelihoodCalibration::Entry>"));
  ::Reflex::Type type_2012 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<GBRTree2D,std::allocator<GBRTree2D> >"));
  ::Reflex::Type type_2520 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<GBRTree*,std::vector<GBRTree> >"));
  ::Reflex::Type type_2516 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<GBRTree2D*,std::vector<GBRTree2D> >"));
  ::Reflex::Type type_2519 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const GBRTree*,std::vector<GBRTree> >"));
  ::Reflex::Type type_2515 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const GBRTree2D*,std::vector<GBRTree2D> >"));
  ::Reflex::Type type_1995 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<GBRTree*,std::vector<GBRTree> > >"));
  ::Reflex::Type type_1991 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<GBRTree2D*,std::vector<GBRTree2D> > >"));
  ::Reflex::Type type_1994 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const GBRTree*,std::vector<GBRTree> > >"));
  ::Reflex::Type type_1990 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const GBRTree2D*,std::vector<GBRTree2D> > >"));
  ::Reflex::Type type_2017 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<ElectronLikelihoodCalibration::Entry,std::allocator<ElectronLikelihoodCalibration::Entry> >"));
  ::Reflex::Type type_2514 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<ElectronLikelihoodCalibration::Entry*,std::vector<ElectronLikelihoodCalibration::Entry> >"));
  ::Reflex::Type type_2513 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const ElectronLikelihoodCalibration::Entry*,std::vector<ElectronLikelihoodCalibration::Entry> >"));
  ::Reflex::Type type_2001 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<ElectronLikelihoodCalibration::Entry*,std::vector<ElectronLikelihoodCalibration::Entry> > >"));
  ::Reflex::Type type_2000 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const ElectronLikelihoodCalibration::Entry*,std::vector<ElectronLikelihoodCalibration::Entry> > >"));
  ::Reflex::Type type_3827 = ::Reflex::ReferenceBuilder(type_25);
  ::Reflex::Type type_25c = ::Reflex::ConstBuilder(type_25);
  ::Reflex::Type type_3478 = ::Reflex::ReferenceBuilder(type_25c);
  ::Reflex::Type type_2920c = ::Reflex::ConstBuilder(type_2920);
  ::Reflex::Type type_5723 = ::Reflex::PointerBuilder(type_2920c);
  ::Reflex::Type type_595c = ::Reflex::ConstBuilder(type_595);
  ::Reflex::Type type_3761 = ::Reflex::PointerBuilder(type_595c);
  ::Reflex::Type type_5724 = ::Reflex::ReferenceBuilder(type_1781);
  ::Reflex::Type type_1781c = ::Reflex::ConstBuilder(type_1781);
  ::Reflex::Type type_5725 = ::Reflex::ReferenceBuilder(type_1781c);
  ::Reflex::Type type_5726 = ::Reflex::ReferenceBuilder(type_1783);
  ::Reflex::Type type_1783c = ::Reflex::ConstBuilder(type_1783);
  ::Reflex::Type type_5727 = ::Reflex::ReferenceBuilder(type_1783c);
  ::Reflex::Type type_5728 = ::Reflex::ReferenceBuilder(type_1780);
  ::Reflex::Type type_1780c = ::Reflex::ConstBuilder(type_1780);
  ::Reflex::Type type_5729 = ::Reflex::ReferenceBuilder(type_1780c);
  ::Reflex::Type type_5885 = ::Reflex::ReferenceBuilder(type_342);
  ::Reflex::Type type_342c = ::Reflex::ConstBuilder(type_342);
  ::Reflex::Type type_5886 = ::Reflex::ReferenceBuilder(type_342c);
  ::Reflex::Type type_1814 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::string"), type_1805);
  ::Reflex::Type type_6377 = ::Reflex::ReferenceBuilder(type_526);
  ::Reflex::Type type_526c = ::Reflex::ConstBuilder(type_526);
  ::Reflex::Type type_6378 = ::Reflex::ReferenceBuilder(type_526c);
  ::Reflex::Type type_6411 = ::Reflex::ReferenceBuilder(type_543);
  ::Reflex::Type type_543c = ::Reflex::ConstBuilder(type_543);
  ::Reflex::Type type_6412 = ::Reflex::ReferenceBuilder(type_543c);
  ::Reflex::Type type_4709 = ::Reflex::ReferenceBuilder(type_515);
  ::Reflex::Type type_6413 = ::Reflex::ReferenceBuilder(type_1778);
  ::Reflex::Type type_1778c = ::Reflex::ConstBuilder(type_1778);
  ::Reflex::Type type_6414 = ::Reflex::ReferenceBuilder(type_1778c);
  ::Reflex::Type type_3572 = ::Reflex::ReferenceBuilder(type_795);
  ::Reflex::Type type_795c = ::Reflex::ConstBuilder(type_795);
  ::Reflex::Type type_3467 = ::Reflex::ReferenceBuilder(type_795c);
  ::Reflex::Type type_6478 = ::Reflex::ReferenceBuilder(type_1779);
  ::Reflex::Type type_1779c = ::Reflex::ConstBuilder(type_1779);
  ::Reflex::Type type_6479 = ::Reflex::ReferenceBuilder(type_1779c);
  ::Reflex::Type type_6908 = ::Reflex::ReferenceBuilder(type_1648);
  ::Reflex::Type type_1648c = ::Reflex::ConstBuilder(type_1648);
  ::Reflex::Type type_6909 = ::Reflex::ReferenceBuilder(type_1648c);
  ::Reflex::Type type_2922c = ::Reflex::ConstBuilder(type_2922);
  ::Reflex::Type type_6910 = ::Reflex::PointerBuilder(type_2922c);
  ::Reflex::Type type_6911 = ::Reflex::ReferenceBuilder(type_1782);
  ::Reflex::Type type_1782c = ::Reflex::ConstBuilder(type_1782);
  ::Reflex::Type type_6912 = ::Reflex::ReferenceBuilder(type_1782c);
  ::Reflex::Type type_6900 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("PhysicsTools::Calibration::HistogramF"), type_6898);
  ::Reflex::Type type_3456 = ::Reflex::ReferenceBuilder(type_2443);
  ::Reflex::Type type_2443c = ::Reflex::ConstBuilder(type_2443);
  ::Reflex::Type type_3445 = ::Reflex::ReferenceBuilder(type_2443c);
  ::Reflex::Type type_3454 = ::Reflex::PointerBuilder(type_2443);
  ::Reflex::Type type_3443 = ::Reflex::PointerBuilder(type_2443c);
  ::Reflex::Type type_1981 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_63);
  ::Reflex::Type type_1927 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_94);
  ::Reflex::Type type_1893c = ::Reflex::ConstBuilder(type_1893);
  ::Reflex::Type type_7029 = ::Reflex::ReferenceBuilder(type_1893c);
  ::Reflex::Type type_1777c = ::Reflex::ConstBuilder(type_1777);
  ::Reflex::Type type_7030 = ::Reflex::ReferenceBuilder(type_1777c);
  ::Reflex::Type type_7031 = ::Reflex::ReferenceBuilder(type_1777);
  ::Reflex::Type type_3569 = ::Reflex::PointerBuilder(type_795);
  ::Reflex::Type type_3465 = ::Reflex::PointerBuilder(type_795c);
  ::Reflex::Type type_1894c = ::Reflex::ConstBuilder(type_1894);
  ::Reflex::Type type_7032 = ::Reflex::ReferenceBuilder(type_1894c);
  ::Reflex::Type type_3824 = ::Reflex::PointerBuilder(type_25);
  ::Reflex::Type type_3476 = ::Reflex::PointerBuilder(type_25c);
  ::Reflex::Type type_1898c = ::Reflex::ConstBuilder(type_1898);
  ::Reflex::Type type_7038 = ::Reflex::ReferenceBuilder(type_1898c);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __GBRTree
#undef __GBRTree
#endif
class __GBRTree {
  public:
  __GBRTree();
  virtual ~__GBRTree() throw();
  ::std::vector<unsigned char> fCutIndices;
  ::std::vector<float> fCutVals;
  ::std::vector<int> fLeftIndices;
  ::std::vector<int> fRightIndices;
  ::std::vector<float> fResponses;
};
#ifdef __ElectronLikelihoodCalibration
#undef __ElectronLikelihoodCalibration
#endif
struct __ElectronLikelihoodCalibration {
  public:
  __ElectronLikelihoodCalibration();
  ::std::vector<ElectronLikelihoodCalibration::Entry> data;
};
#ifdef __ElectronLikelihoodCategoryData
#undef __ElectronLikelihoodCategoryData
#endif
struct __ElectronLikelihoodCategoryData {
  public:
  __ElectronLikelihoodCategoryData();
  int ecaldet;
  int ptbin;
  int iclass;
  int ifullclass;
  ::std::string label;
};
#ifdef __GBRForest2D
#undef __GBRForest2D
#endif
class __GBRForest2D {
  public:
  __GBRForest2D();
  double fInitialResponseX;
  double fInitialResponseY;
  ::std::vector<GBRTree2D> fTrees;
};
#ifdef __GBRTree2D
#undef __GBRTree2D
#endif
class __GBRTree2D {
  public:
  __GBRTree2D();
  ::std::vector<unsigned short> fCutIndices;
  ::std::vector<float> fCutVals;
  ::std::vector<int> fLeftIndices;
  ::std::vector<int> fRightIndices;
  ::std::vector<float> fResponsesX;
  ::std::vector<float> fResponsesY;
};
#ifdef __GBRForest
#undef __GBRForest
#endif
class __GBRForest {
  public:
  __GBRForest();
  virtual ~__GBRForest() throw();
  double fInitialResponse;
  ::std::vector<GBRTree> fTrees;
};
#ifdef __ElectronLikelihoodCalibration__Entry
#undef __ElectronLikelihoodCalibration__Entry
#endif
struct __ElectronLikelihoodCalibration__Entry {
  public:
  __ElectronLikelihoodCalibration__Entry();
  ::ElectronLikelihoodCategoryData category;
  ::PhysicsTools::Calibration::HistogramF histogram;
};
#ifdef __std__vector_ElectronLikelihoodCalibration__Entry_
#undef __std__vector_ElectronLikelihoodCalibration__Entry_
#endif
class __std__vector_ElectronLikelihoodCalibration__Entry_ : protected ::std::_Vector_base<ElectronLikelihoodCalibration::Entry,std::allocator<ElectronLikelihoodCalibration::Entry> > {
  public:
  __std__vector_ElectronLikelihoodCalibration__Entry_();
};
#ifdef __std__vector_GBRTree2D_
#undef __std__vector_GBRTree2D_
#endif
class __std__vector_GBRTree2D_ : protected ::std::_Vector_base<GBRTree2D,std::allocator<GBRTree2D> > {
  public:
  __std__vector_GBRTree2D_();
};
#ifdef __std__vector_GBRTree_
#undef __std__vector_GBRTree_
#endif
class __std__vector_GBRTree_ : protected ::std::_Vector_base<GBRTree,std::allocator<GBRTree> > {
  public:
  __std__vector_GBRTree_();
};
}


#endif // __CINT__
namespace {
//------Stub functions for class GBRTree -------------------------------
static  void operator_2216( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GBRTree*)o)->operator=)(*(const ::GBRTree*)arg[0]);
  else   (((::GBRTree*)o)->operator=)(*(const ::GBRTree*)arg[0]);
}

static void constructor_2217( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GBRTree(*(const ::GBRTree*)arg[0]);
  else ::new(mem) ::GBRTree(*(const ::GBRTree*)arg[0]);
}

static void constructor_2218( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GBRTree();
  else ::new(mem) ::GBRTree();
}

static void constructor_2219( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GBRTree((const ::TMVA::DecisionTree*)arg[0]);
  else ::new(mem) ::GBRTree((const ::TMVA::DecisionTree*)arg[0]);
}

static void destructor_2220(void*, void * o, const std::vector<void*>&, void *) {
(((::GBRTree*)o)->::GBRTree::~GBRTree)();
}
static  void method_2221( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::GBRTree*)o)->GetResponse)((const float*)arg[0]));
  else   (((const ::GBRTree*)o)->GetResponse)((const float*)arg[0]);
}

static  void method_2222( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::GBRTree*)o)->TerminalIndex)((const float*)arg[0]));
  else   (((const ::GBRTree*)o)->TerminalIndex)((const float*)arg[0]);
}

static  void method_2223( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GBRTree*)o)->Responses)();
  else   (((::GBRTree*)o)->Responses)();
}

static  void method_2224( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::GBRTree*)o)->Responses)();
  else   (((const ::GBRTree*)o)->Responses)();
}

static  void method_2225( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GBRTree*)o)->CutIndices)();
  else   (((::GBRTree*)o)->CutIndices)();
}

static  void method_2226( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::GBRTree*)o)->CutIndices)();
  else   (((const ::GBRTree*)o)->CutIndices)();
}

static  void method_2227( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GBRTree*)o)->CutVals)();
  else   (((::GBRTree*)o)->CutVals)();
}

static  void method_2228( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::GBRTree*)o)->CutVals)();
  else   (((const ::GBRTree*)o)->CutVals)();
}

static  void method_2229( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GBRTree*)o)->LeftIndices)();
  else   (((::GBRTree*)o)->LeftIndices)();
}

static  void method_2230( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::GBRTree*)o)->LeftIndices)();
  else   (((const ::GBRTree*)o)->LeftIndices)();
}

static  void method_2231( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GBRTree*)o)->RightIndices)();
  else   (((::GBRTree*)o)->RightIndices)();
}

static  void method_2232( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::GBRTree*)o)->RightIndices)();
  else   (((const ::GBRTree*)o)->RightIndices)();
}

static void method_newdel_25( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::GBRTree >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::GBRTree >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::GBRTree >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::GBRTree >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::GBRTree >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class GBRTree -------------------------------
void __GBRTree_db_datamem(Reflex::Class*);
void __GBRTree_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __GBRTree_datamem_bld(&__GBRTree_db_datamem);
Reflex::GenreflexMemberBuilder __GBRTree_funcmem_bld(&__GBRTree_db_funcmem);
void __GBRTree_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("GBRTree"), typeid(::GBRTree), sizeof(::GBRTree), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3827, type_3478), Reflex::Literal("operator="), operator_2216, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3478), Reflex::Literal("GBRTree"), constructor_2217, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("GBRTree"), constructor_2218, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5723), Reflex::Literal("GBRTree"), constructor_2219, 0, "tree", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~GBRTree"), destructor_2220, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_25, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__GBRTree_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__GBRTree_funcmem_bld);
}

//------Delayed data member builder for class GBRTree -------------------
void __GBRTree_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1783, Reflex::Literal("fCutIndices"), OffsetOf(__shadow__::__GBRTree, fCutIndices), ::Reflex::PROTECTED)
  .AddDataMember(type_1781, Reflex::Literal("fCutVals"), OffsetOf(__shadow__::__GBRTree, fCutVals), ::Reflex::PROTECTED)
  .AddDataMember(type_1780, Reflex::Literal("fLeftIndices"), OffsetOf(__shadow__::__GBRTree, fLeftIndices), ::Reflex::PROTECTED)
  .AddDataMember(type_1780, Reflex::Literal("fRightIndices"), OffsetOf(__shadow__::__GBRTree, fRightIndices), ::Reflex::PROTECTED)
  .AddDataMember(type_1781, Reflex::Literal("fResponses"), OffsetOf(__shadow__::__GBRTree, fResponses), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class GBRTree -------------------
void __GBRTree_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_515, type_3761), Reflex::Literal("GetResponse"), method_2221, 0, "vector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_38, type_3761), Reflex::Literal("TerminalIndex"), method_2222, 0, "vector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5724), Reflex::Literal("Responses"), method_2223, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5725), Reflex::Literal("Responses"), method_2224, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5726), Reflex::Literal("CutIndices"), method_2225, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5727), Reflex::Literal("CutIndices"), method_2226, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5724), Reflex::Literal("CutVals"), method_2227, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5725), Reflex::Literal("CutVals"), method_2228, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5728), Reflex::Literal("LeftIndices"), method_2229, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5729), Reflex::Literal("LeftIndices"), method_2230, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5728), Reflex::Literal("RightIndices"), method_2231, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5729), Reflex::Literal("RightIndices"), method_2232, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class ElectronLikelihoodCalibration -------------------------------
static void destructor_2444(void*, void * o, const std::vector<void*>&, void *) {
(((::ElectronLikelihoodCalibration*)o)->::ElectronLikelihoodCalibration::~ElectronLikelihoodCalibration)();
}
static  void operator_2445( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::ElectronLikelihoodCalibration*)o)->operator=)(*(const ::ElectronLikelihoodCalibration*)arg[0]);
  else   (((::ElectronLikelihoodCalibration*)o)->operator=)(*(const ::ElectronLikelihoodCalibration*)arg[0]);
}

static void constructor_2446( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::ElectronLikelihoodCalibration(*(const ::ElectronLikelihoodCalibration*)arg[0]);
  else ::new(mem) ::ElectronLikelihoodCalibration(*(const ::ElectronLikelihoodCalibration*)arg[0]);
}

static void constructor_2447( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::ElectronLikelihoodCalibration();
  else ::new(mem) ::ElectronLikelihoodCalibration();
}

static void method_newdel_342( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::ElectronLikelihoodCalibration >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::ElectronLikelihoodCalibration >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::ElectronLikelihoodCalibration >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::ElectronLikelihoodCalibration >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::ElectronLikelihoodCalibration >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class ElectronLikelihoodCalibration -------------------------------
void __ElectronLikelihoodCalibration_db_datamem(Reflex::Class*);
void __ElectronLikelihoodCalibration_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __ElectronLikelihoodCalibration_datamem_bld(&__ElectronLikelihoodCalibration_db_datamem);
Reflex::GenreflexMemberBuilder __ElectronLikelihoodCalibration_funcmem_bld(&__ElectronLikelihoodCalibration_db_funcmem);
void __ElectronLikelihoodCalibration_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("ElectronLikelihoodCalibration"), typeid(::ElectronLikelihoodCalibration), sizeof(::ElectronLikelihoodCalibration), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ElectronLikelihoodCalibration"), destructor_2444, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5885, type_5886), Reflex::Literal("operator="), operator_2445, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_5886), Reflex::Literal("ElectronLikelihoodCalibration"), constructor_2446, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("ElectronLikelihoodCalibration"), constructor_2447, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_342, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__ElectronLikelihoodCalibration_datamem_bld);
}

//------Delayed data member builder for class ElectronLikelihoodCalibration -------------------
void __ElectronLikelihoodCalibration_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1777, Reflex::Literal("data"), OffsetOf(__shadow__::__ElectronLikelihoodCalibration, data), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class ElectronLikelihoodCalibration -------------------
void __ElectronLikelihoodCalibration_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class ElectronLikelihoodCategoryData -------------------------------
static void destructor_2592(void*, void * o, const std::vector<void*>&, void *) {
(((::ElectronLikelihoodCategoryData*)o)->::ElectronLikelihoodCategoryData::~ElectronLikelihoodCategoryData)();
}
static  void operator_2593( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::ElectronLikelihoodCategoryData*)o)->operator=)(*(const ::ElectronLikelihoodCategoryData*)arg[0]);
  else   (((::ElectronLikelihoodCategoryData*)o)->operator=)(*(const ::ElectronLikelihoodCategoryData*)arg[0]);
}

static void constructor_2594( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::ElectronLikelihoodCategoryData(*(const ::ElectronLikelihoodCategoryData*)arg[0]);
  else ::new(mem) ::ElectronLikelihoodCategoryData(*(const ::ElectronLikelihoodCategoryData*)arg[0]);
}

static void constructor_2595( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::ElectronLikelihoodCategoryData();
  else ::new(mem) ::ElectronLikelihoodCategoryData();
}

static void method_newdel_526( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::ElectronLikelihoodCategoryData >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::ElectronLikelihoodCategoryData >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::ElectronLikelihoodCategoryData >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::ElectronLikelihoodCategoryData >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::ElectronLikelihoodCategoryData >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class ElectronLikelihoodCategoryData -------------------------------
void __ElectronLikelihoodCategoryData_db_datamem(Reflex::Class*);
void __ElectronLikelihoodCategoryData_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __ElectronLikelihoodCategoryData_datamem_bld(&__ElectronLikelihoodCategoryData_db_datamem);
Reflex::GenreflexMemberBuilder __ElectronLikelihoodCategoryData_funcmem_bld(&__ElectronLikelihoodCategoryData_db_funcmem);
void __ElectronLikelihoodCategoryData_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("ElectronLikelihoodCategoryData"), typeid(::ElectronLikelihoodCategoryData), sizeof(::ElectronLikelihoodCategoryData), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ElectronLikelihoodCategoryData"), destructor_2592, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6377, type_6378), Reflex::Literal("operator="), operator_2593, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6378), Reflex::Literal("ElectronLikelihoodCategoryData"), constructor_2594, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("ElectronLikelihoodCategoryData"), constructor_2595, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_526, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__ElectronLikelihoodCategoryData_datamem_bld);
}

//------Delayed data member builder for class ElectronLikelihoodCategoryData -------------------
void __ElectronLikelihoodCategoryData_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_38, Reflex::Literal("ecaldet"), OffsetOf(__shadow__::__ElectronLikelihoodCategoryData, ecaldet), ::Reflex::PUBLIC)
  .AddDataMember(type_38, Reflex::Literal("ptbin"), OffsetOf(__shadow__::__ElectronLikelihoodCategoryData, ptbin), ::Reflex::PUBLIC)
  .AddDataMember(type_38, Reflex::Literal("iclass"), OffsetOf(__shadow__::__ElectronLikelihoodCategoryData, iclass), ::Reflex::PUBLIC)
  .AddDataMember(type_38, Reflex::Literal("ifullclass"), OffsetOf(__shadow__::__ElectronLikelihoodCategoryData, ifullclass), ::Reflex::PUBLIC)
  .AddDataMember(type_1814, Reflex::Literal("label"), OffsetOf(__shadow__::__ElectronLikelihoodCategoryData, label), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class ElectronLikelihoodCategoryData -------------------
void __ElectronLikelihoodCategoryData_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class GBRForest2D -------------------------------
static  void operator_2620( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GBRForest2D*)o)->operator=)(*(const ::GBRForest2D*)arg[0]);
  else   (((::GBRForest2D*)o)->operator=)(*(const ::GBRForest2D*)arg[0]);
}

static void constructor_2621( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GBRForest2D(*(const ::GBRForest2D*)arg[0]);
  else ::new(mem) ::GBRForest2D(*(const ::GBRForest2D*)arg[0]);
}

static void constructor_2622( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GBRForest2D();
  else ::new(mem) ::GBRForest2D();
}

static void destructor_2623(void*, void * o, const std::vector<void*>&, void *) {
(((::GBRForest2D*)o)->::GBRForest2D::~GBRForest2D)();
}
static  void method_2624( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::GBRForest2D*)o)->GetResponse)((const float*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
}

static  void method_2625( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GBRForest2D*)o)->SetInitialResponse)(*(double*)arg[0],
    *(double*)arg[1]);
}

static  void method_2626( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GBRForest2D*)o)->Trees)();
  else   (((::GBRForest2D*)o)->Trees)();
}

static  void method_2627( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::GBRForest2D*)o)->Trees)();
  else   (((const ::GBRForest2D*)o)->Trees)();
}

static void method_newdel_543( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::GBRForest2D >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::GBRForest2D >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::GBRForest2D >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::GBRForest2D >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::GBRForest2D >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class GBRForest2D -------------------------------
void __GBRForest2D_db_datamem(Reflex::Class*);
void __GBRForest2D_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __GBRForest2D_datamem_bld(&__GBRForest2D_db_datamem);
Reflex::GenreflexMemberBuilder __GBRForest2D_funcmem_bld(&__GBRForest2D_db_funcmem);
void __GBRForest2D_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("GBRForest2D"), typeid(::GBRForest2D), sizeof(::GBRForest2D), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("class_version"), "0")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6411, type_6412), Reflex::Literal("operator="), operator_2620, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6412), Reflex::Literal("GBRForest2D"), constructor_2621, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("GBRForest2D"), constructor_2622, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~GBRForest2D"), destructor_2623, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_543, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__GBRForest2D_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__GBRForest2D_funcmem_bld);
}

//------Delayed data member builder for class GBRForest2D -------------------
void __GBRForest2D_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_515, Reflex::Literal("fInitialResponseX"), OffsetOf(__shadow__::__GBRForest2D, fInitialResponseX), ::Reflex::PROTECTED)
  .AddDataMember(type_515, Reflex::Literal("fInitialResponseY"), OffsetOf(__shadow__::__GBRForest2D, fInitialResponseY), ::Reflex::PROTECTED)
  .AddDataMember(type_1778, Reflex::Literal("fTrees"), OffsetOf(__shadow__::__GBRForest2D, fTrees), ::Reflex::PROTECTED)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"));
}
//------Delayed function member builder for class GBRForest2D -------------------
void __GBRForest2D_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_96, type_3761, type_4709, type_4709), Reflex::Literal("GetResponse"), method_2624, 0, "vector;x;y", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_96, type_515, type_515), Reflex::Literal("SetInitialResponse"), method_2625, 0, "x;y", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6413), Reflex::Literal("Trees"), method_2626, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6414), Reflex::Literal("Trees"), method_2627, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class GBRTree2D -------------------------------
static  void operator_2752( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GBRTree2D*)o)->operator=)(*(const ::GBRTree2D*)arg[0]);
  else   (((::GBRTree2D*)o)->operator=)(*(const ::GBRTree2D*)arg[0]);
}

static void constructor_2753( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GBRTree2D(*(const ::GBRTree2D*)arg[0]);
  else ::new(mem) ::GBRTree2D(*(const ::GBRTree2D*)arg[0]);
}

static void constructor_2754( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GBRTree2D();
  else ::new(mem) ::GBRTree2D();
}

static void destructor_2755(void*, void * o, const std::vector<void*>&, void *) {
(((::GBRTree2D*)o)->::GBRTree2D::~GBRTree2D)();
}
static  void method_2756( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::GBRTree2D*)o)->GetResponse)((const float*)arg[0],
    *(double*)arg[1],
    *(double*)arg[2]);
}

static  void method_2757( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::GBRTree2D*)o)->TerminalIndex)((const float*)arg[0]));
  else   (((const ::GBRTree2D*)o)->TerminalIndex)((const float*)arg[0]);
}

static  void method_2758( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GBRTree2D*)o)->ResponsesX)();
  else   (((::GBRTree2D*)o)->ResponsesX)();
}

static  void method_2759( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::GBRTree2D*)o)->ResponsesX)();
  else   (((const ::GBRTree2D*)o)->ResponsesX)();
}

static  void method_2760( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GBRTree2D*)o)->ResponsesY)();
  else   (((::GBRTree2D*)o)->ResponsesY)();
}

static  void method_2761( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::GBRTree2D*)o)->ResponsesY)();
  else   (((const ::GBRTree2D*)o)->ResponsesY)();
}

static  void method_2762( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GBRTree2D*)o)->CutIndices)();
  else   (((::GBRTree2D*)o)->CutIndices)();
}

static  void method_2763( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::GBRTree2D*)o)->CutIndices)();
  else   (((const ::GBRTree2D*)o)->CutIndices)();
}

static  void method_2764( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GBRTree2D*)o)->CutVals)();
  else   (((::GBRTree2D*)o)->CutVals)();
}

static  void method_2765( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::GBRTree2D*)o)->CutVals)();
  else   (((const ::GBRTree2D*)o)->CutVals)();
}

static  void method_2766( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GBRTree2D*)o)->LeftIndices)();
  else   (((::GBRTree2D*)o)->LeftIndices)();
}

static  void method_2767( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::GBRTree2D*)o)->LeftIndices)();
  else   (((const ::GBRTree2D*)o)->LeftIndices)();
}

static  void method_2768( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GBRTree2D*)o)->RightIndices)();
  else   (((::GBRTree2D*)o)->RightIndices)();
}

static  void method_2769( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::GBRTree2D*)o)->RightIndices)();
  else   (((const ::GBRTree2D*)o)->RightIndices)();
}

static void method_newdel_795( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::GBRTree2D >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::GBRTree2D >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::GBRTree2D >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::GBRTree2D >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::GBRTree2D >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class GBRTree2D -------------------------------
void __GBRTree2D_db_datamem(Reflex::Class*);
void __GBRTree2D_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __GBRTree2D_datamem_bld(&__GBRTree2D_db_datamem);
Reflex::GenreflexMemberBuilder __GBRTree2D_funcmem_bld(&__GBRTree2D_db_funcmem);
void __GBRTree2D_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("GBRTree2D"), typeid(::GBRTree2D), sizeof(::GBRTree2D), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3572, type_3467), Reflex::Literal("operator="), operator_2752, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3467), Reflex::Literal("GBRTree2D"), constructor_2753, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("GBRTree2D"), constructor_2754, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~GBRTree2D"), destructor_2755, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_795, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__GBRTree2D_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__GBRTree2D_funcmem_bld);
}

//------Delayed data member builder for class GBRTree2D -------------------
void __GBRTree2D_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1779, Reflex::Literal("fCutIndices"), OffsetOf(__shadow__::__GBRTree2D, fCutIndices), ::Reflex::PROTECTED)
  .AddDataMember(type_1781, Reflex::Literal("fCutVals"), OffsetOf(__shadow__::__GBRTree2D, fCutVals), ::Reflex::PROTECTED)
  .AddDataMember(type_1780, Reflex::Literal("fLeftIndices"), OffsetOf(__shadow__::__GBRTree2D, fLeftIndices), ::Reflex::PROTECTED)
  .AddDataMember(type_1780, Reflex::Literal("fRightIndices"), OffsetOf(__shadow__::__GBRTree2D, fRightIndices), ::Reflex::PROTECTED)
  .AddDataMember(type_1781, Reflex::Literal("fResponsesX"), OffsetOf(__shadow__::__GBRTree2D, fResponsesX), ::Reflex::PROTECTED)
  .AddDataMember(type_1781, Reflex::Literal("fResponsesY"), OffsetOf(__shadow__::__GBRTree2D, fResponsesY), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class GBRTree2D -------------------
void __GBRTree2D_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_96, type_3761, type_4709, type_4709), Reflex::Literal("GetResponse"), method_2756, 0, "vector;x;y", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_38, type_3761), Reflex::Literal("TerminalIndex"), method_2757, 0, "vector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5724), Reflex::Literal("ResponsesX"), method_2758, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5725), Reflex::Literal("ResponsesX"), method_2759, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5724), Reflex::Literal("ResponsesY"), method_2760, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5725), Reflex::Literal("ResponsesY"), method_2761, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6478), Reflex::Literal("CutIndices"), method_2762, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6479), Reflex::Literal("CutIndices"), method_2763, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5724), Reflex::Literal("CutVals"), method_2764, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5725), Reflex::Literal("CutVals"), method_2765, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5728), Reflex::Literal("LeftIndices"), method_2766, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5729), Reflex::Literal("LeftIndices"), method_2767, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5728), Reflex::Literal("RightIndices"), method_2768, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5729), Reflex::Literal("RightIndices"), method_2769, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class GBRForest -------------------------------
static  void operator_3009( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GBRForest*)o)->operator=)(*(const ::GBRForest*)arg[0]);
  else   (((::GBRForest*)o)->operator=)(*(const ::GBRForest*)arg[0]);
}

static void constructor_3010( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GBRForest(*(const ::GBRForest*)arg[0]);
  else ::new(mem) ::GBRForest(*(const ::GBRForest*)arg[0]);
}

static void constructor_3011( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GBRForest();
  else ::new(mem) ::GBRForest();
}

static void constructor_3012( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::GBRForest((const ::TMVA::MethodBDT*)arg[0]);
  else ::new(mem) ::GBRForest((const ::TMVA::MethodBDT*)arg[0]);
}

static void destructor_3013(void*, void * o, const std::vector<void*>&, void *) {
(((::GBRForest*)o)->::GBRForest::~GBRForest)();
}
static  void method_3014( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::GBRForest*)o)->GetResponse)((const float*)arg[0]));
  else   (((const ::GBRForest*)o)->GetResponse)((const float*)arg[0]);
}

static  void method_3015( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::GBRForest*)o)->GetClassifier)((const float*)arg[0]));
  else   (((const ::GBRForest*)o)->GetClassifier)((const float*)arg[0]);
}

static  void method_3016( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::GBRForest*)o)->SetInitialResponse)(*(double*)arg[0]);
}

static  void method_3017( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::GBRForest*)o)->Trees)();
  else   (((::GBRForest*)o)->Trees)();
}

static  void method_3018( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::GBRForest*)o)->Trees)();
  else   (((const ::GBRForest*)o)->Trees)();
}

static void method_newdel_1648( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::GBRForest >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::GBRForest >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::GBRForest >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::GBRForest >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::GBRForest >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class GBRForest -------------------------------
void __GBRForest_db_datamem(Reflex::Class*);
void __GBRForest_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __GBRForest_datamem_bld(&__GBRForest_db_datamem);
Reflex::GenreflexMemberBuilder __GBRForest_funcmem_bld(&__GBRForest_db_funcmem);
void __GBRForest_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("GBRForest"), typeid(::GBRForest), sizeof(::GBRForest), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("class_version"), "0")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6908, type_6909), Reflex::Literal("operator="), operator_3009, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6909), Reflex::Literal("GBRForest"), constructor_3010, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("GBRForest"), constructor_3011, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6910), Reflex::Literal("GBRForest"), constructor_3012, 0, "bdt", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~GBRForest"), destructor_3013, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1648, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__GBRForest_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__GBRForest_funcmem_bld);
}

//------Delayed data member builder for class GBRForest -------------------
void __GBRForest_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_515, Reflex::Literal("fInitialResponse"), OffsetOf(__shadow__::__GBRForest, fInitialResponse), ::Reflex::PROTECTED)
  .AddDataMember(type_1782, Reflex::Literal("fTrees"), OffsetOf(__shadow__::__GBRForest, fTrees), ::Reflex::PROTECTED)
  .AddProperty(Reflex::Literal("mapping"),Reflex::Literal("blob"));
}
//------Delayed function member builder for class GBRForest -------------------
void __GBRForest_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_515, type_3761), Reflex::Literal("GetResponse"), method_3014, 0, "vector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_515, type_3761), Reflex::Literal("GetClassifier"), method_3015, 0, "vector", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_96, type_515), Reflex::Literal("SetInitialResponse"), method_3016, 0, "response", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6911), Reflex::Literal("Trees"), method_3017, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6912), Reflex::Literal("Trees"), method_3018, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Entry -------------------------------
static void destructor_5881(void*, void * o, const std::vector<void*>&, void *) {
(((::ElectronLikelihoodCalibration::Entry*)o)->::ElectronLikelihoodCalibration::Entry::~Entry)();
}
static  void operator_5882( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::ElectronLikelihoodCalibration::Entry*)o)->operator=)(*(const ::ElectronLikelihoodCalibration::Entry*)arg[0]);
  else   (((::ElectronLikelihoodCalibration::Entry*)o)->operator=)(*(const ::ElectronLikelihoodCalibration::Entry*)arg[0]);
}

static void constructor_5883( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::ElectronLikelihoodCalibration::Entry(*(const ::ElectronLikelihoodCalibration::Entry*)arg[0]);
  else ::new(mem) ::ElectronLikelihoodCalibration::Entry(*(const ::ElectronLikelihoodCalibration::Entry*)arg[0]);
}

static void constructor_5884( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::ElectronLikelihoodCalibration::Entry();
  else ::new(mem) ::ElectronLikelihoodCalibration::Entry();
}

static void method_newdel_2443( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::ElectronLikelihoodCalibration::Entry >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::ElectronLikelihoodCalibration::Entry >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::ElectronLikelihoodCalibration::Entry >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::ElectronLikelihoodCalibration::Entry >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::ElectronLikelihoodCalibration::Entry >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Entry -------------------------------
void __ElectronLikelihoodCalibration__Entry_db_datamem(Reflex::Class*);
void __ElectronLikelihoodCalibration__Entry_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __ElectronLikelihoodCalibration__Entry_datamem_bld(&__ElectronLikelihoodCalibration__Entry_db_datamem);
Reflex::GenreflexMemberBuilder __ElectronLikelihoodCalibration__Entry_funcmem_bld(&__ElectronLikelihoodCalibration__Entry_db_funcmem);
void __ElectronLikelihoodCalibration__Entry_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("ElectronLikelihoodCalibration::Entry"), typeid(::ElectronLikelihoodCalibration::Entry), sizeof(::ElectronLikelihoodCalibration::Entry), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Entry"), destructor_5881, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3456, type_3445), Reflex::Literal("operator="), operator_5882, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_3445), Reflex::Literal("Entry"), constructor_5883, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Entry"), constructor_5884, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2443, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__ElectronLikelihoodCalibration__Entry_datamem_bld);
}

//------Delayed data member builder for class Entry -------------------
void __ElectronLikelihoodCalibration__Entry_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_526, Reflex::Literal("category"), OffsetOf(__shadow__::__ElectronLikelihoodCalibration__Entry, category), ::Reflex::PUBLIC)
  .AddDataMember(type_6900, Reflex::Literal("histogram"), OffsetOf(__shadow__::__ElectronLikelihoodCalibration__Entry, histogram), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class Entry -------------------
void __ElectronLikelihoodCalibration__Entry_db_funcmem(Reflex::Class*) {

}
//------Stub functions for class vector<ElectronLikelihoodCalibration::Entry,std::allocator<ElectronLikelihoodCalibration::Entry> > -------------------------------
static void constructor_3519( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<ElectronLikelihoodCalibration::Entry>();
  else ::new(mem) ::std::vector<ElectronLikelihoodCalibration::Entry>();
}

static void constructor_3520( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<ElectronLikelihoodCalibration::Entry>(*(const ::std::allocator<ElectronLikelihoodCalibration::Entry>*)arg[0]);
  else ::new(mem) ::std::vector<ElectronLikelihoodCalibration::Entry>(*(const ::std::allocator<ElectronLikelihoodCalibration::Entry>*)arg[0]);
}

static void constructor_3521( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<ElectronLikelihoodCalibration::Entry>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<ElectronLikelihoodCalibration::Entry>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<ElectronLikelihoodCalibration::Entry>(*(::std::size_t*)arg[0],
      *(const ::ElectronLikelihoodCalibration::Entry*)arg[1]);
  else ::new(mem) ::std::vector<ElectronLikelihoodCalibration::Entry>(*(::std::size_t*)arg[0],
      *(const ::ElectronLikelihoodCalibration::Entry*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<ElectronLikelihoodCalibration::Entry>(*(::std::size_t*)arg[0],
      *(const ::ElectronLikelihoodCalibration::Entry*)arg[1],
      *(const ::std::allocator<ElectronLikelihoodCalibration::Entry>*)arg[2]);
  else ::new(mem) ::std::vector<ElectronLikelihoodCalibration::Entry>(*(::std::size_t*)arg[0],
      *(const ::ElectronLikelihoodCalibration::Entry*)arg[1],
      *(const ::std::allocator<ElectronLikelihoodCalibration::Entry>*)arg[2]);
  }
}

static void constructor_3522( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<ElectronLikelihoodCalibration::Entry>(*(const ::std::vector<ElectronLikelihoodCalibration::Entry>*)arg[0]);
  else ::new(mem) ::std::vector<ElectronLikelihoodCalibration::Entry>(*(const ::std::vector<ElectronLikelihoodCalibration::Entry>*)arg[0]);
}

static void destructor_3523(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->::std::vector<ElectronLikelihoodCalibration::Entry>::~vector)();
}
static  void operator_3524( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->operator=)(*(const ::std::vector<ElectronLikelihoodCalibration::Entry>*)arg[0]);
  else   (((::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->operator=)(*(const ::std::vector<ElectronLikelihoodCalibration::Entry>*)arg[0]);
}

static  void method_3525( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::ElectronLikelihoodCalibration::Entry*)arg[1]);
}

static  void method_3526( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<ElectronLikelihoodCalibration::Entry*,std::vector<ElectronLikelihoodCalibration::Entry> >)((((::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->begin)());
  else   (((::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->begin)();
}

static  void method_3527( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const ElectronLikelihoodCalibration::Entry*,std::vector<ElectronLikelihoodCalibration::Entry> >)((((const ::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->begin)());
  else   (((const ::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->begin)();
}

static  void method_3528( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<ElectronLikelihoodCalibration::Entry*,std::vector<ElectronLikelihoodCalibration::Entry> >)((((::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->end)());
  else   (((::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->end)();
}

static  void method_3529( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const ElectronLikelihoodCalibration::Entry*,std::vector<ElectronLikelihoodCalibration::Entry> >)((((const ::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->end)());
  else   (((const ::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->end)();
}

static  void method_3534( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->size)());
  else   (((const ::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->size)();
}

static  void method_3535( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->max_size)());
  else   (((const ::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->max_size)();
}

static  void method_3536( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::ElectronLikelihoodCalibration::Entry*)arg[1]);
  }
}

static  void method_3537( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->capacity)());
  else   (((const ::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->capacity)();
}

static  void method_3538( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->empty)());
  else   (((const ::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->empty)();
}

static  void method_3539( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_3540( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_3541( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_3543( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3544( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3545( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->front)();
  else   (((::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->front)();
}

static  void method_3546( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->front)();
  else   (((const ::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->front)();
}

static  void method_3547( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->back)();
  else   (((::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->back)();
}

static  void method_3548( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->back)();
  else   (((const ::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->back)();
}

static  void method_3549( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->data)());
  else   (((::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->data)();
}

static  void method_3550( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->data)());
  else   (((const ::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->data)();
}

static  void method_3551( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->push_back)(*(const ::ElectronLikelihoodCalibration::Entry*)arg[0]);
}

static  void method_3552( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->pop_back)();
}

static  void method_3553( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<ElectronLikelihoodCalibration::Entry*,std::vector<ElectronLikelihoodCalibration::Entry> >)((((::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<ElectronLikelihoodCalibration::Entry*,std::vector<ElectronLikelihoodCalibration::Entry> >*)arg[0],
    *(const ::ElectronLikelihoodCalibration::Entry*)arg[1]));
  else   (((::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<ElectronLikelihoodCalibration::Entry*,std::vector<ElectronLikelihoodCalibration::Entry> >*)arg[0],
    *(const ::ElectronLikelihoodCalibration::Entry*)arg[1]);
}

static  void method_3554( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<ElectronLikelihoodCalibration::Entry*,std::vector<ElectronLikelihoodCalibration::Entry> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::ElectronLikelihoodCalibration::Entry*)arg[2]);
}

static  void method_3555( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<ElectronLikelihoodCalibration::Entry*,std::vector<ElectronLikelihoodCalibration::Entry> >)((((::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<ElectronLikelihoodCalibration::Entry*,std::vector<ElectronLikelihoodCalibration::Entry> >*)arg[0]));
  else   (((::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<ElectronLikelihoodCalibration::Entry*,std::vector<ElectronLikelihoodCalibration::Entry> >*)arg[0]);
}

static  void method_3556( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<ElectronLikelihoodCalibration::Entry*,std::vector<ElectronLikelihoodCalibration::Entry> >)((((::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<ElectronLikelihoodCalibration::Entry*,std::vector<ElectronLikelihoodCalibration::Entry> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<ElectronLikelihoodCalibration::Entry*,std::vector<ElectronLikelihoodCalibration::Entry> >*)arg[1]));
  else   (((::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<ElectronLikelihoodCalibration::Entry*,std::vector<ElectronLikelihoodCalibration::Entry> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<ElectronLikelihoodCalibration::Entry*,std::vector<ElectronLikelihoodCalibration::Entry> >*)arg[1]);
}

static  void method_3557( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->swap)(*(::std::vector<ElectronLikelihoodCalibration::Entry>*)arg[0]);
}

static  void method_3558( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<ElectronLikelihoodCalibration::Entry>*)o)->clear)();
}

static void method_newdel_1777( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<ElectronLikelihoodCalibration::Entry> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<ElectronLikelihoodCalibration::Entry> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<ElectronLikelihoodCalibration::Entry> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<ElectronLikelihoodCalibration::Entry> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<ElectronLikelihoodCalibration::Entry> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x8( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<ElectronLikelihoodCalibration::Entry,std::allocator<ElectronLikelihoodCalibration::Entry> >")), ::Reflex::BaseOffset< ::std::vector<ElectronLikelihoodCalibration::Entry>,::std::_Vector_base<ElectronLikelihoodCalibration::Entry,std::allocator<ElectronLikelihoodCalibration::Entry> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x9( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<ElectronLikelihoodCalibration::Entry> >::Generate();
  else ::Reflex::Proxy< ::std::vector<ElectronLikelihoodCalibration::Entry> >::Generate();
}

//------Dictionary for class vector<ElectronLikelihoodCalibration::Entry,std::allocator<ElectronLikelihoodCalibration::Entry> > -------------------------------
void __std__vector_ElectronLikelihoodCalibration__Entry__db_datamem(Reflex::Class*);
void __std__vector_ElectronLikelihoodCalibration__Entry__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_ElectronLikelihoodCalibration__Entry__datamem_bld(&__std__vector_ElectronLikelihoodCalibration__Entry__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_ElectronLikelihoodCalibration__Entry__funcmem_bld(&__std__vector_ElectronLikelihoodCalibration__Entry__db_funcmem);
void __std__vector_ElectronLikelihoodCalibration__Entry__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<ElectronLikelihoodCalibration::Entry>"), typeid(::std::vector<ElectronLikelihoodCalibration::Entry>), sizeof(::std::vector<ElectronLikelihoodCalibration::Entry>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2017, ::Reflex::BaseOffset< ::std::vector<ElectronLikelihoodCalibration::Entry>, ::std::_Vector_base<ElectronLikelihoodCalibration::Entry,std::allocator<ElectronLikelihoodCalibration::Entry> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_2443, Reflex::Literal("std::vector<ElectronLikelihoodCalibration::Entry>::_Alloc_value_type"))
  .AddTypedef(type_2017, Reflex::Literal("std::vector<ElectronLikelihoodCalibration::Entry>::_Base"))
  .AddTypedef(type_1893, Reflex::Literal("std::vector<ElectronLikelihoodCalibration::Entry>::_Tp_alloc_type"))
  .AddTypedef(type_2443, Reflex::Literal("std::vector<ElectronLikelihoodCalibration::Entry>::value_type"))
  .AddTypedef(type_3454, Reflex::Literal("std::vector<ElectronLikelihoodCalibration::Entry>::pointer"))
  .AddTypedef(type_3443, Reflex::Literal("std::vector<ElectronLikelihoodCalibration::Entry>::const_pointer"))
  .AddTypedef(type_3456, Reflex::Literal("std::vector<ElectronLikelihoodCalibration::Entry>::reference"))
  .AddTypedef(type_3445, Reflex::Literal("std::vector<ElectronLikelihoodCalibration::Entry>::const_reference"))
  .AddTypedef(type_2514, Reflex::Literal("std::vector<ElectronLikelihoodCalibration::Entry>::iterator"))
  .AddTypedef(type_2513, Reflex::Literal("std::vector<ElectronLikelihoodCalibration::Entry>::const_iterator"))
  .AddTypedef(type_2000, Reflex::Literal("std::vector<ElectronLikelihoodCalibration::Entry>::const_reverse_iterator"))
  .AddTypedef(type_2001, Reflex::Literal("std::vector<ElectronLikelihoodCalibration::Entry>::reverse_iterator"))
  .AddTypedef(type_1981, Reflex::Literal("std::vector<ElectronLikelihoodCalibration::Entry>::size_type"))
  .AddTypedef(type_1927, Reflex::Literal("std::vector<ElectronLikelihoodCalibration::Entry>::difference_type"))
  .AddTypedef(type_1893, Reflex::Literal("std::vector<ElectronLikelihoodCalibration::Entry>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_3519, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7029), Reflex::Literal("vector"), constructor_3520, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1981, type_3445, type_7029), Reflex::Literal("vector"), constructor_3521, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7030), Reflex::Literal("vector"), constructor_3522, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_3523, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1777, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x8, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x9, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_ElectronLikelihoodCalibration__Entry__funcmem_bld);
}

//------Delayed data member builder for class vector<ElectronLikelihoodCalibration::Entry,std::allocator<ElectronLikelihoodCalibration::Entry> > -------------------
void __std__vector_ElectronLikelihoodCalibration__Entry__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<ElectronLikelihoodCalibration::Entry,std::allocator<ElectronLikelihoodCalibration::Entry> > -------------------
void __std__vector_ElectronLikelihoodCalibration__Entry__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7031, type_7030), Reflex::Literal("operator="), operator_3524, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_96, type_1981, type_3445), Reflex::Literal("assign"), method_3525, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2514), Reflex::Literal("begin"), method_3526, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2513), Reflex::Literal("begin"), method_3527, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2514), Reflex::Literal("end"), method_3528, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2513), Reflex::Literal("end"), method_3529, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1981), Reflex::Literal("size"), method_3534, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1981), Reflex::Literal("max_size"), method_3535, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_96, type_1981, type_2443), Reflex::Literal("resize"), method_3536, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1981), Reflex::Literal("capacity"), method_3537, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2237), Reflex::Literal("empty"), method_3538, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_96, type_1981), Reflex::Literal("reserve"), method_3539, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3456, type_1981), Reflex::Literal("operator[]"), operator_3540, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3445, type_1981), Reflex::Literal("operator[]"), operator_3541, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3456, type_1981), Reflex::Literal("at"), method_3543, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3445, type_1981), Reflex::Literal("at"), method_3544, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3456), Reflex::Literal("front"), method_3545, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3445), Reflex::Literal("front"), method_3546, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3456), Reflex::Literal("back"), method_3547, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3445), Reflex::Literal("back"), method_3548, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3454), Reflex::Literal("data"), method_3549, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3443), Reflex::Literal("data"), method_3550, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_96, type_3445), Reflex::Literal("push_back"), method_3551, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_96), Reflex::Literal("pop_back"), method_3552, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2514, type_2514, type_3445), Reflex::Literal("insert"), method_3553, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_96, type_2514, type_1981, type_3445), Reflex::Literal("insert"), method_3554, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2514, type_2514), Reflex::Literal("erase"), method_3555, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2514, type_2514, type_2514), Reflex::Literal("erase"), method_3556, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_96, type_7031), Reflex::Literal("swap"), method_3557, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_96), Reflex::Literal("clear"), method_3558, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<GBRTree2D,std::allocator<GBRTree2D> > -------------------------------
static void constructor_3582( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<GBRTree2D>();
  else ::new(mem) ::std::vector<GBRTree2D>();
}

static void constructor_3583( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<GBRTree2D>(*(const ::std::allocator<GBRTree2D>*)arg[0]);
  else ::new(mem) ::std::vector<GBRTree2D>(*(const ::std::allocator<GBRTree2D>*)arg[0]);
}

static void constructor_3584( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<GBRTree2D>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<GBRTree2D>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<GBRTree2D>(*(::std::size_t*)arg[0],
      *(const ::GBRTree2D*)arg[1]);
  else ::new(mem) ::std::vector<GBRTree2D>(*(::std::size_t*)arg[0],
      *(const ::GBRTree2D*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<GBRTree2D>(*(::std::size_t*)arg[0],
      *(const ::GBRTree2D*)arg[1],
      *(const ::std::allocator<GBRTree2D>*)arg[2]);
  else ::new(mem) ::std::vector<GBRTree2D>(*(::std::size_t*)arg[0],
      *(const ::GBRTree2D*)arg[1],
      *(const ::std::allocator<GBRTree2D>*)arg[2]);
  }
}

static void constructor_3585( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<GBRTree2D>(*(const ::std::vector<GBRTree2D>*)arg[0]);
  else ::new(mem) ::std::vector<GBRTree2D>(*(const ::std::vector<GBRTree2D>*)arg[0]);
}

static void destructor_3586(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<GBRTree2D>*)o)->::std::vector<GBRTree2D>::~vector)();
}
static  void operator_3587( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<GBRTree2D>*)o)->operator=)(*(const ::std::vector<GBRTree2D>*)arg[0]);
  else   (((::std::vector<GBRTree2D>*)o)->operator=)(*(const ::std::vector<GBRTree2D>*)arg[0]);
}

static  void method_3588( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<GBRTree2D>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::GBRTree2D*)arg[1]);
}

static  void method_3589( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<GBRTree2D*,std::vector<GBRTree2D> >)((((::std::vector<GBRTree2D>*)o)->begin)());
  else   (((::std::vector<GBRTree2D>*)o)->begin)();
}

static  void method_3590( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const GBRTree2D*,std::vector<GBRTree2D> >)((((const ::std::vector<GBRTree2D>*)o)->begin)());
  else   (((const ::std::vector<GBRTree2D>*)o)->begin)();
}

static  void method_3591( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<GBRTree2D*,std::vector<GBRTree2D> >)((((::std::vector<GBRTree2D>*)o)->end)());
  else   (((::std::vector<GBRTree2D>*)o)->end)();
}

static  void method_3592( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const GBRTree2D*,std::vector<GBRTree2D> >)((((const ::std::vector<GBRTree2D>*)o)->end)());
  else   (((const ::std::vector<GBRTree2D>*)o)->end)();
}

static  void method_3597( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<GBRTree2D>*)o)->size)());
  else   (((const ::std::vector<GBRTree2D>*)o)->size)();
}

static  void method_3598( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<GBRTree2D>*)o)->max_size)());
  else   (((const ::std::vector<GBRTree2D>*)o)->max_size)();
}

static  void method_3599( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<GBRTree2D>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<GBRTree2D>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::GBRTree2D*)arg[1]);
  }
}

static  void method_3600( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<GBRTree2D>*)o)->capacity)());
  else   (((const ::std::vector<GBRTree2D>*)o)->capacity)();
}

static  void method_3601( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<GBRTree2D>*)o)->empty)());
  else   (((const ::std::vector<GBRTree2D>*)o)->empty)();
}

static  void method_3602( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<GBRTree2D>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_3603( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<GBRTree2D>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<GBRTree2D>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_3604( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<GBRTree2D>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<GBRTree2D>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_3606( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<GBRTree2D>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<GBRTree2D>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3607( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<GBRTree2D>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<GBRTree2D>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3608( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<GBRTree2D>*)o)->front)();
  else   (((::std::vector<GBRTree2D>*)o)->front)();
}

static  void method_3609( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<GBRTree2D>*)o)->front)();
  else   (((const ::std::vector<GBRTree2D>*)o)->front)();
}

static  void method_3610( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<GBRTree2D>*)o)->back)();
  else   (((::std::vector<GBRTree2D>*)o)->back)();
}

static  void method_3611( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<GBRTree2D>*)o)->back)();
  else   (((const ::std::vector<GBRTree2D>*)o)->back)();
}

static  void method_3612( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<GBRTree2D>*)o)->data)());
  else   (((::std::vector<GBRTree2D>*)o)->data)();
}

static  void method_3613( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<GBRTree2D>*)o)->data)());
  else   (((const ::std::vector<GBRTree2D>*)o)->data)();
}

static  void method_3614( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<GBRTree2D>*)o)->push_back)(*(const ::GBRTree2D*)arg[0]);
}

static  void method_3615( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<GBRTree2D>*)o)->pop_back)();
}

static  void method_3616( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<GBRTree2D*,std::vector<GBRTree2D> >)((((::std::vector<GBRTree2D>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<GBRTree2D*,std::vector<GBRTree2D> >*)arg[0],
    *(const ::GBRTree2D*)arg[1]));
  else   (((::std::vector<GBRTree2D>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<GBRTree2D*,std::vector<GBRTree2D> >*)arg[0],
    *(const ::GBRTree2D*)arg[1]);
}

static  void method_3617( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<GBRTree2D>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<GBRTree2D*,std::vector<GBRTree2D> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::GBRTree2D*)arg[2]);
}

static  void method_3618( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<GBRTree2D*,std::vector<GBRTree2D> >)((((::std::vector<GBRTree2D>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<GBRTree2D*,std::vector<GBRTree2D> >*)arg[0]));
  else   (((::std::vector<GBRTree2D>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<GBRTree2D*,std::vector<GBRTree2D> >*)arg[0]);
}

static  void method_3619( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<GBRTree2D*,std::vector<GBRTree2D> >)((((::std::vector<GBRTree2D>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<GBRTree2D*,std::vector<GBRTree2D> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<GBRTree2D*,std::vector<GBRTree2D> >*)arg[1]));
  else   (((::std::vector<GBRTree2D>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<GBRTree2D*,std::vector<GBRTree2D> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<GBRTree2D*,std::vector<GBRTree2D> >*)arg[1]);
}

static  void method_3620( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<GBRTree2D>*)o)->swap)(*(::std::vector<GBRTree2D>*)arg[0]);
}

static  void method_3621( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<GBRTree2D>*)o)->clear)();
}

static void method_newdel_1778( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<GBRTree2D> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<GBRTree2D> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<GBRTree2D> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<GBRTree2D> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<GBRTree2D> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x11( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<GBRTree2D,std::allocator<GBRTree2D> >")), ::Reflex::BaseOffset< ::std::vector<GBRTree2D>,::std::_Vector_base<GBRTree2D,std::allocator<GBRTree2D> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x12( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<GBRTree2D> >::Generate();
  else ::Reflex::Proxy< ::std::vector<GBRTree2D> >::Generate();
}

//------Dictionary for class vector<GBRTree2D,std::allocator<GBRTree2D> > -------------------------------
void __std__vector_GBRTree2D__db_datamem(Reflex::Class*);
void __std__vector_GBRTree2D__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_GBRTree2D__datamem_bld(&__std__vector_GBRTree2D__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_GBRTree2D__funcmem_bld(&__std__vector_GBRTree2D__db_funcmem);
void __std__vector_GBRTree2D__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<GBRTree2D>"), typeid(::std::vector<GBRTree2D>), sizeof(::std::vector<GBRTree2D>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2012, ::Reflex::BaseOffset< ::std::vector<GBRTree2D>, ::std::_Vector_base<GBRTree2D,std::allocator<GBRTree2D> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_795, Reflex::Literal("std::vector<GBRTree2D>::_Alloc_value_type"))
  .AddTypedef(type_2012, Reflex::Literal("std::vector<GBRTree2D>::_Base"))
  .AddTypedef(type_1894, Reflex::Literal("std::vector<GBRTree2D>::_Tp_alloc_type"))
  .AddTypedef(type_795, Reflex::Literal("std::vector<GBRTree2D>::value_type"))
  .AddTypedef(type_3569, Reflex::Literal("std::vector<GBRTree2D>::pointer"))
  .AddTypedef(type_3465, Reflex::Literal("std::vector<GBRTree2D>::const_pointer"))
  .AddTypedef(type_3572, Reflex::Literal("std::vector<GBRTree2D>::reference"))
  .AddTypedef(type_3467, Reflex::Literal("std::vector<GBRTree2D>::const_reference"))
  .AddTypedef(type_2516, Reflex::Literal("std::vector<GBRTree2D>::iterator"))
  .AddTypedef(type_2515, Reflex::Literal("std::vector<GBRTree2D>::const_iterator"))
  .AddTypedef(type_1990, Reflex::Literal("std::vector<GBRTree2D>::const_reverse_iterator"))
  .AddTypedef(type_1991, Reflex::Literal("std::vector<GBRTree2D>::reverse_iterator"))
  .AddTypedef(type_1981, Reflex::Literal("std::vector<GBRTree2D>::size_type"))
  .AddTypedef(type_1927, Reflex::Literal("std::vector<GBRTree2D>::difference_type"))
  .AddTypedef(type_1894, Reflex::Literal("std::vector<GBRTree2D>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_3582, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7032), Reflex::Literal("vector"), constructor_3583, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1981, type_3467, type_7032), Reflex::Literal("vector"), constructor_3584, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6414), Reflex::Literal("vector"), constructor_3585, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_3586, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1778, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x11, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x12, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_GBRTree2D__funcmem_bld);
}

//------Delayed data member builder for class vector<GBRTree2D,std::allocator<GBRTree2D> > -------------------
void __std__vector_GBRTree2D__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<GBRTree2D,std::allocator<GBRTree2D> > -------------------
void __std__vector_GBRTree2D__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6413, type_6414), Reflex::Literal("operator="), operator_3587, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_96, type_1981, type_3467), Reflex::Literal("assign"), method_3588, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2516), Reflex::Literal("begin"), method_3589, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2515), Reflex::Literal("begin"), method_3590, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2516), Reflex::Literal("end"), method_3591, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2515), Reflex::Literal("end"), method_3592, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1981), Reflex::Literal("size"), method_3597, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1981), Reflex::Literal("max_size"), method_3598, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_96, type_1981, type_795), Reflex::Literal("resize"), method_3599, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1981), Reflex::Literal("capacity"), method_3600, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2237), Reflex::Literal("empty"), method_3601, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_96, type_1981), Reflex::Literal("reserve"), method_3602, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3572, type_1981), Reflex::Literal("operator[]"), operator_3603, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3467, type_1981), Reflex::Literal("operator[]"), operator_3604, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3572, type_1981), Reflex::Literal("at"), method_3606, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3467, type_1981), Reflex::Literal("at"), method_3607, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3572), Reflex::Literal("front"), method_3608, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3467), Reflex::Literal("front"), method_3609, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3572), Reflex::Literal("back"), method_3610, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3467), Reflex::Literal("back"), method_3611, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3569), Reflex::Literal("data"), method_3612, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3465), Reflex::Literal("data"), method_3613, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_96, type_3467), Reflex::Literal("push_back"), method_3614, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_96), Reflex::Literal("pop_back"), method_3615, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2516, type_2516, type_3467), Reflex::Literal("insert"), method_3616, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_96, type_2516, type_1981, type_3467), Reflex::Literal("insert"), method_3617, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2516, type_2516), Reflex::Literal("erase"), method_3618, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2516, type_2516, type_2516), Reflex::Literal("erase"), method_3619, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_96, type_6413), Reflex::Literal("swap"), method_3620, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_96), Reflex::Literal("clear"), method_3621, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<GBRTree,std::allocator<GBRTree> > -------------------------------
static void constructor_3837( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<GBRTree>();
  else ::new(mem) ::std::vector<GBRTree>();
}

static void constructor_3838( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<GBRTree>(*(const ::std::allocator<GBRTree>*)arg[0]);
  else ::new(mem) ::std::vector<GBRTree>(*(const ::std::allocator<GBRTree>*)arg[0]);
}

static void constructor_3839( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<GBRTree>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<GBRTree>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<GBRTree>(*(::std::size_t*)arg[0],
      *(const ::GBRTree*)arg[1]);
  else ::new(mem) ::std::vector<GBRTree>(*(::std::size_t*)arg[0],
      *(const ::GBRTree*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<GBRTree>(*(::std::size_t*)arg[0],
      *(const ::GBRTree*)arg[1],
      *(const ::std::allocator<GBRTree>*)arg[2]);
  else ::new(mem) ::std::vector<GBRTree>(*(::std::size_t*)arg[0],
      *(const ::GBRTree*)arg[1],
      *(const ::std::allocator<GBRTree>*)arg[2]);
  }
}

static void constructor_3840( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<GBRTree>(*(const ::std::vector<GBRTree>*)arg[0]);
  else ::new(mem) ::std::vector<GBRTree>(*(const ::std::vector<GBRTree>*)arg[0]);
}

static void destructor_3841(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<GBRTree>*)o)->::std::vector<GBRTree>::~vector)();
}
static  void operator_3842( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<GBRTree>*)o)->operator=)(*(const ::std::vector<GBRTree>*)arg[0]);
  else   (((::std::vector<GBRTree>*)o)->operator=)(*(const ::std::vector<GBRTree>*)arg[0]);
}

static  void method_3843( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<GBRTree>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::GBRTree*)arg[1]);
}

static  void method_3844( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<GBRTree*,std::vector<GBRTree> >)((((::std::vector<GBRTree>*)o)->begin)());
  else   (((::std::vector<GBRTree>*)o)->begin)();
}

static  void method_3845( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const GBRTree*,std::vector<GBRTree> >)((((const ::std::vector<GBRTree>*)o)->begin)());
  else   (((const ::std::vector<GBRTree>*)o)->begin)();
}

static  void method_3846( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<GBRTree*,std::vector<GBRTree> >)((((::std::vector<GBRTree>*)o)->end)());
  else   (((::std::vector<GBRTree>*)o)->end)();
}

static  void method_3847( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const GBRTree*,std::vector<GBRTree> >)((((const ::std::vector<GBRTree>*)o)->end)());
  else   (((const ::std::vector<GBRTree>*)o)->end)();
}

static  void method_3852( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<GBRTree>*)o)->size)());
  else   (((const ::std::vector<GBRTree>*)o)->size)();
}

static  void method_3853( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<GBRTree>*)o)->max_size)());
  else   (((const ::std::vector<GBRTree>*)o)->max_size)();
}

static  void method_3854( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<GBRTree>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<GBRTree>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::GBRTree*)arg[1]);
  }
}

static  void method_3855( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<GBRTree>*)o)->capacity)());
  else   (((const ::std::vector<GBRTree>*)o)->capacity)();
}

static  void method_3856( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<GBRTree>*)o)->empty)());
  else   (((const ::std::vector<GBRTree>*)o)->empty)();
}

static  void method_3857( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<GBRTree>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_3858( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<GBRTree>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<GBRTree>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_3859( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<GBRTree>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<GBRTree>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_3861( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<GBRTree>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<GBRTree>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3862( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<GBRTree>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<GBRTree>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_3863( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<GBRTree>*)o)->front)();
  else   (((::std::vector<GBRTree>*)o)->front)();
}

static  void method_3864( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<GBRTree>*)o)->front)();
  else   (((const ::std::vector<GBRTree>*)o)->front)();
}

static  void method_3865( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<GBRTree>*)o)->back)();
  else   (((::std::vector<GBRTree>*)o)->back)();
}

static  void method_3866( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<GBRTree>*)o)->back)();
  else   (((const ::std::vector<GBRTree>*)o)->back)();
}

static  void method_3867( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<GBRTree>*)o)->data)());
  else   (((::std::vector<GBRTree>*)o)->data)();
}

static  void method_3868( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<GBRTree>*)o)->data)());
  else   (((const ::std::vector<GBRTree>*)o)->data)();
}

static  void method_3869( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<GBRTree>*)o)->push_back)(*(const ::GBRTree*)arg[0]);
}

static  void method_3870( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<GBRTree>*)o)->pop_back)();
}

static  void method_3871( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<GBRTree*,std::vector<GBRTree> >)((((::std::vector<GBRTree>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<GBRTree*,std::vector<GBRTree> >*)arg[0],
    *(const ::GBRTree*)arg[1]));
  else   (((::std::vector<GBRTree>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<GBRTree*,std::vector<GBRTree> >*)arg[0],
    *(const ::GBRTree*)arg[1]);
}

static  void method_3872( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<GBRTree>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<GBRTree*,std::vector<GBRTree> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::GBRTree*)arg[2]);
}

static  void method_3873( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<GBRTree*,std::vector<GBRTree> >)((((::std::vector<GBRTree>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<GBRTree*,std::vector<GBRTree> >*)arg[0]));
  else   (((::std::vector<GBRTree>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<GBRTree*,std::vector<GBRTree> >*)arg[0]);
}

static  void method_3874( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<GBRTree*,std::vector<GBRTree> >)((((::std::vector<GBRTree>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<GBRTree*,std::vector<GBRTree> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<GBRTree*,std::vector<GBRTree> >*)arg[1]));
  else   (((::std::vector<GBRTree>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<GBRTree*,std::vector<GBRTree> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<GBRTree*,std::vector<GBRTree> >*)arg[1]);
}

static  void method_3875( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<GBRTree>*)o)->swap)(*(::std::vector<GBRTree>*)arg[0]);
}

static  void method_3876( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<GBRTree>*)o)->clear)();
}

static void method_newdel_1782( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<GBRTree> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<GBRTree> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<GBRTree> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<GBRTree> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<GBRTree> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x14( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<GBRTree,std::allocator<GBRTree> >")), ::Reflex::BaseOffset< ::std::vector<GBRTree>,::std::_Vector_base<GBRTree,std::allocator<GBRTree> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x15( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<GBRTree> >::Generate();
  else ::Reflex::Proxy< ::std::vector<GBRTree> >::Generate();
}

//------Dictionary for class vector<GBRTree,std::allocator<GBRTree> > -------------------------------
void __std__vector_GBRTree__db_datamem(Reflex::Class*);
void __std__vector_GBRTree__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_GBRTree__datamem_bld(&__std__vector_GBRTree__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_GBRTree__funcmem_bld(&__std__vector_GBRTree__db_funcmem);
void __std__vector_GBRTree__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<GBRTree>"), typeid(::std::vector<GBRTree>), sizeof(::std::vector<GBRTree>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2014, ::Reflex::BaseOffset< ::std::vector<GBRTree>, ::std::_Vector_base<GBRTree,std::allocator<GBRTree> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_25, Reflex::Literal("std::vector<GBRTree>::_Alloc_value_type"))
  .AddTypedef(type_2014, Reflex::Literal("std::vector<GBRTree>::_Base"))
  .AddTypedef(type_1898, Reflex::Literal("std::vector<GBRTree>::_Tp_alloc_type"))
  .AddTypedef(type_25, Reflex::Literal("std::vector<GBRTree>::value_type"))
  .AddTypedef(type_3824, Reflex::Literal("std::vector<GBRTree>::pointer"))
  .AddTypedef(type_3476, Reflex::Literal("std::vector<GBRTree>::const_pointer"))
  .AddTypedef(type_3827, Reflex::Literal("std::vector<GBRTree>::reference"))
  .AddTypedef(type_3478, Reflex::Literal("std::vector<GBRTree>::const_reference"))
  .AddTypedef(type_2520, Reflex::Literal("std::vector<GBRTree>::iterator"))
  .AddTypedef(type_2519, Reflex::Literal("std::vector<GBRTree>::const_iterator"))
  .AddTypedef(type_1994, Reflex::Literal("std::vector<GBRTree>::const_reverse_iterator"))
  .AddTypedef(type_1995, Reflex::Literal("std::vector<GBRTree>::reverse_iterator"))
  .AddTypedef(type_1981, Reflex::Literal("std::vector<GBRTree>::size_type"))
  .AddTypedef(type_1927, Reflex::Literal("std::vector<GBRTree>::difference_type"))
  .AddTypedef(type_1898, Reflex::Literal("std::vector<GBRTree>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_3837, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7038), Reflex::Literal("vector"), constructor_3838, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_1981, type_3478, type_7038), Reflex::Literal("vector"), constructor_3839, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6912), Reflex::Literal("vector"), constructor_3840, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_3841, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1782, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x14, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x15, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_GBRTree__funcmem_bld);
}

//------Delayed data member builder for class vector<GBRTree,std::allocator<GBRTree> > -------------------
void __std__vector_GBRTree__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<GBRTree,std::allocator<GBRTree> > -------------------
void __std__vector_GBRTree__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6911, type_6912), Reflex::Literal("operator="), operator_3842, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_96, type_1981, type_3478), Reflex::Literal("assign"), method_3843, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2520), Reflex::Literal("begin"), method_3844, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2519), Reflex::Literal("begin"), method_3845, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2520), Reflex::Literal("end"), method_3846, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2519), Reflex::Literal("end"), method_3847, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1981), Reflex::Literal("size"), method_3852, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1981), Reflex::Literal("max_size"), method_3853, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_96, type_1981, type_25), Reflex::Literal("resize"), method_3854, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1981), Reflex::Literal("capacity"), method_3855, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2237), Reflex::Literal("empty"), method_3856, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_96, type_1981), Reflex::Literal("reserve"), method_3857, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3827, type_1981), Reflex::Literal("operator[]"), operator_3858, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3478, type_1981), Reflex::Literal("operator[]"), operator_3859, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3827, type_1981), Reflex::Literal("at"), method_3861, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3478, type_1981), Reflex::Literal("at"), method_3862, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3827), Reflex::Literal("front"), method_3863, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3478), Reflex::Literal("front"), method_3864, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3827), Reflex::Literal("back"), method_3865, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3478), Reflex::Literal("back"), method_3866, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3824), Reflex::Literal("data"), method_3867, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3476), Reflex::Literal("data"), method_3868, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_96, type_3478), Reflex::Literal("push_back"), method_3869, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_96), Reflex::Literal("pop_back"), method_3870, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2520, type_2520, type_3478), Reflex::Literal("insert"), method_3871, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_96, type_2520, type_1981, type_3478), Reflex::Literal("insert"), method_3872, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2520, type_2520), Reflex::Literal("erase"), method_3873, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2520, type_2520, type_2520), Reflex::Literal("erase"), method_3874, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_96, type_6911), Reflex::Literal("swap"), method_3875, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_96), Reflex::Literal("clear"), method_3876, 0, 0, ::Reflex::PUBLIC);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __GBRTree_dict(); 
      __ElectronLikelihoodCalibration_dict(); 
      __ElectronLikelihoodCategoryData_dict(); 
      __GBRForest2D_dict(); 
      __GBRTree2D_dict(); 
      __GBRForest_dict(); 
      __ElectronLikelihoodCalibration__Entry_dict(); 
      __std__vector_ElectronLikelihoodCalibration__Entry__dict(); 
      __std__vector_GBRTree2D__dict(); 
      __std__vector_GBRTree__dict(); 
    }
    ~Dictionaries() {
      type_25.Unload(); // class GBRTree 
      type_342.Unload(); // class ElectronLikelihoodCalibration 
      type_526.Unload(); // class ElectronLikelihoodCategoryData 
      type_543.Unload(); // class GBRForest2D 
      type_795.Unload(); // class GBRTree2D 
      type_1648.Unload(); // class GBRForest 
      type_2443.Unload(); // class ElectronLikelihoodCalibration::Entry 
      type_1777.Unload(); // class std::vector<ElectronLikelihoodCalibration::Entry> 
      type_1778.Unload(); // class std::vector<GBRTree2D> 
      type_1782.Unload(); // class std::vector<GBRTree> 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
