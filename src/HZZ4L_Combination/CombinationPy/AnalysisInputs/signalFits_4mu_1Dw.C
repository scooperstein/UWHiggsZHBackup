/////////////////////////////////////////////////////////////////////////
//
// 'ORGANIZATION AND SIMULTANEOUS FITS' RooFit tutorial macro #503
// 
// Reading and using a workspace
//
// --> The input file for this macro is generated by rf502_wspaceread.C
// 
//
// 07/2008 - Wouter Verkerke 
//
/////////////////////////////////////////////////////////////////////////
/*
#ifndef __CINT__
#include "RooGlobalFunc.h"
#endif

#include "RooRealVar.h"
#include "RooDataSet.h"
#include "RooGaussian.h"
#include "RooConstVar.h"
#include "RooChebychev.h"
#include "RooAddPdf.h"
#include "RooWorkspace.h"
#include "RooPlot.h"
#include "TCanvas.h"
#include "TAxis.h"
#include "TFile.h"
#include "TH1.h"
 //*/
#include "TH1F.h"
#include "TNtuple.h"
#include "TCanvas.h"
#include <fstream>
#include <iostream>
#include <string>
#include <iomanip>
#include <sstream>
#include <algorithm>
#include "TCutG.h"
#include "TFile.h"
#include "TH2.h"
#include "TPad.h"

using namespace RooFit ;
using namespace std;
using namespace ROOT::Math;


void signalFits_4mu_1Dw(int channel = 1)
{

	gSystem->AddIncludePath("-I$ROOFITSYS/include");
	gROOT->ProcessLine(".L ~/tdrstyle.C");
	setTDRStyle();
	gStyle->SetStatX(-0.5);
	//gSystem->Load("PDFs/RooRelBW1_cxx.so");
	//gSystem->Load("PDFs/RooRelBW2_cxx.so");
	gSystem->Load("../CreateDatacards/PDFs/HZZ4LRooPdfs_cc.so");

	string schannel;
	if (channel == 1) schannel = "4mu";
	if (channel == 2) schannel = "4e";
	if (channel == 3) schannel = "2mu2e";
	std::cout << "schannel = " << schannel << std::endl;

	const int nPoints = 17.;
	int masses[nPoints] = {120,130,140,150,160,170,180,190,200,250,300,350,400,450,500,550,600};
	double mHVal[nPoints] = {120,130,140,150,160,170,180,190,200,250,300,350,400,450,500,550,600};
	double widths[nPoints] = {3.48e-03,4.88e-03,8.14e-03,1.73e-02,8.30e-02,3.80e-01,6.31e-01,1.04e+00,1.43e+00,4.04e+00,8.43e+00,1.52e+01,2.92e+01,46.95,6.80e+01,93.15,1.23e+02};
	// R e a d   w o r k s p a c e   f r o m   f i l e
	// -----------------------------------------------
	
	double a_meanBW[nPoints];
	double a_gammaBW[nPoints];
	double a_meanCB[nPoints];
	double a_sigmaCB[nPoints];
	double a_alphaCB[nPoints];
	double a_nCB[nPoints];
		
	for (int i = 0; i < nPoints; i++){
	//for (int i = 0; i < 1; i++){
		
		// Open input file with workspace (generated by rf14_wspacewrite)
		char infile[192];
		sprintf(infile,"dataLM_wWeights/standard/signal/%s/ZZAnalysisTree_H%i%s.root",schannel.c_str(),masses[i],schannel.c_str());
		TFile *f = new TFile(infile) ;
		char outfile[192];
		sprintf( outfile, "sigFigs/pdf_%s_sig%i.eps", schannel.c_str(), masses[i] );
		//f->ls();
		
		double windowVal = max( widths[i], 1. );
		if (mHVal[i] >= 275){ lowside = 180.; }
		else { lowside = 100.; }
		double low_M = max( (mHVal[i] - 20.*windowVal), lowside) ;
		double high_M = min( (mHVal[i] + 15.*windowVal), 900.) ;

		//double windowVal = max( widths[i], 1.);
		//double windowVal = max ( widths[i], 1. );
		//low_M = max( (mHVal[i] - 25.*windowVal), 100.) ;
		//high_M = min( (mHVal[i] + 20.*windowVal), 1000.) ;
		//low_M = max( (mHVal[i] - 15.*windowVal), 100.) ;
		//high_M = min( (mHVal[i] + 10.*windowVal), 1000.) ;
		std::cout << "lowM = " << low_M << ", highM = " << high_M << std::endl;
			
		/////////
		// r e a d   i n   w e i g h t e d   u n b i n n e d   d a t a 
		RooRealVar* MC_weight = new RooRealVar("MC_weight","MC_weight",0.,2.) ; 
		RooRealVar* ZZMass = new RooRealVar("ZZMass","ZZMass",100.,1000.);

		RooDataSet* set = new RooDataSet("set","set",(TTree*)f->Get("SelectedTree"),RooArgSet(*ZZMass,*MC_weight),0,"MC_weight");
		ZZMass->setRange(low_M,high_M);
		
		
		//for (int a=0 ; a<set->numEntries() ; a++) { 
		//	set->get(a) ; 
		//	//cout << ZZMass->getVal() << " = " << set->weight() << endl ; 
		//} 
		
		// constraining parameters...
		double l_sigmaCB = 0., s_sigmaCB = 3.;
		if (mHVal[i] >= 500.){ l_sigmaCB = 10.; s_sigmaCB = 12.; }
		double h_alpha_CB = 1.15;
		if (mHVal[i] >= 500.){ h_alpha_CB = 0.99; }

		double s_alpha_CB = 1.2 + (-0.4/590)*(mHVal[i]-110.);
		
		double l_meanCB = -25.;
		if (mHVal[i]>=450.) l_meanCB = -0.;
		
		RooRealVar mean_CB("mean_CB","mean_CB",0.,l_meanCB,25);
		RooRealVar sigma_CB("sigma_CB","sigma_CB",s_sigmaCB,l_sigmaCB,30.);
		//RooRealVar alpha_CB("alpha_CB","alpha_CB",0.9,0.7,h_alpha_CB);
		RooRealVar alpha_CB("alpha_CB","alpha_CB",s_alpha_CB,0.5,2.5);
		RooRealVar n_CB("n_CB","n_CB",1.7,1.0,2.4);
		RooCBShape signalCB("signalCB","signalCB",*ZZMass,mean_CB,sigma_CB,alpha_CB,n_CB);
		
		RooRealVar mean_BW("mean_BW","mean_BW", mHVal[i] ,100.,1000.);
		RooRealVar gamma_BW("gamma_BW","gamma_BW",widths[i],0.,200.);
		
		RooRelBWUF signalBW("signalBW", "signalBW",*ZZMass,mean_BW);
		//RooRelBW1 signalBW("signalBW", "signalBW",*ZZMass,mean_BW,gamma_BW);
		RooBreitWigner signalBW1("signalBW1", "signalBW1",*ZZMass,mean_BW,gamma_BW);
		RooRelBW1 signalBW2("signalBW2", "signalBW2",*ZZMass,mean_BW,gamma_BW);
		RooRealVar x("x","x",1.);
		RooRelBWUFParam signalBW3("signalBW3", "signalBW3",*ZZMass,mean_BW,x);
		RooRealVar y("y","y",0.33333);
		RooRelBWUFParam signalBW4("signalBW4", "signalBW4",*ZZMass,mean_BW,y);

		//Set #bins to be used for FFT sampling to 10000
		ZZMass->setBins(100000,"fft") ;

		//Construct BW (x) CB
		RooFFTConvPdf* sig_ggH = new RooFFTConvPdf("sig_ggH","BW (X) CB",*ZZMass,signalBW,signalCB, 2);
		// Buffer fraction for cyclical behavior
		sig_ggH->setBufferFraction(0.2);
		
		double m = mHVal[i];
		double val_n_CB = -0.00063*m + 1.7;
	    double val_alpha_CB = -0.0013*m + 1.5;
	    double val_mean_CB = 8.9e-08*m*m*m - 1.9e-05*m*m - 0.0035*m + 0.48;
	    double val_sigma_CB = 2.4e-11*m*m*m*m + 1.1e-07*m*m*m - 3.3e-05*m*m + 0.013*m;
		

		mean_CB.setVal(val_mean_CB);
		mean_CB.setConstant(kTRUE);
		sigma_CB.setVal(val_sigma_CB);
		sigma_CB.setConstant(kTRUE);
		n_CB.setVal(val_n_CB);
		n_CB.setConstant(kTRUE);
		alpha_CB.setVal(val_alpha_CB);
		alpha_CB.setConstant(kTRUE);
		mean_BW.setConstant(kTRUE);
		gamma_BW.setConstant(kTRUE);
	
		//////RooFitResult *r = sig_ggH->fitTo( *set, SumW2Error(kTRUE) );//, Save(kTRUE), SumW2Error(kTRUE)) ;
		a_meanBW[i] = mean_BW.getVal();
		a_gammaBW[i] = gamma_BW.getVal();
		a_meanCB[i] = mean_CB.getVal();
		a_sigmaCB[i] = sigma_CB.getVal();
		a_alphaCB[i] = alpha_CB.getVal();
		a_nCB[i] = n_CB.getVal();
		
		
		// Plot Y
		RooPlot* frameM4l = ZZMass->frame(Title("M4L"),Bins(100)) ;
		set->plotOn(frameM4l) ;
		sig_ggH.plotOn(frameM4l) ;

		RooPlot* testFrame = ZZMass->frame(Title("M4L"),Bins(100)) ;
		signalBW.plotOn(testFrame) ;
		signalBW1.plotOn(testFrame, LineColor(kBlack)) ;
		signalBW2.plotOn(testFrame, LineColor(kRed)) ;
		signalBW3.plotOn(testFrame, LineColor(kMagenta)) ;
		signalBW4.plotOn(testFrame, LineColor(kGreen)) ;
				
		TCanvas *c = new TCanvas("c","c",800,600);
		c->cd();
		frameM4l->Draw();
		char plotName[192];
		sprintf(plotName,"sigFigs_4mu_1D/%s_m%i.eps",schannel.c_str(),masses[i]);
		
		c->SaveAs(plotName);

		TCanvas *c3 = new TCanvas("c3","c3",800,600);
		c3->cd();
		testFrame->Draw();
		//char plotName[192];
		sprintf(plotName,"sigFigs_4mu_1D/%s_shape%i.eps",schannel.c_str(),masses[i]);
		
		c3->SaveAs(plotName);
		
		
		delete f;
		delete set;
		delete c;
	}
	

	TGraph* gr_meanBW = new TGraph( nPoints, mHVal, a_meanBW );
	TGraph* gr_gammaBW = new TGraph( nPoints, mHVal, a_gammaBW );
	TGraph* gr_meanCB = new TGraph( nPoints, mHVal, a_meanCB );
	TGraph* gr_sigmaCB = new TGraph( nPoints, mHVal, a_sigmaCB );
	TGraph* gr_alphaCB = new TGraph( nPoints, mHVal, a_alphaCB );
	TGraph* gr_nCB = new TGraph( nPoints, mHVal, a_nCB );
	
	//TF1 *polyFunc1= new TF1("polyFunc1","[0]+[1]*x+[2]*(x-[3])*(x-[3])+[4]*x*x*x*x", 120., 600.);
	//polyFunc1->SetParameters(1., 1., 1., 100.,0.1);
	//TF1 *polyFunc2= new TF1("polyFunc2","[0]+[1]*x+[2]*(x-[3])*(x-[3])+[4]*x*x*x*x", 120., 600.);
	//polyFunc2->SetParameters(1., 1., 1., 100.,0.1);
	TF1 *polyFunc1= new TF1("polyFunc1","[0]+[1]*x+[2]*(x-[3])*(x-[3])", 120., 600.);
	polyFunc1->SetParameters(1., 1., 1., 100.);
	TF1 *polyFunc2= new TF1("polyFunc2","[0]+[1]*x+[2]*(x-[3])*(x-[3])", 120., 600.);
	polyFunc2->SetParameters(1., 1., 1., 100.);
	
	
	TCanvas *c = new TCanvas("c","c",1200,800);
	c->Divide(3,2);
	//c->SetGrid();
	//TH1F *hr = c->DrawFrame(0.,0.,610.,1.);
	c->cd(1);
	gr_meanBW->Draw("alp");
	gr_meanBW->GetXaxis()->SetTitle("mean BW");
	c->cd(2);
	gr_gammaBW->Draw("alp");
	gr_gammaBW->GetXaxis()->SetTitle("gamma BW");
	c->cd(3);
	gr_meanCB->Fit(polyFunc1,"Rt");
	gr_meanCB->Draw("alp");
	gr_meanCB->GetXaxis()->SetTitle("mean CB");
	c->cd(4);
	gr_sigmaCB->Fit(polyFunc2,"Rt");
	gr_sigmaCB->Draw("alp");
	gr_sigmaCB->GetXaxis()->SetTitle("sigma CB");
	c->cd(5);
	gr_alphaCB->Draw("alp");
	gr_alphaCB->GetXaxis()->SetTitle("alpha CB");
	c->cd(6);
	gr_nCB->Draw("alp");
	gr_nCB->GetXaxis()->SetTitle("n CB");
	char paramout[192];
	sprintf(paramout,"sigFigs/params_%s.eps",schannel.c_str());
	c->SaveAs(paramout);
	
	std::cout << "mean_CB = " << polyFunc1->GetParameter(0) << " + " << polyFunc1->GetParameter(1) << "*m + " << polyFunc1->GetParameter(2) << "*(m - " << polyFunc1->GetParameter(3) << ")*(m - " << polyFunc1->GetParameter(3);
	std::cout << ") + " << polyFunc1->GetParameter(4) << "*m*m*m*m;" << std::endl;
	std::cout << "sigma_CB = " << polyFunc2->GetParameter(0) << " + " << polyFunc2->GetParameter(1) << "*m + " << polyFunc2->GetParameter(2) << "*(m - " << polyFunc2->GetParameter(3) << ")*(m - " << polyFunc2->GetParameter(3);
	std::cout << ") + " << polyFunc2->GetParameter(4) << "*m*m*m*m;" << std::endl;
	
	
	// calculate sysetmatic errors from interpolation...
	double sum_meanCB = 0;
	double sum_sigmaCB = 0;
	for (int i = 0; i < nPoints; i++){
		double tmp_meanCB = (polyFunc1->Eval(mHVal[i]) - a_meanCB[i]);
		sum_meanCB += (tmp_meanCB*tmp_meanCB);
		double tmp_sigmaCB = (polyFunc2->Eval(mHVal[i]) - a_sigmaCB[i])/a_sigmaCB[i];
		sum_sigmaCB += (tmp_sigmaCB*tmp_sigmaCB);
		std::cout << "mean: " << tmp_meanCB << ", sigma: " << tmp_sigmaCB << std::endl;
	}
	double rms_meanCB = sqrt( sum_meanCB/( (double) nPoints) );
	double rms_sigmaCB = sqrt( sum_sigmaCB/( (double) nPoints) );
	std::cout << "err (meanCB) = " << rms_meanCB << ", err (sigmaCB) = " << rms_sigmaCB << std::endl;
	
	
}
