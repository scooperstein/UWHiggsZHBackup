/////////////////////////////////////////////////////////////////////////
//
// 'ORGANIZATION AND SIMULTANEOUS FITS' RooFit tutorial macro #503
// 
// Reading and using a workspace
//
// --> The input file for this macro is generated by rf502_wspaceread.C
// 
//
// 07/2008 - Wouter Verkerke 
//
/////////////////////////////////////////////////////////////////////////
/*
#ifndef __CINT__
#include "RooGlobalFunc.h"
#endif

#include "RooRealVar.h"
#include "RooDataSet.h"
#include "RooGaussian.h"
#include "RooConstVar.h"
#include "RooChebychev.h"
#include "RooAddPdf.h"
#include "RooWorkspace.h"
#include "RooPlot.h"
#include "TCanvas.h"
#include "TAxis.h"
#include "TFile.h"
#include "TH1.h"
 //*/
#include "TH1F.h"
#include "TNtuple.h"
#include "TCanvas.h"
#include <fstream>
#include <iostream>
#include <string>
#include <iomanip>
#include <sstream>
#include <algorithm>
#include "TCutG.h"
#include "TFile.h"
#include "TH2.h"
#include "TPad.h"

using namespace RooFit ;
using namespace std;
using namespace ROOT::Math;


void plotSignals_4mu(int channel = 1)
{

	gSystem->AddIncludePath("-I$ROOFITSYS/include");
	gROOT->ProcessLine(".L ~/tdrstyle.C");
	setTDRStyle();
	//gSystem->Load("PDFs/RooRelBW1_cxx.so");
	//gSystem->Load("PDFs/RooRelBW2_cxx.so");
	gSystem->Load("../PDFs/HZZ4LRooPdfs_cc.so");

	string schannel;
	if (channel == 1) schannel = "4mu";
	if (channel == 2) schannel = "4e";
	if (channel == 3) schannel = "2mu2e";
	std::cout << "schannel = " << schannel << std::endl;

	const int nPoints = 17.;
	int masses[nPoints] = {120,130,140,150,160,170,180,190,200,250,300,350,400,450,500,550,600};
	double mHVal[nPoints] = {120,130,140,150,160,170,180,190,200,250,300,350,400,450,500,550,600};
	double widths[nPoints] = {3.48e-03,4.88e-03,8.14e-03,1.73e-02,8.30e-02,3.80e-01,6.31e-01,1.04e+00,1.43e+00,4.04e+00,8.43e+00,1.52e+01,2.92e+01,46.95,6.80e+01,93.15,1.23e+02};
	// R e a d   w o r k s p a c e   f r o m   f i l e
	// -----------------------------------------------
	
	double a_meanBW[nPoints];
	double a_gammaBW[nPoints];
	double a_meanCB[nPoints];
	double a_sigmaCB[nPoints];
	double a_alphaCB[nPoints];
	double a_nCB[nPoints];
		
	//for (int i = 0; i < nPoints; i++){
	for (int i = 0; i < (nPoints-3); i++){
		
		// Open input file with workspace (generated by rf14_wspacewrite)
		char infile[192];
		sprintf(infile,"/scratch/hep/ntran/dataFiles/HZZ4L/datasets/datasets_baseline/%s/ZZAnalysisTree_H%i%s.root",schannel.c_str(),masses[i],schannel.c_str());
		TFile *f = new TFile(infile) ;
		char outfile[192];
		sprintf( outfile, "figs/pdf_%s_bkg_highmass.eps", schannel.c_str() );
		//f->ls();
		
		double windowVal = max( widths[i], 1. );
		if (mHVal[i] >= 275){ lowside = 180.; }
		else { lowside = 100.; }
		double low_M = max( (mHVal[i] - 20.*windowVal), lowside) ;
		//double high_M = min( (mHVal[i] + 15.*windowVal), 900.) ;
		double high_M = min( (mHVal[i] + 15.*windowVal), 600.) ;

		std::cout << "lowM = " << low_M << ", highM = " << high_M << std::endl;
			
		RooDataSet* set = (RooDataSet*) f->Get("data");
		RooArgSet* obs = set->get() ;
		obs->Print();
		RooRealVar* CMS_zz4l_mass = (RooRealVar*) obs->find("CMS_zz4l_mass") ;
		CMS_zz4l_mass->setRange(low_M,high_M);
		for (int a=0 ; a<set->numEntries() ; a++) { 
			set->get(a) ; 
			//cout << CMS_zz4l_mass->getVal() << " = " << set->weight() << endl ; 
		} 
		
		// constraining parameters...
		double l_sigmaCB = 0., s_sigmaCB = 3.;
		if (mHVal[i] >= 500.){ l_sigmaCB = 10.; s_sigmaCB = 12.; }
		double h_alpha_CB = 1.15;
		if (mHVal[i] >= 500.){ h_alpha_CB = 0.99; }

		double s_alpha_CB = 1.2 + (-0.4/590)*(mHVal[i]-110.);
		
		RooRealVar mean_CB("mean_CB","mean_CB",0.,-25.,25);
		RooRealVar sigma_CB("sigma_CB","sigma_CB",s_sigmaCB,l_sigmaCB,30.);
		//RooRealVar alpha_CB("alpha_CB","alpha_CB",0.9,0.7,h_alpha_CB);
		RooRealVar alpha_CB("alpha_CB","alpha_CB",s_alpha_CB);
		RooRealVar n_CB("n_CB","n_CB",1.7,1.5,2.4);
		RooCBShape signalCB("signalCB","signalCB",*CMS_zz4l_mass,mean_CB,sigma_CB,alpha_CB,n_CB);
		
		RooRealVar mean_BW("mean_BW","mean_BW", mHVal[i] ,100.,1000.);
		RooRealVar gamma_BW("gamma_BW","gamma_BW",widths[i],0.,200.);
		//RooBreitWigner signalBW("signalBW", "signalBW",*CMS_zz4l_mass,mean_BW,gamma_BW);
		//RooRelBW1 signalBW("signalBW", "signalBW",*CMS_zz4l_mass,mean_BW,gamma_BW);
		
		RooRelBWUF signalBW("signalBW", "signalBW",*CMS_zz4l_mass,mean_BW);
		//RooRelBW1 signalBW("signalBW", "signalBW",*CMS_zz4l_mass,mean_BW,gamma_BW);
		RooBreitWigner signalBW1("signalBW1", "signalBW1",*CMS_zz4l_mass,mean_BW,gamma_BW);
		RooRelBW1 signalBW2("signalBW2", "signalBW2",*CMS_zz4l_mass,mean_BW,gamma_BW);
		RooRealVar x("x","x",1.);
		RooRelBWUFParam signalBW3("signalBW3", "signalBW3",*CMS_zz4l_mass,mean_BW,x);
		RooRealVar y("y","y",0.33333);
		RooRelBWUFParam signalBW4("signalBW4", "signalBW4",*CMS_zz4l_mass,mean_BW,y);

		//Set #bins to be used for FFT sampling to 10000
		CMS_zz4l_mass->setBins(100000,"fft") ;

		//Construct BW (x) CB
		RooFFTConvPdf* sig_ggH = new RooFFTConvPdf("sig_ggH","BW (X) CB",*CMS_zz4l_mass,signalBW,signalCB, 2);
		// Buffer fraction for cyclical behavior
		sig_ggH->setBufferFraction(0.2);
		
		mean_BW.setConstant(kTRUE);
		gamma_BW.setConstant(kTRUE);
		n_CB.setConstant(kTRUE);
		//alpha_CB.setConstant(kTRUE);
		
		RooFitResult *r = sig_ggH.fitTo( *set, SumW2Error(kTRUE) );//, Save(kTRUE), SumW2Error(kTRUE)) ;
		
		a_meanBW[i] = mean_BW.getVal();
		a_gammaBW[i] = gamma_BW.getVal();
		a_meanCB[i] = mean_CB.getVal();
		a_sigmaCB[i] = sigma_CB.getVal();;
		a_alphaCB[i] = alpha_CB.getVal();;
		a_nCB[i] = n_CB.getVal();;
		
		
		///////////////////////////////////////////////////
		// P l o t t i n g
		int iLineColor = 1;
		string lab = "blah";
		if (channel == 1) { iLineColor = 2; lab = "4#mu"; }
		if (channel == 3) { iLineColor = 4; lab = "2e2#mu"; }
		if (channel == 2) { iLineColor = 6; lab = "4e"; }
		double separation = 0.5;
		if (mHVal[i] >= 300.) separation = 2;
		double nbins = (high_M-low_M);
		nbins /= separation;
		char yname[192];
		sprintf(yname,"Events / %1.1f GeV/c^{2}", separation);
		char lname[192];
		sprintf(lname,"M_{H} = %i [GeV/c^{2}]", (int) mHVal[i] );
		char lname2[192];
		sprintf(lname2,"Shape Model, %s", lab.c_str() );
		
		RooPlot* frameM4l = CMS_zz4l_mass->frame(Bins( (int) nbins )) ;
		set->plotOn(frameM4l) ;
		sig_ggH->plotOn(frameM4l, LineColor(iLineColor)) ;
		
		// dummy!
		TF1* dummyF = new TF1("dummyF","1",0.,1.);
		TH1F* dummyH = new TH1F("dummyG","dummyG",1, 0.,1.);
		dummyF->SetLineColor( iLineColor );
		//dummyH->SetLineColor( kBlue );
		TLegend * box2 = new TLegend(0.17,0.70,0.52,0.90);
		box2->SetFillColor(0);
		box2->SetBorderSize(0);
		box2->AddEntry(dummyH,"Simulation (Powheg + CMS)  ","pe");
		box2->AddEntry(dummyH,lname,"");
		box2->AddEntry(dummyF,lname2,"l");
		
		TPaveText *pt = new TPaveText(0.15,0.955,0.4,0.99,"NDC");
        pt->SetFillColor(0);
		pt->SetBorderSize(0);
        pt->AddText("CMS Preliminary 2011");
		TPaveText *pt2 = new TPaveText(0.83,0.955,0.99,0.99,"NDC");
        pt2->SetFillColor(0);
		pt2->SetBorderSize(0);
        pt2->AddText("#sqrt{s} = 7 TeV"); 		
		
		
		
		frameM4l->SetTitle("");
        frameM4l->GetXaxis()->SetTitle("M_{4l} [GeV/c^{2}]");
        frameM4l->GetYaxis()->SetTitleOffset(1.2);		
		frameM4l->GetYaxis()->SetTitle(yname);		
		
		TCanvas *c = new TCanvas("c","c",800,600);
		c->cd();
		frameM4l->Draw();
		box2->Draw();
		pt->Draw();
		pt2->Draw();
		char plotName[192];
		sprintf(plotName,"sigFigs/m%i.eps",masses[i]);
		
		c->SaveAs(plotName);
		
		///////////////////////////////////////////////////
		
		RooPlot* testFrame = CMS_zz4l_mass->frame(Title("M4L"),Bins(100)) ;
		signalBW.plotOn(testFrame) ;
		signalBW1.plotOn(testFrame, LineColor(kBlack)) ;
		signalBW2.plotOn(testFrame, LineColor(kRed)) ;		
		
		TCanvas *c3 = new TCanvas("c3","c3",800,600);
		c3->cd();
		testFrame->Draw();
		//char plotName[192];
		sprintf(plotName,"sigFigs/shape%i.eps",masses[i]);
		
		c3->SaveAs(plotName);
		
		///////////////////////////////////////////////////		
		
		delete f;
		delete set;
		delete c;
	}
	

	TGraph* gr_meanBW = new TGraph( nPoints, mHVal, a_meanBW );
	TGraph* gr_gammaBW = new TGraph( nPoints, mHVal, a_gammaBW );
	TGraph* gr_meanCB = new TGraph( nPoints, mHVal, a_meanCB );
	TGraph* gr_sigmaCB = new TGraph( nPoints, mHVal, a_sigmaCB );
	TGraph* gr_alphaCB = new TGraph( nPoints, mHVal, a_alphaCB );
	TGraph* gr_nCB = new TGraph( nPoints, mHVal, a_nCB );
	
	TF1 *polyFunc1= new TF1("polyFunc1","[0]+[1]*x+[2]*(x-[3])*(x-[3])+[4]*x*x*x*x", 120., 600.);
	polyFunc1->SetParameters(1., 1., 1., 100.,0.1);
	TF1 *polyFunc2= new TF1("polyFunc2","[0]+[1]*x+[2]*(x-[3])*(x-[3])+[4]*x*x*x*x", 120., 600.);
	polyFunc2->SetParameters(1., 1., 1., 100.,0.1);
	
	
	TCanvas *c = new TCanvas("c","c",1200,800);
	c->Divide(3,2);
	//c->SetGrid();
	//TH1F *hr = c->DrawFrame(0.,0.,610.,1.);
	c->cd(1);
	gr_meanBW->Draw("alp");
	gr_meanBW->GetXaxis()->SetTitle("mean BW");
	c->cd(2);
	gr_gammaBW->Draw("alp");
	gr_gammaBW->GetXaxis()->SetTitle("gamma BW");
	c->cd(3);
	gr_meanCB->Fit(polyFunc1,"Rt");
	gr_meanCB->Draw("alp");
	gr_meanCB->GetXaxis()->SetTitle("mean CB");
	c->cd(4);
	gr_sigmaCB->Fit(polyFunc2,"Rt");
	gr_sigmaCB->Draw("alp");
	gr_sigmaCB->GetXaxis()->SetTitle("sigma CB");
	c->cd(5);
	gr_alphaCB->Draw("alp");
	gr_alphaCB->GetXaxis()->SetTitle("alpha CB");
	c->cd(6);
	gr_nCB->Draw("alp");
	gr_nCB->GetXaxis()->SetTitle("n CB");
	c->SaveAs("sigFigs/params.eps");
	
	std::cout << "mean_CB = " << polyFunc1->GetParameter(0) << " + " << polyFunc1->GetParameter(1) << "*m + " << polyFunc1->GetParameter(2) << "*(m - " << polyFunc1->GetParameter(3) << ")*(m - " << polyFunc1->GetParameter(3);
	std::cout << ") + " << polyFunc1->GetParameter(4) << "*m*m*m*m;" << std::endl;
	std::cout << "sigma_CB = " << polyFunc2->GetParameter(0) << " + " << polyFunc2->GetParameter(1) << "*m + " << polyFunc2->GetParameter(2) << "*(m - " << polyFunc2->GetParameter(3) << ")*(m - " << polyFunc2->GetParameter(3);
	std::cout << ") + " << polyFunc2->GetParameter(4) << "*m*m*m*m;" << std::endl;
	
	
	// calculate sysetmatic errors from interpolation...
	double sum_meanCB = 0;
	double sum_sigmaCB = 0;
	for (int i = 0; i < nPoints; i++){
		double tmp_meanCB = (polyFunc1->Eval(mHVal[i]) - a_meanCB[i]);
		sum_meanCB += (tmp_meanCB*tmp_meanCB);
		double tmp_sigmaCB = (polyFunc2->Eval(mHVal[i]) - a_sigmaCB[i])/a_sigmaCB[i];
		sum_sigmaCB += (tmp_sigmaCB*tmp_sigmaCB);
		std::cout << "mean: " << tmp_meanCB << ", sigma: " << tmp_sigmaCB << std::endl;
	}
	double rms_meanCB = sqrt( sum_meanCB/( (double) nPoints) );
	double rms_sigmaCB = sqrt( sum_sigmaCB/( (double) nPoints) );
	std::cout << "err (meanCB) = " << rms_meanCB << ", err (sigmaCB) = " << rms_sigmaCB << std::endl;
	
	
}
