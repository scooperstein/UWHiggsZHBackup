//
// 'ORGANIZATION AND SIMULTANEOUS FITS' RooFit tutorial macro #503
// 
// Reading and using a workspace
//
// --> The input file for this macro is generated by rf502_wspaceread.C
// 
//
// 07/2008 - Wouter Verkerke 
//
/////////////////////////////////////////////////////////////////////////

#ifndef __CINT__
#include "RooGlobalFunc.h"
#endif

#include "RooRealVar.h"
#include "RooDataSet.h"
#include "RooGaussian.h"
#include "RooConstVar.h"
#include "RooChebychev.h"
#include "RooAddPdf.h"
#include "RooCBShape.h"
#include "RooWorkspace.h"
#include "RooPlot.h"
#include "TCanvas.h"
#include "TAxis.h"
#include "TFile.h"
#include "TH1.h"
#include "RooFFTConvPdf.h"
#include "TGraphErrors.h"
#include "RooFitResult.h"
#include "TSystem.h"
#include "RooDataHist.h"
 
#include "TH1F.h"
#include "TNtuple.h"
#include "TCanvas.h"
#include <fstream>
#include <iostream>
#include <string>
#include <iomanip>
#include <sstream>
#include <algorithm>
#include "TCutG.h"
#include "TFile.h"
#include "TH2.h"
#include "TPad.h"

#include "HZZ4LRooPdfs.cc"
#include "FloridaStyle.C"

using namespace RooFit ;
using namespace std;
//using namespace ROOT::Math;


void signalFitsCB(int channel = 1)
{

	//gSystem->AddIncludePath("-I$ROOFITSYS/include");
	
	//gSystem->Load("HZZ4LRooPdfs_cc.so");
	FloridaStyle();

	TString schannel;
	if (channel == 1) schannel = "4mu";
	if (channel == 2) schannel = "4e";
	if (channel == 3) schannel = "2e2mu";
	std::cout << "schannel = " << schannel << std::endl;

	const int nPoints = 24;
	int masses[nPoints] = {115,120,130,140,150,160,170,180,190,200,210,220,230,250,275,300,325,350,375,400,425,450,500,600};
	double mHVal[nPoints] = {115,120,130,140,150,160,170,180,190,200,210,220,230,250,275,300,325,350,375,400,425,450,500,600};
	double widths[nPoints] = {
		3.48e-03, //115
3.48e-03,4.88e-03,8.14e-03,1.73e-02,8.30e-02,3.80e-01,6.31e-01,1.04e+00,1.43e+00, //120 -> 200
		4.04, 4.04, 4.04, 4.04e+00, //210 -> 250
		8.43, 8.43e+00,	8.43e+00, //300 and 325
		1.52e+01, 29.2, 2.92e+01, 46.95, 46.95, 6.80e+01, 1.23e+02};
	// R e a d   w o r k s p a c e   f r o m   f i l e
	// -----------------------------------------------
	
	double a_meanCB[nPoints], a_meanCB_err[nPoints];
	double a_sigmaCB[nPoints], a_sigmaCB_err[nPoints];
	double a_alphaCB[nPoints], a_alphaCB_err[nPoints];
	double a_nCB[nPoints], a_nCB_err[nPoints];
	double a_relsigma[nPoints], a_relsigma_err[nPoints];
	double a_relmean[nPoints], a_relmean_err[nPoints];

	double a_fitCovQual[nPoints];
	double a_fitEDM[nPoints];
	double a_fitStatus[nPoints];
		
	double a_param_meanCB[nPoints];
	double a_param_sigmaCB[nPoints];
	double a_param_alphaCB[nPoints];
	double a_param_nCB[nPoints];
	for (int i = 0; i < nPoints; i++){
		TString infile = "rootFiles/mH_"; infile+=mHVal[i]; infile+="_ggH.root";
			
		TFile *f = new TFile(infile) ;
		if(f==NULL) {cout<<" file is not exist "<<mHVal[i]<<" GEV"<<endl; exit(1);}
		cout<<"hi"<<endl;
		if(f->IsZombie()) continue;
		cout<<"hi"<<endl;
		
		double windowVal = max ( widths[i], 1. );
		double lowside = 100.;
		if (mHVal[i] > 300){ lowside = 200.; }
		else { lowside = 100.; }
		double low_M = max( (mHVal[i] - 15.*windowVal), lowside) ;
		double high_M = min( (mHVal[i] + 10.*windowVal), 900.) ;
		std::cout << "lowM = " << low_M << ", highM = " << high_M << std::endl;
			
		TTree * tree= (TTree*) f->Get("Ana/passedEvents");
		cout<<"hi"<<endl;

		if(tree==NULL) {cout<<" tree is not exist "<<mHVal[i]<<" GEV"<<endl; exit(1);}
		
		RooRealVar mass2e2mu("mass"+schannel,"mass"+schannel, low_M, high_M);
		mass2e2mu.setBins(100);
		RooDataSet *set2= new RooDataSet( "data","data", tree, RooArgSet(mass2e2mu) );
		RooDataHist *set= (RooDataHist*)set2->binnedClone("datahist","datahist");

		cout<<" 0 "<<endl;
		RooArgSet* obs = (RooArgSet*)set->get() ;
		obs->Print();
		RooRealVar* CMS_zz4l_mass = (RooRealVar*) obs->find("mass"+schannel) ;
		CMS_zz4l_mass->setRange(low_M,high_M);

		cout<<" 1 "<<endl;
		
		RooRealVar mH("mH","mH",mHVal[i],100.,1000.);
		mH.setConstant( kTRUE );

		RooRelBWUF RBW("RBW","RBW",*CMS_zz4l_mass,mH);

		cout<<" 2 "<<endl;

		double m = mHVal[i];
		double _DCBmean = -1.6;
		double _DCBn1 = 2;
		double _DCBsigma = 0;
		double _DCBalpha2 = 0;
		if(channel==2){ //4e
			 _DCBmean =  2.95517e-10 * pow(m, 4) -  1.57245e-07 * pow(m, 3) + 3.65384e-05*pow(m,2) - 0.00723547*m + 0.350264;
			 _DCBn1 = 4;
			 _DCBsigma = ( -1.44799e-10*m*m*m +  1.99184e-07*m*m -7.90901e-05*m + 0.0248625)*m;
			 _DCBalpha2 = 1.4;
		}
		if(channel==3){ //2e2mu
			 _DCBmean = 1.32637e-10 * pow(m,4) - 3.18803e-08 * pow(m,3) + 5.7852e-06 * pow(m,2) - 0.00558556 *m +  0.595935 ;
			 _DCBn1 = 3.1;
			 _DCBsigma = ( -2.84438e-10*m*m*m +  3.3396e-07*m*m - 9.96204e-05*m + 0.0221201 ) * m;
			 _DCBalpha2 = 1.5;
		}
		if(channel==1){ //4mu
			_DCBmean =   4.40431e-11*pow(m,4) +  9.18724e-08*m*m*m  -4.9034e-05*m*m +  0.00376756 *m + 0.0629559   ;
			_DCBn1 = 2;
			_DCBsigma = ( -2.58093e-10 *m*m*m + 3.3042e-07*m*m - 8.00048e-05*m + 0.0153993 )*m;
			_DCBalpha2 = 1.65;

		}

		cout<<" 3 "<<endl;

		RooRealVar DCBmean("DCBmean", "DCBmean", _DCBmean);//, -2, 20);
		RooRealVar DCBalpha1("DCBalpha1", "DCBalpha1", -2, -5., 0.);
		RooRealVar DCBalpha2("DCBalpha2", "DCBalpha2", _DCBalpha2, 0, 5);
		RooRealVar DCBsigma("DCBsigma", "DCBsigma",mHVal[i]*0.01, mHVal[i]*0.003, mHVal[i]*0.10);  
		RooRealVar DCBn1("DCBn1", "DCBn1", 100, 1, 200);
		RooRealVar DCBn2("DCBn2", "DCBn2", 1, 0.1, 5);
		RooRealVar DCBN("DCBN", "DCBN", 0.15);//, 0.1, 0.3);

		cout<<" 4 "<<endl;

		   //Single Sided Crytal Ball 
		   //
		   //
		   double _CBn = 0;
		   double _CBsigma = 0;
		   double _CBmean = 0;
		   double _CBalpha=0;


		   if(channel==2){//4e
			   // full range
			   _CBn =-8.93603e-08*m*m*m +0.000127189  *m*m -0.0622318 *m + 11.6926 ;
			   // upto 400
			   //_CBn = 6.67552e-05 *m*m -0.0521036*m +11.5366;

			   //full range 
			   _CBsigma = (1.12863e-08 *m*m -3.82425e-05 *m + 0.0211873 )*m;
			   // upto 400
			   //_CBsigma = (7.07645e-08*m*m -6.43001e-05*m + 0.0242935 ) *m;

			   _CBmean =  2.3924e-07 *m*m*m -0.000119008*m*m + 0.0196955*m -1.08406 ;
			   _CBalpha = 2.31779e-06*m*m -0.000364087*m + 0.73047;

			   //_CBalpha = 0.8;

		   }
		   if(channel==1){//4mu
			   _CBmean = 8.89217e-08 *m*m*m -1.91244e-05*m*m -0.00353969*m +  0.482443 ;	   
			   //full range 
			   _CBn = -0.00063219 *m + 1.72759 ;
			   // upto 400
			   //_CBn = -0.000451623 *m + 1.66747 ;

			   _CBalpha = -0.00129395*m + 1.49548;
			   // full range
			   _CBsigma = ( 2.35921e-11 *m*m*m + 1.07356e-07*m*m -3.34837e-05*m + 0.0125076 )*m;
			   // upto 400
			   //_CBsigma = (8.2331e-08  *m*m -1.99882e-05*m + 0.0111925)*m;
			   //_CBalpha = 1.2;
		   }
		   if(channel==3){//2e2mu
			   //full range 
			   _CBn = 4.15444e-06*m*m -0.00642982*m + 3.46673;
			   //upto 400
			   //_CBn = -0.00526889 *m + 3.47135;

			   _CBmean =1.17955e-07 *m*m*m -2.26571e-05*m*m -0.00409989 *m + 0.620462 ; 
			   // full range 
			   _CBsigma =(4.1737e-10*m*m*m -2.47734e-07*m*m + 3.17146e-05*m + 0.0127533)*m; 
			   // upto 400
			   //_CBsigma = (8.64361e-08*m*m -4.9537e-05*m +0.0185657 )*m;
			   _CBalpha = 1.0;
		   }
		   //_CBmean = 0;
		//cout<<"MINE: mH, CBsigma, err =  { "<<mHVal[i]<<" , "<<_CBsigma<<" }, "<<endl;
		//continue;

		a_param_nCB[i] = _CBn;
		a_param_sigmaCB[i] = _CBsigma/mHVal[i];
		a_param_meanCB[i] = _CBmean/mHVal[i];
		a_param_alphaCB[i] = _CBalpha;

		   //RooRealVar CBmean("CBmean",  	"CBmean"       	,mHVal[i], low_M, high_M);  // when fit only with CB
		   RooRealVar CBmean("CBmean",  	"CBmean"       	, _CBmean, -100, 100);    // when fit with  BW convoluted with CB

		  RooRealVar CBsigma("CBsigma",	"CBsigma"	, _CBsigma, mHVal[i]*0.003, mHVal[i]*0.05);   
		   RooRealVar CBalpha("CBalpha",	"CBalpha"	,_CBalpha, 0, 50);	
		   RooRealVar CBn("CBn",		"CBn"		, _CBn, 0, 50);        
		   RooCBShape massRes("cryBall1","Crystal Ball resolution model", *CMS_zz4l_mass, CBmean, CBsigma, CBalpha, CBn) ;


		RooFFTConvPdf sig_ggH("sig_ggH","sig_ggH",*CMS_zz4l_mass, RBW,massRes) ;
		sig_ggH.setBufferFraction(0.2);



		RooPlot* frameM4l = CMS_zz4l_mass->frame(Title("M4L"),Bins(100)) ;
		set->plotOn(frameM4l) ;
		if(mHVal[i]<1.60) {
			massRes.plotOn(frameM4l);
			massRes.paramOn(frameM4l);
		}else {
			sig_ggH.plotOn(frameM4l) ;
			//sig_ggH.paramOn(frameM4l);
		}
		TCanvas *c = new TCanvas("c","c",800,600);
		c->cd();
		TString sxtitle ;
		if(channel==1) sxtitle="m_{4#mu} (GeV/c^{2})";
		if(channel==2) sxtitle="m_{4e} (GeV/c^{2})";
		if(channel==3) sxtitle="m_{2e2#mu} (GeV/c^{2})";
		frameM4l->SetXTitle(sxtitle);
		frameM4l->Draw();
		char plotName[192];
		sprintf(plotName,"sigFigs/CB_%s_m%i_par.pdf",schannel.Data(),masses[i]);
		c->SaveAs(plotName);


		RooFitResult *r ;
		//RooFitResult *r = sig_ggH.fitTo( *set, Save(kTRUE), SumW2Error(kTRUE)) ;
		//if(mHVal[i]<1.60) r= massRes.fitTo( *set, Save(kTRUE)) ;
		//else 
		r=sig_ggH.fitTo(*set, Save(kTRUE));
		r->Print();

		a_fitEDM[i] = r->edm();
		a_fitCovQual[i] =  r->covQual();
		a_fitStatus[i] = r->status();

		// Plot Y
		RooPlot* frameM4l_2 = CMS_zz4l_mass->frame(Title("M4L"),Bins(100)) ;
		set->plotOn(frameM4l_2) ;
		if(mHVal[i]<1.60) {
			massRes.plotOn(frameM4l_2);
			massRes.paramOn(frameM4l_2);
		}else {
			sig_ggH.plotOn(frameM4l_2) ;
			//sig_ggH.paramOn(frameM4l_2);
		}
		frameM4l_2->SetXTitle(sxtitle);
		frameM4l_2->Draw();
		plotName[192];
		sprintf(plotName,"sigFigs/CB_%s_m%i.pdf",schannel.Data(),masses[i]);
		c->SaveAs(plotName);
		sprintf(plotName,"sigFigs/CB_%s_m%i.root",schannel.Data(),masses[i]);
		c->SaveAs(plotName);


		cout<<"MINE: mH, CBmean, err =  { "<<mHVal[i]<<" , "<<CBmean.getVal()<<" , "<<CBmean.getError()<<" },"<<endl;
		cout<<"MINE: mH, CBsigma, err =  { "<<mHVal[i]<<" , "<<CBsigma.getVal()<<" , "<<CBsigma.getError()<<" },"<<endl;
		cout<<"MINE: mH, CBalpha, err =  { "<<mHVal[i]<<" , "<<CBalpha.getVal()<<" , "<<CBalpha.getError()<<" },"<<endl;
		cout<<"MINE: mH, CBn, err =  { "<<mHVal[i]<<" , "<<CBn.getVal()<<" , "<<CBn.getError()<<" },"<<endl;
		a_meanCB[i] = CBmean.getVal(); a_meanCB_err[i] = CBmean.getError();
		a_sigmaCB[i] = CBsigma.getVal(); a_sigmaCB_err[i] = CBsigma.getError();
		a_alphaCB[i] = CBalpha.getVal(); a_alphaCB_err[i] = CBalpha.getError();
		a_nCB[i] = CBn.getVal(); a_nCB_err[i] = CBn.getError();
		a_relsigma[i]=CBsigma.getVal()/mHVal[i]; a_relsigma_err[i]=CBsigma.getError()/mHVal[i];
		a_relmean[i]=CBmean.getVal()/mHVal[i]; a_relmean_err[i]=CBmean.getError()/mHVal[i];
	}

	TGraphErrors* gr_meanCB = new TGraphErrors( nPoints, mHVal, a_meanCB, 0, a_meanCB_err );
	TGraphErrors* gr_sigmaCB = new TGraphErrors( nPoints, mHVal, a_sigmaCB, 0, a_sigmaCB_err );
	TGraphErrors* gr_alphaCB = new TGraphErrors( nPoints, mHVal, a_alphaCB, 0, a_alphaCB_err );
	TGraphErrors* gr_nCB = new TGraphErrors( nPoints, mHVal, a_nCB, 0, a_nCB_err );
	TGraphErrors* gr_relsigma = new TGraphErrors( nPoints, mHVal, a_relsigma, 0, a_relsigma_err );
	TGraphErrors* gr_relmean = new TGraphErrors( nPoints, mHVal, a_relmean, 0, a_relmean_err );

	TGraph* gr_param_meanCB = new TGraph( nPoints, mHVal, a_param_meanCB);
	TGraph* gr_param_sigmaCB = new TGraph( nPoints, mHVal, a_param_sigmaCB);
	TGraph* gr_param_alphaCB = new TGraph( nPoints, mHVal, a_param_alphaCB);
	TGraph* gr_param_nCB = new TGraph( nPoints, mHVal, a_param_nCB);

	TGraph *gr_fitEDM = new TGraph(nPoints, mHVal, a_fitEDM);
	TGraph *gr_fitCovQual = new TGraph(nPoints, mHVal, a_fitCovQual);
	TGraph *gr_fitStatus = new TGraph(nPoints, mHVal, a_fitStatus);

	TCanvas *c = new TCanvas("c","c",1200,800);
	c->Divide(3,3);
	c->cd(1);
	gr_relmean->Draw("ap");
	gr_relmean->SetMarkerStyle(20);
	gr_relmean->GetXaxis()->SetTitle("CrystalBall mean / m_{H}, "+schannel);
	gr_relmean->SetTitle();
	gr_param_meanCB->Draw("c");
	c->cd(2);
	gr_relsigma->Draw("ap");
	gr_relsigma->SetMarkerStyle(20);
	gr_relsigma->GetXaxis()->SetTitle("CrystalBall sigma / m_{H}, "+schannel);
	gr_relsigma->SetTitle();
	gr_param_sigmaCB->Draw("c");
	c->cd(3);
	gr_alphaCB->Draw("ap");
	gr_alphaCB->SetMarkerStyle(20);
	gr_alphaCB->GetXaxis()->SetTitle("CrystalBall #alpha, "+schannel);
	gr_alphaCB->SetTitle();
	gr_param_alphaCB->Draw("c");
	c->cd(4);
	gr_nCB->Draw("ap");
	gr_nCB->SetMarkerStyle(20);
	gr_nCB->GetXaxis()->SetTitle("CrystalBall n, "+schannel);
	gr_nCB->SetTitle();
	gr_param_nCB->Draw("c");
	c->cd(5);
	gr_fitEDM->Draw("ap");
	gr_fitEDM->SetMarkerStyle(20);
	gr_fitEDM->GetXaxis()->SetTitle("fit Estimated Distance to Minimum");
	c->cd(5)->SetLogy();
	c->cd(6);
	gr_fitCovQual->Draw("ap");
	gr_fitCovQual->SetMarkerStyle(20);
	gr_fitCovQual->GetXaxis()->SetTitle("Quality of Convariance Matrix from Minuit Fit ");
	c->cd(7);
	gr_fitStatus->Draw("ap");
	gr_fitStatus->SetMarkerStyle(20);
	gr_fitStatus->GetXaxis()->SetTitle("Status of Minuit Fit ");

	TString sparams = "sigFigs/paramsCB_";
 	sparams+=schannel; 
 	c->SaveAs(sparams+".gif");
 	c->SaveAs(sparams+".root");
 	c->SaveAs(sparams+".pdf");


	TFile ftmp(sparams+".root", "UPDATE");
	gr_meanCB->SetName("meanCB");
	gr_sigmaCB->SetName("sigmaCB");
	gr_alphaCB->SetName("alphaCB");
	gr_nCB->SetName("nCB");
	gr_relsigma->SetName("relsigma");
	gr_relmean->SetName("relmean");
	ftmp.WriteTObject(gr_meanCB);
	ftmp.WriteTObject(gr_sigmaCB);
	ftmp.WriteTObject(gr_alphaCB);
	ftmp.WriteTObject(gr_nCB);
	ftmp.WriteTObject(gr_relsigma);
	ftmp.WriteTObject(gr_relmean);



	TCanvas *c1=new TCanvas("c1","c1",800,600);
	c1->SetGrid();
	gr_relmean->Draw("ap");
	gr_relmean->SetMinimum(-0.005);
	gr_relmean->SetMaximum(0.045);
//	gr_relmean->SetMarkerStyle(1);
	gr_param_meanCB->Draw("c");
	gr_relmean->SetMarkerSize(2);
	gr_param_meanCB->SetLineWidth(3);
	gr_param_meanCB->SetLineColor(kRed);
	c1->SaveAs(sparams+"_relmean.pdf");
	c1->SaveAs(sparams+"_relmean.root");
	TCanvas *c2=new TCanvas("c2","c2",800,600);
	c2->SetGrid();
	gr_relsigma->Draw("ap");
//	gr_relsigma->SetMarkerStyle(1);
	gr_relsigma->SetMinimum(0);
	gr_relsigma->SetMaximum(0.06);
	gr_param_sigmaCB->Draw("c");
	gr_relsigma->SetMarkerSize(2);
	gr_param_sigmaCB->SetLineWidth(3);
	gr_param_sigmaCB->SetLineColor(kRed);
	c2->SaveAs(sparams+"_relsigma.pdf");
	c2->SaveAs(sparams+"_relsigma.root");
	TCanvas *c3=new TCanvas("c3","c3",800,600);
	c3->SetGrid();
	gr_alphaCB->Draw("ap");
	gr_alphaCB->SetMinimum(0.2);
	gr_alphaCB->SetMaximum(2.5);
//	gr_alphaCB->SetMarkerStyle(1);
	gr_param_alphaCB->Draw("c");
	gr_alphaCB->SetMarkerSize(2);
	gr_param_alphaCB->SetLineWidth(3);
	gr_param_alphaCB->SetLineColor(kRed);
	c3->SaveAs(sparams+"_alphaCB.pdf");
	c3->SaveAs(sparams+"_alphaCB.root");
	TCanvas *c4=new TCanvas("c4","c4",800,600);
	c4->SetGrid();
	gr_nCB->Draw("ap");
	gr_nCB->SetMinimum(0.0);
	gr_nCB->SetMaximum(12.0);
//	gr_nCB->SetMarkerStyle(1);
	gr_param_nCB->Draw("c");
	gr_nCB->SetMarkerSize(2);
	gr_param_nCB->SetLineWidth(3);
	gr_param_nCB->SetLineColor(kRed);
	c4->SaveAs(sparams+"_nCB.pdf");
	c4->SaveAs(sparams+"_nCB.root");
}

